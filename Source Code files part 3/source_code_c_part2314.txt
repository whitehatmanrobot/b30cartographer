            = 0x00000008,

        // Win2k will often stomp all over our buffer when we're not in a BeginScene/EndScene.
        // For apps where this is a problem, we give the application write access to the normal
        // buffer when it sends us an EndScene.
        APPFLAGS_WRITE_ACCESS_ON_ENDSCENE  = 0x00000010,

        // Normally, we will blit to either the super or normal buffer, depending on
        // which one is valid.  Some apps don't like it when we blit to the superbuffer.
        // In these cases, always downscale the buffer before blitting.
        APPFLAGS_DOWNSAMPLE_ON_BLIT        = 0x00000020,

        // Z compression doesn't always work right when we're upscaling/downscaling
        // the Z buffer.  Force compression off if it's causing problems.
        APPFLAGS_FORCE_UNCOMPRESSED_Z      = 0x00000040
    };
    
    typedef enum NotificationType {
        NOTIFY_FULL_SCREEN_COLOR_CLEAR,
    };

    static const char * BufferTypeNames[];
    static const char * AccessTypeNames[];
    
    typedef enum BufferFlags {
        FLAGS_VALID  = 0x00000001,  // Contains valid data
    };

    // Public members
    CKelvinAAState();

    void SetSampleMask();

    void TestCreation(PNVD3DCONTEXT);
    void Create(PNVD3DCONTEXT);
    void Destroy();
    void Suspend();
    void Resume();
    void Refresh();
    void Flip();
    void Notify(NotificationType);
    void ReCreateZBuffer();
    void TagBadSemantics() { _badSemantics = true; }
    void EndScene();
    bool IsValid(BufferType buffer) { return (_bufferInfo[buffer].flags & FLAGS_VALID); }

    void Save();
    void Restore();
    void SetChanged() { _bAAMethodChanged = true; }

    void UpdateZBuffer();
    void UpdateRenderTarget();

    float GetXOffset() { return _appCompatibility.fXOffset; }
    float GetYOffset() { return _appCompatibility.fYOffset; }

    void TagSeen3D() { _seen3D = 1; }

    CSimpleSurface * GetSRT() { return _bufferInfo[BUFFER_SRT].pSurface; }
    CSimpleSurface * GetSZB() { return _bufferInfo[BUFFER_SZB].pSurface; }

    CSimpleSurface * GetCurrentRT(PNVD3DCONTEXT);
    CSimpleSurface * GetCurrentZB(PNVD3DCONTEXT);

    DWORD GetAAFormat();
    DWORD GetWidthScale() { return BufferBltInfo[MethodInfo[_method].type].dwSuperBufferScaleX; }
    DWORD GetHeightScale() { return BufferBltInfo[MethodInfo[_method].type].dwSuperBufferScaleY; }
    
    int IsEnabled();
    int IsCreated();
    int IsMultisampling();
    int IsSupersampling();

    bool CompatibilityMode(AppCompatibilityFlags flags) { return ((_appCompatibility.dwFlags & flags) ? true : false); }
    bool IsMixedModeAA() { return _MixedModeAA; }
    static bool CheckBufferMemoryConfig(PNVD3DCONTEXT);

    void GrantAccess(BufferType, AccessType, bool = false, bool = false);

    static PNVD3DCONTEXT GetContext(CSimpleSurface *);

private:
    // Private enums
    typedef enum MethodType {
        METHOD_NONE                         = 0,
        METHOD_SUPERSAMPLE_2X_H             = 1,
        METHOD_SUPERSAMPLE_2X_V             = 2,
        METHOD_MULTISAMPLE_2X               = 3,
        METHOD_MULTISAMPLE_2X_QUINCUNX      = 4,
        METHOD_SUPERSAMPLE_4X_BIAS          = 5,
        METHOD_SUPERSAMPLE_4X               = 6,
        METHOD_SUPERSAMPLE_4X_GAUSSIAN      = 7,
        METHOD_MULTISAMPLE_4X               = 8,
        METHOD_MULTISAMPLE_4X_GAUSSIAN      = 9,
        METHOD_MULTISAMPLE_4X_ROTATED_4TAP  = 10,   
        METHOD_MULTISAMPLE_4X_ROTATED_8TAP  = 11,
        METHOD_SUPERSAMPLE_9X_BIAS          = 12,   // Not used yet
        METHOD_SUPERSAMPLE_9X               = 13,   // Not used yet
        METHOD_SUPERSAMPLE_16X_BIAS         = 14,   // Not used yet
        METHOD_SUPERSAMPLE_16X              = 15,   // Not used yet
        METHOD_MAX                          = 16
    };

    typedef enum SimpleMethodType {
        SIMPLEMETHOD_1X1 = 0,
        SIMPLEMETHOD_1X2 = 1,
        SIMPLEMETHOD_2X1 = 2,
        SIMPLEMETHOD_2X2 = 3,
        SIMPLEMETHOD_3X3 = 4,
        SIMPLEMETHOD_4X4 = 5,
        SIMPLEMETHOD_MAX = 6,
    };

    // Private structs
    struct BufferInfo {
        DWORD flags;
        BufferType other;
        CSimpleSurface *pSurface;
    } _bufferInfo[BUFFER_MAX];

    struct MethodInfoStruct {
        bool  bMultisample;
        float fBias;
        float fLinePointSize;
        SimpleMethodType type;
        DWORD AASurfaceType;
        DWORD dwKernel;
        DWORD dwBoxFilteredAlternative;
        DWORD dwSuperSampledAlternative;
    };

    struct BufferBltInfoStruct {
        DWORD   dwSuperBufferScaleX;
        DWORD   dwSuperBufferScaleY;

        DWORD   dwScratchBufferScaleX;
        DWORD   dwScratchBufferScaleY;

        double  fDownscaleOffsetX1;
        double  fDownscaleOffsetY1;
        double  fDownscaleOffsetX2;
        double  fDownscaleOffsetY2;

        double  fUpscaleOffsetX;
        double  fUpscaleOffsetY;
    };


    // break filter into strips
    struct  stripinfo {
        DF x0, y0;
        DF _x0;
        DWORD remainder;
        DWORD num_strips;
        DWORD stripsize;
        DF srcyinc;
        DF srcyrem;
        DF dstyinc;
        DF dstyrem;
        DF srcWidth;
        DF srcWidth_x0;
        DF dstWidth;
        DWORD swath;
    } _strip;

    // Private methods
    void ScaledBlt(BufferType, BufferType, bool, bool);
    void ScaledBlt(CSimpleSurface *, DWORD, DWORD, DWORD, DWORD, CSimpleSurface *, double, double, DWORD, DWORD);

    void ImageModeTexBlt(CSimpleSurface *, CSimpleSurface *, DWORD, bool, bool, bool);

    bool InGrantAccess() { return _bInGrantAccess; }
    void EnterGrantAccess() { _bInGrantAccess = true; }
    void ExitGrantAccess() { _bInGrantAccess = false; }

    void InitAppCompatibility();

    // Private members
    PNVD3DCONTEXT _pContext;
    bool _enabled;
    bool _seen3D;
    bool _MixedModeAA;
    bool _invalidRT;
    bool _badSemantics;
    bool _didUpsample;
    bool _lastDownsampleUsedConvolution;
    bool _bSubdivideAA;
    bool _bSubdivideAASave;
    bool _bAAMethodChanged;
    bool _bInitializedState;
    bool _bInGrantAccess;
    DWORD _sampleMask;
    DWORD _method;
    DWORD _methodSave;
    DWORD _numUpsamplings;
    DWORD _UpsampleFlip;
    DWORD _numZLocks;
    KELVIN_MICRO_PROGRAM _program;

    struct AppCompatibilityStruct {
        uint64 qwHashVal;
        DWORD dwFlags;
        float fXOffset, fYOffset;
    } _appCompatibility;

    CSimpleSurface *_flipChain[KELVIN_AA_NUM_FLIP_CHAIN_SLOTS]; // potentially they could have a huge flip chain; in reality it'll be 2 or 3


    static const MethodInfoStruct MethodInfo[METHOD_MAX];
    static const BufferBltInfoStruct BufferBltInfo[SIMPLEMETHOD_MAX];
    static const MethodType RegQualityToAATypeMapping[10];

    void SetMethod(MethodType);
};

#endif // NVARCH >= 0x020

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\kelvin\inc\nvKelvinProgram.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvKelvinProgram.h
//      Kelvin program header file
//
// **************************************************************************
//
//  History:
//      Craig Duttweiler        23May2000         NV20 development
//
// **************************************************************************

#ifndef _NVKELVINPROGRAM_H
#define _NVKELVINPROGRAM_H

#if (NVARCH >= 0x020)

#include "vtxpgmconsts.h"
#include "vtxpgmcomp.h"


// #define MAX_PROGRAM_COUNT             128
// #define GL_EXECUTE_PROGRAM           0x88888888
// #define GL_DRIVER_EXECUTE_PROGRAM    0x88888889

#define SET_ILU(pucode,x) (pucode->ilu = (x)&7)     /* cycle 0.. */
#define SET_MAC(pucode,x) (pucode->mac = (x)&15)    /* cycle 01. */
#define SET_CA(pucode,x)  (pucode->ca  = (x)&255)   /* cycle 0.2 */
#define SET_VA(pucode,x)  (pucode->va  = (x)&15)    /* cycle 0.. */

#define SET_AMX(pucode,x) (pucode->amx = (x)&3)     /* cycle 0.. */
#define SET_ARR(pucode,x) (pucode->arr = (x)&15)    /* cycle 0.. */
#define SET_ANE(pucode,x) (pucode->ane = (x)&1)     /* cycle 0.. */
#define SET_AXS(pucode,x) (pucode->axs = (x)&3)     /* cycle 0.. */
#define SET_AYS(pucode,x) (pucode->ays = (x)&3)     /* cycle 0.. */
#define SET_AZS(pucode,x) (pucode->azs = (x)&3)     /* cycle 0.. */
#define SET_AWS(pucode,x) (pucode->aws = (x)&3)     /* cycle 0.. */

#define SET_BMX(pucode,x) (pucode->bmx = (x)&3)     /* cycle 0.. */
#define SET_BRR(pucode,x) (pucode->brr = (x)&15)    /* cycle 0.. */
#define SET_BNE(pucode,x) (pucode->bne = (x)&1)     /* cycle 0.. */
#define SET_BXS(pucode,x) (pucode->bxs = (x)&3)     /* cycle 0.. */
#define SET_BYS(pucode,x) (pucode->bys = (x)&3)     /* cycle 0.. */
#define SET_BZS(pucode,x) (pucode->bzs = (x)&3)     /* cycle 0.. */
#define SET_BWS(pucode,x) (pucode->bws = (x)&3)     /* cycle 0.. */

#define SET_CMX(pucode,x) (pucode->cmx = (x)&3)     /* cycle 0.. */
#define SET_CRR(pucode,x) (pucode->crr = (x)&15)    /* cycle 0.. */
#define SET_CNE(pucode,x) (pucode->cne = (x)&1)     /* cycle 0.. */
#define SET_CXS(pucode,x) (pucode->cxs = (x)&3)     /* cycle 0.. */
#define SET_CYS(pucode,x) (pucode->cys = (x)&3)     /* cycle 0.. */
#define SET_CZS(pucode,x) (pucode->czs = (x)&3)     /* cycle 0.. */
#define SET_CWS(pucode,x) (pucode->cws = (x)&3)     /* cycle 0.. */

#define SET_RWM(pucode,x) (pucode->rwm = (x)&15)    /* cycle ..2 */
#define SET_RW(pucode,x)  (pucode->rw  = (x)&15)    /* cycle ..2 */
#define SET_SWM(pucode,x) (pucode->swm = (x)&15)    /* cycle ..2 */
#define SET_OWM(pucode,x) (pucode->owm = (x)&15)    /* cycle ..2 */
#define SET_OC(pucode,x)  (pucode->oc  = (x)&511)   /* cycle ..2 */
#define SET_OM(pucode,x)  (pucode->om  = (x)&1)     /* cycle ..2 */
#define SET_CIN(pucode,x) (pucode->cin = (x)&1)     /* cycle 0.. */
#define SET_EOS(pucode,x) (pucode->eos = (x)&1)     /* cycle 0.. */

#define PGM_UWORDW(pucode) ((pucode->eos << 0) |\
                            (pucode->cin << 1) |\
                            (pucode->om  << 2) |\
                            (pucode->oc  << 3) |\
                            (pucode->owm <<12) |\
                            (pucode->swm <<16) |\
                            (pucode->rw  <<20) |\
                            (pucode->rwm <<24) |\
                            (pucode->cmx <<28) |\
                            (pucode->crr <<30))

#define PGM_UWORDZ(pucode) ((pucode->crr >> 2) |\
                            (pucode->cws << 2) |\
                            (pucode->czs << 4) |\
                            (pucode->cys << 6) |\
                            (pucode->cxs << 8) |\
                            (pucode->cne <<10) |\
                            (pucode->bmx <<11) |\
                            (pucode->brr <<13) |\
                            (pucode->bws <<17) |\
                            (pucode->bzs <<19) |\
                            (pucode->bys <<21) |\
                            (pucode->bxs <<23) |\
                            (pucode->bne <<25) |\
                            (pucode->amx <<26) |\
                            (pucode->arr <<28))

#define PGM_UWORDY(pucode) ((pucode->aws << 0) |\
                            (pucode->azs << 2) |\
                            (pucode->ays << 4) |\
                            (pucode->axs << 6) |\
                            (pucode->ane << 8) |\
                            (pucode->va  << 9) |\
                            (pucode->ca  <<13) |\
                            (pucode->mac <<21) |\
                            (pucode->ilu <<25))

#define PGM_UWORDX(pucode) 0

#define ADD_MASK  (0x0000ff)
#define MUX_MASK  (0x000300)
#define SWZ_MASK  (0x0ff000)
#define SGN_MASK  (0x100000)
#define IDX_MASK  (0x200000)
#define DST_MASK  (0x400000)

#define NV_IGRAPH_XF_V_NOP        0x00
#define NV_IGRAPH_XF_V_MOV        0x01
#define NV_IGRAPH_XF_V_MUL        0x02
#define NV_IGRAPH_XF_V_ADD        0x03
#define NV_IGRAPH_XF_V_MAD        0x04
#define NV_IGRAPH_XF_V_DP3        0x05
#define NV_IGRAPH_XF_V_DPH        0x06
#define NV_IGRAPH_XF_V_DP4        0x07
#define NV_IGRAPH_XF_V_DST        0x08
#define NV_IGRAPH_XF_V_MIN        0x09
#define NV_IGRAPH_XF_V_MAX        0x0a
#define NV_IGRAPH_XF_V_SLT        0x0b
#define NV_IGRAPH_XF_V_SGE        0x0c
#define NV_IGRAPH_XF_V_ARL        0x0d

#define NV_IGRAPH_XF_S_NOP        0x00
#define NV_IGRAPH_XF_S_MOV        0x01
#define NV_IGRAPH_XF_S_RCP        0x02
#define NV_IGRAPH_XF_S_RCC        0x03
#define NV_IGRAPH_XF_S_RSQ        0x04
#define NV_IGRAPH_XF_S_EXP        0x05
#define NV_IGRAPH_XF_S_LOG        0x06
#define NV_IGRAPH_XF_S_LIT        0x07

#define CSW_X                     0x00  // take swizzled source from x
#define CSW_Y                     0x01  // ...from y
#define CSW_Z                     0x02  // ...from z
#define CSW_W                     0x03  // ...from w

#define MX_M                      0     // mux select
#define MX_R                      1     // mux select scratch (a.k.a. temporary) register
#define MX_V                      2     // mux select input (a.k.a. vertex attribute) register
#define MX_C                      3     // mux select context (a.k.a. parameter/constant) register
#define MX_O                      MX_M

#define OM_MAC                    0x00  // output mux selects value produced by MLU/ALU
#define OM_ILU                    0x01  // output mux selects value produced by ILU

typedef struct _t_CheopsUcode {
    unsigned long eos:1;        /* 0:00 last instruction */
    unsigned long cin:1;        /* 0:01 ctx indexed address */
    unsigned long  om:1;        /* 0:02 output mux */
    unsigned long  oc:9;        /* 0:03 output write control */
    unsigned long owm:4;        /* 0:12 output write mask */
    unsigned long swm:4;        /* 0:16 secondary register write mask */
    unsigned long  rw:4;        /* 0:20 register write */
    unsigned long rwm:4;        /* 0:24 primary register write mask */
    unsigned long cmx:2;        /* 0:28 c mux (NA,r1,v,c) */
    unsigned long crr:4;        /* 0:30 c register read */
    unsigned long cws:2;        /* 1:02 c w swizzle */
    unsigned long czs:2;        /* 1:04 c z swizzle */
    unsigned long cys:2;        /* 1:06 c y swizzle */
    unsigned long cxs:2;        /* 1:08 c x swizzle */
    unsigned long cne:1;        /* 1:10 c negate */
    unsigned long bmx:2;        /* 1:11 b mux (NA,r1,v,c) */
    unsigned long brr:4;        /* 1:13 b register read */
    unsigned long bws:2;        /* 1:17 b w swizzle */
    unsigned long bzs:2;        /* 1:19 b z swizzle */
    unsigned long bys:2;        /* 1:21 b y swizzle */
    unsigned long bxs:2;        /* 1:23 b x swizzle */
    unsigned long bne:1;        /* 1:25 b negate */
    unsigned long amx:2;        /* 1:26 a mux (NA,r0,v,c) */
    unsigned long arr:4;        /* 1:28 a register read */
    unsigned long aws:2;        /* 2:00 a w swizzle */
    unsigned long azs:2;        /* 2:02 a z swizzle */
    unsigned long ays:2;        /* 2:04 a y swizzle */
    unsigned long axs:2;        /* 2:06 a x swizzle */
    unsigned long ane:1;        /* 2:08 a negate */
    unsigned long  va:4;        /* 2:09 ibuffer address */
    unsigned long  ca:8;        /* 2:13 ctx address */
    unsigned long mac:4;        /* 2:21 MLU/ALU op */
    unsigned long ilu:3;        /* 2:25 ILU op */
} t_CheopsUcode;

// a program that's been fully compiled and assembled into kelvin microcode
typedef struct _KELVIN_MICRO_PROGRAM {
    //GLuint nid;
    //long pType;
    long ctxwri;
    long outwri;
    long length;
    //long stadd;
    //long bound;
    //long loaded;
    //float x,y,z,w;
    t_CheopsUcode ucode[136];
} KELVIN_MICRO_PROGRAM, *PKELVIN_MICRO_PROGRAM;

// a compiled program in the intermediate format between a D3D token stream and microcode
typedef struct _KELVIN_PROGRAM {
    Instruction code[136];
    DWORD dwNumInstructions;
} KELVIN_PROGRAM, *PKELVIN_PROGRAM;


// prototypes
void nvKelvinInitProgram           (PKELVIN_MICRO_PROGRAM pProgram);
void nvKelvinParseProgram          (PKELVIN_MICRO_PROGRAM pProgram, char *s);
void nvKelvinDownloadProgram       (PNVD3DCONTEXT pContext, PKELVIN_MICRO_PROGRAM pProgram,DWORD dwStartAddress);
void nvKelvinDownloadProgram       (PNVD3DCONTEXT pContext, VertexProgramOutput *pProgramOutput, DWORD dwStartAddress);
void nvKelvinDownloadConstants     (PNVD3DCONTEXT pContext);
void nvKelvinParseVertexShaderCode (PKELVIN_PROGRAM pProgram, ParsedProgram* parsed, DWORD *pCode, DWORD dwCodeSize);


#ifdef KPFS
class CVertexShader;

class CKelvinProgramMan {
    
    class CInstr {
    public:
        CInstr *next;
        DWORD len;    
        DWORD handle; 
        DWORD index;  
    };
    
    PNVD3DCONTEXT m_pContext, m_pPrevContext;
    DWORD m_dwInstructions;
    DWORD m_dwOffset;
    DWORD m_dwLastHandle;
    DWORD m_dwDirty;
    CInstr* ins; 
    
    void add (DWORD handle, DWORD num_instr);
    bool find(DWORD handle, DWORD num_instr);
    
    public:
        
        CKelvinProgramMan()  {};
        ~CKelvinProgramMan() {};
        
        void create(DWORD);
        void destroy();
        void flush();
        void download(PNVD3DCONTEXT pContext, CVertexShader* pVertexShader);
        void download_special(PNVD3DCONTEXT pContext, PKELVIN_MICRO_PROGRAM pProgram, DWORD handle);
        void display();
        inline void dirty() {m_dwDirty=1;}
};
#endif 

#endif  // NVARCH >= 0x020

#endif  // _NVKELVINPROGRAM_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\kelvin\inc\nvKelvinCaps.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
// Module: nvKelvinCaps.h
//      Define the capabilities of the kelvin D3D driver.
//
// **************************************************************************
//
// History:
//      Craig Duttweiler    bertrem     26Apr2000     created
//
// **************************************************************************

#ifndef _NVKELVINCAPS_H_
#define _NVKELVINCAPS_H_

#if (NVARCH >= 0x020)

// --------------------------------------------------------------------------
//  Direct 3D HAL Capabilities
// --------------------------------------------------------------------------

// Define which fields of the D3DDEVICECAPS structure are valid.
#define KELVIN_DEVDESC_FLAGS            D3DDD_COLORMODEL                    |   \
                                        D3DDD_DEVCAPS                       |   \
                                        D3DDD_LINECAPS                      |   \
                                        D3DDD_TRICAPS                       |   \
                                        D3DDD_DEVICERENDERBITDEPTH          |   \
                                        D3DDD_DEVICEZBUFFERBITDEPTH

// Define the color model for the D3D driver.
#define KELVIN_COLORMODEL               D3DCOLOR_RGB

// Define the device capabilities.
#define KELVIN_DEVCAPS_FLAGS            D3DDEVCAPS_FLOATTLVERTEX            |   \
                                        D3DDEVCAPS_EXECUTESYSTEMMEMORY      |   \
                                        D3DDEVCAPS_EXECUTEVIDEOMEMORY       |   \
                                        D3DDEVCAPS_TLVERTEXSYSTEMMEMORY     |   \
                                        D3DDEVCAPS_TLVERTEXVIDEOMEMORY      |   \
                                        D3DDEVCAPS_TEXTUREVIDEOMEMORY       |   \
                                        D3DDEVCAPS_DRAWPRIMTLVERTEX         |   \
                                        D3DDEVCAPS_CANRENDERAFTERFLIP       |   \
                                        D3DDEVCAPS_TEXTURENONLOCALVIDMEM    |   \
                                        D3DDEVCAPS_DRAWPRIMITIVES2          |   \
                                        D3DDEVCAPS_DRAWPRIMITIVES2EX        |   \
                                        D3DDEVCAPS_HWTRANSFORMANDLIGHT      |   \
                                        D3DDEVCAPS_CANBLTSYSTONONLOCAL      |   \
                                        D3DDEVCAPS_PUREDEVICE               |   \
                                        D3DDEVCAPS_QUINTICRTPATCHES         |   \
                                        D3DDEVCAPS_RTPATCHES                |   \
                                        D3DDEVCAPS_HWVERTEXBUFFER           |   \
                                        D3DDEVCAPS_HWINDEXBUFFER            |   \
                                        D3DDEVCAPS_HWRASTERIZATION

// Define the transformation capabilities.
#define KELVIN_TRANSFORMCAPS_FLAGS      D3DTRANSFORMCAPS_CLIP

// Define 3D clipping capabilities.
#define KELVIN_3DCLIPPINGCAPS           TRUE

// Define the lighting capabilities.
#define KELVIN_LIGHTINGCAPS_FLAGS       D3DLIGHTINGMODEL_RGB                |   \
                                        D3DLIGHTCAPS_POINT                  |   \
                                        D3DLIGHTCAPS_SPOT                   |   \
                                        D3DLIGHTCAPS_DIRECTIONAL
#define KELVIN_MAX_LIGHTS               8

// Define NULL primary capabilities.
#define KELVIN_PRIMCAPS_NULL            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

// Define the line capabilities.
//
// Miscellaneous capabilities (dwMiscCaps)
#define KELVIN_LINECAPS_MISC            D3DPMISCCAPS_MASKZ                  |   \
                                        D3DPMISCCAPS_CULLNONE               |   \
                                        D3DPMISCCAPS_CULLCW                 |   \
                                        D3DPMISCCAPS_CULLCCW                |   \
                                        D3DPMISCCAPS_BLENDOP                |   \
                                        D3DPMISCCAPS_COLORWRITEENABLE       |   \
                                        D3DPMISCCAPS_TSSARGTEMP

// Raster capabilities (dwRasterCaps)
#define KELVIN_LINECAPS_RASTER          D3DPRASTERCAPS_DITHER                   |   \
                                        D3DPRASTERCAPS_SUBPIXEL                 |   \
                                        D3DPRASTERCAPS_FOGVERTEX                |   \
                                        D3DPRASTERCAPS_FOGTABLE                 |   \
                                        D3DPRASTERCAPS_MIPMAPLODBIAS            |   \
                                        D3DPRASTERCAPS_ZBIAS                    |   \
                                        D3DPRASTERCAPS_FOGRANGE                 |   \
                                        D3DPRASTERCAPS_WBUFFER                  |   \
                                        D3DPRASTERCAPS_WFOG                     |   \
                                        D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT |   \
                                        D3DPRASTERCAPS_STRETCHBLTMULTISAMPLE    |   \
                                        D3DPRASTERCAPS_ANISOTROPY               |   \
                                        D3DPRASTERCAPS_ZFOG

// Z Compare capabilities (dwZCmpCaps)
#define KELVIN_LINECAPS_ZCMP            D3DPCMPCAPS_NEVER                   |   \
                                        D3DPCMPCAPS_LESS                    |   \
                                        D3DPCMPCAPS_EQUAL                   |   \
                                        D3DPCMPCAPS_LESSEQUAL               |   \
                                        D3DPCMPCAPS_GREATER                 |   \
                                        D3DPCMPCAPS_NOTEQUAL                |   \
                                        D3DPCMPCAPS_GREATEREQUAL            |   \
                                        D3DPCMPCAPS_ALWAYS

// Source blend capabilities (dwSrcBlendCaps)
#define KELVIN_LINECAPS_SRCBLEND        D3DPBLENDCAPS_ZERO                  |   \
                                        D3DPBLENDCAPS_ONE                   |   \
                                        D3DPBLENDCAPS_SRCCOLOR              |   \
                                        D3DPBLENDCAPS_INVSRCCOLOR           |   \
                                        D3DPBLENDCAPS_SRCALPHA              |   \
                                        D3DPBLENDCAPS_INVSRCALPHA           |   \
                                        D3DPBLENDCAPS_DESTALPHA             |   \
                                        D3DPBLENDCAPS_INVDESTALPHA          |   \
                                        D3DPBLENDCAPS_DESTCOLOR             |   \
                                        D3DPBLENDCAPS_INVDESTCOLOR          |   \
                                        D3DPBLENDCAPS_SRCALPHASAT           |   \
                                        D3DPBLENDCAPS_BOTHSRCALPHA          |   \
                                        D3DPBLENDCAPS_BOTHINVSRCALPHA

// Destination blend capabilities (dwDestBlendCaps)
#define KELVIN_LINECAPS_DESTBLEND       D3DPBLENDCAPS_ZERO                  |   \
                                        D3DPBLENDCAPS_ONE                   |   \
                                        D3DPBLENDCAPS_SRCCOLOR              |   \
                                        D3DPBLENDCAPS_INVSRCCOLOR           |   \
                                        D3DPBLENDCAPS_SRCALPHA              |   \
                                        D3DPBLENDCAPS_INVSRCALPHA           |   \
                                        D3DPBLENDCAPS_DESTALPHA             |   \
                                        D3DPBLENDCAPS_INVDESTALPHA          |   \
                                        D3DPBLENDCAPS_DESTCOLOR             |   \
                                        D3DPBLENDCAPS_INVDESTCOLOR          |   \
                                        D3DPBLENDCAPS_SRCALPHASAT           |   \
                                        D3DPBLENDCAPS_BOTHSRCALPHA          |   \
                                        D3DPBLENDCAPS_BOTHINVSRCALPHA

// Alpha compare capabilities (dwAlphaCmpCaps)
#define KELVIN_LINECAPS_ALPHACMP        D3DPCMPCAPS_NEVER                   |   \
                                        D3DPCMPCAPS_LESS                    |   \
                                        D3DPCMPCAPS_EQUAL                   |   \
                                        D3DPCMPCAPS_LESSEQUAL               |   \
                                        D3DPCMPCAPS_GREATER                 |   \
                                        D3DPCMPCAPS_NOTEQUAL                |   \
                                        D3DPCMPCAPS_GREATEREQUAL            |   \
                                        D3DPCMPCAPS_ALWAYS

// Shading capabilities (dwShadeCaps)
#define KELVIN_LINECAPS_SHADE           D3DPSHADECAPS_COLORFLATMONO         |   \
                                        D3DPSHADECAPS_COLORFLATRGB          |   \
                                        D3DPSHADECAPS_COLORGOURAUDMONO      |   \
                                        D3DPSHADECAPS_COLORGOURAUDRGB       |   \
                                        D3DPSHADECAPS_SPECULARFLATRGB       |   \
                                        D3DPSHADECAPS_SPECULARGOURAUDRGB    |   \
                                        D3DPSHADECAPS_ALPHAFLATBLEND        |   \
                                        D3DPSHADECAPS_ALPHAGOURAUDBLEND     |   \
                                        D3DPSHADECAPS_FOGFLAT               |   \
                                        D3DPSHADECAPS_FOGGOURAUD

// Texture capabilities (dwTextureCaps)
#define KELVIN_LINECAPS_TEXTURE         D3DPTEXTURECAPS_PERSPECTIVE         |   \
                                        D3DPTEXTURECAPS_POW2                |   \
                                        D3DPTEXTURECAPS_ALPHA               |   \
                                        D3DPTEXTURECAPS_TRANSPARENCY        |   \
                                        D3DPTEXTURECAPS_CUBEMAP             |   \
                                        D3DPTEXTURECAPS_CUBEMAP_POW2        |   \
                                        D3DPTEXTURECAPS_MIPMAP              |   \
                                        D3DPTEXTURECAPS_MIPCUBEMAP          |   \
                                        D3DPTEXTURECAPS_PROJECTED           |   \
                                        D3DPTEXTURECAPS_ALPHAPALETTE        |   \
                                        D3DPTEXTURECAPS_VOLUMEMAP           |   \
                                        D3DPTEXTURECAPS_VOLUMEMAP_POW2      |   \
                                        D3DPTEXTURECAPS_MIPVOLUMEMAP

// Texture filtering capabilities (dwTextureFilterCaps)
#define KELVIN_LINECAPS_TEXTUREFILTER   D3DPTFILTERCAPS_NEAREST             |   \
                                        D3DPTFILTERCAPS_LINEAR              |   \
                                        D3DPTFILTERCAPS_MIPNEAREST          |   \
                                        D3DPTFILTERCAPS_MIPLINEAR           |   \
                                        D3DPTFILTERCAPS_LINEARMIPNEAREST    |   \
                                        D3DPTFILTERCAPS_LINEARMIPLINEAR     |   \
                                        D3DPTFILTERCAPS_MINFPOINT           |   \
                                        D3DPTFILTERCAPS_MINFLINEAR          |   \
                                        D3DPTFILTERCAPS_MIPFPOINT           |   \
                                        D3DPTFILTERCAPS_MIPFLINEAR          |   \
                                        D3DPTFILTERCAPS_MAGFPOINT           |   \
                                        D3DPTFILTERCAPS_MAGFLINEAR

// Texture blending capabilities (dwTextureBlendCaps)
#define KELVIN_LINECAPS_TEXTUREBLEND    D3DPTBLENDCAPS_DECAL                |   \
                                        D3DPTBLENDCAPS_MODULATE             |   \
                                        D3DPTBLENDCAPS_DECALALPHA           |   \
                                        D3DPTBLENDCAPS_MODULATEALPHA        |   \
                                        D3DPTBLENDCAPS_DECALMASK            |   \
                                        D3DPTBLENDCAPS_MODULATEMASK         |   \
                                        D3DPTBLENDCAPS_COPY                 |   \
                                        D3DPTBLENDCAPS_ADD

// Texture addressing capabilities (dwTextureAddressCaps)
#define KELVIN_LINECAPS_TEXTUREADDRESS  D3DPTADDRESSCAPS_WRAP               |   \
                                        D3DPTADDRESSCAPS_MIRROR             |   \
                                        D3DPTADDRESSCAPS_CLAMP              |   \
                                        D3DPTADDRESSCAPS_BORDER             |   \
                                        D3DPTADDRESSCAPS_INDEPENDENTUV

// Maximum stipple dimensions.
#define KELVIN_LINECAPS_STIPPLEWIDTH    0
#define KELVIN_LINECAPS_STIPPLEHEIGHT   0

// Define the triangle capabilities.
//
// Miscellaneous capabilities (dwMiscCaps)
#define KELVIN_TRICAPS_MISC             D3DPMISCCAPS_MASKZ                  |   \
                                        D3DPMISCCAPS_CULLNONE               |   \
                                        D3DPMISCCAPS_CULLCW                 |   \
                                        D3DPMISCCAPS_CULLCCW                |   \
                                        D3DPMISCCAPS_BLENDOP                |   \
                                        D3DPMISCCAPS_COLORWRITEENABLE       |   \
                                        D3DPMISCCAPS_TSSARGTEMP

// Raster capabilities (dwRasterCaps)
#define KELVIN_TRICAPS_RASTER           D3DPRASTERCAPS_DITHER                   |   \
                                        D3DPRASTERCAPS_SUBPIXEL                 |   \
                                        D3DPRASTERCAPS_FOGVERTEX                |   \
                                        D3DPRASTERCAPS_FOGTABLE                 |   \
                                        D3DPRASTERCAPS_MIPMAPLODBIAS            |   \
                                        D3DPRASTERCAPS_ZBIAS                    |   \
                                        D3DPRASTERCAPS_FOGRANGE                 |   \
                                        D3DPRASTERCAPS_WBUFFER                  |   \
                                        D3DPRASTERCAPS_WFOG                     |   \
                                        D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT |   \
                                        D3DPRASTERCAPS_STRETCHBLTMULTISAMPLE    |   \
                                        D3DPRASTERCAPS_ANISOTROPY               |   \
                                        D3DPRASTERCAPS_ZFOG

// Z Compare capabilities (dwZCmpCaps)
#define KELVIN_TRICAPS_ZCMP             D3DPCMPCAPS_NEVER                   |   \
                                        D3DPCMPCAPS_LESS                    |   \
                                        D3DPCMPCAPS_EQUAL                   |   \
                                        D3DPCMPCAPS_LESSEQUAL               |   \
                                        D3DPCMPCAPS_GREATER                 |   \
                                        D3DPCMPCAPS_NOTEQUAL                |   \
                                        D3DPCMPCAPS_GREATEREQUAL            |   \
                                        D3DPCMPCAPS_ALWAYS

// Source blend capabilities (dwSrcBlendCaps)
#define KELVIN_TRICAPS_SRCBLEND         D3DPBLENDCAPS_ZERO                  |   \
                                        D3DPBLENDCAPS_ONE                   |   \
                                        D3DPBLENDCAPS_SRCCOLOR              |   \
                                        D3DPBLENDCAPS_INVSRCCOLOR           |   \
                                        D3DPBLENDCAPS_SRCALPHA              |   \
                                        D3DPBLENDCAPS_INVSRCALPHA           |   \
                                        D3DPBLENDCAPS_DESTALPHA             |   \
                                        D3DPBLENDCAPS_INVDESTALPHA          |   \
                                        D3DPBLENDCAPS_DESTCOLOR             |   \
                                        D3DPBLENDCAPS_INVDESTCOLOR          |   \
                                        D3DPBLENDCAPS_SRCALPHASAT           |   \
                                        D3DPBLENDCAPS_BOTHSRCALPHA          |   \
                                        D3DPBLENDCAPS_BOTHINVSRCALPHA

// Destination blend capabilities (dwDestBlendCaps)
#define KELVIN_TRICAPS_DESTBLEND        D3DPBLENDCAPS_ZERO                  |   \
                                        D3DPBLENDCAPS_ONE                   |   \
                                        D3DPBLENDCAPS_SRCCOLOR              |   \
                                        D3DPBLENDCAPS_INVSRCCOLOR           |   \
                                        D3DPBLENDCAPS_SRCALPHA              |   \
                                        D3DPBLENDCAPS_INVSRCALPHA           |   \
                                        D3DPBLENDCAPS_DESTALPHA             |   \
                                        D3DPBLENDCAPS_INVDESTALPHA          |   \
                                        D3DPBLENDCAPS_DESTCOLOR             |   \
                                        D3DPBLENDCAPS_INVDESTCOLOR          |   \
                                        D3DPBLENDCAPS_SRCALPHASAT           |   \
                                        D3DPBLENDCAPS_BOTHSRCALPHA          |   \
                                        D3DPBLENDCAPS_BOTHINVSRCALPHA

// Alpha compare capabilities (dwAlphaCmpCaps)
#define KELVIN_TRICAPS_ALPHACMP         D3DPCMPCAPS_NEVER                   |   \
                                        D3DPCMPCAPS_LESS                    |   \
                                        D3DPCMPCAPS_EQUAL                   |   \
                                        D3DPCMPCAPS_LESSEQUAL               |   \
                                        D3DPCMPCAPS_GREATER                 |   \
                                        D3DPCMPCAPS_NOTEQUAL                |   \
                                        D3DPCMPCAPS_GREATEREQUAL            |   \
                                        D3DPCMPCAPS_ALWAYS

// Shading capabilities (dwShadeCaps)
#define KELVIN_TRICAPS_SHADE            D3DPSHADECAPS_COLORFLATMONO         |   \
                                        D3DPSHADECAPS_COLORFLATRGB          |   \
                                        D3DPSHADECAPS_COLORGOURAUDMONO      |   \
                                        D3DPSHADECAPS_COLORGOURAUDRGB       |   \
                                        D3DPSHADECAPS_SPECULARFLATRGB       |   \
                                        D3DPSHADECAPS_SPECULARGOURAUDRGB    |   \
                                        D3DPSHADECAPS_ALPHAFLATBLEND        |   \
                                        D3DPSHADECAPS_ALPHAGOURAUDBLEND     |   \
                                        D3DPSHADECAPS_FOGFLAT               |   \
                                        D3DPSHADECAPS_FOGGOURAUD

// Texture capabilities (dwTextureCaps)
#define KELVIN_TRICAPS_TEXTURE          D3DPTEXTURECAPS_PERSPECTIVE         |   \
                                        D3DPTEXTURECAPS_POW2                |   \
                                        D3DPTEXTURECAPS_ALPHA               |   \
                                        D3DPTEXTURECAPS_TRANSPARENCY        |   \
                                        D3DPTEXTURECAPS_CUBEMAP             |   \
                                        D3DPTEXTURECAPS_CUBEMAP_POW2        |   \
                                        D3DPTEXTURECAPS_MIPMAP              |   \
                                        D3DPTEXTURECAPS_MIPCUBEMAP          |   \
                                        D3DPTEXTURECAPS_PROJECTED           |   \
                                        D3DPTEXTURECAPS_ALPHAPALETTE        |   \
                                        D3DPTEXTURECAPS_VOLUMEMAP           |   \
                                        D3DPTEXTURECAPS_VOLUMEMAP_POW2      |   \
                                        D3DPTEXTURECAPS_MIPVOLUMEMAP


// Texture filtering capabilities (dwTextureFilterCaps)
#define KELVIN_TRICAPS_TEXTUREFILTER    D3DPTFILTERCAPS_NEAREST             |   \
                                        D3DPTFILTERCAPS_LINEAR              |   \
                                        D3DPTFILTERCAPS_MIPNEAREST          |   \
                                        D3DPTFILTERCAPS_MIPLINEAR           |   \
                                        D3DPTFILTERCAPS_LINEARMIPNEAREST    |   \
                                        D3DPTFILTERCAPS_LINEARMIPLINEAR     |   \
                                        D3DPTFILTERCAPS_MINFPOINT           |   \
                                        D3DPTFILTERCAPS_MINFLINEAR          |   \
                                        D3DPTFILTERCAPS_MINFANISOTROPIC     |   \
                                        D3DPTFILTERCAPS_MIPFPOINT           |   \
                                        D3DPTFILTERCAPS_MIPFLINEAR          |   \
                                        D3DPTFILTERCAPS_MAGFPOINT           |   \
                                        D3DPTFILTERCAPS_MAGFLINEAR          |   \
                                        D3DPTFILTERCAPS_MAGFANISOTROPIC

// Volume texture filtering capabilities
#define KELVIN_TRICAPS_VOLUMETEXFILTER  D3DPTFILTERCAPS_NEAREST             |   \
                                        D3DPTFILTERCAPS_LINEAR              |   \
                                        D3DPTFILTERCAPS_MIPNEAREST          |   \
                                        D3DPTFILTERCAPS_MIPLINEAR           |   \
                                        D3DPTFILTERCAPS_LINEARMIPNEAREST    |   \
                                        D3DPTFILTERCAPS_LINEARMIPLINEAR     |   \
                                        D3DPTFILTERCAPS_MINFPOINT           |   \
                                        D3DPTFILTERCAPS_MINFLINEAR          |   \
                                        D3DPTFILTERCAPS_MINFANISOTROPIC     |   \
                                        D3DPTFILTERCAPS_MIPFPOINT           |   \
                                        D3DPTFILTERCAPS_MIPFLINEAR          |   \
                                        D3DPTFILTERCAPS_MAGFPOINT


// Texture blending capabilities (dwTextureBlendCaps)
#define KELVIN_TRICAPS_TEXTUREBLEND     D3DPTBLENDCAPS_DECAL                |   \
                                        D3DPTBLENDCAPS_MODULATE             |   \
                                        D3DPTBLENDCAPS_DECALALPHA           |   \
                                        D3DPTBLENDCAPS_MODULATEALPHA        |   \
                                        D3DPTBLENDCAPS_DECALMASK            |   \
                                        D3DPTBLENDCAPS_MODULATEMASK         |   \
                                        D3DPTBLENDCAPS_COPY                 |   \
                                        D3DPTBLENDCAPS_ADD

// Texture addressing capabilities (dwTextureAddressCaps)
#define KELVIN_TRICAPS_TEXTUREADDRESS   D3DPTADDRESSCAPS_WRAP               |   \
                                        D3DPTADDRESSCAPS_MIRROR             |   \
                                        D3DPTADDRESSCAPS_CLAMP              |   \
                                        D3DPTADDRESSCAPS_BORDER             |   \
                                        D3DPTADDRESSCAPS_INDEPENDENTUV

// Maximum stipple dimensions.
#define KELVIN_TRICAPS_STIPPLEWIDTH     0
#define KELVIN_TRICAPS_STIPPLEHEIGHT    0

// Texture Ops
#define KELVIN_CAPS_TEXTUREOPS   D3DTEXOPCAPS_DISABLE                       |   \
                                 D3DTEXOPCAPS_SELECTARG1                    |   \
                                 D3DTEXOPCAPS_SELECTARG2                    |   \
                                 D3DTEXOPCAPS_MODULATE                      |   \
                                 D3DTEXOPCAPS_MODULATE2X                    |   \
                                 D3DTEXOPCAPS_MODULATE4X                    |   \
                                 D3DTEXOPCAPS_ADD                           |   \
                                 D3DTEXOPCAPS_ADDSIGNED                     |   \
                                 D3DTEXOPCAPS_ADDSIGNED2X                   |   \
                                 D3DTEXOPCAPS_SUBTRACT                      |   \
                                 D3DTEXOPCAPS_ADDSMOOTH                     |   \
                                 D3DTEXOPCAPS_BLENDDIFFUSEALPHA             |   \
                                 D3DTEXOPCAPS_BLENDTEXTUREALPHA             |   \
                                 D3DTEXOPCAPS_BLENDFACTORALPHA              |   \
                                 D3DTEXOPCAPS_BLENDTEXTUREALPHAPM           |   \
                                 D3DTEXOPCAPS_BLENDCURRENTALPHA             |   \
                                 D3DTEXOPCAPS_PREMODULATE                   |   \
                                 D3DTEXOPCAPS_MODULATEALPHA_ADDCOLOR        |   \
                                 D3DTEXOPCAPS_MODULATECOLOR_ADDALPHA        |   \
                                 D3DTEXOPCAPS_MODULATEINVALPHA_ADDCOLOR     |   \
                                 D3DTEXOPCAPS_MODULATEINVCOLOR_ADDALPHA     |   \
                                 D3DTEXOPCAPS_BUMPENVMAP                    |   \
                                 D3DTEXOPCAPS_BUMPENVMAPLUMINANCE           |   \
                                 D3DTEXOPCAPS_DOTPRODUCT3                   |   \
                                 D3DTEXOPCAPS_MULTIPLYADD                   |   \
                                 D3DTEXOPCAPS_LERP

// Stencil Ops
#define KELVIN_CAPS_STENCILOPS   D3DSTENCILCAPS_KEEP                        |   \
                                 D3DSTENCILCAPS_ZERO                        |   \
                                 D3DSTENCILCAPS_REPLACE                     |   \
                                 D3DSTENCILCAPS_INCRSAT                     |   \
                                 D3DSTENCILCAPS_DECRSAT                     |   \
                                 D3DSTENCILCAPS_INVERT                      |   \
                                 D3DSTENCILCAPS_INCR                        |   \
                                 D3DSTENCILCAPS_DECR

// Vertex Processing Caps
#define KELVIN_CAPS_VTXPCAPS   D3DVTXPCAPS_TEXGEN                           |   \
                               D3DVTXPCAPS_MATERIALSOURCE7                  |   \
                               D3DVTXPCAPS_VERTEXFOG                        |   \
                               D3DVTXPCAPS_DIRECTIONALLIGHTS                |   \
                               D3DVTXPCAPS_POSITIONALLIGHTS                 |   \
                               D3DVTXPCAPS_LOCALVIEWER                      |   \
                               D3DVTXPCAPS_NO_VSDT_UBYTE4 // NV20 does not support this, NV25 does

// Define the render bit depth capabilites.
#define KELVIN_RENDERBITDEPTHCAPS      (DDBD_16 | DDBD_32)

// Define the Z buffer bit depth capabilities.
#define KELVIN_ZBUFFERBITDEPTHCAPS     (DDBD_16 | DDBD_24)

#endif  // NVARCH > 0x020
#endif  // _NVKELVINCAPS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\kelvin\inc\nvKelvinStateHelp.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvKelvinStateHelp.h
//      Constants, macros, and prototypes for nvKelvinStateHelp.cpp
//
// **************************************************************************
//
//  History:
//       Craig Duttweiler        26Apr2000         NV20 development
//
// **************************************************************************

#ifndef _NVKELVINSTATEHELP_H
#define _NVKELVINSTATEHELP_H

#if (NVARCH >= 0x020)

DWORD nvKelvinValidateTextureStageState (LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA);
DWORD nvKelvinInlineVertexStride        (PNVD3DCONTEXT pContext);

#endif  // NVARCH >= 0x020

#endif  // _NVKELVINSTATEHELP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\kelvin\src\nvKelvinAA.cpp ===
/*
 * Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvKelvinAA.cpp                                                    *
*     prototypes for aa routines                                            *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Scott Cutler                     11Oct2000   created                *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x020)

#ifdef DEBUG_SURFACE_PLACEMENT
extern CSurfaceDebug csd;
#endif

//#define SCALED_IMAGE
//#define SUPERSAMPLE
#define AAFORCE_16_32
#define SUBDIVIDE_AA
//#define _16_BIT_FIX
//#define TEST_SUB

#define UPSAMPLE_SEMANTICS_FRAME_COUNT 5

#ifdef SUBDIVIDE_AA
#ifdef TEST_SUB
DWORD __stripsize = 768;
DWORD __swath = NV097_SET_SWATH_WIDTH_V_32;
#endif
#endif


extern HRESULT nvSetKelvinD3DDefaults(PNVD3DCONTEXT pContext);
__forceinline DWORD F2D(float f) { return *(DWORD *)&f; }

const char * CKelvinAAState::BufferTypeNames[] = {
    "BUFFER_SRT",
    "BUFFER_RT",
    "BUFFER_SZB",
    "BUFFER_ZB",
    "BUFFER_SCRATCH"
};

const char * CKelvinAAState::AccessTypeNames[] = {
    "ACCESS_READ",
    "ACCESS_WRITE",
    "ACCESS_WRITE_DISCARD"
};

const CKelvinAAState::MethodInfoStruct CKelvinAAState::MethodInfo[METHOD_MAX] = {
    { // METHOD_NONE
        false, 
        1.0,  0.0, 
        SIMPLEMETHOD_1X1, 
        DRF_DEF(097, _SET_SURFACE_FORMAT, _ANTI_ALIASING, _CENTER_1),        
        0,
        METHOD_NONE,
        METHOD_NONE
    }, { // METHOD_SUPERSAMPLE_2X_H                                                     
        false, 
        1.41, 0.0, 
        SIMPLEMETHOD_2X1, 
        DRF_DEF(097, _SET_SURFACE_FORMAT, _ANTI_ALIASING, _CENTER_1),        
        0,
        METHOD_SUPERSAMPLE_2X_H,
        METHOD_SUPERSAMPLE_2X_H
    }, { // METHOD_SUPERSAMPLE_2X_V                                                     
        false, 
        1.41, 0.0, 
        SIMPLEMETHOD_1X2, 
        DRF_DEF(097, _SET_SURFACE_FORMAT, _ANTI_ALIASING, _CENTER_1),        
        0,
        METHOD_SUPERSAMPLE_2X_V,
        METHOD_SUPERSAMPLE_2X_V
    }, { // METHOD_MULTISAMPLE_2X                                                     
        true,  
        0.0,  0.0, 
        SIMPLEMETHOD_2X1, 
        DRF_DEF(097, _SET_SURFACE_FORMAT, _ANTI_ALIASING, _CENTER_CORNER_2), 
        0,
        METHOD_MULTISAMPLE_2X,
        METHOD_SUPERSAMPLE_2X_V
    }, { // METHOD_MULTISAMPLE_2X_QUINCUNX                                                     
        true,  
        0.0,  0.0, 
        SIMPLEMETHOD_2X1, 
        DRF_DEF(097, _SET_SURFACE_FORMAT, _ANTI_ALIASING, _CENTER_CORNER_2), 
        NV097_SET_TEXTURE_FILTER_CONVOLUTION_KERNEL_QUINCUNX,
        METHOD_MULTISAMPLE_2X,
        METHOD_SUPERSAMPLE_2X_V
    }, { // METHOD_SUPERSAMPLE_4X_BIAS                                                     
        false, 
        2.0,  1.0, 
        SIMPLEMETHOD_2X2, 
        DRF_DEF(097, _SET_SURFACE_FORMAT, _ANTI_ALIASING, _CENTER_1),        
        0,
        METHOD_SUPERSAMPLE_4X_BIAS,
        METHOD_SUPERSAMPLE_4X_BIAS
    }, { // METHOD_SUPERSAMPLE_4X                                                     
        false, 
        2.0,  0.0, 
        SIMPLEMETHOD_2X2, 
        DRF_DEF(097, _SET_SURFACE_FORMAT, _ANTI_ALIASING, _CENTER_1),        
        0,
        METHOD_SUPERSAMPLE_4X,
        METHOD_SUPERSAMPLE_4X
    }, { // METHOD_SUPERSAMPLE_4X_GAUSSIAN                                                    
        false, 
        2.0,  0.0, 
        SIMPLEMETHOD_2X2, 
        DRF_DEF(097, _SET_SURFACE_FORMAT, _ANTI_ALIASING, _CENTER_1),        
        NV097_SET_TEXTURE_FILTER_CONVOLUTION_KERNEL_GAUSSIAN_3,
        METHOD_SUPERSAMPLE_4X,
        METHOD_SUPERSAMPLE_4X
    }, { // METHOD_MULTISAMPLE_4X                                                     
        true,
        0.0,  0.0,
        SIMPLEMETHOD_2X2,
        DRF_DEF(097, _SET_SURFACE_FORMAT, _ANTI_ALIASING, _SQUARE_OFFSET_4),
        0,
        METHOD_MULTISAMPLE_4X,
        METHOD_SUPERSAMPLE_4X
    }, { // METHOD_MULTISAMPLE_4X_GAUSSIAN                                                     
        true,  
        0.0,  0.0, 
        SIMPLEMETHOD_2X2, 
        DRF_DEF(097, _SET_SURFACE_FORMAT, _ANTI_ALIASING, _SQUARE_OFFSET_4), 
        NV097_SET_TEXTURE_FILTER_CONVOLUTION_KERNEL_GAUSSIAN_3,
        METHOD_MULTISAMPLE_4X,
        METHOD_SUPERSAMPLE_4X
    }, { // METHOD_MULTISAMPLE_4X_ROTATED_4TAP                                                     
        true,  
        0.0,  0.0, 
        SIMPLEMETHOD_2X2, 
        DRF_DEF(097, _SET_SURFACE_FORMAT, _ANTI_ALIASING,_CENTER_CORNER_2),
        0,
        METHOD_MULTISAMPLE_4X,
        METHOD_SUPERSAMPLE_4X
    }, { // METHOD_MULTISAMPLE_4X_ROTATED_8TAP                                                     
        true,  
        0.0,  0.0, 
        SIMPLEMETHOD_2X2, 
        DRF_DEF(097, _SET_SURFACE_FORMAT, _ANTI_ALIASING,_CENTER_CORNER_2),
        0,
        METHOD_MULTISAMPLE_4X,
        METHOD_SUPERSAMPLE_4X
    }, { // METHOD_SUPERSAMPLE_9X_BIAS                                                     
        false, 
        3.0,  1.5, 
        SIMPLEMETHOD_3X3, 
        DRF_DEF(097, _SET_SURFACE_FORMAT, _ANTI_ALIASING, _CENTER_1),
        0,
        METHOD_SUPERSAMPLE_9X_BIAS,
        METHOD_SUPERSAMPLE_9X_BIAS
    }, { // METHOD_SUPERSAMPLE_9X                                                     
        false, 
        3.0,  0.0, 
        SIMPLEMETHOD_3X3, 
        DRF_DEF(097, _SET_SURFACE_FORMAT, _ANTI_ALIASING, _CENTER_1),
        0,
        METHOD_SUPERSAMPLE_9X,
        METHOD_SUPERSAMPLE_9X
    }, { // METHOD_SUPERSAMPLE_16X_BIAS                                                     
        false, 
        4.0,  2.0, 
        SIMPLEMETHOD_4X4, 
        DRF_DEF(097, _SET_SURFACE_FORMAT, _ANTI_ALIASING, _CENTER_1),
        0,
        METHOD_SUPERSAMPLE_16X_BIAS,
        METHOD_SUPERSAMPLE_16X_BIAS
    }, { // METHOD_SUPERSAMPLE_16X                                                     
        false, 
        4.0,  0.0, 
        SIMPLEMETHOD_4X4, 
        DRF_DEF(097, _SET_SURFACE_FORMAT, _ANTI_ALIASING, _CENTER_1),
        0,
        METHOD_SUPERSAMPLE_16X,
        METHOD_SUPERSAMPLE_16X
    }
};

const CKelvinAAState::BufferBltInfoStruct CKelvinAAState::BufferBltInfo[SIMPLEMETHOD_MAX] = {
    {1, 1, 0, 0, 0.00, 0.00, 0.00, 0.00,   0.5000, 0.5000},    // SIMPLEMETHOD_1X1
    {1, 2, 0, 0, 0.00, 0.50, 0.00, 0.00,   0.5000, 0.2500},    // SIMPLEMETHOD_1X2
    {2, 1, 0, 0, 0.50, 0.00, 0.00, 0.00,   0.2500, 0.5000},    // SIMPLEMETHOD_2X1
    {2, 2, 0, 0, 0.50, 0.50, 0.00, 0.00,   0.2500, 0.2500},    // SIMPLEMETHOD_2X2
    {3, 3, 2, 2, 0.25, 0.25, 0.50, 0.50,   0.1666, 0.1666},    // SIMPLEMETHOD_3X3
    {4, 4, 2, 2, 0.50, 0.50, 0.50, 0.50,   0.1250, 0.1250}     // SIMPLEMETHOD_4X4
};


const CKelvinAAState::MethodType CKelvinAAState::RegQualityToAATypeMapping[10] = {
    METHOD_NONE,
    METHOD_MULTISAMPLE_2X,
    METHOD_MULTISAMPLE_2X_QUINCUNX,
    METHOD_MULTISAMPLE_4X,
    METHOD_MULTISAMPLE_4X_GAUSSIAN,
// Following methods are not implemented yet.  Punt to working modes.
//    METHOD_SUPERSAMPLE_9X_BIAS,
//    METHOD_SUPERSAMPLE_9X,
//    METHOD_SUPERSAMPLE_16X_BIAS,
//    METHOD_SUPERSAMPLE_16X
    METHOD_MULTISAMPLE_4X_GAUSSIAN,
    METHOD_MULTISAMPLE_4X_GAUSSIAN,
    METHOD_MULTISAMPLE_4X_GAUSSIAN,
    METHOD_MULTISAMPLE_4X_GAUSSIAN,
    METHOD_MULTISAMPLE_4X_GAUSSIAN
};


CKelvinAAState::CKelvinAAState() { 
    _pContext = 0;
    _enabled = 0;
    _numZLocks = 0;
    _didUpsample = true;
    _lastDownsampleUsedConvolution = false;
    _badSemantics = false;
    _seen3D = 0;

    memset(_bufferInfo, 0, sizeof(_bufferInfo));
}





void CKelvinAAState::Create(PNVD3DCONTEXT pContext) {
    if (_pContext) {
        // Make sure we don't try to create things twice
        // We want one Destroy for every Create
        nvAssert(0);
        return;
    }
        
    nvKelvinInitProgram(&_program);
    nvKelvinParseProgram(&_program, "%!VP1.0\nMOV o[HPOS], v[0];\nMOV o[TEX0], v[9];\nMOV o[TEX1], v[10];\nMOV o[TEX2], v[11];\nMOV o[TEX3], v[12];");

    InitAppCompatibility();
    if (_appCompatibility.dwFlags & APPFLAGS_DISABLE_AA) return;

    //on endscene we give read access to the RT, and if it's invalid, we minify the SRT.
    //after a refresh call, the SRT is invalidated and usually a subsequent write access
    //(like a clear) to the SRT tags the RT as invalid (and the SRT as valid). however, if
    //the app doesn't write to the SRT before the read access to the RT, the RT is never
    //invalidated which means the minification never happens -> eek!
    //this remebers if the SRT was valid at refresh time and does not set the RT as valid
    //in that case. FS
    
    if (_invalidRT)
      _invalidRT = 0;
    else 
      _bufferInfo[BUFFER_RT].flags |= FLAGS_VALID;
      


    // Well, this isn't quite correct, since we haven't copied
    // the contents of the Z buffer.  Fortunately, it shouldn't cause many
    // problems, and it needed because we destroy the normal Z buffer before
    // we create the new one.
    _bufferInfo[BUFFER_SZB].flags |= FLAGS_VALID;

    _bufferInfo[BUFFER_RT].other = BUFFER_SRT;
    _bufferInfo[BUFFER_SRT].other = BUFFER_RT;
    _bufferInfo[BUFFER_ZB].other = BUFFER_SZB;
    _bufferInfo[BUFFER_SZB].other = BUFFER_ZB;

    nvAssert(getDC()->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN);


    if ((!pContext->pRenderTarget) ||
        (pContext->pRenderTarget->isSwizzled())) {
        DPF_LEVEL (NVDBG_LEVEL_ERROR,"CKelvinAAState::Create: AA failed because render target either does not exist or it is swizzled.");
        memset(_bufferInfo, 0, sizeof(_bufferInfo));
        return;
    }

    _pContext = pContext;


    DWORD dwMSBits = _pContext->pRenderTarget->getMultiSampleBits();

    if (dwMSBits >= 2) {
        // App-controlled multisampling.  We support 2 and 4 sample modes.
        nvAssert(!_pContext->pZetaBuffer || (dwMSBits == _pContext->pZetaBuffer->getMultiSampleBits()));

        switch (dwMSBits) {
        case 2:  SetMethod(METHOD_MULTISAMPLE_2X);           break;
        case 3:  SetMethod(METHOD_MULTISAMPLE_2X_QUINCUNX);  break;
        case 4:  SetMethod(METHOD_MULTISAMPLE_4X);           break;
        case 5:  SetMethod(METHOD_MULTISAMPLE_4X_GAUSSIAN);  break;
        default:
            // Invalid number of bits
            DPF_LEVEL(NVDBG_LEVEL_ERROR,"CKelvinAAState::Create: App set invalid number of multisampling bits (%d).", dwMSBits);
            _pContext = 0;
            return;
        }
    } else if ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_ANTIALIASFORCEENABLE_MASK) ||
               (pContext->dwRenderState[D3DRENDERSTATE_ANTIALIAS] != D3DANTIALIAS_NONE)) {
        // FSAA forced on through registry or render state.
        nvAssert(getDC()->nvD3DRegistryData.regAntiAliasQuality < 9);
        SetMethod(RegQualityToAATypeMapping[getDC()->nvD3DRegistryData.regAntiAliasQuality]);
    } else {
        // We shouldn't be in here
        nvAssert(0);
    }

#ifdef AAFORCE_16_32
    _MixedModeAA = (getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_ANTIALIASCONVOLUTIONFASTMODE_MASK) == D3D_REG_ANTIALIASCONVOLUTIONFASTMODE_ENABLE ;
#endif

    const MethodInfoStruct *info = &MethodInfo[_method];
    const BufferBltInfoStruct *bltInfo;

    DWORD dwSimpleMethod = info->type;

    // Just for the convenience factor
    CSimpleSurface *&pRT = _bufferInfo[BUFFER_RT].pSurface;
    CSimpleSurface *&pZB = _bufferInfo[BUFFER_ZB].pSurface;
    CSimpleSurface *&pSRT = _bufferInfo[BUFFER_SRT].pSurface;
    CSimpleSurface *&pSZB = _bufferInfo[BUFFER_SZB].pSurface;

    pRT = _pContext->pRenderTarget;
    pZB = _pContext->pZetaBuffer;
    pSRT = 0;
    pSZB = 0;

    // Kill the normal Z buffer.  There's no need for it unless the application
    // later locks the Z buffer (in which case we'll recreate it).  Otherwise it 
    // just takes up memory and Z tag bit space.
    if (pZB) {
#ifdef DEBUG_SURFACE_PLACEMENT
        csd.DeleteSurface(pZB);
#endif
        pZB->destroy();
    }

    // A "simple method" is a unique buffer scale + filter type combination.
    // We start at the top, iterating down, until we find one that works.
    while (dwSimpleMethod > SIMPLEMETHOD_1X1) {
        DWORD dwMem = 0;
        DWORD dwPitch = 0;

        bltInfo = &BufferBltInfo[dwSimpleMethod];
        
        // 4k is the max.
        if ((pRT->getWidth() * bltInfo->dwSuperBufferScaleX) > 4096) goto creationFail;
        if ((pRT->getHeight() * bltInfo->dwSuperBufferScaleY) > 4096) goto creationFail;

        // Calculate the framebuffer space requirements
        if (pRT) dwMem += pRT->getBPP() * pRT->getWidth() * pRT->getHeight();
        if (pZB) dwMem += pZB->getBPP() * pZB->getWidth() * pZB->getHeight();

        dwMem *= DWORD((bltInfo->dwSuperBufferScaleX * bltInfo->dwSuperBufferScaleY) +
                        (bltInfo->dwScratchBufferScaleX * bltInfo->dwScratchBufferScaleY));

        // Ensure that we still have 1/4 of frame buffer memory left after all is said and done
        if ((int(getDC()->VideoHeapFree) - int(dwMem)) < int(getDC()->VideoHeapTotal / 4)) goto creationFail;

        
        // Create the super render target if the app has one (it better!)
        if (pRT) {
            if (!(pSRT = new CSimpleSurface())) goto creationFail;

#ifndef AAFORCE_16_32
            dwPitch = pRT->getWidth() * bltInfo->dwSuperBufferScaleX * pRT->getBPP();
#else
            if (IsMixedModeAA() && pRT->getFormat() == NV_SURFACE_FORMAT_X8R8G8B8 && (_method == METHOD_MULTISAMPLE_2X_QUINCUNX || _method ==  METHOD_MULTISAMPLE_4X_GAUSSIAN)) 
                dwPitch = pRT->getWidth() * bltInfo->dwSuperBufferScaleX * 2;
            else 
                dwPitch = pRT->getWidth() * bltInfo->dwSuperBufferScaleX * pRT->getBPP();
#endif
            dwPitch = (dwPitch + getDC()->dwSurfaceAlignPad) & ~getDC()->dwSurfaceAlignPad;


#ifndef AAFORCE_16_32
            if (!pSRT->create(NULL,
                              pRT->getFormat(),
                              pRT->getWidth()  * bltInfo->dwSuperBufferScaleX,
                              pRT->getHeight() * bltInfo->dwSuperBufferScaleY,
                              pRT->getDepth(),
                              1,
                              pRT->getBPPRequested(),
                              pRT->getBPP(),
                              dwPitch,
                              CSimpleSurface::HEAP_VID,
                              CSimpleSurface::HEAP_VID,
                              CSimpleSurface::ALLOCATE_TILED
#ifdef CAPTURE
                             ,CAPTURE_SURFACE_KIND_TARGET
#endif
                        )) goto creationFail;
#else   //AAFORCE_16_32

            if (IsMixedModeAA() && pRT->getFormat() == NV_SURFACE_FORMAT_X8R8G8B8 && (_method == METHOD_MULTISAMPLE_2X_QUINCUNX || _method ==  METHOD_MULTISAMPLE_4X_GAUSSIAN)) 
            {
                if (!pSRT->create(NULL,
                                  NV_SURFACE_FORMAT_R5G6B5,
                                  pRT->getWidth()  * bltInfo->dwSuperBufferScaleX,
                                  pRT->getHeight() * bltInfo->dwSuperBufferScaleY,
                                  pRT->getDepth(),
                                  1,
                                  2,
                                  2,
                                  dwPitch,
                                  CSimpleSurface::HEAP_VID,
                                  CSimpleSurface::HEAP_VID,
                                  CSimpleSurface::ALLOCATE_TILED
#ifdef CAPTURE
                                 ,CAPTURE_SURFACE_KIND_TARGET
#endif
                            )) goto creationFail;
                
            }
            else 
            {
                
                if (!pSRT->create(NULL,
                                  pRT->getFormat(),
                                  pRT->getWidth()  * bltInfo->dwSuperBufferScaleX,
                                  pRT->getHeight() * bltInfo->dwSuperBufferScaleY,
                                  pRT->getDepth(),
                                  1,
                                  pRT->getBPPRequested(),
                                  pRT->getBPP(),
                                  dwPitch,
                                  CSimpleSurface::HEAP_VID,
                                  CSimpleSurface::HEAP_VID,
                                  CSimpleSurface::ALLOCATE_TILED
#ifdef CAPTURE
                                 ,CAPTURE_SURFACE_KIND_TARGET
#endif
                            )) goto creationFail;

            }
#endif //AAFORCE_16_32
        } else {
            DPF("Error in CKelvinAAState::Create: No render target");
            nvAssert(0);
            goto creationFail;
        }


#ifdef DEBUG_SURFACE_PLACEMENT
        csd.SetAARenderBuffer(pSRT);
#endif 


        if (pZB) {
            if (!(pSZB = new CSimpleSurface())) goto creationFail;

            dwPitch = pZB->getWidth() * bltInfo->dwSuperBufferScaleX * pZB->getBPP();
            dwPitch = (dwPitch + getDC()->dwSurfaceAlignPad) & ~getDC()->dwSurfaceAlignPad;

            DWORD dwZCmpFlags = (_appCompatibility.dwFlags & APPFLAGS_FORCE_UNCOMPRESSED_Z) ? 
                CSimpleSurface::ALLOCATE_AS_ZBUFFER_UNC : 
                CSimpleSurface::ALLOCATE_AS_ZBUFFER_CMP;

            if (!pSZB->create(NULL,
                              pZB->getFormat(),
                              pZB->getWidth()  * bltInfo->dwSuperBufferScaleX,
                              pZB->getHeight() * bltInfo->dwSuperBufferScaleY,
                              pZB->getDepth(),
                              1,
                              pZB->getBPPRequested(),
                              pZB->getBPP(),
                              dwPitch,
                              CSimpleSurface::HEAP_VID,
                              CSimpleSurface::HEAP_VID,
                              CSimpleSurface::ALLOCATE_TILED | dwZCmpFlags
#ifdef CAPTURE
                             ,CAPTURE_SURFACE_KIND_ZETA
#endif
                        )) goto creationFail;
        }

#ifdef DEBUG_SURFACE_PLACEMENT
        csd.SetAAZBuffer(pSZB);
#endif 

#ifdef  STEREO_SUPPORT
        if (STEREO_ENABLED)
        {
            if (pSRT) {
                pSRT->tagNotReal();
                pSRT->createStereo();
            }
            if (pSZB) {
                pSZB->tagNotReal();
                pSZB->createStereo();
            }
        }
#endif  //STEREO_SUPPORT

        // TODO: scratch buffer stuff


        // The buffers were created properly.
        break;

creationFail:
        if (pSRT) {
            pSRT->destroy();
            delete pSRT;
            pSRT = 0;
        }

        if (pSZB) {
            pSZB->destroy();
            delete pSZB;
            pSZB = 0;
        }

        dwSimpleMethod--;
    }


    CNvObject *pWrapper;
    
    if (pSRT) {
        pWrapper = new CNvObject(0);
        pWrapper->setObject(CNvObject::NVOBJ_SIMPLESURFACE, (void *)pSRT);
        pSRT->setWrapper(pWrapper);
    }
    
    if (pSZB) {
        pWrapper = new CNvObject(0);
        pWrapper->setObject(CNvObject::NVOBJ_SIMPLESURFACE, (void *)pSZB);
        pSZB->setWrapper(pWrapper);
    }
    

    if ((DWORD)info->type != dwSimpleMethod) {
        // We changed the method from what the user requested for one reason or
        // another.  Find an ordinary method that corresponds with this.

        _method = METHOD_SUPERSAMPLE_16X;
        while (
            (_method > METHOD_NONE) && 
            (((DWORD)MethodInfo[_method].type != dwSimpleMethod) ||
            MethodInfo[_method].dwKernel)
            ) _method--;

        info = &MethodInfo[_method];
        bltInfo = &BufferBltInfo[dwSimpleMethod];
    }

    if (_method == METHOD_NONE) {
        ReCreateZBuffer();
    
        pSRT = pRT;
        pSZB = pZB;
        bltInfo = &BufferBltInfo[METHOD_NONE];
    }

    
    if (MethodInfo[_method].bMultisample) {
        // Multisampling does the viewport scaling automatically.
        if (_method == METHOD_MULTISAMPLE_4X_ROTATED_4TAP || _method == METHOD_MULTISAMPLE_4X_ROTATED_8TAP ) 
        {
            _pContext->aa.fWidthAmplifier = 1;
            _pContext->aa.fHeightAmplifier = 2;
        }
        else {
            _pContext->aa.fWidthAmplifier  = 1;
            _pContext->aa.fHeightAmplifier = 1;
        }
        
    } else {
        _pContext->aa.fWidthAmplifier = bltInfo->dwSuperBufferScaleX;
        _pContext->aa.fHeightAmplifier = bltInfo->dwSuperBufferScaleY;
    }
    _pContext->aa.dwDepthAmplifier = 1;
    _pContext->aa.fLODBias = info->fBias;
    _pContext->aa.dwLinePointSize = (DWORD)(info->fLinePointSize * 0x8);

/////////////////////////////////////////////////////
    
    // Should we stripdivide?
    // output 0, dsty, strip._x0, srcy-strip.y0
    //        strip.dstWidth, dsty, strip.srcWidth_x0, srcy-strip.y0
    //        strip.dstWidth, dsty+strip.dstyinc, strip.srcWidth_x0, srcy+strip.srcyinc-strip.y0
    //        0, dsty+strip.dstyinc, strip._x0, srcy+strip.srcyinc-strip.y0

    // This logic actually works whether we're upscaling or downscaling
    if (MethodInfo[_method].dwKernel) {
        _strip.x0.f = 0.25 * BufferBltInfo[dwSimpleMethod].dwSuperBufferScaleX;
        _strip.y0.f = 0.25 * BufferBltInfo[dwSimpleMethod].dwSuperBufferScaleY;
    } else {
        _strip.x0.f = 0;
        _strip.y0.f = 0;
    }
    _strip._x0.f = -_strip.x0.f;

    _bSubdivideAA = true;
    _UpsampleFlip = CURRENT_FLIP;
    if (IsMixedModeAA()) 
    {
        if (_method == METHOD_MULTISAMPLE_2X_QUINCUNX)
            _strip.stripsize = 32;        
        else if (_method == METHOD_MULTISAMPLE_4X_GAUSSIAN)
            _strip.stripsize = 16;
        else  
        {
            _strip.stripsize = pRT->getHeight();
            _bSubdivideAA = false;            
        }
    }
    else 
    {
        if (_method == METHOD_MULTISAMPLE_2X_QUINCUNX)
            _strip.stripsize = 16;
        else 
        {
            _strip.stripsize = pRT->getHeight();
            _bSubdivideAA = false;            
        }
        
    }
    
#ifdef TEST_SUB
    _strip.stripsize = __stripsize;
#endif

    _strip.num_strips =  pRT->getHeight() / _strip.stripsize;
    _strip.remainder = pRT->getHeight() % _strip.stripsize;

    if (_method <= METHOD_MULTISAMPLE_2X_QUINCUNX)
        _strip.swath = NV097_SET_SWATH_WIDTH_V_32;
    else if (_method < METHOD_MULTISAMPLE_4X_GAUSSIAN)
        _strip.swath = NV097_SET_SWATH_WIDTH_V_128;
    else 
        _strip.swath = NV097_SET_SWATH_WIDTH_V_OFF;

    if (_strip.num_strips > 1) 
    {
        if (_method == METHOD_MULTISAMPLE_2X_QUINCUNX)
            _strip.swath = IsMixedModeAA() ? NV097_SET_SWATH_WIDTH_V_16 : NV097_SET_SWATH_WIDTH_V_8;
        else if (IsMixedModeAA()  && (_method == METHOD_MULTISAMPLE_4X_GAUSSIAN))
            _strip.swath = NV097_SET_SWATH_WIDTH_V_16;
    }

#ifdef TEST_SUB
    _strip.swath = __swath;
#endif

    _strip.srcyinc.f = static_cast<float>(_strip.stripsize * BufferBltInfo[dwSimpleMethod].dwSuperBufferScaleY);
    _strip.dstyinc.f = static_cast<float>(_strip.stripsize);
    if (_strip.remainder) 
    {
        _strip.srcyrem.f = static_cast<float>(_strip.remainder * BufferBltInfo[dwSimpleMethod].dwSuperBufferScaleY);         
        _strip.dstyrem.f = static_cast<float>(_strip.remainder);
    }
    float tmp = static_cast<float>(pSRT->getWidth());
    _strip.srcWidth.f = tmp;
    _strip.srcWidth_x0.f = tmp - _strip.x0.f;
    _strip.dstWidth.f = static_cast<float>(pRT->getWidth());

///////////////////////////////////////////////

    // Finally, turn on AA
    SetSampleMask();

    Save();
    
    // start off suspended
    _enabled = 1;

    // for good luck
    if (_pContext) _pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_MISC_STATE | KELVIN_DIRTY_SURFACE | KELVIN_DIRTY_TRANSFORM;

    getDC()->dwAAContextCount++;
}

void CKelvinAAState::Refresh() {
    if (!_enabled || !_pContext) return;

    PNVD3DCONTEXT pContext = _pContext;
    //don't optimize this! FS
    if (IsValid(CKelvinAAState::BUFFER_SRT)) {
        Destroy();
        _invalidRT = true;
    } else {
        Destroy();
    }
    Create(pContext);
}

void CKelvinAAState::Destroy() {
    if (!_pContext) return;
    
    if (getDC()->nvPusher.isValid()) {
        getDC()->nvPusher.flush (TRUE, CPushBuffer::FLUSH_WITH_DELAY);
    }

    //dirty the surface state at least -- do we need to dirty anything else?
    _pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_SURFACE;

    if (_method != SIMPLEMETHOD_1X1) {
        // Eh, we better not destroy these if we don't own them
        if (_bufferInfo[BUFFER_RT].pSurface != _bufferInfo[BUFFER_SRT].pSurface) _bufferInfo[BUFFER_SRT].pSurface->getWrapper()->release();
        if (_bufferInfo[BUFFER_ZB].pSurface != _bufferInfo[BUFFER_SZB].pSurface) _bufferInfo[BUFFER_SZB].pSurface->getWrapper()->release();
    }

    ReCreateZBuffer();

    getDC()->dwAAContextCount--;

    bool badSemantics = _badSemantics; // save this bit of info across destroy calls
    memset(this, 0, sizeof(CKelvinAAState));
    _badSemantics = badSemantics;
}

CSimpleSurface * CKelvinAAState::GetCurrentRT(PNVD3DCONTEXT pContext) {
    _seen3D = true;
    return IsEnabled() ? GetSRT() : pContext->pRenderTarget; 
}

CSimpleSurface * CKelvinAAState::GetCurrentZB(PNVD3DCONTEXT pContext) { 
    _seen3D = true;
    return IsEnabled() ? GetSZB() : pContext->pZetaBuffer; 
}


bool CKelvinAAState::CheckBufferMemoryConfig(PNVD3DCONTEXT pContext) {
    // quick check to see if we have enough memory
    DWORD dwMem = 0;

    if (pContext->pRenderTarget) {
        // 3 bits is really 2 with a filter
        DWORD dwMultiSampleBits = (pContext->pRenderTarget->getMultiSampleBits() == 3) ? 2 : pContext->pRenderTarget->getMultiSampleBits();

        if (dwMultiSampleBits < 2) return true; // no AA

        dwMem += 
            pContext->pRenderTarget->getBPP() * 
            pContext->pRenderTarget->getWidth() * 
            pContext->pRenderTarget->getHeight() *
            dwMultiSampleBits;
    }

    if (pContext->pZetaBuffer) {
        DWORD dwMultiSampleBits = (pContext->pZetaBuffer->getMultiSampleBits() == 3) ? 2 : pContext->pZetaBuffer->getMultiSampleBits();

        if (dwMultiSampleBits < 2) return true; // no AA

        dwMem += 
            pContext->pZetaBuffer->getBPP() * 
            pContext->pZetaBuffer->getWidth() * 
            pContext->pZetaBuffer->getHeight() *
            dwMultiSampleBits;
    }

    // Ensure that we still have 1/4 of frame buffer memory left after all is said and done
    if ((int(getDC()->VideoHeapFree) - int(dwMem)) < int(getDC()->VideoHeapTotal / 4)) return false;

    // multisample settings must match
    if (pContext->pRenderTarget && pContext->pZetaBuffer && 
       (pContext->pRenderTarget->getMultiSampleBits() != pContext->pZetaBuffer->getMultiSampleBits())) return false;

    return true;
}

void CKelvinAAState::TestCreation(PNVD3DCONTEXT pContext) {
    if (!(getDC()->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN)) return;
    
    nvAssert(pContext && getDC());

    if (_pContext) {
        // Already created; destroy if needed
        if (_enabled &&
           ((!(getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_ANTIALIASFORCEENABLE_MASK) &&
             !(pContext->dwRenderState[D3DRENDERSTATE_ANTIALIAS] == D3DANTIALIAS_SORTDEPENDENT) &&
             !(pContext->dwRenderState[D3DRENDERSTATE_ANTIALIAS] == D3DANTIALIAS_SORTINDEPENDENT) &&
             !(_bufferInfo[BUFFER_RT].pSurface->getMultiSampleBits() > 1)  &&
             !(_bufferInfo[BUFFER_ZB].pSurface && (_bufferInfo[BUFFER_ZB].pSurface->getMultiSampleBits() > 1))) ||
             _badSemantics ||
             (_appCompatibility.dwFlags & APPFLAGS_DISABLE_AA))) {
            Destroy();
        }
    } else {
        // Not created; check if we need to
        if (_enabled &&
            !(_appCompatibility.dwFlags & APPFLAGS_DISABLE_AA) &&
            !_badSemantics &&
           ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_ANTIALIASFORCEENABLE_MASK &&
             getDC()->nvD3DRegistryData.regAntiAliasQuality > 0) ||
            (pContext->dwRenderState[D3DRENDERSTATE_ANTIALIAS] == D3DANTIALIAS_SORTDEPENDENT) ||
            (pContext->dwRenderState[D3DRENDERSTATE_ANTIALIAS] == D3DANTIALIAS_SORTINDEPENDENT) ||
            (pContext->pRenderTarget && pContext->pRenderTarget->getMultiSampleBits() > 1))) {
                Create(pContext);
        }
    }

    if (IsEnabled()) {
        CSimpleSurface *pCRT = pContext->pRenderTarget;
        CSimpleSurface *pRT  = _bufferInfo[BUFFER_RT].pSurface;
        CSimpleSurface *pCZB = pContext->pZetaBuffer;
        CSimpleSurface *pZB  = _bufferInfo[BUFFER_ZB].pSurface;
        
        if ((!pCRT != !pRT) || (!pCZB != !pZB) ||
            (pCRT && pRT && (pCRT->getWidth() != pRT->getWidth()) && (pCRT->getHeight() != pRT->getHeight())) ||
            (pCZB && pZB && (pCZB->getWidth() != pZB->getWidth()) && (pCZB->getHeight() != pZB->getHeight()))) {
            Refresh();
        }
    }
}

void CKelvinAAState::Save() 
{
    _bSubdivideAASave = _bSubdivideAA;
    _methodSave = _method;
    _bAAMethodChanged = false;
}

void CKelvinAAState::Restore()
{
    if (_bAAMethodChanged) 
    {
        if ((CURRENT_FLIP - _UpsampleFlip) > 5)
        {
            _bSubdivideAA = _bSubdivideAASave;
            _method = _methodSave;
        }
    
    }
}    


void CKelvinAAState::SetMethod(MethodType method) {
    if (!_pContext) return;

#ifndef SUPERSAMPLE
    if (!(_appCompatibility.dwFlags & APPFLAGS_FORCE_SUPERSAMPLE)) {
        _method = method;
    } else 
#endif
    {
        _method = MethodInfo[method].dwSuperSampledAlternative;
    }

}

DWORD CKelvinAAState::GetAAFormat() {
    return IsEnabled() ? MethodInfo[_method].AASurfaceType : 0; 
}

void CKelvinAAState::Suspend() {
    _enabled = 0;
    if (_pContext) _pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_MISC_STATE | KELVIN_DIRTY_SURFACE | KELVIN_DIRTY_TRANSFORM;
}

void CKelvinAAState::Resume() {
    _enabled = 1;
    if (_pContext) _pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_MISC_STATE | KELVIN_DIRTY_SURFACE | KELVIN_DIRTY_TRANSFORM;
}

void CKelvinAAState::Notify(NotificationType type) {
    if (!_pContext) return;
    // not used yet
    nvAssert(0);
}

void CKelvinAAState::Flip() {
    if (!_pContext) return;

    Resume();

    if (_appCompatibility.dwFlags & APPFLAGS_MAGNIFY_AFTER_FLIP) {
        GrantAccess(BUFFER_RT, ACCESS_WRITE, true);
    } else {
        GrantAccess(BUFFER_RT, ACCESS_READ, true);
    }
}

int CKelvinAAState::IsEnabled() {
    return (_enabled && _pContext && (_method != METHOD_NONE));
}

int CKelvinAAState::IsCreated() {
    return (int)_pContext; 
}

int CKelvinAAState::IsMultisampling() { 
    return (IsEnabled() && MethodInfo[_method].bMultisample);
}

int CKelvinAAState::IsSupersampling() { 
    return (IsEnabled() && MethodInfo[_method].bMultisample);
}

void CKelvinAAState::SetSampleMask() {
    if (!_pContext) return;

    if (_pContext->pRenderTarget->getMultiSampleBits() <= 1) {
        _sampleMask = 0xffff;
    } else {
        _sampleMask = _pContext->dwRenderState[D3DRS_MULTISAMPLEMASK] & 0xf;
        _sampleMask = (_sampleMask << 12) | (_sampleMask << 8) | (_sampleMask << 4) | _sampleMask; // Replicate across four pixels
    }

    DWORD aaControl = _enabled ?
        DRF_DEF(097, _SET_ANTI_ALIASING_CONTROL, _ENABLE, _TRUE) |
        DRF_DEF(097, _SET_ANTI_ALIASING_CONTROL, _ALPHA_TO_COVERAGE, _DISABLE) |
        DRF_DEF(097, _SET_ANTI_ALIASING_CONTROL, _ALPHA_TO_ONE, _DISABLE) |
        DRF_NUM(097, _SET_ANTI_ALIASING_CONTROL, _SAMPLE_MASK, _sampleMask)
        :
        DRF_DEF(097, _SET_ANTI_ALIASING_CONTROL, _ENABLE, _FALSE) |
        DRF_DEF(097, _SET_ANTI_ALIASING_CONTROL, _ALPHA_TO_COVERAGE, _DISABLE) |
        DRF_DEF(097, _SET_ANTI_ALIASING_CONTROL, _ALPHA_TO_ONE, _DISABLE) |
        DRF_NUM(097, _SET_ANTI_ALIASING_CONTROL, _SAMPLE_MASK, 0xffff);

    _pContext->hwState.kelvin.set1(NV097_SET_ANTI_ALIASING_CONTROL, aaControl);
}

void CKelvinAAState::ReCreateZBuffer() {
    
    CSimpleSurface *pZB = _bufferInfo[BUFFER_ZB].pSurface;
    
    if (pZB && !pZB->isValid()) {
//        pZB->recreate(pZB->getBPP());
        pZB->create(pZB->getWrapper(),
            pZB->getFormat(),
            pZB->getWidth(),
            pZB->getHeight(),
            1,
            pZB->getMultiSampleBits(),
            pZB->getBPPRequested(),
            pZB->getBPP(),
            pZB->getBPP() * pZB->getWidth(),
            CSimpleSurface::HEAP_VID,
            CSimpleSurface::HEAP_VID,
            pZB->getAllocFlags()
#ifdef CAPTURE
            ,CAPTURE_SURFACE_KIND_ZETA
#endif          
            );
#ifdef DEBUG_SURFACE_PLACEMENT
        csd.ReCreateZBuffer(pZB);
#endif
#ifdef  STEREO_SUPPORT
            pZB->createStereo();
#endif  //STEREO_SUPPORT
    }
}

PNVD3DCONTEXT CKelvinAAState::GetContext(CSimpleSurface *pSurf) {
    int i;

    PNVD3DCONTEXT pContext = (PNVD3DCONTEXT)getDC()->dwContextListHead;

    while (pContext) {
        if (pSurf == pContext->pZetaBuffer) return pContext;

        for (i=0; i<KELVIN_AA_NUM_FLIP_CHAIN_SLOTS; i++) {
            if (pSurf == pContext->kelvinAA._flipChain[i]) return pContext;
        }

        pContext = pContext->pContextNext;
    }

    return 0;
}


void CKelvinAAState::EndScene() {
#ifdef WINNT
    if (_appCompatibility.dwFlags & APPFLAGS_WRITE_ACCESS_ON_ENDSCENE) {
        GrantAccess(CKelvinAAState::BUFFER_RT, CKelvinAAState::ACCESS_WRITE, TRUE);
    } else
#endif
    {
        GrantAccess(CKelvinAAState::BUFFER_RT, CKelvinAAState::ACCESS_READ, TRUE);
    }
}

void CKelvinAAState::UpdateZBuffer() {
    if (!IsEnabled()) return;

    _bufferInfo[BUFFER_ZB].pSurface = _pContext->pZetaBuffer;
}

void CKelvinAAState::UpdateRenderTarget() {
    if (!IsEnabled()) return;

    CSimpleSurface *pRT = _bufferInfo[BUFFER_RT].pSurface;
    CSimpleSurface *pCRT = _pContext->pRenderTarget;

    if (pCRT && pRT && (pCRT->getWidth() != pRT->getWidth()) && (pCRT->getHeight() != pRT->getHeight())) {
        Refresh();
    }

    _bufferInfo[BUFFER_RT].pSurface = _pContext->pRenderTarget;

    int i;

    for (i=0; i<KELVIN_AA_NUM_FLIP_CHAIN_SLOTS; i++) {
        if (_flipChain[i] == _pContext->pRenderTarget) break;
    }

    if (i == KELVIN_AA_NUM_FLIP_CHAIN_SLOTS) {
        for (i=0; i<KELVIN_AA_NUM_FLIP_CHAIN_SLOTS; i++) if (!_flipChain[i]) break;
        nvAssert(i < KELVIN_AA_NUM_FLIP_CHAIN_SLOTS);
        _flipChain[i] = _pContext->pRenderTarget;
    }
}

void CKelvinAAState::GrantAccess(BufferType buffer, AccessType access, bool bConvolve, bool bFlush) {
#ifdef DEBUG
    nvAssert(buffer < BUFFER_MAX);
    nvAssert(access < ACCESS_MAX);
    DPF_LEVEL(NVDBG_LEVEL_AA_INFO, 
        "CKelvinAAState::GrantAccess(%s, %s), address: %x   %d%d %d%d", 
        BufferTypeNames[buffer], 
        AccessTypeNames[access],
	_bufferInfo[buffer].pSurface,
        !!(_bufferInfo[BUFFER_RT].flags & FLAGS_VALID),
        !!(_bufferInfo[BUFFER_SRT].flags & FLAGS_VALID),
        !!(_bufferInfo[BUFFER_ZB].flags & FLAGS_VALID),
        !!(_bufferInfo[BUFFER_SZB].flags & FLAGS_VALID));
#endif

    // Return if AA is not on
    if (!IsEnabled()) return;
    
    //exit GrantAccess if we have recursed here.
    if (InGrantAccess()) return;
    EnterGrantAccess();

    nvAssert(buffer < BUFFER_MAX);
    nvAssert(access < ACCESS_MAX);

    UpdateRenderTarget();

    BufferType other = _bufferInfo[buffer].other;

    if ((access == ACCESS_WRITE) &&
        _lastDownsampleUsedConvolution &&
        (buffer == BUFFER_RT)) {
        // superbuffer better be valid
        nvAssert(_bufferInfo[other].flags & FLAGS_VALID);
        _bufferInfo[buffer].flags &= ~FLAGS_VALID;
        _appCompatibility.dwFlags |= APPFLAGS_DISABLE_DITHER;
    }

    // We deallocated the normal Z buffer for performance reasons
    // If we desire access, then we have to reallocate it.
    CSimpleSurface *pZB = _bufferInfo[BUFFER_ZB].pSurface;
    if (buffer == BUFFER_ZB) ReCreateZBuffer();

    //at aa creation time, the z buffer was disabled. later, the app
    //enabled it and now we have to write to the super z, so create one.
    if (_bufferInfo[BUFFER_ZB].pSurface && !_bufferInfo[BUFFER_SZB].pSurface && buffer == BUFFER_SZB)
    {
        const BufferBltInfoStruct *bltInfo = &BufferBltInfo[MethodInfo[_method].type];

        if (!(_bufferInfo[BUFFER_SZB].pSurface = new CSimpleSurface())) {
            Destroy();
            ExitGrantAccess();
            return;
        }

        DWORD dwPitch = pZB->getWidth() * bltInfo->dwSuperBufferScaleX * pZB->getBPP();
        dwPitch = (dwPitch + getDC()->dwSurfaceAlignPad) & ~getDC()->dwSurfaceAlignPad;
        
        if (!_bufferInfo[BUFFER_SZB].pSurface->create(NULL,
            pZB->getFormat(),
            pZB->getWidth()  * bltInfo->dwSuperBufferScaleX,
            pZB->getHeight() * bltInfo->dwSuperBufferScaleY,
            pZB->getDepth(),
            1,
            pZB->getBPPRequested(),
            pZB->getBPP(),
            dwPitch,
            CSimpleSurface::HEAP_VID,
            CSimpleSurface::HEAP_VID,
            CSimpleSurface::ALLOCATE_TILED | CSimpleSurface::ALLOCATE_AS_ZBUFFER_CMP
#ifdef CAPTURE
            ,CAPTURE_SURFACE_KIND_ZETA
#endif
            ))
        {
            Destroy();
            ExitGrantAccess();
            return;
        }
#ifdef  STEREO_SUPPORT
        _bufferInfo[BUFFER_SZB].pSurface->createStereo();
#endif  //STEREO_SUPPORT
        CNvObject *pWrapper = new CNvObject(0);
        pWrapper->setObject(CNvObject::NVOBJ_SIMPLESURFACE, (void *)_bufferInfo[BUFFER_SZB].pSurface);
        _bufferInfo[BUFFER_SZB].pSurface->setWrapper(pWrapper);
    }
    
    switch (access) {
    case ACCESS_READ:
        if (!(_bufferInfo[buffer].flags & FLAGS_VALID)) {
            ScaledBlt(buffer, other, bConvolve, bFlush);
            _bufferInfo[buffer].flags |= FLAGS_VALID;
        }

        break;
    case ACCESS_WRITE:
        if (!(_bufferInfo[buffer].flags & FLAGS_VALID)) {
            // we never want to give write access to a blur filtered buffer
            ScaledBlt(buffer, other, bConvolve, bFlush);
            _bufferInfo[buffer].flags |= FLAGS_VALID;
        }
        _bufferInfo[other].flags &= ~FLAGS_VALID;

        break;
    case ACCESS_WRITE_DISCARD:
        // Don't have to perform any blts; we don't care about the results
        _bufferInfo[buffer].flags |= FLAGS_VALID;
        _bufferInfo[other].flags &= ~FLAGS_VALID;

        break;
    default:
        DPF("Invalid access type in CKelvinAAState::GrantAccess()");
        nvAssert(0);

        break;
    };

    ExitGrantAccess();
    return;
}

void CKelvinAAState::ScaledBlt(BufferType dst, BufferType src, bool bConvolve, bool bFlush) {
    DPF_LEVEL(NVDBG_LEVEL_AA_INFO, "CKelvinAAState::ScaledBlt(%s, %s)", BufferTypeNames[dst], BufferTypeNames[src]);
    nvAssert(_enabled && _pContext);

    BufferInfo *dstInfo = &_bufferInfo[dst];
    BufferInfo *srcInfo = &_bufferInfo[src];
    const BufferBltInfoStruct *bltInfo = &BufferBltInfo[MethodInfo[src].type];

    BufferInfo *tempInfo = (bltInfo->dwScratchBufferScaleX) ? &_bufferInfo[BUFFER_SCRATCH] : 0;

    bConvolve = bConvolve && MethodInfo[_method].dwKernel; // and out the filter if we're not using convolution

    if (!srcInfo->pSurface || !dstInfo->pSurface) return;
    if (_method == SIMPLEMETHOD_1X1) return;

    nvAssert(dstInfo->pSurface);
    nvAssert(srcInfo->pSurface);

    DWORD dwMethod = _method;
    bool bSubdivideAA = (bool)_bSubdivideAA;
    bool bDither = !(_appCompatibility.dwFlags & APPFLAGS_DISABLE_DITHER);
    bool bZBuffer = (src == BUFFER_ZB) || (src == BUFFER_SZB);

    if ((dstInfo->pSurface->getWidth() < srcInfo->pSurface->getWidth()) ||
        (dstInfo->pSurface->getHeight() < srcInfo->pSurface->getHeight())) {
        if (!bZBuffer) {
            if (_didUpsample) {
                bDither = false;
                _didUpsample = false;
            }
    
            if (bConvolve) {
                _lastDownsampleUsedConvolution = true;
            } else {
                _lastDownsampleUsedConvolution = false;
                dwMethod = MethodInfo[_method].dwBoxFilteredAlternative;
            }
        }
    } else {
        // upsampling
        bSubdivideAA = false;
        bDither = false;
        _didUpsample = true;
        dwMethod = MethodInfo[_method].dwBoxFilteredAlternative;
    }

    if (!tempInfo) {
#ifndef SCALED_IMAGE
#ifdef  STEREO_SUPPORT
        if (STEREO_ACTIVATED)
        {
			//We can't mess up the pStereoData->dwLastEye or use SetupStereoContext
			//for that matter. Those are higher level primitives.
			DWORD dwLastEye = pStereoData->dwLastEye;
			pStereoData->dwLastEye = EYE_LEFT;
            ImageModeTexBlt(dstInfo->pSurface, srcInfo->pSurface, dwMethod, bSubdivideAA, bDither, bFlush);
            pStereoData->dwLastEye = EYE_RIGHT;
            ImageModeTexBlt(dstInfo->pSurface, srcInfo->pSurface, dwMethod, bSubdivideAA, bDither, bFlush);
			pStereoData->dwLastEye = dwLastEye;
        } else
            ImageModeTexBlt(dstInfo->pSurface, srcInfo->pSurface, dwMethod, bSubdivideAA, bDither, bFlush);
#else   //STEREO_SUPPORT==0
        ImageModeTexBlt(dstInfo->pSurface, srcInfo->pSurface, dwMethod, bSubdivideAA, bDither, bFlush);
#endif  //STEREO_SUPPORT
#else
        DWORD dstWidth  = dstInfo->pSurface->getWidth();
        DWORD dstHeight = dstInfo->pSurface->getHeight();
        DWORD srcWidth  = srcInfo->pSurface->getWidth();
        DWORD srcHeight = srcInfo->pSurface->getHeight();
        
        if (dstWidth >= 1024) {
            nvAssert(!(dstWidth & 0x1));
            
            ScaledBlt(
                dstInfo->pSurface, 0, 0, dstWidth/2, dstInfo->pSurface->getHeight(), 
                srcInfo->pSurface, bltInfo->fDownscaleOffsetX1, bltInfo->fDownscaleOffsetY1, srcWidth/2, srcInfo->pSurface->getHeight() 
                );
            ScaledBlt(
                dstInfo->pSurface, dstWidth/2, 0, dstWidth/2, dstInfo->pSurface->getHeight(), 
                srcInfo->pSurface, bltInfo->fDownscaleOffsetX1+(srcWidth/2), bltInfo->fDownscaleOffsetY1, srcWidth/2, srcInfo->pSurface->getHeight() 
                );
        } else {
            ScaledBlt(
                dstInfo->pSurface, 0, 0, dstInfo->pSurface->getWidth(), dstInfo->pSurface->getHeight(), 
                srcInfo->pSurface, bltInfo->fDownscaleOffsetX1, bltInfo->fDownscaleOffsetY1, srcInfo->pSurface->getWidth(), srcInfo->pSurface->getHeight() 
                );
        }
#endif
    } else {
        nvAssert(0);
        // We don't handle this case yet
    }
}

void CKelvinAAState::ImageModeTexBlt(
    CSimpleSurface *pDst, 
    CSimpleSurface *pSrc,
    DWORD dwMethod,
    bool bSubdivideAA,
    bool bDither,
    bool bFlush
) {
    DWORD i;
    DWORD dwSimpleMethod = MethodInfo[dwMethod].type;
    DWORD dwSrcFormat = pSrc->getFormat();
    DWORD dwDstFormat = pDst->getFormat();
    bool bZBuffer = false;

    if (!_bInitializedState) {
        _pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_REALLY_FILTHY;
        nvSetKelvinState(_pContext);
	    // THIS IS KIND OF UGLY NOW because we moved the GrantAccess call into nvSetKelvinState
	    // thus ImageModeTexBlt could call itself recursively.  Make sure you set _bInitializedState=true
	    // BEFORE calling nvSetKelvinState here or you will fall into an infinite loop
        _bInitializedState = true;	//<------------------- DO NOT DELETE
    }

    bool bUpscaling = (pDst->getWidth() > pSrc->getWidth()) || (pDst->getHeight() > pSrc->getHeight());


    // Spoof the src format
    switch (dwSrcFormat) {
    case NV_SURFACE_FORMAT_Z16:
        bZBuffer = true;
        bDither = false;
    case NV_SURFACE_FORMAT_R5G6B5:
    case NV_SURFACE_FORMAT_IMAGE_R5G6B5:
        dwSrcFormat = NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R5G6B5;
        break;
    case NV_SURFACE_FORMAT_Z24S8:
    case NV_SURFACE_FORMAT_Z24X8:
        bZBuffer = true;
        bDither = false;
    case NV_SURFACE_FORMAT_X8R8G8B8:
    case NV_SURFACE_FORMAT_A8R8G8B8:
    case NV_SURFACE_FORMAT_IMAGE_A8R8G8B8:
        dwSrcFormat = NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8R8G8B8;
        break;
    default:
        // Invalid surface format
        nvAssert(0);
        return;
    }

    // Spoof the dst format
    switch (dwDstFormat) {
    case NV_SURFACE_FORMAT_X1R5G5B5:
        dwDstFormat = NV097_SET_SURFACE_FORMAT_COLOR_LE_X1R5G5B5_Z1R5G5B5;
        break;
    case NV_SURFACE_FORMAT_Z16:
    case NV_SURFACE_FORMAT_R5G6B5:
    case NV_SURFACE_FORMAT_IMAGE_R5G6B5:
        dwDstFormat = NV097_SET_SURFACE_FORMAT_COLOR_LE_R5G6B5;
        break;
    case NV_SURFACE_FORMAT_Z24S8:
    case NV_SURFACE_FORMAT_Z24X8:
    case NV_SURFACE_FORMAT_X8R8G8B8:
    case NV_SURFACE_FORMAT_A8R8G8B8:
    case NV_SURFACE_FORMAT_IMAGE_A8R8G8B8:
        dwDstFormat = NV097_SET_SURFACE_FORMAT_COLOR_LE_A8R8G8B8;
        break;
    case NV_SURFACE_FORMAT_X1A7R8G8B8:
        dwDstFormat = NV097_SET_SURFACE_FORMAT_COLOR_LE_X1A7R8G8B8_Z1A7R8G8B8;
        break;
    default:
        // don't worry, we're not catching all the cases
        break;
    }


    struct filterTypeStruct {
        bool bEmulateFilter;
        DWORD dwNumTextures;

        struct {
            float fXOffset;
            float fYOffset;
        } texStageInfo[4];

        DWORD dwNumCombinerStages;

        struct {
            DWORD dwICW;
            DWORD dwOCW;
            DWORD dwFactor0;
            DWORD dwFactor1;
        } combinerInfo[4];
    };

    float fCenterContrib = 0.25; // Contribution of center texel in Gaussian filter.
    float fSqrtCenterContrib = float(sqrt(fCenterContrib));

    DWORD dwCombinerCountInc = 0;

#ifdef _16_BIT_FIX
    if ((pSrc->getBPP() == 2) && !bUpscaling && bDither) dwCombinerCountInc = 1;
#endif

    static const filterTypeStruct filterType[] = {
        {   // ordinary filter - box, standard gaussian, standard quincunx
            false,
            1, 
            {{0.0, 0.0},
             {0.0, 0.0},
             {0.0, 0.0},
             {0.0, 0.0}},
            1+dwCombinerCountInc, 
            {{0x08200000, 0x00000c00, 0x00000000, 0x00000000},
             {0x0c010000, 0x00000c00, 0x00f7fbf7, 0x00000000},
             {0x00000000, 0x00000000, 0x00000000, 0x00000000},
             {0x00000000, 0x00000000, 0x00000000, 0x00000000}}
        }, { // emulated gaussian
            true,
            4, 
            {{-1+fSqrtCenterContrib, -1+fSqrtCenterContrib},
             { 1-fSqrtCenterContrib, -1+fSqrtCenterContrib},
             {-1+fSqrtCenterContrib,  1-fSqrtCenterContrib},
             { 1-fSqrtCenterContrib,  1-fSqrtCenterContrib}},
            3+dwCombinerCountInc, 
            {{0x08010902, 0x00000C00, 0x7f7f7f7f, 0x7f7f7f7f},
             {0x0c010a02, 0x00000C00, 0x7f7f7f7f, 0x3f3f3f3f},
             {0x0c010b02, 0x00000C00, 0xffffffff, 0x3f3f3f3f},
             {0x0c010000, 0x00000c00, 0x00f7fbf7, 0x00000000}}
        
        },  { //9 tap emulated gaussian 
            true,
            4, 
            {{0.66+0.5, 0.5+0.5},  //.75 8
             {1.33+0.5, 0.5+0.5},  //.75 9
             {0+0.5   , 1.5+0.5},  //.25 a
             {2+0.5   , 1.5+0.5}}, //.25 b
            4, 
            {{0x48014a02, 0x00000c00, 0xBFBFBFBF, 0x3f3f3f3f},
             {0x49014b02, 0x00000d00, 0xBFBFBFBF, 0x3f3f3f3f},
             {0xcc01cd02, 0x00000C00, 0x7f7f7f7f, 0x7f7f7f7f},
             {0xcc01c102, 0x00000C00, 0x7f7f7f7f, 0xFFFFFFFF}}
        },  { //
            true,
            2, 
            {{0.5,      0.0},
             {-0.5,      0.5},
             {0.0,      0.0},
             {0.0,      0.0}},
            1+dwCombinerCountInc, 
            {{0x08010902, 0x00000c00, 0x80808080, 0x7f7f7f7f},
             {0x0c010000, 0x00000c00, 0x00f7fbf7, 0x00000000},
             {0x00000000, 0x00000000, 0x00000000, 0x00000000},
             {0x00000000, 0x00000000, 0x00000000, 0x00000000}}
        }
    };
    
    DWORD dwFilterType;

    switch (dwMethod) {
//    case METHOD_MULTISAMPLE_2X_QUINCUNX:       dwFilterType = 3;   break;
    case METHOD_MULTISAMPLE_4X_ROTATED_8TAP:   dwFilterType = 2;   break;
    default:                                   dwFilterType = 0;   break; 
    }

    DWORD dwShaderStageProgram = 0;
    for (i=0; i<filterType[dwFilterType].dwNumTextures; i++) {
        dwShaderStageProgram |= DRF_DEF(097, _SET_SHADER_STAGE_PROGRAM, _STAGE0, _2D_PROJECTIVE) << (5*i);
    }

    _pContext->hwState.kelvin.set1(NV097_SET_SHADER_STAGE_PROGRAM, dwShaderStageProgram);

    _pContext->hwState.kelvin.set1(NV097_SET_DOT_RGBMAPPING,
        DRF_DEF(097, _SET_DOT_RGBMAPPING, _STAGE1, _ZERO_TO_1) |
        DRF_DEF(097, _SET_DOT_RGBMAPPING, _STAGE2, _ZERO_TO_1) |
        DRF_DEF(097, _SET_DOT_RGBMAPPING, _STAGE3, _ZERO_TO_1));

#ifdef SUBDIVIDE_AA
    _pContext->hwState.kelvin.set1(NV097_SET_SWATH_WIDTH, _strip.swath);
#else
    if (dwMethod <= METHOD_MULTISAMPLE_2X_QUINCUNX)
        _pContext->hwState.kelvin.set1(NV097_SET_SWATH_WIDTH, NV097_SET_SWATH_WIDTH_V_32);
    else if (dwMethod < METHOD_MULTISAMPLE_4X_GAUSSIAN)
        _pContext->hwState.kelvin.set1(NV097_SET_SWATH_WIDTH, NV097_SET_SWATH_WIDTH_V_128);
    else 
        _pContext->hwState.kelvin.set1(NV097_SET_SWATH_WIDTH, NV097_SET_SWATH_WIDTH_V_OFF);
#endif

    // dithering
    _pContext->hwState.kelvin.set1(NV097_SET_DITHER_ENABLE, bDither ? NV097_SET_DITHER_ENABLE_V_TRUE : NV097_SET_DITHER_ENABLE_V_FALSE);

    _pContext->hwState.kelvin.set1(NV097_SET_SHADER_CLIP_PLANE_MODE, 0);
    _pContext->hwState.kelvin.set1(NV097_SET_SHADER_OTHER_STAGE_INPUT, 0);
    _pContext->hwState.kelvin.set1(NV097_SET_FLAT_SHADE_OP, NV097_SET_FLAT_SHADE_OP_V_LAST_VTX);
    _pContext->hwState.kelvin.set1(NV097_SET_LOGIC_OP_ENABLE, NV097_SET_LOGIC_OP_ENABLE_V_FALSE);
    _pContext->hwState.kelvin.set1(NV097_SET_ZMIN_MAX_CONTROL,
        DRF_DEF(097, _SET_ZMIN_MAX_CONTROL, _CULL_IGNORE_W, _TRUE)   |
        DRF_DEF(097, _SET_ZMIN_MAX_CONTROL, _ZCLAMP_EN, _CLAMP)      |
        DRF_DEF(097, _SET_ZMIN_MAX_CONTROL, _CULL_NEAR_FAR_EN, _FALSE));

    _pContext->hwState.kelvin.set1(NV097_SET_ANTI_ALIASING_CONTROL, (0xFFFF0000) | NV097_SET_ANTI_ALIASING_CONTROL_ENABLE_FALSE);
    _pContext->hwState.kelvin.set1(NV097_SET_COMPRESS_ZBUFFER_EN, NV097_SET_COMPRESS_ZBUFFER_EN_V_DISABLE);
    _pContext->hwState.kelvin.set1(NV097_SET_OCCLUDE_ZSTENCIL_EN, NV097_SET_OCCLUDE_ZSTENCIL_EN_OCCLUDE_ZEN_DISABLE);
    _pContext->hwState.kelvin.set1(NV097_SET_TWO_SIDE_LIGHT_EN, NV097_SET_TWO_SIDE_LIGHT_EN_V_FALSE);
    _pContext->hwState.kelvin.set1(NV097_SET_ZPASS_PIXEL_COUNT_ENABLE, NV097_SET_ZPASS_PIXEL_COUNT_ENABLE_V_FALSE);

    // deactivate all but the first clip rectangle
    for (DWORD dwWindow=1; dwWindow < KELVIN_NUM_WINDOWS; dwWindow++) {
        _pContext->hwState.kelvin.set1 (NV097_SET_WINDOW_CLIP_HORIZONTAL(dwWindow), 0);
        _pContext->hwState.kelvin.set1 (NV097_SET_WINDOW_CLIP_VERTICAL(dwWindow), 0);
    }


    _pContext->hwState.kelvin.set1 (NV097_SET_WINDOW_CLIP_HORIZONTAL(0), 
        DRF_NUM(097, _SET_WINDOW_CLIP_HORIZONTAL, _XMIN, 0) |
        DRF_NUM(097, _SET_WINDOW_CLIP_HORIZONTAL, _XMAX, pDst->getWidth()-1));

    _pContext->hwState.kelvin.set1 (NV097_SET_WINDOW_CLIP_VERTICAL(0), 
        DRF_NUM(097, _SET_WINDOW_CLIP_VERTICAL, _YMIN, 0) |
        DRF_NUM(097, _SET_WINDOW_CLIP_VERTICAL, _YMAX, pDst->getHeight()-1));

    ////////////////////////////////////////

    _pContext->hwState.kelvin.set8(NV097_SET_VERTEX_DATA_ARRAY_OFFSET(0), 0, 0, 0, 0, 0, 0, 0, 0);
    _pContext->hwState.kelvin.set8(NV097_SET_VERTEX_DATA_ARRAY_OFFSET(8), 0, 8, 16, 24, 32, 0, 0, 0);

    _pContext->hwState.kelvin.set8(NV097_SET_VERTEX_DATA_ARRAY_FORMAT(0),
        DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _2)        | DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F),
        DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _DISABLED) | DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F),
        DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _DISABLED) | DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F),
        DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _DISABLED) | DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F),
        DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _DISABLED) | DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F),
        DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _DISABLED) | DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F),
        DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _DISABLED) | DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F),
        DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _DISABLED) | DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F));

    _pContext->hwState.kelvin.set8(NV097_SET_VERTEX_DATA_ARRAY_FORMAT(8),
        DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _DISABLED) | DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F),
        DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _2)        | DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F),
        DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _2)        | DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F),
        DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _2)        | DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F),
        DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _2)        | DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F),
        DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _DISABLED) | DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F),
        DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _DISABLED) | DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F),
        DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _DISABLED) | DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F));

    _pContext->hwState.kelvin.set1(NV097_SET_CULL_FACE_ENABLE, NV097_SET_CULL_FACE_ENABLE_V_FALSE);

    /////////////////////////////////////////////////////

    DWORD dwFormat = DRF_NUM(097, _SET_SURFACE_FORMAT, _COLOR, dwDstFormat);

    if (pDst->isSwizzled()) {
        CTexture* pTexture = pDst->getWrapper()->getTexture();
        nvAssert(pTexture);
        dwFormat |= DRF_DEF(097, _SET_SURFACE_FORMAT, _TYPE, _SWIZZLE);
        dwFormat |= DRF_NUM(097, _SET_SURFACE_FORMAT, _WIDTH,  pTexture->getLogWidth());
        dwFormat |= DRF_NUM(097, _SET_SURFACE_FORMAT, _HEIGHT, pTexture->getLogHeight());
    } else {
        dwFormat |= DRF_DEF(097, _SET_SURFACE_FORMAT, _TYPE, _PITCH);
    }

    dwFormat |= DRF_NUM(097, _SET_SURFACE_FORMAT, _ZETA, 
        (pDst->getBPP() == 2) ? NV097_SET_SURFACE_FORMAT_ZETA_Z16 : NV097_SET_SURFACE_FORMAT_ZETA_Z24S8);

    _pContext->hwState.kelvin.set3(NV097_SET_SURFACE_PITCH,
                                 (DRF_NUM (097, _SET_SURFACE_PITCH, _COLOR, pDst->getPitch()) |
                                  DRF_NUM (097, _SET_SURFACE_PITCH, _ZETA, KELVIN_ALIGNMENT_MIN)),
#ifdef  STEREO_SUPPORT
                                  GetStereoOffset(pDst),
#else   //STEREO_SUPPORT==0
                                  pDst->getOffset(),
#endif  //STEREO_SUPPORT
                                  0);

    _pContext->hwState.kelvin.set1 (NV097_SET_SURFACE_FORMAT, dwFormat);

    _pContext->hwState.kelvin.set2 (NV097_SET_SURFACE_CLIP_HORIZONTAL,
        DRF_NUM(097, _SET_SURFACE_CLIP_HORIZONTAL, _X, 0) |
        DRF_NUM(097, _SET_SURFACE_CLIP_HORIZONTAL, _WIDTH, pDst->getWidth()),
        DRF_NUM(097, _SET_SURFACE_CLIP_VERTICAL, _Y, 0) |
        DRF_NUM(097, _SET_SURFACE_CLIP_VERTICAL, _HEIGHT, pDst->getHeight()));

    ///////////////////////////////////////////////////////

    for (i=0; i<filterType[dwFilterType].dwNumTextures; i++) {
        _pContext->hwState.kelvin.set1(NV097_SET_TEXTURE_FORMAT(i),
            DRF_NUM(097, _SET_TEXTURE_FORMAT, _MIPMAP_LEVELS, 1)                               |
            DRF_NUM(097, _SET_TEXTURE_FORMAT, _COLOR, dwSrcFormat)                             |
            DRF_DEF(097, _SET_TEXTURE_FORMAT, _DIMENSIONALITY, _TWO)                           |
            DRF_DEF(097, _SET_TEXTURE_FORMAT, _BORDER_SOURCE, _COLOR)                          |
            DRF_DEF(097, _SET_TEXTURE_FORMAT, _CUBEMAP_ENABLE, _FALSE)                         |
            DRF_NUM(097, _SET_TEXTURE_FORMAT, _CONTEXT_DMA, nv097TextureContextDma[pSrc->getContextDMA()]));

        _pContext->hwState.kelvin.set1(NV097_SET_TEXTURE_CONTROL0(i),
            DRF_DEF(097, _SET_TEXTURE_CONTROL0, _ENABLE, _TRUE)              |
            DRF_NUM(097, _SET_TEXTURE_CONTROL0, _MIN_LOD_CLAMP, 0)           |
            DRF_NUM(097, _SET_TEXTURE_CONTROL0, _MAX_LOD_CLAMP, 0)           |
            DRF_DEF(097, _SET_TEXTURE_CONTROL0, _LOG_MAX_ANISO, _0)          |
            DRF_DEF(097, _SET_TEXTURE_CONTROL0, _IMAGE_FIELD_ENABLE, _FALSE) |
            DRF_DEF(097, _SET_TEXTURE_CONTROL0, _ALPHA_KILL_ENABLE, _FALSE)  |
            DRF_DEF(097, _SET_TEXTURE_CONTROL0, _COLOR_KEY_OPERATION, _FALSE));

        _pContext->hwState.kelvin.set1(NV097_SET_TEXTURE_CONTROL1(i),
            DRF_NUM(097, _SET_TEXTURE_CONTROL1, _IMAGE_PITCH, pSrc->getPitch()));

        _pContext->hwState.kelvin.set1(NV097_SET_TEXTURE_ADDRESS(i),
            DRF_DEF(097, _SET_TEXTURE_ADDRESS, _CYLWRAP_Q, _FALSE) |
            DRF_DEF(097, _SET_TEXTURE_ADDRESS, _CYLWRAP_P, _FALSE) |
            DRF_DEF(097, _SET_TEXTURE_ADDRESS, _CYLWRAP_V, _FALSE) |
            DRF_DEF(097, _SET_TEXTURE_ADDRESS, _CYLWRAP_U, _FALSE) |
            DRF_DEF(097, _SET_TEXTURE_ADDRESS, _U, _CLAMP_TO_EDGE) |
            DRF_DEF(097, _SET_TEXTURE_ADDRESS, _V, _CLAMP_TO_EDGE) |
            DRF_DEF(097, _SET_TEXTURE_ADDRESS, _P, _CLAMP_TO_EDGE));
        
        if (bUpscaling || bZBuffer) {
            // We're upscaling
            _pContext->hwState.kelvin.set1(NV097_SET_TEXTURE_FILTER(i),
                DRF_DEF(097, _SET_TEXTURE_FILTER, _BSIGNED, _BIT_DISABLED) |
                DRF_DEF(097, _SET_TEXTURE_FILTER, _GSIGNED, _BIT_DISABLED) |
                DRF_DEF(097, _SET_TEXTURE_FILTER, _RSIGNED, _BIT_DISABLED) |
                DRF_DEF(097, _SET_TEXTURE_FILTER, _ASIGNED, _BIT_DISABLED) |
                DRF_DEF(097, _SET_TEXTURE_FILTER, _MAG, _BOX_LOD0)         |
                DRF_DEF(097, _SET_TEXTURE_FILTER, _MIN, _BOX_LOD0)         |
                DRF_DEF(097, _SET_TEXTURE_FILTER, _CONVOLUTION_KERNEL, _GAUSSIAN_3));
        } else if (MethodInfo[dwMethod].dwKernel && !filterType[dwFilterType].bEmulateFilter) {
            _pContext->hwState.kelvin.set1(NV097_SET_TEXTURE_FILTER(i),
                DRF_DEF(097, _SET_TEXTURE_FILTER, _BSIGNED, _BIT_DISABLED)    |
                DRF_DEF(097, _SET_TEXTURE_FILTER, _GSIGNED, _BIT_DISABLED)    |
                DRF_DEF(097, _SET_TEXTURE_FILTER, _RSIGNED, _BIT_DISABLED)    |
                DRF_DEF(097, _SET_TEXTURE_FILTER, _ASIGNED, _BIT_DISABLED)    |
                DRF_DEF(097, _SET_TEXTURE_FILTER, _MAG, _CONVOLUTION_2D_LOD0) |
                DRF_DEF(097, _SET_TEXTURE_FILTER, _MIN, _CONVOLUTION_2D_LOD0) |
                DRF_NUM(097, _SET_TEXTURE_FILTER, _CONVOLUTION_KERNEL, MethodInfo[dwMethod].dwKernel));
        } else {
            // We're downscaling
            _pContext->hwState.kelvin.set1(NV097_SET_TEXTURE_FILTER(i),
                DRF_DEF(097, _SET_TEXTURE_FILTER, _BSIGNED, _BIT_DISABLED) |
                DRF_DEF(097, _SET_TEXTURE_FILTER, _GSIGNED, _BIT_DISABLED) |
                DRF_DEF(097, _SET_TEXTURE_FILTER, _RSIGNED, _BIT_DISABLED) |
                DRF_DEF(097, _SET_TEXTURE_FILTER, _ASIGNED, _BIT_DISABLED) |
                DRF_DEF(097, _SET_TEXTURE_FILTER, _MAG, _TENT_LOD0)        |
                DRF_DEF(097, _SET_TEXTURE_FILTER, _MIN, _TENT_LOD0)        |
                DRF_DEF(097, _SET_TEXTURE_FILTER, _CONVOLUTION_KERNEL, _GAUSSIAN_3));
        }
    
#ifdef  STEREO_SUPPORT
        _pContext->hwState.kelvin.set1(NV097_SET_TEXTURE_OFFSET(i), GetStereoOffset(pSrc));
#else   //STEREO_SUPPORT==0
        _pContext->hwState.kelvin.set1(NV097_SET_TEXTURE_OFFSET(i), pSrc->getOffset());
#endif  //STEREO_SUPPORT

        // we subtract the X and Y scaling factors here, then c
//        _pContext->hwState.kelvin.set1(NV097_SET_TEXTURE_IMAGE_RECT(i), 
//            DRF_NUM(097, _SET_TEXTURE_IMAGE_RECT, _WIDTH, pSrc->getWidth()-BufferBltInfo[dwSimpleMethod].dwSuperBufferScaleX) |
//            DRF_NUM(097, _SET_TEXTURE_IMAGE_RECT, _HEIGHT, pSrc->getHeight()-BufferBltInfo[dwSimpleMethod].dwSuperBufferScaleY));
        _pContext->hwState.kelvin.set1(NV097_SET_TEXTURE_IMAGE_RECT(i), 
            DRF_NUM(097, _SET_TEXTURE_IMAGE_RECT, _WIDTH, pSrc->getWidth()) |
            DRF_NUM(097, _SET_TEXTURE_IMAGE_RECT, _HEIGHT, pSrc->getHeight()));

        _pContext->hwState.kelvin.set4(NV097_SET_TEXGEN_S(i),
            NV097_SET_TEXGEN_S_V_DISABLE,
            NV097_SET_TEXGEN_T_V_DISABLE,
            NV097_SET_TEXGEN_R_V_DISABLE,
            NV097_SET_TEXGEN_Q_V_DISABLE);

        _pContext->hwState.kelvin.set1(NV097_SET_TEXTURE_MATRIX_ENABLE(i), 
            DRF_DEF(097, _SET_TEXTURE_MATRIX_ENABLE, _V, _FALSE));
    }


    ///////////////////////////////////////////////////////

    _pContext->hwState.kelvin.set1(NV097_SET_LIGHTING_ENABLE, NV097_SET_LIGHTING_ENABLE_V_FALSE);
    _pContext->hwState.kelvin.set1(NV097_SET_DEPTH_TEST_ENABLE, NV097_SET_DEPTH_TEST_ENABLE_V_FALSE);
    _pContext->hwState.kelvin.set2(NV097_SET_FRONT_POLYGON_MODE, NV097_SET_FRONT_POLYGON_MODE_V_FILL, NV097_SET_BACK_POLYGON_MODE_V_FILL);
    _pContext->hwState.kelvin.set1(NV097_SET_BLEND_ENABLE, NV097_SET_BLEND_ENABLE_V_FALSE);
    _pContext->hwState.kelvin.set1(NV097_SET_ALPHA_TEST_ENABLE, NV097_SET_ALPHA_TEST_ENABLE_V_FALSE);
    _pContext->hwState.kelvin.set1(NV097_SET_STENCIL_TEST_ENABLE, NV097_SET_STENCIL_TEST_ENABLE_V_FALSE);
    _pContext->hwState.kelvin.set1(NV097_SET_FOG_ENABLE, NV097_SET_FOG_ENABLE_V_FALSE);
#ifdef KPFS
    getDC()->nvKelvinPM.download_special(_pContext,&_program,0xFFFFFFFE);
#else
    _pContext->hwState.kelvin.set1(NV097_SET_TRANSFORM_EXECUTION_MODE,
         DRF_DEF(097, _SET_TRANSFORM_EXECUTION_MODE, _MODE, _PROGRAM) |
         DRF_DEF(097, _SET_TRANSFORM_EXECUTION_MODE, _RANGE_MODE, _PRIV));

    _pContext->hwState.kelvin.set1(NV097_SET_TRANSFORM_PROGRAM_CXT_WRITE_EN,
         DRF_DEF(097, _SET_TRANSFORM_PROGRAM_CXT_WRITE_EN, _V, _READ_ONLY));

    nvKelvinDownloadProgram(_pContext, &_program,0);

    _pContext->hwState.kelvin.set1 (NV097_SET_TRANSFORM_PROGRAM_START, 0);
#endif
    _pContext->hwState.kelvin.set1(NV097_INVALIDATE_VERTEX_CACHE_FILE, 0);

    /////////////////////////////////////////////////////////

    _pContext->hwState.kelvin.set1 (NV097_SET_COMBINER_CONTROL, 
        DRF_NUM(097, _SET_COMBINER_CONTROL, _ITERATION_COUNT, filterType[dwFilterType].dwNumCombinerStages)         |
        DRF_DEF(097, _SET_COMBINER_CONTROL, _MUX_SELECT, _LSB)           |
        DRF_DEF(097, _SET_COMBINER_CONTROL, _FACTOR0, _EACH_STAGE)       |
        DRF_DEF(097, _SET_COMBINER_CONTROL, _FACTOR1, _EACH_STAGE));

    for (i=0; i<filterType[dwFilterType].dwNumCombinerStages; i++) {
        _pContext->hwState.kelvin.set1 (NV097_SET_COMBINER_COLOR_ICW(i), filterType[dwFilterType].combinerInfo[i].dwICW);
        _pContext->hwState.kelvin.set1 (NV097_SET_COMBINER_COLOR_OCW(i), filterType[dwFilterType].combinerInfo[i].dwOCW);
        _pContext->hwState.kelvin.set1 (NV097_SET_COMBINER_ALPHA_ICW(i), filterType[dwFilterType].combinerInfo[i].dwICW |
            DRF_DEF(097, _SET_COMBINER_ALPHA, _ICW_A_ALPHA, _TRUE) |
            DRF_DEF(097, _SET_COMBINER_ALPHA, _ICW_B_ALPHA, _TRUE) |
            DRF_DEF(097, _SET_COMBINER_ALPHA, _ICW_C_ALPHA, _TRUE) |
            DRF_DEF(097, _SET_COMBINER_ALPHA, _ICW_D_ALPHA, _TRUE));
        _pContext->hwState.kelvin.set1 (NV097_SET_COMBINER_ALPHA_OCW(i), filterType[dwFilterType].combinerInfo[i].dwOCW);
        _pContext->hwState.kelvin.set1 (NV097_SET_COMBINER_FACTOR0(i), filterType[dwFilterType].combinerInfo[i].dwFactor0);
        _pContext->hwState.kelvin.set1 (NV097_SET_COMBINER_FACTOR1(i), filterType[dwFilterType].combinerInfo[i].dwFactor1);
    }

    /////////////////////////////////////////////////////

    float x0, y0;
    
    // This logic actually works whether we're upscaling or downscaling
    if (MethodInfo[dwMethod].dwKernel && !filterType[dwFilterType].bEmulateFilter) {
        x0 = 0.25 * BufferBltInfo[dwSimpleMethod].dwSuperBufferScaleX;
        y0 = 0.25 * BufferBltInfo[dwSimpleMethod].dwSuperBufferScaleY;
    } else {
        x0 = 0;
        y0 = 0;
    }

    if (IsMultisampling()) {
        if (bUpscaling) {
            x0 -= _appCompatibility.fXOffset;
            y0 -= _appCompatibility.fYOffset;
        } else {
            // match the offset we already added in nvSetKelvinTransform
            x0 += _appCompatibility.fXOffset * BufferBltInfo[dwSimpleMethod].dwSuperBufferScaleX;
            y0 += _appCompatibility.fYOffset * BufferBltInfo[dwSimpleMethod].dwSuperBufferScaleY;
        }
    } 

    float dx0 = filterType[dwFilterType].texStageInfo[0].fXOffset;
    float dy0 = filterType[dwFilterType].texStageInfo[0].fYOffset;
    float dx1 = filterType[dwFilterType].texStageInfo[1].fXOffset;
    float dy1 = filterType[dwFilterType].texStageInfo[1].fYOffset;
    float dx2 = filterType[dwFilterType].texStageInfo[2].fXOffset;
    float dy2 = filterType[dwFilterType].texStageInfo[2].fYOffset;
    float dx3 = filterType[dwFilterType].texStageInfo[3].fXOffset;
    float dy3 = filterType[dwFilterType].texStageInfo[3].fYOffset;
    
    if (bSubdivideAA) {
        float srcy0, srcy1, dsty0, dsty1;
        srcy0 = 0;
        dsty0 = 0;
        srcy1 = _strip.srcyinc.f;
        dsty1 = _strip.dstyinc.f;

        for (DWORD j=0; j<=_strip.num_strips; j++) {
            _pContext->hwState.kelvin.set1(NV097_SET_BEGIN_END, NV097_SET_BEGIN_END_OP_QUADS);
            getDC()->nvPusher.makeSpace (sizeSetStartMethod + 40);
            nvglSetStartMethod (0, NV_DD_KELVIN, NVPUSHER_NOINC(NV097_INLINE_ARRAY), 40);
            getDC()->nvPusher.inc (sizeSetStartMethod);

            if (j == _strip.num_strips) {
                srcy1 = srcy0 + _strip.srcyrem.f;
                dsty1 = dsty0 + _strip.dstyrem.f;
            }
            
            const float verts[4][10] = {
                {
                    0,                       dsty0,                 
                    x0+dx0,                  srcy0+y0+dy0, 
                    x0+dx1,                  srcy0+y0+dy1, 
                    x0+dx2,                  srcy0+y0+dy2, 
                    x0+dx3,                  srcy0+y0+dy3 
                }, {
                    pDst->getWidth(),        dsty0,                 
                    pSrc->getWidth()+x0+dx0, srcy0+y0+dy0, 
                    pSrc->getWidth()+x0+dx1, srcy0+y0+dy1, 
                    pSrc->getWidth()+x0+dx2, srcy0+y0+dy2, 
                    pSrc->getWidth()+x0+dx3, srcy0+y0+dy3 
                }, {
                    pDst->getWidth(),        dsty1, 
                    pSrc->getWidth()+x0+dx0, srcy1+y0+dy0, 
                    pSrc->getWidth()+x0+dx1, srcy1+y0+dy1, 
                    pSrc->getWidth()+x0+dx2, srcy1+y0+dy2, 
                    pSrc->getWidth()+x0+dx3, srcy1+y0+dy3
                }, {
                    0,                       dsty1, 
                    x0+dx0,                  srcy1+y0+dy0,
                    x0+dx1,                  srcy1+y0+dy1,
                    x0+dx2,                  srcy1+y0+dy2,
                    x0+dx3,                  srcy1+y0+dy3,
                }
            };
            
            
            for (i=0; i<40; i++) nvglSetData(i, *(DWORD *)&(((float *)verts)[i]));
            getDC()->nvPusher.inc(40);

            _pContext->hwState.kelvin.set1(NV097_SET_BEGIN_END, NV097_SET_BEGIN_END_OP_END);
    
            srcy0 = srcy1;
            dsty0 = dsty1;
            srcy1 += _strip.srcyinc.f;
            dsty1 += _strip.dstyinc.f;
        }
    } else {
        _pContext->hwState.kelvin.set1(NV097_SET_BEGIN_END, NV097_SET_BEGIN_END_OP_QUADS);
        
        getDC()->nvPusher.makeSpace (sizeSetStartMethod + 40);
        nvglSetStartMethod (0, NV_DD_KELVIN, NVPUSHER_NOINC(NV097_INLINE_ARRAY), 40);
        getDC()->nvPusher.inc (sizeSetStartMethod);
        
        const float verts[4][10] = {
            {
                0,                       0,
                x0+dx0,                  y0+dy0,
                x0+dx1,                  y0+dy1,
                x0+dx2,                  y0+dy2,
                x0+dx3,                  y0+dy3
            }, {
                pDst->getWidth(),        0,                 
                pSrc->getWidth()+x0+dx0, y0+dy0, 
                pSrc->getWidth()+x0+dx1, y0+dy1, 
                pSrc->getWidth()+x0+dx2, y0+dy2, 
                pSrc->getWidth()+x0+dx3, y0+dy3 
            }, {
                pDst->getWidth(),        pDst->getHeight(), 
                pSrc->getWidth()+x0+dx0, pSrc->getHeight()+y0+dy0, 
                pSrc->getWidth()+x0+dx1, pSrc->getHeight()+y0+dy1, 
                pSrc->getWidth()+x0+dx2, pSrc->getHeight()+y0+dy2, 
                pSrc->getWidth()+x0+dx3, pSrc->getHeight()+y0+dy3
            }, {
                0,                       pDst->getHeight(), 
                x0+dx0,                  pSrc->getHeight()+y0+dy0,
                x0+dx1,                  pSrc->getHeight()+y0+dy1,
                x0+dx2,                  pSrc->getHeight()+y0+dy2,
                x0+dx3,                  pSrc->getHeight()+y0+dy3,
            }
        };
        
        
        for (i=0; i<40; i++) nvglSetData(i, *(DWORD *)&(((float *)verts)[i]));
        getDC()->nvPusher.inc(40);
        
        _pContext->hwState.kelvin.set1(NV097_SET_BEGIN_END, NV097_SET_BEGIN_END_OP_END);
    }

    //////////////////////////////////////////////////
    // Gotta reset the whole shebang
    _pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_REALLY_FILTHY;
    if (bFlush) getDC()->nvPusher.flush (TRUE, CPushBuffer::FLUSH_WITH_DELAY);

    // Turn AA back on
    SetSampleMask();
    nvPusherStart(FALSE);
}


void CKelvinAAState::ScaledBlt(
    CSimpleSurface *pDst, 
    DWORD dwDstX,
    DWORD dwDstY,
    DWORD dwDstWidth, 
    DWORD dwDstHeight, 
    CSimpleSurface *pSrc, 
    double fSrcX,
    double fSrcY,
    DWORD dwSrcWidth,
    DWORD dwSrcHeight
    ) {

    nvAssert(_pContext);

    DWORD dwDstFormat = pDst->getFormat();
    DWORD dwSrcFormat = pSrc->getFormat();

    // Spoof the dst format
    switch (dwDstFormat) {
    case NV_SURFACE_FORMAT_Z16:
        dwDstFormat = NV_SURFACE_FORMAT_R5G6B5;
        break;
    case NV_SURFACE_FORMAT_Z24S8:
    case NV_SURFACE_FORMAT_Z24X8:
        dwDstFormat = NV_SURFACE_FORMAT_A8R8G8B8;
        break;
    }

    // Spoof the src format
    switch (dwSrcFormat) {
    case NV_SURFACE_FORMAT_Z16:
        dwSrcFormat = NV_SURFACE_FORMAT_R5G6B5;
        break;
    case NV_SURFACE_FORMAT_Z24S8:
    case NV_SURFACE_FORMAT_Z24X8:
        dwSrcFormat = NV_SURFACE_FORMAT_A8R8G8B8;
        break;
    }

    DWORD bDither = 1;

/////////////////////////////////////////////////////

    DWORD dwDstBPP = nvSurfaceFormatToBPP[dwDstFormat];
    DWORD dwSrcBPP = nvSurfaceFormatToBPP[dwSrcFormat];

/////////////////////////////////////////////////////

    nvPushData(0, dDrawSubchannelOffset(NV_DD_ROP) | SET_ROP_OFFSET | 0x40000);
    nvPushData(1, (SRCCOPY >> 16));
    nvPusherAdjust(2);
    getDC()->bltData.dwLastRop = (SRCCOPY >> 16);

/////////////////////////////////////////////////////

    DWORD dwSrcOffset, dwDstOffset;
    DWORD dwSrcPitch, dwDstPitch;
    DWORD dwSrcPoint, dwDstPoint;
    DWORD dwDsDx, dwDtDy;
    DWORD dwSrcSize, dwDstSize;
    DWORD dwSrcX, dwSrcY;
    DWORD bFOH, bCenter;


    dwSrcPitch = pSrc->getPitch();
    dwDstPitch = pDst->getPitch();

    dwDstOffset  = pDst->getOffset() + (dwDstBPP * dwDstX + dwDstPitch * dwDstY);
    dwDstX       = 0;
    dwDstY       = 0;
    if (dwDstOffset & NV_BYTE_ALIGNMENT_PAD) {
        dwDstX      += (dwDstOffset & NV_BYTE_ALIGNMENT_PAD) / dwDstBPP;
        dwDstOffset &= ~NV_BYTE_ALIGNMENT_PAD;
    }

    dwSrcX = (DWORD)(fSrcX * 16);
    dwSrcY = (DWORD)(fSrcY * 16);
    dwSrcOffset = pSrc->getOffset() + (dwSrcBPP * (dwSrcX >> 4) + dwSrcPitch * (dwSrcY >> 4));
    dwSrcX     &= 0xf;
    dwSrcY     &= 0xf;
    if (dwSrcOffset & NV_BYTE_ALIGNMENT_PAD) {
        dwSrcX      += ((dwSrcOffset & NV_BYTE_ALIGNMENT_PAD) / dwSrcBPP) << 4;
        dwSrcOffset &= ~NV_BYTE_ALIGNMENT_PAD;
    }

    dwDstSize = (dwDstHeight << 16) | dwDstWidth;
    dwSrcSize = (dwSrcHeight << 16) | dwSrcWidth;

    dwDstPoint = (dwDstY << 16) | dwDstX;
    dwSrcPoint = (dwSrcY << 20) | (dwSrcX << 4);

    dwDsDx = DWORD((__int64(dwSrcWidth) << 20) / __int64(dwDstWidth));
    dwDtDy = DWORD((__int64(dwSrcHeight) << 20) / __int64(dwDstHeight));

    bFOH = 1;
    bCenter = 0;

///////////////////////////////////////////////

//    nvAssert(!(dwSrcSize & 0xfffefffe));
//    nvAssert(!(dwDstSize & 0xfffefffe));

///////////////////////////////////////////////

    nvPushData ( 0, dDrawSubchannelOffset(NV_DD_SURFACES) | SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x100000);
    nvPushData ( 1, nv062SurfaceFormat[dwSrcFormat]);    // SetColorFormat
    nvPushData ( 2, (dwDstPitch << 16) | dwSrcPitch); // SetPitch
    nvPushData ( 3, dwSrcOffset);                     // SetOffset
    nvPushData ( 4, dwDstOffset);                     // SetOffset
    nvPusherAdjust (5);
    getDC()->bltData.dwLastColourFormat = nv062SurfaceFormat[dwSrcFormat];
    getDC()->bltData.dwLastCombinedPitch = (dwDstPitch << 16) | dwSrcPitch;
    getDC()->bltData.dwLastSrcOffset = dwSrcOffset;
    getDC()->bltData.dwLastDstOffset = dwDstOffset;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
    nvPushData(1, NV_DD_CONTEXT_COLOR_KEY);
    nvPushData(2, dDrawSubchannelOffset(NV_DD_SPARE) | SET_TRANSCOLOR_OFFSET | 0x40000);
    nvPushData(3, 0);
    nvPusherAdjust(4);
    getDC()->bltData.dwLastColourKey = 0xFFFFFFFF;
    getDC()->dDrawSpareSubchannelObject = NV_DD_CONTEXT_COLOR_KEY;


    nvPushData ( 0, dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000);
    nvPushData ( 1, NV_DD_SCALED_IMAGE_IID);
    nvPushData ( 2, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_CONTEXT_DMA_IMAGE_OFFSET | 0x40000);
    nvPushData ( 3, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY); // SetContextDmaImage
    nvPushData ( 4, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_SET_COLOR_FORMAT | 0x40000);
    nvPushData ( 5, nv089SurfaceFormat[dwDstFormat]); // SetColorFormat
    nvPushData ( 6, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_CLIPPOINT_OFFSET | 0x180000);
    nvPushData ( 7, dwDstPoint);             // ClipPoint
    nvPushData ( 8, dwDstSize);              // ClipSize
    nvPushData ( 9, dwDstPoint);             // ImageOutPoint
    nvPushData (10, dwDstSize);              // ImageOutSize
    nvPushData (11, dwDsDx);                 // DsDx
    nvPushData (12, dwDtDy);                 // DtDy
    nvPushData (13, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_IMAGE_IN_SIZE_OFFSET | 0x100000);
    nvPushData (14, dwSrcSize);              // ImageInSize
    nvPushData (15, (bFOH ? (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24)
                          : (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_ZOH << 24)) |     // ImageInFormat
                    (bCenter ? (NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16)
                             : (NV077_IMAGE_IN_FORMAT_ORIGIN_CORNER << 16)) |
                    dwSrcPitch);
    nvPushData (16, dwSrcOffset);            // ImageInOffset
    nvPushData (17, dwSrcPoint);             // ImageInPoint

    if (bDither) {
        nvPushData (18, dDrawSubchannelOffset(NV_DD_STRETCH) | NV089_SET_COLOR_CONVERSION | 0x40000);
        nvPushData (19, NV089_SET_COLOR_CONVERSION_DITHER); // SetColorFormat
        nvPusherAdjust (20);
    } else {
        nvPusherAdjust (18);
    }

    nvPusherStart (TRUE);

    getDC()->TwoDRenderingOccurred   = TRUE;
    getDC()->ThreeDRenderingOccurred = 0;

    _pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_REALLY_FILTHY;
    
} 

extern "C" void __CxxFrameHandler() {
    // WARNING: This frame handler does absolutely nothing.  It's only
    // defined because it's required by __try/__except blocks, and apparently
    // we can't link in the library that has the real function.  If you hit this
    // int 3, make absolutely sure that the behavior is what you want.
#ifdef DEBUG
    __asm int 3;
#endif
}

char * nvGetCommandLine() {
#ifdef WINNT
    if (getDC()->nvD3DRegistryData.regAACompatibilityBits) {
        // the address is defined in the registry; load it
        char **pCmdLinePtrPtr = (char **)(~getDC()->nvD3DRegistryData.regAACompatibilityBits);

        if (*pCmdLinePtrPtr) {
            return *pCmdLinePtrPtr;
        } else {
            // somebody input the wrong registry value, and we were lucky to trap the null pointer
            dbgD3DError();
            return "";
        }
    } else {
        // nothing in the registry; iterate through our list of known possible 
        // locations, trying to determine which one will work, and using exception
        // handlers to gracefully recover.

#define MAX_GCL_PTRS 3
        // To add a new OS:
        // - Write a small program to return the address of the GetCommandLine function (say, 0x77e871cc)
        // - While still in the program (so that the DLL doesn't get unmapped), break into SoftICE and
        //   disassemble starting at that address ("u 77e871cc").
        // - There should be a line looking something like "mov eax, [77ee0694]".  The number in the 
        //   brackets is the one you want
        // - Add it to the list below, making sure to comment the OS, service pack, and build number
        // - I suggest adding the item to the bottom of the list and testing, to ensure that when it
        //   runs through the existing pointers, the excpetion handling works correctly.

        static const char **ppGCL[MAX_GCL_PTRS] = {
            (const char **)0x77edf694,    // Win2k SP1
            (const char **)0x77ee0694,    // Win2k, no SP
            (const char **)0x77e48fdc,    // Whistler build 2416
        };

        static char pCmdLine[256];
        int i, j, len;
    
        for (i=0; i<MAX_GCL_PTRS; i++) {
            __try {
                // This memcpy will throw an exception if the pointer is bad, though try/except
                // only works for user-space pointers.  Check that the pointer we look at is <2 GB,
                // and attempt the copy.

                nvAssert(ppGCL[i] < (const char **)0x80000000);      // no kernel-space pointers should be put in ppGCL!
                if (*ppGCL[i] >= (const char *)0x80000000) continue; // check that the dereferenced pointer is also <2 GB

                memcpy(pCmdLine, *ppGCL[i], 256);
    
                for (j=0; j<256; j++) if (!pCmdLine[j]) break;
                
                if (j == 256) continue; // no null character in string; we must be looking at the wrong memory
    
                len = j;
                if (len < 5) continue; // the filename better have at least one character, a dot, and an extension

                for (j=0; j<len; j++) if ((pCmdLine[j] > 0) && (pCmdLine[j] < 32)) continue; // hmmm, hit some control characters; abort.

                break; // looks like we found one that works
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                continue;
            }
        }

        if (i == MAX_GCL_PTRS) {
            // we tried all the pointers in ppGCL, and they all failed
            return "";
        } else {
            return (char *)pCmdLine;
        }
    }

#else
    // under Win9x, we don't have to go through this mess
    return GetCommandLine();
#endif
}


void CKelvinAAState::InitAppCompatibility() {
    char *pCmdLine = nvGetCommandLine();

    static const AppCompatibilityStruct AppCompatibilitySettings[] = {
        {0x7ce92a196eb3e4a8, APPFLAGS_FORCE_SUPERSAMPLE, 0.04, 0.04},     // "monkey4.exe"          Escape From Monkey Island
        {0x97b0a9f590eb304f, APPFLAGS_FORCE_SUPERSAMPLE, 0, 0},           // "gpolice.exe"          G-Police
        {0x61053382419baf37, 0, 0.04, 0.04},                              // "hh2002_demo.exe"      High Heat Baseball 2002
        {0xd528be9ef82890fa, APPFLAGS_FORCE_SUPERSAMPLE, 0, 0},           // "monsterx.exe"         Monster Truck Madness 1/2
        {0x7814373c4b0b7201, APPFLAGS_WRITE_ACCESS_ON_ENDSCENE, 0, 0},    // "mrball.exe"           Mr Ball
        {0x8e039f4e0d3c4a75, APPFLAGS_FORCE_SUPERSAMPLE, 0, 0},           // "newhaas.exe"          Newman Hass Racing
        {0x925ac5084c34c71f, 0, -0.25, -0.25},                            // "lithtech.exe"         No One Lives Forever demo
        {0xbe568edf15a298b0, APPFLAGS_DOWNSAMPLE_ON_BLIT, 0, 0},          // "pop3ddemo.exe"        Prince of Persia demo
        {0x1ed8331bc713a59c, APPFLAGS_DISABLE_AA, 0, 0},                  // "revenant.exe"         Revenant
        {0xc9360a7086bac23c, APPFLAGS_FORCE_UNCOMPRESSED_Z, 0, 0},        // "kamdemo.exe"          Star Trek: Klingon Academy
        {0x8c02d8d6d094cf9a, 0, -1.0, -1.0},                              // "unrealtournament.exe" Unreal Tournament
        {0x849ce96f91d533d9, APPFLAGS_DOWNSAMPLE_ON_BLIT | APPFLAGS_FORCE_SUPERSAMPLE, 0, 0},        // "armada.exe" Star Trek Armada
        {0x0fb32fa59c3762d6, APPFLAGS_MAGNIFY_AFTER_FLIP | APPFLAGS_DOWNSAMPLE_ON_BLIT, 0, 0},     // "lemmings revolution.exe" Lemmings Revolution
        {0xb7c39ae78e70f3d3, 0,0.25,0.25},                                //"aquanox.exe"           Aquanox
        {0xfffe65aaac391e60, APPFLAGS_DISABLE_DITHER,0.25,0.0},           //"linksmmi.exe"          Msft Links2001
        {0x34b3962ff618545d, 0,0,0.25},                                   //"fs2.exe"               Descent Freepace 2, partial fix
        {0xd9e267694cee1255, APPFLAGS_FORCE_SUPERSAMPLE, 0.2501,0.25},    //"game.exe"              Driver, also matches Diablo II (.25->.2501 for Quincunx AA on Diablo)
        {0x0000000000000000, 0, 0, 0}   
    };

    
    char pLCCmdLine[256];
    strncpy(pLCCmdLine, pCmdLine, 256);
    pLCCmdLine[255] = 0;
    _strlwr(pLCCmdLine);

    char *pPos = strstr(pLCCmdLine, ".exe");
    char *pEnd = pPos + 4;
    char pExeName[256];

    
    if (pPos) {
        while ((pPos >= pLCCmdLine) && (*pPos != '\\') && (*pPos != '"')) pPos--;
        pPos++;

        int len = pEnd - pPos;

        strncpy(pExeName, pPos, len);
        pExeName[len] = 0;
    } else {
        pExeName[0] = 0;
    }
    


    _appCompatibility.qwHashVal = nvHash64((unsigned char *)pExeName, strlen(pExeName));
    DPF("Program name/hash value: \"%s\" = 0x%08x%08x", pExeName, (DWORD)(_appCompatibility.qwHashVal>>32), (DWORD)(_appCompatibility.qwHashVal&0xffffffff));  

    for (int i=0; AppCompatibilitySettings[i].qwHashVal; i++) {
        if (_appCompatibility.qwHashVal == AppCompatibilitySettings[i].qwHashVal) {
            _appCompatibility = AppCompatibilitySettings[i];
            //DPF (">>>>>>>>>>>>> matched");
            break;
        }
    }
}

/////////////////////////////////////////////////////////////////////////////


/*
--------------------------------------------------------------------
hash() -- hash a variable-length key into a 64-bit value
  k     : the key (the unaligned variable-length array of bytes)
  len   : the length of the key, counting by bytes
  level : can be any 8-byte value
Returns a 64-bit value.  Every bit of the key affects every bit of
the return value.  No funnels.  Every 1-bit and 2-bit delta achieves
avalanche.  About 41+5len instructions.

The best hash table sizes are powers of 2.  There is no need to do
mod a prime (mod is sooo slow!).  If you need less than 64 bits,
use a bitmask.  For example, if you need only 10 bits, do
  h = (h & hashmask(10));
In which case, the hash table should have hashsize(10) elements.

If you are hashing n strings (ub1 **)k, do it like this:
  for (i=0, h=0; i<n; ++i) h = hash( k[i], len[i], h);

By Bob Jenkins, Jan 4 1997.  bob_jenkins@burtleburtle.net.  You may
use this code any way you wish, private, educational, or commercial,
as long as this whole comment accompanies it.

See http://burtleburtle.net/bob/hash/evahash.html
Use for hash table lookup, or anything where one collision in 2^^64
is acceptable.  Do NOT use for cryptographic purposes.
--------------------------------------------------------------------
*/

#define mix64(a,b,c) do { \
    a -= b; a -= c; a ^= (c>>43); \
    b -= c; b -= a; b ^= (a<<9); \
    c -= a; c -= b; c ^= (b>>8); \
    a -= b; a -= c; a ^= (c>>38); \
    b -= c; b -= a; b ^= (a<<23); \
    c -= a; c -= b; c ^= (b>>5); \
    a -= b; a -= c; a ^= (c>>35); \
    b -= c; b -= a; b ^= (a<<49); \
    c -= a; c -= b; c ^= (b>>11); \
    a -= b; a -= c; a ^= (c>>12); \
    b -= c; b -= a; b ^= (a<<18); \
    c -= a; c -= b; c ^= (b>>22); \
} while (0)

uint64 nvHash64(unsigned char *k, unsigned int length) {
    uint64 a,b,c;
    unsigned int len;
    
    // Set up the internal state
    len = length;
    a = b = 0;
    c = 0x9e3779b97f4a7c13; // the golden ratio; an arbitrary value
    
    // handle most of the key
    while (len >= 24) {
        a += ((uint64)k[0]       + ((uint64)k[ 1]<< 8) + ((uint64)k[ 2]<<16) + ((uint64)k[ 3]<<24)
          +  ((uint64)k[4 ]<<32) + ((uint64)k[ 5]<<40) + ((uint64)k[ 6]<<48) + ((uint64)k[ 7]<<56));
        b += ((uint64)k[8]       + ((uint64)k[ 9]<< 8) + ((uint64)k[10]<<16) + ((uint64)k[11]<<24)
          +  ((uint64)k[12]<<32) + ((uint64)k[13]<<40) + ((uint64)k[14]<<48) + ((uint64)k[15]<<56));
        c += ((uint64)k[16]      + ((uint64)k[17]<< 8) + ((uint64)k[18]<<16) + ((uint64)k[19]<<24)
          +  ((uint64)k[20]<<32) + ((uint64)k[21]<<40) + ((uint64)k[22]<<48) + ((uint64)k[23]<<56));
        
        mix64(a,b,c);
        k += 24; len -= 24;
    }
    
    // handle the last 23 bytes
    c += length;
    switch (len) {
    case 23: c+=((uint64)k[22]<<56);
    case 22: c+=((uint64)k[21]<<48);
    case 21: c+=((uint64)k[20]<<40);
    case 20: c+=((uint64)k[19]<<32);
    case 19: c+=((uint64)k[18]<<24);
    case 18: c+=((uint64)k[17]<<16);
    case 17: c+=((uint64)k[16]<<8);
    // the first byte of c is reserved for the length
    case 16: b+=((uint64)k[15]<<56);
    case 15: b+=((uint64)k[14]<<48);
    case 14: b+=((uint64)k[13]<<40);
    case 13: b+=((uint64)k[12]<<32);
    case 12: b+=((uint64)k[11]<<24);
    case 11: b+=((uint64)k[10]<<16);
    case 10: b+=((uint64)k[ 9]<<8);
    case  9: b+=((uint64)k[ 8]);
    case  8: a+=((uint64)k[ 7]<<56);
    case  7: a+=((uint64)k[ 6]<<48);
    case  6: a+=((uint64)k[ 5]<<40);
    case  5: a+=((uint64)k[ 4]<<32);
    case  4: a+=((uint64)k[ 3]<<24);
    case  3: a+=((uint64)k[ 2]<<16);
    case  2: a+=((uint64)k[ 1]<<8);
    case  1: a+=((uint64)k[ 0]);
    // case 0: nothing left to add
    }
    
    mix64(a,b,c);
    
    return c;
}

#endif // NVARCH >= 0x020
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\kelvin\inc\nvKelvinTables.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvKelvinTables.h
//      tables of values and constants related to the kelvin object
//
// **************************************************************************
//
//  History:
//       Craig Duttweiler        28Apr2000         NV20 development
//
// **************************************************************************

#ifndef _NVKELVINTABLES_H
#define _NVKELVINTABLES_H

#if (NVARCH >= 0x020)

// table for looking up pre-computed combiner settings for legacy texture blends
extern DWORD kelvinTextureBlendSettings[D3D_TBLEND_MAX+1][4];
extern DWORD kelvinTextureBlendDefault[4];

// table of dependencies between d3d renderstates and kelvin state
extern DWORD kelvinDirtyBitsFromRenderState[D3D_RENDERSTATE_MAX+1];

// table of dependencies between d3d texture stage states and kelvin state
extern DWORD kelvinDirtyBitsFromTextureStageState[D3D_TEXSTAGESTATE_MAX+1];

// table mapping dp2ops to the kelvin method values associated with them.
extern DWORD kelvinBeginEndOp[D3D_DP2OP_MAX+1];

// table mapping d3d vertex types to kelvin vertex sizes
extern DWORD kelvinVertexSize[8];

// table mapping d3d vertex types to kelvin vertex types
extern DWORD kelvinVertexType[8];

// table mapping dp2ops to the scale and bias required to calculate
// the number of vertices from the number of primitives.
extern DWORD kelvinPrimitiveToPrimitiveMagic[D3D_DP2OP_MAX+1];

// table for primitive names
#ifdef DEBUG
extern char* kelvinPrimitiveName[D3D_DP2OP_MAX+1];
#endif

#endif  // NVARCH >= 0x020

#endif  // _NVKELVINTABLES_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\kelvin\inc\nvKelvinState.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvKelvinState.h
//      Kelvin state header file
//
// **************************************************************************
//
//  History:
//      Craig Duttweiler        27Mar2000         NV20 development
//
// **************************************************************************

#ifndef _NVKELVINSTATE_H
#define _NVKELVINSTATE_H

#if (NVARCH >= 0x020)

// general HW capabilities used internally by driver ------------------------

#define KELVIN_NUM_COMBINERS            8           // virtual combiner stages
#define KELVIN_NUM_MATRICES             4           // blendable matrices
#define KELVIN_NUM_TEXTURES             4           // texture units
#define KELVIN_NUM_WINDOWS              8           // clip windows

#define KELVIN_ALIGNMENT_MIN            64

#define KELVIN_VIEWPORT_BOUND           0           // kelvin viewport runs from 0..4096
#define KELVIN_D3D2OGL                  0.5f        // add 0.5 so that D3D pixels line up with OGL pixels
#define KELVIN_HALFSUBPIXELBIAS         0.03125f    // round to nearest 1/16 pixel grid

#define KELVIN_BORDER                   (-KELVIN_VIEWPORT_BOUND + KELVIN_D3D2OGL + KELVIN_HALFSUBPIXELBIAS)

// z depths
#define KELVIN_Z_SCALE16                65535.0f     // 2^16 - 1
#define KELVIN_Z_SCALE24                16777215.0f  // 2^24 - 1
#define KELVIN_Z_SCALE16_INV            (1.0f / KELVIN_Z_SCALE16)
#define KELVIN_Z_SCALE24_INV            (1.0f / KELVIN_Z_SCALE24)

#define KELVIN_TETRIS_THRESHOLD         1024         // minimum width of a clear that will get striped
#define KELVIN_TETRIS_WIDTH             256          // width of clear stripe in pixels (optimal = 1024 bytes)
                                                     // This needs to be adjusted by the color depth, as it's only accurate for 32bpp.
                                                     // It turns out that for NV20, it's much faster to clear 1024 byte swaths of
                                                     // the Z buffer.


#define KELVIN_MAX_INLINE_STRIDE        16    // largest number of DWORDs allowed in a single vertex
#define KELVIN_MAX_INLINE_VERTICES      120   // maximum vertices = maximum method data size / maximum vertex size
                                              //                  = 2^11 DWORDs / KELVIN_MAX_INLINE_STRIDE
                                              //                  = 128
#define KELVIN_MAX_NONINC_DATA          1000  // maximum amount of data (DWORDs) that can be sent to a non-incrementing
                                              // method like NV097_ARRAY_ELEMENT16 (actually 2^10-1 = 1023)

// general HW capabilities exported to D3D ----------------------------------

#define KELVIN_MAXVERTEXCOUNT                       32768
#define KELVIN_MAXBUFFERSIZE                        0

#define KELVIN_CAPS_GUARD_BAND_LEFT                -1.0e8f   // nv10/20 can use a guardband as large as 1e25, but 1e8 appears
#define KELVIN_CAPS_GUARD_BAND_TOP                 -1.0e8f   // to be the largest value that the game re-volt will handle.
#define KELVIN_CAPS_GUARD_BAND_RIGHT                1.0e8f   // anything larger aggravates an app bug that causes it to
#define KELVIN_CAPS_GUARD_BAND_BOTTOM               1.0e8f   // send us completely broken geometry.

#define KELVIN_CAPS_MAX_TEXTURE_REPEAT              8192 // the constraint on nv10 is actually du/dx < 8192
#define KELVIN_CAPS_MAX_TEXTURE_ASPECT_RATIO        0
#define KELVIN_CAPS_MAX_ANISOTROPY                  8    // Means we support anisotropic filtering.
#define KELVIN_CAPS_EXTENTS_ADJUST                  0

#define KELVIN_CAPS_MAX_UV_PAIRS                    8    // Number of texture uv's supported.

#define KELVIN_CAPS_FVF_CAPS                        (KELVIN_CAPS_MAX_UV_PAIRS | D3DFVFCAPS_DONOTSTRIPELEMENTS)
#define KELVIN_CAPS_MAX_TEXTURE_BLEND_STATES        KELVIN_NUM_COMBINERS
#define KELVIN_CAPS_MAX_SIMULTANEOUS_TEXTURES       KELVIN_NUM_TEXTURES

// DX7 stuff
#define KELVIN_CAPS_MAX_ACTIVE_LIGHTS               8
#define KELVIN_CAPS_MAX_USER_CLIP_PLANES_EXPORTED   0    // we can do 16, but it's not orthogonal to texturing, so WHQL won't let us export any
#define KELVIN_CAPS_MAX_USER_CLIP_PLANES_ALLOWED    8    // we can do 16, but nv30 will only do 8, so only process that many and ignore others
#define KELVIN_CAPS_MAX_VERTEX_BLEND_MATRICES       KELVIN_NUM_MATRICES

// DX8 stuff
#define KELVIN_CAPS_MAX_STREAMS                     16
#define KELVIN_CAPS_MAX_PSHADER_CONSTS              16
#define KELVIN_CAPS_MAX_VSHADER_CONSTS              96
#define KELVIN_CAPS_MAX_VSHADER_TEMPS               16

// maximum fog scale = 2^13. (the HW has 14 bits. we leave one for roundoff)
#define KELVIN_MAX_FOG_SCALE                        8192.0f

//---------------------------------------------------------------------------

// combiner inputs
typedef enum _kelvinCombinerInput {
    kelvinCombinerInputA = 0,
    kelvinCombinerInputB = 1,
    kelvinCombinerInputC = 2,
    kelvinCombinerInputD = 3,
} kelvinCombinerInput;

// the positions of the inputs in the input control words
static DWORD kelvinCombinerInputShift[4] = {24, 16, 8, 0};

//---------------------------------------------------------------------------
// dirty bits

// celsius uses 0x0000FFFF
// kelvin  uses 0xFFFF0000
#define KELVIN_DIRTY_COMBINERS_COLOR   0x00010000
#define KELVIN_DIRTY_COMBINERS_SPECFOG 0x00020000
#define KELVIN_DIRTY_CONTROL0          0x00040000
#define KELVIN_DIRTY_DEFAULTS          0x00080000
#define KELVIN_DIRTY_FVF               0x00100000
#define KELVIN_DIRTY_LIGHTS            0x00200000
#define KELVIN_DIRTY_MISC_STATE        0x00400000
#define KELVIN_DIRTY_SURFACE           0x00800000
#define KELVIN_DIRTY_TEXTURE_STATE     0x01000000
#define KELVIN_DIRTY_TEXTURE_TRANSFORM 0x02000000
#define KELVIN_DIRTY_TRANSFORM         0x04000000
#define KELVIN_DIRTY_VERTEX_SHADER     0x08000000
#define KELVIN_DIRTY_PIXEL_SHADER      0x10000000

#define KELVIN_DIRTY_REALLY_FILTHY     (KELVIN_DIRTY_COMBINERS_COLOR   | \
                                        KELVIN_DIRTY_COMBINERS_SPECFOG | \
                                        KELVIN_DIRTY_CONTROL0          | \
                                        KELVIN_DIRTY_DEFAULTS          | \
                                        KELVIN_DIRTY_FVF               | \
                                        KELVIN_DIRTY_LIGHTS            | \
                                        KELVIN_DIRTY_MISC_STATE        | \
                                        KELVIN_DIRTY_SURFACE           | \
                                        KELVIN_DIRTY_TEXTURE_STATE     | \
                                        KELVIN_DIRTY_TEXTURE_TRANSFORM | \
                                        KELVIN_DIRTY_TRANSFORM         | \
                                        KELVIN_DIRTY_VERTEX_SHADER     | \
                                        KELVIN_DIRTY_PIXEL_SHADER)

//---------------------------------------------------------------------------

// values for the texture stage <=> texture unit mappings
#define KELVIN_UNUSED                          0xdeadbeef
#define KELVIN_COMBINER_REG_TEX0               0x00000008      // the combiner's first texture register (data from texture unit 0)

// values for texture unit status
#define KELVIN_TEXUNITSTATUS_IDLE              0x00000000      // texture unit is unused
#define KELVIN_TEXUNITSTATUS_USER              0x00000001      // texture unit has a typical user-supplied texture
#define KELVIN_TEXUNITSTATUS_BUMPMAPA          0x00000002      // texture unit has a user-supplied bumpmap in it (see below)
#define KELVIN_TEXUNITSTATUS_BUMPMAPB          0x00000004      //                          "
#define KELVIN_TEXUNITSTATUS_BUMPMAPC          0x00000008      //                          "
#define KELVIN_TEXUNITSTATUS_BUMPMAPD          0x00000010      //                          "
#define KELVIN_TEXUNITSTATUS_CLIP              0x00000020      // texture unit is being used to handle user clip plnes

// bumpmap flavors:
//   A: blend mode does not request luminance from texture, and texure does not have it
//   B: blend mode does not request luminance from texture, but texure does have it
//   C: blend mode requests luminance from texture, but texure does not have it
//   D: blend mode requests luminance from texture, and texure has it

// general kelvin state flags
#define KELVIN_FLAG_PASSTHROUGHMODE            0x00000001      // are we in passthrough mode?
#define KELVIN_FLAG_TEXSTATENEEDSINVMV         0x00000004      // inverse modelview matrix is needed b/c of texture state
#define KELVIN_FLAG_LIGHTINGNEEDSINVMV         0x00000008      // inverse modelview matrix is needed b/c of light state
#define KELVIN_FLAG_COMBINERSNEEDSPECULAR      0x00000010      // specular is referenced as a combiner (TSS) input
#define KELVIN_FLAG_SETUPFAILURE               0x00008000      // did we fail to give the app what it really wanted for one reason or another?

// kelvin texture unit and combiner state flags
#define KELVIN_FLAG_USERTEXCOORDSNEEDED(i)     (0x00010000 << (4*(i)))  // are user texture coordinates needed by HW texture unit i?
#define KELVIN_FLAG_USERTEXCOORDSNEEDED_MASK   (0x11110000)

#ifdef STOMP_TEX_COORDS
#define KELVIN_FLAG_STOMP_4TH_COORD(i)         (0x00020000 << (4*(i)))  // stupid app fix: stomp 4th texcoord to 1.0 when they moronically send down extraneous coordinates
#define KELVIN_FLAG_STOMP_4TH_COORD_MASK       (0x22220000)
#endif  // STOMP_TEX_COORDS

#define KELVIN_SET_NUM_TEX_COORDS(stage,num)   ((num) << (4*(stage)))
#define KELVIN_GET_NUM_TEX_COORDS(value,stage) (((value) >> (4*(stage))) & 0xf)

#ifdef STOMP_TEX_COORDS
#define KELVIN_MASK_INNERLOOPUNIQUENESS        (KELVIN_FLAG_USERTEXCOORDSNEEDED_MASK  |  \
                                                KELVIN_FLAG_STOMP_4TH_COORD_MASK)
#else  // !STOMP_TEX_COORDS
#define KELVIN_MASK_INNERLOOPUNIQUENESS        (KELVIN_FLAG_USERTEXCOORDSNEEDED_MASK)
#endif  // !STOMP_TEX_COORDS

// inner loop constants
#define KELVIN_ILMASK_PRIMTYPE        0x0000ffff
#define KELVIN_ILFLAG_LEGACY          0x00010000  // use legacy strides
//#define KELVIN_ILFLAG_CMHACK          0x00020000  // use tex matrix hack vertex copy routine
#define KELVIN_ILFLAG_NOCULL          0x00040000  // no culling

#define KELVIN_ILMASK_LOOPTYPE        0xf0000000  // type of inner loop
#define KELVIN_ILFLAG_IX_VB_PRIM      0x00000000
#define KELVIN_ILFLAG_IX_STR_PRIM     0x10000000
#define KELVIN_ILFLAG_IX_INL_PRIM     0x20000000
#define KELVIN_ILFLAG_IX_INL_TRI_LIST 0x40000000
#define KELVIN_ILFLAG_IX_DVB_TRI      0x60000000
#define KELVIN_ILFLAG_OR_VB_PRIM      0x80000000
#define KELVIN_ILFLAG_OR_STR_PRIM     0x90000000
#define KELVIN_ILFLAG_OR_INL_PRIM     0xa0000000
#define KELVIN_ILFLAG_OR_INL_TRI_LIST 0xc0000000
#define KELVIN_ILFLAG_SUPER_TRI_LIST  0xe0000000

#define KELVIN_SHORT_INDEXED_PRIM_COUNT_CUTOFF     25    // prim length before we introduce culling
#define KELVIN_SHORT_ORDERED_PRIM_COUNT_CUTOFF     25

// xPipe / Super-tri constants
#define KELVIN_CULLFLAG_MODELOK         0x00000001

// xPipe / Super-tri inner loop flags. These ought to be in the inner loop flags above, but we don't have enough
// flag bits.
#define KELVIN_STILFLAG_STDEFVB         0x00000001  // default VB is used (affects supertri logic)
#define KELVIN_STILFLAG_MODEL           0x00000002  // Model Culling
#define KELVIN_STILFLAG_XFORM           0x00000004  // Xform / clipcheck / cull
#define KELVIN_STILFLAG_HIBW            0x00000008  // High bandwidth mode -- check all triangles

typedef void (__stdcall *KELVINDISPATCHPRIMITIVE)(void);

//---------------------------------------------------------------------------

// forward declarations
class CVertexShader;

//---------------------------------------------------------------------------

class CKelvinState
{
    // intermediate state
public:

    // methods
public:

#if STATE_OPTIMIZE
    // push integer data from an array
    inline void seta (DWORD dwOffset, DWORD count, DWORD *dwArray)
    {
        if (!count) return;

        getDC()->nvPusher.push (0, (count << 18) | (NV_DD_KELVIN << 13) | dwOffset);
        for (DWORD i = 1; i <= count; i++)
        {
            getDC()->nvPusher.push(i, *dwArray++);
        }
        getDC()->nvPusher.adjust(count+1);
    }
#endif

    // integer data
    inline void set1 (DWORD dwOffset, DWORD dw0)
    {
        getDC()->nvPusher.push (0, 0x00040000 | (NV_DD_KELVIN << 13) | dwOffset);
        getDC()->nvPusher.push (1, dw0);
        getDC()->nvPusher.adjust (2);
    }
    inline void set2 (DWORD dwOffset, DWORD dw0, DWORD dw1)
    {
        getDC()->nvPusher.push (0, 0x00080000 | (NV_DD_KELVIN << 13) | dwOffset);
        getDC()->nvPusher.push (1, dw0);
        getDC()->nvPusher.push (2, dw1);
        getDC()->nvPusher.adjust (3);
    }
    inline void set3 (DWORD dwOffset, DWORD dw0, DWORD dw1, DWORD dw2)
    {
        getDC()->nvPusher.push (0, 0x000c0000 | (NV_DD_KELVIN << 13) | dwOffset);
        getDC()->nvPusher.push (1, dw0);
        getDC()->nvPusher.push (2, dw1);
        getDC()->nvPusher.push (3, dw2);
        getDC()->nvPusher.adjust (4);
    }
    inline void set4 (DWORD dwOffset, DWORD dw0, DWORD dw1, DWORD dw2, DWORD dw3)
    {
        getDC()->nvPusher.push (0, 0x00100000 | (NV_DD_KELVIN << 13) | dwOffset);
        getDC()->nvPusher.push (1, dw0);
        getDC()->nvPusher.push (2, dw1);
        getDC()->nvPusher.push (3, dw2);
        getDC()->nvPusher.push (4, dw3);
        getDC()->nvPusher.adjust (5);
    }
    inline void set5 (DWORD dwOffset, DWORD dw0, DWORD dw1, DWORD dw2, DWORD dw3, DWORD dw4)
    {
        getDC()->nvPusher.push (0, 0x00140000 | (NV_DD_KELVIN << 13) | dwOffset);
        getDC()->nvPusher.push (1, dw0);
        getDC()->nvPusher.push (2, dw1);
        getDC()->nvPusher.push (3, dw2);
        getDC()->nvPusher.push (4, dw3);
        getDC()->nvPusher.push (5, dw4);
        getDC()->nvPusher.adjust (6);
    }
    inline void set6 (DWORD dwOffset, DWORD dw0, DWORD dw1, DWORD dw2, DWORD dw3, DWORD dw4, DWORD dw5)
    {
        getDC()->nvPusher.push (0, 0x00180000 | (NV_DD_KELVIN << 13) | dwOffset);
        getDC()->nvPusher.push (1, dw0);
        getDC()->nvPusher.push (2, dw1);
        getDC()->nvPusher.push (3, dw2);
        getDC()->nvPusher.push (4, dw3);
        getDC()->nvPusher.push (5, dw4);
        getDC()->nvPusher.push (6, dw5);
        getDC()->nvPusher.adjust (7);
    }
    inline void set7 (DWORD dwOffset, DWORD dw0, DWORD dw1, DWORD dw2, DWORD dw3, DWORD dw4, DWORD dw5, DWORD dw6)
    {
        getDC()->nvPusher.push (0, 0x001c0000 | (NV_DD_KELVIN << 13) | dwOffset);
        getDC()->nvPusher.push (1, dw0);
        getDC()->nvPusher.push (2, dw1);
        getDC()->nvPusher.push (3, dw2);
        getDC()->nvPusher.push (4, dw3);
        getDC()->nvPusher.push (5, dw4);
        getDC()->nvPusher.push (6, dw5);
        getDC()->nvPusher.push (7, dw6);
        getDC()->nvPusher.adjust (8);
    }
    inline void set8 (DWORD dwOffset, DWORD dw0, DWORD dw1, DWORD dw2, DWORD dw3, DWORD dw4, DWORD dw5, DWORD dw6, DWORD dw7)
    {
        getDC()->nvPusher.push (0, 0x00200000 | (NV_DD_KELVIN << 13) | dwOffset);
        getDC()->nvPusher.push (1, dw0);
        getDC()->nvPusher.push (2, dw1);
        getDC()->nvPusher.push (3, dw2);
        getDC()->nvPusher.push (4, dw3);
        getDC()->nvPusher.push (5, dw4);
        getDC()->nvPusher.push (6, dw5);
        getDC()->nvPusher.push (7, dw6);
        getDC()->nvPusher.push (8, dw7);
        getDC()->nvPusher.adjust (9);
    }

    // floating-point data
    inline void set1f (DWORD dwOffset, float fData0)
    {
        getDC()->nvPusher.push (0, 0x00040000 | (NV_DD_KELVIN << 13) | dwOffset);
        getDC()->nvPusher.push (1, *(DWORD*)&fData0);
        getDC()->nvPusher.adjust (2);
    }
    inline void set2f (DWORD dwOffset, float fData0, float fData1)
    {
        getDC()->nvPusher.push (0, 0x00080000 | (NV_DD_KELVIN << 13) | dwOffset);
        getDC()->nvPusher.push (1, *(DWORD*)&fData0);
        getDC()->nvPusher.push (2, *(DWORD*)&fData1);
        getDC()->nvPusher.adjust (3);
    }
    inline void set3f (DWORD dwOffset, float fData0, float fData1, float fData2)
    {
        getDC()->nvPusher.push (0, 0x000c0000 | (NV_DD_KELVIN << 13) | dwOffset);
        getDC()->nvPusher.push (1, *(DWORD*)&fData0);
        getDC()->nvPusher.push (2, *(DWORD*)&fData1);
        getDC()->nvPusher.push (3, *(DWORD*)&fData2);
        getDC()->nvPusher.adjust (4);
    }
    inline void set4f (DWORD dwOffset,
                       float fData0, float fData1,
                       float fData2, float fData3)
    {
        getDC()->nvPusher.push (0, 0x00100000 | (NV_DD_KELVIN << 13) | dwOffset);
        getDC()->nvPusher.push (1, *(DWORD*)&fData0);
        getDC()->nvPusher.push (2, *(DWORD*)&fData1);
        getDC()->nvPusher.push (3, *(DWORD*)&fData2);
        getDC()->nvPusher.push (4, *(DWORD*)&fData3);
        getDC()->nvPusher.adjust (5);
    }
    inline void set8f (DWORD dwOffset,
                       float fData0, float fData1, float fData2, float fData3,
                       float fData4, float fData5, float fData6, float fData7)
    {
        getDC()->nvPusher.push (0, 0x00200000 | (NV_DD_KELVIN << 13) | dwOffset);
        getDC()->nvPusher.push (1, *(DWORD*)&fData0);
        getDC()->nvPusher.push (2, *(DWORD*)&fData1);
        getDC()->nvPusher.push (3, *(DWORD*)&fData2);
        getDC()->nvPusher.push (4, *(DWORD*)&fData3);
        getDC()->nvPusher.push (5, *(DWORD*)&fData4);
        getDC()->nvPusher.push (6, *(DWORD*)&fData5);
        getDC()->nvPusher.push (7, *(DWORD*)&fData6);
        getDC()->nvPusher.push (8, *(DWORD*)&fData7);
        getDC()->nvPusher.adjust (9);
    }

    // various routines to set texture transform matrices. see comments in nvSetKelvinTextureTransform()
    // (s,t,1.0) in, (s,t,1.0) out
    void setTextureTransformMatrixType220 (DWORD dwName, D3DMATRIX *pMatrix)
    {
        set4f (dwName +  0, pMatrix->_11, pMatrix->_21, 0.0f,         pMatrix->_31);
        set4f (dwName + 16, pMatrix->_12, pMatrix->_22, 0.0f,         pMatrix->_32);
        set4f (dwName + 32, 0.0f,         0.0f,         0.0f,         0.0f        );
        set4f (dwName + 48, 0.0f,         0.0f,         0.0f,         1.0f        );
    }
    // (s,t,1.0) in, (s,t,r,1.0) out
    void setTextureTransformMatrixType230 (DWORD dwName, D3DMATRIX *pMatrix)
    {
        set4f (dwName +  0, pMatrix->_11, pMatrix->_21, 0.0f,         pMatrix->_31);
        set4f (dwName + 16, pMatrix->_12, pMatrix->_22, 0.0f,         pMatrix->_32);
        set4f (dwName + 32, pMatrix->_13, pMatrix->_23, 0.0f,         pMatrix->_33);
        set4f (dwName + 48, 0.0f,         0.0f,         0.0f,         1.0f        );
    }
    // (s,t,1.0) in, (s,t,q) out
    void setTextureTransformMatrixType231 (DWORD dwName, D3DMATRIX *pMatrix)
    {
        set4f (dwName +  0, pMatrix->_11, pMatrix->_21, 0.0f,         pMatrix->_31);
        set4f (dwName + 16, pMatrix->_12, pMatrix->_22, 0.0f,         pMatrix->_32);
        set4f (dwName + 32, 0.0f,         0.0f,         0.0f,         0.0f        );
        set4f (dwName + 48, pMatrix->_13, pMatrix->_23, 0.0f,         pMatrix->_33);
    }
    // (s,t,1.0) in, (s,t,r,q) out
    void setTextureTransformMatrixType241 (DWORD dwName, D3DMATRIX *pMatrix)
    {
        set4f (dwName +  0, pMatrix->_11, pMatrix->_21, 0.0f,         pMatrix->_31);
        set4f (dwName + 16, pMatrix->_12, pMatrix->_22, 0.0f,         pMatrix->_32);
        set4f (dwName + 32, pMatrix->_13, pMatrix->_23, 0.0f,         pMatrix->_33);
        set4f (dwName + 48, pMatrix->_14, pMatrix->_24, 0.0f,         pMatrix->_34);
    }
    // (s,t,r,1.0) in, (s,t,1.0) out
    void setTextureTransformMatrixType320 (DWORD dwName, D3DMATRIX *pMatrix)
    {
        set4f (dwName +  0, pMatrix->_11, pMatrix->_21, pMatrix->_31, pMatrix->_41);
        set4f (dwName + 16, pMatrix->_12, pMatrix->_22, pMatrix->_32, pMatrix->_42);
        set4f (dwName + 32, 0.0f,         0.0f,         0.0f,         0.0f        );
        set4f (dwName + 48, 0.0f,         0.0f,         0.0f,         1.0f        );
    }
    // (s,t,r,1.0) in, (s,t,r,1.0) out
    void setTextureTransformMatrixType330 (DWORD dwName, D3DMATRIX *pMatrix)
    {
        set4f (dwName +  0, pMatrix->_11, pMatrix->_21, pMatrix->_31, pMatrix->_41);
        set4f (dwName + 16, pMatrix->_12, pMatrix->_22, pMatrix->_32, pMatrix->_42);
        set4f (dwName + 32, pMatrix->_13, pMatrix->_23, pMatrix->_33, pMatrix->_43);
        set4f (dwName + 48, 0.0f,         0.0f,         0.0f,         1.0f        );
    }
    // (s,t,r,1.0) in, (s,t,q) out
    void setTextureTransformMatrixType331 (DWORD dwName, D3DMATRIX *pMatrix)
    {
        set4f (dwName +  0, pMatrix->_11, pMatrix->_21, pMatrix->_31, pMatrix->_41);
        set4f (dwName + 16, pMatrix->_12, pMatrix->_22, pMatrix->_32, pMatrix->_42);
        set4f (dwName + 32, 0.0f,         0.0f,         0.0f,         0.0f        );
        set4f (dwName + 48, pMatrix->_13, pMatrix->_23, pMatrix->_33, pMatrix->_43);
    }
    // (s,t,r,1.0) in, (s,t,r,q) out
    void setTextureTransformMatrixType341 (DWORD dwName, D3DMATRIX *pMatrix)
    {
        set4f (dwName +  0, pMatrix->_11, pMatrix->_21, pMatrix->_31, pMatrix->_41);
        set4f (dwName + 16, pMatrix->_12, pMatrix->_22, pMatrix->_32, pMatrix->_42);
        set4f (dwName + 32, pMatrix->_13, pMatrix->_23, pMatrix->_33, pMatrix->_43);
        set4f (dwName + 48, pMatrix->_14, pMatrix->_24, pMatrix->_34, pMatrix->_44);
    }

    // set only the first three rows, since the rest is unnecessary
    void setInverseModelViewMatrix (DWORD dwName, D3DMATRIX *pMatrix)
    {
        set4f (dwName +  0, pMatrix->_11, pMatrix->_12, pMatrix->_13, pMatrix->_14);
        set4f (dwName + 16, pMatrix->_21, pMatrix->_22, pMatrix->_23, pMatrix->_24);
        set4f (dwName + 32, pMatrix->_31, pMatrix->_32, pMatrix->_33, pMatrix->_34);
    }

    // transpose the matrix since d3d does {v}[M] instead of [M]{v}'
    void setMatrixTransposed (DWORD dwName,D3DMATRIX *pMatrix)
    {
        set4f (dwName +  0, pMatrix->_11, pMatrix->_21, pMatrix->_31, pMatrix->_41);
        set4f (dwName + 16, pMatrix->_12, pMatrix->_22, pMatrix->_32, pMatrix->_42);
        set4f (dwName + 32, pMatrix->_13, pMatrix->_23, pMatrix->_33, pMatrix->_43);
        set4f (dwName + 48, pMatrix->_14, pMatrix->_24, pMatrix->_34, pMatrix->_44);
    }
};

// prototypes ---------------------------------------------------------------

HRESULT __stdcall       nvSetKelvinState           (PNVD3DCONTEXT pContext);
HRESULT __stdcall       nvSetKelvinClearState      (PNVD3DCONTEXT pContext);
KELVINDISPATCHPRIMITIVE nvKelvinGetDispatchRoutine (PNVD3DCONTEXT pConext,DWORD dwFlags);

#endif  // NVARCH >= 0x020

#endif  // _NVKELVINSTATE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\kelvin\src\nvKelvinAlphaCombiners.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvKelvinAlphaCombiners.cpp
//      routines for setting up the Kelvin alpha combiners from
//      DX6-style texture stages
//
// **************************************************************************
//
//  History:
//      Craig Duttweiler        29Mar00         NV20 development
//
// **************************************************************************
#include "nvprecomp.h"

#if (NVARCH >= 0x20)

//---------------------------------------------------------------------------

// Set an alpha input to to 1 or -1

void nvKelvinACSetAlphaInputOne (PNVD3DCONTEXT pContext, kelvinCombinerInput eInput,
                                 DWORD dwCombinerStage, BOOL bNegate)
{
    DWORD dwICW = 0;

    dwICW |= bNegate ? DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_D_MAP, _EXPAND_NORMAL) :
                       DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_D_MAP, _UNSIGNED_INVERT);

    dwICW |= DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_D_ALPHA, _FALSE);
    dwICW |= DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_D_SOURCE, _REG_0);

    pContext->hwState.dwAlphaICW[dwCombinerStage] |= (dwICW << kelvinCombinerInputShift[eInput]);
}

//---------------------------------------------------------------------------

// Select the source for combiner input eInput in combiner stage
// dwCombinerStage from argument dwD3DTSSArg in D3D stage dwD3DStage.
// return TSS_USES_NULL_TEXTURE if we reference a texture we don't have

HRESULT nvKelvinACSelectAlphaInput (PNVD3DCONTEXT pContext, kelvinCombinerInput eInput,
                                    DWORD dwCombinerStage, DWORD dwD3DStage, DWORD dwD3DTSSArg,
                                    BOOL bComplement, BOOL bExpandNormal)
{
    DWORD dwICW = 0;
    DWORD dwCurrentUsed =FALSE;
    int i;

    switch (pContext->tssState[dwD3DStage].dwValue[dwD3DTSSArg] & D3DTA_SELECTMASK) {
        case D3DTA_CURRENT:
            if (dwD3DStage != 0)
            {
                for (i=dwD3DStage - 1;i>=0;i--)
                {
                    if (pContext->tssState[i].dwValue[D3DTSS_RESULTARG] != D3DTA_TEMP)
                    {
                        dwCurrentUsed=TRUE;
                        break;
                    }
                }
            
            }
            if (dwCurrentUsed == TRUE) {
                // Output from previous stage
                dwICW |= DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_D_SOURCE, _REG_C);
                break;
            }
            // else, default to diffuse below
        case D3DTA_DIFFUSE:
            dwICW |= DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_D_SOURCE, _REG_4);
            break;
        case D3DTA_TEXTURE:
            if (!(pContext->tssState[dwD3DStage].dwValue[D3DTSS_TEXTUREMAP])) {
                // if we don't actually have a texture, default to the 'current' alpha.
                // yes, this is actually the d3d default: select texture with no texture.
                // my mama done told me, my name was duh microsoft.
                return (TSS_USES_NULL_TEXTURE);
            }
            else {
                if (pContext->hwState.dwNextAvailableTextureUnit < KELVIN_NUM_TEXTURES) {
                    pContext->hwState.dwTexUnitToTexStageMapping[pContext->hwState.dwNextAvailableTextureUnit] = dwD3DStage;
                    dwICW |= DRF_NUM (097, _SET_COMBINER_ALPHA, _ICW_D_SOURCE, KELVIN_COMBINER_REG_TEX0 + pContext->hwState.dwNextAvailableTextureUnit);
                }
                else {
                    pContext->hwState.dwStateFlags |= KELVIN_FLAG_SETUPFAILURE;
                    dwICW |= DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_D_SOURCE, _REG_0);
                }
            }
            break;
        case D3DTA_TFACTOR:
            dwICW |= DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_D_SOURCE, _REG_1);
            break;
        case D3DTA_TEMP:
            dwICW |= DRF_DEF(097, _SET_COMBINER_ALPHA, _ICW_D_SOURCE, _REG_D);
            break;
        case D3DTA_SPECULAR:
            dwICW |= DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_D_SOURCE, _REG_5);
            pContext->hwState.dwStateFlags |= KELVIN_FLAG_COMBINERSNEEDSPECULAR;
            DPF ("Specular Alpha doesn't exist in Kelvin, rendering corruption will result.",
                 pContext->tssState[dwD3DStage].dwValue[dwD3DTSSArg] & D3DTA_SELECTMASK);
            dbgD3DError();
            pContext->hwState.dwStateFlags |= KELVIN_FLAG_SETUPFAILURE;
            break;
        default:
            DPF ("unknown / illegal alpha argument '%d' in nvKelvinACSelectAlphaInput",
                 pContext->tssState[dwD3DStage].dwValue[dwD3DTSSArg] & D3DTA_SELECTMASK);
            dbgD3DError();
            pContext->hwState.dwStateFlags |= KELVIN_FLAG_SETUPFAILURE;
            break;
    }

    // handle the alpha replicate and complement flags

    dwICW |= DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_D_ALPHA, _TRUE);

    bComplement = ((pContext->tssState[dwD3DStage].dwValue[dwD3DTSSArg] & D3DTA_COMPLEMENT) ^
                   ((bComplement) ? D3DTA_COMPLEMENT : 0))
                  ?
                  TRUE : FALSE;

    if (bExpandNormal) {
        dwICW |= bComplement ? DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_D_MAP, _EXPAND_NEGATE) :
                               DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_D_MAP, _EXPAND_NORMAL);
    }
    else {
        dwICW |= bComplement ? DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_D_MAP, _UNSIGNED_INVERT) :
                               DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_D_MAP, _UNSIGNED_IDENTITY);
    }

    pContext->hwState.dwAlphaICW[dwCombinerStage] |= (dwICW << kelvinCombinerInputShift[eInput]);
    return (0);
}

//---------------------------------------------------------------------------

// Select the input into A
static HRESULT nvKelvinACSelect1 (PNVD3DCONTEXT pContext, DWORD dwHWStage, DWORD dwD3DStage)
{
    HRESULT hr;
    // Make A input
    hr = nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG1, FALSE, FALSE);
    // Make B 1
    nvKelvinACSetAlphaInputOne (pContext, kelvinCombinerInputB, dwHWStage, FALSE);
    // C & D default to zero
    return (hr);
}

//---------------------------------------------------------------------------

// Select the input into D
static HRESULT nvKelvinACSelect2 (PNVD3DCONTEXT pContext, DWORD dwHWStage, DWORD dwD3DStage)
{
    HRESULT hr;
    // Multiply D * 1
    nvKelvinACSetAlphaInputOne (pContext, kelvinCombinerInputC, dwHWStage, FALSE);
    hr = nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputD, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG2, FALSE, FALSE);
    // A & B default to zero
    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinACModulate (PNVD3DCONTEXT pContext, DWORD dwHWStage, DWORD dwD3DStage)
{
    HRESULT hr;
    // Multiply A * B
    hr  = nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG1, FALSE, FALSE);
    hr |= nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputB, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG2, FALSE, FALSE);
    // C & D default to zero
    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinACAdd (PNVD3DCONTEXT pContext, DWORD dwHWStage, DWORD dwD3DStage)
{
    HRESULT hr;
    // Multiply A * 1
    hr = nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG1, FALSE, FALSE);
    // Make B 1
    nvKelvinACSetAlphaInputOne (pContext, kelvinCombinerInputB, dwHWStage, FALSE);
    // Multiply D * 1
    nvKelvinACSetAlphaInputOne (pContext, kelvinCombinerInputC, dwHWStage, FALSE);
    hr |= nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputD, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG2, FALSE, FALSE);
    // Implicit A + D
    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinACSub (PNVD3DCONTEXT pContext, DWORD dwHWStage, DWORD dwD3DStage)
{
    HRESULT hr;
    // Multiply A * 1
    hr = nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG1, FALSE, FALSE);
    nvKelvinACSetAlphaInputOne (pContext, kelvinCombinerInputB, dwHWStage, FALSE);
    // Multiply D * -1
    nvKelvinACSetAlphaInputOne (pContext, kelvinCombinerInputC, dwHWStage, TRUE);
    hr |= nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputD, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG2, FALSE, FALSE);
    // Implicit A + -D
    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinACAddSmooth (PNVD3DCONTEXT pContext,DWORD dwHWStage, DWORD dwD3DStage)
{
    HRESULT hr;
    // Multiply A * 1
    hr = nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG1, FALSE, FALSE);
    nvKelvinACSetAlphaInputOne (pContext, kelvinCombinerInputB, dwHWStage, FALSE);
    // Make C: (1-arg1), make D: arg2
    hr |= nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputC, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG1, TRUE, FALSE);
    hr |= nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputD, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG2, FALSE, FALSE);
    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinACBlendAlpha (PNVD3DCONTEXT pContext, DWORD dwHWStage, DWORD dwD3DStage, DWORD dwType)
{
    HRESULT hr;
    DWORD dwTemp;

    // Multiply A * B(alpha)
    hr = nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG1, FALSE, FALSE);

    if (dwType == TEXTUREPM) { // this type defined by us
        // Make B 1 since texture is already pre-multiplied
        nvKelvinACSetAlphaInputOne (pContext, kelvinCombinerInputB, dwHWStage, FALSE);
        // set type again for making C (1-alpha) below
        dwType = D3DTA_TEXTURE;
    }
    else {
        // Make B alpha, appropriate type
        dwTemp = pContext->tssState[dwD3DStage].dwValue[D3DTSS_ALPHAARG2];
        pContext->tssState[dwD3DStage].dwValue[D3DTSS_ALPHAARG2] = dwType;
        hr |= nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputB, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG2, FALSE, FALSE);
        // copy arg2 back
        pContext->tssState[dwD3DStage].dwValue[D3DTSS_ALPHAARG2] = dwTemp;
    }

    // Make C: 1-alpha, make D: arg2
    dwTemp = pContext->tssState[dwD3DStage].dwValue[D3DTSS_ALPHAARG1];
    pContext->tssState[dwD3DStage].dwValue[D3DTSS_ALPHAARG1] = dwType;
    hr |= nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputC, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG1, TRUE, FALSE);
    // copy back to alphaarg1
    pContext->tssState[dwD3DStage].dwValue[D3DTSS_ALPHAARG1] = dwTemp;
    hr |= nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputD, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG2, FALSE, FALSE);

    return (hr);
}

//---------------------------------------------------------------------------

// The way D3D does this, it essentially allows using texture from stage 1
// in stage1 twice.  D3D does not normally allow you to use a texture in
// stage 0 and stage1.  This way, D3D allows you to modulate in (effectively)
// stage 0 and then do whatever it is you are going to do in stage1.  The
// key is that we use the texture from stage1 (since there is really no texture
// in stage 0)
static HRESULT nvKelvinACPremodulate (PNVD3DCONTEXT pContext,DWORD dwHWStage, DWORD dwD3DStage)
{
    HRESULT hr;
    DWORD   dwTemp;

    DPF ("pre-modulation is totally broken right now");
    dbgD3DError();

    if (dwD3DStage == 0) {
        if(pContext->tssState[dwD3DStage+1].dwValue[D3DTSS_ALPHAOP] != D3DTOP_DISABLE){
            // make A: alphaArg1(0), make B: texture(1)
             hr = nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG1, FALSE, FALSE);
             dwTemp = pContext->tssState[dwD3DStage].dwValue[D3DTSS_ALPHAARG2];
             pContext->tssState[dwD3DStage].dwValue[D3DTSS_ALPHAARG2] = D3DTA_TEXTURE;
             hr |= nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputB, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG2, FALSE, FALSE);
             // copy back arg2
             pContext->tssState[dwD3DStage].dwValue[D3DTSS_ALPHAARG2] = dwTemp;
        }
        else{
            //asked to do premodulate on a single texture stage -- just pass down
            //the colorarg1
            hr = nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG1, FALSE, FALSE);
            nvKelvinACSetAlphaInputOne (pContext, kelvinCombinerInputB, dwHWStage, FALSE);
        }

    }
    else { // well, right now we only handle two stages (we could compress these)
        // if pre-modulate is called in stage1, we could modulate with
        // texture from next stage. But, we'd have to handle settexture a bit
        // differently. For now, we'll just use selectarg1
        hr = nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG1, FALSE, FALSE);
        nvKelvinACSetAlphaInputOne (pContext, kelvinCombinerInputB, dwHWStage, FALSE);
    }

    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinACMultiplyAdd (PNVD3DCONTEXT pContext, int hdStage, int dxStage)
{
    HRESULT hr;

    // set A to arg1
    hr  = nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputA, hdStage, dxStage, D3DTSS_ALPHAARG0, FALSE, FALSE);
    //set B to 1
    nvKelvinACSetAlphaInputOne (pContext, kelvinCombinerInputB, hdStage, FALSE);
    // set C to arg2
    hr |= nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputC, hdStage, dxStage, D3DTSS_ALPHAARG1, FALSE, FALSE);
    //set D to arg3
    hr |= nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputD, hdStage, dxStage, D3DTSS_ALPHAARG2, FALSE, FALSE);

    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinACLerp (PNVD3DCONTEXT pContext, int hdStage, int dxStage)
{
    HRESULT hr;

    // Multiply A * B
    hr  = nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputA, hdStage, dxStage, D3DTSS_ALPHAARG0, FALSE, FALSE);
    hr |= nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputB, hdStage, dxStage, D3DTSS_ALPHAARG1, FALSE, FALSE);
    //set C to 1 - arg1
    hr |= nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputC, hdStage, dxStage, D3DTSS_ALPHAARG0, TRUE, FALSE);
    //set D to arg3
    hr |= nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputD, hdStage, dxStage, D3DTSS_ALPHAARG2, FALSE, FALSE);

    return (hr);
}

//---------------------------------------------------------------------------

void nvConstructKelvinOutputAlphaCombiners (PNVD3DCONTEXT pContext, BOOL bEnable,
                                            DWORD dwHWStage, DWORD dwD3DStage,
                                            BOOL bBias, DWORD dwShift, BOOL bOutTemp)
{
    bOutTemp &= (dwD3DStage != 8);

    if ((!bEnable) ||
        (pContext->tssState[dwD3DStage].dwValue[D3DTSS_COLOROP] == D3DTOP_DOTPRODUCT3))
    {
        pContext->hwState.dwAlphaOCW[dwHWStage] |= (DRF_DEF (097, _SET_COMBINER_ALPHA, _OCW_SUM_DST, _REG_0)  |
                                                    DRF_DEF (097, _SET_COMBINER_ALPHA, _OCW_AB_DST, _REG_0)   |
                                                    DRF_DEF (097, _SET_COMBINER_ALPHA, _OCW_CD_DST, _REG_0));
        return;
    }

    // select bias operation
    switch (dwShift) {
        case 0:
            pContext->hwState.dwAlphaOCW[dwHWStage] |= bBias ?
                                                       DRF_DEF (097, _SET_COMBINER_ALPHA, _OCW_OPERATION, _NOSHIFT_BIAS) :
                                                       DRF_DEF (097, _SET_COMBINER_ALPHA, _OCW_OPERATION, _NOSHIFT);
            break;
        case 1:
            pContext->hwState.dwAlphaOCW[dwHWStage] |= bBias ?
                                                       DRF_DEF (097, _SET_COMBINER_ALPHA, _OCW_OPERATION, _SHIFTLEFTBY1_BIAS) :
                                                       DRF_DEF (097, _SET_COMBINER_ALPHA, _OCW_OPERATION, _SHIFTLEFTBY1);
            break;
        case 2:
            pContext->hwState.dwAlphaOCW[dwHWStage] |= bBias ?
                                                       // we can't shift by 2 and bias. do the best we can...
                                                       DRF_DEF (097, _SET_COMBINER_ALPHA, _OCW_OPERATION, _SHIFTLEFTBY1_BIAS) :
                                                       DRF_DEF (097, _SET_COMBINER_ALPHA, _OCW_OPERATION, _SHIFTLEFTBY2);
            break;
        default:
            DPF ("illegal shift in nvConstructKelvinOutputAlphaCombiners");
            dbgD3DError();
            break;
    }  // switch

    pContext->hwState.dwAlphaOCW[dwHWStage] |= (DRF_DEF (097, _SET_COMBINER_ALPHA, _OCW_MUX_ENABLE, _FALSE) |
                                                DRF_DEF (097, _SET_COMBINER_ALPHA, _OCW_AB_DST, _REG_0)     |
                                                DRF_DEF (097, _SET_COMBINER_ALPHA, _OCW_CD_DST, _REG_0));
    pContext->hwState.dwAlphaOCW[dwHWStage] |= bOutTemp ?
                                               DRF_DEF (097, _SET_COMBINER_ALPHA, _OCW_SUM_DST, _REG_D) :
                                               DRF_DEF (097, _SET_COMBINER_ALPHA, _OCW_SUM_DST, _REG_C);
}

//---------------------------------------------------------------------------

void nvConstructKelvinAlphaCombiners (PNVD3DCONTEXT pContext, DWORD dwHWStage, DWORD dwD3DStage, BOOL bStageActive)
{
    DWORD   dwShift;
    BOOL    bBias, bEnable;
    HRESULT hr = 0;

    dwShift = 0;
    bBias   = FALSE;
    bEnable = TRUE;

    pContext->hwState.dwAlphaICW[dwHWStage] = 0;
    pContext->hwState.dwAlphaOCW[dwHWStage] = 0;

    if (!bStageActive) {
        // colorop was set to disable
        if (dwHWStage == 0) { // only construct default for stage 0
            // Default is diffuse alpha, make A=diffuse alpha, B=1, C=D=0
            pContext->hwState.dwAlphaICW[dwHWStage] |= DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_A_SOURCE, _REG_4);
            pContext->hwState.dwAlphaICW[dwHWStage] |= DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_A_ALPHA, _TRUE);
            nvKelvinACSetAlphaInputOne (pContext, kelvinCombinerInputB, dwHWStage, FALSE);
        }
        else {
            bEnable = FALSE;
        }
    }

    else {

        switch (pContext->tssState[dwD3DStage].dwValue[D3DTSS_ALPHAOP]) {
            default:
            case D3DTOP_DOTPRODUCT3:
                // We treat dot3 like disable because it doesn't really matter.
                // if the colorop is also dot3, then alpha will be overwritten momentarily anyhow.
                // BUGBUG if the colorop is NOT dot3, what the heck does this even mean???
            case D3DTOP_DISABLE:
                if (dwHWStage == 0) { // only construct default for stage 0
                    // Default is diffuse alpha, make A=diffuse alpha, B=1, C=D=0
                    pContext->hwState.dwAlphaICW[dwHWStage] |= DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_A_SOURCE, _REG_4);
                    pContext->hwState.dwAlphaICW[dwHWStage] |= DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_A_ALPHA, _TRUE);
                    nvKelvinACSetAlphaInputOne (pContext, kelvinCombinerInputB, dwHWStage, FALSE);
                }
                else {
                    bEnable = FALSE;
                }
                break;
            case D3DTOP_SELECTARG1:
                hr = nvKelvinACSelect1 (pContext, dwHWStage, dwD3DStage);
                break;
            case D3DTOP_SELECTARG2:
                hr = nvKelvinACSelect2 (pContext, dwHWStage, dwD3DStage);
                break;
            case D3DTOP_MODULATE4X:
                dwShift++;
            case D3DTOP_MODULATE2X:
                dwShift++;
            case D3DTOP_MODULATE:
                hr = nvKelvinACModulate (pContext, dwHWStage, dwD3DStage);
                break;
            case D3DTOP_ADDSIGNED2X: // same as addsigned with following change
                dwShift = 1;
            case D3DTOP_ADDSIGNED:   // same as add with following change
                bBias = TRUE;
            case D3DTOP_ADD:
                hr = nvKelvinACAdd (pContext, dwHWStage, dwD3DStage);
                break;
            case D3DTOP_SUBTRACT:
                hr = nvKelvinACSub (pContext, dwHWStage, dwD3DStage);
                break;
            case D3DTOP_ADDSMOOTH:
                hr = nvKelvinACAddSmooth (pContext, dwHWStage, dwD3DStage);
                break;
            case D3DTOP_BLENDDIFFUSEALPHA:
                hr = nvKelvinACBlendAlpha (pContext, dwHWStage, dwD3DStage, D3DTA_DIFFUSE);
                break;
            case D3DTOP_BLENDTEXTUREALPHA:
                hr = nvKelvinACBlendAlpha (pContext, dwHWStage, dwD3DStage, D3DTA_TEXTURE);
                break;
            case D3DTOP_BLENDFACTORALPHA:
                hr = nvKelvinACBlendAlpha (pContext, dwHWStage, dwD3DStage, D3DTA_TFACTOR);
                break;
            case D3DTOP_BLENDTEXTUREALPHAPM:
                hr = nvKelvinACBlendAlpha (pContext,dwHWStage, dwD3DStage, TEXTUREPM);
                break;
            case D3DTOP_BLENDCURRENTALPHA:
                hr = nvKelvinACBlendAlpha (pContext, dwHWStage, dwD3DStage, D3DTA_CURRENT);
                break;
            case D3DTOP_PREMODULATE:
                hr = nvKelvinACPremodulate (pContext, dwHWStage, dwD3DStage);
                break;
// BUGBUG
#if 0
            case D3DTOP_ALPHAMODULATE:
                // This is the case where the old D3DRENDERSTATE_TEXTUREMAPBLEND was used with
                // the D3DTBLEND_MODULATE op because the dump translates this into TSS we define
                // a new op that properly handles D3DTBLEND_MODULATE
                // Alpha is obtained by the texture, if it has alpha otherwise it is obtained from
                // the vertex. The dump always sets arg1 to be texture and arg2 to be current
                if (statev.ptexture[0] && statev.ptexture[0]->sd.ddpfPixelFormat.dwRGBAlphaBitMask) {
                    nvKelvinACSelect1(dwHWStage);
                }
                else {
                    nvKelvinACSelect2(dwHWStage);
                }
                break;
#endif
            case D3DTOP_MULTIPLYADD:
                hr = nvKelvinACMultiplyAdd (pContext, dwHWStage, dwD3DStage);
                break;
            case D3DTOP_LERP:
                hr = nvKelvinACLerp (pContext, dwHWStage, dwD3DStage);
                break;
        }  // switch

    }

    if (hr == TSS_USES_NULL_TEXTURE) {
        // this stage references a non-existent texture. just set it back to "select current"
        if (dwHWStage == 0) {
            // current = diffuse in stage 0
            pContext->hwState.dwAlphaICW[dwHWStage] = DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_A_SOURCE, _REG_4) |
                                                          DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_A_ALPHA, _TRUE);
        }
        else {
            pContext->hwState.dwAlphaICW[dwHWStage] = DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_A_SOURCE, _REG_C) |
                                                          DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_A_ALPHA, _TRUE);
        }
        nvKelvinACSetAlphaInputOne (pContext, kelvinCombinerInputB, dwHWStage, FALSE);
    }

    nvConstructKelvinOutputAlphaCombiners (pContext, bEnable, dwHWStage, dwD3DStage, bBias, dwShift,
                                           pContext->tssState[dwD3DStage].dwValue[D3DTSS_RESULTARG] == D3DTA_TEMP);

}

#endif  // NVARCH == 0x20
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\kelvin\src\nvKelvinInlPrim.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvKelvinInlPrim.cpp
//      compiled inner loops for Kelvin inline primitives
//
// **************************************************************************
//
//  History:
//      Craig Duttweiler        10Aug2000         port from celsius
//
// **************************************************************************
#include "nvprecomp.h"

#if (NVARCH >= 0x20)

#include "x86.h"

#ifdef KELVIN_ILC
//////////////////////////////////////////////////////////////////////////////
// notes:
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// switches
//

//////////////////////////////////////////////////////////////////////////////
// aliases
//
#define ilcData         global.dwILCData
#define ilcCount        global.dwILCCount
#define ilcMax          global.dwILCMax

//////////////////////////////////////////////////////////////////////////////
// externals
//
void ILCCompile_mul                            (DWORD reg,DWORD num);
void nvKelvinILCompile_copyVertex              (PNVD3DCONTEXT pContext,DWORD dwFlags);
void nvKelvinILCompile_prefetch                (BOOL bIsIndexed,BOOL bLegacyStrides);
void nvKelvinILCompile_limit                   (DWORD regLimit,DWORD regDummy);

void __stdcall nvKelvinDispatchGetPusherSpace (void);

//---------------------------------------------------------------------------
DWORD nvKelvinILCompile_inline_prim
(
    PNVD3DCONTEXT pContext,
    DWORD         dwFlags
)
{
     //
    // get loop constants
    //
    DWORD  dwMagic                = kelvinPrimitiveToPrimitiveMagic[dwFlags & KELVIN_ILMASK_PRIMTYPE];
    DWORD  dwVerticesPerPrim      = (dwMagic >> 8) & 0xff;
    DWORD  dwStartVerticesPerPrim = (dwMagic >> 0) & 0xff;
    BOOL   bLegacyStrides         = dwFlags & KELVIN_ILFLAG_LEGACY;
    BOOL   bIsIndexed             = (dwFlags & KELVIN_ILMASK_LOOPTYPE) == KELVIN_ILFLAG_IX_INL_PRIM;

    //
    // align entry point
    //
    while (ilcCount & 31) { xINT3 }
    DWORD lEntry;
    xLABEL (lEntry);

    //
    // setup stack frame
    //
    xPUSH_r     (rEBP)
    xPUSH_r     (rEBX)
    xPUSH_r     (rESI)
    xPUSH_r     (rEDI)

    //
    // verify that we are using the correct inner loop - debug only
    //
#ifdef DEBUG
    DWORD ld1,ld2;
    xLABEL      (ld1)
    xJMP        (0)
    xLABEL      (ld2)
    xINT3

#define CHECK(a,x)                  \
{                                   \
    xMOV_rm_imm (rmREG(rEBX),a)     \
    xMOV_rm_imm (rmREG(rEAX),x)     \
    xCMP_r_i32  (rEAX,mMEM32(x))    \
    xJNZ32      (ld2)               \
}
#define CHECK2(a,x,y,t)             \
{                                   \
    xMOV_r_i32  (rEDX,mMEM32(global.kelvin.x))    \
    xMOV_rm_imm (rmREG(rEBX),a)     \
    xMOV_rm_imm (rmREG(rEAX),x->y)   \
    xCMP_r_rm   (rEAX,rmIND32(rEDX)) xOFS32(OFFSETOF(t,y)) \
    xJNZ32      (ld2)               \
}

    xTARGET_jmp (ld1)

/*
    CHECK (0x00000000,fvfData.dwVertexStride)

    CHECK (0x00010000,fvfData.dwVertexType)

    CHECK (0x00020000,fvfData.dwUVCount[0])
    CHECK (0x00020001,fvfData.dwUVCount[1])
    CHECK (0x00020002,fvfData.dwUVCount[2])
    CHECK (0x00020003,fvfData.dwUVCount[3])
    CHECK (0x00020004,fvfData.dwUVCount[4])
    CHECK (0x00020005,fvfData.dwUVCount[5])
    CHECK (0x00020006,fvfData.dwUVCount[6])
    CHECK (0x00020007,fvfData.dwUVCount[7])

    CHECK (0x00030000,fvfData.dwUVOffset[0])
    CHECK (0x00030001,fvfData.dwUVOffset[1])
    CHECK (0x00030002,fvfData.dwUVOffset[2])
    CHECK (0x00030003,fvfData.dwUVOffset[3])
    CHECK (0x00030004,fvfData.dwUVOffset[4])
    CHECK (0x00030005,fvfData.dwUVOffset[5])
    CHECK (0x00030006,fvfData.dwUVOffset[6])
    CHECK (0x00030007,fvfData.dwUVOffset[7])
*/

    //  - pContext->hwState.dwStateFlags & KELVIN_MASK_INNERLOOPUNIQUENESS
    xMOV_r_i32  (rEDX,mMEM32(global.kelvin.pContext))
    xMOV_rm_imm (rmREG(rEBX),0x00040000)
    xMOV_r_rm   (rEAX,rmIND32(rEDX)) xOFS32(OFFSETOF(NVD3DCONTEXT, hwState.dwStateFlags))
    xAND_rm_imm (rmREG(rEAX),KELVIN_MASK_INNERLOOPUNIQUENESS)
    xCMP_rm_imm (rmREG(rEAX),pContext->hwState.dwStateFlags & KELVIN_MASK_INNERLOOPUNIQUENESS)
    xJNZ32      (ld2)

    if (pContext->hwState.dwStateFlags & KELVIN_FLAG_USERTEXCOORDSNEEDED(0))
    {
        CHECK2 (0x00050000,pContext,hwState.dwTexUnitToTexStageMapping[0],NVD3DCONTEXT)
    }
    if (pContext->hwState.dwStateFlags & KELVIN_FLAG_USERTEXCOORDSNEEDED(1))
    {
        CHECK2 (0x00050001,pContext,hwState.dwTexUnitToTexStageMapping[1],NVD3DCONTEXT)
    }
#endif

#ifdef KELVIN_INLINE_REUSE
    if (bIsIndexed)
    {
        // clear the reuse history buffer
        xMOV_rm_imm     (rmREG(rECX), KELVIN_MAX_REUSE)
        xMOV_rm_imm     (rmREG(rEDI), mMEM32(global.kelvin.dwVertexReuse))
        DWORD lClearReuse;
        xLABEL          (lClearReuse);
        xMOV_rm_imm     (rmIND(rEDI), 0xffffffff);
        xADD_rm_imm8    (rmREG(rEDI), 0x4);
        xDEC_r          (rECX)
        xJNZ            (lClearReuse)

        xXOR_r_rm       (rEAX, rmREG(rEAX))
        xMOV_i32_r      (mMEM32(global.kelvin.dwCurrentHistoryIndex), rEAX)


    }

#endif KELVIN_INLINE_REUSE

//     if (pContext->hwState.pVertexShader->bVAExists(CVertexShader::PSIZE_ARRAY)) // do the point size
//     {
// #if 0 //USE_C_LOGIC
//         xMOV_rm_imm (rmREG(rEAX),dwFlags)
//             xPUSH_r (rEAX)
//             xMOV_rm_imm (rmREG(rEAX),nvCelsiusDumpTLPoints)
//             xCALL_rm (rmREG(rEAX))
//             xADD_rm_imm (rmREG(rESP),4);
// #else //USE_C_LOGIC
//         nvAssert(0);
// #endif
//     }
//     else
    {
    //
    // setup push buffer
    //
    xMOV_r_i32  (rEDX,mMEM32(pDriverData))
    xMOV_r_rm   (rEDI,rmIND32(rEDX)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))

    //
    // calc how many verts to copy into EBX
    //
    xMOV_r_i32  (rEBX,mMEM32(global.kelvin.dwPrimCount))
    ILCCompile_mul (rEBX, dwVerticesPerPrim);
    if (dwStartVerticesPerPrim)
    {
        xADD_rm_imm (rmREG(rEBX),dwStartVerticesPerPrim)
    }

    //
    // setup prefetcher (EBX has # of vertices to copy in total)
    //
    if (bIsIndexed)
    {
        xMOV_r_i32  (rEAX,mMEM32(global.kelvin.pIndices))
         xLEA_r_rm   (rECX,rmSIB) xSIB(rEAX,rEBX,x2)
        xMOV_i32_r  (mMEM32(global.kelvin.dwPrefetchBase),rEAX)
         xMOV_i32_r  (mMEM32(global.kelvin.dwPrefetchMax),rECX)
        if (bLegacyStrides)
        {
            xMOV_r_i32  (rEAX,mMEM32(global.kelvin.pIndices))
            xMOV_i32_r  (mMEM32(global.kelvin.pIndexBase),rEAX)
        }
    }
    else
    {
        xMOV_r_i32  (rEAX,mMEM32(global.kelvin.pVertices))
         xMOV_r_rm   (rECX,rmREG(rEBX))
         ILCCompile_mul (rECX,global.kelvin.dwVertexStride);
         xADD_r_rm   (rECX,rmREG(rEAX))
        xMOV_i32_r  (mMEM32(global.kelvin.dwPrefetchBase),rEAX)
         xMOV_i32_r  (mMEM32(global.kelvin.dwPrefetchMax),rECX)
    }

    //
    // start primitive
    //
    xMOV_rm_imm (rmREG(rEAX),((sizeSetNv20KelvinBeginEndMthdCnt << 2) << 16) | ((NV_DD_KELVIN) << 13) | NV097_SET_BEGIN_END);
    xMOV_rm_imm (rmREG(rECX),kelvinBeginEndOp[dwFlags & KELVIN_ILMASK_PRIMTYPE])
    xMOV_rm_r   (rmIND(rEDI),rEAX)
    xMOV_rm_r   (rmIND8(rEDI),rECX) xOFS8(4)
    xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(8)

#ifdef KELVIN_INLINE_REUSE
    DWORD           nextVertex;
#endif

    //
    // start copying
    //   for this loop EDI points to PUT and EBX has the amount of prims to go
    //
    DWORD labelLoop;
    xLABEL  (labelLoop)
    {
        xPUSH_r     (rEBX)

        //
        // prefetch
        //
        nvKelvinILCompile_prefetch (bIsIndexed, bLegacyStrides);

        //
        // copy vertex
        //
        if (bIsIndexed)
        {
            // get index
            xMOV_r_i32  (rEDX,mMEM32(global.kelvin.pIndices))
            xXOR_r_rm   (rESI,rmREG(rESI))
       x16r xMOV_r_rm   (rSI,rmIND(rEDX))
            xLEA_r_rm   (rEDX,rmIND8(rEDX)) xOFS8(2)
            if (bLegacyStrides)
            {
                xMOV_r_rm   (rEAX,rmREG(rEDX))
                xSUB_r_i32  (rEAX,mMEM32(global.kelvin.pIndexBase))
                xAND_rm_imm (rmREG(rEAX),6)
                xXOR_r_rm   (rECX,rmREG(rECX))
                xCMP_rm_imm (rmREG(rEAX),6)
                xSETNZ_rm8  (rmREG(rCL))
                xDEC_rm     (rmREG(rECX))
                xAND_rm_imm (rmREG(rECX),2)
                xADD_r_rm   (rEDX,rmREG(rECX))
            }
            xMOV_i32_r  (mMEM32(global.kelvin.pIndices),rEDX)

#ifdef KELVIN_INLINE_REUSE
            // ESI contains the vertex

            xMOV_r_i32      (rEAX, mMEM32(global.kelvin.dwCurrentHistoryIndex))
            xMOV_rm_imm     (rmREG(rECX), KELVIN_MAX_REUSE)
            xXOR_r_rm       (rEDX, rmREG(rEDX))

            DWORD ReuseLoop;
            xLABEL          (ReuseLoop)


            xCMP_r_rm       (rESI, rmSIB) xSIBID(rEAX,x4) xOFS32(mMEM32(global.kelvin.dwVertexReuse[0]))
            DWORD notFound;
            xLABEL          (notFound)
            xJNZ            (0)

            // output reused index
            xMOV_rm_imm     (rmREG(rEBX),( ( ((1) << 2) << 16) | ((NV_DD_KELVIN) << 13) | (NV097_INLINE_VERTEX_REUSE)))
            xMOV_rm_r       (rmIND(rEDI),rEBX)
            xMOV_rm_r       (rmIND8(rEDI),rEDX) xOFS8(4)
            xLEA_r_rm       (rEDI, rmIND8(rEDI)) xOFS8(8)

            xLABEL          (nextVertex)
            xJMP            (0)

            xTARGET_b8      (notFound)
            xINC_r          (rEDX)

            xDEC_r          (rEAX)
            xAND_rm_imm8    (rmREG(rEAX), KELVIN_REUSE_MASK)

            xDEC_r          (rECX)
            xJNZ            (ReuseLoop)

            // New index -- output it and update cached indices

            xMOV_r_i32      (rEAX, mMEM32(global.kelvin.dwCurrentHistoryIndex))
            xINC_r          (rEAX)
            xAND_rm_imm8    (rmREG(rEAX), KELVIN_REUSE_MASK)
            xMOV_i32_r      (mMEM32(global.kelvin.dwCurrentHistoryIndex), rEAX)
            xMOV_rm_r       (rmSIB, rESI) xSIBID(rEAX,x4) xOFS32(mMEM32(global.kelvin.dwVertexReuse[0]))


#endif // KELVIN_INLINE_REUSE

            // compute vertex offset
            ILCCompile_mul (rESI,global.kelvin.dwVertexStride);
            // range limit for NT
            nvKelvinILCompile_limit (rESI,rECX);

            // compute vertex address
            xADD_r_i32  (rESI,mMEM32(global.kelvin.pVertices))
        }
        else
        {
            // get vertex & increment
            xMOV_r_i32  (rESI,mMEM32(global.kelvin.pVertices))
            xLEA_r_rm   (rEAX,rmIND32(rESI)) xOFS32(global.kelvin.dwVertexStride)
            xMOV_i32_r  (mMEM32(global.kelvin.pVertices),rEAX)
        }

        // copy vertex (from ESI to EDI)
        nvKelvinILCompile_copyVertex (pContext,dwFlags);

        // update instumentation stats
#ifdef INSTRUMENT_INNER_LOOPS
        {
            xMOV_rm_imm (rmREG(rEAX),fvfData.dwVertexStride)
            xADD_i32_r  (mMEM32(global.dwBytesCopied),rEAX)
        }
#endif

#ifdef KELVIN_INLINE_REUSE
        if (bIsIndexed)
        {
            xTARGET_jmp     (nextVertex)
        }
#endif//KELVIN_INLINE_REUSE

        // check for pusher space
        DWORD labelSpace;
        xMOV_r_i32  (rESI,mMEM32(pDriverData))
        xCMP_r_rm   (rEDI,rmIND32(rESI)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwThreshold))
        xLABEL      (labelSpace)
        xJL         (0)
        {
            xMOV_rm_r   (rmIND32(rESI),rEDI) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
            xMOV_rm_imm (rmREG(rEAX),(DWORD)nvKelvinDispatchGetPusherSpace)
            xCALL_rm    (rmREG(rEAX))
            xMOV_r_rm   (rEDI,rmIND32(rESI)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
        }
        xTARGET_b8  (labelSpace)

        // next
        xPOP_r  (rEBX)
        xDEC_rm (rmREG(rEBX))
    }
    xJNZ32  (labelLoop)

    //
    // end primitive
    //
    xMOV_rm_imm (rmREG(rEAX),((sizeSetNv20KelvinBeginEndMthdCnt << 2) << 16) | ((NV_DD_KELVIN) << 13) | NV097_SET_BEGIN_END);
    xMOV_rm_imm (rmREG(rECX),NV097_SET_BEGIN_END_OP_END)
    xMOV_rm_r   (rmIND(rEDI),rEAX)
    xMOV_rm_r   (rmIND8(rEDI),rECX) xOFS8(4)
    xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(8)

    //
    // save off push buffer
    //
    xMOV_r_i32  (rEDX,mMEM32(pDriverData))
#ifndef NV_NULL_HW_DRIVER
    xMOV_rm_r   (rmIND32(rEDX),rEDI) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
#endif
    }
    //
    // done
    //
    xPOP_r      (rEDI)
    xPOP_r      (rESI)
    xPOP_r      (rEBX)
    xPOP_r      (rEBP)
    xRET

    return lEntry;
}

#endif // KELVIN_ILC

#endif  // NVARCH == 0x20
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\kelvin\src\nvKelvinPrim.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvKelvinPrim.cpp
//      Kelvin primitive rendering routines
//
// **************************************************************************
//
//  History:
//      Craig Duttweiler        26Apr2000         NV20 development
//
// **************************************************************************
#include "nvprecomp.h"

#if (NVARCH >= 0x20)

#ifdef KELVIN_ILC
DWORD UseKelvinILC = 1;     //Temp - set to zero to disable Kelvin compiled inner loops.
#endif

#ifdef PROFILE_INDEX
void nvLogIndexData(DWORD, DWORD, WORD *);
#endif

// switches
#define VERTEX_REUSE

//---------------------------------------------------------------------------
// forward declarations

void nvKelvinDispatchIndexedPrimitiveInline    (PNVD3DCONTEXT       pContext,
                                                DWORD               dwCount,
                                                BOOL                bLegacyStrides);
void nvKelvinDispatchNonIndexedPrimitiveInline (PNVD3DCONTEXT       pContext,
                                                DWORD               dwCount);

//---------------------------------------------------------------------------

void nvKelvinDispatchIndexedPrimitive
(
    NV_INNERLOOP_ARGLIST
)
{
    BOOL bLegacyStrides;

#ifdef FORCE_NULL
    return;
#endif

#ifdef PROFILE_INDEX
    nvLogIndexData(dwDP2Operation, (DWORD)wCount, pIndices);
#endif //PROFILE_INDEX

    // any work?
    if (dwCount == 0) return;

    DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, dwCount);
    bLegacyStrides = (pContext->dp2.dwDP2Prim == D3DDP2OP_INDEXEDTRIANGLELIST) ? TRUE : FALSE;

    // book keeping
    if (pContext->pZetaBuffer) {
        pContext->pZetaBuffer->getWrapper()->setCTDrawPrim();
    }

    // lock surfaces for use by the HW
    nvHWLockTextures (pContext);
    nvHWLockStreams (pContext, KELVIN_CAPS_MAX_STREAMS);

#if SYSVB2AGP
    DWORD bAltVBPerfStrategy = ( (pContext->dwEarlyCopyStrategy) || (pContext->dwEarlyCopyStrategy > 0x20));

    if (bAltVBPerfStrategy) {

        if (pContext->dp2.dwDP2Prim == D3DDP2OP_INDEXEDTRIANGLELIST2 && pContext->dp2.dwVertexBufferOffset == 0)
        {
            if (!pContext->sysvb.pSysMemVB)
            {
                DWORD stream = pContext->hwState.pVertexShader->getVAStream(defaultInputRegMap[D3DVSDE_POSITION]);
                CVertexBuffer *pVertexBuffer = pContext->ppDX8Streams[stream];
                if (!pVertexBuffer->cachedhwCanRead())
                {

                    DWORD dwTotalSize = pContext->hwState.pVertexShader->getStride() * pContext->dp2.dwVertexLength;
                    if (dwTotalSize < pDriverData->nvD3DPerfData.dwRecommendedStageBufferSize)   // never fill more than 1/4 at once
                    {
                        pContext->sysvb.dwStreamDMACount = pContext->dwStreamDMACount;
                        pContext->dwStreamDMACount &= 0xffff;
                        // get default VB
                        CVertexBuffer *pDefVertexBuffer = getDC()->defaultVB.getVB();
                        DWORD stride = pContext->hwState.pVertexShader->getStride();

                        pDefVertexBuffer->setVertexStride(stride);

                        // check for space
                        DWORD dwVBOffset = (getDC()->defaultVB.waitForSpace(dwTotalSize + 64 * 12, TRUE) + 32) & ~31;
                        // copy verts
                        nvMemCopy (pDefVertexBuffer->getAddress() + dwVBOffset ,
                                   (DWORD)pVertexBuffer->getAddress(),
                                   dwTotalSize);
                        // set up supertri
                        pDefVertexBuffer->setSuperTriLookAsideBuffer ((void*)((DWORD)pVertexBuffer->getAddress()));
                        pContext->dp2.dwVertexBufferOffsetSave = pContext->dp2.dwVertexBufferOffset;
                        pContext->sysvb.dwDefVBOffset = pContext->dp2.dwVertexBufferOffset = dwVBOffset;

                        pContext->sysvb.pSysMemVB = pVertexBuffer;
                        pContext->sysvb.dwSysMemVBStream = stream;
                        pContext->ppDX8Streams[stream] = pDefVertexBuffer;

                        // unlock vb
                        getDC()->defaultVB.m_dwTotalVerticesSincePut += pContext->dp2.dwVertexLength;
                        if (getDC()->defaultVB.m_dwTotalVerticesSincePut >= 128)
                        {
                            pContext->sysvb.bWriteOffset = TRUE;
                            getDC()->defaultVB.m_dwTotalVerticesSincePut = 0;
                        }
                        getDC()->defaultVB.m_dwCurrentOffset = dwVBOffset + dwTotalSize;

                    }
                }
            }
            else
            {
                pContext->sysvb.dwStreamDMACount = pContext->dwStreamDMACount;
                pContext->dwStreamDMACount &= 0xffff;
                pContext->dp2.dwVertexBufferOffsetSave = pContext->dp2.dwVertexBufferOffset;
                pContext->dp2.dwVertexBufferOffset = pContext->sysvb.dwDefVBOffset;
                pContext->sysvb.pSysMemVB = pContext->ppDX8Streams[pContext->sysvb.dwSysMemVBStream];
                pContext->ppDX8Streams[pContext->sysvb.dwSysMemVBStream] = getDC()->defaultVB.getVB();
            }
        }
    }
#endif //SYSVB2AGP

    // set the vertex sources and if anything has changed, dirty the fvf flag
    if (pContext->hwState.dwVertexOffset != pContext->dp2.dwVertexBufferOffset)
    {
        pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_FVF;
    }

    // ugh.  Special case to set up the combiners for pointsprites..
    if ((pContext->dwRenderState[D3DRS_POINTSPRITEENABLE]) &&
        (pContext->hwState.dwCombinerDP2Prim != pContext->dp2.dwDP2Prim))
    {
        pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_COMBINERS_COLOR;
    }

#ifdef KELVIN_ILC
// ToDo: Insert code to copy SYSMEM VB's to AGP here. Make it work for things other than test 6 & 7.

//     if (!pContext->ppDX8Streams[pContext->pCurrentVShader->getVAStream(defaultInputRegMap[D3DVSDE_POSITION])]->cachedhwCanRead())
//     {
//         __asm int 3
//     }
#endif //KELVIN_ILC

    // set kelvin state (required to get the correct inner loop)
    nvSetKelvinState (pContext);

#ifdef FORCE_INLINE_VERTICES

    nvKelvinDispatchIndexedPrimitiveInline (pContext, dwCount, pIndices, bLegacyStrides);

#else // !FORCE_INLINE_VERTICES

#ifdef KELVIN_ILC
    // get inner loop entry point flags
    DWORD dwFlags = (pContext->dp2.dwDP2Prim & KELVIN_ILMASK_PRIMTYPE)
                  | (bLegacyStrides ? KELVIN_ILFLAG_LEGACY : 0);
#endif KELVIN_ILC


#ifdef KELVIN_ILC

    if (UseKelvinILC)
    {
        if (pContext->dp2.dwIndexStride == 4) {
            goto C_Code;
        }

        if (pContext->hwState.dwInlineVertexStride)
        {
            if ((pContext->hwState.pVertexShader->hasProgram())
             || (NV_NUM_UNIQUE_STREAMS(pContext->dwStreamDMACount) > 1) // asm code doesn't handle multiple streams
             || (NV_NUM_SYSTEM_STREAMS(pContext->dwStreamDMACount) > 1)) {
                goto C_Code;
            }

            if ((dwCount >= KELVIN_SHORT_INDEXED_PRIM_COUNT_CUTOFF) &&
                ((kelvinPrimitiveToPrimitiveMagic[pContext->dp2.dwDP2Prim] & 0x00ffffff) == 0x00030300))
            {
                if (NV_VERTEX_TRANSFORMED(pContext->hwState.pVertexShader)) {
                    dwFlags |= KELVIN_ILFLAG_IX_INL_TRI_LIST;
                }
                else {
                    dwFlags |= KELVIN_ILFLAG_IX_INL_PRIM;
                }
                dwFlags                    |= ((pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_NONE) ? KELVIN_ILFLAG_NOCULL : 0);
                global.kelvin.dwCullValue  =  (pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_CCW)  ? 0x80000000 : 0x00000000;
            }
            else {
                dwFlags |= KELVIN_ILFLAG_IX_INL_PRIM;
            }
        }

        else
        {
            if (pContext->hwState.SuperTri.Strategy (pContext->dp2.dwDP2Prim, dwCount, pContext->hwState.pVertexShader))
            {
                dwFlags |= KELVIN_ILFLAG_SUPER_TRI_LIST;
            }
            else
            {
                dwFlags |= KELVIN_ILFLAG_IX_VB_PRIM;
            }
        }

        // setup variables passed to innerloop
        global.kelvin.pContext              = (DWORD)pContext;
        global.kelvin.pContext_kelvinState  = (DWORD)&pContext->hwState;
        global.kelvin.dwPrimCount           = dwCount;

        global.kelvin.dwVertexStride        = pContext->hwState.pVertexShader->getStride();  // vertex stride of source data
        global.kelvin.pIndices              = pContext->dp2.dwIndices;
        global.kelvin.dwIndexStride         = pContext->dp2.dwIndexStride;

        // BUGBUG this won't work with vertex shaders
        // pVertices is used in the inline functions and needs the base vertex (dwVStart) built in.
        // pVertices is not used in the VB routines - they use dwBaseVertex
        global.kelvin.pVertices             = pContext->hwState.ppStreams[pContext->hwState.pVertexShader->getVAStream(defaultInputRegMap[D3DVSDE_POSITION])]->getAddress() +
                                              pContext->hwState.dwVertexOffset +
                                              pContext->dp2.dwVStart * pContext->hwState.ppStreams[pContext->hwState.pVertexShader->getVAStream(defaultInputRegMap[D3DVSDE_POSITION])]->getVertexStride() +
                                              pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]);
        //set base vertex for use in VB Prim and super tri routines
        global.kelvin.dwBaseVertex          = pContext->dp2.dwVStart;

        // set component offsets
        global.kelvin.dwOffsetXYZ           = pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]);
        global.kelvin.dwOffsetRHW           = pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]) + 3*sizeof(DWORD);
        global.kelvin.dwOffsetWeight        = pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_BLENDWEIGHT]);
        global.kelvin.dwOffsetNormal        = pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_NORMAL]);
        global.kelvin.dwOffsetDiffuse       = pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_DIFFUSE]);
        global.kelvin.dwOffsetSpecular      = pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_SPECULAR]);
        global.kelvin.dwOffsetPointSize     = pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_PSIZE]);
        for (DWORD i=0; i<KELVIN_CAPS_MAX_UV_PAIRS; i++) {
            global.kelvin.dwOffsetUV[i]     = pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_TEXCOORD0+i]);
        }
        global.kelvin.dwEyeAddr             = pContext->hwState.SuperTri.getEyeAddr();
        global.kelvin.dwCullAddr            = pContext->hwState.SuperTri.getCullsignAddr();

        if ((dwFlags & KELVIN_ILMASK_LOOPTYPE) == KELVIN_ILFLAG_SUPER_TRI_LIST)
        {
            // do preprocessing
            dwFlags                   |= ((pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_NONE) ? KELVIN_ILFLAG_NOCULL : 0);
            global.kelvin.dwCullValue  = (pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_CCW)  ? 0x80000000 : 0x00000000;
            CVertexBuffer *pVertexBufferInUse = pContext->ppDX8Streams[pContext->hwState.pVertexShader->getVAStream(defaultInputRegMap[D3DVSDE_POSITION])];
            global.kelvin.pVertices           = (DWORD) pVertexBufferInUse->getSuperTriLookAsideBuffer() +
                                                pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]);
        }

        KELVINDISPATCHPRIMITIVE pfn = nvKelvinGetDispatchRoutine(pContext,dwFlags);
        if (pfn) pfn();
    }
    else
    {

#endif //KELVIN_ILC
C_Code:
    if (pContext->hwState.dwInlineVertexStride)
    {

        // vertices are not in video memory or not accessible by HW. shove them through the push buffer
        nvKelvinDispatchIndexedPrimitiveInline (pContext, dwCount, bLegacyStrides);
    }
    else
    {
        // vertices are in video memory. allow NV20 to fetch them from there

        nvAssert (kelvinBeginEndOp[pContext->dp2.dwDP2Prim] != ~0);
        nvglSetNv20KelvinBeginEnd (NV_DD_KELVIN, kelvinBeginEndOp[pContext->dp2.dwDP2Prim]);

        // determine the number of indices
        DWORD dwScaleAndBias = kelvinPrimitiveToPrimitiveMagic[pContext->dp2.dwDP2Prim];
        nvAssert (dwScaleAndBias != ~0);
        DWORD dwIndexCount = (((dwScaleAndBias >> 8) & 0xff) * dwCount) + (dwScaleAndBias & 0xff);

        // cache index info
        PBYTE pIndices  = (PBYTE)(pContext->dp2.dwIndices);
        DWORD dwIStride = pContext->dp2.dwIndexStride;

        // dump 32-bit blocks of indices
        DWORD dw32BitCount, dw32BitStart, dwMethod;
        if (dwIStride == 2) {
            dw32BitCount = dwIndexCount >> 1;
            dw32BitStart = (pContext->dp2.dwVStart << 16) | (pContext->dp2.dwVStart << 0);
            dwMethod     = NV097_ARRAY_ELEMENT16;
        }
        else {
            nvAssert (dwIStride == 4);
            dw32BitCount = dwIndexCount;
            dw32BitStart = pContext->dp2.dwVStart;
            dwMethod     = NV097_ARRAY_ELEMENT32;
        }

        while (dw32BitCount) {
            DWORD dwCount = min (dw32BitCount, KELVIN_MAX_NONINC_DATA);
            getDC()->nvPusher.makeSpace (sizeSetStartMethod + dwCount);
            nvglSetStartMethod (0, NV_DD_KELVIN, NONINC_METHOD(dwMethod), dwCount);
            getDC()->nvPusher.inc (sizeSetStartMethod);
            for (DWORD i=0; i<dwCount; i++) {
                nvglSetData (i, *((DWORD*)pIndices) + dw32BitStart);
                pIndices += 4;
            }
            getDC()->nvPusher.inc (dwCount);
            dw32BitCount -= dwCount;
        }

        // handle the odd 16-bit index if there is one
        if ((dwIStride == 2) && (dwIndexCount & 0x1)) {
            getDC()->nvPusher.makeSpace (sizeSetStartMethod + 1);
            nvglSetStartMethod (0, NV_DD_KELVIN, NONINC_METHOD(NV097_ARRAY_ELEMENT32), 1);
            getDC()->nvPusher.inc (sizeSetStartMethod);
            nvglSetData (0, (DWORD)(*((WORD*)pIndices)) + pContext->dp2.dwVStart);
            getDC()->nvPusher.inc (1);
        }

        nvglSetNv20KelvinBeginEnd (NV_DD_KELVIN, NV097_SET_BEGIN_END_OP_END);

    }


#ifdef KELVIN_ILC
    }
#endif



#endif // !FORCE_INLINE_VERTICES

#if SYSVB2AGP
    if (pContext->sysvb.pSysMemVB)
    {
        DWORD stream = pContext->sysvb.dwSysMemVBStream;
        pContext->ppDX8Streams[pContext->sysvb.dwSysMemVBStream] = pContext->sysvb.pSysMemVB;
        pContext->sysvb.pSysMemVB = getDC()->defaultVB.getVB();
        pContext->dwStreamDMACount = pContext->sysvb.dwStreamDMACount;
        pContext->dp2.dwVertexBufferOffset = pContext->dp2.dwVertexBufferOffsetSave;
    }
#endif
    //set that we need to unlock all surfaces.  defer till we need to to lower number of CPU
    //clocks per primitive.
    pContext->dwHWUnlockAllPending = TRUE;
}

//---------------------------------------------------------------------------

void nvKelvinDispatchNonIndexedPrimitive
(
    NV_INNERLOOP_ARGLIST
)
{
#ifdef FORCE_NULL
    return;
#endif

    // any work?
    if (dwCount == 0) return;

    DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)dwCount);
    // book keeping
    if (pContext->pZetaBuffer) {
        pContext->pZetaBuffer->getWrapper()->setCTDrawPrim();
    }

    // lock surfaces for use by the HW
    nvHWLockTextures (pContext);
    nvHWLockStreams (pContext, KELVIN_CAPS_MAX_STREAMS);

    // set the vertex sources and if anything has changed, dirty the fvf flag
    if (pContext->hwState.dwVertexOffset != pContext->dp2.dwVertexBufferOffset)
    {
        pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_FVF;

    }
    // ugh.  Special case to set up the combiners for pointsprites..
    if ((pContext->dwRenderState[D3DRS_POINTSPRITEENABLE]) &&
        (pContext->hwState.dwCombinerDP2Prim != pContext->dp2.dwDP2Prim))
    {
        pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_COMBINERS_COLOR;
    }

    // set kelvin state (required to get the correct inner loop)
    nvSetKelvinState (pContext);

#ifdef FORCE_INLINE_VERTICES

    nvKelvinDispatchNonIndexedPrimitiveInline (pContext, dwCount);

#else // !FORCE_INLINE_VERTICES

    if (pContext->hwState.dwInlineVertexStride) {

        nvKelvinDispatchNonIndexedPrimitiveInline (pContext, dwCount);

    }

    else {

        // vertices are in video memory. allow NV20 to fetch them from there

        nvAssert (kelvinBeginEndOp[pContext->dp2.dwDP2Prim] != ~0);
        nvglSetNv20KelvinBeginEnd (NV_DD_KELVIN, kelvinBeginEndOp[pContext->dp2.dwDP2Prim]);

        DWORD dwScaleAndBias = kelvinPrimitiveToPrimitiveMagic[pContext->dp2.dwDP2Prim];
        nvAssert (dwScaleAndBias != ~0);
        DWORD dwNumVertices = (((dwScaleAndBias >> 8) & 0xff) * dwCount) + (dwScaleAndBias & 0xff);

        DWORD dwIndex = 0;
        while (dwNumVertices > KELVIN_MAX_INLINE_VERTICES) {
            nvglSetNv20KelvinDrawArrays (NV_DD_KELVIN,
                                         DRF_NUM(097, _DRAW_ARRAYS, _COUNT, KELVIN_MAX_INLINE_VERTICES-1) |
                                         DRF_NUM(097, _DRAW_ARRAYS, _START_INDEX, dwIndex + pContext->dp2.dwVStart));
            dwNumVertices -= KELVIN_MAX_INLINE_VERTICES;
            dwIndex += KELVIN_MAX_INLINE_VERTICES;
        }
        if (dwNumVertices) {
            nvglSetNv20KelvinDrawArrays (NV_DD_KELVIN,
                                         DRF_NUM(097, _DRAW_ARRAYS, _COUNT, dwNumVertices-1) |
                                         DRF_NUM(097, _DRAW_ARRAYS, _START_INDEX, dwIndex + pContext->dp2.dwVStart));
        }

        nvglSetNv20KelvinBeginEnd (NV_DD_KELVIN, NV097_SET_BEGIN_END_OP_END);

    }

#endif // !FORCE_INLINE_VERTICES

    //set that we need to unlock all surfaces.  defer till we need to to lower number of CPU
    //clocks per primitive.
    pContext->dwHWUnlockAllPending = TRUE;
}

//---------------------------------------------------------------------------

void nvKelvinDispatchLegacyWireframePrimitive
(
    NV_INNERLOOP_ARGLIST
)
{
    nvAssert (pContext->dwRenderState[D3DRENDERSTATE_FILLMODE] == D3DFILL_WIREFRAME);

    DWORD dwCachedDP2Op     = pContext->dp2.dwDP2Prim;
    pContext->dp2.dwDP2Prim = D3DDP2OP_INDEXEDLINELIST;

    if (dwCachedDP2Op == D3DDP2OP_INDEXEDTRIANGLELIST) {

        LPD3DHAL_DP2INDEXEDTRIANGLELIST pTriListData;
        DWORD dwEdge;
        WORD  wIndicesIn[3];
        WORD  wIndicesOut[2];

        pTriListData = (LPD3DHAL_DP2INDEXEDTRIANGLELIST)(pContext->dp2.dwIndices);
        pContext->dp2.dwIndices     = (DWORD)(&(wIndicesOut[0]));
        pContext->dp2.dwIndexStride = 2;

        while (dwCount) {

            wIndicesIn[0] = pTriListData->wV1;
            wIndicesIn[1] = pTriListData->wV2;
            wIndicesIn[2] = pTriListData->wV3;

            for (dwEdge=0; dwEdge<3; dwEdge++) {
                if (pTriListData->wFlags & (D3DTRIFLAG_EDGEENABLE1 << dwEdge)) {
                    wIndicesOut[0] = wIndicesIn [(dwEdge+0) % 3];
                    wIndicesOut[1] = wIndicesIn [(dwEdge+1) % 3];
                    nvKelvinDispatchIndexedPrimitive (pContext, 1);
                }
            }

            pTriListData ++;
            dwCount --;

        }

    }

    else if ((dwCachedDP2Op == D3DDP2OP_TRIANGLEFAN_IMM) || (dwCachedDP2Op == D3DDP2OP_TRIANGLEFAN)) {

        DWORD dwEdgeFlags, dwEdgeMask;
        WORD  wTriNum;
        WORD  wIndicesOut[2];

        nvAssert (dwCount < 32);

        dwEdgeFlags = pContext->dp2.dwEdgeFlags;
        dwEdgeMask  = 0x1;

        pContext->dp2.dwIndices     = (DWORD)(&(wIndicesOut[0]));
        pContext->dp2.dwIndexStride = 2;

        // we never draw edge v0-v1 for anything but the first triangle
        wIndicesOut[0] = 1;
        wIndicesOut[1] = 0;
        if (dwEdgeFlags & dwEdgeMask) {
            nvKelvinDispatchIndexedPrimitive (pContext, 1);
            dbgFlushType (NVDBG_FLUSH_PRIMITIVE);
        }
        dwEdgeMask <<= 1;

        // we may draw edge v1-v2 for any or all triangles
        for (wTriNum=0; wTriNum<dwCount; wTriNum++) {
            wIndicesOut[0] = wTriNum+1;
            wIndicesOut[1] = wTriNum+2;
            if (dwEdgeFlags & dwEdgeMask) {
                nvKelvinDispatchIndexedPrimitive (pContext, 1);
                dbgFlushType (NVDBG_FLUSH_PRIMITIVE);
            }
            dwEdgeMask <<= 1;
        }

        // we never draw edge v2-v0 for anything but the last triangle
        wIndicesOut[0] = dwCount+1;
        wIndicesOut[1] = 0;
        if (dwEdgeFlags & dwEdgeMask) {
            nvKelvinDispatchIndexedPrimitive (pContext, 1);
            dbgFlushType (NVDBG_FLUSH_PRIMITIVE);
        }
        dwEdgeMask <<= 1;

    }

    else {

        // we don't handle any other legacy primitives
        nvAssert (0);

    }

    pContext->dp2.dwDP2Prim = dwCachedDP2Op;
}

/*****************************************************************************
 *****************************************************************************
 *** Inline Vertex Code ******************************************************
 *****************************************************************************
 *****************************************************************************/

// this code is typically unused. it's used only for debugging
// purposes if FORCE_INLINE_VERTICES is defined

// table mapping dp2ops to the scale and bias required to calculate the number
// of vertices from the number of primitives. the scale is in the upper half
// of the word and the bias is in the lower.
// numVertices = scale * numPrimitives + bias

DWORD kelvinPrimitiveToVertexCountScaleAndBias[D3D_DP2OP_MAX+1] =
{
    ~0,                                          //   0  invalid
    0x00010000,                                  //   1  D3DDP2OP_POINTS
    0x00020000,                                  //   2  D3DDP2OP_INDEXEDLINELIST
    0x00030000,                                  //   3  D3DDP2OP_INDEXEDTRIANGLELIST
    ~0,                                          //   4  invalid
    ~0,                                          //   5  invalid
    ~0,                                          //   6  invalid
    ~0,                                          //   7  invalid
    ~0,                                          //   8  D3DDP2OP_RENDERSTATE
    ~0,                                          //   9  invalid
    ~0,                                          //  10  invalid
    ~0,                                          //  11  invalid
    ~0,                                          //  12  invalid
    ~0,                                          //  13  invalid
    ~0,                                          //  14  invalid
    0x00020000,                                  //  15  D3DDP2OP_LINELIST
    0x00010001,                                  //  16  D3DDP2OP_LINESTRIP
    0x00010001,                                  //  17  D3DDP2OP_INDEXEDLINESTRIP
    0x00030000,                                  //  18  D3DDP2OP_TRIANGLELIST
    0x00010002,                                  //  19  D3DDP2OP_TRIANGLESTRIP
    0x00010002,                                  //  20  D3DDP2OP_INDEXEDTRIANGLESTRIP
    0x00010002,                                  //  21  D3DDP2OP_TRIANGLEFAN
    0x00010002,                                  //  22  D3DDP2OP_INDEXEDTRIANGLEFAN
    0x00010002,                                  //  23  D3DDP2OP_TRIANGLEFAN_IMM
    0x00020000,                                  //  24  D3DDP2OP_LINELIST_IMM
    ~0,                                          //  25  D3DDP2OP_TEXTURESTAGESTATE
    0x00030000,                                  //  26  D3DDP2OP_INDEXEDTRIANGLELIST2
    0x00020000,                                  //  27  D3DDP2OP_INDEXEDLINELIST2
    ~0,                                          //  28  D3DDP2OP_VIEWPORTINFO
    ~0,                                          //  29  D3DDP2OP_WINFO
    ~0,                                          //  30  D3DDP2OP_SETPALETTE
    ~0,                                          //  31  D3DDP2OP_UPDATEPALETTE
    ~0,                                          //  32  D3DDP2OP_ZRANGE
    ~0,                                          //  33  D3DDP2OP_SETMATERIAL
    ~0,                                          //  34  D3DDP2OP_SETLIGHT
    ~0,                                          //  35  D3DDP2OP_CREATELIGHT
    ~0,                                          //  36  D3DDP2OP_SETTRANSFORM
    ~0,                                          //  37  D3DDP2OP_EXT
    ~0,                                          //  38  D3DDP2OP_TEXBLT
    ~0,                                          //  39  D3DDP2OP_STATESET
    ~0,                                          //  40  D3DDP2OP_SETPRIORITY
    ~0,                                          //  41  D3DDP2OP_SETRENDERTARGET
    ~0,                                          //  42  D3DDP2OP_CLEAR
    ~0,                                          //  43  D3DDP2OP_SETTEXLOD
    ~0                                           //  44  D3DDP2OP_SETCLIPPLANE
};

//---------------------------------------------------------------------------

// dump one vertex attribute into the push buffer (conditional on its existence)

__inline void nvKelvinDumpInlineVA
(
    DWORD           dwReg,
    CVertexShader  *pShader,
    CVertexBuffer **ppStreams,
    DWORD           dwVertexBufferOffset,
    DWORD           dwIndex,
    DWORD          *dwPutIndex
#ifdef STOMP_TEX_COORDS
    BOOL           ,bStompLast
#endif  // STOMP_TEX_COORDS
)
{
    DWORD dwStreamSelector, pComponent, dwCount, i;

    dwStreamSelector = pShader->getVAStream(dwReg);
    if (dwStreamSelector != CVertexShader::VA_STREAM_NONE) {
        nvAssert (ppStreams[dwStreamSelector]);
        pComponent = ppStreams[dwStreamSelector]->getAddress()                // address of buffer
                   + dwVertexBufferOffset                                     // global offset within buffer
                   + pShader->getVAOffset (dwReg)                             // offset of this component
                   + dwIndex*ppStreams[dwStreamSelector]->getVertexStride();  // offset of this particular vertex
        dwCount = pShader->getVASize (dwReg) / sizeof(DWORD);
        for (i=0; i<dwCount; i++) {
            nvglSetData (*dwPutIndex, ((DWORD*)pComponent)[i]);
            (*dwPutIndex) ++;
        }
#ifdef STOMP_TEX_COORDS
        if (bStompLast) {
            nvglSetData ((*dwPutIndex)-1, FP_ONE_BITS);
        }
#endif  // STOMP_TEX_COORDS
    }
}

//---------------------------------------------------------------------------

void nvKelvinDumpDebugVertex
(
    PNVD3DCONTEXT pContext,
    DWORD         dwIndex
)
{
    CVertexShader  *pShader;
    CVertexBuffer **ppStreams;
    DWORD           dwVertexBufferOffset;
    DWORD           dwPBIndex, dwReg;
    DWORD           dwHWStage, dwD3DStage, dwTCIndex, dwVAIndex;

    pShader              = pContext->hwState.pVertexShader;
    ppStreams            = pContext->hwState.ppStreams;
    dwVertexBufferOffset = pContext->hwState.dwVertexOffset;
    dwIndex             += pContext->dp2.dwVStart; //add in the base vertex
    dwPBIndex=0;

    DWORD  *pComponent;
    DWORD   dwSs;
    DWORD   flag = NVDBG_SHOW_VERTICES;

    dbgDPFAndDump(flag, "\nkelvin vertex, index = %d", dwIndex);

    // x,y,z,w
    dwReg=defaultInputRegMap[D3DVSDE_POSITION];
    dwSs=pShader->getVAStream(dwReg);
    if (dwSs!=CVertexShader::VA_STREAM_NONE)
    {
        pComponent = (DWORD*)(ppStreams[dwSs]->getAddress()
            + dwVertexBufferOffset
            + pShader->getVAOffset (dwReg)
            + dwIndex*ppStreams[dwSs]->getVertexStride());

        dbgDPFAndDump(flag, "             X = %f",    FLOAT_FROM_DWORD(pComponent[0]));
        dbgDPFAndDump(flag, "             Y = %f",    FLOAT_FROM_DWORD(pComponent[1]));
        dbgDPFAndDump(flag, "             Z = %f",    FLOAT_FROM_DWORD(pComponent[2]));
        dbgDPFAndDump(flag, "             W = %f",    FLOAT_FROM_DWORD(pComponent[3]));
    }

    // blendweight
    dwReg=defaultInputRegMap[D3DVSDE_BLENDWEIGHT];
    dwSs=pShader->getVAStream(dwReg);
    if (dwSs!=CVertexShader::VA_STREAM_NONE)
    {
        pComponent = (DWORD*)(ppStreams[dwSs]->getAddress()
            + dwVertexBufferOffset
            + pShader->getVAOffset (dwReg)
            + dwIndex*ppStreams[dwSs]->getVertexStride());

        dbgDPFAndDump(flag, " blendWeight = %f",    FLOAT_FROM_DWORD(pComponent[0]));
    }

    // normal
    dwReg=defaultInputRegMap[D3DVSDE_NORMAL];
    dwSs=pShader->getVAStream(dwReg);
    if (dwSs!=CVertexShader::VA_STREAM_NONE)
    {
        pComponent = (DWORD*)(ppStreams[dwSs]->getAddress()
            + dwVertexBufferOffset
            + pShader->getVAOffset (dwReg)
            + dwIndex*ppStreams[dwSs]->getVertexStride());

        dbgDPFAndDump(flag, "    nX       = %f",    FLOAT_FROM_DWORD(pComponent[0]));
        dbgDPFAndDump(flag, "    nY       = %f",    FLOAT_FROM_DWORD(pComponent[1]));
        dbgDPFAndDump(flag, "    nZ       = %f",    FLOAT_FROM_DWORD(pComponent[2]));
    }

    // diffuse
    dwReg=defaultInputRegMap[D3DVSDE_DIFFUSE];
    dwSs=pShader->getVAStream(dwReg);
    if (dwSs!=CVertexShader::VA_STREAM_NONE)
    {
        pComponent = (DWORD*)(ppStreams[dwSs]->getAddress()
            + dwVertexBufferOffset
            + pShader->getVAOffset (dwReg)
            + dwIndex*ppStreams[dwSs]->getVertexStride());

        dbgDPFAndDump(flag, "     diffuse = %x",    pComponent[0]);
    }

    // specular
    dwReg=defaultInputRegMap[D3DVSDE_SPECULAR];
    dwSs=pShader->getVAStream(dwReg);
    if (dwSs!=CVertexShader::VA_STREAM_NONE)
    {
        pComponent = (DWORD*)(ppStreams[dwSs]->getAddress()
            + dwVertexBufferOffset
            + pShader->getVAOffset (dwReg)
            + dwIndex*ppStreams[dwSs]->getVertexStride());

        dbgDPFAndDump(flag, "    specular = %x",    pComponent[0]);
    }

    for (dwHWStage=0; dwHWStage < KELVIN_NUM_TEXTURES; dwHWStage++)
    {
        if (pContext->hwState.dwStateFlags & KELVIN_FLAG_USERTEXCOORDSNEEDED(dwHWStage))
        {
            dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[dwHWStage];
            nvAssert (dwD3DStage != KELVIN_UNUSED);
            dwTCIndex  = (pContext->hwState.dwTexCoordIndices >> (8*dwHWStage)) & 0xff;  // BUGBUG?? are these indices even relevant in DX8?
            dwVAIndex  = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
            nvAssert (pShader->bVAExists(dwVAIndex));  // they better have given us coordinates


            dwReg=dwVAIndex;
            dwSs=pShader->getVAStream(dwReg);
            if (dwSs!=CVertexShader::VA_STREAM_NONE)
            {
                pComponent = (DWORD*)(ppStreams[dwSs]->getAddress()
                    + dwVertexBufferOffset
                    + pShader->getVAOffset (dwReg)
                    + dwIndex*ppStreams[dwSs]->getVertexStride());

                switch (pShader->getVASize(dwReg)>>2) {
                case 1: dbgDPFAndDump(flag, "    Texture %d = <%f>", dwHWStage, FLOAT_FROM_DWORD(pComponent[0])); break;
                case 2: dbgDPFAndDump(flag, "    Texture %d = <%f, %f>", dwHWStage, FLOAT_FROM_DWORD(pComponent[0]), FLOAT_FROM_DWORD(pComponent[1])); break;
                case 3: dbgDPFAndDump(flag, "    Texture %d = <%f, %f, %f>", dwHWStage, FLOAT_FROM_DWORD(pComponent[0]), FLOAT_FROM_DWORD(pComponent[1]), FLOAT_FROM_DWORD(pComponent[2])); break;
                case 4: dbgDPFAndDump(flag, "    Texture %d = <%f, %f, %f, %f>", dwHWStage, FLOAT_FROM_DWORD(pComponent[0]), FLOAT_FROM_DWORD(pComponent[1]), FLOAT_FROM_DWORD(pComponent[2]), FLOAT_FROM_DWORD(pComponent[3])); break;
                default: dbgDPFAndDump(flag, "    Invalid number of texture coordinates"); dbgD3DError();
                }
            }
        }
    }
}

//---------------------------------------------------------------------------

// dumps one vertex into the push buffer with the components in the order
// kelvin requires. note that adequate push buffer space is assumed to have
// been verified already!

void nvKelvinDumpInlineVertex
(
    PNVD3DCONTEXT pContext,
    DWORD         dwIndex
)
{
    CVertexShader  *pShader;
    CVertexBuffer **ppStreams;
    DWORD           dwVertexBufferOffset;
    DWORD           dwPBIndex, dwReg;
    DWORD           dwHWStage, dwD3DStage, dwTCIndex, dwVAIndex;

    pShader              = pContext->hwState.pVertexShader;
    ppStreams            = pContext->hwState.ppStreams;
    dwVertexBufferOffset = pContext->hwState.dwVertexOffset;
    dwIndex             += pContext->dp2.dwVStart; //add in the base vertex
    dwPBIndex=0;

    if (pShader->hasProgram()) {

        // dump all enabled vertex attributes
        for (dwReg=0; dwReg < NV_CAPS_MAX_STREAMS; dwReg++) {
#ifdef STOMP_TEX_COORDS
            nvKelvinDumpInlineVA (dwReg, pShader, ppStreams, dwVertexBufferOffset, dwIndex, &dwPBIndex, FALSE);
#else  // !STOMP_TEX_COORDS
            nvKelvinDumpInlineVA (dwReg, pShader, ppStreams, dwVertexBufferOffset, dwIndex, &dwPBIndex);
#endif  // !STOMP_TEX_COORDS
        }
        if (pContext->hwState.dwInlineVertexStride == 4) //workaround for kelvin bug
        {
            //add some extra
            nvglSetData (dwPBIndex, 0);
            dwPBIndex++;
        }
    }
    else {

        if ((dbgShowState & NVDBG_SHOW_VERTICES) || (dbgDumpState & NVDBG_SHOW_VERTICES)) {
            nvKelvinDumpDebugVertex (pContext, dwIndex);
        }

#ifdef STOMP_TEX_COORDS
        // dump pre-ordained components
        nvKelvinDumpInlineVA (defaultInputRegMap[D3DVSDE_POSITION],    pShader, ppStreams, dwVertexBufferOffset, dwIndex, &dwPBIndex, FALSE);
        nvKelvinDumpInlineVA (defaultInputRegMap[D3DVSDE_BLENDWEIGHT], pShader, ppStreams, dwVertexBufferOffset, dwIndex, &dwPBIndex, FALSE);
        nvKelvinDumpInlineVA (defaultInputRegMap[D3DVSDE_NORMAL],      pShader, ppStreams, dwVertexBufferOffset, dwIndex, &dwPBIndex, FALSE);
        nvKelvinDumpInlineVA (defaultInputRegMap[D3DVSDE_DIFFUSE],     pShader, ppStreams, dwVertexBufferOffset, dwIndex, &dwPBIndex, FALSE);
        nvKelvinDumpInlineVA (defaultInputRegMap[D3DVSDE_SPECULAR],    pShader, ppStreams, dwVertexBufferOffset, dwIndex, &dwPBIndex, FALSE);
        nvKelvinDumpInlineVA (defaultInputRegMap[D3DVSDE_PSIZE],       pShader, ppStreams, dwVertexBufferOffset, dwIndex, &dwPBIndex, FALSE);
        for (dwHWStage=0; dwHWStage < KELVIN_NUM_TEXTURES; dwHWStage++) {
            if (pContext->hwState.dwStateFlags & KELVIN_FLAG_USERTEXCOORDSNEEDED(dwHWStage)) {
                dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[dwHWStage];
                nvAssert (dwD3DStage != KELVIN_UNUSED);
                dwTCIndex  = (pContext->hwState.dwTexCoordIndices >> (8*dwHWStage)) & 0xff;  // BUGBUG?? are these indices even relevant in DX8?
                dwVAIndex  = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
                nvAssert (pShader->bVAExists(dwVAIndex));  // they better have given us coordinates
                BOOL bStompLast = (pContext->hwState.dwStateFlags & KELVIN_FLAG_STOMP_4TH_COORD(dwHWStage));
                nvKelvinDumpInlineVA (dwVAIndex, pShader, ppStreams, dwVertexBufferOffset, dwIndex, &dwPBIndex, bStompLast);
            }
        }
#else  // !STOMP_TEX_COORDS
        // dump pre-ordained components
        nvKelvinDumpInlineVA (defaultInputRegMap[D3DVSDE_POSITION],    pShader, ppStreams, dwVertexBufferOffset, dwIndex, &dwPBIndex);
        nvKelvinDumpInlineVA (defaultInputRegMap[D3DVSDE_BLENDWEIGHT], pShader, ppStreams, dwVertexBufferOffset, dwIndex, &dwPBIndex);
        nvKelvinDumpInlineVA (defaultInputRegMap[D3DVSDE_NORMAL],      pShader, ppStreams, dwVertexBufferOffset, dwIndex, &dwPBIndex);
        nvKelvinDumpInlineVA (defaultInputRegMap[D3DVSDE_DIFFUSE],     pShader, ppStreams, dwVertexBufferOffset, dwIndex, &dwPBIndex);
        nvKelvinDumpInlineVA (defaultInputRegMap[D3DVSDE_SPECULAR],    pShader, ppStreams, dwVertexBufferOffset, dwIndex, &dwPBIndex);
        nvKelvinDumpInlineVA (defaultInputRegMap[D3DVSDE_PSIZE],       pShader, ppStreams, dwVertexBufferOffset, dwIndex, &dwPBIndex);
        for (dwHWStage=0; dwHWStage < KELVIN_NUM_TEXTURES; dwHWStage++) {
            if (pContext->hwState.dwStateFlags & KELVIN_FLAG_USERTEXCOORDSNEEDED(dwHWStage)) {
                dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[dwHWStage];
                nvAssert (dwD3DStage != KELVIN_UNUSED);
                dwTCIndex  = (pContext->hwState.dwTexCoordIndices >> (8*dwHWStage)) & 0xff;  // BUGBUG?? are these indices even relevant in DX8?
                dwVAIndex  = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
                nvAssert (pShader->bVAExists(dwVAIndex));  // they better have given us coordinates
                nvKelvinDumpInlineVA (dwVAIndex, pShader, ppStreams, dwVertexBufferOffset, dwIndex, &dwPBIndex);
            }
        }
#endif  // !STOMP_TEX_COORDS

    }

    nvAssert ((dwPBIndex == (pContext->hwState.dwInlineVertexStride >> 2)) || pContext->hwState.dwInlineVertexStride == 4 );
}

//---------------------------------------------------------------------------

// dumps a block of 'dwCount' non-indexed vertices starting with index 'i0'

void nvKelvinDumpNonIndexedInlineVertexBlock
(
    PNVD3DCONTEXT pContext,
    DWORD         i0,
    DWORD         dwCount,
    DWORD         dwInlineVertexStride
)
{
    DWORD dwMethodCount;

    dwMethodCount = dwCount * dwInlineVertexStride;  // number of 4-byte words
    nvAssert (dwMethodCount < (1<<11));

    getDC()->nvPusher.makeSpace (sizeSetStartMethod + dwMethodCount);
    nvglSetStartMethod (0, NV_DD_KELVIN, NVPUSHER_NOINC(NV097_INLINE_ARRAY), dwMethodCount);
    getDC()->nvPusher.inc (sizeSetStartMethod);

    for (DWORD i=i0; i<i0+dwCount; i++) {
        nvKelvinDumpInlineVertex (pContext, i);
        getDC()->nvPusher.inc (dwInlineVertexStride);
    }
}

#ifndef VERTEX_REUSE

//---------------------------------------------------------------------------

// dumps a block of 'dwCount' indexed vertices beginning with index 'i0'

void nvKelvinDumpIndexedInlineVertexBlock
(
    PNVD3DCONTEXT pContext,
    DWORD         i0,
    DWORD         dwCount,
    BOOL          bLegacyStrides,
    DWORD         dwInlineVertexStride
)
{
    DWORD dwMethodCount;
    DWORD i, i1;
    PWORD lpIndices  = (PWORD)(pContext->dp2.dwIndices);

    dwMethodCount = dwCount * dwInlineVertexStride;  // number of 4-byte words
    nvAssert (dwMethodCount < 2048);

    getDC()->nvPusher.makeSpace (sizeSetStartMethod + dwMethodCount);
    nvglSetStartMethod (0, NV_DD_KELVIN, NVPUSHER_NOINC(NV097_INLINE_ARRAY), dwMethodCount);
    getDC()->nvPusher.inc (sizeSetStartMethod);

    if (bLegacyStrides) {

        // stupid old style indexing - {index16:index16 index16:junk16} repeat
        for (i=i0; i < (i0+dwCount); i++) {
            i1 = 4 * i / 3;  // offset of the i'th index
            nvKelvinDumpInlineVertex (pContext, lpIndices[i1]);
            getDC()->nvPusher.inc (dwInlineVertexStride);
        }

    }

    else {

        // new indexing - fully packed
        for (i=i0; i < (i0+dwCount); i++) {
            nvKelvinDumpInlineVertex (pContext, lpIndices[i]);
            getDC()->nvPusher.inc (dwInlineVertexStride);
        }

    }
}

#else  // VERTEX_REUSE


#if 0 // old way

//---------------------------------------------------------------------------

// dumps a block of 'dwCount' indexed vertices beginning with index 'i0'

void nvKelvinDumpIndexedInlineVertexBlock
(
    PNVD3DCONTEXT pContext,
    LPWORD        lpIndices,
    DWORD         i0,
    DWORD         dwCount,
    BOOL          bLegacyStrides,
    DWORD         dwInlineVertexStride
)
{
    DWORD dwMethodCount;
    DWORD i, i1;
    DWORD adwBitField[16];
    DWORD dwIndexMask;
    DWORD dwBitIndex, dwBit;
#ifdef DEBUG
    DWORD dwNewCount = 0;
    DWORD dwReuseCount = 0;
#endif

    if (bLegacyStrides) {

        // stupid old style indexing - {index16:index16 index16:junk16} repeat

        dwMethodCount = dwCount * dwInlineVertexStride;  // number of 4-byte words
        nvAssert (dwMethodCount <= 2048);

        getDC()->nvPusher.makeSpace (sizeSetStartMethod + dwMethodCount);
        nvglSetStartMethod (0, NV_DD_KELVIN, NVPUSHER_NOINC(NV097_INLINE_ARRAY), dwMethodCount);
        getDC()->nvPusher.inc (sizeSetStartMethod);

        for (i=i0; i < (i0+dwCount); i++) {
            i1 = 4 * i / 3;  // offset of the i'th index
            nvKelvinDumpInlineVertex (pContext, lpIndices[i1]);
            getDC()->nvPusher.inc (dwInlineVertexStride);
        }

    }

    else {

        // new indexing - fully packed

        // conservatively make space as if we're not going to reuse any
        getDC()->nvPusher.makeSpace (dwCount * (sizeSetStartMethod + dwInlineVertexStride));

        // clear the cached values
        memset ((void*)adwBitField, 0, 16*sizeof(DWORD));

        for (i=i0; i < (i0+dwCount); i++) {

            i1 = lpIndices[i];

            // see if we've used this index before
            dwIndexMask = ~0;
            for (dwBitIndex=0; dwBitIndex<16; dwBitIndex++) {
                dwBit = (i1 >> dwBitIndex) & 0x1;
                dwIndexMask &= ((adwBitField[dwBitIndex] >> (dwBit<<4)) & 0xffff);
            }

            if (dwIndexMask) {

                // we've seen this index before. re-use the vertex
#ifdef DEBUG
                dwReuseCount++;

                // only one bit should be set
                DWORD aa = dwIndexMask;
                DWORD bb = dwIndexMask;
                ASM_LOG2(aa);
                ASM_LOG2_R(bb);
                nvAssert (aa==bb);
#endif
                ASM_LOG2(dwIndexMask);
                nvglSetStartMethod (0, NV_DD_KELVIN, NV097_INLINE_VERTEX_REUSE, 1);
                nvglSetData (1, dwIndexMask);
                getDC()->nvPusher.inc (2);

            }

            else {

                // this is a new index. emit the vertex and update cached indices
#ifdef DEBUG
                dwNewCount++;
#endif
                nvglSetStartMethod (0, NV_DD_KELVIN, NVPUSHER_NOINC(NV097_INLINE_ARRAY), dwInlineVertexStride);
                getDC()->nvPusher.inc (sizeSetStartMethod);
                nvKelvinDumpInlineVertex (pContext, i1);
                getDC()->nvPusher.inc (dwInlineVertexStride);
                for (dwBitIndex=0; dwBitIndex<16; dwBitIndex++) {
                    dwBit = (i1 >> dwBitIndex) & 0x1;
                    adwBitField[dwBitIndex] <<= 1;
                    adwBitField[dwBitIndex]  &= 0xfffefffe;
                    adwBitField[dwBitIndex]  |= ((dwBit << 16) | (dwBit ^ 0x1));
                }

            }

        }

    }

#ifdef DEBUG
    DPF_LEVEL (NVDBG_LEVEL_VERTEX_REUSE, "Vertex Reuse Statistics:");
    DPF_LEVEL (NVDBG_LEVEL_VERTEX_REUSE, "      new : %d (%.2f)", dwNewCount, (float)dwNewCount/(dwNewCount+dwReuseCount));
    DPF_LEVEL (NVDBG_LEVEL_VERTEX_REUSE, "   reused : %d (%.2f)", dwReuseCount, (float)dwReuseCount/(dwNewCount+dwReuseCount));
    DPF_LEVEL (NVDBG_LEVEL_VERTEX_REUSE, "    total : %d (%.2f)", dwNewCount+dwReuseCount, 100.f);
#endif

}


#else // new way

//---------------------------------------------------------------------------

// dumps a block of 'dwCount' indexed vertices beginning with index 'i0'

#define INDEX_HISTORY_SIZE 16
#define INDEX_HISTORY_MASK (INDEX_HISTORY_SIZE-1)
void nvKelvinDumpIndexedInlineVertexBlock
(
    PNVD3DCONTEXT pContext,
    DWORD         i0,
    DWORD         dwCount,
    BOOL          bLegacyStrides,
    DWORD         dwInlineVertexStride
)
{
    DWORD dwMethodCount;
    DWORD i, i1;
    DWORD dwReuseIndex, dwVertexIndex;
    DWORD adwIndexHistory[INDEX_HISTORY_SIZE];
    DWORD dwCurrentHistoryIndex, dwHistoryIndex;

    PBYTE pIndices  = (PBYTE)(pContext->dp2.dwIndices);
    DWORD dwIStride = pContext->dp2.dwIndexStride;

    if (bLegacyStrides) {

        // stupid old style indexing - {index16:index16 index16:junk16} repeat

        dwMethodCount = dwCount * dwInlineVertexStride;  // number of 4-byte words
        nvAssert (dwMethodCount <= 2048);
        nvAssert (dwIStride == 2);  // legacy shouldn't be using 32-bit indices

        getDC()->nvPusher.makeSpace (sizeSetStartMethod + dwMethodCount);
        nvglSetStartMethod (0, NV_DD_KELVIN, NVPUSHER_NOINC(NV097_INLINE_ARRAY), dwMethodCount);
        getDC()->nvPusher.inc (sizeSetStartMethod);

        for (i=i0; i < (i0+dwCount); i++) {
            i1 = 4 * i / 3;  // offset of the i'th index
            nvKelvinDumpInlineVertex (pContext, ((WORD*)pIndices)[i1]);
            getDC()->nvPusher.inc (dwInlineVertexStride);
        }

    }

    else {

        // new indexing - fully packed

        // conservatively make space as if we're not going to reuse any
        getDC()->nvPusher.makeSpace (dwCount * (sizeSetStartMethod + dwInlineVertexStride));

        // clear the history
        dwCurrentHistoryIndex = 0;
        memset ((void*)adwIndexHistory, 0xff, INDEX_HISTORY_SIZE*sizeof(DWORD));

        for (i=i0; i < (i0+dwCount); i++) {

            dwVertexIndex = (dwIStride == 2) ? ((WORD*)pIndices)[i] : ((DWORD*)pIndices)[i];

            // see if we've used this index before
            dwHistoryIndex = dwCurrentHistoryIndex;
            for (dwReuseIndex=0; dwReuseIndex<INDEX_HISTORY_SIZE; dwReuseIndex++) {
                if (adwIndexHistory[dwHistoryIndex] == dwVertexIndex) {
                    // re-use index dwReuseIndex
                    nvglSetStartMethod (0, NV_DD_KELVIN, NV097_INLINE_VERTEX_REUSE, 1);
                    nvglSetData (1, dwReuseIndex);
                    getDC()->nvPusher.inc (2);
                    goto next_i;
                }
                dwHistoryIndex--;
                dwHistoryIndex &= INDEX_HISTORY_MASK;
            }

            // this is a new index. emit the vertex and update cached indices
            nvglSetStartMethod (0, NV_DD_KELVIN, NVPUSHER_NOINC(NV097_INLINE_ARRAY), dwInlineVertexStride);
            getDC()->nvPusher.inc (sizeSetStartMethod);
            nvKelvinDumpInlineVertex (pContext, dwVertexIndex);
            getDC()->nvPusher.inc (dwInlineVertexStride);

            dwCurrentHistoryIndex++;
            dwCurrentHistoryIndex &= INDEX_HISTORY_MASK;
            adwIndexHistory[dwCurrentHistoryIndex] = dwVertexIndex;

            next_i:
            ;  // null statement to make label happy

        }

    }
}

#endif  // new way

#endif  // VERTEX_REUSE

//---------------------------------------------------------------------------

void nvKelvinDispatchNonIndexedPrimitiveInline
(
    PNVD3DCONTEXT       pContext,
    DWORD               dwCount
)
{
    DWORD numVertices, emittedVertices, dwScaleAndBias, dwInlineVertexStride, dwKelvinMaxInlineVertices;

    dwInlineVertexStride      = pContext->hwState.dwInlineVertexStride >> 2;
    if (dwInlineVertexStride == 1) dwInlineVertexStride = 2; //workaround for kelvin bug
    dwKelvinMaxInlineVertices = NVPUSHER_MAX_METHOD_COUNT / dwInlineVertexStride;

    nvAssert (kelvinBeginEndOp[pContext->dp2.dwDP2Prim] != ~0);

    nvglSetStartMethod (0, NV_DD_KELVIN, NV097_SET_BEGIN_END, 1);
    nvglSetData (1, kelvinBeginEndOp[pContext->dp2.dwDP2Prim]);
    nvglAdjust (2);

    dwScaleAndBias = kelvinPrimitiveToVertexCountScaleAndBias[pContext->dp2.dwDP2Prim];
    nvAssert (dwScaleAndBias != ~0);
    numVertices = (dwScaleAndBias >> 16) * dwCount + (dwScaleAndBias & 0xffff);

    emittedVertices = 0;

    while (numVertices > dwKelvinMaxInlineVertices) {
        // attempt to kick off some work already
        nvPusherStart (FALSE);
        // send more vertices
        nvKelvinDumpNonIndexedInlineVertexBlock (pContext, emittedVertices, dwKelvinMaxInlineVertices, dwInlineVertexStride);
        emittedVertices += dwKelvinMaxInlineVertices;
        numVertices -= dwKelvinMaxInlineVertices;
    }

    nvKelvinDumpNonIndexedInlineVertexBlock (pContext, emittedVertices, numVertices, dwInlineVertexStride);

    nvglSetStartMethod (0, NV_DD_KELVIN, NV097_SET_BEGIN_END, 1);
    nvglSetData (1, NV097_SET_BEGIN_END_OP_END);
    nvglAdjust (2);

    nvPusherStart (FALSE);
}

//---------------------------------------------------------------------------

void nvKelvinDispatchIndexedPrimitiveInline
(
    PNVD3DCONTEXT       pContext,
    DWORD               dwCount,
    BOOL                bLegacyStrides
)
{
    DWORD numVertices, emittedVertices, dwScaleAndBias, dwInlineVertexStride, dwKelvinMaxInlineVertices;

    dwInlineVertexStride      = pContext->hwState.dwInlineVertexStride >> 2;
    if (dwInlineVertexStride == 1) dwInlineVertexStride = 2; // workaround for kelvin bug
    dwKelvinMaxInlineVertices = NVPUSHER_MAX_METHOD_COUNT / dwInlineVertexStride;

    // tell the hardware what kind of thing we're going to draw
    nvAssert (kelvinBeginEndOp[pContext->dp2.dwDP2Prim] != ~0);

    nvglSetStartMethod (0, NV_DD_KELVIN, NV097_SET_BEGIN_END, 1);
    nvglSetData (1, kelvinBeginEndOp[pContext->dp2.dwDP2Prim]);
    nvglAdjust (2);

    // determine the number of vertices
    dwScaleAndBias = kelvinPrimitiveToVertexCountScaleAndBias[pContext->dp2.dwDP2Prim];
    nvAssert (dwScaleAndBias != ~0);
    numVertices = (dwScaleAndBias >> 16) * dwCount + (dwScaleAndBias & 0xffff);

    emittedVertices = 0;

    while (numVertices > dwKelvinMaxInlineVertices) {
        // attempt to kick off some work already
        nvPusherStart (FALSE);
        // send more vertices
        nvKelvinDumpIndexedInlineVertexBlock (pContext, emittedVertices, dwKelvinMaxInlineVertices,
                                              bLegacyStrides, dwInlineVertexStride);
        emittedVertices += dwKelvinMaxInlineVertices;
        numVertices     -= dwKelvinMaxInlineVertices;
    }

    // dump the remainder
    nvKelvinDumpIndexedInlineVertexBlock (pContext, emittedVertices, numVertices,
                                          bLegacyStrides, dwInlineVertexStride);

    nvglSetStartMethod (0, NV_DD_KELVIN, NV097_SET_BEGIN_END, 1);
    nvglSetData (1, NV097_SET_BEGIN_END_OP_END);
    nvglAdjust (2);

    // attempt to kick off some work already
    nvPusherStart (FALSE);
}

#endif  // NVARCH > 0x020
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\kelvin\src\nvKelvinComp.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvKelvinComp.cpp
//      Kelvin inner loop compiler
//
// **************************************************************************
//
//  History:
//      Craig Duttweiler        29Jun2000         ported from celsius
//
// **************************************************************************
#include "nvprecomp.h"

#if (NVARCH >= 0x20)

#include "x86.h"
#include "nvILHash.h"

#ifdef KELVIN_ILC

//////////////////////////////////////////////////////////////////////////////
// notes:
//
// inner loop uniqueness is a function of:
//  - fvfData.dwVertexStride
//  - fvfData.dwVertexType
//  - fvfData.dwUVCount[8]
//  - fvfData.dwUVOffset[8]
//  - pContext->hwState.dwStateFlags & KELVIN_MASK_INNERLOOPUNIQUENESS
//  - pContext->hwState.kelvin.dwTexUnitToTexStageMapping[2]
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// switches
//
//#define PRINT_NAME          // prints ilcFlags for every primitive batch

//////////////////////////////////////////////////////////////////////////////
// aliases
//
#define ilcData         global.dwILCData
#define ilcCount        global.dwILCCount
#define ilcMax          global.dwILCMax

#define KNIMEM(x)           ((((DWORD)&((*(KATMAI_STATE*)global.kni).x[0])) + 15) & ~15)

//////////////////////////////////////////////////////////////////////////////
// external declarations (mostly nvcomp.cpp)
//
void ILCCompile_GetSpace (void);
void ILCCompile_mul      (DWORD reg,DWORD num);

// forward declarations
//
DWORD nvKelvinILCompile_inline_prim      (PNVD3DCONTEXT pContext,DWORD dwFlags);    // nvKelvinInlPrim.cpp
DWORD nvKelvinILCompile_inline_tri_list  (PNVD3DCONTEXT pContext,DWORD dwFlags);    // nvKelvinInlTri.cpp
DWORD nvKelvinILCompile_vb_prim          (PNVD3DCONTEXT pContext,DWORD dwFlags);    // nvKelvinVbPrim.cpp
// DWORD nvKelvinILCompile_str_prim         (PNVD3DCONTEXT pContext,DWORD dwFlags);    // nvKelvinInlStrPrim.cpp
DWORD nvKelvinILCompile_super_tri_list   (PNVD3DCONTEXT pContext,DWORD dwFlags);    // nvKelvinSuperTri.cpp

//---------------------------------------------------------------------------

// nvKelvinGetDispatchRoutine

KELVINDISPATCHPRIMITIVE nvKelvinGetDispatchRoutine
(
    PNVD3DCONTEXT pContext,
    DWORD         dwFlags
)
{
    // check quick cache
    if (global.kelvin.dwLoopCache)
    {
        CILHashEntry *pEntry = (CILHashEntry*)global.kelvin.dwLoopCache;
        if (pEntry->match (pContext,NVCLASS_FAMILY_KELVIN,dwFlags))
        {
            return (KELVINDISPATCHPRIMITIVE)(ilcData + pEntry->getOffset());
        }
    }

    // check hash table
    DWORD dwHashIndex = (DRAW_PRIM_TABLE_ENTRIES - 1) & ((dwFlags + (dwFlags >> 12) + (dwFlags >> 24))
                                                      + pContext->hwState.pVertexShader->getStride()
                                                      + pContext->hwState.pVertexShader->getFVF());

    CILHashEntry *pEntry = (CILHashEntry*)dwDrawPrimitiveTable[dwHashIndex];

    while (pEntry)
    {
        // found it?
        if (pEntry->match (pContext,NVCLASS_FAMILY_KELVIN,dwFlags))
        {
            global.kelvin.dwLoopCache = (DWORD)pEntry;
            return (KELVINDISPATCHPRIMITIVE)(ilcData + pEntry->getOffset());
        }
        // next
        pEntry = pEntry->getNext();
    }

    // build new innerloop
    //  loops require pContext->hwState.dwStateFlags to be set up correctly (CM hack, inline expansion)
    DWORD dwOffset;
    switch (dwFlags & KELVIN_ILMASK_LOOPTYPE)
    {
        case KELVIN_ILFLAG_IX_VB_PRIM:
        case KELVIN_ILFLAG_OR_VB_PRIM:       dwOffset = nvKelvinILCompile_vb_prim(pContext,dwFlags);
                                             break;
        case KELVIN_ILFLAG_IX_STR_PRIM:
        case KELVIN_ILFLAG_OR_STR_PRIM:      //dwOffset = nvKelvinILCompile_str_prim(pContext,dwFlags);
                                             dwOffset = 0;
                                             break;
        case KELVIN_ILFLAG_IX_INL_PRIM:
        case KELVIN_ILFLAG_OR_INL_PRIM:      dwOffset = nvKelvinILCompile_inline_prim(pContext,dwFlags);
                                             break;
        case KELVIN_ILFLAG_IX_INL_TRI_LIST:
        case KELVIN_ILFLAG_OR_INL_TRI_LIST:  dwOffset = nvKelvinILCompile_inline_tri_list(pContext,dwFlags);
                                             break;
        case KELVIN_ILFLAG_SUPER_TRI_LIST:   dwOffset = nvKelvinILCompile_super_tri_list(pContext,dwFlags);
                                             break;
        case KELVIN_ILFLAG_IX_DVB_TRI:       dwOffset = 0;//todo - nvKelvinILCompile_indexed_dvb_tri(pContext,dwFlags);
                                             break;
    }

    // add to hash list
    pEntry = new CILHashEntry (pContext,NVCLASS_FAMILY_KELVIN,dwFlags,dwOffset,(CILHashEntry*)dwDrawPrimitiveTable[dwHashIndex]);
    if (!pEntry) return NULL;
    dwDrawPrimitiveTable[dwHashIndex] = (DWORD)pEntry;

#ifdef PRINT_NAME
    PF ("new kelvin loop (%08x): type %x, dp2 %s (%2x), state = %08x, %s %s", pEntry,
        (dwFlags & 0xF0000000) >> 28,
        kelvinPrimitiveName[dwFlags & 0xFFFF], dwFlags & 0xFFFF,
        pContext->hwState.dwStateFlags & KELVIN_MASK_INNERLOOPUNIQUENESS,
        dwFlags & KELVIN_ILFLAG_LEGACY ? "LEGACY" : "",
        dwFlags & KELVIN_ILFLAG_NOCULL ? "NOCULL" : "");
#endif

    // done
    global.kelvin.dwLoopCache = (DWORD)pEntry;
    return (KELVINDISPATCHPRIMITIVE)(ilcData + pEntry->getOffset());
}


//---------------------------------------------------------------------------

// helpers

void __stdcall nvKelvinDispatchGetPusherSpace (void)
{
    // wrap around -or- make space
    nvPusherAdjust (0);
}

//---------------------------------------------------------------------------

#ifdef DEBUG
void __stdcall nvKelvinDispatchFlush (void)
{
    nvPusherAdjust (0);
    getDC()->nvPusher.flush (TRUE, CPushBuffer::FLUSH_WITH_DELAY);
}

void __stdcall nvKelvinDispatchPrintVertex (PNVD3DCONTEXT pContext,DWORD dwPutAddress)
{
    static DWORD  dwVertexCount = 0;
           DWORD *pdwData       = ((DWORD*)dwPutAddress) + 1;

    if (dbgShowState & NVDBG_SHOW_VERTICES)
    {
        dwVertexCount ++;

        DPF ("Vertex %d",dwVertexCount);

        if (pContext->hwState.pVertexShader->bVAExists(defaultInputRegMap[D3DVSDE_BLENDWEIGHT])) {
            DPF ("         B = %08x",pdwData[0]);
            pdwData += 1;
        }

        if (pContext->hwState.pVertexShader->bVAExists(defaultInputRegMap[D3DVSDE_NORMAL])) {
            DPF ("    Normal = %f, %f, %f", FLOAT_FROM_DWORD(pdwData[0]),FLOAT_FROM_DWORD(pdwData[1]),FLOAT_FROM_DWORD(pdwData[2]));
            DPF ("           = [%08x, %08x, %08x]", pdwData[0],pdwData[1],pdwData[2]);
            pdwData += 3;
        }

        if (pContext->hwState.dwStateFlags & KELVIN_FLAG_USERTEXCOORDSNEEDED(1)) {
            DWORD dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[1];
            DWORD dwTCIndex  = (pContext->hwState.dwTexCoordIndices >> 8) & 0xff;
            DWORD dwVAIndex  = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
            DWORD dwCount    = (pContext->hwState.pVertexShader->getVASize(dwVAIndex) >> 2);
            for (DWORD i = 0; i < dwCount; i++)
            {
                DPF ("   UV1[%d] = %f [%08x]", i,FLOAT_FROM_DWORD(pdwData[0]),pdwData[0]);
                pdwData += 1;
            }
        }

        if (pContext->hwState.dwStateFlags & KELVIN_FLAG_USERTEXCOORDSNEEDED(0)) {
            DWORD dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[0];
            DWORD dwTCIndex  = (pContext->hwState.dwTexCoordIndices >> 0) & 0xff;
            DWORD dwVAIndex  = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
            DWORD dwCount    = (pContext->hwState.pVertexShader->getVASize(dwVAIndex) >> 2);
            for (DWORD i = 0; i < dwCount; i++)
            {
                DPF ("   UV0[%d] = %f [%08x]", i,FLOAT_FROM_DWORD(pdwData[0]),pdwData[0]);
                pdwData += 1;
            }
        }

        if (pContext->hwState.pVertexShader->bVAExists(defaultInputRegMap[D3DVSDE_SPECULAR])){
            DPF ("  Specular = %08x",pdwData[0]);
            pdwData += 1;
        }

        if (pContext->hwState.pVertexShader->bVAExists(defaultInputRegMap[D3DVSDE_DIFFUSE])) {
            DPF ("   Diffuse = %08x",pdwData[0]);
            pdwData += 1;
        }

        nvAssert (pContext->hwState.pVertexShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]));
        DPF ("       XYZ = %f, %f, %f", FLOAT_FROM_DWORD(pdwData[0]),FLOAT_FROM_DWORD(pdwData[1]),FLOAT_FROM_DWORD(pdwData[2]));
        DPF ("           = [%08x, %08x, %08x]", pdwData[0],pdwData[1],pdwData[2]);
        pdwData += 3;

        if (pContext->hwState.pVertexShader->getVASize(defaultInputRegMap[D3DVSDE_POSITION]) == 4*sizeof(DWORD)) {
            DPF ("       RHW = %f [%08x]", FLOAT_FROM_DWORD(pdwData[0]),pdwData[0]);
            pdwData += 1;
        }
        DPF ("");
    }
}
#endif

// copies dwCount bytes from [esi] to [edi] with increment. if dwCount is zero then we copy ecx bytes
// we use esi,edi,eax and ecx. for kni we also use xmm0 to xmm3
void nvKelvinILCompile_memcpy
(
    DWORD dwCount, bool recurse
)
{

//    if (dwCount)
//    {
//        xMOV_rm_imm (rmREG(rECX),dwCount)
//    }
//
//    xMOV_r_rm   (rEAX,rmREG(rECX))
//    xSHR_rm_imm (rmREG(rECX),2)
//    xAND_rm_imm (rmREG(rEAX),3)
//    xREP xMOVSD
//    xMOV_r_rm   (rECX,rmREG(rEAX))
//    xREP xMOVSB
//
    if (dwCount)
    {
        // do copy
        if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI)
        {
            //
            // KNI copy
            //
            while (dwCount >= 64)
            {
                xMOVLPS_r_rm    (rXMM0,rmIND(rESI))
                xMOVHPS_r_rm    (rXMM0,rmIND8(rESI)) xOFS8(8)
                xMOVLPS_r_rm    (rXMM1,rmIND8(rESI)) xOFS8(16)
                xMOVHPS_r_rm    (rXMM1,rmIND8(rESI)) xOFS8(24)
                xMOVLPS_r_rm    (rXMM2,rmIND8(rESI)) xOFS8(32)
                xMOVHPS_r_rm    (rXMM2,rmIND8(rESI)) xOFS8(40)
                xMOVLPS_r_rm    (rXMM3,rmIND8(rESI)) xOFS8(48)
                xMOVHPS_r_rm    (rXMM3,rmIND8(rESI)) xOFS8(56)
                xADD_rm_imm     (rmREG(rESI),64)
                xMOVLPS_rm_r    (rmIND(rEDI),rXMM0)
                xMOVHPS_rm_r    (rmIND8(rEDI),rXMM0) xOFS8(8)
                xMOVLPS_rm_r    (rmIND8(rEDI),rXMM1) xOFS8(16)
                xMOVHPS_rm_r    (rmIND8(rEDI),rXMM1) xOFS8(24)
                xMOVLPS_rm_r    (rmIND8(rEDI),rXMM2) xOFS8(32)
                xMOVHPS_rm_r    (rmIND8(rEDI),rXMM2) xOFS8(40)
                xMOVLPS_rm_r    (rmIND8(rEDI),rXMM3) xOFS8(48)
                xMOVHPS_rm_r    (rmIND8(rEDI),rXMM3) xOFS8(56)
                xADD_rm_imm     (rmREG(rEDI),64)
                dwCount -= 64;
            }

            while (dwCount >= 16)
            {
                xMOVLPS_r_rm    (rXMM0,rmIND(rESI))
                xMOVHPS_r_rm    (rXMM0,rmIND8(rESI)) xOFS8(8)
                xADD_rm_imm     (rmREG(rESI),16)
                xMOVLPS_rm_r    (rmIND(rEDI),rXMM0)
                xMOVHPS_rm_r    (rmIND8(rEDI),rXMM0) xOFS8(8)
                xADD_rm_imm     (rmREG(rEDI),16)
                dwCount -= 16;
            }

            while (dwCount >= 8)
            {
                xMOV_r_rm    (rEAX,rmIND(rESI))
                xMOV_r_rm    (rECX,rmIND8(rESI)) xOFS8(4)
                xADD_rm_imm  (rmREG(rESI),8)
                xMOV_rm_r    (rmIND(rEDI),rEAX)
                xADD_rm_imm  (rmREG(rEDI),8)
                xMOV_rm_r    (rmIND8(rEDI),rECX) xOFS8(4 - 8)
                dwCount -= 8;
            }

            while (dwCount >= 4)
            {
                xMOV_r_rm    (rEAX,rmIND(rESI))
                xADD_rm_imm  (rmREG(rESI),4)
                xMOV_rm_r    (rmIND(rEDI),rEAX)
                xADD_rm_imm  (rmREG(rEDI),4)
                dwCount -= 4;
            }

            if (dwCount)
            {
                xMOV_rm_imm (rmREG(rECX),dwCount)
                xREP xMOVSB
            }
        }
        else if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_ATHLON)
        {
            //
            // AMD copy
            //
            bool needFemms = false;
            if (dwCount >= 16 && !recurse)
            {
                xFEMMS
                needFemms = true;
            }

            while (dwCount >= 64)
            {
                xMOVQ_r_rm      (rMM0,rmIND(rESI))
                xMOVQ_r_rm      (rMM1,rmIND8(rESI)) xOFS8(8)
                xMOVQ_r_rm      (rMM2,rmIND8(rESI)) xOFS8(16)
                xMOVQ_r_rm      (rMM3,rmIND8(rESI)) xOFS8(24)
                xMOVQ_r_rm      (rMM4,rmIND8(rESI)) xOFS8(32)
                xMOVQ_r_rm      (rMM5,rmIND8(rESI)) xOFS8(40)
                xMOVQ_r_rm      (rMM6,rmIND8(rESI)) xOFS8(48)
                xMOVQ_r_rm      (rMM7,rmIND8(rESI)) xOFS8(56)
                xADD_rm_imm     (rmREG(rESI),64)
                xMOVNTQ_rm_r    (rmIND(rEDI),rMM0)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM1) xOFS8(8)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM2) xOFS8(16)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM3) xOFS8(24)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM4) xOFS8(32)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM5) xOFS8(40)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM6) xOFS8(48)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM7) xOFS8(56)
                xADD_rm_imm     (rmREG(rEDI),64)
                dwCount -= 64;
            }

            while (dwCount >= 16)
            {
                xMOVQ_r_rm      (rMM0,rmIND(rESI))
                xMOVQ_r_rm      (rMM1,rmIND8(rESI)) xOFS8(8)
                xADD_rm_imm     (rmREG(rESI),16)
                xMOVNTQ_rm_r    (rmIND(rEDI),rMM0)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM1) xOFS8(8)
                xADD_rm_imm     (rmREG(rEDI),16)
                dwCount -= 16;
            }

            while (dwCount >= 8)
            {
                xMOV_r_rm    (rEAX,rmIND(rESI))
                xMOV_r_rm    (rECX,rmIND8(rESI)) xOFS8(4)
                xADD_rm_imm  (rmREG(rESI),8)
                xMOV_rm_r    (rmIND(rEDI),rEAX)
                xADD_rm_imm  (rmREG(rEDI),8)
                xMOV_rm_r    (rmIND8(rEDI),rECX) xOFS8(4 - 8)
                dwCount -= 8;
            }

            while (dwCount >= 4)
            {
                xMOV_r_rm    (rEAX,rmIND(rESI))
                xADD_rm_imm  (rmREG(rESI),4)
                xMOV_rm_r    (rmIND(rEDI),rEAX)
                xADD_rm_imm  (rmREG(rEDI),4)
                dwCount -= 4;
            }

            if (dwCount)
            {
                xMOV_rm_imm (rmREG(rECX),dwCount)
                xREP xMOVSB
            }

            if (needFemms)
            {
                xFEMMS
            }

        }
        else
        {
            //
            // normal 8086 copy
            //
            DWORD dwWordCount = dwCount / 4;
            if (dwWordCount)
            {
                xMOV_rm_imm (rmREG(rECX),dwWordCount)
                xREP xMOVSD
            }
            dwCount &= 3;
            if (dwCount)
            {
                xMOV_rm_imm (rmREG(rECX),dwCount)
                xREP xMOVSB
            }
        }
    }
    else
    {
        // variable length copy
        if ((pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI) || (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_ATHLON))
        {
            bool needFemms = false;
            if (dwCount >= 16 && !recurse)
            {
                xFEMMS
                needFemms = true;
            }

            //
            // kni copy
            //
            DWORD label1;
            DWORD label2;
            // 64 byte xfers
            xLABEL      (label2)
            xCMP_rm_imm (rmREG(rECX),64)
            xLABEL      (label1)
            xJL32       (0)
            xPUSH_r     (rECX)
            nvKelvinILCompile_memcpy (64, true);
            xPOP_r      (rECX)
            xLEA_r_rm   (rECX,rmIND8(rECX)) xOFS8(-64)
            xJMP        (label2)
            xTARGET_b32 (label1)
            // 16 byte xfers
            xLABEL      (label2)
            xCMP_rm_imm (rmREG(rECX),16)
            xLABEL      (label1)
            xJL32       (0)
            xPUSH_r     (rECX)
            nvKelvinILCompile_memcpy (16, true);
            xPOP_r      (rECX)
            xLEA_r_rm   (rECX,rmIND8(rECX)) xOFS8(-16)
            xJMP        (label2)
            xTARGET_b32 (label1)
            // the rest
            xMOV_r_rm   (rEAX,rmREG(rECX))
            xSHR_rm_imm8(rmREG(rECX),2)
            xAND_rm_imm (rmREG(rEAX),3)
            xREP xMOVSD
            xMOV_r_rm   (rECX,rmREG(rEAX))
            xREP xMOVSB

            if (needFemms)
            {
                xFEMMS
            }
        }
        else
        {
            //
            // normal 8086 copy
            //
            xMOV_r_rm   (rEAX,rmREG(rECX))
            xSHR_rm_imm8(rmREG(rECX),2)
            xAND_rm_imm (rmREG(rEAX),3)
            xREP xMOVSD
            xMOV_r_rm   (rECX,rmREG(rEAX))
            xREP xMOVSB
        }
    }
}

// adds a base vertex index (16bit) to all 16bit chunks
// copies dwCount bytes from [esi] to [edi] with increment. if dwCount is zero then we copy ecx bytes
// we use esi,edi,eax and ecx. for kni we also use xmm0 to xmm3
void nvKelvinILCompile_indexcpy
(
    DWORD dwCount
)
{
    if (dwCount)
    {
        // do copy
        if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_WILLAMETTE)
        {
            //
            // WNI copy
            //
            xMOV_r_i32      (rECX,mMEM32(global.kelvin.dwBaseVertex))
            xSHL_rm_imm8    (rmREG(rECX),16)
            xOR_r_i32       (rECX,mMEM32(global.kelvin.dwBaseVertex))
            xMOVDX_r_rm      (rXMM4, rmREG(rECX))
            xPSHUFLW_r_rm_imm (rXMM4, rmREG(rXMM4), 0)
            xPUNPCKLWDX_r_rm (rXMM4, rmREG(rXMM4))

            while (dwCount >= 64)
            {
                xMOVLPS_r_rm    (rXMM0,rmIND(rESI))
                xMOVHPS_r_rm    (rXMM0,rmIND8(rESI)) xOFS8(8)
                xPADDWX_r_rm    (rXMM0, rmREG(rXMM4))
                xMOVLPS_r_rm    (rXMM1,rmIND8(rESI)) xOFS8(16)
                xMOVHPS_r_rm    (rXMM1,rmIND8(rESI)) xOFS8(24)
                xPADDWX_r_rm    (rXMM1, rmREG(rXMM4))
                xMOVLPS_r_rm    (rXMM2,rmIND8(rESI)) xOFS8(32)
                xMOVHPS_r_rm    (rXMM2,rmIND8(rESI)) xOFS8(40)
                xPADDWX_r_rm    (rXMM2, rmREG(rXMM4))
                xMOVLPS_r_rm    (rXMM3,rmIND8(rESI)) xOFS8(48)
                xMOVHPS_r_rm    (rXMM3,rmIND8(rESI)) xOFS8(56)
                xPADDWX_r_rm    (rXMM3, rmREG(rXMM4))
                xADD_rm_imm     (rmREG(rESI),64)
                xMOVLPS_rm_r    (rmIND(rEDI),rXMM0)
                xMOVHPS_rm_r    (rmIND8(rEDI),rXMM0) xOFS8(8)
                xMOVLPS_rm_r    (rmIND8(rEDI),rXMM1) xOFS8(16)
                xMOVHPS_rm_r    (rmIND8(rEDI),rXMM1) xOFS8(24)
                xMOVLPS_rm_r    (rmIND8(rEDI),rXMM2) xOFS8(32)
                xMOVHPS_rm_r    (rmIND8(rEDI),rXMM2) xOFS8(40)
                xMOVLPS_rm_r    (rmIND8(rEDI),rXMM3) xOFS8(48)
                xMOVHPS_rm_r    (rmIND8(rEDI),rXMM3) xOFS8(56)
                xADD_rm_imm     (rmREG(rEDI),64)
                dwCount -= 64;
            }

            while (dwCount >= 16)
            {
                xMOVLPS_r_rm    (rXMM0,rmIND(rESI))
                xMOVHPS_r_rm    (rXMM0,rmIND8(rESI)) xOFS8(8)
                xPADDWX_r_rm    (rXMM0, rmREG(rXMM4))
                xADD_rm_imm     (rmREG(rESI),16)
                xMOVLPS_rm_r    (rmIND(rEDI),rXMM0)
                xMOVHPS_rm_r    (rmIND8(rEDI),rXMM0) xOFS8(8)
                xADD_rm_imm     (rmREG(rEDI),16)
                dwCount -= 16;
            }
        }
        else if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI)
        {
            //
            // KNI copy - we use MMX because there's no integer add for KNI regs.
            //
            xEMMS
            xMOV_r_i32      (rECX,mMEM32(global.kelvin.dwBaseVertex))
            xSHL_rm_imm8    (rmREG(rECX),16)
            xOR_r_i32       (rECX,mMEM32(global.kelvin.dwBaseVertex))
            xMOVD_r_rm      (rMM4, rmREG(rECX))
            xPSHUFW_r_rm_imm (rMM4, rmREG(rMM4), 0)
            while (dwCount >= 64)
            {

                xMOVQ_r_rm      (rMM0,rmIND(rESI))
                xPADDW_r_rm     (rMM0, rmREG(rMM4))
                xMOVQ_r_rm      (rMM1,rmIND8(rESI)) xOFS8(8)
                xPADDW_r_rm     (rMM1, rmREG(rMM4))
                xMOVQ_r_rm      (rMM2,rmIND8(rESI)) xOFS8(16)
                xPADDW_r_rm     (rMM2, rmREG(rMM4))
                xMOVQ_r_rm      (rMM3,rmIND8(rESI)) xOFS8(24)
                xPADDW_r_rm     (rMM3, rmREG(rMM4))

                xMOVNTQ_rm_r    (rmIND(rEDI),rMM0)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM1) xOFS8(8)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM2) xOFS8(16)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM3) xOFS8(24)

                xMOVQ_r_rm      (rMM0,rmIND8(rESI)) xOFS8(32)
                xPADDW_r_rm     (rMM0, rmREG(rMM4))
                xMOVQ_r_rm      (rMM1,rmIND8(rESI)) xOFS8(40)
                xPADDW_r_rm     (rMM1, rmREG(rMM4))
                xMOVQ_r_rm      (rMM2,rmIND8(rESI)) xOFS8(48)
                xPADDW_r_rm     (rMM2, rmREG(rMM4))
                xMOVQ_r_rm      (rMM3,rmIND8(rESI)) xOFS8(56)
                xPADDW_r_rm     (rMM3, rmREG(rMM4))

                xADD_rm_imm     (rmREG(rESI),64)


                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM0) xOFS8(32)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM1) xOFS8(40)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM2) xOFS8(48)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM3) xOFS8(56)
                xADD_rm_imm     (rmREG(rEDI),64)


                dwCount -= 64;
            }

            while (dwCount >= 16)
            {
                xMOVQ_r_rm      (rMM0,rmIND(rESI))
                xPADDW_r_rm     (rMM0, rmREG(rMM4))
                xMOVQ_r_rm      (rMM1,rmIND8(rESI)) xOFS8(8)
                xPADDW_r_rm     (rMM1, rmREG(rMM4))
                xADD_rm_imm     (rmREG(rESI),16)
                xMOVNTQ_rm_r    (rmIND(rEDI),rMM0)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM1) xOFS8(8)
                xADD_rm_imm     (rmREG(rEDI),16)
                dwCount -= 16;
            }
            xEMMS

        }
        else if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_ATHLON)
        {
            //
            // AMD copy
            //
            xFEMMS
            xMOV_r_i32      (rECX,mMEM32(global.kelvin.dwBaseVertex))
            xSHL_rm_imm8    (rmREG(rECX),16)
            xOR_r_i32       (rECX,mMEM32(global.kelvin.dwBaseVertex))
            xMOVD_r_rm      (rMM4, rmREG(rECX))
            xPUNPCKLDQ_r_rm (rMM4, rmREG(rMM4))
            while (dwCount >= 64)
            {
                xMOVQ_r_rm      (rMM0,rmIND(rESI))
                xPADDW_r_rm     (rMM0, rmREG(rMM4))
                xMOVQ_r_rm      (rMM1,rmIND8(rESI)) xOFS8(8)
                xPADDW_r_rm     (rMM1, rmREG(rMM4))
                xMOVQ_r_rm      (rMM2,rmIND8(rESI)) xOFS8(16)
                xPADDW_r_rm     (rMM2, rmREG(rMM4))
                xMOVQ_r_rm      (rMM3,rmIND8(rESI)) xOFS8(24)
                xPADDW_r_rm     (rMM3, rmREG(rMM4))

                xMOVNTQ_rm_r    (rmIND(rEDI),rMM0)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM1) xOFS8(8)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM2) xOFS8(16)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM3) xOFS8(24)

                xMOVQ_r_rm      (rMM0,rmIND8(rESI)) xOFS8(32)
                xPADDW_r_rm     (rMM0, rmREG(rMM4))
                xMOVQ_r_rm      (rMM1,rmIND8(rESI)) xOFS8(40)
                xPADDW_r_rm     (rMM1, rmREG(rMM4))
                xMOVQ_r_rm      (rMM2,rmIND8(rESI)) xOFS8(48)
                xPADDW_r_rm     (rMM2, rmREG(rMM4))
                xMOVQ_r_rm      (rMM3,rmIND8(rESI)) xOFS8(56)
                xPADDW_r_rm     (rMM3, rmREG(rMM4))

                xADD_rm_imm     (rmREG(rESI),64)


                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM0) xOFS8(32)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM1) xOFS8(40)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM2) xOFS8(48)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM3) xOFS8(56)
                xADD_rm_imm     (rmREG(rEDI),64)


                dwCount -= 64;
            }

            while (dwCount >= 16)
            {
                xMOVQ_r_rm      (rMM0,rmIND(rESI))
                xPADDW_r_rm     (rMM0, rmREG(rMM4))
                xMOVQ_r_rm      (rMM1,rmIND8(rESI)) xOFS8(8)
                xPADDW_r_rm     (rMM1, rmREG(rMM4))
                xADD_rm_imm     (rmREG(rESI),16)
                xMOVNTQ_rm_r    (rmIND(rEDI),rMM0)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM1) xOFS8(8)
                xADD_rm_imm     (rmREG(rEDI),16)
                dwCount -= 16;
            }
            xFEMMS
        }
        if (dwCount)
        {
            //
            // normal 8086 copy
            //
            DWORD label;
            xLABEL (label)


            xMOV_r_i32  (rECX,mMEM32(global.kelvin.dwBaseVertex))
            xSHL_rm_imm8 (rmREG(rECX),16)
            xOR_r_i32   (rECX,mMEM32(global.kelvin.dwBaseVertex))
            //hmmm fully unrolled loop might not be the best... HMH
            //never mind, 64 indices is max (aka 32 moves)
            while (dwCount >= 4)
            {
                xMOV_r_rm    (rEAX,rmIND(rESI))
                xADD_rm_imm  (rmREG(rESI),4)
                xADD_r_rm    (rEAX, rmREG(rECX)) //add base index
                xMOV_rm_r    (rmIND(rEDI),rEAX)
                xADD_rm_imm  (rmREG(rEDI),4)
                dwCount -= 4;

            }
            if (dwCount) //it had better be 2
            {
                x16r xMOV_r_rm (rAX,rmIND(rESI))
                xADD_rm_imm  (rmREG(rESI),2)
                xADD_r_rm    (rEAX, rmREG(rECX)) //add base index
                xMOV_rm_r    (rmIND(rEDI),rAX)
                xADD_rm_imm  (rmREG(rEDI),2)
                dwCount -= 2;
            }
        }
    }
}


// vertex at ESI, pusher at EDI
//  thrashes eax,ebx,ecx,edx and ebp
void nvKelvinILCompile_copyVertex
(
    PNVD3DCONTEXT pContext,
    DWORD         dwFlags
)
{
    CVertexShader *pVShader;

    const DWORD    adwRegister[]        = { rEAX,rEBX,rECX,rEDX,rEBP };
    DWORD          dwDstIndex           = 0;
    DWORD          dwInlineVertexStride = pContext->hwState.dwInlineVertexStride;

    // cache the vertex shader
    pVShader = pContext->hwState.pVertexShader;
    nvAssert (pVShader);

    // rd: method
    xMOV_rm_imm (rmREG(rEAX),(((dwInlineVertexStride) << 16) | ((NV_DD_KELVIN) << 13) | (NVPUSHER_NOINC(NV097_INLINE_ARRAY))))

    // wr: method
    xMOV_rm_r   (rmIND(rEDI),rEAX)
    dwDstIndex += 4;

    nvAssert (pVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]));

    // rd: xyz
    xMOV_r_rm   (rECX,rmIND8(rESI)) xOFS8(global.kelvin.dwOffsetXYZ)
    xMOV_r_rm   (rEDX,rmIND8(rESI)) xOFS8(global.kelvin.dwOffsetXYZ + 4)
    xMOV_r_rm   (rEBP,rmIND8(rESI)) xOFS8(global.kelvin.dwOffsetXYZ + 8)

    // wr: xyz
    xMOV_rm_r   (rmIND8(rEDI),rECX) xOFS8(dwDstIndex)
    xMOV_rm_r   (rmIND8(rEDI),rEDX) xOFS8(dwDstIndex + 4)
    xMOV_rm_r   (rmIND8(rEDI),rEBP) xOFS8(dwDstIndex + 8)
    dwDstIndex += 12;

    // rd & wr: rhw
    if (pVShader->getVASize(defaultInputRegMap[D3DVSDE_POSITION]) == 4*sizeof(DWORD))
    {
        xMOV_r_rm   (rEAX,rmIND8(rESI)) xOFS8(global.kelvin.dwOffsetRHW)
        xMOV_rm_r   (rmIND8(rEDI),rEAX) xOFS8(dwDstIndex)
        dwDstIndex += 4;
    }

    // rd & wr: blend weights
    if (pVShader->bVAExists(defaultInputRegMap[D3DVSDE_BLENDWEIGHT]))
    {
        DWORD dwNumWeights = pVShader->getVASize(defaultInputRegMap[D3DVSDE_BLENDWEIGHT]) >> 2;
        for (DWORD i=0; i<dwNumWeights; i++) {
            xMOV_r_rm   (rEBX,rmIND8(rESI)) xOFS8(global.kelvin.dwOffsetWeight + 4*i)
            xMOV_rm_r   (rmIND8(rEDI),rEBX) xOFS8(dwDstIndex)
            dwDstIndex += 4;
        }
    }

    // rd & wr: normal
    if (pVShader->bVAExists(defaultInputRegMap[D3DVSDE_NORMAL]))
    {
        xMOV_r_rm   (rECX,rmIND8(rESI)) xOFS8(global.kelvin.dwOffsetNormal)
        xMOV_r_rm   (rEDX,rmIND8(rESI)) xOFS8(global.kelvin.dwOffsetNormal + 4)
        xMOV_r_rm   (rEBP,rmIND8(rESI)) xOFS8(global.kelvin.dwOffsetNormal + 8)
        xMOV_rm_r   (rmIND8(rEDI),rECX) xOFS8(dwDstIndex)
        xMOV_rm_r   (rmIND8(rEDI),rEDX) xOFS8(dwDstIndex + 4)
        xMOV_rm_r   (rmIND8(rEDI),rEBP) xOFS8(dwDstIndex + 8)
        dwDstIndex += 12;
    }

    // rd: diffuse
    if (pVShader->bVAExists(defaultInputRegMap[D3DVSDE_DIFFUSE]))
    {
        xMOV_r_rm   (rEAX,rmIND8(rESI)) xOFS8(global.kelvin.dwOffsetDiffuse)
    }

    // rd: specular
    if (pVShader->bVAExists(defaultInputRegMap[D3DVSDE_SPECULAR]))
    {
        xMOV_r_rm   (rEBX,rmIND8(rESI)) xOFS8(global.kelvin.dwOffsetSpecular)
    }

    // rd: point size
    if (pVShader->bVAExists(defaultInputRegMap[D3DVSDE_PSIZE]))
    {
        xMOV_r_rm   (rECX,rmIND8(rESI)) xOFS8(global.kelvin.dwOffsetPointSize)
    }

    // wr: diffuse
    if (pVShader->bVAExists(defaultInputRegMap[D3DVSDE_DIFFUSE]))
    {
        xMOV_rm_r   (rmIND8(rEDI),rEAX) xOFS8(dwDstIndex)
        dwDstIndex += 4;
    }

    // wr: specular
    if (pVShader->bVAExists(defaultInputRegMap[D3DVSDE_SPECULAR]))
    {
        xMOV_rm_r   (rmIND8(rEDI),rEBX) xOFS8(dwDstIndex)
        dwDstIndex += 4;
    }

    // wr: point size
    if (pVShader->bVAExists(defaultInputRegMap[D3DVSDE_PSIZE]))
    {
        xMOV_rm_r   (rmIND8(rEDI),rECX) xOFS8(dwDstIndex)
        dwDstIndex += 4;
    }

    for (DWORD dwHWStage = 0; dwHWStage < KELVIN_NUM_TEXTURES; dwHWStage++)
    {
        if (pContext->hwState.dwStateFlags & KELVIN_FLAG_USERTEXCOORDSNEEDED(dwHWStage))
        {
            DWORD dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[dwHWStage];
            DWORD dwTCIndex  = (pContext->hwState.dwTexCoordIndices >> (8*dwHWStage)) & 0xff;  // BUGBUG?? are these indices even relevant in DX8?
            DWORD dwVAIndex  = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
            DWORD dwCount    = ((pVShader->getVASize (dwVAIndex)) >> 2);
            assert (dwCount < 5);
            {
                for (DWORD i = 0; i < dwCount; i++)
                {
                    xMOV_r_rm   (adwRegister[i],rmIND8(rESI)) xOFS8(i * 4 + global.kelvin.dwOffsetUV[dwTCIndex])
                }

#ifdef STOMP_TEX_COORDS
                if (pContext->hwState.dwStateFlags & KELVIN_FLAG_STOMP_4TH_COORD(dwHWStage))
                {
                    xMOV_r_imm  (adwRegister[3],0x3f800000)
                }
#endif  // STOMP_TEX_COORDS

                for (DWORD k = 0; k < dwCount; k++)
                {
                    xMOV_rm_r   (rmIND8(rEDI),adwRegister[k]) xOFS8(dwDstIndex)
                    dwDstIndex += 4;
                }
            }
        }
    }

    // sanity check
    assert ((dwDstIndex - 4) == dwInlineVertexStride);

    // we can optionally print the vertex here
#if defined(DEBUG) || defined(NVSTATDRIVER)
    xMOV_rm_imm (rmREG(rEAX),(DWORD)nvKelvinDispatchPrintVertex)
    xMOV_r_i32  (rEBX,mMEM32(global.kelvin.pContext))
    xPUSH_r     (rEDI)
    xPUSH_r     (rEBX)
    xCALL_rm    (rmREG(rEAX))
#endif

    // adjust put
    xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(dwDstIndex)
}

//
// range limit <only on NT> (dummy must be eax, ebx, ecx or edx)
//
void nvKelvinILCompile_limit
(
    DWORD regLimit,
    DWORD regDummy
)
{
    assert ((regDummy == rEAX)
         || (regDummy == rEBX)
         || (regDummy == rECX)
         || (regDummy == rEDX));

#ifdef WINNT
    xXOR_r_rm   (regDummy,rmREG(regDummy))
    xCMP_r_i32  (regLimit,mMEM32(global.dwMaxVertexOffset))
    xSETAE_rm8  (rmREG(regDummy))
    xDEC_rm     (rmREG(regDummy))
    xAND_r_rm   (regLimit,rmREG(regDummy))
#endif
}



// prefetch data
//  will trash ESI, ECX, EDX, EAX
void nvKelvinILCompile_prefetch
(
    BOOL bIsIndexed,
    BOOL bLegacyStrides
)
{
    if (bIsIndexed)
    {
        // prefetch & range check indices
        DWORD labelPrefetch1;
        DWORD labelPrefetch2;
        DWORD labelPrefetch3;
        DWORD labelPrefetch4;
        xLABEL      (labelPrefetch1)
        xMOV_r_i32  (rESI,mMEM32(global.kelvin.dwPrefetchBase))
        xCMP_r_i32  (rESI,mMEM32(global.kelvin.pIndices))
        xLABEL      (labelPrefetch2)
        xJA32       (0)

        xMOV_rm_imm (rmREG(rECX),2048 / global.kelvin.dwVertexStride)
        xLABEL      (labelPrefetch4)
        {
            xPUSH_r     (rECX)
            // read index
            xXOR_r_rm   (rEDX,rmREG(rEDX))
       x16r xMOV_r_rm   (rDX,rmIND(rESI))
            xLEA_r_rm   (rESI,rmIND8(rESI)) xOFS8(2)
            if (bLegacyStrides)
            {
                xMOV_r_rm   (rEAX,rmREG(rESI))
                xSUB_r_i32  (rEAX,mMEM32(global.kelvin.pIndexBase))
                xAND_rm_imm (rmREG(rEAX),6)
                xXOR_r_rm   (rECX,rmREG(rECX))
                xCMP_rm_imm (rmREG(rEAX),6)
                xSETNZ_rm8  (rmREG(rCL))
                xDEC_rm     (rmREG(rECX))
                xAND_rm_imm (rmREG(rECX),2)
                xADD_r_rm   (rESI,rmREG(rECX))
            }
            ILCCompile_mul (rEDX,global.kelvin.dwVertexStride);
            // range limit
            nvKelvinILCompile_limit (rEDX,rECX);
            // compute vertex address
            xADD_r_i32  (rEDX,mMEM32(global.kelvin.pVertices))
            // prefetch
            xMOV_r_rm   (rEAX,rmIND(rEDX))
            if (global.kelvin.dwVertexStride > 32)
            {
                xMOV_r_rm   (rEAX,rmIND8(rEDX)) xOFS8(32)
            }
            xMOV_rm_imm (rmREG(rEAX),0)
            // end of valid run?
            xPOP_r      (rECX)
            xCMP_r_i32  (rESI,mMEM32(global.kelvin.dwPrefetchMax))
            xLABEL      (labelPrefetch3)
            xJAE32      (0)
            // next
            xDEC_rm     (rmREG(rECX))
        }
        xJNZ32      (labelPrefetch4)
        xTARGET_b32 (labelPrefetch3)
        xMOV_i32_r  (mMEM32(global.kelvin.dwPrefetchBase),rESI)
        xTARGET_b32 (labelPrefetch2)
    }
    else
    {
        // prefetch & range check indices
        DWORD labelPrefetch1;
        DWORD labelPrefetch2;
        DWORD labelPrefetch3;
        DWORD labelPrefetch4;
        xLABEL      (labelPrefetch1)
        xMOV_r_i32  (rESI,mMEM32(global.kelvin.dwPrefetchBase))
        xCMP_r_i32  (rESI,mMEM32(global.kelvin.pVertices))
        xLABEL      (labelPrefetch2)
        xJA32       (0)

        xMOV_rm_imm (rmREG(rECX),2048 / global.kelvin.dwVertexStride)
        xLABEL      (labelPrefetch4)
        {
            // prefetch
            xMOV_r_rm   (rEAX,rmIND(rESI))
            xMOV_rm_imm (rmREG(rEAX),0)
            xADD_rm_imm (rmREG(rESI),32)
            // end of valid run?
            xCMP_r_i32  (rESI,mMEM32(global.kelvin.dwPrefetchMax))
            xLABEL      (labelPrefetch3)
            xJAE32      (0)
            // next
            xDEC_rm     (rmREG(rECX))
        }
        xJNZ32      (labelPrefetch4)
        xTARGET_b32 (labelPrefetch3)
        xMOV_i32_r  (mMEM32(global.kelvin.dwPrefetchBase),rESI)
        xTARGET_b32 (labelPrefetch2)
    }
}

#endif KELVIN_ILC


#endif  // NVARCH == 0x20
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\kelvin\src\nvKelvinOptimiseVS_link.cpp ===
// **************************************************************************
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvKelvinCompileVS_link.cpp
//      a pointer to a shared file
//
// **************************************************************************

#include "nvprecomp.h"
#include "..\..\..\common\src\vpoptimize.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\kelvin\src\nvkelvininltri.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvKelvinInlTri.cpp                                               *
*       indexed and ordered inline triangle lists                           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Scott Kephart           18Nov00         Ported from NV10            *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x10)

#include "x86.h"

#ifdef KELVIN_ILC

//////////////////////////////////////////////////////////////////////////////
// notes:
//  - when offset changes, only program it, dont call setcelsiusstate
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// switches
//

//////////////////////////////////////////////////////////////////////////////
// aliases
//
#define ilcData         global.dwILCData
#define ilcCount        global.dwILCCount
#define ilcMax          global.dwILCMax

//////////////////////////////////////////////////////////////////////////////
// externals
//
void ILCCompile_mul                             (DWORD reg,DWORD num);
void nvKelvinILCompile_beginEnd                 (DWORD dwPrimType);
void nvKelvinILCompile_computeIndexAndOffset    (DWORD dwVBStride,DWORD dwVBLogStride);
void nvKelvinILCompile_memcpy                   (DWORD dwCount, bool recurse);
void nvKelvinILCompile_copyVertex               (PNVD3DCONTEXT pContext,DWORD dwFlags);
void nvKelvinILCompile_prefetch                 (BOOL bIsIndexed,BOOL bLegacyStrides);
void nvKelvinILCompile_limit                    (DWORD regLimit,DWORD regDummy);

void __stdcall nvKelvinDispatchGetFreeSpace   (PNVD3DCONTEXT pContext);
void __stdcall nvKelvinDispatchGetPusherSpace (void);
#ifdef DEBUG
void __stdcall nvKelvinDispatchFlush          (void);
void __stdcall nvKelvinDispatchPrintVertex    (PNVD3DCONTEXT pContext,DWORD dwPutAddress);
#endif

/*****************************************************************************
 *****************************************************************************
 *** helpers *****************************************************************
 *****************************************************************************
 *****************************************************************************/

void nvKelvinILCompile_cullcheck
(
    BOOL bIsIndexed
)
{
    //
    // get vertices into eax, ebx and ecx
    //
    if (bIsIndexed)
    {
        // already set up correctly
    }
    else
    {
        xMOV_r_i32       (rEAX,mMEM32(global.kelvin.pVertices))
        xMOV_r_rm        (rEBX,rmREG(rEAX))
        xMOV_r_rm        (rECX,rmREG(rEAX))
        xADD_rm_imm      (rmREG(rEBX),global.kelvin.dwVertexStride)
        xADD_rm_imm      (rmREG(rECX),global.kelvin.dwVertexStride * 2)
    }

    //
    // compute cross product
    //
    if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI)
    {
        /*
         * katmai
         */
        xMOVLPS_r_rm     (rXMM0,rmIND(rEAX))
        xMOVLPS_r_rm     (rXMM1,rmIND(rEBX))
        xSHUFPS_r_rm_imm (rXMM0,rmREG(rXMM0),0x44)          // xmm0: y0     x0      y0      x0
        xMOVHPS_r_rm     (rXMM1,rmIND(rECX))                // xmm1: y2     x2      y1      x1

        xSUBPS_r_rm      (rXMM1,rmREG(rXMM0))               // xmm1: y2-y0  x2-x0   y1-y0   x1-x0
        xSHUFPS_r_rm_imm (rXMM1,rmREG(rXMM1),0xe1)          // xmm1: y2-y0  x2-x0   x1-x0   y1-y0

        xMOVHLPS_r_r     (rXMM0,rXMM1)                      // xmm0: ?      ?       y2-y0   x2-x0
        xMULPS_r_rm      (rXMM0,rmREG(rXMM1))               // xmm0: ?      ?       (x1-x0)*(y2-y0) (y1-y0)*(x2-x0)

        xMOVAPS_r_rm     (rXMM1,rmREG(rXMM0))
        xSHUFPS_r_rm_imm (rXMM1,rmREG(rXMM1),0xe1)          // xmm1: ?      ?       ?       (x1-x0)*(y2-y0)

        xSUBSS_r_rm      (rXMM1,rmREG(rXMM0))               // xmm1: ?      ?       ?       (x1-x0)*(y2-y0)-(y1-y0)*(x2-x0)
        xMOVSS_i32_r     (mMEM32(global.dwTemp),rXMM1)
        xMOV_r_i32       (rEDX,mMEM32(global.dwTemp))
        xAND_rm_imm      (rmREG(rEDX),0x80000000)
        xCMP_r_i32       (rEDX,mMEM32(global.kelvin.dwCullValue))
    }
    else
    {
        /*
         * generic
         */
        xFLD_rm32  (rmIND(rEAX))                    // X0
        xFLD_rm32  (rmIND(rEBX))                    // X1 | X0
        xFXCH_st   (rST1)                           // X0 | X1
        xFSUBP_st  (rST1)                           // X1-X0
        xFLD_rm32  (rmIND8(rECX)) xOFS8(4)          // Y2 | X1-X0
        xFXCH_st   (rST1)                           // X1-X0 | Y2
        xFLD_rm32  (rmIND8(rEAX)) xOFS8(4)          // Y0 | X1-X0 | Y2
        xFXCH_st   (rST1)                           // X1-X0 | Y0 | Y2
        xFLD_rm32  (rmIND(rECX))                    // X2 | X1-X0 | Y0 | Y2
        xFXCH_st   (rST3)                           // Y2 | X1-X0 | Y0 | X2
        xFLD_rm32  (rmIND(rEAX))                    // X0 | Y2 | X1-X0 | Y0 | X2
        xFXCH_st   (rST3)                           // Y0 | Y2 | X1-X0 | X0 | X2
        xFSUBP_st  (rST1)                           // Y2-Y0 | X1-X0 | X0 | X2
        xFXCH_st   (rST3)                           // X2 | X1-X0 | X0 | Y2-Y0
        xFLD_rm32  (rmIND8(rEBX)) xOFS8(4)          // Y1 | X2 | X1-X0 | X0 | Y2-Y0
        xFXCH_st   (rST3)                           // X0 | X2 | X1-X0 | Y1 | Y2-Y0
        xFSUBP_st  (rST1)                           // X2-X0 | X1-X0 | Y1 | Y2-Y0
        xFXCH_st   (rST3)                           // Y2-Y0 | X1-X0 | Y1 | X2-X0
        xFLD_rm32  (rmIND8(rEAX)) xOFS8(4)          // Y0 | Y2-Y0 | X1-X0 | Y1 | X2-X0
        xFXCH_st   (rST2)                           // X1-X0 | Y2-Y0 | Y0 | Y1 | X2-X0
        xFMULP_st  (rST1)                           // (X1-X0)(Y2-Y0) | Y0 | Y1 | X2-X0
        xFXCH_st   (rST1)                           // Y0 | (X1-X0)(Y2-Y0) | Y1 | X2-X0
        xFSUBP_st  (rST2)                           // (X1-X0)(Y2-Y0) | Y1-Y0 | X2-X0
        xFXCH_st   (rST2)                           // X2-X0 | Y1-Y0 | (X1-X0)(Y2-Y0)
        xFMULP_st  (rST1)                           // (X2-X0)(Y1-Y0) | (X1-X0)(Y2-Y0)
        xFSUBP_st  (rST1)                           // (X1-X0)(Y2-Y0)-(X2-X0)(Y1-Y0)
        xFSTP_i32  (mMEM32(global.dwTemp))
        xMOV_r_i32       (rEDX,mMEM32(global.dwTemp))
        xAND_rm_imm      (rmREG(rEDX),0x80000000)
        xCMP_r_i32       (rEDX,mMEM32(global.kelvin.dwCullValue))
    }
}

/*****************************************************************************
 *****************************************************************************
 *** inline triangle lists ***************************************************
 *****************************************************************************
 *****************************************************************************/
DWORD nvKelvinILCompile_inline_tri_list
(
    PNVD3DCONTEXT pContext,
    DWORD         dwFlags
)
{
    //
    // get loop constants
    //
    BOOL   bLegacyStrides = dwFlags & KELVIN_ILFLAG_LEGACY;
    BOOL   bIsIndexed     = (dwFlags & KELVIN_ILMASK_LOOPTYPE) == KELVIN_ILFLAG_IX_INL_TRI_LIST;

    //
    // align entry point
    //
    while (ilcCount & 31) { xINT3 }
    DWORD lEntry;
    xLABEL (lEntry);

    //
    // setup stack frame
    //
    xPUSH_r     (rEBP)
    xPUSH_r     (rEBX)
    xPUSH_r     (rESI)
    xPUSH_r     (rEDI)

    //
    // verify that we are using the correct inner loop - debug only
    //
#ifdef DEBUG
    DWORD ld1,ld2;
    xLABEL      (ld1)
    xJMP        (0)
    xLABEL      (ld2)
    xINT3

#define CHECK(a,x)                  \
{                                   \
    xMOV_rm_imm (rmREG(rEBX),a)     \
    xMOV_rm_imm (rmREG(rEAX),x)     \
    xCMP_r_i32  (rEAX,mMEM32(x))    \
    xJNZ32      (ld2)               \
}
#define CHECK2(a,x,y,t)             \
{                                   \
    xMOV_r_i32  (rEDX,mMEM32(global.kelvin.x))    \
    xMOV_rm_imm (rmREG(rEBX),a)     \
    xMOV_rm_imm (rmREG(rEAX),x->y)   \
    xCMP_r_rm   (rEAX,rmIND32(rEDX)) xOFS32(OFFSETOF(t,y)) \
    xJNZ32      (ld2)               \
}

    xTARGET_jmp (ld1)

/*
    CHECK (0x00000000,fvfData.dwVertexStride)

    CHECK (0x00010000,fvfData.dwVertexType)

    CHECK (0x00020000,fvfData.dwUVCount[0])
    CHECK (0x00020001,fvfData.dwUVCount[1])
    CHECK (0x00020002,fvfData.dwUVCount[2])
    CHECK (0x00020003,fvfData.dwUVCount[3])
    CHECK (0x00020004,fvfData.dwUVCount[4])
    CHECK (0x00020005,fvfData.dwUVCount[5])
    CHECK (0x00020006,fvfData.dwUVCount[6])
    CHECK (0x00020007,fvfData.dwUVCount[7])

    CHECK (0x00030000,fvfData.dwUVOffset[0])
    CHECK (0x00030001,fvfData.dwUVOffset[1])
    CHECK (0x00030002,fvfData.dwUVOffset[2])
    CHECK (0x00030003,fvfData.dwUVOffset[3])
    CHECK (0x00030004,fvfData.dwUVOffset[4])
    CHECK (0x00030005,fvfData.dwUVOffset[5])
    CHECK (0x00030006,fvfData.dwUVOffset[6])
    CHECK (0x00030007,fvfData.dwUVOffset[7])
*/

    //  - pContext->hwState.dwStateFlags & KELVIN_MASK_INNERLOOPUNIQUENESS
    xMOV_r_i32  (rEDX,mMEM32(global.kelvin.pContext))
    xMOV_rm_imm (rmREG(rEBX),0x00040000)
    xMOV_r_rm   (rEAX,rmIND32(rEDX)) xOFS32(OFFSETOF(NVD3DCONTEXT, hwState.dwStateFlags))
    xAND_rm_imm (rmREG(rEAX),KELVIN_MASK_INNERLOOPUNIQUENESS)
    xCMP_rm_imm (rmREG(rEAX),pContext->hwState.dwStateFlags & KELVIN_MASK_INNERLOOPUNIQUENESS)
    xJNZ32      (ld2)

    if (pContext->hwState.dwStateFlags & KELVIN_FLAG_USERTEXCOORDSNEEDED(0))
    {
        CHECK2 (0x00050000,pContext,hwState.dwTexUnitToTexStageMapping[0],NVD3DCONTEXT)
    }
    if (pContext->hwState.dwStateFlags & KELVIN_FLAG_USERTEXCOORDSNEEDED(1))
    {
        CHECK2 (0x00050001,pContext,hwState.dwTexUnitToTexStageMapping[1],NVD3DCONTEXT)
    }
#endif

    //
    // setup push buffer
    //
    xMOV_r_i32  (rEDX,mMEM32(pDriverData))
    xMOV_r_rm   (rEDI,rmIND32(rEDX)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))

    //
    // calc how many verts to copy into EBX
    //
    xMOV_r_i32  (rEBX,mMEM32(global.kelvin.dwPrimCount))
    ILCCompile_mul (rEBX,bLegacyStrides ? 4 : 3);

    //
    // setup prefetcher (EBX has # of vertices to copy in total)
    //
    if (bIsIndexed)
    {
        xMOV_r_i32  (rEAX,mMEM32(global.kelvin.pIndices))
         xLEA_r_rm   (rECX,rmSIB) xSIB(rEAX,rEBX,x2)
        xMOV_i32_r  (mMEM32(global.kelvin.dwPrefetchBase),rEAX)
         xMOV_i32_r  (mMEM32(global.kelvin.dwPrefetchMax),rECX)
    }
    else
    {
        xMOV_r_i32  (rEAX,mMEM32(global.kelvin.pVertices))
         xMOV_r_rm   (rECX,rmREG(rEBX))
         ILCCompile_mul (rECX,global.kelvin.dwVertexStride);
         xADD_r_rm   (rECX,rmREG(rEAX))
        xMOV_i32_r  (mMEM32(global.kelvin.dwPrefetchBase),rEAX)
         xMOV_i32_r  (mMEM32(global.kelvin.dwPrefetchMax),rECX)
    }

    //
    // start primitive
    //
    xMOV_rm_imm (rmREG(rEAX),((sizeSetNv20KelvinBeginEndMthdCnt << 2) << 16) | ((NV_DD_KELVIN) << 13) | NV097_SET_BEGIN_END);
    xMOV_rm_imm (rmREG(rECX),NV097_SET_BEGIN_END_OP_TRIANGLES)
    xMOV_rm_r   (rmIND(rEDI),rEAX)
    xMOV_rm_r   (rmIND8(rEDI),rECX) xOFS8(4)
    xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(8)

    //
    // load prim count into EBX
    //
    xMOV_r_i32  (rEBX,mMEM32(global.kelvin.dwPrimCount))

    //
    // start copying
    //   for this loop EDI points to PUT and EBX has the amount of prims to go
    //
    DWORD labelEarlyExit;
    DWORD labelLoop;
    xLABEL  (labelLoop)
    {
        xPUSH_r     (rEBX)

        //
        // prefetch
        //
        nvKelvinILCompile_prefetch (bIsIndexed,bLegacyStrides);

        //
        // do two triangles at a time
        //
        for (DWORD dwTriNum = 0; dwTriNum < 2; dwTriNum++)
        {
            if (bIsIndexed)
            {
                //
                // compute vertices
                //
                xMOV_r_i32  (rEDX,mMEM32(global.kelvin.pIndices))
                xXOR_r_rm   (rECX,rmREG(rECX))
                xLEA_r_rm   (rEAX,rmIND8(rEDX)) xOFS8 (bLegacyStrides ? 8 : 6)
                xMOV_r_rm   (rEBX,rmIND(rEDX))
           x16r xMOV_r_rm   (rCX,rmIND8(rEDX)) xOFS8(4)
                xMOV_i32_r  (mMEM32(global.kelvin.pIndices),rEAX)
                xMOV_r_rm   (rEAX,rmREG(rEBX))
                xSHR_rm_imm8(rmREG(rEBX),16)
                xAND_rm_imm (rmREG(rEAX),0xffff)
                // convert indices to vertex address with limit checking (on NT)
                ILCCompile_mul (rECX,global.kelvin.dwVertexStride);
                ILCCompile_mul (rEBX,global.kelvin.dwVertexStride);
                ILCCompile_mul (rEAX,global.kelvin.dwVertexStride);
                nvKelvinILCompile_limit (rECX,rEDX);
                nvKelvinILCompile_limit (rEBX,rEDX);
                nvKelvinILCompile_limit (rEAX,rEDX);
                xADD_r_i32  (rEBX,mMEM32(global.kelvin.pVertices))
                xADD_r_i32  (rEAX,mMEM32(global.kelvin.pVertices))
                xADD_r_i32  (rECX,mMEM32(global.kelvin.pVertices))
            }

            //
            // do cull check
            //      indexed - eax,ebx and ecx has vertex addresses
            //      ordered - pVertices has vertex0, rest follow in dwVertexStride increments
            DWORD labelCull;
            if (!(dwFlags & KELVIN_ILFLAG_NOCULL))
            {
                nvKelvinILCompile_cullcheck (bIsIndexed);
                xLABEL      (labelCull)
                xJZ32       (0)
            }

            //
            // copy vertices
            //
            if (bIsIndexed)
            {
                xPUSH_r     (rECX)
                xPUSH_r     (rEBX)
                xMOV_r_rm   (rESI,rmREG(rEAX))
                nvKelvinILCompile_copyVertex (pContext,dwFlags);
                xPOP_r      (rESI)
                nvKelvinILCompile_copyVertex (pContext,dwFlags);
                xPOP_r      (rESI)
                nvKelvinILCompile_copyVertex (pContext,dwFlags);
            }
            else
            {
                xMOV_r_i32  (rESI,mMEM32(global.kelvin.pVertices))
                nvKelvinILCompile_copyVertex (pContext,dwFlags);
                xADD_rm_imm (rmREG(rESI),global.kelvin.dwVertexStride)
                nvKelvinILCompile_copyVertex (pContext,dwFlags);
                xADD_rm_imm (rmREG(rESI),global.kelvin.dwVertexStride)
                nvKelvinILCompile_copyVertex (pContext,dwFlags);
            }

            if (!(dwFlags & KELVIN_ILFLAG_NOCULL))
            {
                xTARGET_b32 (labelCull)
            }

            // update instrumentation count (include culled tris so we have a normalized result)
#ifdef INSTRUMENT_INNER_LOOPS
            {
                xMOV_rm_imm (rmREG(rEAX),fvfData.dwVertexStride * 3)
                xADD_i32_r  (mMEM32(global.dwBytesCopied),rEAX)
            }
#endif

            //
            // next triangle
            //
            if (bIsIndexed)
            {
                // nothing to do here
            }
            else
            {
                xMOV_r_i32  (rEAX,mMEM32(global.kelvin.pVertices))
                xADD_rm_imm (rmREG(rEAX),global.kelvin.dwVertexStride * 3)
                xMOV_i32_r  (mMEM32(global.kelvin.pVertices),rEAX)
            }

            //
            // done already? (odd # of triangles)
            //
            if (dwTriNum == 0)
            {
                xPOP_r  (rEBX)
                xDEC_rm (rmREG(rEBX))
                xLABEL  (labelEarlyExit)
                xJZ32   (0)
                xPUSH_r (rEBX)
            }
        }

/*
        //
        // copy vertex
        //
        if (bIsIndexed)
        {
            // get index
            xMOV_r_i32  (rEDX,mMEM32(global.celsius.pIndices))
            xXOR_r_rm   (rESI,rmREG(rESI))
       x16r xMOV_r_rm   (rSI,rmIND(rEDX))
            xLEA_r_rm   (rEDX,rmIND8(rEDX)) xOFS8(2)
            if (bLegacyStrides)
            {

// do in setup ....
          if (bLegacyStrides)
        {
            xMOV_r_i32  (rEAX,mMEM32(global.celsius.pIndices))
            xMOV_i32_r  (mMEM32(global.celsius.pIndexBase),rEAX)
        }


                xMOV_r_rm   (rEAX,rmREG(rEDX))
                xSUB_r_i32  (rEAX,mMEM32(global.celsius.pIndexBase))
                xAND_rm_imm (rmREG(rEAX),6)
                xXOR_r_rm   (rECX,rmREG(rECX))
                xCMP_rm_imm (rmREG(rEAX),6)
                xSETNZ_rm8  (rmREG(rCL))
                xDEC_rm     (rmREG(rECX))
                xAND_rm_imm (rmREG(rECX),2)
                xADD_r_rm   (rEDX,rmREG(rECX))
            }
            xMOV_i32_r  (mMEM32(global.celsius.pIndices),rEDX)
            // compute vertex offset
            ILCCompile_mul (rESI,fvfData.dwVertexStride);
            // range limit
            xXOR_r_rm   (rECX,rmREG(rECX))
            xCMP_r_i32  (rESI,mMEM32(global.dwMaxVertexOffset))
            xSETAE_rm8  (rmREG(rCL))
            xDEC_rm     (rmREG(rECX))
            xAND_r_rm   (rESI,rmREG(rECX))
            // compute vertex address
            xADD_r_i32  (rESI,mMEM32(global.celsius.pVertices))
        }
        else
        {
            // get vertex & increment
            xMOV_r_i32  (rESI,mMEM32(global.celsius.pVertices))
            xLEA_r_rm   (rEAX,rmIND32(rESI)) xOFS32(fvfData.dwVertexStride)
            xMOV_i32_r  (mMEM32(global.celsius.pVertices),rEAX)
        }

        // copy vertex (from ESI to EDI)
        nvCelsiusILCompile_copyVertex (pContext);
*/

        // check for pusher space
        DWORD labelSpace;
        xMOV_r_i32  (rESI,mMEM32(pDriverData))
        xCMP_r_rm   (rEDI,rmIND32(rESI)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwThreshold))
        xLABEL      (labelSpace)
        xJL         (0)
        {
            xMOV_rm_r   (rmIND32(rESI),rEDI) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
            xMOV_rm_imm (rmREG(rEAX),(DWORD)nvKelvinDispatchGetPusherSpace)
            xCALL_rm    (rmREG(rEAX))
            xMOV_r_rm   (rEDI,rmIND32(rESI)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
        }
        xTARGET_b8  (labelSpace)

        // next
        xPOP_r  (rEBX)
        xDEC_rm (rmREG(rEBX))
    }
    xJNZ32      (labelLoop)
    xTARGET_b32 (labelEarlyExit)

    //
    // end primitive
    //
    xMOV_rm_imm (rmREG(rEAX),((sizeSetNv20KelvinBeginEndMthdCnt << 2) << 16) | ((NV_DD_KELVIN) << 13) | NV097_SET_BEGIN_END);
    xMOV_rm_imm (rmREG(rECX),NV097_SET_BEGIN_END_OP_END)
    xMOV_rm_r   (rmIND(rEDI),rEAX)
    xMOV_rm_r   (rmIND8(rEDI),rECX) xOFS8(4)
    xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(8)

    //
    // save off push buffer
    //
    xMOV_r_i32  (rEDX,mMEM32(pDriverData))
#ifndef NV_NULL_HW_DRIVER
    xMOV_rm_r   (rmIND32(rEDX),rEDI) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
#endif

    //
    // done
    //
    xPOP_r      (rEDI)
    xPOP_r      (rESI)
    xPOP_r      (rEBX)
    xPOP_r      (rEBP)
    xRET
    return lEntry;
}

#endif  //KELVIN_ILC
#endif  // NVARCH == 0x10
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\kelvin\src\nvKelvinProgram.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvKelvinProgram.cpp
//      Routines for management of Kelvin programs
//
// **************************************************************************
//
//  History:
//      Craig Duttweiler        23May00         NV20 development
//
// **************************************************************************
#include "nvprecomp.h"

#if (NVARCH >= 0x20)

extern DWORD dwCelsiusMethodDispatch[11][16][2];

//---------------------------------------------------------------------------

long getout (char *s)
{
    long i=0,add;

    if (strstr(s,"HPOS")) add =  0;
    else if (strstr(s,"COL0")) add =  3;
    else if (strstr(s,"COL1")) add =  4;
    else if (strstr(s,"BFC0")) add =  7;
    else if (strstr(s,"BFC1")) add =  8;
    else if (strstr(s,"FOGC")) add =  5;
    else if (strstr(s,"PSIZ")) add =  6;
    else if (strstr(s,"TEX0")) add =  9;
    else if (strstr(s,"TEX1")) add = 10;
    else if (strstr(s,"TEX2")) add = 11;
    else if (strstr(s,"TEX3")) add = 12;
    else if (strstr(s,"TEX4")) add = 13;
    else if (strstr(s,"TEX5")) add = 14;
    else if (strstr(s,"TEX6")) add = 15;
    else if (strstr(s,"TEX7")) add = 15; /* dev null it */
    else {
        while (s[i] < '0' || s[i] > '9')
            i++;

        add = 0;
        while (s[i] >= '0' && s[i] <= '9') {
            add *= 10;
            add += s[i] - '0';
            i++;
        }
    }

    return(add);
}

//---------------------------------------------------------------------------

long readit
(
    char *s,
    long dest
)
{
    long msk,add,i,neg,mux,indexed,output;
    long xmsk,ymsk,zmsk,wmsk,hold0,hold1,j;

    indexed = 0;
    output = 0;

    if (dest) {
        if (strstr(s,"c[")) {
            mux = MX_C;
            if (strstr(s,"A0"))
                assert(0);
        }
        else if (strstr(s,"o[")) {
            mux = MX_O;
            output = 1;
            add = getout(s);
            if (strstr(s,"A0"))
                assert(0);
        }
        else if (strstr(s,"R")) {
            mux = MX_R;
        }
        else if (strstr(s,"v[")) {
            assert(0);
        }
        else {
            return(0);
        }
    }
    else {
        if (strstr(s,"c[")) {
            mux = MX_C;
            if (strstr(s,"A0"))
                indexed = IDX_MASK;
        }
        else if (strstr(s,"v[")) {
            mux = MX_V;
            if (strstr(s,"A0"))
                assert(0);
        }
        else if (strstr(s,"R")) {
            mux = MX_R;
        }
        else if (strstr(s,"o[")) {
            assert(0);
        }
        else {
            return(0);
        }
    }

    neg = 0;
    if (s[0] == '-')
        neg = SGN_MASK;

    i = 0;
    if (output) {
        while (s[i] != ']')
            i++;
    }
    else {
        while (s[i] < '0' || s[i] > '9')
            i++;

        if (indexed && s[i-1] == 'A' && s[i] == '0') {
            i++;
            while (s[i] < '0' || s[i] > '9')
                i++;
        }

        /* else address */
        add = 0;
        while (s[i] >= '0' && s[i] <= '9') {
            add *= 10;
            add += s[i] - '0';
            i++;
        }
    }
    if (add < 0 || add > 511)
        assert(0);
    add &= 0xff;

    hold0 = hold1 = 0;
    for (j=i; s[j] != '\0'; j++) {
        if (s[j] == '.') hold0 = j;
        if (s[j] == ']') hold1 = j+1;
    }
    i = (hold1 > hold0) ?  hold1 : hold0;

    /* write mask */
    if (dest) {
        msk = 15;
        if (s[i++] == '.') {
            msk = 0;
            while (s[i]=='x' || s[i]=='y' || s[i]=='z' || s[i]=='w') {
                if (s[i]=='x') {
                    if (msk & 0xf)
                        assert(0);
                    msk |= 8;
                }
                if (s[i]=='y') {
                    if (msk & 0x7)
                        assert(0);
                    msk |= 4;
                }
                if (s[i]=='z') {
                    if (msk & 0x3)
                        assert(0);
                    msk |= 2;
                }
                if (s[i]=='w') {
                    if (msk & 0x1)
                        assert(0);
                    msk |= 1;
                }
                i++;
            }
        }
    }

    /* swizzle mask */
    else {
        xmsk = 0;
        ymsk = 1;
        zmsk = 2;
        wmsk = 3;
        if (s[i++] == '.') {
            if (s[i] == 'x' && (s[i+1] < 'w' || s[i+1] > 'z'))
                xmsk = ymsk = zmsk = wmsk = CSW_X;
            else if (s[i] == 'y' && (s[i+1] < 'w' || s[i+1] > 'z'))
                xmsk = ymsk = zmsk = wmsk = CSW_Y;
            else if (s[i] == 'z' && (s[i+1] < 'w' || s[i+1] > 'z'))
                xmsk = ymsk = zmsk = wmsk = CSW_Z;
            else if (s[i] == 'w' && (s[i+1] < 'w' || s[i+1] > 'z'))
                xmsk = ymsk = zmsk = wmsk = CSW_W;
            else {
                switch (s[i++]) {
                    case 'x': xmsk = CSW_X; break;
                    case 'y': xmsk = CSW_Y; break;
                    case 'z': xmsk = CSW_Z; break;
                    case 'w': xmsk = CSW_W; break;
                    default: assert(0);
                }
                switch (s[i++]) {
                    case 'x': ymsk = CSW_X; break;
                    case 'y': ymsk = CSW_Y; break;
                    case 'z': ymsk = CSW_Z; break;
                    case 'w': ymsk = CSW_W; break;
                    default: assert(0);
                }
                switch (s[i++]) {
                    case 'x': zmsk = CSW_X; break;
                    case 'y': zmsk = CSW_Y; break;
                    case 'z': zmsk = CSW_Z; break;
                    case 'w': zmsk = CSW_W; break;
                    default: assert(0);
                }
                switch (s[i++]) {
                    case 'x': wmsk = CSW_X; break;
                    case 'y': wmsk = CSW_Y; break;
                    case 'z': wmsk = CSW_Z; break;
                    case 'w': wmsk = CSW_W; break;
                    default: assert(0);
                }
            }
        }

        msk = (wmsk<<6) | (zmsk<<4) | (ymsk<<2) | (xmsk<<0);
    }

    return(indexed | neg | (msk<<12) | (mux<<8) | add);
}

//---------------------------------------------------------------------------

void opcode
(
    PKELVIN_MICRO_PROGRAM pProgram,
    char *s1,
    char *s2
)
{
    long i,j,iflag,mflag,flog,loop,d1,d2,pp[10],pm,mux;
    long neg,msk,add,dubl,faddr;
    long count,start;
    char a[256];
    t_CheopsUcode *ucode;

    ucode = &(pProgram->ucode[pProgram->length]);

    // default fields
    ucode->mac = NV_IGRAPH_XF_V_NOP;
    ucode->ilu = NV_IGRAPH_XF_S_NOP;
    ucode->ca  = 0;
    ucode->va  = 0;
    ucode->ane = 0;
    ucode->axs = CSW_X;
    ucode->ays = CSW_Y;
    ucode->azs = CSW_Z;
    ucode->aws = CSW_W;
    ucode->amx = MX_R;
    ucode->arr = 0;
    ucode->bne = 0;
    ucode->bxs = CSW_X;
    ucode->bys = CSW_Y;
    ucode->bzs = CSW_Z;
    ucode->bws = CSW_W;
    ucode->bmx = MX_R;
    ucode->brr = 0;
    ucode->cne = 0;
    ucode->cxs = CSW_X;
    ucode->cys = CSW_Y;
    ucode->czs = CSW_Z;
    ucode->cws = CSW_W;
    ucode->cmx = MX_R;
    ucode->crr = 0;
    ucode->rw  = 7;
    ucode->rwm = 0;
    ucode->oc  = 0x1ff;
    ucode->om  = OM_MAC;
    ucode->eos = 0;
    ucode->cin = 0;
    ucode->swm = 0;

    for (i=0; i<10; i++)
        pp[i] = 0;

    /********************************/
    /* one or two instructions      */
    /********************************/
    dubl = 0;
    if (s1[0] != '\0' && s2[0] != '\0')
        dubl = 1;

    /********************************/
    /* s1 processing                */
    /********************************/
    if (s1[0] != '\0')
        for (pm=0,i=3,loop=0; loop<5; loop++) {
            flog = j = 0;
            while (s1[i] != ',' && s1[i] != '\0') {
                if (s1[i] == '{')
                    pm = DST_MASK;
                if (s1[i] == '}') {
                    flog = DST_MASK;
                    pm = 0;
                }
                if (s1[i] == '{' || s1[i] == '}')
                    i++;
                else
                    a[j++] = s1[i++];

                if (j >= 200)
                    assert(0);
            }
            a[j] = '\0';

            d1 = readit(a,(pm?1:0)|(loop==0)|(flog?1:0));

            if (d1 != 0) {
                d1 |= pm | flog;
                if (loop == 0)
                    d1 |= DST_MASK;
            }

            pp[loop] = d1;
            if (s1[i] != '\0')
                i++;
        }

    /********************************/
    /* s2 processing                */
    /********************************/
    if (s2[0] != '\0')
        for (pm=0,i=3,loop=6; loop<10; loop++) {
            flog = j = 0;
            while (s2[i] != ',' && s2[i] != '\0') {
                if (s2[i] == '{')
                    pm = DST_MASK;
                if (s2[i] == '}') {
                    flog = DST_MASK;
                    pm = 0;
                }
                if (s2[i] == '{' || s2[i] == '}')
                    i++;
                else
                    a[j++] = s2[i++];

                if (j >= 200)
                    assert(0);
            }
            a[j] = '\0';

            d2 = readit(a,(pm?1:0)|(loop==6)|(flog?1:0));

            if (d2 != 0) {
                d2 |= pm | flog;
                if (loop == 6)
                    d2 |= DST_MASK;
            }

            pp[loop] = d2;
            if (s2[i] != '\0')
                i++;
        }

    /*** sign check ***/
    for (i=0; i<10; i++)
        if ((pp[i]&DST_MASK) && (pp[i]&SGN_MASK))
            assert(0);

        /********************************/
        /* mac/ilu processing           */
        /********************************/
    mflag = 0;
    iflag = 0;
    if (strstr(s1,"NOP")) {
        SET_MAC(ucode,NV_IGRAPH_XF_V_NOP);
    }
    else if (strstr(s1,"MOV")) {
        SET_MAC(ucode,NV_IGRAPH_XF_V_MOV); mflag = 1;
    }
    else if (strstr(s1,"RCP")) {
        SET_ILU(ucode,NV_IGRAPH_XF_S_RCP); iflag = 1;
    }
    else if (strstr(s1,"RCC")) {
        SET_ILU(ucode,NV_IGRAPH_XF_S_RCC); iflag = 1;
    }
    else if (strstr(s1,"RSQ")) {
        SET_ILU(ucode,NV_IGRAPH_XF_S_RSQ); iflag = 1;
    }
    else if (strstr(s1,"MUL")) {
        SET_MAC(ucode,NV_IGRAPH_XF_V_MUL); mflag = 1;
    }
    else if (strstr(s1,"ADD")) {
        SET_MAC(ucode,NV_IGRAPH_XF_V_ADD); mflag = 1;
    }
    else if (strstr(s1,"MAD")) {
        SET_MAC(ucode,NV_IGRAPH_XF_V_MAD); mflag = 1;
    }
    else if (strstr(s1,"DP3")) {
        SET_MAC(ucode,NV_IGRAPH_XF_V_DP3); mflag = 1;
    }
    else if (strstr(s1,"DPH")) {
        SET_MAC(ucode,NV_IGRAPH_XF_V_DPH); mflag = 1;
    }
    else if (strstr(s1,"DP4")) {
        SET_MAC(ucode,NV_IGRAPH_XF_V_DP4); mflag = 1;
    }
    else if (strstr(s1,"DST")) {
        SET_MAC(ucode,NV_IGRAPH_XF_V_DST); mflag = 1;
    }
    else if (strstr(s1,"MIN")) {
        SET_MAC(ucode,NV_IGRAPH_XF_V_MIN); mflag = 1;
    }
    else if (strstr(s1,"MAX")) {
        SET_MAC(ucode,NV_IGRAPH_XF_V_MAX); mflag = 1;
    }
    else if (strstr(s1,"SLT")) {
        SET_MAC(ucode,NV_IGRAPH_XF_V_SLT); mflag = 1;
    }
    else if (strstr(s1,"SGE")) {
        SET_MAC(ucode,NV_IGRAPH_XF_V_SGE); mflag = 1;
    }
    else if (strstr(s1,"ARL")) {
        SET_MAC(ucode,NV_IGRAPH_XF_V_ARL); mflag = 1;
    }
    else if (strstr(s1,"EXP")) {
        SET_ILU(ucode,NV_IGRAPH_XF_S_EXP); iflag = 1;
    }
    else if (strstr(s1,"LOG")) {
        SET_ILU(ucode,NV_IGRAPH_XF_S_LOG); iflag = 1;
    }
    else if (strstr(s1,"LIT")) {
        SET_ILU(ucode,NV_IGRAPH_XF_S_LIT); iflag = 1;
    }
    else if (strstr(s1,"IMV")) {
        SET_ILU(ucode,NV_IGRAPH_XF_S_MOV); iflag = 1;
    }
    else assert(0);

    if (iflag && dubl)
        assert(0);

    if (s2[0] != '\0') {
        if (strstr(s2,"NOP")) {
            SET_ILU(ucode,NV_IGRAPH_XF_S_NOP); iflag =1;
        }
        else if (strstr(s2,"RCP")) {
            SET_ILU(ucode,NV_IGRAPH_XF_S_RCP); iflag =1;
        }
        else if (strstr(s2,"RCC")) {
            SET_ILU(ucode,NV_IGRAPH_XF_S_RCC); iflag =1;
        }
        else if (strstr(s2,"RSQ")) {
            SET_ILU(ucode,NV_IGRAPH_XF_S_RSQ); iflag =1;
        }
        else if (strstr(s2,"EXP")) {
            SET_ILU(ucode,NV_IGRAPH_XF_S_EXP); iflag =1;
        }
        else if (strstr(s2,"LOG")) {
            SET_ILU(ucode,NV_IGRAPH_XF_S_LOG); iflag =1;
        }
        else if (strstr(s2,"LIT")) {
            SET_ILU(ucode,NV_IGRAPH_XF_S_LIT); iflag =1;
        }
        else if (strstr(s2,"IMV")) {
            SET_ILU(ucode,NV_IGRAPH_XF_S_MOV); iflag =1;
        }
        else assert(0);
    }

    // VA
    for (flog=i=0; i<10; i++) {
        add = (pp[i]>> 0) & 0xff;

        if (((pp[i] & MUX_MASK)>>8) == MX_V) {
            if (pp[i] & DST_MASK)
                assert(0);
            if (flog && add != faddr)
                assert(0);

            SET_VA(ucode,add);
            flog = 1;
            faddr = add;
        }
    }

    /*** CA,CIN ***/
    for (flog=i=0; i<10; i++) {
        add = pp[i] & ADD_MASK;

        if (((pp[i] & MUX_MASK)>>8) == MX_C && !(pp[i] & DST_MASK)) {
            if (flog && add != faddr)
                assert(0);

            SET_CA(ucode,add);
            if (pp[i]&IDX_MASK)
                SET_CIN(ucode,1);
            flog = 1;
            faddr = add;
        }
    }

    /*** AMUX ***/
    if (mflag) {
        for (count=i=0; i<6; i++) {
            add =  pp[i] & ADD_MASK;
            mux = (pp[i] & MUX_MASK)>>8;
            msk = (pp[i] & SWZ_MASK)>>12;
            neg = (pp[i] & SGN_MASK) ? 1 : 0;

            if (pp[i] && !(pp[i]&DST_MASK)) {
                count++;

                if (count == 1) {
                    SET_AMX(ucode,mux);
                    SET_AXS(ucode,(msk>>0)&3);
                    SET_AYS(ucode,(msk>>2)&3);
                    SET_AZS(ucode,(msk>>4)&3);
                    SET_AWS(ucode,(msk>>6)&3);
                    SET_ANE(ucode,neg);
                    if (mux == MX_R)
                        SET_ARR(ucode,add);
                }
            }
        }
    }

    /*** BMX, CMX ***/
    if (mflag) {
        for (count=0,i=0; i<6; i++) {
            add =  pp[i] & ADD_MASK;
            mux = (pp[i] & MUX_MASK)>>8;
            msk = (pp[i] & SWZ_MASK)>>12;
            neg = (pp[i] & SGN_MASK) ? 1 : 0;

            if (pp[i] && !(pp[i]&DST_MASK)) {
                count++;

                if (count == 2) {
                    if (strstr(s1,"MUL") || strstr(s1,"MAD") || strstr(s1,"DP3") || strstr(s1,"DPH") || strstr(s1,"DP4") ||
                        strstr(s1,"DST") || strstr(s1,"MIN") || strstr(s1,"MAX") || strstr(s1,"SLT") || strstr(s1,"SGE")) {
                        SET_BMX(ucode,mux);
                        SET_BXS(ucode,(msk>>0)&3);
                        SET_BYS(ucode,(msk>>2)&3);
                        SET_BZS(ucode,(msk>>4)&3);
                        SET_BWS(ucode,(msk>>6)&3);
                        SET_BNE(ucode,neg);
                        if (mux == MX_R)
                            SET_BRR(ucode,add);
                    }
                }

                if ((count == 2 && strstr(s1,"ADD")) || (count == 3 && (strstr(s1,"MAD")))) {
                    SET_CMX(ucode,mux);
                    SET_CXS(ucode,(msk>>0)&3);
                    SET_CYS(ucode,(msk>>2)&3);
                    SET_CZS(ucode,(msk>>4)&3);
                    SET_CWS(ucode,(msk>>6)&3);
                    SET_CNE(ucode,neg);
                    if (mux == MX_R)
                        SET_CRR(ucode,add);
                }
            }
        }
    }

    /*** CMX ***/
    if (iflag) {
        start = (dubl ? 6 : 0);

        for (i=start; i<10; i++) {
            add =  pp[i] & ADD_MASK;
            mux = (pp[i] & MUX_MASK)>>8;
            msk = (pp[i] & SWZ_MASK)>>12;
            neg = (pp[i] & SGN_MASK) ? 1 : 0;

            if (pp[i] && !(pp[i]&DST_MASK)) {
                SET_CMX(ucode,mux);
                SET_CXS(ucode,(msk>>0)&3);
                SET_CYS(ucode,(msk>>2)&3);
                SET_CZS(ucode,(msk>>4)&3);
                SET_CWS(ucode,(msk>>6)&3);
                SET_CNE(ucode,neg);
                if (mux == MX_R)
                    SET_CRR(ucode,add);

                break;
            }
        }
    }

    /*** RW, RWM, SWM ***/
    for (count=i=0; i<10; i++) {
        add =  pp[i] & ADD_MASK;
        mux = (pp[i] & MUX_MASK)>>8;
        msk = (pp[i] & SWZ_MASK)>>12;

        if (pp[i] && (pp[i]&DST_MASK) && (mux == MX_R)) {
            if (i<6) {
                if (count > 1)
                    assert(0);
                count++;

                SET_RW(ucode,add);

                if (mflag)
                    SET_RWM(ucode,msk);
                else if (iflag)
                    SET_SWM(ucode,msk);
                else
                    assert(0);
            }
            else {
                if (!dubl)
                    assert(0);
                if (add != 1)
                    assert(0);

                SET_SWM(ucode,msk);
            }
        }
    }

    /*** OC, OM, OWM ***/
    for (count=i=0; i<10; i++) {
        mux = (pp[i] & MUX_MASK)>>8;

        if ((pp[i]&DST_MASK) && (mux != MX_R)) {
            add =  pp[i] & ADD_MASK;
            msk = (pp[i] & SWZ_MASK)>>12;

            if (count)
                assert(0);

            SET_OWM(ucode,msk);
            if (i < 6 && mflag)
                SET_OM(ucode,OM_MAC);
            else
                SET_OM(ucode,OM_ILU);

            if (mux == MX_O) {
                count = 1;
                pProgram->outwri = 1;
                SET_OC(ucode,(0x100|add));
            }
            else if (mux == MX_C) {
                count = 1;
                pProgram->ctxwri = 1;
                SET_OC(ucode,add);
            }
            else
                assert(0);
        }
    }

    (pProgram->length)++;
}

//---------------------------------------------------------------------------

void nvKelvinInitProgram
(
    PKELVIN_MICRO_PROGRAM pProgram
)
{
    pProgram->ctxwri = 0;
    pProgram->outwri = 0;
    pProgram->length = 0;
}

//---------------------------------------------------------------------------

void nvKelvinParseProgram
(
    PKELVIN_MICRO_PROGRAM pProgram,
    // GLenum pType,
    // GLuint nid,
    char *s
)
{
    char  t[256], u[256];
    DWORD i, j;

    // check for header %!VP1.0
    if ((s[0] != '%') ||
        (s[1] != '!') ||
        (s[2] != 'V') ||
        (s[3] != 'P') ||
        (s[4] != '1') ||
        (s[5] != '.') ||
        (s[6] != '0')) {
        nvAssert(0);
    }

    // parse program
    for (i=7; s[i]!='\0'; i++) {

        for (j=0; s[i]!=':'&&s[i]!=';'&&s[i]!='\0'; i++)
            if (s[i]!=' ' && s[i]!='\t')
                t[j++] = s[i];

        t[j++] = ';';
        t[j++] = '\0';

        u[0] = '\0';
        if (s[i] == ':') {
            i++;
            for (j=0; s[i]!=';'&&s[i]!='\0'; i++)
                if (s[i]!=' ' && s[i]!='\t')
                    u[j++] = s[i];

            u[j++] = ';';
            u[j++] = '\0';
        }

        for (; (s[i]<'A' || s[i]>'Z') && s[i]!='\0'; i++)
            ;
        i--;

        opcode (pProgram, t, u);
    }

    // set end bit
    pProgram->ucode[pProgram->length-1].eos = 1;

    if (pProgram->length > 128) {
        nvAssert(0);
    }
}

//---------------------------------------------------------------------------

void nvKelvinDownloadProgram
(
    PNVD3DCONTEXT         pContext,
    PKELVIN_MICRO_PROGRAM pProgram,
    DWORD                 dwStartAddress
)
{
    long i;
    t_CheopsUcode *ucode;

    // program load address
    pContext->hwState.kelvin.set1 (NV097_SET_TRANSFORM_PROGRAM_LOAD, dwStartAddress);

    // load program
    for (i=0; i < pProgram->length; i++) {
        ucode = &(pProgram->ucode[i]);
        pContext->hwState.kelvin.set4 (NV097_SET_TRANSFORM_PROGRAM(0),
                                       PGM_UWORDX(ucode), PGM_UWORDY(ucode),
                                       PGM_UWORDZ(ucode), PGM_UWORDW(ucode));
    }
}

//---------------------------------------------------------------------------

void nvKelvinDownloadProgram
(
    PNVD3DCONTEXT        pContext,
    VertexProgramOutput *pProgramOutput,
    DWORD                dwStartAddress
)
{
    nvAssert(pContext);
    nvAssert(pProgramOutput);

    vtxpgmInstPacked *pInst = (vtxpgmInstPacked *) pProgramOutput->residentProgram;

    // program load address
    pContext->hwState.kelvin.set1 (NV097_SET_TRANSFORM_PROGRAM_LOAD, dwStartAddress);

    // load program
    for (int i = 0; i < pProgramOutput->residentNumInstructions; i++) {
        pContext->hwState.kelvin.set4 (NV097_SET_TRANSFORM_PROGRAM(0),
                                    pInst[i].x, pInst[i].y,
                                    pInst[i].z, pInst[i].w);
    }
}

//---------------------------------------------------------------------------

// load constants for use by the user vertex program

void nvKelvinDownloadConstants
(
    PNVD3DCONTEXT pContext
)
{
    pContext->hwState.kelvin.set1 (NV097_SET_TRANSFORM_CONSTANT_LOAD, __GL_KELVIN_FIRST_USER_CONSTANT_REGISTER);
    for (DWORD i=0; i < D3DVS_CONSTREG_MAX_V1_1; i++) {
        nvAssert(pContext->pVShaderConsts);
        VSHADERREGISTER *pConst = &pContext->pVShaderConsts->vertexShaderConstants[i];
        pContext->hwState.kelvin.set4f (NV097_SET_TRANSFORM_CONSTANT(0),
                                        pConst->x, pConst->y, pConst->z, pConst->w);
    }
}

//---------------------------------------------------------------------------

// parse D3D-style vertex shader code into kelvin microcode

DWORD KELVIN_BASE_REG(DWORD type)
{
    switch (type & D3DSP_REGTYPE_MASK)
    {
        case D3DSPR_INPUT:
            return VA_0;
            break;
        case D3DSPR_RASTOUT:
            if ((type & D3DSP_REGNUM_MASK )==0) {
                return VR_0;
            } else {
                return VR_4;
            }
            break;
        case D3DSPR_ATTROUT:
            return VR_1;
            break;
        case D3DSPR_TEXCRDOUT:
            return VR_7;
            break;
        case D3DSPR_ADDR:
            return ARL;
            break;
        case D3DSPR_CONST:
            return PR_0;
            break;
        case D3DSPR_TEMP:
            return TR_0;
            break;
        default:
            return 0xDEADBEEF;
            break;
    }
}

Register_t KELVIN_ENUMERATED_REG (DWORD token)
{
    DWORD final;
    if ((token & D3DSP_REGTYPE_MASK) == D3DSPR_RASTOUT) {
        // psz, fog, pts
        if ((token & D3DSP_REGNUM_MASK) == 0) {
            final = VR_0;
        } else {
            final = VR_4;
        }
        final += (DWORD)(token & D3DSP_REGNUM_MASK);
    } else {
        // everything else
        final = KELVIN_BASE_REG(token);
        final += (DWORD)(token & D3DSP_REGNUM_MASK);
        if (final > ARL) {
            DPF("Vertex Shader register index out of range");
            nvAssert(0);
            final = 0;
        }
    }
#ifdef DEBUG
    // debug stuff
    if (final <= VA_15) {
        DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "VA_%02d", final - VA_0);
    } else if (final <= VR_14) {
        DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "VR_%02d", final - VR_0);
    } else if (final <= PR_95) {
        DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "PR_%02d", final - PR_0);
    } else if (final <= TR_15) {
        DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "TR_%02d", final - TR_0);
    } else if (final == ARL) {
        DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "ARL");
    } else {
        DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "Unknown reg %d", final);
    }
#endif
    return (Register_t)final;
}

static char dbgMaskChar[4] = { 'x', 'y', 'z', 'w' };

char getDbgScalarMask(DWORD mask)
{
    return dbgMaskChar[mask & 0x03];
}

DWORD* getDbgVectorMask(DWORD mask)
{
    static DWORD dwResult;
    dwResult = (dbgMaskChar[(mask >> 0) & 0x03] << 0)
             | (dbgMaskChar[(mask >> 2) & 0x03] << 8)
             | (dbgMaskChar[(mask >> 4) & 0x03] << 16)
             | (dbgMaskChar[(mask >> 6) & 0x03] << 24);
    return &dwResult;
}

DWORD* getDbgWriteMask(DWORD mask)
{
    static DWORD dwResult;
    dwResult = (((mask & 1) ? dbgMaskChar[0] : ' ') << 0)
             | (((mask & 2) ? dbgMaskChar[1] : ' ') << 8)
             | (((mask & 4) ? dbgMaskChar[2] : ' ') << 16)
             | (((mask & 8) ? dbgMaskChar[3] : ' ') << 24);
    return &dwResult;
}

#define KELVIN_SET_SWIZZLED_SRC_REG(swizreg, token)                                                        \
{                                                                                                          \
    DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, ", ");                                                        \
    swizreg.Signed      = BYTE((token & D3DSP_SRCMOD_MASK) >> D3DSP_SRCMOD_SHIFT);                         \
    DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%c", (swizreg.Signed ? '-' : '+'));                          \
    swizreg.reg.reg     = KELVIN_ENUMERATED_REG(token);                                                    \
    swizreg.reg.AddrReg = BYTE((token & D3DVS_ADDRESSMODE_MASK) >> D3DVS_ADDRESSMODE_SHIFT);               \
    if (swizreg.reg.AddrReg) { swizreg.reg.addrRegOffset = swizreg.reg.reg - PR_0;                         \
                               DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "[+a0]"); }                        \
    swizreg.com4        = BYTE((token & D3DVS_SWIZZLE_MASK) >> D3DVS_SWIZZLE_SHIFT);                       \
    DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, ".%4.4s", getDbgVectorMask(swizreg.com4));                    \
}

#define KELVIN_SET_SCALAR_SRC_REG_X(scalarreg, token)                                                      \
{                                                                                                          \
    DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, ", ");                                                        \
    scalarreg.Signed      = BYTE((token & D3DSP_SRCMOD_MASK) >> D3DSP_SRCMOD_SHIFT);                       \
    DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%c", (scalarreg.Signed ? '-' : '+'));                        \
    scalarreg.reg.reg     = KELVIN_ENUMERATED_REG(token);                                                  \
    scalarreg.reg.AddrReg = BYTE((token & D3DVS_ADDRESSMODE_MASK) >> D3DVS_ADDRESSMODE_SHIFT);             \
    if (scalarreg.reg.AddrReg) { scalarreg.reg.addrRegOffset = scalarreg.reg.reg - PR_0;                   \
                                 DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "[+a0]"); }                      \
    scalarreg.com         = Component_t((((token & D3DVS_SWIZZLE_MASK) >> D3DVS_SWIZZLE_SHIFT) >> 0) & 3); \
    DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, ".%-4c", getDbgScalarMask(scalarreg.com));                    \
}

#define KELVIN_SET_SCALAR_SRC_REG_Y(scalarreg, token)                                                      \
{                                                                                                          \
    DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, ", ");                                                        \
    scalarreg.Signed      = BYTE((token & D3DSP_SRCMOD_MASK) >> D3DSP_SRCMOD_SHIFT);                       \
    DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%c", (scalarreg.Signed ? '-' : '+'));                        \
    scalarreg.reg.reg     = KELVIN_ENUMERATED_REG(token);                                                  \
    scalarreg.reg.AddrReg = BYTE((token & D3DVS_ADDRESSMODE_MASK) >> D3DVS_ADDRESSMODE_SHIFT);             \
    if (scalarreg.reg.AddrReg) { scalarreg.reg.addrRegOffset = scalarreg.reg.reg - PR_0;                   \
                                 DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "[+a0]"); }                      \
    scalarreg.com         = Component_t((((token & D3DVS_SWIZZLE_MASK) >> D3DVS_SWIZZLE_SHIFT) >> 2) & 3); \
    DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, ".%-4c", getDbgScalarMask(scalarreg.com));                    \
}

#define KELVIN_SET_SCALAR_SRC_REG_Z(scalarreg, token)                                                      \
{                                                                                                          \
    DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, ", ");                                                        \
    scalarreg.Signed      = BYTE((token & D3DSP_SRCMOD_MASK) >> D3DSP_SRCMOD_SHIFT);                       \
    DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%c", (scalarreg.Signed ? '-' : '+'));                        \
    scalarreg.reg.reg     = KELVIN_ENUMERATED_REG(token);                                                  \
    scalarreg.reg.AddrReg = BYTE((token & D3DVS_ADDRESSMODE_MASK) >> D3DVS_ADDRESSMODE_SHIFT);             \
    if (scalarreg.reg.AddrReg) { scalarreg.reg.addrRegOffset = scalarreg.reg.reg - PR_0;                   \
                                 DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "[+a0]"); }                      \
    scalarreg.com         = Component_t((((token & D3DVS_SWIZZLE_MASK) >> D3DVS_SWIZZLE_SHIFT) >> 4) & 3); \
    DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, ".%-4c", getDbgScalarMask(scalarreg.com));                    \
}

#define KELVIN_SET_SCALAR_SRC_REG_W(scalarreg, token)                                                      \
{                                                                                                          \
    DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, ", ");                                                        \
    scalarreg.Signed      = BYTE((token & D3DSP_SRCMOD_MASK) >> D3DSP_SRCMOD_SHIFT);                       \
    DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%c", (scalarreg.Signed ? '-' : '+'));                        \
    scalarreg.reg.reg     = KELVIN_ENUMERATED_REG(token);                                                  \
    scalarreg.reg.AddrReg = BYTE((token & D3DVS_ADDRESSMODE_MASK) >> D3DVS_ADDRESSMODE_SHIFT);             \
    if (scalarreg.reg.AddrReg) { scalarreg.reg.addrRegOffset = scalarreg.reg.reg - PR_0;                   \
                                 DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "[+a0]"); }                      \
    scalarreg.com         = Component_t((((token & D3DVS_SWIZZLE_MASK) >> D3DVS_SWIZZLE_SHIFT) >> 6) & 3); \
    DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, ".%-4c", getDbgScalarMask(scalarreg.com));                    \
}

#define KELVIN_SET_MASKED_DST_REG(dstreg, token)                                                    \
{                                                                                                   \
    DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, " ");                                                  \
    dstreg.reg  = KELVIN_ENUMERATED_REG(token);                                                     \
    dstreg.mask = (BYTE) ((token & D3DSP_WRITEMASK_ALL) >> 16);                                     \
    DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, ".%4.4s", getDbgWriteMask(dstreg.mask));               \
}
// should really be:
//    dstreg.mask = (token & D3DSP_WRITEMASK_MASK) >> D3DSP_WRITEMASK_SHIFT;

#define KELVIN_SET_ARL_OP(op,pinstruc,pcode)                                                        \
{                                                                                                   \
    pinstruc->arl_op.opclass = CLASS_ARL;                                                           \
    pinstruc->arl_op.opcode  = op;                                                                  \
    KELVIN_SET_SCALAR_SRC_REG_X (pinstruc->arl_op.src, pcode[1]);                                   \
    pcode += 2;                                                                                     \
}

#define KELVIN_SET_VECTOR_OP(op,pinstruc,pcode)                                                     \
{                                                                                                   \
    pinstruc->vector_op.opclass = CLASS_VECTOR;                                                     \
    pinstruc->vector_op.opcode  = op;                                                               \
    KELVIN_SET_MASKED_DST_REG   (pinstruc->vector_op.dst, pcode[0]);                                \
    KELVIN_SET_SWIZZLED_SRC_REG (pinstruc->vector_op.src, pcode[1]);                                \
    pcode += 2;                                                                                     \
}

#define KELVIN_SET_SCALAR_OP(op,pinstruc,pcode)                                                     \
{                                                                                                   \
    pinstruc->scalar_op.opclass = CLASS_SCALAR;                                                     \
    pinstruc->scalar_op.opcode  = op;                                                               \
    KELVIN_SET_MASKED_DST_REG (pinstruc->scalar_op.dst, pcode[0]);                                  \
    KELVIN_SET_SCALAR_SRC_REG_W (pinstruc->scalar_op.src, pcode[1]);                                \
    pcode += 2;                                                                                     \
}

#define KELVIN_SET_BINARY_OP(op,pinstruc,pcode)                                                     \
{                                                                                                   \
    pinstruc->bin_op.opclass = CLASS_BIN;                                                           \
    pinstruc->bin_op.opcode  = op;                                                                  \
    KELVIN_SET_MASKED_DST_REG   (pinstruc->bin_op.dst,  pcode[0]);                                  \
    KELVIN_SET_SWIZZLED_SRC_REG (pinstruc->bin_op.srcA, pcode[1]);                                  \
    KELVIN_SET_SWIZZLED_SRC_REG (pinstruc->bin_op.srcB, pcode[2]);                                  \
    pcode += 3;                                                                                     \
}

#define KELVIN_SET_TERNARY_OP(op,pinstruc,pcode)                                                    \
{                                                                                                   \
    pinstruc->tri_op.opclass = CLASS_TRI;                                                           \
    pinstruc->tri_op.opcode  = op;                                                                  \
    KELVIN_SET_MASKED_DST_REG   (pinstruc->tri_op.dst,  pcode[0]);                                  \
    KELVIN_SET_SWIZZLED_SRC_REG (pinstruc->tri_op.srcA, pcode[1]);                                  \
    KELVIN_SET_SWIZZLED_SRC_REG (pinstruc->tri_op.srcB, pcode[2]);                                  \
    KELVIN_SET_SWIZZLED_SRC_REG (pinstruc->tri_op.srcC, pcode[3]);                                  \
    pcode += 4;                                                                                     \
}

#define KELVIN_SET_MACRO_4_OP(op,pinstruc,pcode)                                                    \
{                                                                                                   \
    pinstruc[0].bin_op.opclass = CLASS_BIN;                                                         \
    pinstruc[1].bin_op.opclass = CLASS_BIN;                                                         \
    pinstruc[2].bin_op.opclass = CLASS_BIN;                                                         \
    pinstruc[3].bin_op.opclass = CLASS_BIN;                                                         \
    pinstruc[0].bin_op.opcode  = op;                                                                \
    pinstruc[1].bin_op.opcode  = op;                                                                \
    pinstruc[2].bin_op.opcode  = op;                                                                \
    pinstruc[3].bin_op.opcode  = op;                                                                \
    KELVIN_SET_MASKED_DST_REG   (pinstruc[0].bin_op.dst,  pcode[0] & ~D3DSP_WRITEMASK_ALL | D3DSP_WRITEMASK_0); \
    KELVIN_SET_MASKED_DST_REG   (pinstruc[1].bin_op.dst,  pcode[0] & ~D3DSP_WRITEMASK_ALL | D3DSP_WRITEMASK_1); \
    KELVIN_SET_MASKED_DST_REG   (pinstruc[2].bin_op.dst,  pcode[0] & ~D3DSP_WRITEMASK_ALL | D3DSP_WRITEMASK_2); \
    KELVIN_SET_MASKED_DST_REG   (pinstruc[3].bin_op.dst,  pcode[0] & ~D3DSP_WRITEMASK_ALL | D3DSP_WRITEMASK_3); \
    KELVIN_SET_SWIZZLED_SRC_REG (pinstruc[0].bin_op.srcA, pcode[1]);                                \
    KELVIN_SET_SWIZZLED_SRC_REG (pinstruc[1].bin_op.srcA, pcode[1]);                                \
    KELVIN_SET_SWIZZLED_SRC_REG (pinstruc[2].bin_op.srcA, pcode[1]);                                \
    KELVIN_SET_SWIZZLED_SRC_REG (pinstruc[3].bin_op.srcA, pcode[1]);                                \
    KELVIN_SET_SWIZZLED_SRC_REG (pinstruc[0].bin_op.srcB, pcode[2] + 0);                            \
    KELVIN_SET_SWIZZLED_SRC_REG (pinstruc[1].bin_op.srcB, pcode[2] + 1);                            \
    KELVIN_SET_SWIZZLED_SRC_REG (pinstruc[2].bin_op.srcB, pcode[2] + 2);                            \
    KELVIN_SET_SWIZZLED_SRC_REG (pinstruc[3].bin_op.srcB, pcode[2] + 3);                            \
    pcode += 3;                                                                                     \
}

#define KELVIN_SET_MACRO_3_OP(op,pinstruc,pcode)                                                    \
{                                                                                                   \
    pinstruc[0].bin_op.opclass = CLASS_BIN;                                                         \
    pinstruc[1].bin_op.opclass = CLASS_BIN;                                                         \
    pinstruc[2].bin_op.opclass = CLASS_BIN;                                                         \
    pinstruc[0].bin_op.opcode  = op;                                                                \
    pinstruc[1].bin_op.opcode  = op;                                                                \
    pinstruc[2].bin_op.opcode  = op;                                                                \
    KELVIN_SET_MASKED_DST_REG   (pinstruc[0].bin_op.dst,  pcode[0] & ~D3DSP_WRITEMASK_ALL | D3DSP_WRITEMASK_0); \
    KELVIN_SET_MASKED_DST_REG   (pinstruc[1].bin_op.dst,  pcode[0] & ~D3DSP_WRITEMASK_ALL | D3DSP_WRITEMASK_1); \
    KELVIN_SET_MASKED_DST_REG   (pinstruc[2].bin_op.dst,  pcode[0] & ~D3DSP_WRITEMASK_ALL | D3DSP_WRITEMASK_2); \
    KELVIN_SET_SWIZZLED_SRC_REG (pinstruc[0].bin_op.srcA, pcode[1]);                                \
    KELVIN_SET_SWIZZLED_SRC_REG (pinstruc[1].bin_op.srcA, pcode[1]);                                \
    KELVIN_SET_SWIZZLED_SRC_REG (pinstruc[2].bin_op.srcA, pcode[1]);                                \
    KELVIN_SET_SWIZZLED_SRC_REG (pinstruc[0].bin_op.srcB, pcode[2] + 0);                            \
    KELVIN_SET_SWIZZLED_SRC_REG (pinstruc[1].bin_op.srcB, pcode[2] + 1);                            \
    KELVIN_SET_SWIZZLED_SRC_REG (pinstruc[2].bin_op.srcB, pcode[2] + 2);                            \
    pcode += 3;                                                                                     \
}

#define KELVIN_SET_MACRO_2_OP(op,pinstruc,pcode)                                                    \
{                                                                                                   \
    pinstruc[0].bin_op.opclass = CLASS_BIN;                                                         \
    pinstruc[1].bin_op.opclass = CLASS_BIN;                                                         \
    pinstruc[0].bin_op.opcode  = op;                                                                \
    pinstruc[1].bin_op.opcode  = op;                                                                \
    KELVIN_SET_MASKED_DST_REG   (pinstruc[0].bin_op.dst,  pcode[0] & ~D3DSP_WRITEMASK_ALL | D3DSP_WRITEMASK_0); \
    KELVIN_SET_MASKED_DST_REG   (pinstruc[1].bin_op.dst,  pcode[0] & ~D3DSP_WRITEMASK_ALL | D3DSP_WRITEMASK_1); \
    KELVIN_SET_SWIZZLED_SRC_REG (pinstruc[0].bin_op.srcA, pcode[1]);                                \
    KELVIN_SET_SWIZZLED_SRC_REG (pinstruc[1].bin_op.srcA, pcode[1]);                                \
    KELVIN_SET_SWIZZLED_SRC_REG (pinstruc[0].bin_op.srcB, pcode[2] + 0);                            \
    KELVIN_SET_SWIZZLED_SRC_REG (pinstruc[1].bin_op.srcB, pcode[2] + 1);                            \
    pcode += 3;                                                                                     \
}

void MarkResultReg (unsigned char* pos, MaskedDstReg_Rec dst)
{
    if (dst.reg >= VR_0 && dst.reg <= VR_14)
    {
        pos[dst.reg-VR_0] |= dst.mask;
    }
}

void ExpMacro (PKELVIN_PROGRAM pProgram, DWORD dwInstruction, DWORD *pcode)
{
    pProgram->code[dwInstruction + 0].scalar_op.opclass         = CLASS_SCALAR;
    pProgram->code[dwInstruction + 0].scalar_op.opcode          = OP_EXP;
    KELVIN_SET_MASKED_DST_REG   (pProgram->code[dwInstruction + 1].vector_op.dst, pcode[0]);
    KELVIN_SET_SCALAR_SRC_REG_W (pProgram->code[dwInstruction + 0].scalar_op.src, pcode[1]);
    pProgram->code[dwInstruction + 0].scalar_op.dst.reg         = TR_8;
    pProgram->code[dwInstruction + 0].scalar_op.dst.mask        = 4; // write z only

    pProgram->code[dwInstruction + 1].scalar_op.opclass         = CLASS_VECTOR;
    pProgram->code[dwInstruction + 1].scalar_op.opcode          = OP_MOV;
    pProgram->code[dwInstruction + 1].vector_op.src.reg.reg     = TR_8;
    pProgram->code[dwInstruction + 1].vector_op.src.reg.AddrReg = 0x0;
    pProgram->code[dwInstruction + 1].vector_op.src.com4        = 0xAA; // get from z
    pProgram->code[dwInstruction + 1].vector_op.src.Signed      = 0x0;
}

void LogMacro (PKELVIN_PROGRAM pProgram, DWORD dwInstruction, DWORD *pcode)
{
    pProgram->code[dwInstruction + 0].scalar_op.opclass         = CLASS_SCALAR;
    pProgram->code[dwInstruction + 0].scalar_op.opcode          = OP_LOG;
    KELVIN_SET_MASKED_DST_REG   (pProgram->code[dwInstruction + 1].vector_op.dst, pcode[0]);
    KELVIN_SET_SCALAR_SRC_REG_W (pProgram->code[dwInstruction + 0].scalar_op.src, pcode[1]);
    pProgram->code[dwInstruction + 0].scalar_op.dst.reg         = TR_8;
    pProgram->code[dwInstruction + 0].scalar_op.dst.mask        = 4; // write z only

    pProgram->code[dwInstruction + 1].scalar_op.opclass         = CLASS_VECTOR;
    pProgram->code[dwInstruction + 1].scalar_op.opcode          = OP_MOV;
    pProgram->code[dwInstruction + 1].vector_op.src.reg.reg     = TR_8;
    pProgram->code[dwInstruction + 1].vector_op.src.reg.AddrReg = 0x0;
    pProgram->code[dwInstruction + 1].vector_op.src.com4        = 0xAA; // get from z
    pProgram->code[dwInstruction + 1].vector_op.src.Signed      = 0x0;
}

DWORD FrcMacro (PKELVIN_PROGRAM pProgram, DWORD dwInstruction, DWORD *pCode)
{
    if (pCode[0] & D3DSP_WRITEMASK_0) { // if x is written
        pProgram->code[dwInstruction].scalar_op.opclass         = CLASS_SCALAR;
        pProgram->code[dwInstruction].scalar_op.opcode          = OP_EXP;
        KELVIN_SET_SCALAR_SRC_REG_X (pProgram->code[dwInstruction].scalar_op.src, pCode[1]);
        pProgram->code[dwInstruction].scalar_op.dst.reg         = TR_8;
        pProgram->code[dwInstruction].scalar_op.dst.mask        = 2; // write y only
        dwInstruction++;
        pProgram->code[dwInstruction].scalar_op.opclass         = CLASS_VECTOR;
        pProgram->code[dwInstruction].scalar_op.opcode          = OP_MOV;
        pProgram->code[dwInstruction].vector_op.src.reg.reg     = TR_8;
        pProgram->code[dwInstruction].vector_op.src.reg.AddrReg = 0x0;
        pProgram->code[dwInstruction].vector_op.src.com4        = 0x55; // get from y
        pProgram->code[dwInstruction].vector_op.src.Signed      = 0x0;
        KELVIN_SET_MASKED_DST_REG   (pProgram->code[dwInstruction].vector_op.dst, pCode[0]);
        pProgram->code[dwInstruction].vector_op.dst.mask        = 0x1; // write x only
        dwInstruction++;
    }

    if (pCode[0] & D3DSP_WRITEMASK_1) { // if y is written
        pProgram->code[dwInstruction].scalar_op.opclass         = CLASS_SCALAR;
        pProgram->code[dwInstruction].scalar_op.opcode          = OP_EXP;
        KELVIN_SET_SCALAR_SRC_REG_Y (pProgram->code[dwInstruction].scalar_op.src, pCode[1]);
        KELVIN_SET_MASKED_DST_REG   (pProgram->code[dwInstruction].vector_op.dst, pCode[0]);
        pProgram->code[dwInstruction].scalar_op.dst.mask        = 2; // write y only
        dwInstruction++;
    }

/* MS doesn't want these anymore (for now)
    if (pCode[0] & D3DSP_WRITEMASK_2) { // if z is written
        pProgram->code[dwInstruction].scalar_op.opclass         = CLASS_SCALAR;
        pProgram->code[dwInstruction].scalar_op.opcode          = OP_EXP;
        KELVIN_SET_SCALAR_SRC_REG_Z (pProgram->code[dwInstruction].scalar_op.src, pCode[1]);
        pProgram->code[dwInstruction].scalar_op.dst.reg         = TR_8;
        pProgram->code[dwInstruction].scalar_op.dst.mask        = 2; // write y only
        dwInstruction++;
        pProgram->code[dwInstruction].scalar_op.opclass         = CLASS_VECTOR;
        pProgram->code[dwInstruction].scalar_op.opcode          = OP_MOV;
        pProgram->code[dwInstruction].vector_op.src.reg.reg     = TR_8;
        pProgram->code[dwInstruction].vector_op.src.reg.AddrReg = 0x0;
        pProgram->code[dwInstruction].vector_op.src.com4        = 0x55; // get from y
        pProgram->code[dwInstruction].vector_op.src.Signed      = 0x0;
        KELVIN_SET_MASKED_DST_REG   (pProgram->code[dwInstruction].vector_op.dst, pCode[0]);
        pProgram->code[dwInstruction].vector_op.dst.mask       &= 0x4; // write z only
        dwInstruction++;
    }

    if (pCode[0] & D3DSP_WRITEMASK_3) { // if w is written
        pProgram->code[dwInstruction].scalar_op.opclass         = CLASS_SCALAR;
        pProgram->code[dwInstruction].scalar_op.opcode          = OP_EXP;
        KELVIN_SET_SCALAR_SRC_REG_W (pProgram->code[dwInstruction].scalar_op.src, pCode[1]);
        pProgram->code[dwInstruction].scalar_op.dst.reg         = TR_8;
        pProgram->code[dwInstruction].scalar_op.dst.mask        = 2; // write y only
        dwInstruction++;
        pProgram->code[dwInstruction].scalar_op.opclass         = CLASS_VECTOR;
        pProgram->code[dwInstruction].scalar_op.opcode          = OP_MOV;
        pProgram->code[dwInstruction].vector_op.src.reg.reg     = TR_8;
        pProgram->code[dwInstruction].vector_op.src.reg.AddrReg = 0x0;
        pProgram->code[dwInstruction].vector_op.src.com4        = 0x55; // get from y
        pProgram->code[dwInstruction].vector_op.src.Signed      = 0x0;
        KELVIN_SET_MASKED_DST_REG   (pProgram->code[dwInstruction].vector_op.dst, pCode[0]);
        pProgram->code[dwInstruction].vector_op.dst.mask       &= 0x8; // write w only
        dwInstruction++;
    }
*/
    return dwInstruction - 1;
}

// parse D3D-style vertex shader code into intermediate compiled code

void nvKelvinParseVertexShaderCode
(
    PKELVIN_PROGRAM pProgram,
    ParsedProgram *parsed,
    DWORD *pCode,
    DWORD dwCodeSize
)
{
    DWORD dwHeader, dwToken, dwInstruction;
    Instruction *pInstruction;
    BOOL bDone;

    // read the header
    dwHeader = *pCode;
    pCode++;

    // clear written regs
    for (int i = 0; i < __GL_NUMBER_OF_RESULT_REGISTERS; i++) {
        parsed->resultRegsWritten[i] = DST_NONE_BITS;
    }

    bDone = FALSE;
    dwInstruction = 0;

    while (!bDone) {

        dwToken = *pCode;
        pCode++;
        pInstruction = &(pProgram->code[dwInstruction]);

        switch (dwToken & D3DSI_OPCODE_MASK) {

            case D3DSIO_NOP:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d NOP ", dwInstruction);
                pInstruction->end_op.opclass = CLASS_END;
                pInstruction->end_op.opcode  = OP_NOP;
                break;
            case D3DSIO_MOV:
                if (KELVIN_BASE_REG(pCode[0]) == ARL) {
                    DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d ARL ", dwInstruction);
                    KELVIN_SET_ARL_OP (OP_ARL, pInstruction, pCode);
                } else {
                    DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d MOV ", dwInstruction);
                    KELVIN_SET_VECTOR_OP (OP_MOV, pInstruction, pCode);
                    MarkResultReg (parsed->resultRegsWritten, pInstruction->vector_op.dst);
                }
                break;
            case D3DSIO_ADD:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d ADD ", dwInstruction);
                KELVIN_SET_BINARY_OP (OP_ADD, pInstruction, pCode);
                MarkResultReg (parsed->resultRegsWritten, pInstruction->bin_op.dst);
                break;
            case D3DSIO_MAD:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d MAD ", dwInstruction);
                KELVIN_SET_TERNARY_OP (OP_MAD, pInstruction, pCode);
                MarkResultReg (parsed->resultRegsWritten, pInstruction->tri_op.dst);
                break;
            case D3DSIO_MUL:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d MUL ", dwInstruction);
                KELVIN_SET_BINARY_OP (OP_MUL, pInstruction, pCode);
                MarkResultReg (parsed->resultRegsWritten, pInstruction->bin_op.dst);
                break;
            case D3DSIO_RCP:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d RCP ", dwInstruction);
                KELVIN_SET_SCALAR_OP (OP_RCP, pInstruction, pCode);
                MarkResultReg (parsed->resultRegsWritten, pInstruction->scalar_op.dst);
                break;
            case D3DSIO_RSQ:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d RSQ ", dwInstruction);
                KELVIN_SET_SCALAR_OP (OP_RSQ, pInstruction, pCode);
                MarkResultReg (parsed->resultRegsWritten, pInstruction->scalar_op.dst);
                break;
            case D3DSIO_DP3:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d DP3 ", dwInstruction);
                KELVIN_SET_BINARY_OP (OP_DP3, pInstruction, pCode);
                MarkResultReg (parsed->resultRegsWritten, pInstruction->bin_op.dst);
                break;
            case D3DSIO_DP4:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d DP4 ", dwInstruction);
                KELVIN_SET_BINARY_OP (OP_DP4, pInstruction, pCode);
                MarkResultReg (parsed->resultRegsWritten, pInstruction->bin_op.dst);
                break;
            case D3DSIO_MIN:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d MIN ", dwInstruction);
                KELVIN_SET_BINARY_OP (OP_MIN, pInstruction, pCode);
                MarkResultReg (parsed->resultRegsWritten, pInstruction->bin_op.dst);
                break;
            case D3DSIO_MAX:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d MAX ", dwInstruction);
                KELVIN_SET_BINARY_OP (OP_MAX, pInstruction, pCode);
                MarkResultReg (parsed->resultRegsWritten, pInstruction->bin_op.dst);
                break;
            case D3DSIO_SLT:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d SLT ", dwInstruction);
                KELVIN_SET_BINARY_OP (OP_SLT, pInstruction, pCode);
                MarkResultReg (parsed->resultRegsWritten, pInstruction->bin_op.dst);
                break;
            case D3DSIO_SGE:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d SGE ", dwInstruction);
                KELVIN_SET_BINARY_OP (OP_SGE, pInstruction, pCode);
                MarkResultReg (parsed->resultRegsWritten, pInstruction->bin_op.dst);
                break;
            case D3DSIO_EXP:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d EXP ", dwInstruction);
                ExpMacro(pProgram, dwInstruction, pCode);
                pCode += 2;
                dwInstruction ++;
                break;
            case D3DSIO_LOG:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d LOG ", dwInstruction);
                LogMacro(pProgram, dwInstruction, pCode);
                pCode += 2;
                dwInstruction ++;
                break;
            case D3DSIO_LIT:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d LIT ", dwInstruction);
                KELVIN_SET_VECTOR_OP (OP_LIT, pInstruction, pCode);
                MarkResultReg (parsed->resultRegsWritten, pInstruction->vector_op.dst);
                break;
            case D3DSIO_DST:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d DST ", dwInstruction);
                KELVIN_SET_BINARY_OP (OP_DST, pInstruction, pCode);
                MarkResultReg (parsed->resultRegsWritten, pInstruction->bin_op.dst);
                break;
            case D3DSIO_M4x4:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d M4x4", dwInstruction);
                KELVIN_SET_MACRO_4_OP (OP_DP4, pInstruction, pCode);
                MarkResultReg (parsed->resultRegsWritten, pInstruction[0].bin_op.dst);
                MarkResultReg (parsed->resultRegsWritten, pInstruction[1].bin_op.dst);
                MarkResultReg (parsed->resultRegsWritten, pInstruction[2].bin_op.dst);
                MarkResultReg (parsed->resultRegsWritten, pInstruction[3].bin_op.dst);
                dwInstruction += 3;
                break;
            case D3DSIO_M3x4:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d M3x4", dwInstruction);
                KELVIN_SET_MACRO_4_OP (OP_DP3, pInstruction, pCode);
                MarkResultReg (parsed->resultRegsWritten, pInstruction[0].bin_op.dst);
                MarkResultReg (parsed->resultRegsWritten, pInstruction[1].bin_op.dst);
                MarkResultReg (parsed->resultRegsWritten, pInstruction[2].bin_op.dst);
                MarkResultReg (parsed->resultRegsWritten, pInstruction[3].bin_op.dst);
                dwInstruction += 3;
                break;
            case D3DSIO_M4x3:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d M4x3", dwInstruction);
                KELVIN_SET_MACRO_3_OP (OP_DP4, pInstruction, pCode);
                MarkResultReg (parsed->resultRegsWritten, pInstruction[0].bin_op.dst);
                MarkResultReg (parsed->resultRegsWritten, pInstruction[1].bin_op.dst);
                MarkResultReg (parsed->resultRegsWritten, pInstruction[2].bin_op.dst);
                dwInstruction += 2;
                break;
            case D3DSIO_M3x3:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d M3x3", dwInstruction);
                KELVIN_SET_MACRO_3_OP (OP_DP3, pInstruction, pCode);
                MarkResultReg (parsed->resultRegsWritten, pInstruction[0].bin_op.dst);
                MarkResultReg (parsed->resultRegsWritten, pInstruction[1].bin_op.dst);
                MarkResultReg (parsed->resultRegsWritten, pInstruction[2].bin_op.dst);
                dwInstruction += 2;
                break;
            case D3DSIO_M3x2:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d M3x2", dwInstruction);
                KELVIN_SET_MACRO_2_OP (OP_DP3, pInstruction, pCode);
                MarkResultReg (parsed->resultRegsWritten, pInstruction[0].bin_op.dst);
                MarkResultReg (parsed->resultRegsWritten, pInstruction[1].bin_op.dst);
                dwInstruction ++;
                break;
            case D3DSIO_FRC:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d FRC ", dwInstruction);
                dwInstruction = FrcMacro(pProgram, dwInstruction, pCode);
                pCode += 2;
                break;
            case D3DSIO_EXPP:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d EXPP", dwInstruction);
                KELVIN_SET_SCALAR_OP (OP_EXP, pInstruction, pCode);
                MarkResultReg (parsed->resultRegsWritten, pInstruction->scalar_op.dst);
                break;
            case D3DSIO_LOGP:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d LOGP", dwInstruction);
                KELVIN_SET_SCALAR_OP (OP_LOG, pInstruction, pCode);
                MarkResultReg (parsed->resultRegsWritten, pInstruction->scalar_op.dst);
                break;
            case D3DSIO_COMMENT:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d COMMENT (TODO)", dwInstruction);
                nvAssert(0);
                break;
            case D3DSIO_END:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d END\r\n", dwInstruction);
                pInstruction->end_op.opclass = CLASS_END;
                pInstruction->end_op.opcode  = OP_END;
                bDone = TRUE;
                break;
            default:
                // unhandled instruction
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "Unknown opcode (%d)", dwToken & D3DSI_OPCODE_MASK);
                nvAssert(0);

        }  // switch

        DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "\r\n");
        dwInstruction++;
    }

    // check special case output registers
    if (parsed->resultRegsWritten[VA_FOGC]) {
        // fog may only use .x
        nvAssert(parsed->resultRegsWritten[VA_FOGC] == 1);

        // force it to .x
        parsed->resultRegsWritten[VA_FOGC] = 1;
    }

/*
    // sanity check program output
    for (i = 0; i < 11; i++)
    {
        DWORD dwRegWriteMask = parsed->resultRegsWritten[i];

        // data in this stream?
        if (dwRegWriteMask)
        {
            // valid combination of output registers written?
            if (dwCelsiusMethodDispatch[i][dwRegWriteMask][0] == 0xDEADBEEF) {
                DPF("Vertex Shader - invalid write mask for register %d reset", i);
                nvAssert(0);
                // set the regs written mask to 0 (disable output for this register)
                parsed->resultRegsWritten[i] = 0; // do this for emulation only
            }
        }
    }
*/
    pProgram->dwNumInstructions = dwInstruction;
}
 
#ifdef KPFS

void CKelvinProgramMan::create(DWORD dwInstructions)
{ 
    memset(this,0,sizeof(CKelvinProgramMan));
    m_dwInstructions = dwInstructions;
    if (!ins)
        ins=new CInstr[dwInstructions]();
    nvAssert(ins);
    memset(ins,0,sizeof(CInstr)*dwInstructions);
    for (DWORD i=0;i<dwInstructions;i++) {
        ins[i].index=i;
        ins[i].len=dwInstructions-i;
    }
    DPF_LEVEL(NVDBG_LEVEL_VSHADER_MAN,"shaderman: created\n");
}

void CKelvinProgramMan::destroy()
{ 
    nvAssert(ins);
    if (ins) 
        delete[] ins;
    DPF_LEVEL(NVDBG_LEVEL_VSHADER_MAN,"shaderman: deleted\n");
}

void CKelvinProgramMan::flush()
{
    DWORD   n= m_dwInstructions;
    CInstr* t= ins ? ins : new CInstr[m_dwInstructions]();
    memset(this,0,sizeof(CKelvinProgramMan));
    ins = t; m_dwInstructions = n;
    for (DWORD i=0;i<m_dwInstructions;i++) {
        ins[i].index=i;
        ins[i].len=m_dwInstructions-i;
        ins[i].next = 0;
    }
    DPF_LEVEL(NVDBG_LEVEL_VSHADER_MAN,"shaderman: flushed\n");
}

bool CKelvinProgramMan::find(DWORD handle, DWORD num_instr)
{
    CInstr *f = &ins[0];
    while (f){
        if (f->handle==handle){   
            //check
            if (f->next) {
                nvAssert((f->next->index) == (f->index+f->len));
                nvAssert(f->len ==num_instr);
            }
            m_dwOffset=f->index;
            return true;
        }
        f=f->next;
    }
    return false;
}

void CKelvinProgramMan::add(DWORD handle, DWORD num_instr) 
{
    DWORD    i,  x, sx, px = ~0;
    CInstr  *t, *n, *a, *f = &ins[0];
    //find a place to insert
    while (f) {
        //found a free block   
        if (!f->handle && f->len >= num_instr){
            sx=f->len;
            n=f->next;
            m_dwOffset = f->index;
            goto free_block;
        }
        
        //slide window and compute cost
        t=f; x=0;
        while(num_instr > x && t) {
            x+=t->len;
            t=t->next;
        }
        
        if (x<px && num_instr <= x) {
            sx=px=x;
            n=t;
            m_dwOffset=f->index;
        }
        
        f=f->next;
    }
    
    //insert
    f = &ins[m_dwOffset]; 
    free_block:
    f->handle = handle;
    f->len = num_instr;
    i = f->index+f->len;
    
    if (i<m_dwInstructions) {
        a = &ins[i];
        f->next = a;
        
        if (f->next!=n) {
            a->next = n;
            a->len=sx-f->len;
            a->handle=0;
        }
    }
    else f->next=NULL;
}   

void CKelvinProgramMan::display() 
{
    CInstr* t=&ins[0];
    while(t) {
        for(DWORD i=0;i<t->len;i++) {
            DPF_PLAIN("%3x",t->handle);        
        }       
        t=t->next;
    }
    DPF_PLAIN("\n"); 
}


#define SET_PROGRAM_TYPE(type)                                              \
{                                                                           \
    pContext->hwState.kelvin.set1(NV097_SET_TRANSFORM_EXECUTION_MODE,       \
    DRF_DEF(097, _SET_TRANSFORM_EXECUTION_MODE, _MODE, _PROGRAM) |          \
    DRF_DEF(097, _SET_TRANSFORM_EXECUTION_MODE, _RANGE_MODE, type));        \
    pContext->hwState.kelvin.set1(NV097_SET_TRANSFORM_PROGRAM_CXT_WRITE_EN, \
    DRF_DEF(097, _SET_TRANSFORM_PROGRAM_CXT_WRITE_EN, _V, _READ_ONLY));     \
}


void CKelvinProgramMan::download_special(PNVD3DCONTEXT pContext, PKELVIN_MICRO_PROGRAM pProgram, DWORD handle) {

    DWORD num_instr = pProgram->length;
    nvAssert(num_instr<=m_dwInstructions);
    
    if (!m_pContext)
        m_pContext=pContext;
    else {
        if (m_pContext!=pContext) {
            m_pContext=pContext;
            m_dwOffset=0;
            flush();
            goto fromzero;
        }
        else {
            //early out
            if ((m_dwLastHandle==handle) && (m_pPrevContext == pContext)) { 
                if (m_dwDirty) {
                    SET_PROGRAM_TYPE(_PRIV);
                    m_dwDirty=0;
                }
                return;
            }
                
            m_dwLastHandle=handle;
            m_pPrevContext = pContext; 
        }
    }

    SET_PROGRAM_TYPE(_PRIV);

    //shader already loaded
    if (find(handle,num_instr)) {
        pContext->hwState.kelvin.set1 (NV097_SET_TRANSFORM_PROGRAM_START, m_dwOffset);
        DPF_LEVEL(NVDBG_LEVEL_VSHADER_MAN,"shaderman: Is %d, %d",m_dwOffset,num_instr);
    }
    else {
        add(handle,num_instr);
        fromzero:
        pContext->hwState.kelvin.set1 (NV097_SET_TRANSFORM_PROGRAM_START, m_dwOffset);
        nvKelvinDownloadProgram(pContext, pProgram,m_dwOffset);
        DPF_LEVEL(NVDBG_LEVEL_VSHADER_MAN,"shaderman: Es %d, %d",m_dwOffset,num_instr);
    }
}

void CKelvinProgramMan::download(PNVD3DCONTEXT pContext,  CVertexShader* pVS) {
    
    DWORD num_instr = pVS->m_ProgramOutput.residentNumInstructions;
    DWORD handle = pVS->getHandle();
    
    nvAssert(num_instr<=m_dwInstructions);
    nvAssert(handle!=0xFFFFFFFF && handle!=0xFFFFFFFE); //reserved for passthrough and aa shaders, bug florin if this ever triggers

    if (!m_pContext)
        m_pContext=pContext;
    else {
        if (m_pContext!=pContext) {
            m_pContext=pContext;
            m_dwOffset=0;
            flush();
            goto fromzero;
        }
        else
        {
            //early out
            if ((m_dwLastHandle==handle) && (m_pPrevContext == pContext)) {
                if (m_dwDirty) {
                    SET_PROGRAM_TYPE(_USER);
                    m_dwDirty=0;
                }
                nvKelvinDownloadConstants (pContext);
                return;
            }
            m_dwLastHandle=handle;
            m_pPrevContext = pContext; 
        }
    }

    SET_PROGRAM_TYPE(_USER);
    
    //shader already loaded
    if (find(handle,num_instr)) {
        pContext->hwState.kelvin.set1 (NV097_SET_TRANSFORM_PROGRAM_START, m_dwOffset);
        DPF_LEVEL(NVDBG_LEVEL_VSHADER_MAN,"I %d, %d",m_dwOffset,num_instr);
    }
    else {
        add(handle,num_instr);
        fromzero:
        pContext->hwState.kelvin.set1 (NV097_SET_TRANSFORM_PROGRAM_START, m_dwOffset);
        nvKelvinDownloadProgram (pContext, &pVS->m_ProgramOutput, m_dwOffset);
        DPF_LEVEL(NVDBG_LEVEL_VSHADER_MAN,"E %d, %d",m_dwOffset,num_instr);
    }
    
    nvKelvinDownloadConstants (pContext);
}
#endif

#endif  // NVARCH >= 0x020
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\kelvin\src\nvKelvinColorCombiners.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvKelvinColorCombiners.cpp
//      routines for setting up the Kelvin color combiners from
//      DX6-style texture stages
//
// **************************************************************************
//
//  History:
//      Craig Duttweiler        29Mar00         NV20 development
//
// **************************************************************************
#include "nvprecomp.h"

#if (NVARCH >= 0x20)

//---------------------------------------------------------------------------

// Set a color input to to 1 or -1

void nvKelvinCCSetColorInputOne (PNVD3DCONTEXT pContext, kelvinCombinerInput eInput,
                                 DWORD dwCombinerStage, BOOL bNegate)
{
    DWORD dwICW = 0;

    dwICW |= bNegate ? DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_D_MAP, _EXPAND_NORMAL) :
                       DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_D_MAP, _UNSIGNED_INVERT);

    dwICW |= DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_D_ALPHA, _FALSE);
    dwICW |= DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_D_SOURCE, _REG_0);

    pContext->hwState.dwColorICW[dwCombinerStage] |= (dwICW << kelvinCombinerInputShift[eInput]);
}

//---------------------------------------------------------------------------

// Select the source for combiner input eInput in combiner stage
// dwCombinerStage from argument dwD3DTSSArg in D3D stage dwD3DStage.
// return TSS_USES_NULL_TEXTURE if we reference a texture we don't have

HRESULT nvKelvinCCSelectColorInput (PNVD3DCONTEXT pContext, kelvinCombinerInput eInput,
                                    DWORD dwCombinerStage, DWORD dwD3DStage, DWORD dwD3DTSSArg,
                                    BOOL bComplement, BOOL bExpandNormal, BOOL bAlphaReplicate)
{
    DWORD dwICW = 0;
    DWORD dwCurrentUsed = FALSE; //slight hack to fix D3DTA_CURRENT issues.  This should be cleaner.
    int i;

    switch (pContext->tssState[dwD3DStage].dwValue[dwD3DTSSArg] & D3DTA_SELECTMASK) {
        case D3DTA_CURRENT:
            if (dwD3DStage != 0)
            {
                for (i=dwD3DStage - 1;i>=0;i--)
                {
                    if (pContext->tssState[i].dwValue[D3DTSS_RESULTARG] != D3DTA_TEMP)
                    {
                        dwCurrentUsed=TRUE;
                        break;
                    }
                }

            }
            if (dwCurrentUsed == TRUE) 
            {
                // Output from previous stage
                dwICW |= DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_D_SOURCE, _REG_C);
                break;
            }
            // else, default to diffuse below
        case D3DTA_DIFFUSE:
            dwICW |= DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_D_SOURCE, _REG_4);
            break;
        case D3DTA_TEXTURE:
            if (!(pContext->tssState[dwD3DStage].dwValue[D3DTSS_TEXTUREMAP])) {
                // if we don't actually have a texture, default to the 'current'.
                // yes, this is actually the d3d default: select texture with no texture.
                // my mama done told me, my name was duh microsoft.
                return (TSS_USES_NULL_TEXTURE);
            }
            else {
                if (pContext->hwState.dwNextAvailableTextureUnit < KELVIN_NUM_TEXTURES) {
                    pContext->hwState.dwTexUnitToTexStageMapping[pContext->hwState.dwNextAvailableTextureUnit] = dwD3DStage;
                    dwICW |= DRF_NUM (097, _SET_COMBINER_COLOR, _ICW_D_SOURCE, KELVIN_COMBINER_REG_TEX0 + pContext->hwState.dwNextAvailableTextureUnit);
                }
                else {
                    pContext->hwState.dwStateFlags |= KELVIN_FLAG_SETUPFAILURE;
                    dwICW |= DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_D_SOURCE, _REG_0);
                }
            }
            break;
        case D3DTA_TFACTOR:
            dwICW |= DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_D_SOURCE, _REG_1);
            break;
        case D3DTA_SPECULAR:
            dwICW |= DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_D_SOURCE, _REG_5);
            pContext->hwState.dwStateFlags |= KELVIN_FLAG_COMBINERSNEEDSPECULAR;
            break;
        case D3DTA_TEMP:
            dwICW |= DRF_DEF(056, _SET_COMBINER_COLOR, _ICW_D_SOURCE, _REG_D);
            break;
        default:
            DPF ("unknown / illegal color argument '%d' in nvKelvinCCSelectColorInput",
                 pContext->tssState[dwD3DStage].dwValue[dwD3DTSSArg] & D3DTA_SELECTMASK);
            dbgD3DError();
            pContext->hwState.dwStateFlags |= KELVIN_FLAG_SETUPFAILURE;
            break;
    }

    // Now handle the alpha replicate and complement flags

    bAlphaReplicate |= (pContext->tssState[dwD3DStage].dwValue[dwD3DTSSArg] & D3DTA_ALPHAREPLICATE);

    dwICW |= bAlphaReplicate ? DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_D_ALPHA, _TRUE) :
                               DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_D_ALPHA, _FALSE);

    bComplement = ((pContext->tssState[dwD3DStage].dwValue[dwD3DTSSArg] & D3DTA_COMPLEMENT) ^
                   ((bComplement) ? D3DTA_COMPLEMENT : 0))
                  ?
                  TRUE : FALSE;

    if (bExpandNormal) {
        dwICW |= bComplement ? DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_D_MAP, _EXPAND_NEGATE) :
                               DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_D_MAP, _EXPAND_NORMAL);
    }
    else {
        dwICW |= bComplement ? DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_D_MAP, _UNSIGNED_INVERT) :
                               DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_D_MAP, _UNSIGNED_IDENTITY);
    }

    pContext->hwState.dwColorICW[dwCombinerStage] |= (dwICW << kelvinCombinerInputShift[eInput]);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

// Select the input into A
static HRESULT nvKelvinCCSelect1 (PNVD3DCONTEXT pContext, DWORD dwHWStage, DWORD dwD3DStage)
{
    HRESULT hr;
    // A * 1
    hr = nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
    nvKelvinCCSetColorInputOne (pContext, kelvinCombinerInputB, dwHWStage, FALSE);
    // C & D default to zero
    return (hr);
}

//---------------------------------------------------------------------------

// Select the input into D
static HRESULT nvKelvinCCSelect2 (PNVD3DCONTEXT pContext, DWORD dwHWStage, DWORD dwD3DStage)
{
    HRESULT hr;
    // Multiply D * 1
    nvKelvinCCSetColorInputOne (pContext, kelvinCombinerInputC, dwHWStage, FALSE);
    hr = nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputD, dwHWStage, dwD3DStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);
    // A & B default to zero
    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinCCModulate (PNVD3DCONTEXT pContext, DWORD dwHWStage, DWORD dwD3DStage)
{
    HRESULT hr;
    // Multiply A * B
    hr  = nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
    hr |= nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputB, dwHWStage, dwD3DStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);
    // C & D default to zero
    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinCCAdd (PNVD3DCONTEXT pContext, DWORD dwHWStage, DWORD dwD3DStage)
{
    HRESULT hr;
    // Multiply A * 1(B)
    hr = nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
    // Make B 1
    nvKelvinCCSetColorInputOne (pContext, kelvinCombinerInputB, dwHWStage, FALSE);
    // Multiply 1(C) * D
    nvKelvinCCSetColorInputOne (pContext, kelvinCombinerInputC, dwHWStage, FALSE);
    hr |= nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputD, dwHWStage, dwD3DStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);
    // Implicit A + D
    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinCCSub (PNVD3DCONTEXT pContext, DWORD dwHWStage, DWORD dwD3DStage)
{
    HRESULT hr;
    // Multiply A * 1
    hr = nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
    nvKelvinCCSetColorInputOne (pContext, kelvinCombinerInputB, dwHWStage, FALSE);
    // Multiply D * -1
    nvKelvinCCSetColorInputOne (pContext, kelvinCombinerInputC, dwHWStage, TRUE);
    hr |= nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputD, dwHWStage, dwD3DStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);
    // Implicit A + -D
    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinCCAddSmooth (PNVD3DCONTEXT pContext, DWORD dwHWStage, DWORD dwD3DStage)
{
    HRESULT hr;
    // Multiply A * 1
    hr = nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
    nvKelvinCCSetColorInputOne (pContext, kelvinCombinerInputB, dwHWStage, FALSE);
    // Make C: (1-arg1), make D: arg2
    hr |= nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputC, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, TRUE, FALSE, FALSE);
    hr |= nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputD, dwHWStage, dwD3DStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);
    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinCCBlendAlpha (PNVD3DCONTEXT pContext, DWORD dwHWStage, DWORD dwD3DStage, DWORD dwType)
{
    HRESULT hr;
    DWORD   dwTemp;

    // Multiply A * B(alpha)
    hr = nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);

    if (dwType == TEXTUREPM) // this type defined by us
    {
        // Make B 1 since texture is already pre-multiplied
        nvKelvinCCSetColorInputOne (pContext, kelvinCombinerInputB, dwHWStage, FALSE);
        // set type again for making C (1-alpha) below
        dwType = D3DTA_TEXTURE;
    }
    else
    {
        // Make B alpha, appropriate type
        dwTemp = pContext->tssState[dwD3DStage].dwValue[D3DTSS_COLORARG2];
        pContext->tssState[dwD3DStage].dwValue[D3DTSS_COLORARG2] = dwType;
        hr |= nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputB, dwHWStage, dwD3DStage, D3DTSS_COLORARG2, FALSE, FALSE, TRUE);
        // copy arg2 back
        pContext->tssState[dwD3DStage].dwValue[D3DTSS_COLORARG2] = dwTemp;
    }

    // Make C: 1-alpha, make D: arg2
    dwTemp = pContext->tssState[dwD3DStage].dwValue[D3DTSS_COLORARG1];
    pContext->tssState[dwD3DStage].dwValue[D3DTSS_COLORARG1] = dwType;
    hr |= nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputC, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, TRUE, FALSE, TRUE);
    // copy back to colorarg1
    pContext->tssState[dwD3DStage].dwValue[D3DTSS_COLORARG1] = dwTemp;
    hr |= nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputD, dwHWStage, dwD3DStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);

    return (hr);
}

//---------------------------------------------------------------------------

// The way D3D does this, it essentially allows using texture from stage 1
// in stage1 twice.  D3D does not normally allow you to use a texture in
// stage 0 and stage1.  This way, D3D allows you to modulate in (effectively)
// stage 0 and then do whatever it is you are going to do in stage1.  The
// key is that we use the texture from stage1 (since there is really no texture
// in stage 0)

// Premodulate in stage (i-1) is effectively selectarg1
// Then, in stage i, modulate current color (the above) with texture in stage i
// Then, do the operation chosen for stage i

static HRESULT nvKelvinCCPremodulate (PNVD3DCONTEXT pContext, DWORD dwHWStage, DWORD dwD3DStage)
{
    HRESULT hr;
    DWORD   dwTemp;

    DPF ("pre-modulationis totally broken");
    dbgD3DError();

    if (dwD3DStage == 0) {
        if (pContext->tssState[1].dwValue[D3DTSS_COLOROP] != D3DTOP_DISABLE) {
            // This modulates selectarg1(stage0) with texture(stage1) now!
            // The right solution is really to wait and see if there is a stage 1
            // make A: colorArg1(0), make B: texture(nextstage)
            hr = nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
            // This is a bit of a hack here since we use colorarg from stage 0
            // but we get the texture from stage 1 (told to in SelectB)
            dwTemp = pContext->tssState[dwD3DStage].dwValue[D3DTSS_COLORARG2];
            pContext->tssState[dwD3DStage].dwValue[D3DTSS_COLORARG2] = D3DTA_TEXTURE;
            hr |= nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputB, dwHWStage, dwD3DStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);
            // reset back arg2
            pContext->tssState[dwD3DStage].dwValue[D3DTSS_COLORARG2] = dwTemp;
        }
        else {
            // asked to do premodulate on a single texture stage -- just pass down
            // the colorarg1
            hr = nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
            nvKelvinCCSetColorInputOne (pContext, kelvinCombinerInputB, dwHWStage, FALSE);
        }
    }
    else // well, right now we only handle two stages (we could compress these)
    {
        // if pre-modulate is called in stage1, we could modulate with
        // texture from next stage. But, we'd have to handle settexture a bit
        // differently. For now, we'll just use selectarg1
        hr = nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
        nvKelvinCCSetColorInputOne (pContext, kelvinCombinerInputB, dwHWStage, FALSE);

        //DCR check for premodulate on stage 0?
    }

    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinCCModulateAlpha (PNVD3DCONTEXT pContext, DWORD dwHWStage, DWORD dwD3DStage, BOOL bComplement)
{
    HRESULT hr;
    // A * 1
    hr = nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
    nvKelvinCCSetColorInputOne (pContext, kelvinCombinerInputB, dwHWStage, FALSE);
    // Set C alpha(arg1), Set D: arg2
    hr |= nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputC, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, bComplement, FALSE, TRUE);
    hr |= nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputD, dwHWStage, dwD3DStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);
    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinCCModulateColor (PNVD3DCONTEXT pContext, DWORD dwHWStage, DWORD dwD3DStage, BOOL bComplement)
{
    HRESULT hr;
    // A * B
    hr  = nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, bComplement, FALSE, FALSE);
    hr |= nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputB, dwHWStage, dwD3DStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);

    // Set C alpha(arg1), Set D: 1
    hr |= nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputC, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, FALSE, FALSE, TRUE);
    nvKelvinCCSetColorInputOne (pContext, kelvinCombinerInputD, dwHWStage, FALSE);
    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinBumpMap (PNVD3DCONTEXT pContext, DWORD dwHWStage, DWORD dwD3DStage)
{
    HRESULT hr;
    DWORD   dwArg1Cache;

    // this is terribly inefficient. we actually burn up a combiner stage doing nothing at all.
    // to make this better, we need a combiner analog to "nextAvailableTextureUnit" and to allow
    // for the possibility that this doesn't get incremented when we parse a D3D combiner stage.
    if (pContext->tssState[dwD3DStage].dwValue[D3DTSS_TEXTUREMAP] == NULL) {
        pContext->hwState.dwStateFlags |= KELVIN_FLAG_SETUPFAILURE;
        hr = TSS_USES_NULL_TEXTURE;
    }
    else if (pContext->hwState.dwNextAvailableTextureUnit >= KELVIN_NUM_TEXTURES) {
        pContext->hwState.dwStateFlags |= KELVIN_FLAG_SETUPFAILURE;
        // not really OK, but there's nothing we can do about it.
        hr = D3D_OK;
    }
    else {
        // just pass the result of the last stage on to the next
        dwArg1Cache = pContext->tssState[dwD3DStage].dwValue[D3DTSS_COLORARG1];
        pContext->tssState[dwD3DStage].dwValue[D3DTSS_COLORARG1] = D3DTA_CURRENT;
        hr = nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
        pContext->tssState[dwD3DStage].dwValue[D3DTSS_COLORARG1] = dwArg1Cache;
        nvKelvinCCSetColorInputOne (pContext, kelvinCombinerInputB, dwHWStage, FALSE);
        pContext->hwState.dwTexUnitToTexStageMapping[pContext->hwState.dwNextAvailableTextureUnit] = dwD3DStage;
    }

    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinCCDotProduct (PNVD3DCONTEXT pContext, DWORD dwHWStage, DWORD dwD3DStage)
{
    HRESULT hr;
    // Multiply expanded A * expanded B
    hr  = nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, FALSE, TRUE, FALSE);
    hr |= nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputB, dwHWStage, dwD3DStage, D3DTSS_COLORARG2, FALSE, TRUE, FALSE);
    // C & D default to zero
    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinCCMultiplyAdd (PNVD3DCONTEXT pContext, int hdStage, int dxStage)
{
    HRESULT hr;

    // set A to arg1
    hr  = nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputA, hdStage, dxStage, D3DTSS_COLORARG0, FALSE, FALSE, FALSE);
    // set B to 1
    nvKelvinCCSetColorInputOne (pContext, kelvinCombinerInputB, hdStage, FALSE);
    // set C to arg2
    hr |= nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputC, hdStage, dxStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
    // set D to arg3
    hr |= nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputD, hdStage, dxStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);

    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinCCLerp (PNVD3DCONTEXT pContext, int hdStage, int dxStage)
{
    HRESULT hr;

    // Multiply A * B
    hr  = nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputA, hdStage, dxStage, D3DTSS_COLORARG0, FALSE, FALSE, FALSE);
    hr |= nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputB, hdStage, dxStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
    // set C to 1 - arg1
    hr |= nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputC, hdStage, dxStage, D3DTSS_COLORARG0, TRUE, FALSE, FALSE);
    // set D to arg3
    hr |= nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputD, hdStage, dxStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);

    return (hr);
}

//---------------------------------------------------------------------------

// Set up output combiners

void nvConstructKelvinOutputColorCombiners (PNVD3DCONTEXT pContext, BOOL bEnable, DWORD dwStage,
                                            BOOL bBias, DWORD dwShift, BOOL bDotAB, BOOL bDotCD, BOOL bOutTemp)
{
    bOutTemp &= (dwStage != 8); // last stage must go to normal output

    if (!bEnable) {
        nvAssert (dwStage > 0);  // stage 0 should always be enabled
        pContext->hwState.dwColorOCW[dwStage] |= DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_SUM_DST, _REG_0);
        return;
    }

    // select bias operation
    switch (dwShift) {
        case 0:
            pContext->hwState.dwColorOCW[dwStage] |= bBias ?
                                                     DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_OP, _NOSHIFT_BIAS) :
                                                     DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_OP, _NOSHIFT);
            break;
        case 1:
            pContext->hwState.dwColorOCW[dwStage] |= bBias ?
                                                     DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_OP, _SHIFTLEFTBY1_BIAS) :
                                                     DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_OP, _SHIFTLEFTBY1);
            break;
        case 2:
            pContext->hwState.dwColorOCW[dwStage] |= bBias ?
                                                     // we can't shift by 2 and bias. do the best we can...
                                                     DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_OP, _SHIFTLEFTBY1_BIAS) :
                                                     DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_OP, _SHIFTLEFTBY2);
            break;
        default:
            DPF ("illagal shift in nvConstructKelvinOutputColorCombiners");
            dbgD3DError();
            break;
    }  // switch

    // select mux enable
    pContext->hwState.dwColorOCW[dwStage] |= DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_MUX_ENABLE, _FALSE);

    // select dot enables
    if (bDotAB && bDotCD) {
        pContext->hwState.dwColorOCW[dwStage] |= (DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_AB_DOT_ENABLE, _TRUE)           |
                                                  DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_CD_DOT_ENABLE, _TRUE)           |
                                                  DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_BLUETOALPHA_AB, _AB_DST_ENABLE) |
                                                  DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_BLUETOALPHA_CD, _CD_DST_ENABLE));
        pContext->hwState.dwColorOCW[dwStage] |= bOutTemp ?
                                                 DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_SUM_DST, _REG_D) :
                                                 DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_SUM_DST, _REG_C);
    }
    else if (bDotAB) {
        pContext->hwState.dwColorOCW[dwStage] |= (DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_AB_DOT_ENABLE, _TRUE)           |
                                                  DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_CD_DOT_ENABLE, _FALSE)          |
                                                  DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_BLUETOALPHA_AB, _AB_DST_ENABLE) |
                                                  DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_BLUETOALPHA_CD, _DISABLE));
        pContext->hwState.dwColorOCW[dwStage] |= bOutTemp ?
                                                 DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_AB_DST, _REG_D) :
                                                 DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_AB_DST, _REG_C);
    }
    else {
        // select the sum as final result
        pContext->hwState.dwColorOCW[dwStage] |= (DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_AB_DOT_ENABLE, _FALSE)    |
                                                  DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_CD_DOT_ENABLE, _FALSE)    |
                                                  DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_BLUETOALPHA_AB, _DISABLE) |
                                                  DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_BLUETOALPHA_CD, _DISABLE));
        pContext->hwState.dwColorOCW[dwStage] |= bOutTemp ?
                                                 DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_SUM_DST, _REG_D) :
                                                 DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_SUM_DST, _REG_C);
    }

}

//---------------------------------------------------------------------------

BOOL nvConstructKelvinColorCombiners (PNVD3DCONTEXT pContext, DWORD dwHWStage, DWORD dwD3DStage)
{
    DWORD   dwShift;
    BOOL    bDotProduct, bBias, bEnable, bStageActive;
    HRESULT hr = 0;

    bEnable      = TRUE;
    bStageActive = TRUE;
    bDotProduct  = FALSE;
    bBias        = FALSE;
    dwShift      = 0;

    pContext->hwState.dwColorICW[dwHWStage] = 0;
    pContext->hwState.dwColorOCW[dwHWStage] = 0;

    switch (pContext->tssState[dwD3DStage].dwValue[D3DTSS_COLOROP]) {
        default:
        case D3DTOP_DISABLE:
            if (dwD3DStage == 0) { // only construct for stage 0
                // Default is diffuse color, make A=diffuse, B=1, C=D=0
                pContext->hwState.dwColorICW[dwHWStage] |= DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_A_SOURCE, _REG_4);
                nvKelvinCCSetColorInputOne (pContext, kelvinCombinerInputB, dwHWStage, FALSE);
            }
            else {
                bEnable = FALSE; // don't enable output combiner
            }
            bStageActive = FALSE;
            break;
        case D3DTOP_SELECTARG1:
            hr = nvKelvinCCSelect1 (pContext, dwHWStage, dwD3DStage);
            break;
        case D3DTOP_SELECTARG2: // same as 2 from above
            hr = nvKelvinCCSelect2 (pContext, dwHWStage, dwD3DStage);
            break;
        case D3DTOP_MODULATE4X:
            dwShift++;
        case D3DTOP_MODULATE2X:
            dwShift++;
        case D3DTOP_MODULATE:
            hr = nvKelvinCCModulate (pContext, dwHWStage, dwD3DStage);
            break;
        case D3DTOP_ADDSIGNED2X: // same as addsigned with following change
            dwShift = 1;
        case D3DTOP_ADDSIGNED:   // same as add with following change
            bBias = TRUE;
        case D3DTOP_ADD:
            hr = nvKelvinCCAdd (pContext, dwHWStage, dwD3DStage);
            break;
        case D3DTOP_SUBTRACT:
            hr = nvKelvinCCSub (pContext, dwHWStage, dwD3DStage);
            break;
        case D3DTOP_ADDSMOOTH:
            hr = nvKelvinCCAddSmooth (pContext, dwHWStage, dwD3DStage);
            break;
        case D3DTOP_BLENDDIFFUSEALPHA:
            hr = nvKelvinCCBlendAlpha (pContext, dwHWStage, dwD3DStage, D3DTA_DIFFUSE);
            break;
        case D3DTOP_BLENDTEXTUREALPHA:
            hr = nvKelvinCCBlendAlpha (pContext, dwHWStage , dwD3DStage, D3DTA_TEXTURE);
            break;
        case D3DTOP_BLENDFACTORALPHA:
            hr = nvKelvinCCBlendAlpha (pContext, dwHWStage, dwD3DStage, D3DTA_TFACTOR);
            break;
        case D3DTOP_BLENDTEXTUREALPHAPM:
            hr = nvKelvinCCBlendAlpha (pContext, dwHWStage, dwD3DStage, TEXTUREPM);
            break;
        case D3DTOP_BLENDCURRENTALPHA:
            hr = nvKelvinCCBlendAlpha (pContext, dwHWStage, dwD3DStage, D3DTA_CURRENT);
            break;
        case D3DTOP_PREMODULATE:
            hr = nvKelvinCCPremodulate (pContext, dwHWStage, dwD3DStage);
            break;
        case D3DTOP_MODULATEALPHA_ADDCOLOR:
            hr = nvKelvinCCModulateAlpha (pContext, dwHWStage, dwD3DStage, FALSE);
            break;
        case D3DTOP_MODULATECOLOR_ADDALPHA:
            hr = nvKelvinCCModulateColor (pContext, dwHWStage, dwD3DStage, FALSE);
            break;
        case D3DTOP_MODULATEINVALPHA_ADDCOLOR:
            hr = nvKelvinCCModulateAlpha (pContext, dwHWStage, dwD3DStage, TRUE); // complement
            break;
        case D3DTOP_MODULATEINVCOLOR_ADDALPHA:
            hr = nvKelvinCCModulateColor (pContext, dwHWStage, dwD3DStage, TRUE); // complement
            break;
        case D3DTOP_BUMPENVMAP:
        case D3DTOP_BUMPENVMAPLUMINANCE:
            hr = nvKelvinBumpMap (pContext, dwHWStage, dwD3DStage);
            break;
        case D3DTOP_DOTPRODUCT3:
            hr = nvKelvinCCDotProduct (pContext, dwHWStage, dwD3DStage);
            bDotProduct = TRUE;
            break;
        case D3DTOP_MULTIPLYADD:
            hr = nvKelvinCCMultiplyAdd (pContext, dwHWStage, dwD3DStage);
            break;
        case D3DTOP_LERP:
            hr = nvKelvinCCLerp (pContext, dwHWStage, dwD3DStage);
            break;
    }

    if (hr == TSS_USES_NULL_TEXTURE) {
        // this stage references a non-existent texture. just set it back to "select current"
        if (dwHWStage == 0) {
            // current = diffuse in stage 0
            pContext->hwState.dwColorICW[dwHWStage] = DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_A_SOURCE, _REG_4);
        }
        else {
            pContext->hwState.dwColorICW[dwHWStage] = DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_A_SOURCE, _REG_C);
        }
        nvKelvinCCSetColorInputOne (pContext, kelvinCombinerInputB, dwHWStage, FALSE);
    }

    nvConstructKelvinOutputColorCombiners (pContext, bEnable, dwHWStage, bBias, dwShift, bDotProduct, FALSE,
                                           pContext->tssState[dwD3DStage].dwValue[D3DTSS_RESULTARG] == D3DTA_TEMP);

    return (bStageActive);
}

#endif  // NVARCH == 0x20
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\kelvin\src\nvKelvinCompileVS_link.cpp ===
// **************************************************************************
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvKelvinCompileVS_link.cpp
//      a pointer to a shared file
//
// **************************************************************************

#include "nvprecomp.h"
#include "..\..\..\common\nv20\src\vpcompilekelvin.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\kelvin\src\nvKelvinTables.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvKelvinTables.cpp
//      tables of values and constants related to the kelvin object
//
// **************************************************************************
//
//  History:
//       Craig Duttweiler        28Apr2000         NV20 development
//
// **************************************************************************
#include "nvprecomp.h"

#if (NVARCH >= 0x20)

//---------------------------------------------------------------------------

// table of precomputed combiner settings for stupid legacy texture blends.

// the table is indexed as [i][j]
// where i = D3DTBLEND_BLAH
//       j=0 => alpha_icw[0]
//       j=1 => color_icw[0]
//       j=2 => alpha_ocw[0]
//       j=3 => color_ocw[0]

DWORD kelvinTextureBlendSettings[D3D_TBLEND_MAX+1][4] =
{
    // i=0
    // invalid

    ~0,
    ~0,
    ~0,
    ~0,

    // i=1
    // D3DTBLEND_DECAL
    // aPix = aTex
    // cPix = cTex

    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_SOURCE, _REG_8)             |  // aTex0
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_SOURCE, _REG_8)             |  // cTex0
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _OPERATION,  _NOSHIFT) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _MUX_ENABLE, _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _SUM_DST,    _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _AB_DST,     _REG_0)   |  // dev/null
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _CD_DST,     _REG_0),     // dev/null

    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _BLUETOALPHA_AB, _DISABLE) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _BLUETOALPHA_CD, _DISABLE) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _OP,             _NOSHIFT) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _MUX_ENABLE,     _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _AB_DOT_ENABLE,  _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _CD_DOT_ENABLE,  _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _SUM_DST,        _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _AB_DST,         _REG_0)   |  // dev/null
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _CD_DST,         _REG_0),     // dev/null

    // i=2
    // D3DTBLEND_MODULATE
    // aPix = aTex
    // cPix = cTex * cDiffuse

    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_SOURCE, _REG_8)             |  // aTex0
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_SOURCE, _REG_8)             |  // cTex0
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_SOURCE, _REG_4)             |  // cDiffuse
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _OPERATION,  _NOSHIFT) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _MUX_ENABLE, _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _SUM_DST,    _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _AB_DST,     _REG_0)   |  // dev/null
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _CD_DST,     _REG_0),     // dev/null

    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _BLUETOALPHA_AB, _DISABLE) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _BLUETOALPHA_CD, _DISABLE) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _OP,             _NOSHIFT) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _MUX_ENABLE,     _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _AB_DOT_ENABLE,  _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _CD_DOT_ENABLE,  _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _SUM_DST,        _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _AB_DST,         _REG_0)   |  // dev/null
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _CD_DST,         _REG_0),     // dev/null

    // i=3
    // D3DTBLEND_DECALALPHA
    // aPix = aDiffuse
    // cPix = ((1 - aTex) * cDiffuse) + (aTex * cTex)

    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_SOURCE, _REG_4)             |  // aDiffuse
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_SOURCE, _REG_8)             |  // 1-aTex0
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_SOURCE, _REG_4)             |  // cDiffuse
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_SOURCE, _REG_8)             |  // aTex0
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_SOURCE, _REG_8),               // cTex0

    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _OPERATION,  _NOSHIFT) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _MUX_ENABLE, _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _SUM_DST,    _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _AB_DST,     _REG_0)   |  // dev/null
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _CD_DST,     _REG_0),     // dev/null

    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _BLUETOALPHA_AB, _DISABLE) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _BLUETOALPHA_CD, _DISABLE) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _OP,             _NOSHIFT) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _MUX_ENABLE,     _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _AB_DOT_ENABLE,  _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _CD_DOT_ENABLE,  _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _SUM_DST,        _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _AB_DST,         _REG_0)   |  // dev/null
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _CD_DST,         _REG_0),     // dev/null

    // i=4
    // D3DTBLEND_MODULATEALPHA
    // aPix = aTex * aDiffuse
    // cPix = cTex * cDiffuse

    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_SOURCE, _REG_8)             |  // aTex0
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_SOURCE, _REG_4)             |  // aDiffuse
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_SOURCE, _REG_8)             |  // cTex0
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_SOURCE, _REG_4)             |  // cDiffuse
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _OPERATION,  _NOSHIFT) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _MUX_ENABLE, _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _SUM_DST,    _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _AB_DST,     _REG_0)   |  // dev/null
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _CD_DST,     _REG_0),     // dev/null

    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _BLUETOALPHA_AB, _DISABLE) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _BLUETOALPHA_CD, _DISABLE) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _OP,             _NOSHIFT) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _MUX_ENABLE,     _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _AB_DOT_ENABLE,  _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _CD_DOT_ENABLE,  _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _SUM_DST,        _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _AB_DST,         _REG_0)   |  // dev/null
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _CD_DST,         _REG_0),     // dev/null

    // i=5
    // D3DTBLEND_DECALMASK
    // aPix = aDiffuse
    // cPix = lsb(aTex) ? cTex : cDiffuse

    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_SOURCE, _REG_4)             |  // aDiffuse
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_SOURCE, _REG_4)             |  // cDiffuse
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_SOURCE, _REG_8)             |  // cTex0
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _OPERATION,  _NOSHIFT) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _MUX_ENABLE, _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _SUM_DST,    _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _AB_DST,     _REG_0)   |  // dev/null
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _CD_DST,     _REG_0),     // dev/null

    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _BLUETOALPHA_AB, _DISABLE) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _BLUETOALPHA_CD, _DISABLE) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _OP,             _NOSHIFT) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _MUX_ENABLE,     _TRUE)    |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _AB_DOT_ENABLE,  _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _CD_DOT_ENABLE,  _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _SUM_DST,        _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _AB_DST,         _REG_0)   |  // dev/null
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _CD_DST,         _REG_0),     // dev/null

    // i=6
    // D3DTBLEND_MODULATEMASK
    // aPix = aDiffuse
    // cPix = lsb(aTex) ? cTex * cDiffuse : cDiffuse

    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_SOURCE, _REG_4)             |  // aDiffuse
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_SOURCE, _REG_4)             |  // cDiffuse
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_SOURCE, _REG_8)             |  // cTex0
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_SOURCE, _REG_4),               // cDiffuse

    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _OPERATION,  _NOSHIFT) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _MUX_ENABLE, _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _SUM_DST,    _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _AB_DST,     _REG_0)   |  // dev/null
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _CD_DST,     _REG_0),     // dev/null

    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _BLUETOALPHA_AB, _DISABLE) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _BLUETOALPHA_CD, _DISABLE) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _OP,             _NOSHIFT) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _MUX_ENABLE,     _TRUE)    |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _AB_DOT_ENABLE,  _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _CD_DOT_ENABLE,  _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _SUM_DST,        _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _AB_DST,         _REG_0)   |  // dev/null
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _CD_DST,         _REG_0),     // dev/null

    // i=7
    // D3DTBLEND_COPY (same as DECAL)
    // aPix = aTex
    // cPix = cTex

    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_SOURCE, _REG_8)             |  // aTex0
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_SOURCE, _REG_8)             |  // cTex0
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _OPERATION,  _NOSHIFT) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _MUX_ENABLE, _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _SUM_DST,    _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _AB_DST,     _REG_0)   |  // dev/null
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _CD_DST,     _REG_0),     // dev/null

    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _BLUETOALPHA_AB, _DISABLE) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _BLUETOALPHA_CD, _DISABLE) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _OP,             _NOSHIFT) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _MUX_ENABLE,     _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _AB_DOT_ENABLE,  _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _CD_DOT_ENABLE,  _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _SUM_DST,        _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _AB_DST,         _REG_0)   |  // dev/null
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _CD_DST,         _REG_0),     // dev/null

    // i=8
    // D3DTBLEND_ADD
    // aPix = aDiffuse
    // cPix = cTex + cDiffuse

    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_SOURCE, _REG_4)             |  // aDiffuse
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_SOURCE, _REG_8)             |  // cTex0
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_SOURCE, _REG_4)             |  // cDiffuse
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_SOURCE, _REG_0),               // 1

    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _OPERATION,  _NOSHIFT) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _MUX_ENABLE, _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _SUM_DST,    _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _AB_DST,     _REG_0)   |  // dev/null
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _CD_DST,     _REG_0),     // dev/null

    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _BLUETOALPHA_AB, _DISABLE) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _BLUETOALPHA_CD, _DISABLE) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _OP,             _NOSHIFT) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _MUX_ENABLE,     _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _AB_DOT_ENABLE,  _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _CD_DOT_ENABLE,  _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _SUM_DST,        _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _AB_DST,         _REG_0)   |  // dev/null
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _CD_DST,         _REG_0)      // dev/null
};

//---------------------------------------------------------------------------

// combiner settings used when they enable a texture blend but not a texture
// aPix = aDiffuse
// cPix = cDiffuse

DWORD kelvinTextureBlendDefault[4] =
{
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_SOURCE, _REG_4)             |  // aDiffuse
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_SOURCE, _REG_4)             |  // cDiffuse
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _OPERATION,  _NOSHIFT) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _MUX_ENABLE, _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _SUM_DST,    _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _AB_DST,     _REG_0)   |  // dev/null
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _CD_DST,     _REG_0),     // dev/null

    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _BLUETOALPHA_AB, _DISABLE) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _BLUETOALPHA_CD, _DISABLE) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _OP,             _NOSHIFT) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _MUX_ENABLE,     _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _AB_DOT_ENABLE,  _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _CD_DOT_ENABLE,  _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _SUM_DST,        _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _AB_DST,         _REG_0)   |  // dev/null
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _CD_DST,         _REG_0)      // dev/null
};

//---------------------------------------------------------------------------

// table mapping dependencies between d3d renderstates and kelvin state.

// kelvinDirtyBitsFromRenderState[D3DRENDERSTATE_FOO] contains the kelvin class
// dirty bits that should be set whenever D3DRENDERSTATE_FOO is changed

DWORD kelvinDirtyBitsFromRenderState[D3D_RENDERSTATE_MAX+1] =
{
    0,                                                            //  0   invalid
    KELVIN_DIRTY_TEXTURE_STATE | KELVIN_DIRTY_TEXTURE_TRANSFORM | //  1   D3DRENDERSTATE_TEXTUREHANDLE
    KELVIN_DIRTY_COMBINERS_COLOR,
    0,                                                            //  2   D3DRENDERSTATE_ANTIALIAS
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  3   D3DRENDERSTATE_TEXTUREADDRESS
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  4   D3DRENDERSTATE_TEXTUREPERSPECTIVE
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  5   D3DRENDERSTATE_WRAPU
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  6   D3DRENDERSTATE_WRAPV
    KELVIN_DIRTY_TRANSFORM | KELVIN_DIRTY_CONTROL0 |              //  7   D3DRENDERSTATE_ZENABLE
    KELVIN_DIRTY_TEXTURE_STATE | KELVIN_DIRTY_MISC_STATE |
    KELVIN_DIRTY_MISC_STATE,
    KELVIN_DIRTY_MISC_STATE,                                      //  8   D3DRENDERSTATE_FILLMODE
    KELVIN_DIRTY_MISC_STATE,                                      //  9   D3DRENDERSTATE_SHADEMODE
    0,                                                            //  10  D3DRENDERSTATE_LINEPATTERN
    0,                                                            //  11  D3DRENDERSTATE_MONOENABLE
    0,                                                            //  12  D3DRENDERSTATE_ROP2
    KELVIN_DIRTY_MISC_STATE,                                      //  13  D3DRENDERSTATE_PLANEMASK
    KELVIN_DIRTY_MISC_STATE,                                      //  14  D3DRENDERSTATE_ZWRITEENABLE
    KELVIN_DIRTY_MISC_STATE,                                      //  15  D3DRENDERSTATE_ALPHATESTENABLE
    0,                                                            //  16  D3DRENDERSTATE_LASTPIXEL
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  17  D3DRENDERSTATE_TEXTUREMAG
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  18  D3DRENDERSTATE_TEXTUREMIN
    KELVIN_DIRTY_MISC_STATE,                                      //  19  D3DRENDERSTATE_SRCBLEND
    KELVIN_DIRTY_MISC_STATE,                                      //  20  D3DRENDERSTATE_DESTBLEND
    KELVIN_DIRTY_COMBINERS_COLOR,                                 //  21  D3DRENDERSTATE_TEXTUREMAPBLEND
    KELVIN_DIRTY_MISC_STATE,                                      //  22  D3DRENDERSTATE_CULLMODE
    KELVIN_DIRTY_MISC_STATE,                                      //  23  D3DRENDERSTATE_ZFUNC
    KELVIN_DIRTY_MISC_STATE,                                      //  24  D3DRENDERSTATE_ALPHAREF
    KELVIN_DIRTY_MISC_STATE,                                      //  25  D3DRENDERSTATE_ALPHAFUNC
    KELVIN_DIRTY_MISC_STATE,                                      //  26  D3DRENDERSTATE_DITHERENABLE
    KELVIN_DIRTY_MISC_STATE,                                      //  27  D3DRENDERSTATE_ALPHABLENDENABLE
    KELVIN_DIRTY_COMBINERS_SPECFOG | KELVIN_DIRTY_VERTEX_SHADER,  //  28  D3DRENDERSTATE_FOGENABLE
    KELVIN_DIRTY_LIGHTS | KELVIN_DIRTY_COMBINERS_SPECFOG,         //  29  D3DRENDERSTATE_SPECULARENABLE
    0,                                                            //  30  D3DRENDERSTATE_ZVISIBLE
    0,                                                            //  31  D3DRENDERSTATE_SUBPIXEL
    0,                                                            //  32  D3DRENDERSTATE_SUBPIXELX
    0,                                                            //  33  D3DRENDERSTATE_STIPPLEDALPHA
    KELVIN_DIRTY_COMBINERS_SPECFOG,                               //  34  D3DRENDERSTATE_FOGCOLOR
    KELVIN_DIRTY_COMBINERS_SPECFOG | KELVIN_DIRTY_VERTEX_SHADER,  //  35  D3DRENDERSTATE_FOGTABLEMODE
    KELVIN_DIRTY_COMBINERS_SPECFOG,                               //  36  D3DRENDERSTATE_FOGTABLESTART   (D3DRENDERSTATE_FOGSTART)
    KELVIN_DIRTY_COMBINERS_SPECFOG,                               //  37  D3DRENDERSTATE_FOGTABLEEND     (D3DRENDERSTATE_FOGEND)
    KELVIN_DIRTY_COMBINERS_SPECFOG,                               //  38  D3DRENDERSTATE_FOGTABLEDENSITY (D3DRENDERSTATE_FOGDENSITY)
    0,                                                            //  39  D3DRENDERSTATE_STIPPLEENABLE
    KELVIN_DIRTY_MISC_STATE,                                      //  40  D3DRENDERSTATE_EDGEANTIALIAS
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  41  D3DRENDERSTATE_COLORKEYENABLE
    0,                                                            //  42  D3DRENDERSTATE_OLDALPHABLENDENABLE
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  43  D3DRENDERSTATE_BORDERCOLOR
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  44  D3DRENDERSTATE_TEXTUREADDRESSU
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  45  D3DRENDERSTATE_TEXTUREADDRESSV
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  46  D3DRENDERSTATE_MIPMAPLODBIAS
    KELVIN_DIRTY_MISC_STATE,                                      //  47  D3DRENDERSTATE_ZBIAS
    KELVIN_DIRTY_COMBINERS_SPECFOG,                               //  48  D3DRENDERSTATE_RANGEFOGENABLE
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  49  D3DRENDERSTATE_ANISOTROPY
    0,                                                            //  50  D3DRENDERSTATE_FLUSHBATCH
    0,                                                            //  51  D3DRENDERSTATE_TRANSLUCENTSORTINDEPENDENT
    KELVIN_DIRTY_CONTROL0 | KELVIN_DIRTY_MISC_STATE,              //  52  D3DRENDERSTATE_STENCILENABLE
    KELVIN_DIRTY_MISC_STATE,                                      //  53  D3DRENDERSTATE_STENCILFAIL
    KELVIN_DIRTY_MISC_STATE,                                      //  54  D3DRENDERSTATE_STENCILZFAIL
    KELVIN_DIRTY_MISC_STATE,                                      //  55  D3DRENDERSTATE_STENCILPASS
    KELVIN_DIRTY_MISC_STATE,                                      //  56  D3DRENDERSTATE_STENCILFUNC
    KELVIN_DIRTY_MISC_STATE,                                      //  57  D3DRENDERSTATE_STENCILREF
    KELVIN_DIRTY_MISC_STATE,                                      //  58  D3DRENDERSTATE_STENCILMASK
    KELVIN_DIRTY_MISC_STATE,                                      //  59  D3DRENDERSTATE_STENCILWRITEMASK
    KELVIN_DIRTY_MISC_STATE,                                      //  60  D3DRENDERSTATE_TEXTUREFACTOR
    0,                                                            //  61  D3DRENDERSTATE_EVICTMANAGEDTEXTURES
    0,                                                            //  62  D3DRENDERSTATE_SCENECAPTURE
    0,                                                            //  63  invalid
    0,                                                            //  64  D3DRENDERSTATE_STIPPLEPATTERN00
    0,                                                            //  65  D3DRENDERSTATE_STIPPLEPATTERN01
    0,                                                            //  66  D3DRENDERSTATE_STIPPLEPATTERN02
    0,                                                            //  67  D3DRENDERSTATE_STIPPLEPATTERN03
    0,                                                            //  68  D3DRENDERSTATE_STIPPLEPATTERN04
    0,                                                            //  69  D3DRENDERSTATE_STIPPLEPATTERN05
    0,                                                            //  70  D3DRENDERSTATE_STIPPLEPATTERN06
    0,                                                            //  71  D3DRENDERSTATE_STIPPLEPATTERN07
    0,                                                            //  72  D3DRENDERSTATE_STIPPLEPATTERN08
    0,                                                            //  73  D3DRENDERSTATE_STIPPLEPATTERN09
    0,                                                            //  74  D3DRENDERSTATE_STIPPLEPATTERN10
    0,                                                            //  75  D3DRENDERSTATE_STIPPLEPATTERN11
    0,                                                            //  76  D3DRENDERSTATE_STIPPLEPATTERN12
    0,                                                            //  77  D3DRENDERSTATE_STIPPLEPATTERN13
    0,                                                            //  78  D3DRENDERSTATE_STIPPLEPATTERN14
    0,                                                            //  79  D3DRENDERSTATE_STIPPLEPATTERN15
    0,                                                            //  80  D3DRENDERSTATE_STIPPLEPATTERN16
    0,                                                            //  81  D3DRENDERSTATE_STIPPLEPATTERN17
    0,                                                            //  82  D3DRENDERSTATE_STIPPLEPATTERN18
    0,                                                            //  83  D3DRENDERSTATE_STIPPLEPATTERN19
    0,                                                            //  84  D3DRENDERSTATE_STIPPLEPATTERN20
    0,                                                            //  85  D3DRENDERSTATE_STIPPLEPATTERN21
    0,                                                            //  86  D3DRENDERSTATE_STIPPLEPATTERN22
    0,                                                            //  87  D3DRENDERSTATE_STIPPLEPATTERN23
    0,                                                            //  88  D3DRENDERSTATE_STIPPLEPATTERN24
    0,                                                            //  89  D3DRENDERSTATE_STIPPLEPATTERN25
    0,                                                            //  90  D3DRENDERSTATE_STIPPLEPATTERN26
    0,                                                            //  91  D3DRENDERSTATE_STIPPLEPATTERN27
    0,                                                            //  92  D3DRENDERSTATE_STIPPLEPATTERN28
    0,                                                            //  93  D3DRENDERSTATE_STIPPLEPATTERN29
    0,                                                            //  94  D3DRENDERSTATE_STIPPLEPATTERN30
    0,                                                            //  95  D3DRENDERSTATE_STIPPLEPATTERN31
    0,                                                            //  96  invalid
    0,                                                            //  97  invalid
    0,                                                            //  98  invalid
    0,                                                            //  99  invalid
    0,                                                            //  100 invalid
    0,                                                            //  101 invalid
    0,                                                            //  102 invalid
    0,                                                            //  103 invalid
    0,                                                            //  104 invalid
    0,                                                            //  105 invalid
    0,                                                            //  106 invalid
    0,                                                            //  107 invalid
    0,                                                            //  108 invalid
    0,                                                            //  109 invalid
    0,                                                            //  110 invalid
    0,                                                            //  111 invalid
    0,                                                            //  112 invalid
    0,                                                            //  113 invalid
    0,                                                            //  114 invalid
    0,                                                            //  115 invalid
    0,                                                            //  116 invalid
    0,                                                            //  117 invalid
    0,                                                            //  118 invalid
    0,                                                            //  119 invalid
    0,                                                            //  120 invalid
    0,                                                            //  121 invalid
    0,                                                            //  122 invalid
    0,                                                            //  123 invalid
    0,                                                            //  124 invalid
    0,                                                            //  125 invalid
    0,                                                            //  126 invalid
    0,                                                            //  127 invalid
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  128 D3DRENDERSTATE_WRAP0
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  129 D3DRENDERSTATE_WRAP1
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  130 D3DRENDERSTATE_WRAP2
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  131 D3DRENDERSTATE_WRAP3
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  132 D3DRENDERSTATE_WRAP4
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  133 D3DRENDERSTATE_WRAP5
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  134 D3DRENDERSTATE_WRAP6
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  135 D3DRENDERSTATE_WRAP7
    0,                                                            //  136 D3DRENDERSTATE_CLIPPING
    KELVIN_DIRTY_LIGHTS,                                          //  137 D3DRENDERSTATE_LIGHTING
    0,                                                            //  138 D3DRENDERSTATE_EXTENTS
    KELVIN_DIRTY_LIGHTS,                                          //  139 D3DRENDERSTATE_AMBIENT
    KELVIN_DIRTY_COMBINERS_SPECFOG | KELVIN_DIRTY_VERTEX_SHADER,  //  140 D3DRENDERSTATE_FOGVERTEXMODE
    KELVIN_DIRTY_LIGHTS,                                          //  141 D3DRENDERSTATE_COLORVERTEX
    KELVIN_DIRTY_LIGHTS,                                          //  142 D3DRENDERSTATE_LOCALVIEWER
    KELVIN_DIRTY_TRANSFORM,                                       //  143 D3DRENDERSTATE_NORMALIZENORMALS
    0,                                                            //  144 D3DRENDERSTATE_COLORKEYBLENDENABLE
    KELVIN_DIRTY_LIGHTS,                                          //  145 D3DRENDERSTATE_DIFFUSEMATERIALSOURCE
    KELVIN_DIRTY_LIGHTS,                                          //  146 D3DRENDERSTATE_SPECULARMATERIALSOURCE
    KELVIN_DIRTY_LIGHTS,                                          //  147 D3DRENDERSTATE_AMBIENTMATERIALSOURCE
    KELVIN_DIRTY_LIGHTS,                                          //  148 D3DRENDERSTATE_EMISSIVEMATERIALSOURCE
    KELVIN_DIRTY_LIGHTS,                                          //  149 D3DRENDERSTATE_ALPHASOURCE
    KELVIN_DIRTY_LIGHTS,                                          //  150 D3DRENDERSTATE_FOGFACTORSOURCE
    KELVIN_DIRTY_MISC_STATE | KELVIN_DIRTY_TRANSFORM,             //  151 D3DRENDERSTATE_VERTEXBLEND
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  152 D3DRENDERSTATE_CLIPPLANEENABLE
    0,                                                            //  153 D3DRENDERSTATE_SOFTWAREVEXTEXPROCESSING
    KELVIN_DIRTY_MISC_STATE,                                      //  154 D3DRENDERSTATE_POINTSIZE
    KELVIN_DIRTY_MISC_STATE,                                      //  155 D3DRENDERSTATE_POINTSIZEMIN
    KELVIN_DIRTY_MISC_STATE |                                     //
    KELVIN_DIRTY_TEXTURE_STATE | KELVIN_DIRTY_COMBINERS_COLOR,    //  156 D3DRENDERSTATE_POINTSPRITEENABLE
    KELVIN_DIRTY_MISC_STATE | KELVIN_DIRTY_TEXTURE_STATE,         //  157 D3DRENDERSTATE_POINTSCALEENABLE
    KELVIN_DIRTY_MISC_STATE,                                      //  158 D3DRENDERSTATE_POINTSCALEA
    KELVIN_DIRTY_MISC_STATE,                                      //  159 D3DRENDERSTATE_POINTSCALEB
    KELVIN_DIRTY_MISC_STATE,                                      //  150 D3DRENDERSTATE_POINTSCALEC
    0,                                                            //  161 D3DRS_MULTISAMPLEANTIALIAS
    KELVIN_DIRTY_MISC_STATE,                                      //  162 D3DRS_MULTISAMPLEMASK
    0,                                                            //  163 D3DRENDERSTATE_COLORKEYMASK
    0,                                                            //  164 D3DRS_PATCHSEGMENTS
    0,                                                            //  165 D3DRS_DEBUGMONITORTOKEN
    0,                                                            //  166 D3DRS_POINTSIZE_MAX
    0,                                                            //  167 D3DRS_INDEXEDVERTEXBLENDENABLE
    KELVIN_DIRTY_MISC_STATE,                                      //  168 D3DRS_COLORWRITEENABLE
    0,                                                            //  169 invalid
    0,                                                            //  170 D3DRS_TWEENFACTOR
    KELVIN_DIRTY_MISC_STATE                                       //  171 D3DRS_BLENDOP
};

//---------------------------------------------------------------------------

// table mapping dependencies between d3d texture stage state and kelvin state.

// kelvinDirtyBitsFromTextureStageState[D3DTSS_FOO] contains the kelvin class
// dirty bits that should be set whenever D3DTSS_FOO is changed

DWORD kelvinDirtyBitsFromTextureStageState[D3D_TEXSTAGESTATE_MAX+1] =
{
    KELVIN_DIRTY_TEXTURE_STATE | KELVIN_DIRTY_TEXTURE_TRANSFORM | //  0  D3DTSS_TEXTUREMAP
    KELVIN_DIRTY_COMBINERS_COLOR | KELVIN_DIRTY_PIXEL_SHADER,
    KELVIN_DIRTY_TEXTURE_TRANSFORM | KELVIN_DIRTY_COMBINERS_COLOR,//  1  D3DTSS_COLOROP
    KELVIN_DIRTY_COMBINERS_COLOR,                                 //  2  D3DTSS_COLORARG1
    KELVIN_DIRTY_COMBINERS_COLOR,                                 //  3  D3DTSS_COLORARG2
    KELVIN_DIRTY_COMBINERS_COLOR,                                 //  4  D3DTSS_ALPHAOP
    KELVIN_DIRTY_COMBINERS_COLOR,                                 //  5  D3DTSS_ALPHAARG1
    KELVIN_DIRTY_COMBINERS_COLOR,                                 //  6  D3DTSS_ALPHAARG2
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  7  D3DTSS_BUMPENVMAT00
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  8  D3DTSS_BUMPENVMAT01
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  9  D3DTSS_BUMPENVMAT10
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  10 D3DTSS_BUMPENVMAT11
    KELVIN_DIRTY_TEXTURE_TRANSFORM | KELVIN_DIRTY_TEXTURE_STATE | //  11 D3DTSS_TEXCOORDINDEX
    KELVIN_DIRTY_FVF,
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  12 D3DTSS_ADDRESS
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  13 D3DTSS_ADDRESSU
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  14 D3DTSS_ADDRESSV
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  15 D3DTSS_BORDERCOLOR
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  16 D3DTSS_MAGFILTER
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  17 D3DTSS_MINFILTER
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  18 D3DTSS_MIPFILTER
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  19 D3DTSS_MIPMAPLODBIAS
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  20 D3DTSS_MAXMIPLEVEL
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  21 D3DTSS_MAXANISOTROPY
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  22 D3DTSS_BUMPENVLSCALE
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  23 D3DTSS_BUMPENVLOFFSET
    KELVIN_DIRTY_TEXTURE_TRANSFORM,                               //  24 D3DTSS_TEXTURETRANSFORMFLAGS
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  25 D3DTSS_ADDRESSW
    KELVIN_DIRTY_COMBINERS_COLOR,                                 //  26 D3DTSS_COLORARG0
    KELVIN_DIRTY_COMBINERS_COLOR,                                 //  27 D3DTSS_ALPHAARG0
    KELVIN_DIRTY_COMBINERS_COLOR                                  //  28 D3DTSS_RESULTARG
};

//---------------------------------------------------------------------------

// table mapping dp2ops to the kelvin method values associated with them.
// these are defined in term of NV097_SET_BEGIN_END_OP_X but the same values
// are used for all enumerants of type NV097_SET_BEGIN_ENDX_OP_X

DWORD kelvinBeginEndOp[D3D_DP2OP_MAX+1] =
{
    ~0,                                          //   0  invalid
    NV097_SET_BEGIN_END_OP_POINTS,               //   1  D3DDP2OP_POINTS
    NV097_SET_BEGIN_END_OP_LINES,                //   2  D3DDP2OP_INDEXEDLINELIST
    NV097_SET_BEGIN_END_OP_TRIANGLES,            //   3  D3DDP2OP_INDEXEDTRIANGLELIST
    ~0,                                          //   4  invalid
    ~0,                                          //   5  invalid
    ~0,                                          //   6  invalid
    ~0,                                          //   7  invalid
    ~0,                                          //   8  D3DDP2OP_RENDERSTATE
    ~0,                                          //   9  invalid
    ~0,                                          //  10  invalid
    ~0,                                          //  11  invalid
    ~0,                                          //  12  invalid
    ~0,                                          //  13  invalid
    ~0,                                          //  14  invalid
    NV097_SET_BEGIN_END_OP_LINES,                //  15  D3DDP2OP_LINELIST
    NV097_SET_BEGIN_END_OP_LINE_STRIP,           //  16  D3DDP2OP_LINESTRIP
    NV097_SET_BEGIN_END_OP_LINE_STRIP,           //  17  D3DDP2OP_INDEXEDLINESTRIP
    NV097_SET_BEGIN_END_OP_TRIANGLES,            //  18  D3DDP2OP_TRIANGLELIST
    NV097_SET_BEGIN_END_OP_TRIANGLE_STRIP,       //  19  D3DDP2OP_TRIANGLESTRIP
    NV097_SET_BEGIN_END_OP_TRIANGLE_STRIP,       //  20  D3DDP2OP_INDEXEDTRIANGLESTRIP
    NV097_SET_BEGIN_END_OP_TRIANGLE_FAN,         //  21  D3DDP2OP_TRIANGLEFAN
    NV097_SET_BEGIN_END_OP_TRIANGLE_FAN,         //  22  D3DDP2OP_INDEXEDTRIANGLEFAN
    NV097_SET_BEGIN_END_OP_TRIANGLE_FAN,         //  23  D3DDP2OP_TRIANGLEFAN_IMM
    NV097_SET_BEGIN_END_OP_LINES,                //  24  D3DDP2OP_LINELIST_IMM
    ~0,                                          //  25  D3DDP2OP_TEXTURESTAGESTATE
    NV097_SET_BEGIN_END_OP_TRIANGLES,            //  26  D3DDP2OP_INDEXEDTRIANGLELIST2
    NV097_SET_BEGIN_END_OP_LINES,                //  27  D3DDP2OP_INDEXEDLINELIST2
    ~0,                                          //  28  D3DDP2OP_VIEWPORTINFO
    ~0,                                          //  29  D3DDP2OP_WINFO
    ~0,                                          //  30  D3DDP2OP_SETPALETTE
    ~0,                                          //  31  D3DDP2OP_UPDATEPALETTE
    ~0,                                          //  32  D3DDP2OP_ZRANGE
    ~0,                                          //  33  D3DDP2OP_SETMATERIAL
    ~0,                                          //  34  D3DDP2OP_SETLIGHT
    ~0,                                          //  35  D3DDP2OP_CREATELIGHT
    ~0,                                          //  36  D3DDP2OP_SETTRANSFORM
    ~0,                                          //  37  D3DDP2OP_EXT
    ~0,                                          //  38  D3DDP2OP_TEXBLT
    ~0,                                          //  39  D3DDP2OP_STATESET
    ~0,                                          //  40  D3DDP2OP_SETPRIORITY
    ~0,                                          //  41  D3DDP2OP_SETRENDERTARGET
    ~0,                                          //  42  D3DDP2OP_CLEAR
    ~0,                                          //  43  D3DDP2OP_SETTEXLOD
    ~0                                           //  44  D3DDP2OP_SETCLIPPLANE
};

//---------------------------------------------------------------------------

// table mapping d3d vertex types to kelvin vertex sizes
DWORD kelvinVertexSize[8] = {
    NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_1,   // D3DVSDT_FLOAT1    0x00
    NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_2,   // D3DVSDT_FLOAT2    0x01
    NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_3,   // D3DVSDT_FLOAT3    0x02
    NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_4,   // D3DVSDT_FLOAT4    0x03
    NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_4,   // D3DVSDT_D3DCOLOR  0x04
    NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_4,   // D3DVSDT_UBYTE4    0x05
    NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_2,   // D3DVSDT_SHORT2    0x06
    NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_4    // D3DVSDT_SHORT4    0x07
};

//---------------------------------------------------------------------------

// table mapping d3d vertex types to kelvin vertex types
DWORD kelvinVertexType[8] = {
    NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_F,      // D3DVSDT_FLOAT1    0x00
    NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_F,      // D3DVSDT_FLOAT2    0x01
    NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_F,      // D3DVSDT_FLOAT3    0x02
    NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_F,      // D3DVSDT_FLOAT4    0x03
    NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_UB_D3D, // D3DVSDT_D3DCOLOR  0x04
    NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_UB_D3D, // D3DVSDT_UBYTE4    0x05 !!! BUG BUG !!!
    NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K,     // D3DVSDT_SHORT2    0x06
    NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K      // D3DVSDT_SHORT4    0x07
};

//---------------------------------------------------------------------------

// table mapping dp2ops to derivative information such as the scale and bias
// required to calculate the number of vertices from the number of primitives.

// nibble 0: bias
// nibble 1: scale (numVertices = scale * numPrimitives + bias)
// nibble 2: scale + bias (= number of vertices in one primitive)
// nibble 3: flags

DWORD kelvinPrimitiveToPrimitiveMagic[D3D_DP2OP_MAX+1] =
{
    ~0,                                          //   0  invalid
    0x00010100,                                  //   1  D3DDP2OP_POINTS
    0x00020200,                                  //   2  D3DDP2OP_INDEXEDLINELIST
    0x00030300,                                  //   3  D3DDP2OP_INDEXEDTRIANGLELIST
    ~0,                                          //   4  invalid
    ~0,                                          //   5  invalid
    ~0,                                          //   6  invalid
    ~0,                                          //   7  invalid
    ~0,                                          //   8  D3DDP2OP_RENDERSTATE
    ~0,                                          //   9  invalid
    ~0,                                          //  10  invalid
    ~0,                                          //  11  invalid
    ~0,                                          //  12  invalid
    ~0,                                          //  13  invalid
    ~0,                                          //  14  invalid
    0x00020200,                                  //  15  D3DDP2OP_LINELIST
    0x00020101,                                  //  16  D3DDP2OP_LINESTRIP
    0x00020101,                                  //  17  D3DDP2OP_INDEXEDLINESTRIP
    0x00030300,                                  //  18  D3DDP2OP_TRIANGLELIST
    0x40030102,                                  //  19  D3DDP2OP_TRIANGLESTRIP
    0x40030102,                                  //  20  D3DDP2OP_INDEXEDTRIANGLESTRIP
    0x80030102,                                  //  21  D3DDP2OP_TRIANGLEFAN
    0x80030102,                                  //  22  D3DDP2OP_INDEXEDTRIANGLEFAN
    0x80030102,                                  //  23  D3DDP2OP_TRIANGLEFAN_IMM
    0x00020200,                                  //  24  D3DDP2OP_LINELIST_IMM
    ~0,                                          //  25  D3DDP2OP_TEXTURESTAGESTATE
    0x00030300,                                  //  26  D3DDP2OP_INDEXEDTRIANGLELIST2
    0x00020200,                                  //  27  D3DDP2OP_INDEXEDLINELIST2
    ~0,                                          //  28  D3DDP2OP_VIEWPORTINFO
    ~0,                                          //  29  D3DDP2OP_WINFO
    ~0,                                          //  30  D3DDP2OP_SETPALETTE
    ~0,                                          //  31  D3DDP2OP_UPDATEPALETTE
    ~0,                                          //  32  D3DDP2OP_ZRANGE
    ~0,                                          //  33  D3DDP2OP_SETMATERIAL
    ~0,                                          //  34  D3DDP2OP_SETLIGHT
    ~0,                                          //  35  D3DDP2OP_CREATELIGHT
    ~0,                                          //  36  D3DDP2OP_SETTRANSFORM
    ~0,                                          //  37  D3DDP2OP_EXT
    ~0,                                          //  38  D3DDP2OP_TEXBLT
    ~0,                                          //  39  D3DDP2OP_STATESET
    ~0,                                          //  40  D3DDP2OP_SETPRIORITY
    ~0,                                          //  41  D3DDP2OP_SETRENDERTARGET
    ~0,                                          //  42  D3DDP2OP_CLEAR
    ~0,                                          //  43  D3DDP2OP_SETTEXLOD
    ~0                                           //  44  D3DDP2OP_SETCLIPPLANE
};


//---------------------------------------------------------------------------

// table mapping dp2ops to a name humans understand

#ifdef DEBUG
char* kelvinPrimitiveName[D3D_DP2OP_MAX+1] =
{
    "oops",                                      //   0  invalid
    "points",                                    //   1  D3DDP2OP_POINTS
    "indexed line list",                         //   2  D3DDP2OP_INDEXEDLINELIST
    "indexed tri list",                          //   3  D3DDP2OP_INDEXEDTRIANGLELIST
    "oops",                                      //   4  invalid
    "oops",                                      //   5  invalid
    "oops",                                      //   6  invalid
    "oops",                                      //   7  invalid
    "oops",                                      //   8  D3DDP2OP_RENDERSTATE
    "oops",                                      //   9  invalid
    "oops",                                      //  10  invalid
    "oops",                                      //  11  invalid
    "oops",                                      //  12  invalid
    "oops",                                      //  13  invalid
    "oops",                                      //  14  invalid
    "line list",                                 //  15  D3DDP2OP_LINELIST
    "line strip",                                //  16  D3DDP2OP_LINESTRIP
    "indexed line strip",                        //  17  D3DDP2OP_INDEXEDLINESTRIP
    "tri list",                                  //  18  D3DDP2OP_TRIANGLELIST
    "tri strip",                                 //  19  D3DDP2OP_TRIANGLESTRIP
    "indexed tri strip",                         //  20  D3DDP2OP_INDEXEDTRIANGLESTRIP
    "tri fan",                                   //  21  D3DDP2OP_TRIANGLEFAN
    "indexed tri fan",                           //  22  D3DDP2OP_INDEXEDTRIANGLEFAN
    "tri fan imm",                               //  23  D3DDP2OP_TRIANGLEFAN_IMM
    "line list imm",                             //  24  D3DDP2OP_LINELIST_IMM
    "oops",                                      //  25  D3DDP2OP_TEXTURESTAGESTATE
    "indexed tri list 2",                        //  26  D3DDP2OP_INDEXEDTRIANGLELIST2
    "indexed line list 2",                       //  27  D3DDP2OP_INDEXEDLINELIST2
    "oops",                                      //  28  D3DDP2OP_VIEWPORTINFO
    "oops",                                      //  29  D3DDP2OP_WINFO
    "oops",                                      //  30  D3DDP2OP_SETPALETTE
    "oops",                                      //  31  D3DDP2OP_UPDATEPALETTE
    "oops",                                      //  32  D3DDP2OP_ZRANGE
    "oops",                                      //  33  D3DDP2OP_SETMATERIAL
    "oops",                                      //  34  D3DDP2OP_SETLIGHT
    "oops",                                      //  35  D3DDP2OP_CREATELIGHT
    "oops",                                      //  36  D3DDP2OP_SETTRANSFORM
    "oops",                                      //  37  D3DDP2OP_EXT
    "oops",                                      //  38  D3DDP2OP_TEXBLT
    "oops",                                      //  39  D3DDP2OP_STATESET
    "oops",                                      //  40  D3DDP2OP_SETPRIORITY
    "oops",                                      //  41  D3DDP2OP_SETRENDERTARGET
    "oops",                                      //  42  D3DDP2OP_CLEAR
    "oops",                                      //  43  D3DDP2OP_SETTEXLOD
    "oops"                                       //  44  D3DDP2OP_SETCLIPPLANE
};
#endif

#endif  // NVARCH >= 0x020
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\kelvin\src\nvKelvinStateHelp.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvhwState.kelvin.cpp
//      Kelvin state management routines.
//
// **************************************************************************
//
//  History:
//      Craig Duttweiler        26Apr2000         NV20 development
//
// **************************************************************************
#include "nvprecomp.h"

#if (NVARCH >= 0x20)

//---------------------------------------------------------------------------

#define KELVIN_VALIDATE_FAIL(reason)    \
{                                       \
    pvtssd->dwNumPasses = 0xffffffff;   \
    pvtssd->ddrval = reason;            \
    dbgTracePop();                      \
    return (DDHAL_DRIVER_HANDLED);      \
}

//---------------------------------------------------------------------------

DWORD nvKelvinValidateTextureStageState
(
    LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA pvtssd
)
{
    dbgTracePush ("nvKelvinValidateTextureStageState");

    // get the context
    PNVD3DCONTEXT pContext;
    NV_SET_CONTEXT (pContext, pvtssd);

    // update everything
    pContext->hwState.dwDirtyFlags = KELVIN_DIRTY_REALLY_FILTHY;
    nvSetKelvinState (pContext);

    // make sure the setup went smoothly
    if (pContext->hwState.dwStateFlags & KELVIN_FLAG_SETUPFAILURE) {
        KELVIN_VALIDATE_FAIL (D3DERR_CONFLICTINGRENDERSTATE);
    }

    // everything is kosher. set return values and return OK
    pvtssd->dwNumPasses = 1;
    pvtssd->ddrval      = D3D_OK;

    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);
}

//---------------------------------------------------------------------------

// returns the size (in bytes) of an inlined vertex

DWORD nvKelvinInlineVertexStride
(
    PNVD3DCONTEXT pContext
)
{
    DWORD dwStride, dwHWStage, dwD3DStage, dwTCIndex, dwVAIndex;

    CVertexShader *pShader = pContext->pCurrentVShader;

    dwStride  = 0;
    dwStride += pShader->getVASize(defaultInputRegMap[D3DVSDE_POSITION]);
    dwStride += pShader->getVASize(defaultInputRegMap[D3DVSDE_BLENDWEIGHT]);
    dwStride += pShader->getVASize(defaultInputRegMap[D3DVSDE_NORMAL]);
    dwStride += pShader->getVASize(defaultInputRegMap[D3DVSDE_DIFFUSE]);
    dwStride += pShader->getVASize(defaultInputRegMap[D3DVSDE_SPECULAR]);
    // fog distance
    dwStride += pShader->getVASize(defaultInputRegMap[D3DVSDE_PSIZE]);
    // back diffuse
    // back specular
    for (dwHWStage=0; dwHWStage < KELVIN_NUM_TEXTURES; dwHWStage++) {
        if (pContext->hwState.dwStateFlags & KELVIN_FLAG_USERTEXCOORDSNEEDED(dwHWStage)) {
            // the app needs texture N and provided us with one
            dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[dwHWStage];
            nvAssert (dwD3DStage != KELVIN_UNUSED);
            dwTCIndex = (pContext->hwState.dwTexCoordIndices >> (8*dwHWStage)) & 0xff;
            dwVAIndex = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
            nvAssert (pShader->getVASize(dwVAIndex));  // they better have given us coordinates
            dwStride += pShader->getVASize(dwVAIndex);
        }
    }

    return (dwStride);
}

#endif // (NVARCH >= 0x020)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\kelvin\src\nvKelvinVbPrim.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvKelvinVbPrim.cpp
//       indexed and ordered vb primitives
//
//***************************************************************************
//
//  History:
//       Craig Duttweiler         10Aug2000         ported from celsius
//
//***************************************************************************
#include "nvprecomp.h"

#if (NVARCH >= 0x20)

#include "x86.h"

#ifdef KELVIN_ILC

//////////////////////////////////////////////////////////////////////////////
// aliases
//
#define ilcData         global.dwILCData
#define ilcCount        global.dwILCCount
#define ilcMax          global.dwILCMax

//////////////////////////////////////////////////////////////////////////////
// externals
//
void ILCCompile_mul                      (DWORD reg,DWORD num);
void nvKelvinILCompile_beginEnd              (DWORD dwPrimType);
void nvKelvinILCompile_computeIndexAndOffset (DWORD dwVBStride,DWORD dwVBLogStride);
void nvKelvinILCompile_memcpy                 (DWORD dwCount, bool recurse);
void nvKelvinILCompile_indexcpy               (DWORD dwCount);
void nvKelvinILCompile_copyVertex            (PNVD3DCONTEXT pContext,DWORD dwFlags);
void nvKelvinILCompile_prefetch              (BOOL bIsIndexed,BOOL bLegacyStrides);
void nvKelvinILCompile_limit                 (DWORD regLimit,DWORD regDummy);

void __stdcall nvKelvinDispatchGetFreeSpace   (PNVD3DCONTEXT pContext);
void __stdcall nvKelvinDispatchGetPusherSpace (void);
#ifdef DEBUG
void __stdcall nvKelvinDispatchFlush          (void);
void __stdcall nvKelvinDispatchPrintVertex    (PNVD3DCONTEXT pContext,DWORD dwPutAddress);
#endif

//---------------------------------------------------------------------------

// vb primitive

DWORD nvKelvinILCompile_vb_prim
(
    PNVD3DCONTEXT pContext,
    DWORD         dwFlags
)
{
    //
    // get loop constants
    //
    DWORD  dwMagic                = kelvinPrimitiveToPrimitiveMagic[dwFlags & KELVIN_ILMASK_PRIMTYPE];
    DWORD  dwVerticesPerPrim      = (dwMagic >> 8) & 0xff;
    DWORD  dwStartVerticesPerPrim = (dwMagic >> 0) & 0xff;
    BOOL   bLegacyStrides         = dwFlags & KELVIN_ILFLAG_LEGACY;
    BOOL   bIsIndexed             = (dwFlags & KELVIN_ILMASK_LOOPTYPE) == KELVIN_ILFLAG_IX_VB_PRIM;

    //
    // align entry point
    //
    while (ilcCount & 31) { xINT3 }
    DWORD lEntry;
    xLABEL (lEntry);
    //
    // setup stack frame
    //
    xPUSH_r     (rEBP)
    xPUSH_r     (rEBX)
    xPUSH_r     (rESI)
    xPUSH_r     (rEDI)

    //
    // verify that we are using the correct inner loop - debug only
    //
#ifdef DEBUG
    DWORD ld1,ld2;
    xLABEL      (ld1)
    xJMP        (0)
    xLABEL      (ld2)
    xINT3

#define CHECK(a,x)                  \
{                                   \
    xMOV_rm_imm (rmREG(rEBX),a)     \
    xMOV_rm_imm (rmREG(rEAX),x)     \
    xCMP_r_i32  (rEAX,mMEM32(x))    \
    xJNZ32      (ld2)               \
}
#define CHECK2(a,x,y,t)             \
{                                   \
    xMOV_r_i32  (rEDX,mMEM32(global.kelvin.x))    \
    xMOV_rm_imm (rmREG(rEBX),a)     \
    xMOV_rm_imm (rmREG(rEAX),x->y)   \
    xCMP_r_rm   (rEAX,rmIND32(rEDX)) xOFS32(OFFSETOF(t,y)) \
    xJNZ32      (ld2)               \
}

    xTARGET_jmp (ld1)

/*
    CHECK (0x00000000,fvfData.dwVertexStride)

    CHECK (0x00010000,fvfData.dwVertexType)

    CHECK (0x00020000,fvfData.dwUVCount[0])
    CHECK (0x00020001,fvfData.dwUVCount[1])
    CHECK (0x00020002,fvfData.dwUVCount[2])
    CHECK (0x00020003,fvfData.dwUVCount[3])
    CHECK (0x00020004,fvfData.dwUVCount[4])
    CHECK (0x00020005,fvfData.dwUVCount[5])
    CHECK (0x00020006,fvfData.dwUVCount[6])
    CHECK (0x00020007,fvfData.dwUVCount[7])

    CHECK (0x00030000,fvfData.dwUVOffset[0])
    CHECK (0x00030001,fvfData.dwUVOffset[1])
    CHECK (0x00030002,fvfData.dwUVOffset[2])
    CHECK (0x00030003,fvfData.dwUVOffset[3])
    CHECK (0x00030004,fvfData.dwUVOffset[4])
    CHECK (0x00030005,fvfData.dwUVOffset[5])
    CHECK (0x00030006,fvfData.dwUVOffset[6])
    CHECK (0x00030007,fvfData.dwUVOffset[7])
*/

    //  - pContext->hwState.dwStateFlags & KELVIN_MASK_INNERLOOPUNIQUENESS
    xMOV_r_i32  (rEDX,mMEM32(global.kelvin.pContext))
    xMOV_rm_imm (rmREG(rEBX),0x00040000)
    xMOV_r_rm   (rEAX,rmIND32(rEDX)) xOFS32(OFFSETOF(NVD3DCONTEXT, hwState.dwStateFlags))
    xAND_rm_imm (rmREG(rEAX),KELVIN_MASK_INNERLOOPUNIQUENESS)
    xCMP_rm_imm (rmREG(rEAX),pContext->hwState.dwStateFlags & KELVIN_MASK_INNERLOOPUNIQUENESS)
    xJNZ32      (ld2)

    if (pContext->hwState.dwStateFlags & KELVIN_FLAG_USERTEXCOORDSNEEDED(0))
    {
        CHECK2 (0x00050000,pContext,hwState.dwTexUnitToTexStageMapping[0],NVD3DCONTEXT)
    }
    if (pContext->hwState.dwStateFlags & KELVIN_FLAG_USERTEXCOORDSNEEDED(1))
    {
        CHECK2 (0x00050001,pContext,hwState.dwTexUnitToTexStageMapping[1],NVD3DCONTEXT)
    }
#endif

    //
    // setup push buffer
    //
    xMOV_r_i32  (rEDX,mMEM32(pDriverData))
    xMOV_r_rm   (rEDI,rmIND32(rEDX)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))

    //
    // start prim
    //
    xMOV_rm_imm (rmREG(rEAX),((sizeSetNv20KelvinBeginEndMthdCnt << 2) << 16) | ((NV_DD_KELVIN) << 13) | NV097_SET_BEGIN_END);
    xMOV_rm_imm (rmREG(rECX),kelvinBeginEndOp[dwFlags & KELVIN_ILMASK_PRIMTYPE])
    xMOV_rm_r   (rmIND(rEDI),rEAX)
    xMOV_rm_r   (rmIND8(rEDI),rECX) xOFS8(4)
    xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(8)

    //
    // do work
    //
    if (bIsIndexed)
    {
        //
        // indexed VB
        //

        //
        // setup prefetcher
        //
        xMOV_r_i32  (rEBX,mMEM32(global.kelvin.dwPrimCount))
        ILCCompile_mul (rEBX,bLegacyStrides ? 4 : dwVerticesPerPrim);
        if (dwStartVerticesPerPrim)
        {
            xADD_rm_imm (rmREG(rEBX),dwStartVerticesPerPrim)
        }
        xLEA_r_rm   (rECX,rmSIB) xSIB(rEBX,rEBX,x1)

        xMOV_r_i32  (rEAX,mMEM32(global.kelvin.pIndices))
        xADD_r_rm   (rECX,rmREG(rEAX))
        xMOV_i32_r  (mMEM32(global.kelvin.dwPrefetchBase),rEAX)
        xMOV_i32_r  (mMEM32(global.kelvin.dwPrefetchMax),rECX)

        //
        // send indices
        //
        xMOV_r_i32  (rESI,mMEM32(global.kelvin.pIndices))
        DWORD labelNext;
        xLABEL      (labelNext)

        //
        // prefetch
        //
        DWORD labelPrefetch1;
        DWORD labelPrefetch2;
        DWORD labelPrefetch3;
        xMOV_r_i32  (rEDX,mMEM32(global.kelvin.dwPrefetchBase))
        xCMP_r_rm   (rEDX,rmREG(rESI))
        xLABEL      (labelPrefetch1)
        xJA32       (0)

        xMOV_rm_imm (rmREG(rECX),2048 / 32)
        xLABEL      (labelPrefetch2)
        {
            xCMP_r_i32  (rEDX,mMEM32(global.kelvin.dwPrefetchMax))
            xLABEL      (labelPrefetch3)
            xJAE32      (0)
            xMOV_r_rm   (rEAX,rmIND(rEDX))
            xDEC_rm     (rmREG(rECX))
            xLEA_r_rm   (rEDX,rmIND8(rEDX)) xOFS8(32)
            xJNZ32      (labelPrefetch2)
        }
        xTARGET_b32 (labelPrefetch3)
        xMOV_i32_r  (mMEM32(global.kelvin.dwPrefetchBase),rEDX)
        xTARGET_b32 (labelPrefetch1)

        //
        // copy indices
        //
        if (bLegacyStrides)
        {
            //
            // legacy - pretty simple since it MUST be a tri list
            //          source = index0:16,index1:16,index2:16,flags:16
            //
            xMOV_r_rm   (rEAX,rmIND(rESI))
            xMOV_r_rm   (rECX,rmIND8(rESI)) xOFS8(4)
            xLEA_r_rm   (rESI,rmIND8(rESI)) xOFS8(8)
            xMOV_r_rm   (rEBP,rmREG(rEAX))
            xAND_rm_imm (rmREG(rEAX),0xffff)
            xADD_r_i32  (rEAX, mMEM32(global.kelvin.dwBaseVertex) ) //add base index
            xMOV_rm_imm (rmREG(rEDX),((((3) << 2) << 16) | ((NV_DD_KELVIN) << 13) | (NVPUSHER_NOINC(NV097_ARRAY_ELEMENT32))))
            xSHR_rm_imm8(rmREG(rEBP),16)
            xADD_r_i32  (rEBP, mMEM32(global.kelvin.dwBaseVertex) ) //add base index
            xMOV_rm_r   (rmIND(rEDI),rEDX)
            xMOV_rm_r   (rmIND8(rEDI),rEAX) xOFS8(4)
            xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(16)
            xAND_rm_imm (rmREG(rECX),0xffff)
            xADD_r_i32  (rECX, mMEM32(global.kelvin.dwBaseVertex) ) //add base index
            xMOV_rm_r   (rmIND8(rEDI),rEBP) xOFS8(8 - 16)
            xSUB_rm_imm (rmREG(rEBX),4)
            xMOV_rm_r   (rmIND8(rEDI),rECX) xOFS8(12 - 16)
            // next tri
            xJNZ32      (labelNext)
        }
        else
        {
            //
            // do a 64 index batch
            //
            DWORD labelCopy0;
            xCMP_rm_imm (rmREG(rEBX),64)
            xLABEL      (labelCopy0)
            xJB32       (0)
            {
                xMOV_rm_imm (rmREG(rEAX),((((32) << 2) << 16) | ((NV_DD_KELVIN) << 13) | (NVPUSHER_NOINC(NV097_ARRAY_ELEMENT16))))
                xMOV_rm_r   (rmIND(rEDI),rEAX)
                xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(4)

                nvKelvinILCompile_indexcpy (128);

                // check for pusher space
                DWORD labelSpace;
                xMOV_r_i32  (rEDX,mMEM32(pDriverData))
                xCMP_r_rm   (rEDI,rmIND32(rEDX)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwThreshold))
                xLABEL      (labelSpace)
                xJL         (0)
                {
                    xMOV_rm_r   (rmIND32(rEDX),rEDI) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
                    xMOV_rm_imm (rmREG(rEAX),(DWORD)nvKelvinDispatchGetPusherSpace)
                    xPUSH_r     (rEDX)
                    xCALL_rm    (rmREG(rEAX))
                    xPOP_r      (rEDX)
                    xMOV_r_rm   (rEDI,rmIND32(rEDX)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
                }
                xTARGET_b8  (labelSpace)

                xSUB_rm_imm (rmREG(rEBX),64)
                xJMP        (labelNext)
            }
            xTARGET_b32 (labelCopy0) // back to prefetch

            //
            // do a 16 index batch
            //
            DWORD labelCopy1;
            xCMP_rm_imm (rmREG(rEBX),16)
            xLABEL      (labelCopy1)
            xJB32       (0)
            {
                xMOV_rm_imm (rmREG(rEAX),((((8) << 2) << 16) | ((NV_DD_KELVIN) << 13) | (NVPUSHER_NOINC(NV097_ARRAY_ELEMENT16))))
                xMOV_rm_r   (rmIND(rEDI),rEAX)
                xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(4)

                nvKelvinILCompile_indexcpy (32);

                xSUB_rm_imm (rmREG(rEBX),16)
                xJMP        (labelNext) // back to prefetch
            }
            xTARGET_b32 (labelCopy1)

            //
            // do a 4 index batch
            //
            DWORD labelCopy2,labelNext2;
            xLABEL      (labelNext2)
            xCMP_rm_imm (rmREG(rEBX),4)
            xLABEL      (labelCopy2)
            xJB32       (0)
            {
                xMOV_rm_imm (rmREG(rEAX),((((2) << 2) << 16) | ((NV_DD_KELVIN) << 13) | (NVPUSHER_NOINC(NV097_ARRAY_ELEMENT16))))
                xMOV_rm_r   (rmIND(rEDI),rEAX)
                xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(4)

                nvKelvinILCompile_indexcpy (8);

                xSUB_rm_imm (rmREG(rEBX),4)
                xJMP        (labelNext2)
            }
            xTARGET_b32 (labelCopy2)

            //
            // do a single index
            //
            DWORD labelCopy3,labelNext3;
            xOR_r_rm    (rEBX,rmREG(rEBX))
            xLABEL      (labelCopy3)
            xJZ32       (0)
            xMOV_rm_imm (rmREG(rEDX),8)
            xLABEL      (labelNext3)
            {
                xXOR_r_rm   (rECX,rmREG(rECX))
                xMOV_rm_imm (rmREG(rEAX),((((1) << 2) << 16) | ((NV_DD_KELVIN) << 13) | (NVPUSHER_NOINC(NV097_ARRAY_ELEMENT32))))
           x16r xMOV_r_rm   (rCX,rmIND(rESI))
                xLEA_r_rm   (rESI,rmIND8(rESI)) xOFS8(2)
                xMOV_rm_r   (rmIND(rEDI),rEAX)
                xADD_r_rm   (rEDI,rmREG(rEDX))
                xADD_r_i32  (rECX, mMEM32(global.kelvin.dwBaseVertex) ) //add base index
                xDEC_rm     (rmREG(rEBX))
                xMOV_rm_r   (rmIND8(rEDI),rECX) xOFS8(4 - 8)
                xJNZ32      (labelNext3)
            }
            xTARGET_b32 (labelCopy3)
        }
    }
    else
    {
        //
        // ordered VB
        //

        //
        // compute how many vertices to send
        //
        xMOV_r_i32  (rEBX,mMEM32(global.kelvin.dwPrimCount))
        ILCCompile_mul (rEBX,dwVerticesPerPrim);
        if (dwStartVerticesPerPrim)
        {
            xADD_rm_imm (rmREG(rEBX),dwStartVerticesPerPrim)
        }

        //
        // zero out the index counter
        //
        xXOR_r_rm   (rESI,rmREG(rESI))

        //
        // send
        //
        DWORD labelNext1;
        DWORD labelNext3;
        xLABEL      (labelNext3)
        xCMP_rm_imm (rmREG(rEBX),128)
        xLABEL      (labelNext1)
        xJB32       (0)
        {
            // send 128 vertices
            xMOV_rm_imm (rmREG(rEAX),(((sizeSetNv20KelvinDrawArraysMthdCnt << 2) << 16) | ((NV_DD_KELVIN) << 13) | NV097_DRAW_ARRAYS))
            xMOV_rm_r   (rmREG(rECX),rESI)
            // xSHL_rm_imm (rmREG(rECX),0 ? NV056_DRAW_ARRAYS_START_INDEX)  // in principle this should be here, but it's a <<0
            xOR_rm_imm  (rmREG(rECX),DRF_NUM(056, _DRAW_ARRAYS, _COUNT, (128 - 1)))
            xMOV_rm_r   (rmIND(rEDI),rEAX)
            xMOV_rm_r   (rmIND8(rEDI),rECX) xOFS8(4)
            xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(8)
            xSUB_rm_imm (rmREG(rEBX),128)  // decrement the vertex counter
            xADD_rm_imm (rmREG(rESI),128)  // increment the index counter

            // check for pusher space
            xMOV_r_i32  (rEDX,mMEM32(pDriverData))
            xCMP_r_rm   (rEDI,rmIND32(rEDX)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwThreshold))
            xJL32       (labelNext3)
            {
                xMOV_rm_r   (rmIND32(rEDX),rEDI) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
                xMOV_rm_imm (rmREG(rEAX),(DWORD)nvKelvinDispatchGetPusherSpace)
                xPUSH_r     (rEDX)
                xCALL_rm    (rmREG(rEAX))
                xPOP_r      (rEDX)
                xMOV_r_rm   (rEDI,rmIND32(rEDX)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
            }
            xJMP        (labelNext3)
        }
        xTARGET_b32     (labelNext1)

        DWORD labelNext2;
        xOR_r_rm        (rEBX,rmREG(rEBX))
        xLABEL          (labelNext2)
        xJZ32           (0)
        {
            // send rest of vertices
            xMOV_rm_imm (rmREG(rEAX),(((sizeSetNv20KelvinDrawArraysMthdCnt << 2) << 16) | ((NV_DD_KELVIN) << 13) | NV097_DRAW_ARRAYS))
            xDEC_rm     (rmREG(rEBX))
            xSHL_rm_imm8(rmREG(rEBX),0 ? NV097_DRAW_ARRAYS_COUNT)
            // xSHL_rm_imm (rmREG(rESI),0 ? NV056_DRAW_ARRAYS_START_INDEX)  // in principle this should be here, but it's a <<0
            xOR_rm_r    (rmREG(rEBX),rESI)

            xMOV_rm_r   (rmIND(rEDI),rEAX)
            xMOV_rm_r   (rmIND8(rEDI),rEBX) xOFS8(4)
            xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(8)
        }
        xTARGET_b32     (labelNext2)
    }

    //
    // end prim
    //
    xMOV_rm_imm (rmREG(rEAX),((sizeSetNv20KelvinBeginEndMthdCnt << 2) << 16) | ((NV_DD_KELVIN) << 13) | NV097_SET_BEGIN_END);
    xMOV_rm_imm (rmREG(rECX),NV097_SET_BEGIN_END_OP_END)
    xMOV_rm_r   (rmIND(rEDI),rEAX)
    xMOV_rm_r   (rmIND8(rEDI),rECX) xOFS8(4)
    xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(8)

    // check for pusher space
    DWORD labelSpace;
    xMOV_r_i32  (rESI,mMEM32(pDriverData))
    xCMP_r_rm   (rEDI,rmIND32(rESI)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwThreshold))
    xLABEL      (labelSpace)
    xJL         (0)
    {
        xMOV_rm_r   (rmIND32(rESI),rEDI) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
        xMOV_rm_imm (rmREG(rEAX),(DWORD)nvKelvinDispatchGetPusherSpace)
        xCALL_rm    (rmREG(rEAX))
        xMOV_r_rm   (rEDI,rmIND32(rESI)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
    }
    xTARGET_b8  (labelSpace)

    //
    // save off push buffer
    //
    xMOV_r_i32  (rEDX,mMEM32(pDriverData))
#ifndef NV_NULL_HW_DRIVER
    xMOV_rm_r   (rmIND32(rEDX),rEDI) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
#endif

    //
    // done
    //
    xPOP_r      (rEDI)
    xPOP_r      (rESI)
    xPOP_r      (rEBX)
    xPOP_r      (rEBP)
    xRET
    return lEntry;
}

#endif KELVIN_ILC

#endif  // NVARCH == 0x20
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\common\inc\ddkmapi.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddkmapi.h
 *  Content:    Kernel mode APIs for accessing DirectDraw support.
 *
 ***************************************************************************/

#ifndef __DDKMAPI_INCLUDED__
#define __DDKMAPI_INCLUDED__


/*
 * API entry point
 */
DWORD
FAR PASCAL
DxApi(
    DWORD dwFunctionNum,
    DWORD lpvInBuffer,
    DWORD cbInBuffer,
    DWORD lpvOutBuffer,
    DWORD cbOutBuffer
);


#define DXAPI_MAJORVERSION              1
#define DXAPI_MINORVERSION              0

#define DD_FIRST_DXAPI                                  0x500

typedef DWORD (FAR PASCAL *LPDD_NOTIFYCALLBACK)(DWORD dwFlags, PVOID pContext, DWORD dwParam1, DWORD dwParam2);

/*
 * Queries the DXAPI version number.
 *
 * Input:  Null
 * Output: LPDDGETVERSIONNUMBER
 */
#define DD_DXAPI_GETVERSIONNUMBER                       (DD_FIRST_DXAPI)

    typedef struct _DDGETVERSIONNUMBER
    {
        DWORD   ddRVal;
        DWORD   dwMajorVersion;
        DWORD   dwMinorVersion;
    } DDGETVERSIONNUMBER, FAR *LPDDGETVERSIONNUMBER;

/*
 * Closes the kernel mode handle.
 *
 * Input:  LPDDCLOSEHANDLE
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_CLOSEHANDLE                            (DD_FIRST_DXAPI+1)

    typedef struct _DDCLOSEHANDLE
    {
        HANDLE  hHandle;
    } DDCLOSEHANDLE, FAR *LPDDCLOSEHANDLE;

/*
 * Opens the DirectDraw object and returns a kernel mode handle.
 *
 * Input:  LPDDOPENDIRECTDRAWIN
 * Output: LPDDOPENDIRECTDRAWOUT
 */
#define DD_DXAPI_OPENDIRECTDRAW                         (DD_FIRST_DXAPI+2)

    typedef struct _DDOPENDIRECTDRAWIN
    {
        DWORD               dwDirectDrawHandle;
        LPDD_NOTIFYCALLBACK pfnDirectDrawClose;
        PVOID               pContext;
    } DDOPENDIRECTDRAWIN, FAR *LPDDOPENDIRECTDRAWIN;

    typedef struct _DDOPENDIRECTDRAWOUT
    {
        DWORD   ddRVal;
        HANDLE  hDirectDraw;
    } DDOPENDIRECTDRAWOUT, FAR *LPDDOPENDIRECTDRAWOUT;

/*
 * Opens the surface and returns a kernel mode handle.
 *
 * Input:  LPDDOPENSURFACEIN
 * Output: LPDDOPENSURFACEOUT
 */
#define DD_DXAPI_OPENSURFACE                            (DD_FIRST_DXAPI+3)

    typedef struct _DDOPENSURFACEIN
    {
        HANDLE              hDirectDraw;
        DWORD               dwSurfaceHandle;
        LPDD_NOTIFYCALLBACK pfnSurfaceClose;
        PVOID               pContext;
    } DDOPENSURFACEIN, FAR *LPDDOPENSURFACEIN;

    typedef struct _DDOPENSURFACEOUT
    {
        DWORD   ddRVal;
        HANDLE  hSurface;
    } DDOPENSURFACEOUT, FAR *LPDDOPENSURFACEOUT;

/*
 * Opens the VideoPort and returns a kernel mode handle.
 *
 * Input:  LPDDOPENVIDEOPORTIN
 * Output: LPDDOPENVIDEOPORTOUT
 */
#define DD_DXAPI_OPENVIDEOPORT                          (DD_FIRST_DXAPI+4)

    typedef struct _DDOPENVIDEOPORTIN
    {
        HANDLE              hDirectDraw;
        DWORD               dwVideoPortHandle;
        LPDD_NOTIFYCALLBACK pfnVideoPortClose;
        PVOID               pContext;
    } DDOPENVIDEOPORTIN, FAR *LPDDOPENVIDEOPORTIN;

    typedef struct _DDOPENVIDEOPORTOUT
    {
        DWORD   ddRVal;
        HANDLE  hVideoPort;
    } DDOPENVIDEOPORTOUT, FAR *LPDDOPENVIDEOPORTOUT;

/*
 * Returns the kernel mode capabilities supported by the device
 *
 * Input:  HANDLE hDirectDraw
 * Output: LPDDGETKERNELCAPSOUT
 */
#define DD_DXAPI_GETKERNELCAPS                          (DD_FIRST_DXAPI+5)

    typedef struct _DDGETKERNELCAPSOUT
    {
        DWORD   ddRVal;
        DWORD   dwCaps;
        DWORD   dwIRQCaps;
    } DDGETKERNELCAPSOUT, FAR *LPDDGETKERNELCAPSOUT;

/*
 * Gets the current field number
 *
 * Input:  LPDDGETFIELDNUMIN
 * Output: LPDDGETFIELDNUMOUT
 */
#define DD_DXAPI_GET_VP_FIELD_NUMBER                    (DD_FIRST_DXAPI+6)

    typedef struct _DDGETFIELDNUMIN
    {
        HANDLE  hDirectDraw;
        HANDLE  hVideoPort;
    } DDGETFIELDNUMIN, FAR *LPDDGETFIELDNUMIN;

    typedef struct _DDGETFIELDNUMOUT
    {
        DWORD   ddRVal;
        DWORD   dwFieldNum;
    } DDGETFIELDNUMOUT, FAR *LPDDGETFIELDNUMOUT;

/*
 * Sets the current field number
 *
 * Input:  LPDDSETFIELDNUM
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_SET_VP_FIELD_NUMBER                    (DD_FIRST_DXAPI+7)

    typedef struct _DDSETFIELDNUM
    {
        HANDLE  hDirectDraw;
        HANDLE  hVideoPort;
        DWORD   dwFieldNum;
    } DDSETFIELDNUM, FAR *LPDDSETFIELDNUM;

/*
 * Indicates which fields should be skipped to undo the 3:2 pulldown.
 *
 * Input:  LPDDSETSKIPFIELD
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_SET_VP_SKIP_FIELD                      (DD_FIRST_DXAPI+8)

    typedef struct _DDSETSKIPFIELD
    {
        HANDLE  hDirectDraw;
        HANDLE  hVideoPort;
        DWORD   dwStartField;
    } DDSETSKIPFIELD, FAR *LPDDSETSKIPFIELD;

/*
 * Notifies whether the surface is in bob or weave mode.
 *
 * Input:  LPDDGETSURFACESTATEIN
 * Output: LPDDGETSURFACESTATEOUT
 */
#define DD_DXAPI_GET_SURFACE_STATE                      (DD_FIRST_DXAPI+9)

    typedef struct _DDGETSURFACESTATEIN
    {
        HANDLE  hDirectDraw;
        HANDLE  hSurface;
    } DDGETSURFACESTATEIN, FAR *LPDDGETSURFACESTATEIN;

    typedef struct _DDGETSURFACESTATEOUT
    {
        DWORD   ddRVal;
        DWORD   dwStateCaps;
        DWORD   dwStateStatus;
    } DDGETSURFACESTATEOUT, FAR *LPDDGETSURFACESTATEOUT;

/*
 * Changes the surface between bob and weave mode.
 *
 * Input:  LPDDSETSURFACESTATE
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_SET_SURFACE_STATE                      (DD_FIRST_DXAPI+10)

    typedef struct _DDSETSURFACETATE
    {
        HANDLE  hDirectDraw;
        HANDLE  hSurface;
        DWORD   dwState;
        DWORD   dwStartField;
    } DDSETSURFACESTATE, FAR *LPDDSETSURFACESTATE;

/*
 * Allows direct access to the surface memory
 *
 * Input:  LPDDLOCKIN
 * Output: LPDDLOCKOUT
 */
#define DD_DXAPI_LOCK                                   (DD_FIRST_DXAPI+11)

    typedef struct _DDLOCKIN
    {
        HANDLE  hDirectDraw;
        HANDLE  hSurface;
    } DDLOCKIN, FAR *LPDDLOCKIN;

    typedef struct _DDLOCKOUT
    {
        DWORD   ddRVal;
        DWORD   dwSurfHeight;
        DWORD   dwSurfWidth;
        LONG    lSurfPitch;
        PVOID   lpSurface;
        DWORD   SurfaceCaps;
        DWORD   dwFormatFlags;
        DWORD   dwFormatFourCC;
        DWORD   dwFormatBitCount;
        union
        {
            DWORD       dwRBitMask;
            DWORD       dwYBitMask;
        };
        union
        {
            DWORD       dwGBitMask;
            DWORD       dwUBitMask;
        };
        union
        {
            DWORD       dwBBitMask;
            DWORD       dwVBitMask;
        };
    } DDLOCKOUT, FAR *LPDDLOCKOUT;

/*
 * Flips the overlay surface
 *
 * Input:  LPDDFLIPOVERLAY
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_FLIP_OVERLAY                           (DD_FIRST_DXAPI+12)

    typedef struct _DDFLIPOVERLAY
    {
        HANDLE  hDirectDraw;
        HANDLE  hCurrentSurface;
        HANDLE  hTargetSurface;
        DWORD   dwFlags;
    } DDFLIPOVERLAY, FAR *LPDDFLIPOVERLAY;

/*
 * Flips the video port
 *
 * Input:  LPDDFLIPOVERLAY
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_FLIP_VP                                (DD_FIRST_DXAPI+13)

    typedef struct _DDFLIPVIDEOPORT
    {
        HANDLE  hDirectDraw;
        HANDLE  hVideoPort;
        HANDLE  hCurrentSurface;
        HANDLE  hTargetSurface;
        DWORD   dwFlags;
    } DDFLIPVIDEOPORT, FAR *LPDDFLIPVIDEOPORT;

/*
 * Returns the current surface receiving the data while autoflipping
 *
 * Input:  LPDDGETAUTOFLIPIN
 * Output: LPDDGETAUTOFLIPOUT
 */
#define DD_DXAPI_GET_CURRENT_VP_AUTOFLIP_SURFACE        (DD_FIRST_DXAPI+14)

    typedef struct _DDGETAUTOFLIPIN
    {
        HANDLE  hDirectDraw;
        HANDLE  hVideoPort;
    } DDGETAUTOFLIPIN, FAR *LPDDGETAUTOFLIPIN;

    typedef struct _DDGETAUTOFLIPOUT
    {
        DWORD   ddRVal;
        HANDLE  hVideoSurface;
        HANDLE  hVBISurface;
        BOOL    bPolarity;
    } DDGETAUTOFLIPOUT, FAR *LPDDGETAUTOFLIPOUT;

/*
 * Returns the surface that received the previous field of data (could
 * be the same as current if video is interleaved)
 *
 * Input:  LPDDGETAUTOFLIPIN
 * Output: LPDDGETAUTOFLIPOUT
 */
#define DD_DXAPI_GET_LAST_VP_AUTOFLIP_SURFACE           (DD_FIRST_DXAPI+15)

/*
 * Registers a callback for when various events occur.
 *
 * Input:  LPDDREGISTERCALLBACK
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_REGISTER_CALLBACK                      (DD_FIRST_DXAPI+16)

    typedef struct _DDREGISTERCALLBACK
    {
        HANDLE              hDirectDraw;
        DWORD               dwEvents;
        LPDD_NOTIFYCALLBACK pfnCallback;
        DWORD               dwParam1;
        DWORD               dwParam2;
        PVOID               pContext;
    } DDREGISTERCALLBACK, FAR *LPDDREGISTERCALLBACK;

/*
 * Unregisters a callback for when various events occur.
 *
 * Input:  LPDDREGISTERCALLBACK
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_UNREGISTER_CALLBACK                    (DD_FIRST_DXAPI+17)

/*
 * Returns the polarity (odd/even) of the current field
 *
 * Input:  LPDDGETPOLARITYIN
 * Output: LPDDGETPOLARITYOUT
 */
#define DD_DXAPI_GET_POLARITY                           (DD_FIRST_DXAPI+18)

    typedef struct _DDGETPOLARITYIN
    {
        HANDLE  hDirectDraw;
        HANDLE  hVideoPort;
    } DDGETPOLARITYIN, FAR *LPDDGETPOLARITYIN;

    typedef struct _DDGETPOLARITYOUT
    {
        DWORD   ddRVal;
        BOOL    bPolarity;
    } DDGETPOLARITYOUT, FAR *LPDDGETPOLARITYOUT;

/*
 * Opens the device for capture
 *
 * Input:  LPDDOPENCAPTUREDEVICEIN
 * Output: LPDDOPENCAPTUREDEVICEOUT
 */
#define DD_DXAPI_OPENVPCAPTUREDEVICE                    (DD_FIRST_DXAPI+19)

    typedef struct _DDOPENVPCAPTUREDEVICEIN
    {
        HANDLE  hDirectDraw;
        HANDLE  hVideoPort;
        DWORD   dwStartLine;
        DWORD   dwEndLine;
        DWORD   dwCaptureEveryNFields;
        LPDD_NOTIFYCALLBACK pfnCaptureClose;
        PVOID   pContext;
    } DDOPENVPCAPTUREDEVICEIN, FAR * LPDDOPENVPCAPTUREDEVICEIN;

    typedef struct _DDOPENVPCAPTUREDEVICEOUT
    {
        DWORD   ddRVal;
        HANDLE  hCapture;
    } DDOPENVPCAPTUREDEVICEOUT, FAR * LPDDOPENVPCAPTUREDEVICEOUT;

/*
 * Adds a capture buffer to the internal video port capture queue
 *
 * Input:  LPDDADDVPCAPTUREBUFF
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_ADDVPCAPTUREBUFFER                     (DD_FIRST_DXAPI+20)

    typedef struct _DDCAPBUFFINFO
    {
        DWORD           dwFieldNumber;
        DWORD           bPolarity;
        LARGE_INTEGER   liTimeStamp;
        DWORD           ddRVal;
    } DDCAPBUFFINFO, FAR * LPDDCAPBUFFINFO;

    typedef struct _DDADDVPCAPTUREBUFF
    {
        HANDLE  hCapture;
        DWORD   dwFlags;
        PMDL    pMDL;
        PKEVENT pKEvent;
        LPDDCAPBUFFINFO lpBuffInfo;
    } DDADDVPCAPTUREBUFF, FAR * LPDDADDVPCAPTUREBUFF;

    #define DDADDBUFF_SYSTEMMEMORY      0x0001  // lpBuffer points to sys mem
    #define DDADDBUFF_NONLOCALVIDMEM    0x0002  // lpBuffer points to AGP mem
    #define DDADDBUFF_INVERT            0x0004  // invert the buffer during capture

/*
 * Flushes the internal video port capture queue
 *
 * Input:  HANDLE to capture device
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_FLUSHVPCAPTUREBUFFERS                  (DD_FIRST_DXAPI+21)


/*
 * State flags returned by DSVXD_DXAPI_DD_GET_SURFACE_STATE
 */
#define DDSTATE_BOB                             0x0001
#define DDSTATE_WEAVE                           0x0002
#define DDSTATE_EXPLICITLY_SET                  0x0004
#define DDSTATE_SOFTWARE_AUTOFLIP               0x0008

/*
 * Event flags - passed into RegisterCallback
 */
#define DDEVENT_DISPLAY_VSYNC                   0x0001
#define DDEVENT_VP_VSYNC                        0x0002
#define DDEVENT_VP_LINE                         0x0004
#define DDEVENT_PRERESCHANGE                    0x0008
#define DDEVENT_POSTRESCHANGE                   0x0010
#define DDEVENT_PREDOSBOX                       0x0020
#define DDEVENT_POSTDOSBOX                      0x0040

/*
 * Notification flags - passed to the notification proc
 */
#define DDNOTIFY_DISPLAY_VSYNC                  0x0001  // dwParam1 = hDirectDraw
#define DDNOTIFY_VP_VSYNC                       0x0002  // dwParam1 = hVideoPort
#define DDNOTIFY_VP_LINE                        0x0004  // dwParam1 = hVideoPort
#define DDNOTIFY_PRERESCHANGE                   0x0008  // dwParam1 = hDirectDraw
#define DDNOTIFY_POSTRESCHANGE                  0x0010  // dwParam1 = hDirectDraw
#define DDNOTIFY_PREDOSBOX                      0x0020  // dwParam1 = hDirectDraw
#define DDNOTIFY_POSTDOSBOX                     0x0040  // dwParam1 = hDirectDraw
#define DDNOTIFY_CLOSEDIRECTDRAW                0x0080  // dwParam1 = hDirectDraw
#define DDNOTIFY_CLOSESURFACE                   0x0100  // dwParam1 = hSurface
#define DDNOTIFY_CLOSEVIDEOPORT                 0x0200  // dwParam1 = hVideoPort
#define DDNOTIFY_CLOSECAPTURE                   0x0400  // dwParam1 = hCapture

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\common\src\surfaces.c ===
/***************************************************************************\
* (C) Copyright NVIDIA Corporation Inc.,                                    *
*  1996,1997, 1998. All rights reserved.                                    *
*                                                                           *
* Module: surfaces.c                                                        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       schaefer           3/26/98                                          *
*                                                                           *
\***************************************************************************/

// MS includes
#include "windows.h"
#include "ddraw.h"
//#include "Ddrawp.h"
#include "ddrawi.h"
#include "ddmini.h"
#include "dvp.h"
#include "dmemmgr.h"
#include "ddkmmini.h"
#include "ddkmapi.h"

#ifndef NV4
#include "real3nv32.h"
#include "nvwin32.h"
#include "nvos.h"
#else
#include "realnv32.h"
#include "nvwin32.h"
#include "nvos.h"
#endif  //NV4
// NV includes



#ifdef  MULTI_MON
#include "nvrmapi.h"
#include "nvrmarch.inc"


// we're going to use this definition so that we can 
// do this under NT or Win9x "MULTI-MON" which is a cheeser way of saying
// that we're using the NValloc architecture
#define USE_NV_ALLOC_ARCH

#endif  // MULTI_MON

// unit specific includes
#include "surfaces.h"
#include "VidTex.h"
#include "nvcm.h"

// Hey Folks some storage right here
extern vpSurfaces*			pMySurfaces;
//vpSurfaces			MySurfaces;

NvChannel* 			pMyNvChan = NULL;
extern NvNotification*	nvMyVPNotifiers;

#define STARTINGBUF	(99)
#define UNKNOWNBUF	(123)


// This is a hack to fix up stuff which a contradiction between the two known systems
// CODE this should be cleaned up as the NV4 style RM moves into NV3 land


BOOLEAN checkScalingOk(U032 in, U032 out ) {
	U032 xIn,yIn,xOut,yOut;
	U032	xRatio;
	/*  Scaling works like this... the output MUST be smaller than the input, and the X ratio must be an integer value
		 there is no limit on the Y ratio since it's just a line dropping system
	*/
	
	xIn  = in & 0xFFFF;
	yIn  = in >> 16;
	xOut = out & 0xFFFF;
	yOut = out >> 16;
	
	if( xIn < xOut ) {
		DPF ("   In dimension X is SMALLER than out X dimension %d, %d",xIn,xOut);
		return FALSE;
	}
	if( yIn < yOut ) {
		DPF ("   In dimension Y is SMALLER than out Y dimension %d, %d",yIn,yOut);
		return FALSE;
	}
	if( xIn % xOut != 0 ) {
		DPF ("   X dimension In does not evenly divide by X out %d, %d",xIn,xOut);
		return FALSE;
	}	
	xRatio = xIn / xOut;
	
	switch (xRatio) {
			case 1:
			case 2:
			case 3:
			case 4:
			case 6:
			case 8:
			case 12:
			case 16:
			case 24:
				break;
			default:
				{
					DPF ("   Not one of the good scale factors %d, %d, %d",xIn,xOut,xRatio);
					return FALSE;
				}			
				break;
	}
		
	return TRUE;
}


BOOL GetField(void) {
	BOOL	retvalue = TRUE;
	U032	whiletime = 0;
	FIELDTYPE aField = UNKNOWN;
	
	// we're not hitting the channel
	//INIT_FREE_COUNT(0);


	// clear the notifiers
	nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(0)+NUM04DOFFSET].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
	nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(1)+NUM04DOFFSET].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
		
	// put the object into the channel
#ifndef NV4
	pMyNvChan->subchannel[0].control.object = MY_EXTERNAL_DECODER_OBJECT;
#else 
	pMyNvChan->subchannel[0].SetObject = MY_EXTERNAL_DECODER_OBJECT;
#endif // NV4

	// fire off the command
#ifndef NV4_HW
	pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.GetImageOffsetNotify[0] =  NV04D_GET_IMAGE_OFFSET_NOTIFY_WRITE_ONLY;
																									
	pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.GetImageOffsetNotify[1] =  NV04D_GET_IMAGE_OFFSET_NOTIFY_WRITE_ONLY;
#else   //NV4_HW
	pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.GetImageOffsetNotify[0] =  NV04D_GET_IMAGE_OFFSET_NOTIFY_WRITE_ONLY;
	pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.GetImageOffsetNotify[1] =  NV04D_GET_IMAGE_OFFSET_NOTIFY_WRITE_ONLY;
#endif  //NV4_HW		
	
	// wait for completion

	while ( ((nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(0)+NUM04DOFFSET].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS) ||
				 (nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(1)+NUM04DOFFSET].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS))	&&
				(whiletime++ < WHILETIMEOUT) );
	
	// only one of these should be running right now....
	if( nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(0)+NUM04DOFFSET].info16 == NV04D_NOTIFICATION_INFO16_FIELD_VALID_OFFSET ) {
		aField = pMySurfaces->Surfaces[pMySurfaces->CurrentBufferSurface[0]]->field;
	}
	if( nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(1)+NUM04DOFFSET].info16 == NV04D_NOTIFICATION_INFO16_FIELD_VALID_OFFSET ) {
		aField = pMySurfaces->Surfaces[pMySurfaces->CurrentBufferSurface[1]]->field;
	}
		
	if(aField == EVEN ) {
		retvalue = TRUE;
	} else {
		retvalue = FALSE;
	}
	
	return retvalue;
}
	
U032 checkNvAllocArchError(U032 error) {
	// returns true if there IS an error
	// otherwise false
	switch (error) {
			case NVOS04_STATUS_SUCCESS:
				return 0;
//				DPF("NVOS04_STATUS_SUCCESS");
				break;
			case NVOS04_STATUS_ERROR_OPERATING_SYSTEM:
				DPF("NVOS04_STATUS_ERROR_OPERATING_SYSTEM");
				return error;
				break;
			case NVOS04_STATUS_ERROR_BAD_OBJECT_PARENT:
				DPF("NVOS04_STATUS_ERROR_BAD_OBJECT_PARENT");
				return error;
				break;
			case NVOS04_STATUS_ERROR_BAD_OBJECT_NEW:
				DPF("NVOS04_STATUS_ERROR_BAD_OBJECT_NEW");
				return error;
				break;
			case NVOS04_STATUS_ERROR_BAD_CLASS:
				DPF("NVOS04_STATUS_ERROR_BAD_CLASS");
				return error;
				break;
			case NVOS04_STATUS_ERROR_BAD_OBJECT_ERROR:
				DPF("NVOS04_STATUS_ERROR_BAD_OBJECT_ERROR");
				return error;
				break;
			case NVOS04_STATUS_ERROR_BAD_FLAGS:
				DPF("NVOS04_STATUS_ERROR_BAD_FLAGS");
				return error;
				break;
			case NVOS04_STATUS_ERROR_INSUFFICIENT_RESOURCES:
				DPF("NVOS04_STATUS_ERROR_INSUFFICIENT_RESOURCES");
				return error;
				break;
			default:
					DPF("UNKNOWN ERROR");
					return 1;
	}
	
	return 0;
}

DWORD SetupVP (LPDDHAL_CREATEVPORTDATA lpInput) {
	U032 error;
	U032 i;
	INIT_FREE_COUNT(0);
	
	pMyNvChan = pMySurfaces->pVPChanPtr;
	if(pMyNvChan == NULL ) {
		//CODE
		error = NvRmAllocChannelPio ((GLOBDATAPTR)->ROOTHANDLE, 
					NV_WIN_DEVICE, 
					MY_VPE_CHANNEL, 
#ifndef NV4
					NV03_CHANNEL_PIO, 
#else
					//NV04_CHANNEL_PIO, 
					NV03_CHANNEL_PIO,
#endif
					0, 
					(PVOID)&(pMySurfaces->pVPChanPtr), 
					ALLOC_CHL_PIO_FLAGS_FIFO_IGNORE_RUNOUT);
		if(checkNvAllocArchError(error )) {
			DPF("   Warning: Unable to sucessfully complete NvRmAllocChannelPio");
	    	return DDHAL_DRIVER_NOTHANDLED;
		}
		
		
		pMyNvChan = pMySurfaces->pVPChanPtr;
		
		// Now store a copy in global land so that the brucerator's code can kill the channel on mode switches
		GLOBDATAPTR->NvDevFlatVPE = (U032) pMySurfaces->pVPChanPtr;

	}	

	if(pMyNvChan == NULL ) {	
		DPF("   Warning: the NV Channel for VPE is not initialized... sorry");
    	return DDHAL_DRIVER_NOTHANDLED;
	} else {
	
			error = NvRmAllocObject(  (GLOBDATAPTR)->ROOTHANDLE,
	                     		MY_VPE_CHANNEL,
	                     		MY_EXTERNAL_DECODER_OBJECT,
										NV03_EXTERNAL_VIDEO_DECODER
								);
		    
			if(checkNvAllocArchError(error )) {
				DPF("NVDD: Cannot allocate External Decoder Object %d",MY_EXTERNAL_DECODER_OBJECT);
				return FALSE;
			}
						 
			error = NvRmAllocObject(  (GLOBDATAPTR)->ROOTHANDLE,
	                     		MY_VPE_CHANNEL,
	                     		MY_TIMER_OBJECT,
#ifndef NV4
										NV_TIMER
#else
										NV01_TIMER
#endif
								);
			if(checkNvAllocArchError(error )) {
				DPF("NVDD: Cannot allocate Timer Object %d",MY_TIMER_OBJECT);
				return FALSE;
			}
						
			// setup Notify Context

			if (NvRmAllocContextDma(  (GLOBDATAPTR)->ROOTHANDLE,
	                     		MY_EXTERNAL_DECODER_NOTIFIER,
	                     		NV01_CONTEXT_DMA,
	                     		(	ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR |
                        				ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
	                     		(PVOID)(((U032)nvMyVPNotifiers) + NUM04DOFFSET*sizeof(NvNotification)),
	                     		(sizeof( NvNotification)*NUM04DNOTIFIER  - 1)
	                     ) != ALLOC_CTX_DMA_STATUS_SUCCESS )
		     {
		        DPF((1, "NVDD: Cannot allocate notifier context"));
		        return FALSE;
		     }
			
			
			if (NvRmAllocContextDma(  (GLOBDATAPTR)->ROOTHANDLE,
	                     		MY_TIMER_NOTIFIER,
	                     		NV01_CONTEXT_DMA,
	                     		(	ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR |
                        				ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
	                     		(PVOID)(((U032)nvMyVPNotifiers) + NUM004OFFSET*sizeof(NvNotification)),
	                     		(sizeof( NvNotification)*NUM004NOTIFIER  - 1)
	                     ) != ALLOC_CTX_DMA_STATUS_SUCCESS )
		     {
		        DPF((1, "NVDD: Cannot allocate notifier context"));
		        return FALSE;
		     }

		
			// Plug the notifiers into the main object
			// make sure the object is on the channel
#ifndef NV4
			pMyNvChan->subchannel[0].control.object = MY_EXTERNAL_DECODER_OBJECT;
#else 
			pMyNvChan->subchannel[0].SetObject  = MY_EXTERNAL_DECODER_OBJECT;
#endif // NV4
			
			pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaNotifies = MY_EXTERNAL_DECODER_NOTIFIER;
			

#ifndef NV4
			pMyNvChan->subchannel[0].control.object = MY_TIMER_OBJECT;
			pMyNvChan->subchannel[0].timer.SetAlarmNotifyCtxDma = MY_TIMER_NOTIFIER;
#else 
			pMyNvChan->subchannel[0].SetObject  = MY_TIMER_OBJECT;
			pMyNvChan->subchannel[0].nv01Timer.SetContextDmaNotifies = MY_TIMER_NOTIFIER;
#endif // NV4
			
			
 //**************************************************************************
 // Allocate a DMA context which points to all of video memory. The limit
 // must be page aligned: i.e. limit = (size in bytes of video mem rounded to the
 // closest page boundary) - 1.
 //**************************************************************************
		
		{
			void*  pFrameBuffer = (void*)(GLOBDATAPTR)->PBASEADDRESS;
			U032	 dwFBLen= DWFBUFFERLEN;
						
			if (NvRmAllocContextDma(	(GLOBDATAPTR)->ROOTHANDLE,
											MY_IMAGE0_BUFFER_CONTEXT,
											NV01_CONTEXT_DMA,
											(	ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR |
			               				ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
											pFrameBuffer,
			                      	dwFBLen
										) != ALLOC_CTX_DMA_STATUS_SUCCESS )
			{
			  DPF((1, "NVDD: Cannot allocate dma in memory context for MY_IMAGE0_BUFFER_CONTEXT"));
			  return FALSE;
			}
			
			 if (NvRmAllocContextDma(  (GLOBDATAPTR)->ROOTHANDLE,
											MY_IMAGE1_BUFFER_CONTEXT,
											NV01_CONTEXT_DMA,
										 	(	ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR |
			               				ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
			                      	pFrameBuffer,
			                      	dwFBLen
			                      ) != ALLOC_CTX_DMA_STATUS_SUCCESS )
			  {
			  DPF((1, "NVDD: Cannot allocate dma in memory context for MY_IMAGE1_BUFFER_CONTEXT"));
			  return FALSE;
			  }
			
			if (NvRmAllocContextDma(  (GLOBDATAPTR)->ROOTHANDLE,
			                      MY_VBI0_BUFFER_CONTEXT,
			                      NV01_CONTEXT_DMA,
										 //NV01_CONTEXT_DMA,
			                      (	ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR |
			               			ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
			                      pFrameBuffer,
			                      dwFBLen
			                      ) != ALLOC_CTX_DMA_STATUS_SUCCESS )
			{
			  DPF((1, "NVDD: Cannot allocate dma in memory context for MY_VBI0_BUFFER_CONTEXT"));
			  return FALSE;
			}
			
			if (NvRmAllocContextDma(  (GLOBDATAPTR)->ROOTHANDLE,
			                      MY_VBI1_BUFFER_CONTEXT,
			                      NV01_CONTEXT_DMA,
										 //NV01_CONTEXT_DMA,
			                      (	ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR |
			               			ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
			                      pFrameBuffer,
			                      dwFBLen
			                      ) != ALLOC_CTX_DMA_STATUS_SUCCESS )
			{
			  DPF((1, "NVDD: Cannot allocate dma in memory context for MY_VBI1_BUFFER_CONTEXT"));
			  return FALSE;
			}

		}

			
			CHECK_FREE_COUNT(pMyNvChan,10*5);
			
			// make sure decoder object is in the channel....
#ifndef NV4
			pMyNvChan->subchannel[0].control.object = MY_EXTERNAL_DECODER_OBJECT;
#else 
			pMyNvChan->subchannel[0].SetObject = MY_EXTERNAL_DECODER_OBJECT;
#endif // NV4
			// plug in our buffer contexts
			pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaImage[0] 	= MY_IMAGE0_BUFFER_CONTEXT;
			pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaImage[1] 	= MY_IMAGE1_BUFFER_CONTEXT;
			pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaVbi[0] 		= MY_VBI0_BUFFER_CONTEXT;
			pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaVbi[1] 		= MY_VBI1_BUFFER_CONTEXT;
			
		// Ok, done setting up the various contexts
		// now we should setup the class with some boring default values
			
			CHECK_FREE_COUNT(pMyNvChan,10*10);
			
			for( i = 0; i < 2; i++ ) {		
				pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImage[i].sizeIn	 = ((240 << 16 ) | 720 );	// *The next four method may fail if the scaling values do not work out properly.
				pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImage[i].sizeOut = ((240 << 16 ) | 720 );		// changing either In or Out values will modify the scaling values
				pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImage[i].offset		=0;			//	*indicates DMA "address" as on offset from frame buffer base
				
				//  we don't actually want to launch any captures at this point
				
				pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetVbi[i].offset		= 0;
				pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetVbi[i].size        = 0;				
				//  we don't actually want to launch any captures at this point
			}
			
			
		// Ok, reset all the notifiers:
		
			for (i = 0; i < NUMVPNOTIFIERS ; i++ ) {
				nvMyVPNotifiers[i].status 		= NV04D_NOTIFICATION_STATUS_NOT_LAUNCHED;
				nvMyVPNotifiers[i].info32 	= 0;
				nvMyVPNotifiers[i].info32	= 0;
				nvMyVPNotifiers[i].timeStamp.nanoseconds[0]	= 0;
				nvMyVPNotifiers[i].timeStamp.nanoseconds[1]	= 0;
			}


			// this means we're going to try for kevin's new cool callback dealy
			
			/*
			 * NvAllocEvent() specifies a Windows event or callback for NV to send to the
			 * application after requesting notifications with the
			 * NV_OS_WRITE_THEN_AWAKEN style.
			 *    first parameter is the NvChannel
			 *    second is the object name
			 *    third is the notify index
			 *    fourth is the notify event type (NV_OS_EVENT_*)
			 *    fifth is the lower 32bits of the 64bit event data       
			 *    sixth is the upper 32bits of the 64bit event data
			 */

 			// first object we're going to associate will be the MY_EXTERNAL_DECODER_OBJECT
			// we want to different notifiers associated here.
			
			pMySurfaces->bThreadDead = FALSE;
			pMySurfaces->bThreadRunning = TRUE;
			
			// I want VBI/Image/ 0 / 1  all to go to the same place


#ifndef NV4
// until someone gets this define in the right header file
#define  NV01_EVENT_KERNEL_CALLBACK                                (0x00000078)
#endif  // nv4

			{
				U032 status = 0;

				status = NvRmAllocEvent	(	(GLOBDATAPTR)->ROOTHANDLE,
	 									MY_EXTERNAL_DECODER_OBJECT,
	                      		MY_VBI0_BUFFER_EVENT,
	                      		NV01_EVENT_KERNEL_CALLBACK,
										NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0),
										(void*)pMySurfaces->pNotifyCallbackProcV0);		    
							
				if( status !=  0x0 /* meaning sucess */ ) {
					DPF("Bad status returned from nvRmAllocEvent. status = %d",status);
				} 
				
				status = NvRmAllocEvent	(	(GLOBDATAPTR)->ROOTHANDLE,
	 									MY_EXTERNAL_DECODER_OBJECT,
	                      		MY_VBI1_BUFFER_EVENT,
	                      		NV01_EVENT_KERNEL_CALLBACK,
										NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(1),
										(void*)pMySurfaces->pNotifyCallbackProcV1);
			   if( status !=  0x0 /* meaning sucess */ ) {
					DPF("Bad status returned from nvRmAllocEvent. status = %d",status);
				} 
				status = NvRmAllocEvent	(	(GLOBDATAPTR)->ROOTHANDLE,
	 									MY_EXTERNAL_DECODER_OBJECT,
	                      		MY_IMAGE0_BUFFER_EVENT,
	                      		NV01_EVENT_KERNEL_CALLBACK,
										NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0),
										(void*)pMySurfaces->pNotifyCallbackProcI0);
			   if( status !=  0x0 /* meaning sucess */ ) {
					DPF("Bad status returned from nvRmAllocEvent. status = %d",status);
				} 
				status = NvRmAllocEvent	(	(GLOBDATAPTR)->ROOTHANDLE,
	 									MY_EXTERNAL_DECODER_OBJECT,
	                      		MY_IMAGE1_BUFFER_EVENT,
	                      		NV01_EVENT_KERNEL_CALLBACK,
										NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1),
										(void*)pMySurfaces->pNotifyCallbackProcI1);
			   if( status !=  0x0 /* meaning sucess */ ) {
					DPF("Bad status returned from nvRmAllocEvent. status = %d",status);
				} 
				 
				 // And finally one for the timer
#ifndef NV4
#define NV004_NOTIFIERS_SET_ALARM_NOTIFY                           (1)
#endif				 
				 status = NvRmAllocEvent	(	(GLOBDATAPTR)->ROOTHANDLE,
	 									MY_TIMER_OBJECT,
	                      		MY_TIMER_EVENT,
	                      		NV01_EVENT_KERNEL_CALLBACK,
										NV004_NOTIFIERS_SET_ALARM_NOTIFY,
										(void*)pMySurfaces->pTimerNotifyProc);
			   if( status !=  0x0 /* meaning sucess */ ) {
					DPF("Bad status returned from nvRmAllocEvent. status = %d",status);
				} 
				            		
			}	// event alloc block									 
			

			

		// Decrement the number of ports available count
			(pMySurfaces->pDriverData)->dwVideoPortsAvailable--;
			

	}

	// this sets up the structures for ring0 data transfers
	SetupMTM();
#ifdef NV4
	initTextureSurf();
#endif
	
	pMySurfaces->SetupComplete = TRUE;
	return DDHAL_DRIVER_HANDLED;
}

	
void 	tearDownVP(void) {
	U032	error;
	U032	i;
	U032	whiletime;
	INIT_FREE_COUNT(0);
	
	// stop things from running  ( check to make sure the channel is not null by which we'll assume
	//   that things are not running
	// tell the thread to exit
	pMySurfaces->bThreadRunning = FALSE;
	
	if(pMyNvChan != NULL)
		StopVP();
		
#ifdef NV4
	DestroyTextureSurf();
#endif

	TearDownMTM();
	
	// this should wake up the thread
//	SetEvent( pMySurfaces->hVPInterruptEvent );	

	// wait for it to die
	whiletime = 0;
	while( (!pMySurfaces->bThreadDead) &
			(whiletime++ < WHILETIMEOUT) );
	// make sure that the thread has really exited
	//TerminateThread((HANDLE)pMySurfaces->VpInterruptId,0);
	
	

	
	if(pMyNvChan != NULL ) {
		CHECK_FREE_COUNT(pMyNvChan,12*4);
					
		// stop the transfers	
#ifndef NV4
		pMyNvChan->subchannel[0].control.object = MY_EXTERNAL_DECODER_OBJECT;
#else 
		pMyNvChan->subchannel[0].SetObject  = MY_EXTERNAL_DECODER_OBJECT;
#endif // NV4
		
		pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.StopTransferImage   = 0;
		pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.StopTransferVbi = 0;
	
	
	}
	
	
#ifdef NOEVENTFREEFUNCTIONYETFOLKS	
	DPF("Now ditching the EVENTs ");
	
	error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, MY_EXTERNAL_DECODER_OBJECT, MY_IMAGE0_BUFFER_EVENT);
   checkNvAllocArchError(error);
	error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, MY_EXTERNAL_DECODER_OBJECT, MY_IMAGE1_BUFFER_EVENT);
   checkNvAllocArchError(error);
	error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, MY_EXTERNAL_DECODER_OBJECT, MY_VBI0_BUFFER_EVENT);
   checkNvAllocArchError(error);
	error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, MY_EXTERNAL_DECODER_OBJECT, MY_VBI1_BUFFER_EVENT);
   checkNvAllocArchError(error);
	error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, MY_TIMER_OBJECT, MY_TIMER_EVENT);
	checkNvAllocArchError(error);
	
#endif  

	DPF("Now setting notifiers to NULL");
	if(pMyNvChan != NULL ) {
	
// set notifiers to NULL context DMAs
#ifndef NV4
		pMyNvChan->subchannel[0].control.object = MY_EXTERNAL_DECODER_OBJECT;
#else 
		pMyNvChan->subchannel[0].SetObject  = MY_EXTERNAL_DECODER_OBJECT;
#endif // NV4
		
		pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaNotifies = 0;
		

#ifndef NV4
		pMyNvChan->subchannel[0].control.object = MY_TIMER_OBJECT;
		pMyNvChan->subchannel[0].timer.SetAlarmNotifyCtxDma = 0;
#else 
		pMyNvChan->subchannel[0].SetObject  = MY_TIMER_OBJECT;
		pMyNvChan->subchannel[0].nv01Timer.SetContextDmaNotifies = 0;
#endif // NV4

// set DMA for transfers to NULL

#ifndef NV4
		pMyNvChan->subchannel[0].control.object = MY_EXTERNAL_DECODER_OBJECT;
#else 
		pMyNvChan->subchannel[0].SetObject = MY_EXTERNAL_DECODER_OBJECT;
#endif // NV4

		pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaImage[0] 	= 0;
		pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaImage[1] 	= 0;
		pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaVbi[0] 		= 0;
		pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaVbi[1] 		= 0;

	


	// spin waiting for empty fifo
#ifdef NV4
		while(NvGetFreeCount(pMyNvChan, 0) < NV06A_FIFO_GUARANTEED_SIZE );
#else
		while(NvGetFreeCount(pMyNvChan, 0) < NV_GUARANTEED_FIFO_SIZE );
#endif
	
	}
//  I'm a bit concerned about syncing the FIFO with these NVRM API calls. but we'll let this slide for now
 
	DPF("Now ditching the Notifiers");
	error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, (GLOBDATAPTR)->ROOTHANDLE, MY_EXTERNAL_DECODER_NOTIFIER);
	checkNvAllocArchError(error);
	error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, (GLOBDATAPTR)->ROOTHANDLE, MY_TIMER_NOTIFIER);
	checkNvAllocArchError(error);



	DPF("Now ditching the Buffer contexts");
	error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, (GLOBDATAPTR)->ROOTHANDLE, MY_IMAGE0_BUFFER_CONTEXT);
	if(checkNvAllocArchError(error)) {
		DPF("that was trouble freeing MY_IMAGE0_BUFFER_CONTEXT");
	}
	error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, (GLOBDATAPTR)->ROOTHANDLE, MY_IMAGE1_BUFFER_CONTEXT);
	if(checkNvAllocArchError(error)) {
		DPF("that was trouble freeing MY_IMAGE1_BUFFER_CONTEXT");
	}
	error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, (GLOBDATAPTR)->ROOTHANDLE, MY_VBI0_BUFFER_CONTEXT);
	if(checkNvAllocArchError(error)) {
		DPF("that was trouble freeing MY_VBI0_BUFFER_CONTEXT");
	}
	error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, (GLOBDATAPTR)->ROOTHANDLE, MY_VBI1_BUFFER_CONTEXT);
	if(checkNvAllocArchError(error)) {
		DPF("that was trouble freeing MY_VBI1_BUFFER_CONTEXT");
	}
	


	
	error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, MY_VPE_CHANNEL, MY_TIMER_OBJECT);
	if(checkNvAllocArchError(error)) {
		DPF("that was trouble freeing MY_TIMER_OBJECT");
	}
	error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, MY_VPE_CHANNEL, MY_EXTERNAL_DECODER_OBJECT);

	if(checkNvAllocArchError(error)) {
		DPF("that was trouble freeing MY_EXTERNAL_DECODER_OBJECT");
	}
	

	
// increment the number of ports available
	(pMySurfaces->pDriverData)->dwVideoPortsAvailable++;
// shut down Media Port channel

	pMyNvChan = pMySurfaces->pVPChanPtr;
	{
		ULONG status;
		
		status = NvRmFree((GLOBDATAPTR)->ROOTHANDLE,
								 NV_WIN_DEVICE, 
								 MY_VPE_CHANNEL);
		
		if( status == 0x0) {
			pMyNvChan = NULL;
			pMySurfaces->pVPChanPtr = NULL;
		} else {
			DPF("Uh Dude,  I couldn't deallocate the channel pointer... ");
		
		}	
	}


	(pMySurfaces->pDriverData)->NvDevFlatVPE = (DWORD) NULL;	
	pMyNvChan = NULL;
	
	// Ok, reset all the notifiers:
	
//	CloseHandle(pMySurfaces->hThreadHandle);
	for (i = 0; i < NUMVPNOTIFIERS ; i++ ) {
		nvMyVPNotifiers[i].status 		= NV04D_NOTIFICATION_STATUS_NOT_LAUNCHED;
		nvMyVPNotifiers[i].info32 	= 0;
		nvMyVPNotifiers[i].info32	= 0;
		nvMyVPNotifiers[i].timeStamp.nanoseconds[0]	= 0;
		nvMyVPNotifiers[i].timeStamp.nanoseconds[1]	= 0;
	}
	pMySurfaces->SetupComplete = FALSE;
	
}


void StopVP(void) {
	U032	whiletime;
	
	INIT_FREE_COUNT(0);
	
#ifndef NV4
		NV_DD_DMA_PUSHER_SYNC();
#endif //NV4		

	CHECK_FREE_COUNT(pMyNvChan,8);
	

#ifndef NV4
	pMyNvChan->subchannel[0].control.object = MY_EXTERNAL_DECODER_OBJECT;
#else 
	pMyNvChan->subchannel[0].SetObject  = MY_EXTERNAL_DECODER_OBJECT;
#endif // NV4
	DPF ("   Firing Off Stop commands");

	pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.StopTransferImage   = 0;
	pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.StopTransferVbi = 0;

// wait for the last few notifies to show up ?		
	
	pMySurfaces->bStopVP = TRUE;
	
	whiletime = 0;
	while ( ((nvMyVPNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS) ||
				 (nvMyVPNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS))	&&
				(whiletime++ < WHILETIMEOUT) );

// CODE wait for VBI notifies.. too
//	while (nvMyVPNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS);
//	while (nvMyVPNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS);
	DPF ("   Done waiting for stops");

	// one more time to make sure those register get cleared	
	pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.StopTransferImage   = 0;
	pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.StopTransferVbi = 0;
    	
}	

DWORD getCurLine(void) {
	U032	whiletime;
  	U032	possibleOffset = 0;
	U032	line;
	U032	returnLine;
	INIT_FREE_COUNT(0);
	
	nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(0)].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
	nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(1)].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
	
	returnLine = 0;

	// Put decoder object into the channel
	CHECK_FREE_COUNT(pMyNvChan,1*4);
#ifndef NV4
	pMyNvChan->subchannel[0].control.object = MY_EXTERNAL_DECODER_OBJECT;
#else 
	pMyNvChan->subchannel[0].SetObject = MY_EXTERNAL_DECODER_OBJECT;
#endif // NV4


	CHECK_FREE_COUNT(pMyNvChan,8);
	
	pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.GetImageOffsetNotify[0]		= 0;			// *allows programming of either ODD or EVEN fields
	pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.GetImageOffsetNotify[1]		= 0;			// *allows programming of either ODD or EVEN fields

//CODE   there may still be in issue with divide by ZERO here.. I can't imagine pitch = 0.. but you never know...

	whiletime = 0;

	while ( ((nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(0)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS) ||
				 (nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(1)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS))	&&
				(whiletime++ < WHILETIMEOUT) );


	if(nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(0)].info32 == NV04D_NOTIFICATION_INFO16_FIELD_VALID_OFFSET ) {
		possibleOffset = nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(0)].info32;
		line = possibleOffset - pMySurfaces->Surfaces[pMySurfaces->CurrentBufferSurface[0]]->dwOffset;
		returnLine = line / pMySurfaces->Surfaces[pMySurfaces->CurrentBufferSurface[0]]->dwPitch;
	}
	if(nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(1)].info32 == NV04D_NOTIFICATION_INFO16_FIELD_VALID_OFFSET ) {
		possibleOffset = nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(1)].info32;
		line = possibleOffset - pMySurfaces->Surfaces[pMySurfaces->CurrentBufferSurface[1]]->dwOffset;
		returnLine = line / pMySurfaces->Surfaces[pMySurfaces->CurrentBufferSurface[1]]->dwPitch;
	}
	
	return returnLine;
}
	
U032	notifyIndexFromBuffer(U032 dwBuffer) {
	switch (dwBuffer) {
			case 0:
				return NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0);
				break;
			case 1:
				return NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1);
				break;
			case 2:
				return NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0);
				break;
			case 3:
				return NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(1);
				break;
			default:
				{
					DPF ("   Problem... trying get an index for an unknown buffer notify");
					return UNKNOWNBUF;
				}
	}
}


VPERRORS replaceSurfaceList(DWORD dwNumAutoflip,DWORD dwNumVBIAutoflip,
										LPDDRAWI_DDRAWSURFACE_INT   *lplpDDSurface,
										LPDDRAWI_DDRAWSURFACE_INT   *lplpDDVBISurface,
										U032 bAutoflip ) {
	VPERRORS	localError = NOVPERROR;
	U032 	imageSurfCount = 0;
	U032	VBISurfCount = 0;
	U032	i;
	U032	next;
	
	pMySurfaces->surfMemAllocCount = 0;
	
	ASSERT(!((lplpDDSurface 		!= NULL) ^ (dwNumAutoflip > 0)));
	ASSERT(!((lplpDDVBISurface 	!= NULL) ^ (dwNumVBIAutoflip > 0)));

	DPF ("   We have #Image=%d  #VB=%d autoflip surfaces",dwNumAutoflip,dwNumVBIAutoflip);
					
	localError = clearAllSurfaces();
	if( localError != NOVPERROR ) {
		return localError;
	}
	
	imageSurfCount = 0;
	
	if(lplpDDSurface != NULL) {
		// first count the surfaces
		imageSurfCount = 0;
		while(lplpDDSurface[imageSurfCount] != NULL ) {
			imageSurfCount++;
		}
		if(bAutoflip) {
			if(imageSurfCount > dwNumAutoflip ) {
				DPF("More in list than are autoflip!");
				imageSurfCount = dwNumAutoflip;
			}
		}
		// next add the surfaces to the list	
		i = 0;
		while((lplpDDSurface[i] != NULL ) && (i <imageSurfCount) ) {
			next = i + 1;
			if( next == imageSurfCount ) 
				next = 0;
			localError = addSurface(createSurface(lplpDDSurface[i], bAutoflip, FALSE, NULL,next));	
			i=i+1;
		}
		
		DPF("Added %d Image surfaces",imageSurfCount);
	}
	pMySurfaces->VBIstart = imageSurfCount;
	
	if(lplpDDVBISurface!=NULL ) {
		// now count VBI surfaces
		VBISurfCount = 0;
		while(lplpDDVBISurface[VBISurfCount] != NULL ) {
			VBISurfCount++;
		}
		if(bAutoflip) {
			if(VBISurfCount > dwNumVBIAutoflip ) {
				DPF("More in VBI list than are autoflip!");
				VBISurfCount = dwNumVBIAutoflip;
			}
		}
		// next add the surfaces to the list	
		i = 0;
		// All the VBI surfaces are offset by a certain amount
		while((lplpDDVBISurface[i] != NULL ) && (i <VBISurfCount) ) {
			next = i + 1;
			if( next == VBISurfCount ) 
				next = 0;
			localError = addSurface(createSurface(lplpDDVBISurface[i], bAutoflip, TRUE, NULL,next+pMySurfaces->VBIstart));	
			i=i+1;
		}
		DPF("Added %d VBI surfaces",VBISurfCount);
	}
	
	
	pMySurfaces->CurrentBufferSurface[0] = NOSURFACEPROGRAMED;
	pMySurfaces->CurrentBufferSurface[1] = NOSURFACEPROGRAMED;
	pMySurfaces->CurrentBufferSurface[2] = NOSURFACEPROGRAMED;
	pMySurfaces->CurrentBufferSurface[3] = NOSURFACEPROGRAMED;
	
	if( localError == NOVPERROR ) {
		DPF ("   Replaced surfaces - OK");
	} else {
		switch (localError) {
				case 	TOOMANYSURFACESERROR:
					DPF ("   Replaced surfaces - TOOMANYSURFACESERROR");
					break;
				case CANTCREATESURFACE:
					DPF ("   Replaced surfaces - CANTCREATESURFACE");
					break;
				case SURFACENOTFOUND:
					DPF ("   Replaced surfaces - SURFACENOTFOUND");
					break;
				case NOSURFACEPROGRAMED:
					DPF ("   Replaced surfaces - NOSURFACEPROGRAMED");
					break;
		}
		
		DPF ("   Replaced surfaces there was a problem = %d",localError);
	}

#if 0
#ifdef DEBUG	
	DPF("Now checking the surface thingie");
	{	
		U032	i;
		for(i=0;i<pMySurfaces->numberOfSurfaces;i++) {
			DPF("#Surfaces = %d surface = %d, nextSurface = %d, prevSurcace = %d",pMySurfaces->numberOfSurfaces,i,getNextSurface(i),getPrevSurface(i));
		}
	}
	
	DPF("done checking");
	
#endif

#endif
	return localError;
}


VPERRORS	addSurface(vpSurfaceInfo*	pNewSurface) {
	ASSERT(pNewSurface 	!= NULL);

	if(pMySurfaces->numberOfSurfaces >= MAXVPSURFACES ) {
		return	TOOMANYSURFACESERROR;
	}	
	if( pNewSurface == NULL) {
		return CANTCREATESURFACE;
	}
	
	pMySurfaces->Surfaces[pMySurfaces->numberOfSurfaces] = pNewSurface;
	pMySurfaces->numberOfSurfaces++;
		
	return NOVPERROR;
}

vpSurfaceInfo* createSurface(LPDDRAWI_DDRAWSURFACE_INT pNewSurface, U032 bAutoflip, 
										U032 bVBI, NvNotification* pToNotify,U032 nextSurface) {
	
	
	vpSurfaceInfo*		pSurface;
	U032 Delta;

	ASSERT( pNewSurface != NULL);
	// unlikely to ever be not NULL
	//ASSERT( pToNotify != NULL);
	ASSERT( nextSurface < MAXVPSURFACES);

	pSurface = &pMySurfaces->surfMemory[pMySurfaces->surfMemAllocCount];
	pMySurfaces->surfMemAllocCount++;
	
	pSurface->surfHandle = pNewSurface;
	pSurface->bAutoFlip = bAutoflip;	
	pSurface->pVidMem = pNewSurface->lpLcl->lpGbl->fpVidMem;
	pSurface->ddsCaps = pNewSurface->lpLcl->ddsCaps.dwCaps;
	pSurface->nextSurfaceNum = nextSurface;
	// store the offset of the intermediate hidden surface
	pSurface->dwRes1 = pNewSurface->lpLcl->lpGbl->dwReserved1;
//
	
	pSurface->dwPitch = pNewSurface->lpLcl->lpGbl->lPitch;

	
	
	// move things around in the surface
	Delta = pMySurfaces->dwOriginX*2 + pMySurfaces->dwOriginY*pSurface->dwPitch;
	
	pSurface->dwOffset = (unsigned long) pSurface->pVidMem 
					- (unsigned long)(pMySurfaces->pDriverData)->BaseAddress
					+ Delta;
	
	
	if(bVBI) {
		pSurface->dwStartLine = pMySurfaces->dwVBIStartLine;
	} else {
		if( pMySurfaces->CurrentScanMode == INTERLEAVBUF) {
				// both field have bigger pitch
				pSurface->dwPitch = pNewSurface->lpLcl->lpGbl->lPitch * 2;
			}
	
	
	
		//if( pMySurfaces->dwImageStartLine < 6 )
		//	pSurface->dwStartLine = 6;
		//else 
			if(pMySurfaces->dwImageStartLine == 1) {
				pSurface->dwStartLine = 16;	//tried 17 no much- 15 can see stuff on top of intercast disk - 16?
			} else {
				pSurface->dwStartLine = pMySurfaces->dwImageStartLine;
			}
	}	

#define VIDEOEXTRALEN (0)
	// make sure we're not trying to cram something into a surface that's too small
	if(bVBI ) {
		pSurface->dwHeight = pMySurfaces->dwVBIHeight;
	} else {
		if ( pMySurfaces->dwInHeight > pNewSurface->lpLcl->lpGbl->wHeight ) {
			pSurface->dwHeight = pNewSurface->lpLcl->lpGbl->wHeight + VIDEOEXTRALEN;
		} else {
			pSurface->dwHeight = pMySurfaces->dwInHeight + VIDEOEXTRALEN;
		}
	}
	if ( pMySurfaces->dwInWidth > pNewSurface->lpLcl->lpGbl->wWidth ) {
		pSurface->dwWidth = pNewSurface->lpLcl->lpGbl->wWidth;
	} else {
		pSurface->dwWidth = pMySurfaces->dwInWidth;
	}
	
	pSurface->dwPreScaleSize =  (pMySurfaces->dwPreWidth) | ((pMySurfaces->dwPreHeight+VIDEOEXTRALEN) << 16);
			// we know that there are TWO bytes per pixel in UYVY format
	//pSurface->dwLength = pNewSurface->lpLcl->lpGbl->lPitch * ((U032)pNewSurface->lpLcl->lpGbl->wHeight) * 2;
	pSurface->dwLength = pSurface->dwPitch * (((U032)pSurface->dwHeight) ) * 2;

	return pSurface;
}


VPERRORS replaceSurfaceWithSurface(U032 surfaceToReplace, LPDDRAWI_DDRAWSURFACE_LCL pNewSurface, U032  bVBI) {

	vpSurfaceInfo*		pSurface;
	U032 					Delta;

	ASSERT( pNewSurface != NULL);

	pSurface = pMySurfaces->Surfaces[surfaceToReplace];
// not sure if this is necessary or not....
//	pSurface->pNvNotify = &(nvMyVPNotifiers[notifyIndexFromBuffer(0)]);
	
	pSurface->surfHandle = pNewSurface;
	// pSurface->bAutoFlip = bAutoflip;	// leave this the same!
	pSurface->pVidMem = pNewSurface->lpGbl->fpVidMem;
	pSurface->ddsCaps = pNewSurface->ddsCaps.dwCaps;
	// pSurface->nextSurfaceNum = nextSurface;		// leave this the same!
	
	pSurface->dwPitch = pNewSurface->lpGbl->lPitch;

	// move things around in the surface
	Delta = pMySurfaces->dwOriginX*2 + pMySurfaces->dwOriginY*pSurface->dwPitch;
	
	pSurface->dwOffset = (unsigned long) pSurface->pVidMem 
					- (unsigned long)(pMySurfaces->pDriverData)->BaseAddress
					+ Delta;
	
	if( pMySurfaces->CurrentScanMode == INTERLEAVBUF) {
		// both field have bigger pitch
		pSurface->dwPitch = pNewSurface->lpGbl->lPitch * 2;
	}
	
	if(bVBI) {
		pSurface->dwStartLine = pMySurfaces->dwVBIStartLine;
	} else {
		//if( pMySurfaces->dwImageStartLine < 6 )
		//	pSurface->dwStartLine = 6;
		//else 
			if(pMySurfaces->dwImageStartLine == 1) {
				pSurface->dwStartLine = 16;	//tried 17 no much- 15 can see stuff on top of intercast disk - 16?
			} else {
				pSurface->dwStartLine = pMySurfaces->dwImageStartLine;
			}
	}	

#define VIDEOEXTRALEN (0)
	// make sure we're not trying to cram something into a surface that's too small
	if(bVBI ) {
		pSurface->dwHeight = pMySurfaces->dwVBIHeight;
	} else {
		if ( pMySurfaces->dwInHeight > pNewSurface->lpGbl->wHeight ) {
			pSurface->dwHeight = pNewSurface->lpGbl->wHeight + VIDEOEXTRALEN;
		} else {
			pSurface->dwHeight = pMySurfaces->dwInHeight + VIDEOEXTRALEN;
		}
	}
	if ( pMySurfaces->dwInWidth > pNewSurface->lpGbl->wWidth ) {
		pSurface->dwWidth = pNewSurface->lpGbl->wWidth;
	} else {
		pSurface->dwWidth = pMySurfaces->dwInWidth;
	}
	
	pSurface->dwPreScaleSize =  (pMySurfaces->dwPreWidth) | ((pMySurfaces->dwPreHeight+VIDEOEXTRALEN) << 16);
			// we know that there are TWO bytes per pixel in UYVY format
	//pSurface->dwLength = pNewSurface->lpGbl->lPitch * ((U032)pNewSurface->lpGbl->wHeight) * 2;
	pSurface->dwLength = pSurface->dwPitch * (((U032)pSurface->dwHeight) ) * 2;

	return NOVPERROR;

}

VPERRORS clearAllSurfaces() {
	U032	i;
	
	for (i=0;i<pMySurfaces->numberOfSurfaces; i++ ) {
		pMySurfaces->Surfaces[i] = NULL;
	}
	
	pMySurfaces->surfMemAllocCount = 0;
	pMySurfaces->numberOfSurfaces = 0;
	
	return NOVPERROR;
}

U032	findSurface(LPDDRAWI_DDRAWSURFACE_LCL pNewSurface ) {
	U032	i;
	
	for(i = 0 ; i < pMySurfaces->numberOfSurfaces; i ++ ) {
		if( pNewSurface->lpGbl->fpVidMem == pMySurfaces->Surfaces[i]->pVidMem ) {
			// Ok, we found the surface!
			return i;
		}
	
	}
	
	return SURFACENOTFOUND;
}

#if 0

FIELDTYPE	getNextFieldType(FIELDTYPE lastFieldType) {

	switch (pMySurfaces->CurrentCaptureMode) {
			case EVENODD:
				if(lastFieldType ==EVEN ) {
					return ODD;
				} else if( lastFieldType ==ODD ) {
					return EVEN;
				} else {
					return EVEN;
				}
				break;
			case EVENEVEN:
				if(lastFieldType ==EVEN ) {
					return EVEN;
				} else {
					return EVEN;
				}	
				break;
			case ODDODD:
				if(lastFieldType ==ODD ) {
					return ODD;
				} else {
					return ODD;
				}	
				break;
			default:
				ASSERT(pMySurfaces->CurrentCaptureMode == ODDODD );
	}
}



U032	ProgramBufferWithSurface(U032	dwBufferIndex,U032	newSurfaceIndex, U032 bZeroLength) {
	// This function is responsible for programming up and then launching buffer/surface combination
	// This will finish Asyncronously, and either be relaunched in the case of auto-flip, or be able 
	// to report back usefully with the VPE functions
	U032	nextField;
	U032	dwInterleaveAddition;
	INIT_FREE_COUNT(0);
	
	ASSERT(dwBufferIndex < 4 );
	ASSERT(newSurfaceIndex < MAXVPSURFACES );
	//Update the surface structures
		// notify

	
	pMySurfaces->Surfaces[newSurfaceIndex]->pNvNotify = &(nvMyVPNotifiers[notifyIndexFromBuffer(dwBufferIndex)]);
	pMySurfaces->CurrentBufferSurface[dwBufferIndex] = newSurfaceIndex;	
	
	
	// Figure out the whole field thing
	nextField = getNextFieldType(pMySurfaces->lastField);
	pMySurfaces->Surfaces[newSurfaceIndex]->field = nextField;
	pMySurfaces->lastField = nextField;
	pMySurfaces->curSurf = newSurfaceIndex;

#define PRINTPROGRAM
#ifdef PRINTPROGRAM		
	DPF("   ProgramBufferWithSurface");
	DPF("           dwBufferIndex = %d",dwBufferIndex);
	DPF("         newSurfaceIndex = %d",newSurfaceIndex);
	DPF("             bZeroLength = %d",bZeroLength);
	switch (nextField) {
			case ODD:
				 DPF("                   field = ODD");
				break;
			case EVEN:
				 DPF("                   field = EVEN");
				break;
			case UNKNOWN:
				 DPF("                   field = UNKNOWN");
				break;
	}
#endif //PRINTPROGRAM

	// if we're interleaving AND we're on the EVEN field then move everything down a bit
	//   OOD field is on top
	if(( pMySurfaces->CurrentScanMode == INTERLEAVBUF) && (nextField == EVEN ) ) {
		dwInterleaveAddition = pMySurfaces->Surfaces[newSurfaceIndex]->dwPitch/2;
	} else {
		dwInterleaveAddition = 0;
	}
	// choose which type of surface this is
	if( dwBufferIndex <2 ) {
		// Image surface
	 	// setup the field polarity, offset and fire it off
		

		// Put decoder object into the channel
		CHECK_FREE_COUNT(pMyNvChan,1*4);
#ifndef NV4
		pMyNvChan->subchannel[0].control.object = MY_EXTERNAL_DECODER_OBJECT;
#else 
		pMyNvChan->subchannel[0].SetObject = MY_EXTERNAL_DECODER_OBJECT;
#endif // NV4
	
		// for now use the same "in" as "out"
		
		CHECK_FREE_COUNT(pMyNvChan,5*4);
		
		pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImageStartLine = 
			pMySurfaces->Surfaces[newSurfaceIndex]->dwStartLine;
		
// check for invalid scaling combo's	
		
		// if prescale is not on 2:1 integer boundaries from output, then fail...
		{
			BOOL bScale = checkScalingOk((pMySurfaces->Surfaces[newSurfaceIndex]->dwWidth) | 
													(pMySurfaces->Surfaces[newSurfaceIndex]->dwHeight << 16)
							,pMySurfaces->Surfaces[newSurfaceIndex]->dwPreScaleSize);
			
			if(! bScale ) {
				DPF("   Invalid Scaling parameters in use...");
	
				return (-7);		
			}
		}

		pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImage[dwBufferIndex].sizeIn =
			(pMySurfaces->dwInWidth) | (pMySurfaces->dwInHeight << 16);

		if( bZeroLength ) {
			pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImage[dwBufferIndex].sizeOut = 0;
		} else {
			pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImage[dwBufferIndex].sizeOut = 
				pMySurfaces->Surfaces[newSurfaceIndex]->dwPreScaleSize;		
		}

#ifdef PRINTPROGRAM	
		DPF("                  offset = %x",pMySurfaces->Surfaces[newSurfaceIndex]->dwOffset + dwInterleaveAddition);
		DPF("                  pitch  = %x",pMySurfaces->Surfaces[newSurfaceIndex]->dwPitch);
#endif //PRINTPROGRAM	
		pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImage[dwBufferIndex].offset	=
				pMySurfaces->Surfaces[newSurfaceIndex]->dwOffset + dwInterleaveAddition;
		
		// There is some sly behavior in the field statement...
		// since progressive fields are expected to be delivered in the EVEN fields we only check for OOD
		// and then everything else is considered to be even
		nvMyVPNotifiers[notifyIndexFromBuffer(dwBufferIndex)].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
		pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImage[dwBufferIndex].format =		
				( pMySurfaces->Surfaces[newSurfaceIndex]->dwPitch & 0xFFFF )  |
				((( ( nextField == ODD ) ? NV04D_SET_IMAGE_FORMAT_FIELD_ODD_FIELD : NV04D_SET_IMAGE_FORMAT_FIELD_EVEN_FIELD) << 16 ) & 0xFF0000 )  |
				((NV_OS_WRITE_THEN_AWAKEN << 24 ) & 0xFF000000 ) ;
		
				
	} else {
		CHECK_FREE_COUNT(pMyNvChan,3*4);
		
		// VBI surface	
		pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetVbi[dwBufferIndex-2].size	=
			(pMySurfaces->Surfaces[newSurfaceIndex]->dwHeight << 16) | (pMySurfaces->Surfaces[newSurfaceIndex]->dwStartLine) ;
		
		pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetVbi[dwBufferIndex-2].offset	=
			pMySurfaces->Surfaces[newSurfaceIndex]->dwOffset;
		
		nvMyVPNotifiers[notifyIndexFromBuffer(dwBufferIndex)].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
		pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetVbi[dwBufferIndex-2].format =		
			( pMySurfaces->Surfaces[newSurfaceIndex]->dwPitch & 0xFFFF )  |
			((( ( nextField == ODD ) ? NV04D_SET_IMAGE_FORMAT_FIELD_ODD_FIELD : NV04D_SET_IMAGE_FORMAT_FIELD_EVEN_FIELD) << 16 ) & 0xFF0000 )  |
			((NV_OS_WRITE_THEN_AWAKEN << 24 ) & 0xFF000000 ) ;
		
	}
	//Update the Capture Class
	
	return 0;
}


DWORD WINAPI VPInterruptThread(PVOID daParameter) {

	DWORD		waitReturnValue;
	HANDLE	myEvent = (HANDLE) daParameter;

	ASSERT(myEvent != NULL);
	
	DPF ("   |||||||| Thread Started");
				
	while(pMySurfaces->bThreadRunning) {
		// sit and wait... 
		// we'll wake up on the event which can be triggered EITHER by the RM 
		// OR by our parent telling us to wake up and then exit
		waitReturnValue = WaitForSingleObject(myEvent,INFINITE);   
		if( pMySurfaces->bThreadRunning ) {
			if(waitReturnValue == WAIT_OBJECT_0 ) {
				//DPF ("   interrupt");
				//HandleBufferInterrupt();
				if( pMySurfaces->myTable.handleBufferInterrupts != NULL ) {
						U032 retval = (pMySurfaces->myTable.handleBufferInterrupts)();
						if(retval != 0) 
							DPF("FUCKUP!!!!!!!!!   this is ab ad thing    what sometimes this is bad = %8x",retval);
					} else {
						ASSERT(1==0);
						// massive failure... hang out here for a while
					}
			}	
		}
	}		

	DPF ("   |||||||| Thread Ending");

	pMySurfaces->bThreadDead = TRUE;
	
	return 0;
}



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\common\inc\MINIVDD.H ===
//*****************************************************************************
//
//   (C) Copyright MICROSOFT Corp., 1988-1993
//
//   Title:      minivdd.inc - VDD definitions for other VxD's and multiple VDD's
//
//   Version:    4.00
//
//   Date:
//
//   Author: FredE for the Mini-VDD interface.  Adapted from VDD.INC in
//           the general include area.  Added services are ONLY for the
//           use of the Mini-VDD and should therefore not be documented.
//
//-----------------------------------------------------------------------------
//=============================================================================

#ifndef _MINIVDD_H_
#define _MINIVDD_H_

#ifndef Not_VxD

/*XLATOFF*/
#define VDD_Service Declare_Service
#pragma warning (disable:4003)      // turn off not enough params warning
/*XLATON*/

#ifdef MINIVDD
#ifdef NEC_98
/*MACROS*/
//
// VDD protect mode services for other devices and VMM (Get_Version must be first).
// Only define these if we're assembling either the "main" VDD or one of the
// mini-VDD's.  Don't define this if we're assembling a display driver or other
// caller of the MiniVDD stuff:
//
Begin_Service_Table(VDD)
VDD_Service(     VDD_Get_Version            ) // Get version number and ID string ptr
VDD_Service(     VDD_PIF_State              ) // Pass video PIF bits to VDD
VDD_Service(     VDD_Get_GrabRtn            ) // Get routine addr for video grab
VDD_Service(     VDD_Hide_Cursor            ) // Hide cursor when display is windowed
VDD_Service(     VDD_Set_VMType             ) // Set VM type(windowed, bckgrnd, excl)
VDD_Service(     VDD_Get_ModTime            ) // Return system time of last mod
VDD_Service(     VDD_Set_HCurTrk            ) // Track horiz cursor movement in window
VDD_Service(     VDD_Msg_ClrScrn            ) // Clear screen for sysmodal message
VDD_Service(     VDD_Msg_ForColor           ) // Set Msg_TextOut forground color
VDD_Service(     VDD_Msg_BakColor           ) // Set Msg_TextOut background color
VDD_Service(     VDD_Msg_TextOut            ) // Output a string
VDD_Service(     VDD_Msg_SetCursPos         ) // Set cursor position
VDD_Service(     VDD_Query_Access           ) // Is it OK to access video now?
VDD_Service(     VDD_Check_Update_Soon      ) // User action may update screen
VDD_Service(     VDD_Get_Mini_Dispatch_Table) // Get addr of dispatch table to mini-VDD
VDD_Service(     VDD_Register_Virtual_Port  ) // Mini-VDD asks us to setup I/O trap
VDD_Service(     VDD_Get_VM_Info            ) // Returns CRTC owner and MemC owners
                                              // and other special VM handles
VDD_Service(     VDD_Get_Special_VM_IDs     ) // returns planar & msg mode IDs
VDD_Service(     VDD_Register_Extra_Screen_Selector )
                                              // allows display driver to use second
                                              // screen selector for block moves
VDD_Service(     VDD_Takeover_VGA_Port      ) // allows MiniVDD to takeover a port
                                              // in range 3C0H through 3DFH
VDD_Service(     VDD_Get_DISPLAYINFO        ) // get DISPLAYINFO data structure
VDD_Service(     VDD_Do_Physical_IO         ) // perform physical I/O for trapped port
VDD_Service(     VDD_Register_Mini_VDD   )
VDD_Service(    VDD_Install_IO_Handler   )
VDD_Service(    VDD_Install_Mult_IO_Handlers    )
VDD_Service(    VDD_Enable_Local_Trapping       )
VDD_Service(    VDD_Disable_Local_Trapping      )
VDD_Service(    VDD_Trap_Suspend        )
VDD_Service(    Test_Vid_VM_Handle      )
VDD_Service(    VDD_Set_Core_Graphics   )
VDD_Service(    VDD_Load_AccBIOS        )
VDD_Service(    VDD_Map_AccBIOS         )
VDD_Service(    VDD_Map_VRAM            )
End_Service_Table(VDD)
/*ENDMACROS*/
#else  /*NEC_98*/
/*MACROS*/
//
// VDD protect mode services for other devices and VMM (Get_Version must be first).
// Only define these if we're assembling either the "main" VDD or one of the
// mini-VDD's.  Don't define this if we're assembling a display driver or other
// caller of the MiniVDD stuff:
//
Begin_Service_Table(VDD)
VDD_Service(     VDD_Get_Version             )// Get version number and ID string ptr
VDD_Service(     VDD_PIF_State               )// Pass video PIF bits to VDD
VDD_Service(     VDD_Get_GrabRtn             )// Get routine addr for video grab
VDD_Service(     VDD_Hide_Cursor             )// Hide cursor when display is windowed
VDD_Service(     VDD_Set_VMType              )// Set VM type(windowed, bckgrnd, excl)
VDD_Service(     VDD_Get_ModTime             )// Return system time of last mod
VDD_Service(     VDD_Set_HCurTrk             )// Track horiz cursor movement in window
VDD_Service(     VDD_Msg_ClrScrn             )// Clear screen for sysmodal message
VDD_Service(     VDD_Msg_ForColor            )// Set Msg_TextOut forground color
VDD_Service(     VDD_Msg_BakColor            )// Set Msg_TextOut background color
VDD_Service(     VDD_Msg_TextOut             )// Output a string
VDD_Service(     VDD_Msg_SetCursPos          )// Set cursor position
VDD_Service(     VDD_Query_Access            )// Is it OK to access video now?
VDD_Service(     VDD_Check_Update_Soon       )// User action may update screen
VDD_Service(     VDD_Get_Mini_Dispatch_Table )// Get addr of dispatch table to mini-VDD
VDD_Service(     VDD_Register_Virtual_Port   )// Mini-VDD asks us to setup I/O trap
VDD_Service(     VDD_Get_VM_Info             )// Returns CRTC owner and MemC owners
                                              // and other special VM handles
VDD_Service(     VDD_Get_Special_VM_IDs      )// returns planar & msg mode IDs
VDD_Service(     VDD_Register_Extra_Screen_Selector )
                                              // allows display driver to use second
                                              // screen selector for block moves
VDD_Service(     VDD_Takeover_VGA_Port   )    // allows MiniVDD to takeover a port
                                              // in range 3C0H through 3DFH
VDD_Service(     VDD_Get_DISPLAYINFO     )    // get DISPLAYINFO data structure
VDD_Service(     VDD_Do_Physical_IO      )    // perform physical I/O for trapped port
VDD_Service(     VDD_Set_Sleep_Flag_Addr )    // when display driver can't be interrupted
End_Service_Table(VDD)                   
/*ENDMACROS*/
#endif  /*NEC_98*/
#endif  /*MINIVDD*/

/*XLATOFF*/
#pragma warning (default:4003)              // turn off not enough params warning
/*XLATON*/

#define VDD_VerNum      0x0400  // version 4.00
#define VDD_MinVerNum   0x030A  // supports down to 3.10

//***************
// PIF_State service definitions
//
// These definitions cannot change without changing the PIF editor!!!
//
#ifdef NEC_98
#define bVidTextMd	 4	; Allocate text mode mem
#define fVidTextMd	 (1 << 4)
#define bVidNTModeFF	 0	; NoTrap: Mode F/F
#define fVidNTModeFF	 (1 << 0)
#define bVidNTModeFFC16	 1	; Default is 16 color mode
#define fVidNTModeFFC16	 (1 << 1)
#define bVidNTDispRW	 2	; NoTrap: Bank Register
#define fVidNTDispRW	 (1 << 2)
#define bVidNTPal	 3	; NoTrap: Palette
#define fVidNTPal	 (1 << 3)
#define bVidNTGDC	 5	; NoTrap: GDC
#define fVidNTGDC	 (1 << 5)
#define bVidNTGDCTON	 6	; Default Text on
#define fVidNTGDCTON	 (1 << 6)
#define bVidNTGDCGON	 7	; Default Grph on
#define fVidNTGDCGON	 (1 << 7)
#define bVidNTFont	 8	; NoTrap: KCG
#define fVidNTFont	 (1 << 8)
#define bVidCRTC	 9	; Use CRTC Tracer
#define fVidCRTC	 (1 << 9)
#define bVidDispDataXfer 10	; Transrate mode (0:Text, 1:Text/Grph)
#define fVidDispDataXfer (1 << 10)
#define bVidXFERPlane0	 11	; Transrate plane Blue
#define fVidXFERPlane0	 (1 << 11)
#define bVidXFERPlane1	 12	; 		  Red
#define fVidXFERPlane1	 (1 << 12)
#define bVidXFERPlane2	 13	; 		  Green
#define fVidXFERPlane2	 (1 << 13)
#define bVidXFERPlane3	 14	; 		  Intensity
#define fVidXFERPlane3	 (1 << 14)

#define mVidXFERPlane	(fVidXFERPlane0+fVidXFERPlane1+fVidXFERPlane2+fVidXFERPlane3)
#define mVidNTH98	(fVidNTModeFF+fVidNTModeFFC16+fVidNTDispRW+fVidNTPal+fVidNTGDC+fVidNTGDCTON+fVidNTGDCGON)
#else //NEC_98
#define fVidTxtEmulate  0x0001  // Do INT 10h TTY and cursor emulation
#define fVidNoTrpTxt    0x0002  // Do not trap text mode apps
#define fVidNoTrpLRGrfx 0x0004  // Do not trap lo res graphics mode apps
#define fVidNoTrpHRGrfx 0x0008  // Do not trap hi res graphics mode apps
#define fVidTextMd      0x0010  // Allocate text mode mem
#define fVidLowRsGrfxMd 0x0020  // Allocate lo res graphics mode mem
#define fVidHghRsGrfxMd 0x0040  // Allocate hi res graphics mode mem
#define fVidRetainAllo  0x0080  // Never deallocate once allocated
#endif //NEC_98

//
// The following stuff was added for mini-VDD support:
//
// Functions that we can call in the hardware-dependent mini-VDD.  Note that
// these equates are used to create the dispatch table for calling functions
// in the mini-VDD:
//
#ifdef NEC_98
#define REGISTER_DISPLAY_DRIVER 	     0
#define PRE_HIRES_TO_VGA		     1
#define SAVE_REGISTERS			     2
#define RESTORE_REGISTERS		     3
#define ENABLE_TRAPS			     4
#define DISABLE_TRAPS			     5
#define DISPLAY_DRIVER_DISABLING	     6
#define ENABLE_ACCELERATER		     7
#define DISABLE_ACCELERATER		     8
#define CHECK_UPDATE			     9
#define CHECK_WINDOWED			     10
#define ACC_VBE_PM			     11
#define ACC_VBE_DDC			     12
#define ACC_INT_10			     13
#define ACC_GET_CAPABILITIES		     14
#define ACC_GET_EXT_MODE_INFO		     15
#define ACC_GET_FLAT_SELECTOR		     16
#define ACC_ENABLE_BIOS			     17
#define ACC_DISABLE_BIOS		     18
#define ACC_SET_PALETTE			     19
#define ACC_GET_PALETTE			     20
#define ACC_SET_CURSOR			     21
#define ACC_SHOW_CURSOR			     22
#define ACC_HIDE_CURSOR			     23
#define ACC_SET_CURSOR_POS		     24
#define ACC_GET_CURSOR_POS		     25
;
#define NBR_MINI_VDD_FUNCTIONS               26      //REMEMBER TO RESET THIS!!!!!!
#else //NEC_98
#define REGISTER_DISPLAY_DRIVER              0
#define GET_VDD_BANK                         1
#define SET_VDD_BANK                         2
#define RESET_BANK                           3
#define PRE_HIRES_TO_VGA                     4
#define POST_HIRES_TO_VGA                    5
#define PRE_VGA_TO_HIRES                     6
#define POST_VGA_TO_HIRES                    7
#define SAVE_REGISTERS                       8
#define RESTORE_REGISTERS                    9
#define MODIFY_REGISTER_STATE                10
#define ACCESS_VGA_MEMORY_MODE               11
#define ACCESS_LINEAR_MEMORY_MODE            12
#define ENABLE_TRAPS                         13
#define DISABLE_TRAPS                        14
#define MAKE_HARDWARE_NOT_BUSY               15
#define VIRTUALIZE_CRTC_IN                   16
#define VIRTUALIZE_CRTC_OUT                  17
#define VIRTUALIZE_SEQUENCER_IN              18
#define VIRTUALIZE_SEQUENCER_OUT             19
#define VIRTUALIZE_GCR_IN                    20
#define VIRTUALIZE_GCR_OUT                   21
#define SET_LATCH_BANK                       22
#define RESET_LATCH_BANK                     23
#define SAVE_LATCHES                         24
#define RESTORE_LATCHES                      25
#define DISPLAY_DRIVER_DISABLING             26
#define SELECT_PLANE                         27
#define PRE_CRTC_MODE_CHANGE                 28
#define POST_CRTC_MODE_CHANGE                29
#define VIRTUALIZE_DAC_OUT                   30
#define VIRTUALIZE_DAC_IN                    31
#define GET_CURRENT_BANK_WRITE               32
#define GET_CURRENT_BANK_READ                33
#define SET_BANK                             34
#define CHECK_HIRES_MODE                     35
#define GET_TOTAL_VRAM_SIZE                  36
#define GET_BANK_SIZE                        37
#define SET_HIRES_MODE                       38
#define PRE_HIRES_SAVE_RESTORE               39
#define POST_HIRES_SAVE_RESTORE              40
#define VESA_SUPPORT                         41
#define GET_CHIP_ID                          42
#define CHECK_SCREEN_SWITCH_OK               43
#define VIRTUALIZE_BLTER_IO                  44
#define SAVE_MESSAGE_MODE_STATE              45
#define SAVE_FORCED_PLANAR_STATE             46
#define VESA_CALL_POST_PROCESSING            47
#define PRE_INT_10_MODE_SET                  48
#define NBR_MINI_VDD_FUNCTIONS_40            49      //REMEMBER TO RESET THIS!!!!!!

//
//  new miniVDD functions that a 4.1 miniVDD should implement
//
#define GET_NUM_UNITS                        49
#define TURN_VGA_OFF                         50
#define TURN_VGA_ON                          51
#define SET_ADAPTER_POWER_STATE              52
#define GET_ADAPTER_POWER_STATE_CAPS         53
#define SET_MONITOR_POWER_STATE              54
#define GET_MONITOR_POWER_STATE_CAPS         55
#define NBR_MINI_VDD_FUNCTIONS_41            56

#ifdef MAINVDD
#define NBR_MINI_VDD_FUNCTIONS  NBR_MINI_VDD_FUNCTIONS_41
#else
#define NBR_MINI_VDD_FUNCTIONS  NBR_MINI_VDD_FUNCTIONS_40
#endif

#endif //NEC_98

#endif /*NotVxD*/

//
// Following are function codes that can be called via the VDD's
// API entry point. These are mainly for display driver --> VDD communication.
// Since Windows 3.0 and 3.1 VDD's may have used the sequential numbers
// (after the Grabber functions) for other VDD API services, we start our
// numbering at 80H so as to avoid ugly conflicts with old 3.1 stuff:
//
// all these entry points take as input:
//
// Entry:
//      Client_EAX  - function code.
//      Client_EBX  - device handle, or device id (1-N)
//
#define VDD_QUERY_VERSION                   0
#define MINIVDD_SVC_BASE_OFFSET             0x80
#define VDD_DRIVER_REGISTER                 (0  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_DRIVER_UNREGISTER               (1  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_SAVE_DRIVER_STATE               (2  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_REGISTER_DISPLAY_DRIVER_INFO    (3  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_REGISTER_SSB_FLAGS              (4  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_GET_DISPLAY_CONFIG              (5  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_PRE_MODE_CHANGE                 (6  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_POST_MODE_CHANGE                (7  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_SET_USER_FLAGS                  (8  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_SET_BUSY_FLAG_ADDR              (9  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_PC98_RESERVED                   (10 + MINIVDD_SVC_BASE_OFFSET)
#define VDD_VBE_PM                          (10 + MINIVDD_SVC_BASE_OFFSET)
//
//   all functions >= VDD_ENABLE also take the following params:
//
//      Client_ES:DI    - buffer
//      Client_ECX      - buffer size
//      Client_EDX      - flags
//
// Exit:
//      Client_EAX  = function code  if the function is not supported.
//                  = 0              if the function succeded.
//                  = -1             if the function failed.
//
#define VDD_ENABLE                          (11 + MINIVDD_SVC_BASE_OFFSET)
#define VDD_GETMEMBASE                      (12 + MINIVDD_SVC_BASE_OFFSET)
#define VDD_OPEN                            (13 + MINIVDD_SVC_BASE_OFFSET)
#define VDD_CLOSE                           (14 + MINIVDD_SVC_BASE_OFFSET)
#define VDD_OPEN_KEY                        (15 + MINIVDD_SVC_BASE_OFFSET)
#define VDD_SET_POWER_STATE                 (16 + MINIVDD_SVC_BASE_OFFSET)
#define VDD_ENUM                            (17 + MINIVDD_SVC_BASE_OFFSET)

//
// special verion of VDD_GET_DISPLAY_CONFIG that always get the
// monitor data, even if the user has disabled using a refresh rate.
//
#define VDD_GET_DISPLAY_CONFIG2             0x8085

//
//  VDD_DRIVER_REGISTER
//
//  The display driver sends us some information needed to handle various
//  context changes.
//
//  Entry:
//         Client_ES:DI Selector:Offset of callback routine used
//                      to reset to Windows HiRes mode upon return
//                      from a full screen DOS VM to the Windows VM.
//         Client_ES    Main code segment of display driver.
//         Client_ECX   contains the total nbr of bytes on-screen (excluding
//                      off-screen memory).
//         Client_EDX   contain 0 if we are to attempt to allow 4 plane VGA
//                      virtualization.
//         Client_EDX   contains -1 if we are to not allow 4 plane VGA
//                      virtualization.
//         Client_EBX   device handle, or device id (1-N)
//  Exit:
//         Client_EAX   contains total bytes of memory used by visible screen
//                      AND the VDD virtualization area (ie: the start of
//                      off-screen memory available for use by the display
//                      driver as "scratch" memory).
//

//
//  VDD_DRIVER_UNREGISTER
//
//  Entry:
//          Client_EBX   device handle, or device id (1-N)
//  Exit:
//

//
//  VDD_ENABLE
//
//  entry:
//      Client_EAX      - VDD_ENABLE (0x008B)
//      Client_EBX      - device handle, or device id (1-N)
//      Client_EDX      - enable flags (see below)
//
//  exit:
//      Client_EAX      - previous enable state.
//
//  only one device at a time can have VGAMEM, VGAIO, or ROM access
//  at a time.
//
#define ENABLE_IO               0x00000001  // enable IO.
#define ENABLE_MEM              0x00000002  // enable memory.
#define ENABLE_VGA              0x00000030  // enable VGA
#define ENABLE_ROM              0x00000080  // enable ROM at C000.
#define ENABLE_ALL              0x000000FF  // enable all access to this device
#define ENABLE_NONE             0x00000000  // disable device.
#define ENABLE_VALID            0x000000FF  // valid flags.
#define ENABLE_ERROR            0xFFFFFFFF  // enable fail code

//
//  VDD_OPEN
//
//      open a device given a name
//
//  Entry:
//          Client_ES:EDI   - device name
//          Client_EDX      - flag
//  Exit:
//          Client_EAX      - device handle
//
#define VDD_OPEN_TEST       0x00000001


//
//  WIN32 IOCTLS
//
//  The following defines are used with the Win32 function DeviceIOControl
//
#define VDD_IOCTL_SET_NOTIFY    0x10000001  // set mode change notify
#define VDD_IOCTL_GET_DDHAL     0x10000002  // get DDHAL functions from miniVDD

//
//  VDD_IOCTL_SET_NOTIFY
//
//  sets a notification function that will be called when events
//  happen on the device.
//
//  input:
//          NotifyMask      - bitfield of events
//          NotifyType      - type of notify
//          NotifyProc      - notify procedure
//          NotifyData      - client data
//
//  output:
//           none
//
//  return:
//          ERROR_SUCCES
//
typedef struct tagVDD_IOCTL_SET_NOTIFY_INPUT {
    DWORD   NotifyMask;
    DWORD   NotifyType;
    DWORD   NotifyProc;
    DWORD   NotifyData;
}   VDD_IOCTL_SET_NOTIFY_INPUT;


//
// NotifyMask
//
#define VDD_NOTIFY_START_MODE_CHANGE    0x00000001
#define VDD_NOTIFY_END_MODE_CHANGE      0x00000002
#define VDD_NOTIFY_ENABLE               0x00000004
#define VDD_NOTIFY_DISABLE              0x00000008

//
//  NotifyType
//
#define VDD_NOTIFY_TYPE_CALLBACK        1


//
// Port size equates:
//
#define BYTE_LENGTHED                       1
#define WORD_LENGTHED                       2

//
// Flag equates:
//
#define GOING_TO_WINDOWS_MODE               1
#define GOING_TO_VGA_MODE                   2
#define DISPLAY_DRIVER_DISABLED             4
#define IN_WINDOWS_HIRES_MODE               8

//
//  DISPLAYINFO structure
//
typedef struct DISPLAYINFO {
        WORD  diHdrSize;
        WORD  diInfoFlags;
        //
        //  display mode specific data
        //
        DWORD diDevNodeHandle;
        char  diDriverName[16];
        WORD  diXRes;
        WORD  diYRes;
        WORD  diDPI;
        BYTE  diPlanes;
        BYTE  diBpp;
        //
        //  monitor specific data
        //
        WORD  diRefreshRateMax;
        WORD  diRefreshRateMin;
        WORD  diLowHorz;
        WORD  diHighHorz;
        WORD  diLowVert;
        WORD  diHighVert;
        DWORD diMonitorDevNodeHandle;
        BYTE  diHorzSyncPolarity;
        BYTE  diVertSyncPolarity;
        //
        // new 4.1 stuff
        //
        DWORD diUnitNumber;             // device unit number
        DWORD diDisplayFlags;           // mode specific flags
        DWORD diXDesktopPos;            // position of desktop
        DWORD diYDesktopPos;            // ...
        DWORD diXDesktopSize;           // size of desktop (for panning)
        DWORD diYDesktopSize;           // ...

} DISPLAYINFO;

/*ASM
DISPLAYINFO_SIZE    equ  diRefreshRateMax+2-diHdrSize
DISPLAYINFO_SIZE1   equ  diBpp+1-diHdrSize
DISPLAYINFO_SIZE2   equ  diVertSyncPolarity+1-diHdrSize
DISPLAYINFO_SIZE3   equ  diMemorySize+4-diHdrSize
*/

//
// Following are values for the diInfoFlags word in DISPLAYINFO:
//
#define RETURNED_DATA_IS_STALE           0x0001
#define MINIVDD_FAILED_TO_LOAD           0x0002
#define MINIVDD_CHIP_ID_DIDNT_MATCH      0x0004
#define REGISTRY_BPP_NOT_VALID           0x0008
#define REGISTRY_RESOLUTION_NOT_VALID    0x0010
#define REGISTRY_DPI_NOT_VALID           0x0020
#define MONITOR_DEVNODE_NOT_ACTIVE       0x0040
#define MONITOR_INFO_NOT_VALID           0x0080
#define MONITOR_INFO_DISABLED_BY_USER    0x0100
#define REFRESH_RATE_MAX_ONLY            0x0200
#define CARD_VDD_LOADED_OK               0x0400
#define DEVICE_IS_NOT_VGA                0x0800

//
//  Following are explanations for the diInfoFlags word in DISPLAYINFO:
//
//  RETURNED_DATA_IS_STALE, if set, means that this call to VDD_GET_DISPLAY_CONFIG
//  or VDD_GetDisplayInfo (which are the Ring 3 and Ring 0 methods by which a
//  program would get the DISPLAYINFO structure returned to him) caused the VDD
//  to return data that was read in a previous call to VDD_GET_DISPLAY_CONFIG
//  insted of actually going out and reading "fresh" data from the Registry.
//
//  This flag brings to light the fact that there are some circumstances when the
//  VDD cannot go out and read the registry in response to the call to
//  VDD_GET_DISPLAY_CONFIG or VDD_GetDisplayInfo (due to system multi-tasking
//  considerations).  In this case, this flag will be set to a 1 to indicate that
//  the information being returned isn't "fresh" -- that is -- it may be
//  incorrect and obsolete.  The caller should respond accordingly if this flag
//  is set.
//
//
//  MINIVDD_FAILED_TO_LOAD if set, indicates that for some reason (typically
//  that the MiniVDD didn't match the chipset installed in the machine), the
//  MiniVDD didn't load.  Callers can examine this flag and act accordingly.
//
//
//  MINIVDD_CHIP_ID_DIDNT_MATCH means that although the MiniVDD did load
//  successfully, when the ChipID that the MiniVDD calculated was compared
//  against the value saved in the registry, they didn't match.  An example of
//  when this would happen is when the user is happily using an S3-911 card
//  and then decides to upgrade his display card to an S3-864.  Since both
//  cards use S3.VXD, the MiniVDD will load, however, since the card model
//  is different, the VDD will return a defect to configuration manager and
//  set this flag.  Callers of the GET_DISPLAY_CONFIG functions can use this
//  flag to take appropriate actions to make sure that the user gets his
//  configuration correct.
//
//
//  REGISTRY_BPP_NOT_VALID if set, means that we failed to obtain the BPP value
//  from the registry when the VDD tried to read it.
//
//
//  REGISTRY_RESOLUTION_NOT_VALID if set, means that we failed to obtain the
//  resolution value from the registry when the VDD tried to read it.
//
//
//  REGISTRY_DPI_NOT_VALID if set, means that we failed to obtain the
//  DPI value from the registry when the VDD tried to read it.
//
//
//  MONITOR_DEVNODE_NOT_ACTIVE is set if someone tries to make a call to the
//  GET_DISPLAY_CONFIG function before the monitor DevNode has been created.
//  This is certainly not fatal by any means.  It simply means that the
//  monitor refresh rate info in the DISPLAYINFO data structure is totally
//  invalid!
//
//
//  MONITOR_INFO_NOT_VALID indicates that something within the code which
//  retrieves and calculates the refresh rate data has failed.  This indicates
//  that the values in diRefreshRateMax through diVertSyncPolarity are not
//  valid and could contain random data.
//
//
//  MONITOR_INFO_DISABLED_BY_USER indicates that the either the RefreshRate=
//  string in SYSTEM.INI had a negative number in it or that the string in
//  the display's software key RefreshRate = string was 0 or a negative number.
//
//
//  REFRESH_RATE_MAX_ONLY indicates that there was no diLowHorz, diHighHorz,
//  diLowVert, diHighVert, or sync polarity data in the registry.  The
//  value returned in diRefreshRateMax is the only refresh rate data that
//  we have available.  This was derived either from RefreshRate= in SYSTEM.INI
//  or the display software key RefreshRate = string in the registry.
//
//
//  CARD_VDD_LOADED_OK indicates that a second MiniVDD (which is useful for
//  display card manufacturers wishing to extend the capabilities of the chip level
//  MiniVDD's ) has successfully been loaded and initialized.
//
//  DEVICE_IS_NOT_VGA indicates that this device is not the primary vga
//

#define NoTrace_VIRTUALIZE_CRTC_IN
#define NoTrace_VIRTUALIZE_CRTC_OUT
#define NoTrace_VIRTUALIZE_SEQUENCER_IN
#define NoTrace_VIRTUALIZE_SEQUENCER_OUT
#define NoTrace_VIRTUALIZE_GCR_IN
#define NoTrace_VIRTUALIZE_GCR_OUT
#define NoTrace_VIRTUALIZE_DAC_OUT
#define NoTrace_VIRTUALIZE_DAC_IN
#define NoTrace_CHECK_HIRES_MODE
/*ASM

ifdef NEC_98
;******************************************************************************
;				 E Q U A T E S
;******************************************************************************

    ;
    ;	Mini-VDD Static Flags
    ;
vFlg_Machine_Std	equ			00000001b
vFlg_Machine_Multi	equ			00000010b
vFlg_Machine_Mate	equ			00000100b
vFlg_Machine_H98	equ			00001000b
vFlg_CRT_New		equ			00010000b
vFlg_CRT_NonInter	equ			00100000b
vFlg_GDC_5MHz		equ			01000000b
vFlg_GDC_Emulate	equ			10000000b
vFlg_Acc_Internal	equ		0000000100000000b
vFlg_Acc_External	equ		0000001000000000b
vFlg_Acc_PCI		equ		0000010000000000b
vFlg_Acc_ML		equ		0000100000000000b
vFlg_Acc_PVD		equ		0001000000000000b
vFlg_Mode_NH		equ		0010000000000000b
vFlg_Mode_H		equ		0100000000000000b
vFlg_Initialized	equ		1000000000000000b
vFlg_Opt_MFR		equ	000000010000000000000000b
vFlg_Opt_NewMFR		equ	000000100000000000000000b
vFlg_Opt_VDP		equ	000001000000000000000000b
vFlg_Opt_NewVDP		equ	000010000000000000000000b

vFlg_Local		equ	000000000100000010000000b

    ;
    ;	Mini-VDD Support Max
    ;
MaxMiniVDD	equ	16
MaxMiniTrap	equ	32
MaxMultiTrap	equ	3
MaxMultiFunc	equ	MaxMiniVDD

    ;
    ;	MiniVDD_LTrap_Struct.LTrap_Status
    ;	MiniVDD_LTrap_Struct.LTrap_Flags.xxxx
    ;
LT_Enable	equ	00000001b
LT_Enable_bit	equ	0
LT_Initialized	equ	10000000b
LT_Initialized_bit equ	7


;******************************************************************************
;			D A T A   S T R U C T U R E S
;******************************************************************************

    ;
    ;	Vids_struct
    ;

Vids_struct struc
   ;
   ;	Common Data supplied by Base-VDD. Some data(bits) set by Mini-VDD.
   ;
	Vids_SFlags		dd	?	; Static flags
	Vids_CB_Offset		dd	?	; 
	Vids_Msg_Pseudo_VM	dd	?	; 

   ;
   ;	Common Procedure supplied by Base-VDD
   ;
	VDD_TGDC_Draw_Off	dd	?	; 
	VDD_TGDC_Sync_Off	dd	?	; 
	VDD_TGDC_Sync_On	dd	?	; 
	VDD_TGDC_FIFO_Empty	dd	?	; 
	VDD_GGDC_Draw_Off	dd	?	; 
	VDD_GGDC_Sync_Off	dd	?	; 
	VDD_GGDC_Sync_On	dd	?	; 
	VDD_GGDC_FIFO_Empty	dd	?	; 
	VDD_GGDC_MOD_Emulate	dd	?	; 

   ;
   ;	Common Procedure supplied by Mini-VDD
   ;
	H98_FLORA_Change	dd	?	; H98 - NH mode
	H98_Clear_Text		dd	?	; H98 - NH mode
	H98_Rest_GCs		dd	?	; H98
	H98_Rest_etc		dd	?	; H98
	H98_Save_ModeFF		dd	?	; H98

Vids_struct ends


Vid_SFlags		equ	<Vids.Vids_SFlags>
VDD_CB_Offset		equ	<Vids.Vids_CB_Offset>
VDD_Msg_Pseudo_VM	equ	<Vids.Vids_Msg_Pseudo_VM>

TGDC_Draw_Off		equ	<Vids.VDD_TGDC_Draw_Off>
GGDC_Draw_Off		equ	<Vids.VDD_GGDC_Draw_Off>
TGDC_Sync_On		equ	<Vids.VDD_TGDC_Sync_On>
TGDC_Sync_Off		equ	<Vids.VDD_TGDC_Sync_Off>
TGDC_FIFO_Empty		equ	<Vids.VDD_TGDC_FIFO_Empty>
GGDC_FIFO_Empty		equ	<Vids.VDD_GGDC_FIFO_Empty>


    ;
    ;	RegTrapStruct
    ;
MiniFuncStruct	STRUC
MF_ProcAddr	dd	?
;;MF_Order	dw	?
;;MF_MiniID	db	?
;;MF_Flags	db	?
MiniFuncStruct	ENDS

    ;
    ;	MiniProcStruct
    ;
MiniVDD_Proc_Struct	STRUC
Proc_Address	dd	?
Proc_Order	dw	?
Proc_MiniID	db	?
Proc_Flags	db	?
MiniVDD_Proc_Struct	ENDS
.errnz	(size MiniVDD_Proc_Struct) mod 4

    ;
    ;	MiniTrapTable	- Global Info
    ;	LocalTrapTable	- Local Status
    ;
MiniVDD_GTrap_Struct	STRUC
GTrap_ProcAddr	dd	?
GTrap_PortAddr	dw	?
GTrap_NumMini	dw	?
GTrap_ProcTable	db	((size MiniVDD_Proc_Struct) * MaxMultiTrap) dup (?)
MiniVDD_GTrap_Struct	ENDS

MiniVDD_LTrap_Struct	STRUC
LTrap_ProcAddr	dd	?
LTrap_Status	db	?
LTrap_Flags	db	MaxMultiTrap dup (?)
MiniVDD_LTrap_Struct	ENDS


;******************************************************************************
;				M A C R O S
;******************************************************************************

    ;
    ;	BeginMiniFunc	TableName
    ;	    MiniFunc	Function-ID, ProcedureName
    ;		|	
    ;	EndMiniFunc	TableName
    ;
EndMiniFunc_	MACRO	n
ifdef	MiniFunc&n
	dd	OFFSET32 MiniFunc&n		; MiniFuncStruct
else
	dd	0
endif
		ENDM

MiniFunc_	MACRO	FuncID, FuncName
		MiniFunc&FuncID equ <FuncName>
		ENDM

BeginMiniFunc	MACRO	TableName
public	TableName
TableName	label	near
		ENDM

EndMiniFunc	MACRO	TableName
		x = 0
		REPT	NBR_MINI_VDD_FUNCTIONS
		EndMiniFunc_	%x
		x = x + 1
		ENDM
		ENDM

MiniFunc	MACRO	FuncID, FuncName
		MiniFunc_ %(FuncID), <FuncName>
		ENDM

    ;
    ;	MiniVDDCall	Function-ID
    ;
MiniVDDCall	MACRO	FuncID, SetCarry
		local	MiniCall_Loop
		local	MiniCall_Exit

		push	ecx
		push	esi
		lea	esi, [MiniVDD_Func_Table][(size MiniVDD_Proc_Struct) * MaxMultiFunc * FuncID]
		mov	ecx, [MiniVDD_NumMini]
MiniCall_Loop:
		cmp	dword ptr [esi.Proc_Address], 0
		jz	MiniCall_Exit
		pushad
ifnb <SetCarry>
		stc
endif
		call	dword ptr [esi.Proc_Address]
		popad
		jc	MiniCall_Exit
		add	esi, size MiniVDD_Proc_Struct
		loop	MiniCall_Loop
MiniCall_Exit:
		pop	esi
		pop	ecx
		ENDM

    ;
    ;	MiniVDDCall	Function-ID
    ;
MiniVDDFunc	MACRO	TmpReg, FuncID
		mov	TmpReg, [MiniVDD_Func_Table.Proc_Address][(size MiniVDD_Proc_Struct) * MaxMultiFunc * FuncID]
		ENDM

    ;
    ;	ExecMode/ExecModeThru
    ;	ExecModeNot/ExecModeThruNot
    ;	ExecModeOnly
    ;	ExecModeOnlyNot
    ;	ExecModeElse
    ;	ExecModeElseNot
    ;	ExecModeEnd
    ;

ExecModeLL	macro	Num
ExecMode_L&Num:
		endm

ExecModeLE	macro	Num
ExecMode_E&Num:
		endm

ExecModeJE	macro	Num
	jmp	ExecMode_E&Num
		endm

ExecModeJZ	macro	Num
	jz	ExecMode_L&Num
		endm

ExecModeJNZ	macro	Num
	jnz	ExecMode_L&Num
		endm

ExecModeJEZ	macro	Num
	jz	ExecMode_E&Num
		endm

ExecModeJENZ	macro	Num
	jnz	ExecMode_E&Num
		endm


ExecModeTest	macro	ModeFlag, CB_Reg
if	ModeFlag and vFlg_Local
ifidni	<CB_Reg>, <Vid>
	push	ebx
	mov	ebx, [Vid_VM_Handle]
	add	ebx, [VDD_CB_Offset]
	test	[ebx.VDD_SFlags], ModeFlag
	pop	ebx
else
ifidni	<CB_Reg>, <Cur>
	push	ebx
	VMMCall	Get_Cur_VM_Handle
	add	ebx, [VDD_CB_Offset]
	test	[ebx.VDD_SFlags], ModeFlag
	pop	ebx
else
ifb	<CB_Reg>
	push	ebx
	add	ebx, [VDD_CB_Offset]
	test	[ebx.VDD_SFlags], ModeFlag
	pop	ebx
else
	test	[CB_Reg.VDD_SFlags], ModeFlag
endif
endif
endif
else
	test	[Vid_SFlags], ModeFlag
endif
	endm


ExecModeChk	macro	HdrFlag, JmpFlag, JmpLabel, ModeFlag, CB_Reg
ifidni	<HdrFlag>, <Jmp>
.erre	FlgExecMode
	ExecModeJE	%EndExecMode
endif
ExecModeLL	%NumExecMode
NumExecMode = NumExecMode + 1
FlgExecMode = 1
ifnb	<ModeFlag>
	ExecModeTest	<ModeFlag>, <CB_Reg>
ifidni	<JmpLabel>, <End>
ifidni	<JmpFlag>, <Not>
	ExecModeJENZ	%EndExecMode
else
	ExecModeJEZ	%EndExecMode
endif
else
ifidni	<JmpFlag>, <Not>
	ExecModeJNZ	%NumExecMode
else
	ExecModeJZ	%NumExecMode
endif
endif
endif
		endm

ExecModeEnd	macro
ExecModeLL	%NumExecMode
ExecModeLE	%EndExecMode
NumExecMode = NumExecMode + 1
EndExecMode = EndExecMode + 1
FlgExecMode = 0
		endm

   ;
   ;	CB_Reg   = Regs/Vid/Cur
   ;	ModeFlag = vFlg_xxxx
   ;
ExecModeJmp	macro	JmpLabel, ModeFlag, CB_Reg
	ExecModeTest	%ModeFlag, <CB_Reg>
	jnz	JmpLabel
		endm

ExecModeJmpNot	macro	JmpLabel, ModeFlag, CB_Reg
	ExecModeTest	%ModeFlag, <CB_Reg>
	jz	JmpLabel
		endm

ExecMode	macro	ModeFlag, CB_Reg
	ExecModeChk Top, Equ, Next, %ModeFlag, CB_Reg
		endm

ExecModeNot	macro	ModeFlag, CB_Reg
	ExecModeChk Top, Not, Next, %ModeFlag, CB_Reg
		endm

ExecModeOnly	macro	ModeFlag, CB_Reg
	ExecModeChk Top, Equ, End, %ModeFlag, CB_Reg
		endm

ExecModeOnlyNot	macro	ModeFlag, CB_Reg
	ExecModeChk Top, Not, End, %ModeFlag, CB_Reg
		endm

ExecModeElse	macro	ModeFlag, CB_Reg
	ExecModeChk Jmp, Equ, Next, %ModeFlag, CB_Reg
		endm

ExecModeElseNot	macro	ModeFlag, CB_Reg
	ExecModeChk Jmp, Not, Next, %ModeFlag, CB_Reg
		endm

ExecModeThru	macro	ModeFlag, CB_Reg
	ExecModeChk Thru, Equ, Next, %ModeFlag, CB_Reg
		endm

ExecModeThruNot	macro	ModeFlag, CB_Reg
	ExecModeChk Thru, Not, Next, %ModeFlag, CB_Reg
		endm

NumExecMode = 1
EndExecMode = 1
FlgExecMode = 0

else ;NEC_98
;
;Some external definitions.  Only define these if we're assembling the
;device independent "main" portion of the Mini-VDD:
;
ifdef MAINVDD
externdef	MiniVDDDispatchTable:dword	;in VDDCTL.ASM
endif ;MAINVDD
;
;
MiniVDDDispatch 	macro	FunctionCode, HandlerAddr
	mov	[edi+(FunctionCode*4)],OFFSET32 MiniVDD_&HandlerAddr
endm
;
;
CardVDDDispatch 	macro	FunctionCode, HandlerAddr
	mov	[edi+(FunctionCode*4)],OFFSET32 CardVDD_&HandlerAddr
endm
;
;
MiniVDDCall		macro	FunctionCode, SaveFlags
local   MiniVDDCallExit, MiniVDDCallLeave

ifdef MAXDEBUG
  ifndef NoTrace_&FunctionCode&
        Trace_Out "MiniVDDCall: &FunctionCode&"
  endif
endif
        push    edi                     ;;save this register for now
ifnb    <SaveFlags>
	pushfd				;;save the flags state
endif
	mov	edi,OFFSET32 MiniVDDDispatchTable
	cmp	dword ptr [edi+(FunctionCode*4)],0
	je	MiniVDDCallLeave	;;MiniVDD doesn't support this
ifnb	<SaveFlags>
	popfd				;;just clear the Stack from the flags
endif
        call    dword ptr [edi+(FunctionCode*4)]
ifnb	<SaveFlags>
	jmp	MiniVDDCallExit 	;;we already restored the flags
endif
;
MiniVDDCallLeave:
ifnb	<SaveFlags>
	popfd				;;
endif
;
MiniVDDCallExit:
	pop	edi			;;we're done handling this call
endm
endif ;NEC_98
*/

#endif  // _MINIVDD_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\kelvin\src\nvKelvinState.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvKelvinState.cpp
//      Kelvin state management routines.
//
// **************************************************************************
//
//  History:
//      Craig Duttweiler        12Mar00         NV20 development
//
// **************************************************************************

#include "nvprecomp.h"

#if (NVARCH >= 0x20)

// all elements of this matrix remain zero except the last row and the diagonal
// which get set appropriately in nvSetKelvinTransform
static D3DMATRIX mViewportMatrix = matrixZero;

#define PRECOMPILED_PASSTHROUGH
#ifdef PRECOMPILED_PASSTHROUGH

static BYTE kmpPassthruProgramSpecFog[] = {
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0xF8, 0x0F, 0x10, 0x1F,
    0xB0, 0x21, 0xD8, 0x20, 0xB0, 0x01, 0x00, 0x02, 0x18, 0xF8, 0x71, 0x90, 0xF1, 0x2F, 0xD8, 0x20,
    0xB0, 0x61, 0x00, 0x42, 0x20, 0xF8, 0x70, 0x10, 0xB0, 0x21, 0xD8, 0x20, 0xB0, 0x81, 0x00, 0x02,
    0x28, 0xF8, 0x70, 0x10, 0xB0, 0x21, 0xD8, 0x20, 0xF0, 0x8F, 0x00, 0x02, 0xF8, 0x0F, 0x10, 0x1F,
    0xB0, 0x61, 0xD8, 0x10, 0xB1, 0x01, 0x74, 0x04, 0x30, 0xF8, 0x70, 0x90, 0xB0, 0x21, 0xD8, 0x20,
    0x00, 0x20, 0x00, 0x02, 0x00, 0xF8, 0x70, 0x30, 0xB0, 0x21, 0xD8, 0x90, 0xB1, 0x01, 0x76, 0x06,
    0x48, 0xF8, 0x70, 0x90, 0xB0, 0x21, 0xD8, 0xA0, 0xB0, 0x21, 0x01, 0x02, 0x50, 0xF8, 0x70, 0x90,
    0xB0, 0x21, 0xD8, 0x20, 0xB0, 0x41, 0x01, 0x02, 0x58, 0xF8, 0x70, 0x10, 0xB0, 0x21, 0xD8, 0xA0,
    0xB0, 0x61, 0x01, 0x02, 0x61, 0xF8, 0x70, 0x90, 0xB0, 0x21, 0xD8, 0xA0, 0xB0, 0x81, 0x01, 0x02,
};

static BYTE kmpPassthruProgramZFog[] = {
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0xF8, 0x0F, 0x10, 0x1F,
    0xB0, 0x21, 0xD8, 0x20, 0xB0, 0x01, 0x00, 0x02, 0x18, 0xF8, 0x71, 0x90, 0xF1, 0x2F, 0xD8, 0x20,
    0xB0, 0x61, 0x00, 0x42, 0x20, 0xF8, 0x70, 0x10, 0xB0, 0x21, 0xD8, 0x20, 0xB0, 0x81, 0x00, 0x02,
    0x28, 0xF8, 0x70, 0x10, 0xB0, 0x21, 0xD8, 0x10, 0xA1, 0x0A, 0x00, 0x02, 0xF8, 0x0F, 0x10, 0x1F,
    0xB0, 0x61, 0xD8, 0x10, 0xB1, 0x01, 0x74, 0x04, 0x30, 0xF8, 0x70, 0x90, 0xB0, 0x21, 0xD8, 0x20,
    0x00, 0x20, 0x00, 0x02, 0x00, 0xF8, 0x70, 0x30, 0xB0, 0x21, 0xD8, 0x90, 0xB1, 0x01, 0x76, 0x06,
    0x48, 0xF8, 0x70, 0x90, 0xB0, 0x21, 0xD8, 0xA0, 0xB0, 0x21, 0x01, 0x02, 0x50, 0xF8, 0x70, 0x90,
    0xB0, 0x21, 0xD8, 0x20, 0xB0, 0x41, 0x01, 0x02, 0x58, 0xF8, 0x70, 0x10, 0xB0, 0x21, 0xD8, 0xA0,
    0xB0, 0x61, 0x01, 0x02, 0x61, 0xF8, 0x70, 0x90, 0xB0, 0x21, 0xD8, 0xA0, 0xB0, 0x81, 0x01, 0x02,
};

static BYTE kmpPassthruProgramWFog[] = {
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0xF8, 0x0F, 0x10, 0x1F,
    0xB0, 0x21, 0xD8, 0x20, 0xB0, 0x01, 0x00, 0x02, 0x18, 0xF8, 0x71, 0x90, 0xF1, 0x2F, 0xD8, 0x20,
    0xB0, 0x61, 0x00, 0x42, 0x20, 0xF8, 0x70, 0x10, 0xB0, 0x21, 0xD8, 0x20, 0xB0, 0x81, 0x00, 0x02,
    0x28, 0xF8, 0x70, 0x10, 0xB0, 0x21, 0xD8, 0x10, 0xF1, 0x0F, 0x00, 0x02, 0xF8, 0x0F, 0x10, 0x1F,
    0xB0, 0x61, 0xD8, 0x10, 0xB1, 0x01, 0x74, 0x04, 0x30, 0xF8, 0x70, 0x90, 0xB0, 0x21, 0xD8, 0x20,
    0x00, 0x20, 0x00, 0x02, 0x00, 0xF8, 0x70, 0x30, 0xB0, 0x21, 0xD8, 0x90, 0xB1, 0x01, 0x76, 0x06,
    0x48, 0xF8, 0x70, 0x90, 0xB0, 0x21, 0xD8, 0xA0, 0xB0, 0x21, 0x01, 0x02, 0x50, 0xF8, 0x70, 0x90,
    0xB0, 0x21, 0xD8, 0x20, 0xB0, 0x41, 0x01, 0x02, 0x58, 0xF8, 0x70, 0x10, 0xB0, 0x21, 0xD8, 0xA0,
    0xB0, 0x61, 0x01, 0x02, 0x61, 0xF8, 0x70, 0x90, 0xB0, 0x21, 0xD8, 0xA0, 0xB0, 0x81, 0x01, 0x02,
};

#else  // !PRECOMPILED_PASSTHROUGH

static char szPassthruProgramSpecFog[] = \
   "%!VP1.0                              \
    MOV R1,v[0];                         \
    MOV o[COL0],v[3] : RCP R1.w,R1.w;    \
    MOV o[COL1],v[4];                    \
    MOV o[FOGC],v[4].w;                  \
    MUL R1,R1,c[58];                     \
    MOV o[PSIZ],v[1].x;                  \
    ADD o[HPOS],R1,c[59];                \
    MOV o[TEX0],v[9];                    \
    MOV o[TEX1],v[10];                   \
    MOV o[TEX2],v[11];                   \
    MOV o[TEX3],v[12];";

static char szPassthruProgramZFog[] =    \
   "%!VP1.0                              \
    MOV R1,v[0];                         \
    MOV o[COL0],v[3] : RCP R1.w,R1.w;    \
    MOV o[COL1],v[4];                    \
    MOV o[FOGC],R1.z;                    \
    MUL R1,R1,c[58];                     \
    MOV o[PSIZ],v[1].x;                  \
    ADD o[HPOS],R1,c[59];                \
    MOV o[TEX0],v[9];                    \
    MOV o[TEX1],v[10];                   \
    MOV o[TEX2],v[11];                   \
    MOV o[TEX3],v[12];";

static char szPassthruProgramWFog[] =    \
   "%!VP1.0                              \
    MOV R1,v[0];                         \
    MOV o[COL0],v[3] : RCP R1.w,R1.w;    \
    MOV o[COL1],v[4];                    \
    MOV o[FOGC],R1.w;                    \
    MUL R1,R1,c[58];                     \
    MOV o[PSIZ],v[1].x;                  \
    ADD o[HPOS],R1,c[59];                \
    MOV o[TEX0],v[9];                    \
    MOV o[TEX1],v[10];                   \
    MOV o[TEX2],v[11];                   \
    MOV o[TEX3],v[12];";

#endif  // !PRECOMPILED_PASSTHROUGH

//---------------------------------------------------------------------------

// set things that are never changed in D3D. this routine is run once to initialize
// and then only whenever someone else (DDRAW) stomps on our kelvin object

HRESULT nvSetKelvinD3DDefaults (PNVD3DCONTEXT pContext)
{
    // clear the dirty bit
    pContext->hwState.dwDirtyFlags &= ~KELVIN_DIRTY_DEFAULTS;

    // context dmas
    pContext->hwState.kelvin.set3 (NV097_SET_CONTEXT_DMA_NOTIFIES,
                                   NV_DD_DMA_PUSHER_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY,   // notifier context
                                   D3D_CONTEXT_DMA_HOST_MEMORY,                            // texture context a - system/agp memory
                                   NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);                 // texture context b - video memory

#ifdef KELVIN_SEMAPHORES
    pContext->hwState.kelvin.set7 (NV097_SET_CONTEXT_DMA_STATE,
                                   NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY,                  // state context
                                   NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY,                  // frame buffer context
                                   NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY,                  // zeta buffer context
                                   D3D_CONTEXT_DMA_HOST_MEMORY,                            // vertex buffer context a
                                   NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY,                // vertex buffer context b
                                   CSemaphoreManager::SEMAPHORE_CONTEXT_DMA_IN_MEMORY,     // semaphore context
                                   NV01_NULL_OBJECT);                                      // report context
#else
    pContext->hwState.kelvin.set7 (NV097_SET_CONTEXT_DMA_STATE,
                                   NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY,                  // state context
                                   NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY,                  // frame buffer context
                                   NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY,                  // zeta buffer context
                                   D3D_CONTEXT_DMA_HOST_MEMORY,                            // vertex buffer context a
                                   NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY,                // vertex buffer context b
                                   NV01_NULL_OBJECT,                                       // semaphore context
                                   NV01_NULL_OBJECT);                                      // report context
#endif

    // use the first vertex to determine the color used for flat-shading
    pContext->hwState.kelvin.set1 (NV097_SET_FLAT_SHADE_OP, NV097_SET_FLAT_SHADE_OP_V_FIRST_VTX);

    // clipping is inclusive of boundaries
    pContext->hwState.kelvin.set1 (NV097_SET_WINDOW_CLIP_TYPE, NV097_SET_WINDOW_CLIP_TYPE_V_INCLUSIVE);

    // deactivate all but the first clip rectangle
    for (DWORD dwWindow=1; dwWindow < KELVIN_NUM_WINDOWS; dwWindow++) {
        pContext->hwState.kelvin.set1 (NV097_SET_WINDOW_CLIP_HORIZONTAL(dwWindow), 0);
        pContext->hwState.kelvin.set1 (NV097_SET_WINDOW_CLIP_VERTICAL(dwWindow), 0);
    }

    // no point params until DX8
    if (global.dwDXRuntimeVersion < 0x0800) {
        pContext->hwState.kelvin.set1 (NV097_SET_POINT_PARAMS_ENABLE, NV097_SET_POINT_PARAMS_ENABLE_V_FALSE);
    }

    // D3D has no smoothing (note smoothing != anti-aliasing!)
    pContext->hwState.kelvin.set3 (NV097_SET_POINT_SMOOTH_ENABLE,
                                   NV097_SET_POINT_SMOOTH_ENABLE_V_FALSE,
                                   NV097_SET_LINE_SMOOTH_ENABLE_V_FALSE,
                                   NV097_SET_POLY_SMOOTH_ENABLE_V_FALSE);

    // blend color not available in d3d
    pContext->hwState.kelvin.set1 (NV097_SET_BLEND_COLOR, 0);

    // line and point sizes are just one pixel (in DX7. this changes in DX8)
    pContext->hwState.kelvin.set1 (NV097_SET_LINE_WIDTH, 0x00000008);  // 6.3 format
    pContext->hwState.kelvin.set1 (NV097_SET_POINT_SIZE, 0x00000008);  // 6.3 format

    pContext->hwState.kelvin.set1 (NV097_SET_EDGE_FLAG, NV097_SET_EDGE_FLAG_V_TRUE);

    // initialize immediate mode data
    pContext->hwState.kelvin.set3f (NV097_SET_NORMAL3F(0), 0.0f, 0.0f, 1.0f);

    pContext->hwState.kelvin.set4f (NV097_SET_TEXCOORD0_4F(0), 0.0f, 0.0f, 0.0f, 1.0f);
    pContext->hwState.kelvin.set4f (NV097_SET_TEXCOORD1_4F(0), 0.0f, 0.0f, 0.0f, 1.0f);
    pContext->hwState.kelvin.set4f (NV097_SET_TEXCOORD2_4F(0), 0.0f, 0.0f, 0.0f, 1.0f);
    pContext->hwState.kelvin.set4f (NV097_SET_TEXCOORD3_4F(0), 0.0f, 0.0f, 0.0f, 1.0f);

    pContext->hwState.kelvin.set1f (NV097_SET_FOG1F, 0.0f);

    // set image (unswizzled) texture pitch to an allowable, innocuous value
    for (DWORD dwTex=0; dwTex < KELVIN_NUM_TEXTURES; dwTex++) {
        pContext->hwState.kelvin.set1 (NV097_SET_TEXTURE_CONTROL1(dwTex),
                                       DRF_NUM (097, _SET_TEXTURE_CONTROL1, _IMAGE_PITCH, 0x0008));
    }

    // swath width for the boustrophedonic rasterization
    // todo - use montrym's algorithm
    pContext->hwState.kelvin.set1 (NV097_SET_SWATH_WIDTH, NV097_SET_SWATH_WIDTH_V_128);

    pContext->hwState.kelvin.set4f (NV097_SET_EYE_POSITION(0),  0.0f, 0.0f, 0.0f, 1.0f);
    pContext->hwState.kelvin.set3f (NV097_SET_EYE_DIRECTION(0), 0.0f, 0.0f,-1.0f);

    // we'll always cull what we call backfacing geometry.
    // this goes along with D3D's definition of culling.
    pContext->hwState.kelvin.set1 (NV097_SET_CULL_FACE, NV097_SET_CULL_FACE_V_BACK);

    // always clip <0
    pContext->hwState.kelvin.set1 (NV097_SET_SHADER_CLIP_PLANE_MODE, 0);

    // fog plane
    pContext->hwState.kelvin.set4f (NV097_SET_FOG_PLANE(0), 0.0f, 0.0f, 1.0f, 0.0f);

#ifndef DISABLE_Z_COMPR
    // compressed z
    if ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_ZCOMPRESSENABLE_MASK) == D3D_REG_ZCOMPRESSENABLE_ENABLE) {
        pContext->hwState.kelvin.set1 (NV097_SET_COMPRESS_ZBUFFER_EN, NV097_SET_COMPRESS_ZBUFFER_EN_V_ENABLE);
    }
#endif

    // no two-sided lighting in d3d (maybe in dx8?)
    pContext->hwState.kelvin.set1 (NV097_SET_TWO_SIDE_LIGHT_EN, NV097_SET_TWO_SIDE_LIGHT_EN_V_FALSE);

    // set up clipping in z and w. for now default to strict nv10-like behavior
    pContext->hwState.kelvin.set1 (NV097_SET_ZMIN_MAX_CONTROL,
                                   (DRF_DEF (097, _SET_ZMIN_MAX_CONTROL, _CULL_NEAR_FAR_EN, _TRUE) |
                                    DRF_DEF (097, _SET_ZMIN_MAX_CONTROL, _ZCLAMP_EN, _CULL)        |
                                    DRF_DEF (097, _SET_ZMIN_MAX_CONTROL, _CULL_IGNORE_W, _FALSE)));

    // for DX7, dependent texture lookups always run between stages i and i+1
    pContext->hwState.kelvin.set1 (NV097_SET_SHADER_OTHER_STAGE_INPUT,
                                   (DRF_DEF (097, _SET_SHADER_OTHER_STAGE_INPUT, _STAGE1, _INSTAGE_0) |
                                    DRF_DEF (097, _SET_SHADER_OTHER_STAGE_INPUT, _STAGE2, _INSTAGE_1) |
                                    DRF_DEF (097, _SET_SHADER_OTHER_STAGE_INPUT, _STAGE3, _INSTAGE_2)));

    dbgFlushType (NVDBG_FLUSH_STATE);

    return (D3D_OK);
}

//---------------------------------------------------------------------------

// set surface info: offset, pitch, clip

HRESULT nvSetKelvinSurfaceInfo (PNVD3DCONTEXT pContext)
{
    DWORD dwFormat;
    DWORD dwOffset, dwPitch;
    DWORD dwZOffset, dwZPitch;
    DWORD dwClipH, dwClipV;  // horizontal and vertical clip locations
    DWORD dwOcclude;

    pContext->hwState.dwDirtyFlags &= ~KELVIN_DIRTY_SURFACE;

    // get  render targets
#if (NVARCH >= 0x020)
    CSimpleSurface *pRenderTarget = pContext->kelvinAA.GetCurrentRT(pContext);
    CSimpleSurface *pZetaBuffer = pContext->kelvinAA.GetCurrentZB(pContext);
#else
    CSimpleSurface *pRenderTarget = pContext->pRenderTarget;
    CSimpleSurface *pZetaBuffer = pContext->pZetaBuffer;
#endif

    nvAssert (pRenderTarget);

    // surface formats
    dwFormat = DRF_NUM (097, _SET_SURFACE_FORMAT, _COLOR, nv097SurfaceFormat[pRenderTarget->getFormat()]);

    if (pRenderTarget->isSwizzled()) {
        CTexture* pTexture = pRenderTarget->getWrapper()->getTexture();
        nvAssert(pTexture);
        dwFormat |= DRF_DEF (097, _SET_SURFACE_FORMAT, _TYPE, _SWIZZLE);
        dwFormat |= DRF_NUM (097, _SET_SURFACE_FORMAT, _WIDTH,  pTexture->getLogWidth());
        dwFormat |= DRF_NUM (097, _SET_SURFACE_FORMAT, _HEIGHT, pTexture->getLogHeight());
    }
    else {
        dwFormat |= DRF_DEF (097, _SET_SURFACE_FORMAT, _TYPE, _PITCH);
    }

    dwFormat |= pZetaBuffer ?
                DRF_NUM (097, _SET_SURFACE_FORMAT, _ZETA, nv097SurfaceFormat[pZetaBuffer->getFormat()]) :
                // no zbuffer - set the format according to the render target bit depth to prevent an RM exception
                DRF_NUM (097, _SET_SURFACE_FORMAT, _ZETA, (pRenderTarget->getBPP() == 2) ?
                         NV097_SET_SURFACE_FORMAT_ZETA_Z16 : NV097_SET_SURFACE_FORMAT_ZETA_Z24S8);

    dwFormat |= pContext->kelvinAA.GetAAFormat();

    // render target pitch and offset
#ifdef STEREO_SUPPORT
    dwOffset = GetStereoOffset(pRenderTarget);
#else  //STEREO_SUPPORT==0
    dwOffset = pRenderTarget->getOffset();
#endif //STEREO_SUPPORT
    dwPitch  = pRenderTarget->getPitch();

    // zeta buffer pitch and offset
    if (pZetaBuffer) {
#ifdef  STEREO_SUPPORT
        dwZOffset = GetStereoOffset(pZetaBuffer);
#else //STEREO_SUPPORT==0
        dwZOffset = pZetaBuffer->getOffset();
#endif//STEREO_SUPPORT
        dwZPitch  = pZetaBuffer->getPitch();
    }
    else {
        dwZOffset = 0;
        dwZPitch  = KELVIN_ALIGNMENT_MIN;
    }

    // send everything to the HW
    pContext->hwState.kelvin.set3 (NV097_SET_SURFACE_PITCH,
                                   (DRF_NUM (097, _SET_SURFACE_PITCH, _COLOR, dwPitch) |
                                    DRF_NUM (097, _SET_SURFACE_PITCH, _ZETA,  dwZPitch)),
                                   dwOffset,
                                   dwZOffset);
    pContext->hwState.kelvin.set1 (NV097_SET_SURFACE_FORMAT, dwFormat);

    // since we're using the window clip to clip to the viewport,
    // the surface clip can just clip to the whole window.
    dwClipH = DRF_NUM (097, _SET_SURFACE_CLIP_HORIZONTAL, _X, 0) |
              DRF_NUM (097, _SET_SURFACE_CLIP_HORIZONTAL, _WIDTH, ((DWORD)pRenderTarget->getWidth()));
    dwClipV = DRF_NUM (097, _SET_SURFACE_CLIP_VERTICAL, _Y, 0) |
              DRF_NUM (097, _SET_SURFACE_CLIP_VERTICAL, _HEIGHT, ((DWORD)pRenderTarget->getHeight()));

    pContext->hwState.kelvin.set2 (NV097_SET_SURFACE_CLIP_HORIZONTAL, dwClipH, dwClipV);

    // set up occlusion culling. this doesn't logically belong here, but ends up here
    // because of an unfortunate HW bug that yields a dependancy on z-buffer format

    // BUGBUG: BSK 1/5/00 -- Disable Z CULL in AA modes -- it's broken and yet slow. Remove this for NV25.
    if (pZetaBuffer && !pContext->kelvinAA.IsEnabled() && ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_ZCULLENABLE_MASK) == D3D_REG_ZCULLENABLE_ENABLE)) {
        dwOcclude  = DRF_DEF (097, _SET_OCCLUDE_ZSTENCIL_EN, _OCCLUDE_STENCIL_EN, _ENABLE);
        dwOcclude |= (pZetaBuffer->getBPP() == 2) ?
                     DRF_DEF (097, _SET_OCCLUDE_ZSTENCIL_EN, _OCCLUDE_ZEN, _DISABLE) :
                     DRF_DEF (097, _SET_OCCLUDE_ZSTENCIL_EN, _OCCLUDE_ZEN, _ENABLE);
    }
    else {
        dwOcclude  = DRF_DEF (097, _SET_OCCLUDE_ZSTENCIL_EN, _OCCLUDE_STENCIL_EN, _DISABLE) |
                     DRF_DEF (097, _SET_OCCLUDE_ZSTENCIL_EN, _OCCLUDE_ZEN, _DISABLE);
    }
    pContext->hwState.kelvin.set1 (NV097_SET_OCCLUDE_ZSTENCIL_EN, dwOcclude);

    // cache the z scales
    if (pZetaBuffer) {
        if (pZetaBuffer->getBPP() == 2) {
            pContext->hwState.dvZScale    = KELVIN_Z_SCALE16;
            pContext->hwState.dvInvZScale = KELVIN_Z_SCALE16_INV;
        }
        else {
            pContext->hwState.dvZScale    = KELVIN_Z_SCALE24;
            pContext->hwState.dvInvZScale = KELVIN_Z_SCALE24_INV;
        }
    }

    dbgFlushType (NVDBG_FLUSH_STATE);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

// set up the combiners to produce one of the legacy D3D texture blends

HRESULT nvKelvinSetTextureBlend (PNVD3DCONTEXT pContext)
{
    DWORD dwTBlend;

    if (pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP]) {

        // we have a texture. go ahead and do the blend

        dwTBlend = pContext->dwRenderState[D3DRENDERSTATE_TEXTUREMAPBLEND];

        nvAssert (dwTBlend <= D3D_TBLEND_MAX);  // make sure we're not off the end of the table

        pContext->hwState.dwAlphaICW[0] = kelvinTextureBlendSettings[dwTBlend][0];
        pContext->hwState.dwColorICW[0] = kelvinTextureBlendSettings[dwTBlend][1];
        pContext->hwState.dwAlphaOCW[0] = kelvinTextureBlendSettings[dwTBlend][2];
        pContext->hwState.dwColorOCW[0] = kelvinTextureBlendSettings[dwTBlend][3];

        // handle the stupid special case in which we have TBLEND_MODULATE and a
        // texture without alpha; use D3DTBLEND_MODULATEALPHA instead
        if (dwTBlend == D3DTBLEND_MODULATE) {
            CTexture *pTexture = ((CNvObject *)(pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP]))->getTexture();
            if (!pTexture->hasAlpha()) {
                pContext->hwState.dwAlphaICW[0] = kelvinTextureBlendSettings[D3DTBLEND_MODULATEALPHA][0];
            }
        }

        pContext->hwState.dwTexUnitToTexStageMapping[0] = 0;

    }

    else {

        // they've enabled a texture blend without a texture. just use diffuse
        pContext->hwState.dwAlphaICW[0] = kelvinTextureBlendDefault[0];
        pContext->hwState.dwColorICW[0] = kelvinTextureBlendDefault[1];
        pContext->hwState.dwAlphaOCW[0] = kelvinTextureBlendDefault[2];
        pContext->hwState.dwColorOCW[0] = kelvinTextureBlendDefault[3];

    }

    return (D3D_OK);
}

//---------------------------------------------------------------------------

// set up the kelvin combiners for either the current texture stage state
// or a legacy texture blend

HRESULT nvSetKelvinColorCombiners     (PNVD3DCONTEXT pContext)
{
    DWORD dwStage;
    BOOL  bStageActive;
    DWORD dwMapping[KELVIN_NUM_TEXTURES];
    DWORD dwControl;

    pContext->hwState.dwDirtyFlags &= ~KELVIN_DIRTY_COMBINERS_COLOR;

    // save off the last prim type for which combiners were set up (affects point sprites)
    pContext->hwState.dwCombinerDP2Prim = pContext->dp2.dwDP2Prim;

    // cache current values
    for (dwStage = 0; dwStage < KELVIN_NUM_TEXTURES; dwStage++) {
        dwMapping[dwStage] = pContext->hwState.dwTexUnitToTexStageMapping[dwStage];
    }

    // clear state that will be re-determined here
    pContext->hwState.dwNumActiveCombinerStages = 0;
    for (dwStage=0; dwStage < KELVIN_NUM_TEXTURES; dwStage++) {
        pContext->hwState.dwTexUnitToTexStageMapping[dwStage] = KELVIN_UNUSED;
    }

    pContext->hwState.dwNextAvailableTextureUnit = ((pContext->dwRenderState[D3DRS_POINTSPRITEENABLE]) &&
                                                    (pContext->dp2.dwDP2Prim == D3DDP2OP_POINTS)) ? 3 : 0;

    if (pContext->bUseTBlendSettings) {

        nvKelvinSetTextureBlend (pContext);
        pContext->hwState.dwNumActiveCombinerStages = 1;

    }

    else {

        // process all active texture stages
        do {

            bStageActive = nvConstructKelvinColorCombiners (pContext,
                                                            pContext->hwState.dwNumActiveCombinerStages,
                                                            pContext->hwState.dwNumActiveCombinerStages);
            nvConstructKelvinAlphaCombiners (pContext,
                                             pContext->hwState.dwNumActiveCombinerStages,
                                             pContext->hwState.dwNumActiveCombinerStages,
                                             bStageActive);

            // if the current unit got assigned to this stage, move on to the next
            if ((pContext->hwState.dwNextAvailableTextureUnit < KELVIN_NUM_TEXTURES) &&
                (pContext->hwState.dwTexUnitToTexStageMapping[pContext->hwState.dwNextAvailableTextureUnit] != KELVIN_UNUSED)) {
                pContext->hwState.dwNextAvailableTextureUnit++;
            }

            if ((bStageActive) || (pContext->hwState.dwNumActiveCombinerStages == 0)) {
                pContext->hwState.dwNumActiveCombinerStages++;
            }

        } while (bStageActive && pContext->hwState.dwNumActiveCombinerStages < KELVIN_NUM_COMBINERS);

    }

    // clear all the unused stages
    for (dwStage=pContext->hwState.dwNumActiveCombinerStages; dwStage<KELVIN_NUM_COMBINERS; dwStage++) {
        pContext->hwState.dwColorICW[dwStage] = 0;
        pContext->hwState.dwColorOCW[dwStage] = 0;
        pContext->hwState.dwAlphaICW[dwStage] = 0;
        pContext->hwState.dwAlphaOCW[dwStage] = 0;
    }

    // set control bits
    dwControl = DRF_NUM (097, _SET_COMBINER_CONTROL, _ITERATION_COUNT,
                         pContext->hwState.dwNumActiveCombinerStages);
    dwControl |= (DRF_DEF (097, _SET_COMBINER_CONTROL, _MUX_SELECT, _LSB)           |
                  DRF_DEF (097, _SET_COMBINER_CONTROL, _FACTOR0, _SAME_FACTOR_ALL)  |
                  DRF_DEF (097, _SET_COMBINER_CONTROL, _FACTOR1, _SAME_FACTOR_ALL));

#if STATE_OPTIMIZE
    // send the active stages to the hardware
    pContext->hwState.kelvin.set1 (NV097_SET_COMBINER_CONTROL, dwControl);
    pContext->hwState.kelvin.seta (NV097_SET_COMBINER_COLOR_ICW(0), pContext->hwState.dwNumActiveCombinerStages, pContext->hwState.dwColorICW);
    pContext->hwState.kelvin.seta (NV097_SET_COMBINER_COLOR_OCW(0), pContext->hwState.dwNumActiveCombinerStages, pContext->hwState.dwColorOCW);
    pContext->hwState.kelvin.seta (NV097_SET_COMBINER_ALPHA_ICW(0), pContext->hwState.dwNumActiveCombinerStages, pContext->hwState.dwAlphaICW);
    pContext->hwState.kelvin.seta (NV097_SET_COMBINER_ALPHA_OCW(0), pContext->hwState.dwNumActiveCombinerStages, pContext->hwState.dwAlphaOCW);

#else
    // send everything to the hardware
    pContext->hwState.kelvin.set1 (NV097_SET_COMBINER_CONTROL, dwControl);
    pContext->hwState.kelvin.set8 (NV097_SET_COMBINER_COLOR_ICW(0),
                                   pContext->hwState.dwColorICW[0],
                                   pContext->hwState.dwColorICW[1],
                                   pContext->hwState.dwColorICW[2],
                                   pContext->hwState.dwColorICW[3],
                                   pContext->hwState.dwColorICW[4],
                                   pContext->hwState.dwColorICW[5],
                                   pContext->hwState.dwColorICW[6],
                                   pContext->hwState.dwColorICW[7]);
    pContext->hwState.kelvin.set8 (NV097_SET_COMBINER_COLOR_OCW(0),
                                   pContext->hwState.dwColorOCW[0],
                                   pContext->hwState.dwColorOCW[1],
                                   pContext->hwState.dwColorOCW[2],
                                   pContext->hwState.dwColorOCW[3],
                                   pContext->hwState.dwColorOCW[4],
                                   pContext->hwState.dwColorOCW[5],
                                   pContext->hwState.dwColorOCW[6],
                                   pContext->hwState.dwColorOCW[7]);
    pContext->hwState.kelvin.set8 (NV097_SET_COMBINER_ALPHA_ICW(0),
                                   pContext->hwState.dwAlphaICW[0],
                                   pContext->hwState.dwAlphaICW[1],
                                   pContext->hwState.dwAlphaICW[2],
                                   pContext->hwState.dwAlphaICW[3],
                                   pContext->hwState.dwAlphaICW[4],
                                   pContext->hwState.dwAlphaICW[5],
                                   pContext->hwState.dwAlphaICW[6],
                                   pContext->hwState.dwAlphaICW[7]);
    pContext->hwState.kelvin.set8 (NV097_SET_COMBINER_ALPHA_OCW(0),
                                   pContext->hwState.dwAlphaOCW[0],
                                   pContext->hwState.dwAlphaOCW[1],
                                   pContext->hwState.dwAlphaOCW[2],
                                   pContext->hwState.dwAlphaOCW[3],
                                   pContext->hwState.dwAlphaOCW[4],
                                   pContext->hwState.dwAlphaOCW[5],
                                   pContext->hwState.dwAlphaOCW[6],
                                   pContext->hwState.dwAlphaOCW[7]);
#endif

    // if we've changed the flags or mappings, invalidate a bunch of state

    //if ((pContext->hwState.dwStateFlags & KELVIN_MASK_COMBINERPROGRAMUNIQUENESS) != dwStateFlags) {
    //    pContext->hwState.dwDirtyFlags |= (KELVIN_DIRTY_SPECFOG_COMBINER |
    //                                            KELVIN_DIRTY_LIGHTS);
    //}

#ifdef TESTCALLANDRETURN

    // this should render a pink banana in bend
    getDC()->nvPusher.flush (TRUE, CPushBuffer::FLUSH_WITH_DELAY);

    DWORD dwPBBase = getDC()->nvPusher.getBase();
    DWORD dwPBEnd = dwPBBase + getDC()->nvPusher.getSize();
    DWORD dwFuncBase = dwPBEnd - (14<<2);

    getDC()->nvPusher.push (0, NVPUSHER_CALL(dwFuncBase-dwPBBase));
    getDC()->nvPusher.adjust(1);

    dwControl = DRF_NUM (097, _SET_COMBINER_CONTROL, _ITERATION_COUNT, 1);
    dwControl |= (DRF_DEF (097, _SET_COMBINER_CONTROL, _MUX_SELECT, _LSB)           |
                  DRF_DEF (097, _SET_COMBINER_CONTROL, _FACTOR0, _SAME_FACTOR_ALL)  |
                  DRF_DEF (097, _SET_COMBINER_CONTROL, _FACTOR1, _SAME_FACTOR_ALL));

    DWORD dwCICW = 0x20010000;
    DWORD dwCOCW = 0x00000c00;
    DWORD dwAICW = 0x30300000;
    DWORD dwAOCW = 0x00000c00;

    ((DWORD*)dwFuncBase)[0]  = (0x00040000 | (NV_DD_KELVIN << 13) | NV097_SET_COMBINER_FACTOR0(0));
    ((DWORD*)dwFuncBase)[1]  = 0x00ff00ff;
    ((DWORD*)dwFuncBase)[2]  = (0x00040000 | (NV_DD_KELVIN << 13) | NV097_SET_COMBINER_CONTROL);
    ((DWORD*)dwFuncBase)[3]  = dwControl;
    ((DWORD*)dwFuncBase)[4]  = (0x00040000 | (NV_DD_KELVIN << 13) | NV097_SET_COMBINER_COLOR_ICW(0));
    ((DWORD*)dwFuncBase)[5]  = dwCICW;
    ((DWORD*)dwFuncBase)[6]  = (0x00040000 | (NV_DD_KELVIN << 13) | NV097_SET_COMBINER_COLOR_OCW(0));
    ((DWORD*)dwFuncBase)[7]  = dwCOCW;
    ((DWORD*)dwFuncBase)[8]  = (0x00040000 | (NV_DD_KELVIN << 13) | NV097_SET_COMBINER_ALPHA_ICW(0));
    ((DWORD*)dwFuncBase)[9]  = dwAICW;
    ((DWORD*)dwFuncBase)[10] = (0x00040000 | (NV_DD_KELVIN << 13) | NV097_SET_COMBINER_ALPHA_OCW(0));
    ((DWORD*)dwFuncBase)[11] = dwAOCW;
    ((DWORD*)dwFuncBase)[12] = NVPUSHER_RETURN();

    getDC()->nvPusher.flush (TRUE, CPushBuffer::FLUSH_WITH_DELAY);

#endif

    for (dwStage=0; dwStage<KELVIN_NUM_TEXTURES; dwStage++) {
        if (pContext->hwState.dwTexUnitToTexStageMapping[dwStage] != dwMapping[dwStage]) {
            pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_TEXTURE_STATE
                                           |  KELVIN_DIRTY_TEXTURE_TRANSFORM
                                           |  KELVIN_DIRTY_FVF
                                           |  KELVIN_DIRTY_TRANSFORM;
            break;
        }
    }

#ifdef ALPHA_CULL
    if(pContext->dwEarlyCopyStrategy && pContext->hwState.alphacull_mode >= 2)
        pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_MISC_STATE;
#endif

    dbgFlushType (NVDBG_FLUSH_STATE);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvSetKelvinPixelShader (PNVD3DCONTEXT pContext)
{
    pContext->hwState.dwDirtyFlags &= ~KELVIN_DIRTY_PIXEL_SHADER;

    if (pContext->pCurrentPShader) {
        pContext->pCurrentPShader->setKelvinState(pContext);
        pContext->hwState.dwDirtyFlags |= (KELVIN_DIRTY_TEXTURE_STATE     |
                                           KELVIN_DIRTY_FVF               |
                                           KELVIN_DIRTY_TEXTURE_TRANSFORM |
                                           KELVIN_DIRTY_TRANSFORM);
    }

    dbgFlushType (NVDBG_FLUSH_STATE);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

// find next clip plane, if any, given clip plane enable bits and the
// current clip plane index. The former is expected to already have been
// shifted right by the latter.

__inline D3DVALUE *nvKelvinGetClipPlane
(
    PNVD3DCONTEXT pContext,
    DWORD *dwClipPlaneEnable,
    DWORD *dwCurrentClipPlaneIndex
)
{
    D3DVALUE *pClipPlane;

    if (*dwClipPlaneEnable) {
        // skip over disabled planes
        while (!((*dwClipPlaneEnable) & 0x1)) {
            (*dwClipPlaneEnable) >>= 1;
            (*dwCurrentClipPlaneIndex) ++;
        }
        // pick off the enabled plane
        pClipPlane = pContext->ppClipPlane[*dwCurrentClipPlaneIndex];
        (*dwClipPlaneEnable) >>= 1;
        (*dwCurrentClipPlaneIndex) ++;
    }
    else {
        pClipPlane = NULL;
    }

    return (pClipPlane);
}

//---------------------------------------------------------------------------

// set kelvin texture state, including:
//      - formats
//      - filters
//      - offsets
// note: the combiners must be set up before calling this routine!

HRESULT nvSetKelvinTextureState (PNVD3DCONTEXT pContext)
{
    DWORD               dwHWStage, dwD3DStage;
    PNVD3DTEXSTAGESTATE pTSSState;
    CTexture           *pTexture;
    CNvObject          *pTexObj;
    CNvObject          *pPalObj;
    CSimpleSurface     *pPalette;
    DWORD               dwOffset, dwFormat, dwAddress;
    DWORD               dwControl0, dwControl1;
    DWORD               dwFilter, dwRect, dwPalette, dwKey;
    DWORD               dwTexUnitStatus, dwLastTexUnitStatus;
    DWORD               dwTexGen, dwTCIndex, dwTexgenMode;
    DWORD               dwUserCoordsNeeded = 0;
    DWORD               dwTexCoordIndices = 0;
    DWORD               dwNumTexCoordsNeeded = 0;
    DWORD               dwInvMVNeeded = 0;
    BOOL                bCubeMap, bBumpMap, bSignedHILO, bUnsignedHILO, bLuminanceMode, bTextureHasLuminance;
    BOOL                bWrapU, bWrapV, bWrapP, bWrapQ;
    DWORD               dwClipPlaneEnable, dwCurrentClipPlaneIndex, dwClipStagesAllowed;
    DWORD               dwPlane, dwMethodOffset;
    D3DVALUE            dvScale, dvOffset;
    D3DVALUE            pClipPlaneEye[4];
    D3DVALUE           *pClipPlane[KELVIN_NUM_TEXTURES];
    D3DMATRIX           mTmp, mTmp2;
    DWORD               dwShaderMode[KELVIN_NUM_TEXTURES];
    DWORD               dwRGBMapping[KELVIN_NUM_TEXTURES];

    pContext->hwState.dwDirtyFlags &= ~KELVIN_DIRTY_TEXTURE_STATE;

    dwClipStagesAllowed     = KELVIN_CAPS_MAX_USER_CLIP_PLANES_ALLOWED >> 2;
    dwClipPlaneEnable       = pContext->dwRenderState[D3DRENDERSTATE_CLIPPLANEENABLE];
    dwCurrentClipPlaneIndex = 0;

    dwLastTexUnitStatus = KELVIN_TEXUNITSTATUS_IDLE;

    // iterate over the HW's texture units

    for (dwHWStage=0; dwHWStage < KELVIN_NUM_TEXTURES; dwHWStage++) {

        // which D3D stage is handled by this HW stage
        dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[dwHWStage];

        if (dwD3DStage != KELVIN_UNUSED) {

#ifdef NV_PROFILE_DP2OPS
            pDriverData->pBenchmark->incActiveTextures();
#endif

            // the combiners assigned this texture unit.
            // we must have a legitimate texture to use

            pTSSState = &(pContext->tssState[dwD3DStage]);
            pTexObj = (CNvObject *)(pTSSState->dwValue[D3DTSS_TEXTUREMAP]);
            pTexture = pTexObj ? pTexObj->getTexture() : 0;

            if(!pTexture){
                //we should ALWAYS have a texture by this point -- substitute the default texture
                //this should be considered a setup error and will propogate out to 
                //nvValidateTextureStageState
                pTexture = getDC()->pDefaultTexture;
                pContext->hwState.dwStateFlags |= KELVIN_FLAG_SETUPFAILURE;
            }

            if (pTexture) {

                dbgTextureDisplay (pTexture);

                bCubeMap = pTexture->isCubeMap();
                if (bCubeMap) {
                    // cubemaps may only be referenced from their bases
                    pTexture = pTexture->getBaseTexture();
                }

                bBumpMap = (pContext->pCurrentPShader) ?
                        pContext->pCurrentPShader->isBEM(dwHWStage) :
                        (pTSSState->dwValue[D3DTSS_COLOROP] == D3DTOP_BUMPENVMAP) || (pTSSState->dwValue[D3DTSS_COLOROP] == D3DTOP_BUMPENVMAPLUMINANCE);

                if ((bBumpMap ^ pTexture->isBumpMap()) && !pContext->pCurrentPShader) {
                    DPF ("stupid app (WHQL) using bumpmapping w/o a bumpmap texture or vice-versa");
                    dbgD3DError();
                    pContext->hwState.dwStateFlags |= KELVIN_FLAG_SETUPFAILURE;
                }

                if (bBumpMap) {
                    // some kind of bumpmapping is desired. the exact flavor and how we treat it
                    // depends on the DX version, the blend mode, and the texture format. ugh.
                    bLuminanceMode = (pContext->pCurrentPShader) ?
                                    pContext->pCurrentPShader->isBEML(dwHWStage) :
                                    (pTSSState->dwValue[D3DTSS_COLOROP] == D3DTOP_BUMPENVMAPLUMINANCE);
                    bTextureHasLuminance = ((pTexture->getFormat() == NV_SURFACE_FORMAT_L6DV5DU5) ||
                                            (pTexture->getFormat() == NV_SURFACE_FORMAT_X8L8DV8DU8)) ? TRUE : FALSE;
                    dwTexUnitStatus = (!bLuminanceMode && !bTextureHasLuminance) ?
                                        KELVIN_TEXUNITSTATUS_BUMPMAPA :
                                        (!bLuminanceMode && bTextureHasLuminance) ?
                                            KELVIN_TEXUNITSTATUS_BUMPMAPB :
                                            (bLuminanceMode && !bTextureHasLuminance) ?
                                                KELVIN_TEXUNITSTATUS_BUMPMAPC :
                                                KELVIN_TEXUNITSTATUS_BUMPMAPD;
                }
                else {
                    dwTexUnitStatus = KELVIN_TEXUNITSTATUS_USER;
                }

                pContext->hwState.pTextureInUse[dwHWStage] = pTexture;

            }  // pTexture

            // we need this data later, for stomping out the projective coordinate when apps are stupid
            // and send down 4 coordinates, even though they don't need them
            if (pContext->pCurrentPShader) {
                dwNumTexCoordsNeeded |= KELVIN_SET_NUM_TEX_COORDS(dwHWStage, pContext->pCurrentPShader->getNumTexCoords(pContext, dwHWStage));
            } else if (pTexture) {
                dwNumTexCoordsNeeded |= KELVIN_SET_NUM_TEX_COORDS(dwHWStage, pTexture->getNumTexCoords());
            }

            // texgen -------------------------------------------------------
            if (pContext->pCurrentVShader->hasProgram()) {
                dwTexgenMode = NV097_SET_TEXGEN_S_V_DISABLE;  // vertex shader subsumes texgen
                dwTCIndex    = dwD3DStage;                    // mapping between vertex shader outputs and texture stages is identity
            }
            else {
                dwTexGen  = (pContext->hwState.dwStateFlags & KELVIN_FLAG_PASSTHROUGHMODE) ?
                            D3DTSS_TCI_PASSTHRU :
                            pTSSState->dwValue[D3DTSS_TEXCOORDINDEX] & 0xffff0000;
                dwTCIndex = pTSSState->dwValue[D3DTSS_TEXCOORDINDEX] & 0x0000ffff;
                switch (dwTexGen) {
                    case D3DTSS_TCI_PASSTHRU:
                        if (pContext->pCurrentVShader->bVAExists (defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex])) {
                            dwUserCoordsNeeded |= KELVIN_FLAG_USERTEXCOORDSNEEDED(dwHWStage);
                            dwTexCoordIndices  |= dwTCIndex << (8*dwHWStage);
                        }
                        else if (!pContext->dwRenderState[D3DRS_POINTSPRITEENABLE]) {
                            // the architects are on crack. the NV097_SET_TEXCOORDx_4F methods are not evenly spaced.
                            DWORD dwBase = (dwHWStage == 3) ?
                                           NV097_SET_TEXCOORD3_4F(0) :
                                           NV097_SET_TEXCOORD0_4F(0) + 0x28*dwHWStage;
                            // u,v = 0,0  (says MS)W=1.0 THIS IS IMPORTANT (DOH!)
                            pContext->hwState.kelvin.set4f (dwBase, 0.0f, 0.0f, 0.0f, 1.0f);
                        }
                        dwTexgenMode = NV097_SET_TEXGEN_S_V_DISABLE;
                        break;
                    case D3DTSS_TCI_CAMERASPACENORMAL:
                        dwInvMVNeeded = KELVIN_FLAG_TEXSTATENEEDSINVMV;
                        dwTexgenMode = NV097_SET_TEXGEN_S_V_NORMAL_MAP;
                        break;
                    case D3DTSS_TCI_CAMERASPACEPOSITION:
                        pContext->hwState.kelvin.set4f (NV097_SET_TEXGEN_PLANE_S(dwHWStage,0), 1.0f, 0.0f, 0.0f, 0.0f);
                        pContext->hwState.kelvin.set4f (NV097_SET_TEXGEN_PLANE_T(dwHWStage,0), 0.0f, 1.0f, 0.0f, 0.0f);
                        pContext->hwState.kelvin.set4f (NV097_SET_TEXGEN_PLANE_R(dwHWStage,0), 0.0f, 0.0f, 1.0f, 0.0f);
                        dwTexgenMode = NV097_SET_TEXGEN_S_V_EYE_LINEAR;
                        break;
                    case D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR:
                        dwInvMVNeeded = KELVIN_FLAG_TEXSTATENEEDSINVMV;
                        dwTexgenMode = NV097_SET_TEXGEN_S_V_REFLECTION_MAP;
                        break;
                    default:
                        DPF ("unknown texgen mode in nvSetKelvinTextureState");
                        dbgD3DError();
                        pContext->hwState.dwStateFlags |= KELVIN_FLAG_SETUPFAILURE;
                        break;
                }
            }

            // we always generate three coordinates (i think)
            pContext->hwState.kelvin.set4 (NV097_SET_TEXGEN_S(dwHWStage),
                                           dwTexgenMode, dwTexgenMode,
                                           dwTexgenMode, NV097_SET_TEXGEN_Q_V_DISABLE);
            pContext->hwState.kelvin.set1 (NV097_SET_TEXGEN_VIEW_MODEL,
                                           pContext->dwRenderState[D3DRENDERSTATE_LOCALVIEWER] ?
                                           NV097_SET_TEXGEN_VIEW_MODEL_V_LOCAL_VIEWER :
                                           NV097_SET_TEXGEN_VIEW_MODEL_V_INFINITE_VIEWER);

            if (pTexture) {

                // offset -------------------------------------------------------
                dwOffset = pTexture->getSwizzled()->getOffset();

                // format -------------------------------------------------------
                dwFormat  = DRF_NUM (097, _SET_TEXTURE_FORMAT, _CONTEXT_DMA, nv097TextureContextDma[pTexture->getSwizzled()->getContextDMA()]);
                dwFormat |= DRF_NUM (097, _SET_TEXTURE_FORMAT, _CUBEMAP_ENABLE, bCubeMap);

                dwFormat |= (pTexture->isVolumeMap()) ?
                            DRF_DEF (097, _SET_TEXTURE_FORMAT, _DIMENSIONALITY, _THREE) :
                            DRF_DEF (097, _SET_TEXTURE_FORMAT, _DIMENSIONALITY, _TWO);

                if ((pTSSState->dwValue[D3DTSS_ADDRESSU] == D3DTADDRESS_BORDER) ||
                    (pTSSState->dwValue[D3DTSS_ADDRESSV] == D3DTADDRESS_BORDER) ||
                    (pTSSState->dwValue[D3DTSS_ADDRESSW] == D3DTADDRESS_BORDER)) {
                    pContext->hwState.kelvin.set1 (NV097_SET_TEXTURE_BORDER_COLOR(dwHWStage), pTSSState->dwValue[D3DTSS_BORDERCOLOR]);
                }

                dwFormat |= DRF_DEF (097, _SET_TEXTURE_FORMAT, _BORDER_SOURCE, _COLOR);
                dwFormat |= DRF_NUM (097, _SET_TEXTURE_FORMAT, _COLOR, nv097TextureFormat[pTexture->getFormat()]);

                dwFormat |= DRF_NUM (097, _SET_TEXTURE_FORMAT, _MIPMAP_LEVELS, pTexture->getMipMapCount());
                dwFormat |= DRF_NUM (097, _SET_TEXTURE_FORMAT, _BASE_SIZE_U,   pTexture->getLogicalLogWidth());
                dwFormat |= DRF_NUM (097, _SET_TEXTURE_FORMAT, _BASE_SIZE_V,   pTexture->getLogicalLogHeight());
                dwFormat |= DRF_NUM (097, _SET_TEXTURE_FORMAT, _BASE_SIZE_P,   pTexture->getLogicalLogDepth());

                // addressing ---------------------------------------------------

                // force clamp to edge if we're cubemapping
                dwAddress  = DRF_NUM (097, _SET_TEXTURE_ADDRESS, _U, pTexture->isCubeMap() ? nv097TextureAddress[3] : nv097TextureAddress[pTSSState->dwValue[D3DTSS_ADDRESSU]]);
                dwAddress |= DRF_NUM (097, _SET_TEXTURE_ADDRESS, _V, pTexture->isCubeMap() ? nv097TextureAddress[3] : nv097TextureAddress[pTSSState->dwValue[D3DTSS_ADDRESSV]]);
                dwAddress |= pTexture->isVolumeMap() ?    // D3DTSS_ADDRESSW doesn't seem to be valid if we don't have a volume map
                             DRF_NUM (097, _SET_TEXTURE_ADDRESS, _P, nv097TextureAddress[pTSSState->dwValue[D3DTSS_ADDRESSW]]) :
                             DRF_NUM (097, _SET_TEXTURE_ADDRESS, _P, nv097TextureAddress[1]);


                // check cylindrical wrapping (disallow it if we're cubemapping)
                NV_EVAL_CYLINDRICAL_WRAP (pContext, dwTCIndex, bWrapU, bWrapV, bWrapP, bWrapQ);
                dwAddress |= DRF_NUM (097, _SET_TEXTURE_ADDRESS, _CYLWRAP_U, bWrapU);
                dwAddress |= DRF_NUM (097, _SET_TEXTURE_ADDRESS, _CYLWRAP_V, bWrapV);
                dwAddress |= DRF_NUM (097, _SET_TEXTURE_ADDRESS, _CYLWRAP_P, bWrapP);
                dwAddress |= DRF_NUM (097, _SET_TEXTURE_ADDRESS, _CYLWRAP_Q, bWrapQ);

                // control0 -----------------------------------------------------
                dwControl0  = DRF_DEF (097, _SET_TEXTURE_CONTROL0, _ENABLE, _TRUE);

                // these are backward from openGL. d3d can only set the maximum mipmap level, by which they mean
                // the openGL minimum level (d3d maximum = largest sized level to use, not largest level number).
                // the d3d minimum level (the openGL / kelvin maximum) is always just the end of the chain
                dwControl0 |= DRF_NUM (097, _SET_TEXTURE_CONTROL0, _MIN_LOD_CLAMP, ((pTSSState->dwValue[D3DTSS_MAXMIPLEVEL]) << 8));  // 4.8 fixed point
                // If we are not mip mapped, we need to set the MAX_LOD_CLAMP to 1 in order to
                // get min filtering (if set to 0 we only get mag filtering on non-mipmapped textures).
                if( pTexture->getMipMapCount() == 1 ) {
                    dwControl0 |= DRF_NUM (097, _SET_TEXTURE_CONTROL0, _MAX_LOD_CLAMP, (1 << 8));  // 4.8 fixed point
                }
                else {
                    dwControl0 |= DRF_NUM (097, _SET_TEXTURE_CONTROL0, _MAX_LOD_CLAMP, ((pTexture->getMipMapCount()-1) << 8));  // 4.8 fixed point
                }

                dwControl0 |= DRF_DEF (097, _SET_TEXTURE_CONTROL0, _ALPHA_KILL_ENABLE, _FALSE);
                dwControl0 |= DRF_DEF (097, _SET_TEXTURE_CONTROL0, _IMAGE_FIELD_ENABLE, _FALSE);  // BUGBUG what's this???

                // colorkey
                if ((pContext->dwRenderState[D3DRENDERSTATE_COLORKEYENABLE]) && (pTexture->hasColorKey())) {
                    dwControl0 |= DRF_DEF (097, _SET_TEXTURE_CONTROL0, _COLOR_KEY_OPERATION, _KILL);  // use this choice since the texture may not have alpha
                    dwKey = pTexture->getColorKey();
                    if (pTexture->isPalettized()) {
                        if ((pTexture->getWrapper()) &&
                            (pTexture->getWrapper()->getPalette()) &&
                            (pTexture->getWrapper()->getPalette()->getPaletteSurface()) &&
                            (dwKey < 256)) {
                            dwKey = ((DWORD *)(pTexture->getWrapper()->getPalette()->getPaletteSurface()->getAddress()))[dwKey];
                        }
                        else {
                            DPF ("unable to extract color key from palettized texture");
                            dbgD3DError();
                        }
                    }
                    pContext->hwState.kelvin.set1 (NV097_SET_COLOR_KEY_COLOR(dwHWStage), dwKey);
                }
                else {
                    dwControl0 |= DRF_DEF (097, _SET_TEXTURE_CONTROL0, _COLOR_KEY_OPERATION, _FALSE);
                }

                // control1 -----------------------------------------------------
                dwControl1 = DRF_NUM (097, _SET_TEXTURE_CONTROL1, _IMAGE_PITCH, 0x0008);

                // filter -------------------------------------------------------
                dwFilter  = DRF_DEF (097, _SET_TEXTURE_FILTER, _CONVOLUTION_KERNEL, _GAUSSIAN_3);

                bSignedHILO   = (pTexture->getFormat() == NV_SURFACE_FORMAT_HILO_HEMI_V16U16);
                bUnsignedHILO = (pTexture->getFormat() == NV_SURFACE_FORMAT_HILO_1_V16U16);

                if (pContext->pCurrentPShader && !pContext->pCurrentPShader->stageUsesTexture(dwHWStage)) {
                    dwFilter |= DRF_DEF (097, _SET_TEXTURE_FILTER, _ASIGNED, _BIT_DISABLED) |
                                DRF_DEF (097, _SET_TEXTURE_FILTER, _RSIGNED, _BIT_DISABLED) |
                                DRF_DEF (097, _SET_TEXTURE_FILTER, _GSIGNED, _BIT_DISABLED) |
                                DRF_DEF (097, _SET_TEXTURE_FILTER, _BSIGNED, _BIT_DISABLED);
                } else if (bBumpMap) {
                    dwFilter |= DRF_DEF (097, _SET_TEXTURE_FILTER, _ASIGNED, _BIT_DISABLED) |
                                DRF_DEF (097, _SET_TEXTURE_FILTER, _RSIGNED, _BIT_DISABLED) |
                                DRF_DEF (097, _SET_TEXTURE_FILTER, _GSIGNED, _BIT_ENABLED)  |
                                DRF_DEF (097, _SET_TEXTURE_FILTER, _BSIGNED, _BIT_ENABLED);
                } else if (bSignedHILO) {
                    dwFilter |= DRF_DEF (097, _SET_TEXTURE_FILTER, _ASIGNED, _BIT_ENABLED)  |
                                DRF_DEF (097, _SET_TEXTURE_FILTER, _RSIGNED, _BIT_DISABLED) |
                                DRF_DEF (097, _SET_TEXTURE_FILTER, _GSIGNED, _BIT_ENABLED)  |
                                DRF_DEF (097, _SET_TEXTURE_FILTER, _BSIGNED, _BIT_DISABLED);
                } else if (pTexture->getFourCC() == D3DFMT_Q8W8V8U8) {
                    dwFilter |= DRF_DEF (097, _SET_TEXTURE_FILTER, _ASIGNED, _BIT_ENABLED) |
                                DRF_DEF (097, _SET_TEXTURE_FILTER, _RSIGNED, _BIT_ENABLED) |
                                DRF_DEF (097, _SET_TEXTURE_FILTER, _GSIGNED, _BIT_ENABLED) |
                                DRF_DEF (097, _SET_TEXTURE_FILTER, _BSIGNED, _BIT_ENABLED);
                } else {
                    dwFilter |= DRF_DEF (097, _SET_TEXTURE_FILTER, _ASIGNED, _BIT_DISABLED) |
                                DRF_DEF (097, _SET_TEXTURE_FILTER, _RSIGNED, _BIT_DISABLED) |
                                DRF_DEF (097, _SET_TEXTURE_FILTER, _GSIGNED, _BIT_DISABLED) |
                                DRF_DEF (097, _SET_TEXTURE_FILTER, _BSIGNED, _BIT_DISABLED);
                }

                DWORD dwMinFilter = pTSSState->dwValue[D3DTSS_MINFILTER];
                DWORD dwMagFilter = pTSSState->dwValue[D3DTSS_MAGFILTER];
                DWORD dwMipFilter = pTSSState->dwValue[D3DTSS_MIPFILTER];

                if (pContext->dwDXAppVersion >= 0x800) {
                    // DX8 changed the filter enumerants. Remap them so we don't have to change our code.
                    dwMinFilter = dx8MinFilterMapping[dwMinFilter];
                    dwMagFilter = dx8MagFilterMapping[dwMagFilter];
                    dwMipFilter = dx8MipFilterMapping[dwMipFilter];
                }

                // Mag filter aniso is bilinear in HW, and this passes WHQL.
                // As a result trigger anisotropic off of Min filter only
                if ((dwMinFilter == D3DTFN_ANISOTROPIC) ||
                    (getDC()->nvD3DRegistryData.regAnisotropicLevel != D3D_REG_ANISOTROPICLEVEL_PASSIVE))
                {
                    DWORD dwMaxAnisotropy = (getDC()->nvD3DRegistryData.regAnisotropicLevel == D3D_REG_ANISOTROPICLEVEL_PASSIVE) ?
                                            pTSSState->dwValue[D3DTSS_MAXANISOTROPY] :
                                            getDC()->nvD3DRegistryData.regAnisotropicLevel;
                    // We can only handle anisotropy in powers-of-2.  Non powers-of-2 are
                    // promoted to higher levels of anisotropy.
                    switch (dwMaxAnisotropy) {
                        case 0:
                            // default back to point
                            dwControl0 |= DRF_DEF (097, _SET_TEXTURE_CONTROL0, _LOG_MAX_ANISO, _0);
                            dwFilter   |= DRF_NUM (097, _SET_TEXTURE_FILTER, _MIN, nv097TextureMinFilter[D3DTFN_POINT][dwMipFilter]);
                            dwFilter   |= DRF_NUM (097, _SET_TEXTURE_FILTER, _MAG, nv097TextureMagFilter[dwMagFilter]);
                            break;
                        case 1:
                            // default back to linear with no aniso
                            dwControl0 |= DRF_DEF (097, _SET_TEXTURE_CONTROL0, _LOG_MAX_ANISO, _0);
                            dwFilter   |= DRF_NUM (097, _SET_TEXTURE_FILTER, _MIN, nv097TextureMinFilter[D3DTFN_LINEAR][dwMipFilter]);
                            dwFilter   |= DRF_NUM (097, _SET_TEXTURE_FILTER, _MAG, nv097TextureMagFilter[dwMagFilter]);
                            break;
                        case 2:
                            // use real aniso
                            dwControl0 |= DRF_DEF (097, _SET_TEXTURE_CONTROL0, _LOG_MAX_ANISO, _1);
                            dwFilter   |= DRF_NUM (097, _SET_TEXTURE_FILTER, _MIN, nv097TextureMinFilter[D3DTFN_LINEAR][dwMipFilter]);
                            dwFilter   |= DRF_NUM (097, _SET_TEXTURE_FILTER, _MAG, nv097TextureMagFilter[D3DTFG_LINEAR]);
                            if(dwMagFilter == D3DTFG_POINT) {
                                // When aniso filtering is on, mag filter will be linear, point filtering
                                // won't happen, so we must fail validate texture stage for DCT450.
                                pContext->hwState.dwStateFlags |= KELVIN_FLAG_SETUPFAILURE;
                            }
                            break;
                        case 3:
                        case 4:
                            // use real aniso
                            dwControl0 |= DRF_DEF (097, _SET_TEXTURE_CONTROL0, _LOG_MAX_ANISO, _2);
                            dwFilter   |= DRF_NUM (097, _SET_TEXTURE_FILTER, _MIN, nv097TextureMinFilter[D3DTFN_LINEAR][dwMipFilter]);
                            dwFilter   |= DRF_NUM (097, _SET_TEXTURE_FILTER, _MAG, nv097TextureMagFilter[D3DTFG_LINEAR]);
                            if(dwMagFilter == D3DTFG_POINT) {
                                // When aniso filtering is on, mag filter will be linear, point filtering
                                // won't happen, so we must fail validate texture stage for DCT450.
                                pContext->hwState.dwStateFlags |= KELVIN_FLAG_SETUPFAILURE;
                            }
                            break;
                        default:
                            // aniso > 8. we can't really do it, but we'll approximate it as best we can
                            pContext->hwState.dwStateFlags |= KELVIN_FLAG_SETUPFAILURE;
                            // fall through
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                            // use real aniso
                            dwControl0 |= DRF_DEF (097, _SET_TEXTURE_CONTROL0, _LOG_MAX_ANISO, _3);
                            dwFilter   |= DRF_NUM (097, _SET_TEXTURE_FILTER, _MIN, nv097TextureMinFilter[D3DTFN_LINEAR][dwMipFilter]);
                            dwFilter   |= DRF_NUM (097, _SET_TEXTURE_FILTER, _MAG, nv097TextureMagFilter[D3DTFG_LINEAR]);
                            if(dwMagFilter == D3DTFG_POINT) {
                                // When aniso filtering is on, mag filter will be linear, point filtering
                                // won't happen, so we must fail validate texture stage for DCT450.
                                pContext->hwState.dwStateFlags |= KELVIN_FLAG_SETUPFAILURE;
                            }
                            break;
                    }  // switch
                }

                else {  // anisotropic filtering should not be enabled
                    // Mag aniso is bilinear in HW, and this passes WHQL.
                    if (dwMagFilter == D3DTFG_ANISOTROPIC) {
                        dwMagFilter = D3DTFG_LINEAR;
                    }

                    dwControl0 |= DRF_DEF (097, _SET_TEXTURE_CONTROL0, _LOG_MAX_ANISO, _0);
                    dwFilter   |= DRF_NUM (097, _SET_TEXTURE_FILTER, _MIN, nv097TextureMinFilter[dwMinFilter][dwMipFilter]);
                    dwFilter   |= DRF_NUM (097, _SET_TEXTURE_FILTER, _MAG, nv097TextureMagFilter[dwMagFilter]);
                }

                // LOD bias
                dwFilter |= DRF_NUM (097, _SET_TEXTURE_FILTER, _MIPMAP_LOD_BIAS, pTSSState->dwLODBias);

                // image rect ---------------------------------------------------
                dwRect  = DRF_NUM (097, _SET_TEXTURE_IMAGE_RECT, _WIDTH, 8);  // this is ignored, just set something valid
                dwRect |= DRF_NUM (097, _SET_TEXTURE_IMAGE_RECT, _HEIGHT, 8);

                // palette ------------------------------------------------------
                dwPalette = 0;
                if (pTexture->isPalettized()) {
                    pPalObj = ((CNvObject *)(pTSSState->dwValue[D3DTSS_TEXTUREMAP]))->getPalette();
                    if (pPalObj) {
                        pPalette = pPalObj->getPaletteSurface();
                        nvAssert (pPalette);   // should already have bound a palette before using this texture
                        dwPalette |= DRF_NUM (097, _SET_TEXTURE_PALETTE, _CONTEXT_DMA, nv097PaletteContextDma[pPalette->getContextDMA()]);
                        dwPalette |= DRF_DEF (097, _SET_TEXTURE_PALETTE, _LENGTH, _256);
                        dwPalette |= DRF_NUM (097, _SET_TEXTURE_PALETTE, _OFFSET, (pPalette->getOffset() >> 6));  // offset measured is 64-byte units
                    } else {
                        DPF ("stupid app/runtime gave us a palettized texture without a palette");
                        DPF ("the app likely has no idea about alt-tabbing");
                        dbgD3DError();
                    }
                }
                else if (pTexture->hasAutoPalette()) {
                    nvAssert ((pTexture->getAutoPaletteOffset() & 63) == 0);
                    dwPalette |= DRF_NUM (097, _SET_TEXTURE_PALETTE, _CONTEXT_DMA, nv097PaletteContextDma[pTexture->getSwizzled()->getContextDMA()]);
                    dwPalette |= DRF_DEF (097, _SET_TEXTURE_PALETTE, _LENGTH, _256);
                    dwPalette |= DRF_NUM (097, _SET_TEXTURE_PALETTE, _OFFSET, (pTexture->getAutoPaletteOffset() >> 6));  // offset measured is 64-byte units
                }

                // send everything ----------------------------------------------
                pContext->hwState.kelvin.set6 (NV097_SET_TEXTURE_OFFSET(dwHWStage),
                                               dwOffset, dwFormat, dwAddress, dwControl0, dwControl1, dwFilter);
                pContext->hwState.kelvin.set2 (NV097_SET_TEXTURE_IMAGE_RECT(dwHWStage),
                                               dwRect, dwPalette);

                // bumpmapping and shader mode ----------------------------------
                // the latter is saved off to be sent to the HW when we're done with all textures
                if (dwLastTexUnitStatus & (KELVIN_TEXUNITSTATUS_BUMPMAPA |
                                           KELVIN_TEXUNITSTATUS_BUMPMAPB |
                                           KELVIN_TEXUNITSTATUS_BUMPMAPC |
                                           KELVIN_TEXUNITSTATUS_BUMPMAPD)) {

                    if (pContext->tssState[dwD3DStage].dwValue[D3DTSS_TEXTURETRANSFORMFLAGS] & D3DTTFF_PROJECTED) {
                        DPF ("kelvin097 cannot do projective texturing with bumpmapping");
                        pContext->hwState.dwStateFlags |= KELVIN_FLAG_SETUPFAILURE;
                    }

                    DWORD dwBumpMapStage = (pContext->pCurrentPShader) ? dwD3DStage : (dwD3DStage-1);

                    pContext->hwState.kelvin.set4 (NV097_SET_TEXTURE_SET_BUMP_ENV_MAT00(dwHWStage),
                                                   pContext->tssState[dwBumpMapStage].dwValue[D3DTSS_BUMPENVMAT00],
                                                   pContext->tssState[dwBumpMapStage].dwValue[D3DTSS_BUMPENVMAT01],
                                                   pContext->tssState[dwBumpMapStage].dwValue[D3DTSS_BUMPENVMAT11],
                                                   pContext->tssState[dwBumpMapStage].dwValue[D3DTSS_BUMPENVMAT10]);

                    if (pContext->dwDXAppVersion < 0x0700) {
                        // DX6 or below
                        switch (dwLastTexUnitStatus) {
                            case KELVIN_TEXUNITSTATUS_BUMPMAPA:
                            case KELVIN_TEXUNITSTATUS_BUMPMAPB:
                            case KELVIN_TEXUNITSTATUS_BUMPMAPC:
                                dvScale  = 0.f;
                                dvOffset = FLOAT_FROM_DWORD(pContext->tssState[dwBumpMapStage].dwValue[D3DTSS_BUMPENVLSCALE]) +
                                           FLOAT_FROM_DWORD(pContext->tssState[dwD3DStage-1].dwValue[D3DTSS_BUMPENVLOFFSET]);
                                dwShaderMode[dwHWStage] = NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_BUMPENVMAP_LUMINANCE;
                                break;
                            case KELVIN_TEXUNITSTATUS_BUMPMAPD:
                                dvScale  = FLOAT_FROM_DWORD(pContext->tssState[dwBumpMapStage].dwValue[D3DTSS_BUMPENVLSCALE]);
                                dvOffset = FLOAT_FROM_DWORD(pContext->tssState[dwBumpMapStage].dwValue[D3DTSS_BUMPENVLOFFSET]);
                                dwShaderMode[dwHWStage] = NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_BUMPENVMAP_LUMINANCE;
                                break;
                        }
                    }
                    else {
                        // DX7 or higher
                        switch (dwLastTexUnitStatus) {
                            case KELVIN_TEXUNITSTATUS_BUMPMAPA:
                            case KELVIN_TEXUNITSTATUS_BUMPMAPB:
                                dvScale  = 0.f;  // actually n/a
                                dvOffset = 0.f;  // actually n/a
                                dwShaderMode[dwHWStage] = NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_BUMPENVMAP;
                                break;
                            case KELVIN_TEXUNITSTATUS_BUMPMAPC:
                                dvScale  = 0.f;
                                dvOffset = FLOAT_FROM_DWORD(pContext->tssState[dwBumpMapStage].dwValue[D3DTSS_BUMPENVLSCALE]) +
                                           FLOAT_FROM_DWORD(pContext->tssState[dwBumpMapStage].dwValue[D3DTSS_BUMPENVLOFFSET]);
                                dwShaderMode[dwHWStage] = NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_BUMPENVMAP_LUMINANCE;
                                break;
                            case KELVIN_TEXUNITSTATUS_BUMPMAPD:
                                dvScale  = FLOAT_FROM_DWORD(pContext->tssState[dwBumpMapStage].dwValue[D3DTSS_BUMPENVLSCALE]);
                                dvOffset = FLOAT_FROM_DWORD(pContext->tssState[dwBumpMapStage].dwValue[D3DTSS_BUMPENVLOFFSET]);
                                dwShaderMode[dwHWStage] = NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_BUMPENVMAP_LUMINANCE;
                                break;
                        }
                    }
                    pContext->hwState.kelvin.set2f (NV097_SET_TEXTURE_SET_BUMP_ENV_SCALE(dwHWStage), dvScale, dvOffset);

                }

                else {
                    dwShaderMode[dwHWStage] = bCubeMap ?
                                                  NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_CUBE_MAP :
                                                  pTexture->isVolumeMap() ?
                                                      NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_3D_PROJECTIVE :
                                                      NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_2D_PROJECTIVE;
                }

                // really only relevant for stages >= 1, but innocuous for stage 0
                dwRGBMapping[dwHWStage] = bSignedHILO ?
                                              NV097_SET_DOT_RGBMAPPING_STAGE1_HILO_HEMISPHERE_MS :
                                              (bUnsignedHILO ?
                                                  NV097_SET_DOT_RGBMAPPING_STAGE1_HILO_1 :
                                                  NV097_SET_DOT_RGBMAPPING_STAGE1_ZERO_TO_1);

            }

            else {

                dwTexUnitStatus = KELVIN_TEXUNITSTATUS_USER;

                // control 0
                dwControl0  = DRF_DEF (097, _SET_TEXTURE_CONTROL0, _ENABLE, _FALSE);
                dwControl0 |= DRF_NUM (097, _SET_TEXTURE_CONTROL0, _MIN_LOD_CLAMP, 0);
                dwControl0 |= DRF_NUM (097, _SET_TEXTURE_CONTROL0, _MAX_LOD_CLAMP, 0);
                dwControl0 |= DRF_DEF (097, _SET_TEXTURE_CONTROL0, _ALPHA_KILL_ENABLE, _FALSE);
                dwControl0 |= DRF_DEF (097, _SET_TEXTURE_CONTROL0, _IMAGE_FIELD_ENABLE, _FALSE);
                dwControl0 |= DRF_DEF (097, _SET_TEXTURE_CONTROL0, _COLOR_KEY_OPERATION, _FALSE);
                dwControl0 |= DRF_DEF (097, _SET_TEXTURE_CONTROL0, _LOG_MAX_ANISO, _0);

                pContext->hwState.kelvin.set1 (NV097_SET_TEXTURE_CONTROL0(dwHWStage), dwControl0);

            }

        }

        else if (dwClipPlaneEnable && dwClipStagesAllowed) {

            // if user clip planes are enabled, knock off as many as we can.
            // (each texture stage can handle four)

            dwTexUnitStatus = KELVIN_TEXUNITSTATUS_CLIP;
            pContext->hwState.pTextureInUse[dwHWStage] = NULL;

            dwClipStagesAllowed --;

            // fetch up to four planes
            for (dwPlane = 0; dwPlane < 4; dwPlane++) {
                pClipPlane[dwPlane] = nvKelvinGetClipPlane (pContext, &dwClipPlaneEnable, &dwCurrentClipPlaneIndex);
            }

            // we better have found at least one
            nvAssert(pClipPlane[0]);

            // D3D gives us the normals in world space, so they need to be converted to eye space
            // calculate the required matrix
            Inverse4x4 (&mTmp, &(pContext->xfmView), TRUE);
            MatrixTranspose4x4 (&mTmp2, &mTmp);

            dwMethodOffset = NV097_SET_TEXGEN_PLANE_S (dwHWStage,0);

            // transform and send as many planes as we have
            for (dwPlane = 0; dwPlane < 4; dwPlane++) {
                if (pClipPlane[dwPlane]) {
                    XformVector4 (pClipPlaneEye, pClipPlane[dwPlane], &mTmp2);
                }
                // send the last plane repeatedly to fill the remaining slots
                pContext->hwState.kelvin.set4f (dwMethodOffset,
                                                pClipPlaneEye[0], pClipPlaneEye[1],
                                                pClipPlaneEye[2], pClipPlaneEye[3]);
                dwMethodOffset += 0x10;
            }

            // generate texture coords from eye space coordinates
            pContext->hwState.kelvin.set4 (NV097_SET_TEXGEN_S(dwHWStage),
                                           NV097_SET_TEXGEN_S_V_EYE_LINEAR,
                                           NV097_SET_TEXGEN_T_V_EYE_LINEAR,
                                           NV097_SET_TEXGEN_R_V_EYE_LINEAR,
                                           NV097_SET_TEXGEN_Q_V_EYE_LINEAR);

            // according to Harold, the only thing we care about in this case is control0
            dwControl0  = DRF_DEF (097, _SET_TEXTURE_CONTROL0, _ENABLE, _TRUE);
            dwControl0 |= DRF_NUM (097, _SET_TEXTURE_CONTROL0, _MIN_LOD_CLAMP, 0);
            dwControl0 |= DRF_NUM (097, _SET_TEXTURE_CONTROL0, _MAX_LOD_CLAMP, 0);
            dwControl0 |= DRF_DEF (097, _SET_TEXTURE_CONTROL0, _ALPHA_KILL_ENABLE, _FALSE);
            dwControl0 |= DRF_DEF (097, _SET_TEXTURE_CONTROL0, _IMAGE_FIELD_ENABLE, _FALSE);
            dwControl0 |= DRF_DEF (097, _SET_TEXTURE_CONTROL0, _COLOR_KEY_OPERATION, _FALSE);
            dwControl0 |= DRF_DEF (097, _SET_TEXTURE_CONTROL0, _LOG_MAX_ANISO, _0);

            pContext->hwState.kelvin.set1 (NV097_SET_TEXTURE_CONTROL0(dwHWStage), dwControl0);

            // set the shader program to clip mode (pixel kill contingent on sign of eye
            // coords dotted with clip plane normal)
            dwShaderMode[dwHWStage] = NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_CLIP_PLANE;
            dwRGBMapping[dwHWStage] = NV097_SET_DOT_RGBMAPPING_STAGE1_ZERO_TO_1;

        }

        else if (!pContext->pCurrentPShader) {

            // no user texture, no clip planes. go ahead and totally disable the stage

            dwTexUnitStatus = KELVIN_TEXUNITSTATUS_IDLE;
            pContext->hwState.pTextureInUse[dwHWStage] = NULL;

            pContext->hwState.kelvin.set4 (NV097_SET_TEXGEN_S(dwHWStage),
                                           NV097_SET_TEXGEN_S_V_DISABLE,
                                           NV097_SET_TEXGEN_T_V_DISABLE,
                                           NV097_SET_TEXGEN_R_V_DISABLE,
                                           NV097_SET_TEXGEN_Q_V_DISABLE);

            // control 0
            dwControl0  = DRF_DEF (097, _SET_TEXTURE_CONTROL0, _ENABLE, _FALSE);
            dwControl0 |= DRF_NUM (097, _SET_TEXTURE_CONTROL0, _MIN_LOD_CLAMP, 0);
            dwControl0 |= DRF_NUM (097, _SET_TEXTURE_CONTROL0, _MAX_LOD_CLAMP, 0);
            dwControl0 |= DRF_DEF (097, _SET_TEXTURE_CONTROL0, _ALPHA_KILL_ENABLE, _FALSE);
            dwControl0 |= DRF_DEF (097, _SET_TEXTURE_CONTROL0, _IMAGE_FIELD_ENABLE, _FALSE);
            dwControl0 |= DRF_DEF (097, _SET_TEXTURE_CONTROL0, _COLOR_KEY_OPERATION, _FALSE);
            dwControl0 |= DRF_DEF (097, _SET_TEXTURE_CONTROL0, _LOG_MAX_ANISO, _0);

            pContext->hwState.kelvin.set1 (NV097_SET_TEXTURE_CONTROL0(dwHWStage), dwControl0);

            dwShaderMode[dwHWStage] = NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_PROGRAM_NONE;
            dwRGBMapping[dwHWStage] = NV097_SET_DOT_RGBMAPPING_STAGE1_ZERO_TO_1;

        }

        dwLastTexUnitStatus = dwTexUnitStatus;

        if (pContext->hwState.dwTextureUnitStatus[dwHWStage] != dwTexUnitStatus) {
            pContext->hwState.dwTextureUnitStatus[dwHWStage] = dwTexUnitStatus;
            pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_TEXTURE_TRANSFORM | KELVIN_DIRTY_FVF;
        }

    }  // for dwHWStage=0...

    if (!pContext->pCurrentPShader) {
        // send the shader RGB mapping state to the hardware
        pContext->hwState.kelvin.set1 (NV097_SET_DOT_RGBMAPPING, // No stage 0 remapping
                                       (DRF_NUM (097, _SET_DOT_RGBMAPPING, _STAGE1, dwRGBMapping[1]) |
                                        DRF_NUM (097, _SET_DOT_RGBMAPPING, _STAGE2, dwRGBMapping[2]) |
                                        DRF_NUM (097, _SET_DOT_RGBMAPPING, _STAGE3, dwRGBMapping[3])));

        // send the collective shader programs to the HW
        pContext->hwState.kelvin.set1 (NV097_SET_SHADER_STAGE_PROGRAM,
                                       (DRF_NUM (097, _SET_SHADER_STAGE_PROGRAM, _STAGE0, dwShaderMode[0]) |
                                        DRF_NUM (097, _SET_SHADER_STAGE_PROGRAM, _STAGE1, dwShaderMode[1]) |
                                        DRF_NUM (097, _SET_SHADER_STAGE_PROGRAM, _STAGE2, dwShaderMode[2]) |
                                        DRF_NUM (097, _SET_SHADER_STAGE_PROGRAM, _STAGE3, dwShaderMode[3])));

        // for DX7, dependent texture lookups always run between stages i and i+1
        pContext->hwState.kelvin.set1 (NV097_SET_SHADER_OTHER_STAGE_INPUT,
                                      (DRF_DEF (097, _SET_SHADER_OTHER_STAGE_INPUT, _STAGE1, _INSTAGE_0) |
                                       DRF_DEF (097, _SET_SHADER_OTHER_STAGE_INPUT, _STAGE2, _INSTAGE_1) |
                                       DRF_DEF (097, _SET_SHADER_OTHER_STAGE_INPUT, _STAGE3, _INSTAGE_2)));
    }

    // set dependent dirty state

    if ((pContext->hwState.dwStateFlags & KELVIN_FLAG_USERTEXCOORDSNEEDED_MASK) != dwUserCoordsNeeded) {
        pContext->hwState.dwStateFlags &= ~KELVIN_FLAG_USERTEXCOORDSNEEDED_MASK;
        pContext->hwState.dwStateFlags |= dwUserCoordsNeeded;
        pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_FVF;
    }

    if (dwNumTexCoordsNeeded != pContext->hwState.dwNumTexCoordsNeeded) {
        pContext->hwState.dwNumTexCoordsNeeded = dwNumTexCoordsNeeded;
        pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_FVF;
    }

    if ((pContext->hwState.dwStateFlags & KELVIN_FLAG_TEXSTATENEEDSINVMV) != dwInvMVNeeded) {
        pContext->hwState.dwStateFlags &= ~KELVIN_FLAG_TEXSTATENEEDSINVMV;
        pContext->hwState.dwStateFlags |= dwInvMVNeeded;
        pContext->hwState.dwDirtyFlags |= dwInvMVNeeded ? KELVIN_DIRTY_TRANSFORM : 0;
    }

    if (pContext->hwState.dwTexCoordIndices != dwTexCoordIndices) {
        pContext->hwState.dwTexCoordIndices = dwTexCoordIndices;
        pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_FVF;
    }

    if ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_SQUASHW_MASK) == D3D_REG_SQUASHW_ENABLE) {
        pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_TRANSFORM;
    }

    if (dwClipPlaneEnable) {
        DPF ("nvSetKelvinTextureState: exiting with unhandled clip planes");
        nvAssert (0);
        pContext->hwState.dwStateFlags |= KELVIN_FLAG_SETUPFAILURE;
    }

    dbgFlushType (NVDBG_FLUSH_STATE);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvKelvinSetFogMode (PNVD3DCONTEXT pContext)
{
    float fBias, fScale;

    nvAssert (pContext->dwRenderState[D3DRENDERSTATE_FOGENABLE]);

    cacheFogValues (pContext);

    switch (pContext->fogData.dwFogTableMode) {
        case D3DFOG_NONE:   // user-supplied fog (neither table nor vertex)
            fBias = 1.0f;
            fScale = 1.0f;
            pContext->hwState.kelvin.set1 (NV097_SET_FOG_MODE, NV097_SET_FOG_MODE_V_LINEAR);
            break;
        case D3DFOG_LINEAR:
            fBias = 1.0f + pContext->fogData.fFogTableEnd * pContext->fogData.fFogTableLinearScale;
            fScale = -pContext->fogData.fFogTableLinearScale;
            pContext->hwState.kelvin.set1 (NV097_SET_FOG_MODE, NV097_SET_FOG_MODE_V_LINEAR);
            break;
        case D3DFOG_EXP:
            fBias = 1.5f;
            fScale = -pContext->fogData.fFogTableDensity * (1.0f / (2.0f * 5.5452f));
            pContext->hwState.kelvin.set1 (NV097_SET_FOG_MODE, NV097_SET_FOG_MODE_V_EXP);
            break;
        case D3DFOG_EXP2:
            fBias = 1.5f;
            fScale = -pContext->fogData.fFogTableDensity * (1.0f / (2.0f * (float)sqrt(5.5452f)));
            pContext->hwState.kelvin.set1 (NV097_SET_FOG_MODE, NV097_SET_FOG_MODE_V_EXP2);
            break;
        default:
            DPF ("uh oh. unknown fog mode");
    }

    // set fog_gen mode. note this is actually only relevant in T&L fixed mode, but we'll just set it regardless
    if (pContext->fogData.dwFogTableMode == D3DFOG_NONE) {
        // both table fog and vertex fog are disabled. we default back to regular user fog from specular alpha
        pContext->hwState.kelvin.set1 (NV097_SET_FOG_GEN_MODE, NV097_SET_FOG_GEN_MODE_V_SPEC_ALPHA);
    }
    else {
        pContext->hwState.kelvin.set1 (NV097_SET_FOG_GEN_MODE,
                                       pContext->dwRenderState[D3DRENDERSTATE_RANGEFOGENABLE] ?
                                           NV097_SET_FOG_GEN_MODE_V_RADIAL :
                                           NV097_SET_FOG_GEN_MODE_V_PLANAR);
    }

    pContext->hwState.kelvin.set3f (NV097_SET_FOG_PARAMS(0), fBias, fScale, 0.0f);

    dbgFlushType (NVDBG_FLUSH_STATE);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

// set the specular/fog combiner

HRESULT nvSetKelvinSpecularFogCombiner (PNVD3DCONTEXT pContext)
{
    DWORD dwControl0, dwControl1;  // HW control words

    pContext->hwState.dwDirtyFlags &= ~KELVIN_DIRTY_COMBINERS_SPECFOG;

    dwControl0 = 0;

    if (pContext->dwRenderState[D3DRENDERSTATE_FOGENABLE]) {

        pContext->hwState.kelvin.set2 (NV097_SET_FOG_ENABLE,
                                       NV097_SET_FOG_ENABLE_V_TRUE,
                                       swapRGB(pContext->dwRenderState[D3DRENDERSTATE_FOGCOLOR]));

        nvKelvinSetFogMode (pContext);

        // A is fog factor, obtained from fog alpha
        dwControl0 |= (DRF_DEF (097, _SET_COMBINER_SPECULAR_FOG_CW0, _A_SOURCE, _REG_3) |
                       DRF_DEF (097, _SET_COMBINER_SPECULAR_FOG_CW0, _A_ALPHA, _TRUE));

        // B source is (textured diffuse) or (textured diffuse + specular)
        if (pContext->dwRenderState[D3DRENDERSTATE_SPECULARENABLE]) {
            dwControl0 |= DRF_DEF (097, _SET_COMBINER_SPECULAR_FOG_CW0, _B_SOURCE, _REG_SPECLIT);
        }
        else {  // don't add specular to diffuse(textured) color
            dwControl0 |= DRF_DEF (097, _SET_COMBINER_SPECULAR_FOG_CW0, _B_SOURCE, _REG_C);
        }

        // C is fog color
        dwControl0 |= DRF_DEF (097, _SET_COMBINER_SPECULAR_FOG_CW0, _C_SOURCE, _REG_3);

        // D isn't used

        pContext->hwState.kelvin.set1 (NV097_SET_COMBINER_SPECULAR_FOG_CW0, dwControl0);
    }

    else { // no fog, just output diffuse (+ specular)

        pContext->hwState.kelvin.set1 (NV097_SET_FOG_ENABLE, NV097_SET_FOG_ENABLE_V_FALSE);

        if (pContext->dwRenderState[D3DRENDERSTATE_SPECULARENABLE]) {
            dwControl0 |= DRF_DEF (097, _SET_COMBINER_SPECULAR_FOG_CW0, _D_SOURCE, _REG_SPECLIT);
        }
        else {  // don't add specular to diffuse(textured) color
            dwControl0 |= DRF_DEF (097, _SET_COMBINER_SPECULAR_FOG_CW0, _D_SOURCE, _REG_C);
        }

        pContext->hwState.kelvin.set1 (NV097_SET_COMBINER_SPECULAR_FOG_CW0, dwControl0);
    }

    dwControl1 = 0;

    // the final value for alpha is just taken from G
    dwControl1 |= (DRF_DEF (097, _SET_COMBINER_SPECULAR_FOG_CW1, _G_SOURCE, _REG_C) |
                   DRF_DEF (097, _SET_COMBINER_SPECULAR_FOG_CW1, _G_ALPHA, _TRUE));

    dwControl1 |= DRF_DEF (097, _SET_COMBINER_SPECULAR_FOG_CW1, _SPECULAR_CLAMP, _TRUE);

    pContext->hwState.kelvin.set1 (NV097_SET_COMBINER_SPECULAR_FOG_CW1, dwControl1);

#ifdef ALPHA_CULL
    //cachec off spec/fog control words
    pContext->hwState.specfog_cw[0] = dwControl0;
    pContext->hwState.specfog_cw[1] = dwControl1;

    if(pContext->dwEarlyCopyStrategy && pContext->hwState.alphacull_mode >= 2)
        pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_MISC_STATE;
#endif

    dbgFlushType (NVDBG_FLUSH_STATE);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

// set kelvin vertex shaders

HRESULT nvSetKelvinVertexShader (PNVD3DCONTEXT pContext)
{
#ifdef PRECOMPILED_PASSTHROUGH
    KELVIN_MICRO_PROGRAM *pProgram;
#else
    KELVIN_MICRO_PROGRAM program;
    char *pProgram;
#endif

    pContext->hwState.dwDirtyFlags &= ~KELVIN_DIRTY_VERTEX_SHADER;

    nvAssert(pContext->pCurrentVShader);

    if ((pContext->dwDXAppVersion >= 0x800) && (pContext->pCurrentVShader->hasProgram())) {

        // load user's program
        CVertexShader* pVertexShader = pContext->pCurrentVShader;

        if (pVertexShader->m_ProgramOutput.residentNumInstructions) {

#ifdef KPFS
            pDriverData->nvKelvinPM.download(pContext,pVertexShader);
#else

            pContext->hwState.kelvin.set1 (NV097_SET_TRANSFORM_EXECUTION_MODE,
                                           (DRF_DEF (097, _SET_TRANSFORM_EXECUTION_MODE, _MODE, _PROGRAM) |
                                            DRF_DEF (097, _SET_TRANSFORM_EXECUTION_MODE, _RANGE_MODE, _USER)));
            pContext->hwState.kelvin.set1 (NV097_SET_TRANSFORM_PROGRAM_CXT_WRITE_EN,
                                           DRF_DEF (097, _SET_TRANSFORM_PROGRAM_CXT_WRITE_EN, _V, _READ_ONLY));

            pContext->hwState.kelvin.set1 (NV097_SET_TRANSFORM_PROGRAM_START, 0);
            nvKelvinDownloadProgram (pContext, &pVertexShader->m_ProgramOutput, 0);
            nvKelvinDownloadConstants (pContext);
#endif

        }

    }

    else if (pContext->hwState.dwStateFlags & KELVIN_FLAG_PASSTHROUGHMODE) {
        // choose the appropriate passthru program
        if (pContext->fogData.dwFogTableMode == D3DFOG_NONE) {
            // fog is disabled or both table fog and vertex fog are disabled.
            // we default back to regular user fog from specular alpha
#ifdef PRECOMPILED_PASSTHROUGH
            pProgram = (KELVIN_MICRO_PROGRAM*)(kmpPassthruProgramSpecFog);
#else
            pProgram = szPassthruProgramSpecFog;
#endif
        }
        else {
            // we're doing vertex or table fog
            nvAssert(pContext->hwState.dwFogSource); // assert that fog source has been set
            if (pContext->hwState.dwFogSource == CHardwareState::FOG_SOURCE_Z) {
                // use z for fog depth
#ifdef PRECOMPILED_PASSTHROUGH
                pProgram = (KELVIN_MICRO_PROGRAM*)(kmpPassthruProgramZFog);
#else
                pProgram = szPassthruProgramZFog;
#endif
            }
            else {
                // use w for fog depth
#ifdef PRECOMPILED_PASSTHROUGH
                pProgram = (KELVIN_MICRO_PROGRAM*)(kmpPassthruProgramWFog);
#else
                pProgram = szPassthruProgramWFog;
#endif
            }
        }
        DWORD temp = sizeof(KELVIN_MICRO_PROGRAM);
        // passthrough program
        pContext->hwState.kelvin.set1 (NV097_SET_TRANSFORM_EXECUTION_MODE,
                                       (DRF_DEF (097, _SET_TRANSFORM_EXECUTION_MODE, _MODE, _PROGRAM) |
                                        DRF_DEF (097, _SET_TRANSFORM_EXECUTION_MODE, _RANGE_MODE, _PRIV)));
        pContext->hwState.kelvin.set1 (NV097_SET_TRANSFORM_PROGRAM_CXT_WRITE_EN,
                                       DRF_DEF (097, _SET_TRANSFORM_PROGRAM_CXT_WRITE_EN, _V, _READ_ONLY));
#ifdef PRECOMPILED_PASSTHROUGH

    #ifdef KPFS
        pDriverData->nvKelvinPM.download_special(pContext,pProgram,0xFFFFFFFF);
    #else
        nvKelvinDownloadProgram (pContext, pProgram,0);
    #endif

#else
        nvKelvinInitProgram (&program);
        nvKelvinParseProgram (&program, pProgram);

    #ifdef KPFS
        pDriverData->nvKelvinPM.download_special(pContext,pProgram,0xFFFFFFFF);
    #else
        nvKelvinDownloadProgram (pContext, &program,0);
    #endif

#endif

#ifndef KPFS
        // the starting address is just 0
        pContext->hwState.kelvin.set1 (NV097_SET_TRANSFORM_PROGRAM_START, 0);
#endif
    }

    else {
        // just use fixed mode
        pContext->hwState.kelvin.set1 (NV097_SET_TRANSFORM_EXECUTION_MODE,
                                       (DRF_DEF (097, _SET_TRANSFORM_EXECUTION_MODE, _MODE, _FIXED) |
                                        DRF_DEF (097, _SET_TRANSFORM_EXECUTION_MODE, _RANGE_MODE, _PRIV)));
#ifdef KPFS
        pDriverData->nvKelvinPM.dirty();
#endif

    }

    dbgFlushType (NVDBG_FLUSH_STATE);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

// set texture transformation matrices

HRESULT nvSetKelvinTextureTransform (PNVD3DCONTEXT pContext)
{
    BOOL       bEnable;
    DWORD      dwHWStage, dwD3DStage;
    DWORD      dwInCount, dwOutCount;
    DWORD      dwFlags, dwTexUnitStatus;
    DWORD      dwMatrixName, dwMatrixType;
    D3DMATRIX *pMatrix;

    pContext->hwState.dwDirtyFlags &= ~KELVIN_DIRTY_TEXTURE_TRANSFORM;

    for (dwHWStage=0; dwHWStage < KELVIN_NUM_TEXTURES; dwHWStage++) {

        dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[dwHWStage];
        dwTexUnitStatus = pContext->hwState.dwTextureUnitStatus[dwHWStage];

        if ((dwD3DStage == KELVIN_UNUSED) || (dwTexUnitStatus == KELVIN_TEXUNITSTATUS_CLIP)) {

            bEnable = FALSE;

        }

        else {

            nvAssert (dwTexUnitStatus & (KELVIN_TEXUNITSTATUS_USER     |
                                         KELVIN_TEXUNITSTATUS_BUMPMAPA |
                                         KELVIN_TEXUNITSTATUS_BUMPMAPB |
                                         KELVIN_TEXUNITSTATUS_BUMPMAPC |
                                         KELVIN_TEXUNITSTATUS_BUMPMAPD));
            nvAssert (pContext->pCurrentPShader || (pContext->tssState[dwD3DStage].dwValue[D3DTSS_COLOROP] != D3DTOP_DISABLE));

            dwFlags = pContext->tssState[dwD3DStage].dwValue[D3DTSS_TEXTURETRANSFORMFLAGS];

            // the number of coordinates to come out of the transformation, including the projective coordinate
            // (== the number of d3d-style matrix columns with non-zero elements)
            dwOutCount = dwFlags & 0xff; // BUGBUG there should be a #define for this. pester MS
            bEnable = (dwOutCount != D3DTTFF_DISABLE);

        }

        if (!bEnable) {

            pContext->hwState.kelvin.set1 (NV097_SET_TEXTURE_MATRIX_ENABLE(dwHWStage),
                                           DRF_DEF (097, _SET_TEXTURE_MATRIX_ENABLE, _V, _FALSE));

        }

        else {

            pContext->hwState.kelvin.set1 (NV097_SET_TEXTURE_MATRIX_ENABLE(dwHWStage),
                                           DRF_DEF (097, _SET_TEXTURE_MATRIX_ENABLE, _V, _TRUE));

            pMatrix = &(pContext->tssState[dwD3DStage].mTexTransformMatrix);

            // the number of coordinates incoming from the vertex streams or texgen (not counting q).
            // this is typically the number of d3d-style matrix rows with non-zero elements, though
            // there may be dwInCount+1 rows, the last of which references the q=1.0 that d3d assumes
            // to be automatically postpended to the incoming coordinates.
            DWORD dwTexGen  = pContext->tssState[dwD3DStage].dwValue[D3DTSS_TEXCOORDINDEX] & 0xffff0000;
            DWORD dwTCIndex = pContext->tssState[dwD3DStage].dwValue[D3DTSS_TEXCOORDINDEX] & 0x0000ffff;
            DWORD dwVAIndex = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
            if (dwTexGen) {
                dwInCount = 3;
            }
            else {
                // if index invalid, just use 0,0
                dwInCount = (pContext->pCurrentVShader->bVAExists(dwVAIndex)) ?
                            (pContext->pCurrentVShader->getVASize(dwVAIndex)) :
                            2*sizeof(DWORD);
                dwInCount >>= 2;
            }

            // nv097 texture matrix macros are less than ideal
            dwMatrixName = NV097_SET_TEXTURE_MATRIX0(0) + 0x40*dwHWStage;

            // calculate an arbitrary identifier
            dwMatrixType = (dwInCount << 8) | (dwOutCount << 4) | ((dwFlags & D3DTTFF_PROJECTED) ? 1 : 0);

            // the way we emit the matrix varies widely because d3d is dumb.
            // A. when there are two incoming coordinates, we must move the 3rd matrix row to the fourth, because
            //    MS expects the appended q to sit in the third slot, whereas in the HW, it sits in the 4th.
            // B. when the matrix is projective and there are only 3 outgoing coordinates (including q)
            //    we must shift the value in the third outgoing slot (where MS puts q) to the 4th slot (where
            //    the HW wants it) by moving the 3rd column to the 4th
            // C. when the matrix is non-projective, it becomes our job to override the relevant row of the
            //    matrix, forcing the outgoing q to 1.0
            // finally, when all is said and done, the matrix must be transposed to change it from backward
            // d3d style to real opengl style.
            switch (dwMatrixType) {

                case 0x220:
                    // (s,t,1.0) in, (s,t,1.0) out
                    pContext->hwState.kelvin.setTextureTransformMatrixType220 (dwMatrixName, pMatrix);
                    break;
                case 0x230:
                    // (s,t,1.0) in, (s,t,r,1.0) out
                    pContext->hwState.kelvin.setTextureTransformMatrixType230 (dwMatrixName, pMatrix);
                    break;
                case 0x231:
                    // (s,t,1.0) in, (s,t,q) out
                    pContext->hwState.kelvin.setTextureTransformMatrixType231 (dwMatrixName, pMatrix);
                    break;
                case 0x241:
                    // (s,t,1.0) in, (s,t,r,q) out
                    pContext->hwState.kelvin.setTextureTransformMatrixType241 (dwMatrixName, pMatrix);
                    break;
                case 0x320:
                    // (s,t,r,1.0) in, (s,t,1.0) out
                    pContext->hwState.kelvin.setTextureTransformMatrixType320 (dwMatrixName, pMatrix);
                    break;
                case 0x330:
                    // (s,t,r,1.0) in, (s,t,r,1.0) out
                    pContext->hwState.kelvin.setTextureTransformMatrixType330 (dwMatrixName, pMatrix);
                    break;
                case 0x331:
                    // (s,t,r,1.0) in, (s,t,q) out
                    pContext->hwState.kelvin.setTextureTransformMatrixType331 (dwMatrixName, pMatrix);
                    break;
                case 0x341:
                    // (s,t,r,1.0) in, (s,t,r,q) out
                    pContext->hwState.kelvin.setTextureTransformMatrixType341 (dwMatrixName, pMatrix);
                    break;
                default:
                    DPF ("unhandled texture transform = 0x%04x", dwMatrixType);
                    dbgD3DError();
                    break;

            }  // switch

        }  // else enable

    }  // for dwHWStage=0...

    dbgFlushType (NVDBG_FLUSH_STATE);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

// set kelvin class specular parameters

HRESULT nvKelvinSetSpecularParams (PNVD3DCONTEXT pContext)
{
    float L, M, N, L1, M1, N1, power;

    nvAssert ((pContext->dwRenderState[D3DRENDERSTATE_SPECULARENABLE]) ||
              (pContext->hwState.dwStateFlags & KELVIN_FLAG_COMBINERSNEEDSPECULAR));

    power = pContext->Material.dvPower;
    explut (power, &L, &M);
    N = 1.f+L-M;
    explut (0.5f*power, &L1, &M1);
    N1 = 1.f+L1-M1;
    pContext->hwState.kelvin.set3f (NV097_SET_SPECULAR_PARAMS(0),L, M, N);
    pContext->hwState.kelvin.set3f (NV097_SET_SPECULAR_PARAMS(3),L1,M1,N1);
    //pContext->hwState.kelvin.set3f (NV097_SET_BACK_SPECULAR_PARAMS(0),L, M, N);
    //pContext->hwState.kelvin.set3f (NV097_SET_BACK_SPECULAR_PARAMS(3),L1,M1,N1);

    return (D3D_OK);
}

//---------------------------------------------------------------------------

// set diffuse, specular, and ambient colors for a particular light
// input:
//      - dwLightID = light index [0...7]
//      - pLight7 = pointer to light data
//      - dwCmArg   = color material flags

HRESULT nvKelvinDumpLightColors (PNVD3DCONTEXT pContext, DWORD dwLightID, LPD3DLIGHT7 pLight7, DWORD dwCmArg)
{
    D3DVALUE dvAmbientR, dvAmbientG, dvAmbientB;
    D3DVALUE dvDiffuseR, dvDiffuseG, dvDiffuseB;
    D3DVALUE dvSpecularR, dvSpecularG, dvSpecularB;

    nvAssert ((dwLightID >=0) && (dwLightID <= 7));

    dvAmbientR = pLight7->dcvAmbient.dvR;
    dvAmbientG = pLight7->dcvAmbient.dvG;
    dvAmbientB = pLight7->dcvAmbient.dvB;
    if (DRF_VAL (097, _SET_COLOR_MATERIAL, _AMBIENT_MATERIAL, dwCmArg) == NV097_SET_COLOR_MATERIAL_AMBIENT_MATERIAL_DISABLE) {
        // use material ambient color
        dvAmbientR *= pContext->Material.dcvAmbient.dvR;
        dvAmbientG *= pContext->Material.dcvAmbient.dvG;
        dvAmbientB *= pContext->Material.dcvAmbient.dvB;
    }

    dvDiffuseR = pLight7->dcvDiffuse.dvR;
    dvDiffuseG = pLight7->dcvDiffuse.dvG;
    dvDiffuseB = pLight7->dcvDiffuse.dvB;
    if (DRF_VAL (097, _SET_COLOR_MATERIAL, _DIFF_MATERIAL, dwCmArg) == NV097_SET_COLOR_MATERIAL_DIFF_MATERIAL_DISABLE) {
        // use material diffuse color
        dvDiffuseR *= pContext->Material.dcvDiffuse.dvR;
        dvDiffuseG *= pContext->Material.dcvDiffuse.dvG;
        dvDiffuseB *= pContext->Material.dcvDiffuse.dvB;
    }

    dvSpecularR = pLight7->dcvSpecular.dvR;
    dvSpecularG = pLight7->dcvSpecular.dvG;
    dvSpecularB = pLight7->dcvSpecular.dvB;
    if (DRF_VAL (097, _SET_COLOR_MATERIAL, _SPECULAR_MATERIAL, dwCmArg) == NV097_SET_COLOR_MATERIAL_SPECULAR_MATERIAL_DISABLE) {
        // follow material specular color
        dvSpecularR *= pContext->Material.dcvSpecular.dvR;
        dvSpecularG *= pContext->Material.dcvSpecular.dvG;
        dvSpecularB *= pContext->Material.dcvSpecular.dvB;
    }

    pContext->hwState.kelvin.set3f (NV097_SET_LIGHT_AMBIENT_COLOR(dwLightID,0), dvAmbientR, dvAmbientG, dvAmbientB);  // ambient
    pContext->hwState.kelvin.set3f (NV097_SET_LIGHT_DIFFUSE_COLOR(dwLightID,0), dvDiffuseR, dvDiffuseG, dvDiffuseB);  // diffuse
    pContext->hwState.kelvin.set3f (NV097_SET_LIGHT_SPECULAR_COLOR(dwLightID,0),dvSpecularR,dvSpecularG,dvSpecularB); // specular

    return (D3D_OK);
}

//---------------------------------------------------------------------------

// set position and attenuation of a particular light
// input:
//      - dwLightID = light index [0...7]
//      - pLight7 = pointer to light data

HRESULT nvKelvinDumpLocalLightData (PNVD3DCONTEXT pContext, int dwLightID, LPD3DLIGHT7 pLight7)
{
    D3DVECTOR pos1;

    nvAssert ((dwLightID >=0) && (dwLightID <= 7));

    // We don't normalize the position
    XformBy4x3 (&pos1, &(pLight7->dvPosition), 1.f, &(pContext->xfmView));

    pContext->hwState.kelvin.set3f (NV097_SET_LIGHT_LOCAL_POSITION(dwLightID,0), pos1.dvX, pos1.dvY, pos1.dvZ);

    nvAssert ((DWORD_FROM_FLOAT(pLight7->dvAttenuation0) != 0) ||
              (DWORD_FROM_FLOAT(pLight7->dvAttenuation1) != 0) ||
              (DWORD_FROM_FLOAT(pLight7->dvAttenuation2) != 0));

    pContext->hwState.kelvin.set3f (NV097_SET_LIGHT_LOCAL_ATTENUATION(dwLightID,0),
                                    pLight7->dvAttenuation0,
                                    pLight7->dvAttenuation1,
                                    pLight7->dvAttenuation2);

    return (D3D_OK);
}

//---------------------------------------------------------------------------

DWORD getKelvinColorMaterialFlags (PNVD3DCONTEXT pContext)
{
    DWORD dwArgs;

    // start out with everything disabled
    dwArgs = 0;

    // if COLORVERTEX isn't set just return now
    if (!pContext->dwRenderState[D3DRENDERSTATE_COLORVERTEX]) {
        return (dwArgs);
    }

    switch (pContext->dwRenderState[D3DRENDERSTATE_AMBIENTMATERIALSOURCE]) {
        case D3DMCS_MATERIAL:
            break;
        case D3DMCS_COLOR1:  // diffuse
            if (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_DIFFUSE])) {
                dwArgs |= DRF_DEF (097, _SET_COLOR_MATERIAL, _AMBIENT_MATERIAL, _DIFFUSE_VTX_COLOR);
                //dwArgs |= DRF_DEF (097, _SET_COLOR_MATERIAL, _BACK_AMBIENT_MATERIAL, _DIFF_VTX_COLOR);
            }
            break;
        case D3DMCS_COLOR2:  // specular
            if (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_SPECULAR])) {
                dwArgs |= DRF_DEF (097, _SET_COLOR_MATERIAL, _AMBIENT_MATERIAL, _SPECULAR_VTX_COLOR);
                //dwArgs |= DRF_DEF (097, _SET_COLOR_MATERIAL, _BACK_AMBIENT_MATERIAL, _SPEC_VTX_COLOR);
            }
            break;
        default:
            DPF ("unknown AMBIENTMATERIALSOURCE");
            break;
    }

    switch (pContext->dwRenderState[D3DRENDERSTATE_DIFFUSEMATERIALSOURCE]) {
        case D3DMCS_MATERIAL:
            break;
        case D3DMCS_COLOR1:  // diffuse
            if (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_DIFFUSE])) {
                dwArgs |= DRF_DEF (097, _SET_COLOR_MATERIAL, _DIFF_MATERIAL, _DIFFUSE_VTX_COLOR);
                //dwArgs |= DRF_DEF (097, _SET_COLOR_MATERIAL, _BACK_DIFF_MATERIAL, _DIFF_VTX_COLOR);
            }
            break;
        case D3DMCS_COLOR2:  // specular
            if (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_SPECULAR])) {
                dwArgs |= DRF_DEF (097, _SET_COLOR_MATERIAL, _DIFF_MATERIAL, _SPECULAR_VTX_COLOR);
                //dwArgs |= DRF_DEF (097, _SET_COLOR_MATERIAL, _BACK_DIFF_MATERIAL, _SPEC_VTX_COLOR);
            }
            break;
        default:
            DPF ("unknown DIFFUSEMATERIALSOURCE");
            break;
    }

    switch (pContext->dwRenderState[D3DRENDERSTATE_SPECULARMATERIALSOURCE]) {
        case D3DMCS_MATERIAL:
            break;
        case D3DMCS_COLOR1:  // diffuse
            if (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_DIFFUSE])) {
                dwArgs |= DRF_DEF (097, _SET_COLOR_MATERIAL, _SPECULAR_MATERIAL, _DIFFUSE_VTX_COLOR);
                //dwArgs |= DRF_DEF (097, _SET_COLOR_MATERIAL, _BACK_SPECULAR_MATERIAL, _DIFF_VTX_COLOR);
            }
            break;
        case D3DMCS_COLOR2:  // specular
            // inherit material specular from vertex specular
            if (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_SPECULAR])) {
                dwArgs |= DRF_DEF (097, _SET_COLOR_MATERIAL, _SPECULAR_MATERIAL, _SPECULAR_VTX_COLOR);
                //dwArgs |= DRF_DEF (097, _SET_COLOR_MATERIAL, _BACK_SPECULAR_MATERIAL, _SPEC_VTX_COLOR);
            }
            break;
        default:
            DPF ("unknown SPECULARMATERIALSOURCE");
            break;
    }

    switch (pContext->dwRenderState[D3DRENDERSTATE_EMISSIVEMATERIALSOURCE]) {
        case D3DMCS_MATERIAL:
            break;
        case D3DMCS_COLOR1:  // diffuse
            if (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_DIFFUSE])) {
                dwArgs |= DRF_DEF (097, _SET_COLOR_MATERIAL, _EMISSIVE_MATERIAL, _DIFFUSE_VTX_COLOR);
                //dwArgs |= DRF_DEF (097, _SET_COLOR_MATERIAL, _BACK_EMISSIVE_MATERIAL, _DIFF_VTX_COLOR);
            }
            break;
        case D3DMCS_COLOR2:  // specular
            if (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_SPECULAR])) {
                dwArgs |= DRF_DEF (097, _SET_COLOR_MATERIAL, _EMISSIVE_MATERIAL, _SPECULAR_VTX_COLOR);
                //dwArgs |= DRF_DEF (097, _SET_COLOR_MATERIAL, _BACK_EMISSIVE_MATERIAL, _SPEC_VTX_COLOR);
            }
            break;
        default:
            DPF ("unknown EMISSIVEMATERIALSOURCE");
            break;
    }

    return (dwArgs);
}

//---------------------------------------------------------------------------

// set lighting state

HRESULT nvSetKelvinLights (PNVD3DCONTEXT pContext)
{
    DWORD         dwColorMaterialArgs;
    DWORD         dwControl = 0;
    DWORD         dwLightNum;
    DWORD         dwMask = 0;
    D3DCOLORVALUE dcvAmbient, dcvEmissive;
    D3DVECTOR     eyeDirection;
    D3DVECTOR     dir, hv;          // light directions
    pnvLight      pLight;
    LPD3DLIGHT7   pLight7;
    BOOL          bSpecularNeeded;
    DWORD         dwInvMVNeeded;

    pContext->hwState.dwDirtyFlags &= ~KELVIN_DIRTY_LIGHTS;

    // specular enable
    bSpecularNeeded = ((pContext->dwRenderState[D3DRENDERSTATE_SPECULARENABLE]) ||
                       (pContext->hwState.dwStateFlags & KELVIN_FLAG_COMBINERSNEEDSPECULAR)) ? TRUE : FALSE;

    // disable hardware lighting if app has disabled it or if we're in passthrough mode
    // (yes, stupid apps will try to enable lighting without giving us normals, etc...)
    if (!GET_LIGHTING_STATE(pContext) || (pContext->hwState.dwStateFlags & KELVIN_FLAG_PASSTHROUGHMODE)) {

        // disable lighting
        pContext->hwState.kelvin.set1 (NV097_SET_LIGHTING_ENABLE, NV097_SET_LIGHTING_ENABLE_V_FALSE);

        dwInvMVNeeded = 0;

        pContext->hwState.kelvin.set1 (NV097_SET_SPECULAR_ENABLE, DRF_NUM (097, _SET_SPECULAR_ENABLE, _V, bSpecularNeeded));

        dwControl |= (DRF_DEF (097, _SET_LIGHT_CONTROL, _LOCALEYE, _FALSE) |
                      DRF_DEF (097, _SET_LIGHT_CONTROL, _SOUT, _ZERO_OUT)  |            // set alpha component to 1.0 (method is horribly misnamed)
                      DRF_DEF (097, _SET_LIGHT_CONTROL, _SEPARATE_SPECULAR_EN, _TRUE)); // this is a don't-care

        pContext->hwState.kelvin.set1 (NV097_SET_LIGHT_CONTROL, dwControl);

        // set default diffuse and specular
        pContext->hwState.kelvin.set1 (NV097_SET_DIFFUSE_COLOR4UB,  0xFFFFFFFF);  // white
        pContext->hwState.kelvin.set1 (NV097_SET_SPECULAR_COLOR4UB, 0);           // black

    }

    else {

        // we shouldn't be in passthru mode if we're really going to do lighting
        // (moreover we can't be, b/c we won't have calculated xfmInvModelView which
        // is needed for spot lights)
        nvAssert (!(pContext->hwState.dwStateFlags & KELVIN_FLAG_PASSTHROUGHMODE));

        // enable lighting
        pContext->hwState.kelvin.set1 (NV097_SET_LIGHTING_ENABLE, NV097_SET_LIGHTING_ENABLE_V_TRUE);

        dwInvMVNeeded = KELVIN_FLAG_LIGHTINGNEEDSINVMV;

        // this should always be TRUE in T&L mode. see table of kelvin's perverse specular behavior
        pContext->hwState.kelvin.set1 (NV097_SET_SPECULAR_ENABLE, DRF_DEF (097, _SET_SPECULAR_ENABLE, _V, _TRUE));

        // set specular parameters if needed
        if (bSpecularNeeded) {
            nvKelvinSetSpecularParams (pContext);
        }

        // use local viewer only if we really need to, since it's slow
        if ((pContext->dwRenderState[D3DRENDERSTATE_LOCALVIEWER]) &&
            (pContext->lighting.pActiveLights != NULL) &&
            (bSpecularNeeded)) {
            dwControl |= DRF_DEF (097, _SET_LIGHT_CONTROL, _LOCALEYE, _TRUE);
        }
        else {
            dwControl |= DRF_DEF (097, _SET_LIGHT_CONTROL, _LOCALEYE, _FALSE);
        }

        dwControl |= (DRF_DEF (097, _SET_LIGHT_CONTROL, _SOUT, _ZERO_OUT) |             // set alpha component to 1.0 (method is horribly misnamed)
                      DRF_DEF (097, _SET_LIGHT_CONTROL, _SEPARATE_SPECULAR_EN, _TRUE)); // d3d never lumps specular in with diffuse

        pContext->hwState.kelvin.set1 (NV097_SET_LIGHT_CONTROL, dwControl);

        // material properties
        dwColorMaterialArgs = getKelvinColorMaterialFlags (pContext);
        pContext->hwState.kelvin.set1 (NV097_SET_COLOR_MATERIAL, dwColorMaterialArgs);

        // in kelvin, the color is initialized to SCENE_AMBIENT, C0, or C1. this is followed by an
        // optional accumulation of C0 or C1 times MATERIAL_EMISSION. both the initialization and
        // accumulation are controlled by the color material bits, so these determine the (sometimes
        // counter-intuitive) values to which we initialize SCENE_AMBIENT and MATERIAL_EMISSION.

        if (dwColorMaterialArgs & (DRF_DEF (097, _SET_COLOR_MATERIAL, _AMBIENT_MATERIAL, _DIFFUSE_VTX_COLOR) |
                                   DRF_DEF (097, _SET_COLOR_MATERIAL, _AMBIENT_MATERIAL, _SPECULAR_VTX_COLOR))) {
            // ambient is being pulled from the vertex
            dcvAmbient.dvR  = pContext->Material.dcvEmissive.dvR;
            dcvAmbient.dvG  = pContext->Material.dcvEmissive.dvG;
            dcvAmbient.dvB  = pContext->Material.dcvEmissive.dvB;
            dcvEmissive.dvR = pContext->lighting.dcvAmbient.dvR;
            dcvEmissive.dvG = pContext->lighting.dcvAmbient.dvG;
            dcvEmissive.dvB = pContext->lighting.dcvAmbient.dvB;
        }
        else if (dwColorMaterialArgs & (DRF_DEF (097, _SET_COLOR_MATERIAL, _EMISSIVE_MATERIAL, _DIFFUSE_VTX_COLOR) |
                                        DRF_DEF (097, _SET_COLOR_MATERIAL, _EMISSIVE_MATERIAL, _SPECULAR_VTX_COLOR))) {
            // emissive is being pulled from the vertex, and ambient is not
            dcvAmbient.dvR  = pContext->lighting.dcvAmbient.dvR * pContext->Material.dcvAmbient.dvR;
            dcvAmbient.dvG  = pContext->lighting.dcvAmbient.dvG * pContext->Material.dcvAmbient.dvG;
            dcvAmbient.dvB  = pContext->lighting.dcvAmbient.dvB * pContext->Material.dcvAmbient.dvB;
            dcvEmissive.dvR = 1.0;
            dcvEmissive.dvG = 1.0;
            dcvEmissive.dvB = 1.0;
        }
        else {
            // neither ambient nor emissive is being pulled from the vertex
            dcvAmbient.dvR  = (pContext->lighting.dcvAmbient.dvR * pContext->Material.dcvAmbient.dvR) + pContext->Material.dcvEmissive.dvR;
            dcvAmbient.dvG  = (pContext->lighting.dcvAmbient.dvG * pContext->Material.dcvAmbient.dvG) + pContext->Material.dcvEmissive.dvG;
            dcvAmbient.dvB  = (pContext->lighting.dcvAmbient.dvB * pContext->Material.dcvAmbient.dvB) + pContext->Material.dcvEmissive.dvB;
            dcvEmissive.dvR = 0.0;
            dcvEmissive.dvG = 0.0;
            dcvEmissive.dvB = 0.0;
        }

        pContext->hwState.kelvin.set3f (NV097_SET_SCENE_AMBIENT_COLOR(0), dcvAmbient.dvR,  dcvAmbient.dvG,  dcvAmbient.dvB);
        pContext->hwState.kelvin.set3f (NV097_SET_MATERIAL_EMISSION(0),   dcvEmissive.dvR, dcvEmissive.dvG, dcvEmissive.dvB);

        // pull material alpha from the diffuse component
        pContext->hwState.kelvin.set1f (NV097_SET_MATERIAL_ALPHA, pContext->Material.dcvDiffuse.dvA);
        //pContext->hwState.kelvin.set1f (NV097_SET_BACK_MATERIAL_ALPHA, pContext->Material.dcvDiffuse.dvA);

        // Set the eye position and direction
        eyeDirection = vectorZero;
        eyeDirection.dvZ = -1.0f;

        // Download transform and lighting methods. Pack lights and send them

        dwMask = 0;
        dwLightNum = 0;

        for (pLight=pContext->lighting.pActiveLights; pLight!=NULL; pLight=pLight->pNext) {

            if (dwLightNum == 8) break; // too many

            pLight7 = &(pLight->Light7);
            dbgDisplayLight (pLight7);

            switch (pLight7->dltType) {

                case D3DLIGHT_POINT:

                    dwMask |= NV097_SET_LIGHT_ENABLE_MASK_LIGHT0_LOCAL << (dwLightNum << 1);

                    nvKelvinDumpLightColors (pContext, dwLightNum, pLight7, dwColorMaterialArgs);
                    pContext->hwState.kelvin.set1f (NV097_SET_LIGHT_LOCAL_RANGE(dwLightNum), pLight7->dvRange);
                    nvKelvinDumpLocalLightData (pContext, dwLightNum, pLight7);

                    break;

                case D3DLIGHT_SPOT:

                    dwMask |= NV097_SET_LIGHT_ENABLE_MASK_LIGHT0_SPOT << (dwLightNum << 1);

                    nvKelvinDumpLightColors (pContext, dwLightNum, pLight7, dwColorMaterialArgs);
                    pContext->hwState.kelvin.set1f (NV097_SET_LIGHT_LOCAL_RANGE(dwLightNum), pLight7->dvRange);
                    nvKelvinDumpLocalLightData (pContext, dwLightNum, pLight7);

                    // Transform the spotlight direction vector back
                    XformBy4x3 (&dir, &(pLight->direction), 0.f, &(pContext->xfmView));
                    // unless the view matrix has non-uniform scales in it, this is not necessary
                    // For now, we take the easy way out though.
                    NormalizeVector3 (&dir);

                    ScaleVector3 (&dir, &dir, pLight->dvScale);
                    pContext->hwState.kelvin.set3f (NV097_SET_LIGHT_SPOT_FALLOFF(dwLightNum,0),
                                                    pLight->falloffParams.L,
                                                    pLight->falloffParams.M,
                                                    pLight->falloffParams.N);
                    pContext->hwState.kelvin.set4f (NV097_SET_LIGHT_SPOT_DIRECTION(dwLightNum,0),
                                                    dir.dvX, dir.dvY, dir.dvZ, pLight->dvW);

                    break;

                case D3DLIGHT_DIRECTIONAL:

                    dwMask |= NV097_SET_LIGHT_ENABLE_MASK_LIGHT0_INFINITE << (dwLightNum << 1);

                    nvKelvinDumpLightColors (pContext, dwLightNum, pLight7, dwColorMaterialArgs);
                    pContext->hwState.kelvin.set1f (NV097_SET_LIGHT_LOCAL_RANGE(dwLightNum), 1e30f);

                    // Transform the spotlight direction vector back
                    XformBy4x3 (&dir, &(pLight->direction), 0.f, &(pContext->xfmView));
                    // unless the view matrix has non-uniform scales in it, this is not necessary
                    // For now, we take the easy way out though.
                    NormalizeVector3 (&dir);

                    AddVectors3 (&hv, &dir, &eyeDirection);
                    NormalizeVector3 (&hv);
                    pContext->hwState.kelvin.set3f (NV097_SET_LIGHT_INFINITE_HALF_VECTOR(dwLightNum,0),
                                                    hv.dvX, hv.dvY, hv.dvZ);
                    pContext->hwState.kelvin.set3f (NV097_SET_LIGHT_INFINITE_DIRECTION(dwLightNum,0),
                                                    dir.dvX, dir.dvY, dir.dvZ);

                    break;

                default:

                    DPF ("unknown light type in nvSetKelvinLights");
                    dbgD3DError();
                    break;

            } // switch

            dwLightNum++;

        } // for all lights

        // Tell HW which lights are active
        pContext->hwState.kelvin.set1 (NV097_SET_LIGHT_ENABLE_MASK, dwMask);

    }

    if ((pContext->hwState.dwStateFlags & KELVIN_FLAG_LIGHTINGNEEDSINVMV) != dwInvMVNeeded) {
        pContext->hwState.dwStateFlags &= ~KELVIN_FLAG_LIGHTINGNEEDSINVMV;
        pContext->hwState.dwStateFlags |= dwInvMVNeeded;
        pContext->hwState.dwDirtyFlags |= dwInvMVNeeded ? KELVIN_DIRTY_TRANSFORM : 0;
    }

#ifdef KELVIN_ILC
    pContext->hwState.SuperTri.setNumLights(dwLightNum);
#endif

    // disable lights after setting them up (i.e minimum impact)
#ifdef NV_NULL_LIGHTS_DRIVER
    pContext->hwState.kelvin.set (NV097_SET_SPECULAR_ENABLE, DRF_NUM (097, _SET_SPECULAR_ENABLE, _V, FALSE));
    pContext->hwState.kelvin.set (NV097_SET_LIGHTING_ENABLE, NV097_SET_LIGHTING_ENABLE_V_FALSE);
#endif

    dbgFlushType (NVDBG_FLUSH_STATE);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

// set geometric transformation matrices

HRESULT nvSetKelvinTransform (PNVD3DCONTEXT pContext)
{
    D3DMATRIX        mMV0, mMVBlend, mCTM, mInvMV, mTemp;
    DWORD            dwClipH, dwClipV;
    float            fm11, fm22, fm33, fm41, fm42, fm43, fm44;
    float            fxTrans, fyTrans;
    SurfaceViewport  viewport;

    pContext->hwState.dwDirtyFlags &= ~KELVIN_DIRTY_TRANSFORM;

    viewport = pContext->surfaceViewport;

    if (pContext->kelvinAA.IsEnabled()) {
        viewport.clipHorizontal.wX      = (DWORD)(0.5f + viewport.clipHorizontal.wX     * pContext->aa.fWidthAmplifier);
        viewport.clipHorizontal.wWidth  = (DWORD)(0.5f + viewport.clipHorizontal.wWidth * pContext->aa.fWidthAmplifier);
        viewport.clipVertical.wY        = (DWORD)(0.5f + viewport.clipVertical.wY       * pContext->aa.fHeightAmplifier);
        viewport.clipVertical.wHeight   = (DWORD)(0.5f + viewport.clipVertical.wHeight  * pContext->aa.fHeightAmplifier);
    }

    if (pContext->pCurrentVShader->hasProgram()) {

        fxTrans = (float)(viewport.clipHorizontal.wX) + KELVIN_BORDER;
        fyTrans = (float)(viewport.clipVertical.wY) + KELVIN_BORDER;

        fm11 = 0.5f * (float)(viewport.clipHorizontal.wWidth);
        fm41 = fm11;

        fm22 = -0.5f * (float)(viewport.clipVertical.wHeight);
        fm42 = -fm22;

        fm33 = pContext->hwState.dvZScale * (pContext->surfaceViewport.dvMaxZ - pContext->surfaceViewport.dvMinZ);
        fm43 = pContext->hwState.dvZScale * pContext->surfaceViewport.dvMinZ;

        // these end up in privileged registers c[58] and c[59], from which they are read by the
        // viewport transformation code automatically tacked onto the end of every user program
        pContext->hwState.kelvin.set4f (NV097_SET_VIEWPORT_SCALE(0), fm11, fm22, fm33, 0.0f);
        pContext->hwState.kelvin.set4f (NV097_SET_VIEWPORT_OFFSET(0), fm41 + fxTrans, fm42 + fyTrans, fm43, 0.0f);

        // set depth clipping
        pContext->hwState.kelvin.set2f (NV097_SET_CLIP_MIN, 0.0f, pContext->hwState.dvZScale);

    }

    else if (pContext->hwState.dwStateFlags & KELVIN_FLAG_PASSTHROUGHMODE) {

        // calculate scales and biases for passthru mode

        D3DVECTOR4 vScale = {1.0f, 1.0f, 1.0f, 1.0f};
        D3DVECTOR4 vBias  = {KELVIN_BORDER, KELVIN_BORDER, 0.0f, 0.0f};

        if (getDC()->nvD3DRegistryData.regfZBias) {
            vScale.dvZ = pContext->hwState.dvZScale / (1.f + getDC()->nvD3DRegistryData.regfZBias);
            vBias.dvZ  = getDC()->nvD3DRegistryData.regfZBias * vScale.dvZ;
        }
        else {
            vScale.dvZ = pContext->hwState.dvZScale;
        }

        // Because NV20 uses a weird sampling pattern, we offset by approximately a pixel here, then clamp on
        // the right edge of the superbuffer.  This fixes apps that clip their non-T&L geometry
        // to the border of the *aliased* samples on screen (not the antialiased subsamples).
        if (pContext->kelvinAA.IsMultisampling()) {
            vBias.dvX += pContext->kelvinAA.GetXOffset();
            vBias.dvY += pContext->kelvinAA.GetYOffset();
        }

        if ( ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_SQUASHW_MASK) == D3D_REG_SQUASHW_ENABLE)
             &&
             ( ((pContext->hwState.dwTextureUnitStatus[0] == KELVIN_TEXUNITSTATUS_IDLE) &&
                (pContext->hwState.dwTextureUnitStatus[1] == KELVIN_TEXUNITSTATUS_IDLE))
               ||
               (pContext->dwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE] == FALSE)
             )
           )
        {
            vScale.dvW = 0.0f;
        }
        else  {
            vScale.dvW = (pContext->dwRenderState[D3DRENDERSTATE_ZENABLE] == D3DZB_USEW) ?
                         pContext->surfaceViewport.dvInvWFar * pContext->hwState.dvZScale :
                         1.0f;
        }

        vScale.dvX *= pContext->aa.fWidthAmplifier;
        vScale.dvY *= pContext->aa.fHeightAmplifier;

        // these end up in privileged registers c[58] and c[59], from which they are read by the passthru-mode programs
        pContext->hwState.kelvin.set4f (NV097_SET_VIEWPORT_SCALE(0), vScale.dvX, vScale.dvY, vScale.dvZ, vScale.dvW);
        pContext->hwState.kelvin.set4f (NV097_SET_VIEWPORT_OFFSET(0), vBias.dvX, vBias.dvY, vBias.dvZ, vBias.dvW);

        // set depth clipping
        // if we're w-buffering in passthru mode, do the best we can to disable the HW's inevitable
        // z clipping because dumb apps may give us bad z's thinking they're unneeded.
        // otherwise, just clip z to the real range of the z-buffer
        // BUGBUG we can explicitly ignore z on nv20. no need for this hack
        pContext->hwState.kelvin.set2f (NV097_SET_CLIP_MIN, 0.0f, (pContext->dwRenderState[D3DRENDERSTATE_ZENABLE] == D3DZB_USEW) ?
                                                                  KELVIN_Z_SCALE24 :
                                                                  pContext->hwState.dvZScale);

    }

    else {

        float fMinZ = pContext->surfaceViewport.dvMinZ;
        float fMaxZ = pContext->surfaceViewport.dvMaxZ;

        if (fMinZ == fMaxZ) {
            // the whole universe has been packed down to a single plane.
            // this is an LSB nightmare, so back it off a bit.
            fMinZ = max (0.0f, fMinZ-EPSILON);
            fMaxZ = min (1.0f, fMaxZ+EPSILON);
        }

        // disable CT
        if (pContext->pZetaBuffer) {
            pContext->pZetaBuffer->getWrapper()->tagCTZE();
            pContext->pZetaBuffer->getWrapper()->disableCT();
        }

        // process viewport dependencies
        fxTrans = (float)(viewport.clipHorizontal.wX) + KELVIN_BORDER;
        fyTrans = (float)(viewport.clipVertical.wY) + KELVIN_BORDER;

        pContext->hwState.kelvin.set4f (NV097_SET_VIEWPORT_OFFSET(0), fxTrans, fyTrans, 0.0f, 0.0f);

        // this is based on clipX = -1.0, clipY = 1.0
        fm11 = 0.5f * (float)(viewport.clipHorizontal.wWidth);
        fm41 = fm11;

        fm22 = -0.5f * (float)(viewport.clipVertical.wHeight);
        fm42 = -fm22;

        fm33 = pContext->hwState.dvZScale * (fMaxZ - fMinZ);
        fm43 = pContext->hwState.dvZScale * fMinZ;

        if (pContext->dwRenderState[D3DRENDERSTATE_ZENABLE] == D3DZB_USEW) {
            // we are doing w-buffering  - scale w to optimize use of buffer
            fm44 = pContext->hwState.dvZScale * pContext->surfaceViewport.dvInvWFar;
            // scale x, y, and z similarly to negate the effect of dividing through by a scaled w
            fm11 *= fm44;  fm22 *= fm44;  fm33 *= fm44;
            fm41 *= fm44;  fm42 *= fm44;  fm43 *= fm44;
        }
        else {
            fm44 = 1.0f;
        }

#ifdef NV_NULL_FILL_DRIVER
        fm11 = 0.0f;
        fm22 = 0.0f;
#endif

        mViewportMatrix._11 = fm11;
        mViewportMatrix._22 = fm22;
        mViewportMatrix._33 = fm33;
        mViewportMatrix._41 = fm41;
        mViewportMatrix._42 = fm42;
        mViewportMatrix._43 = fm43;
        mViewportMatrix._44 = fm44;

        // set the 3 Cheops matrices

        // Cheops modelview = D3D world * D3D view
        MatrixProduct4x4 (&mMV0, &(pContext->xfmWorld[0]), &(pContext->xfmView));

        pContext->hwState.kelvin.setMatrixTransposed (NV097_SET_MODEL_VIEW_MATRIX0(0), &mMV0);

#ifdef KELVIN_ILC
        pContext->hwState.SuperTri.setEye(&mMV0);
#endif
        // Normals are transformed by the transpose of the inverse of the model view matrix.
        // (see Graphics Gems I, p. 541).
        // We only invert the upper 3x3 in order to eliminate the effects of translations.
        // the transposition happens because unlike all other matrices, we DON'T un-transpose
        // this one when we send it to the HW. (this is the one matrix for which D3D's
        // backwardness is convenient)

        if (pContext->hwState.dwStateFlags & (KELVIN_FLAG_TEXSTATENEEDSINVMV | KELVIN_FLAG_LIGHTINGNEEDSINVMV)) {
            // there's no reason to waste time normalizing the inverse MV matrix if we're going to have to normalize
            // normals anyway. otherwise, they give us normalized stuff and we need to preserve the normalization
            Inverse4x4 (&mInvMV, &mMV0, (pContext->dwRenderState[D3DRENDERSTATE_NORMALIZENORMALS] == FALSE));
            pContext->hwState.kelvin.setInverseModelViewMatrix (NV097_SET_INVERSE_MODEL_VIEW_MATRIX0(0), &mInvMV);
        }

        if (GET_VERTEXBLEND_STATE(pContext) == FALSE) {
            // we're not skinning.
            // compute the composite matrix normally and skip the second set of modelview matrices.
            // cheops composite = D3D World*View*projection plus accomodations for the viewport
            MatrixProduct4x4 (&mTemp, &(pContext->xfmProj), &mViewportMatrix);
            MatrixProduct4x4 (&mCTM, &mMV0, &mTemp);
            pContext->hwState.kelvin.setMatrixTransposed (NV097_SET_COMPOSITE_MATRIX(0), &mCTM);

            // for supertri we need world*view*proj
            if (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_SUPERTRI) {
                MatrixProduct4x4 (&pContext->hwState.mTransform, &mMV0, &(pContext->xfmProj));
            }
        }

        else {
            // when skinning, the composite matrix does NOT include the modelview matrix.
            // cheops composite = projection plus accomodations for the viewport
            MatrixProduct4x4 (&mCTM, &(pContext->xfmProj), &mViewportMatrix);
            pContext->hwState.kelvin.setMatrixTransposed (NV097_SET_COMPOSITE_MATRIX(0), &mCTM);

            // we also need to compute and send down the second set of modelview matrices
            for (DWORD i=1; i<KELVIN_NUM_MATRICES; i++) {
                MatrixProduct4x4 (&mMVBlend, &(pContext->xfmWorld[i]), &(pContext->xfmView));
                pContext->hwState.kelvin.setMatrixTransposed (NV097_SET_MODEL_VIEW_MATRIX0(0) + 0x40*i, &mMVBlend);
                if (pContext->hwState.dwStateFlags & (KELVIN_FLAG_TEXSTATENEEDSINVMV | KELVIN_FLAG_LIGHTINGNEEDSINVMV)) {
                    Inverse4x4 (&mInvMV, &mMVBlend, (pContext->dwRenderState[D3DRENDERSTATE_NORMALIZENORMALS] == FALSE));
                    pContext->hwState.kelvin.setInverseModelViewMatrix (NV097_SET_INVERSE_MODEL_VIEW_MATRIX0(0) + 0x40*i, &mInvMV);
                }
            }
        }

        pContext->hwState.kelvin.set1 (NV097_SET_NORMALIZATION_ENABLE,
                                       DRF_NUM(097, _SET_NORMALIZATION_ENABLE, _V, pContext->dwRenderState[D3DRENDERSTATE_NORMALIZENORMALS]));

        // set depth clipping
        float fClipNear, fClipFar;
        if (pContext->dwRenderState[D3DRENDERSTATE_ZENABLE] == D3DZB_USEW) {
            fClipNear = pContext->hwState.dvZScale * pContext->surfaceViewport.dvWNear * pContext->surfaceViewport.dvInvWFar;
            fClipFar  = pContext->hwState.dvZScale;
        }
        else {
            fClipNear = pContext->hwState.dvZScale * fMinZ;
            fClipFar  = pContext->hwState.dvZScale * fMaxZ;
        }
        pContext->hwState.kelvin.set2f (NV097_SET_CLIP_MIN, fClipNear, fClipFar);

    }  // !FVF_TRANSFORMED

    // set window clipping
    // we subtract one from xmax (ymax) because the HW clips to xmin <= x <= xmax
    // ie. it's inclusive of both limits. note this makes it impossible to clip to nothing
    DWORD x,y,w,h;
    x = viewport.clipHorizontal.wX;
    w = viewport.clipHorizontal.wWidth;
    y = viewport.clipVertical.wY;
    h = viewport.clipVertical.wHeight;

    dwClipH = DRF_NUM (097, _SET_WINDOW_CLIP_HORIZONTAL, _XMIN, ((x - KELVIN_VIEWPORT_BOUND) & 0xfff))  |
              DRF_NUM (097, _SET_WINDOW_CLIP_HORIZONTAL, _XMAX, ((x + w - 1 - KELVIN_VIEWPORT_BOUND) & 0xfff));
    dwClipV = DRF_NUM (097, _SET_WINDOW_CLIP_VERTICAL, _YMIN, ((y - KELVIN_VIEWPORT_BOUND) & 0xfff))  |
              DRF_NUM (097, _SET_WINDOW_CLIP_VERTICAL, _YMAX, ((y + h - 1 - KELVIN_VIEWPORT_BOUND) & 0xfff));

    pContext->hwState.kelvin.set1 (NV097_SET_WINDOW_CLIP_HORIZONTAL(0), dwClipH);
    pContext->hwState.kelvin.set1 (NV097_SET_WINDOW_CLIP_VERTICAL(0),   dwClipV);

    dbgFlushType (NVDBG_FLUSH_STATE);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

// This handles the SetControl0 method:
//      premultiplied alpha
//      texture perspective
//      z perspective
//      z format
//      stencil write enable

HRESULT nvSetKelvinControl0 (PNVD3DCONTEXT pContext)
{
    DWORD dwControl0;

    pContext->hwState.dwDirtyFlags &= ~KELVIN_DIRTY_CONTROL0;

    dwControl0 = DRF_DEF (097, _SET_CONTROL0, _COLOR_SPACE_CONVERT, _PASS);

    // SRWNOTE: D3D has the possibility of having pre-multiplied alpha in 1
    // texture stage and not in another stage. How do we handle this?
    // hmm... actually this seems to be specified on a per surface basis
    // hedge on this for now
// BUGBUG
#if 0
    if (statev.premultipliedalpha)
        dwControl0 |= DRF_DEF (097, _SET_CONTROL0, _PREMULTIPLIEDALPHA, _TRUE);
    else
        dwControl0 |= DRF_DEF (097, _SET_CONTROL0, _PREMULTIPLIEDALPHA, _FALSE);
#endif

    // disabling texture perspective kills color perspective as well. since
    // the latter is assumed by D3D, we must always enable the former.
    dwControl0 |= DRF_DEF (097, _SET_CONTROL0, _TEXTUREPERSPECTIVE, _TRUE);

    // w or z buffering
    dwControl0 |= DRF_NUM (097, _SET_CONTROL0, _Z_PERSPECTIVE_ENABLE,
                           (pContext->dwRenderState[D3DRENDERSTATE_ZENABLE] == D3DZB_USEW) ? 1:0);

    // D3D has no provision for specification of zbuffer format
    // somewhat arbitrarily choose FIXED. alternately we could select it
    // to their advantage according to whether w-buffering is enabled (?)
    dwControl0 |= DRF_DEF (097, _SET_CONTROL0, _Z_FORMAT, _FIXED);


    dwControl0 |= DRF_NUM (097, _SET_CONTROL0, _STENCIL_WRITE_ENABLE,
                           pContext->dwRenderState[D3DRENDERSTATE_STENCILENABLE]);

    pContext->hwState.kelvin.set1 (NV097_SET_CONTROL0, dwControl0);

    dbgFlushType (NVDBG_FLUSH_STATE);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

// set everything else not covered by other kelvin state routines. this includes:
//      - depth testing
//      - stencil testing
//      - alpha testing
//      - alpha blending

HRESULT nvSetKelvinMiscState (PNVD3DCONTEXT pContext)
{
    DWORD dwHWStage, dwMask;
    DWORD dwSrcFactor, dwDstFactor;
    DWORD dwPointSize;
    DWORD dwZEnable;
    float fDepthBias, fDepthScale;
    float fAtten, fPP0, fPP1, fPP2, fPP3, fPP4, fPP5;  // point size variables
    float fSizeMin, fSizeMax, fSize, fHeight, fScale;

    pContext->hwState.dwDirtyFlags &= ~KELVIN_DIRTY_MISC_STATE;

    // z-buffering
    dwZEnable = pContext->pZetaBuffer ? pContext->dwRenderState[D3DRENDERSTATE_ZENABLE] : D3DZB_FALSE;
    if (dwZEnable) {
        pContext->hwState.kelvin.set1 (NV097_SET_DEPTH_TEST_ENABLE, NV097_SET_DEPTH_TEST_ENABLE_V_TRUE);
        pContext->hwState.kelvin.set1 (NV097_SET_DEPTH_MASK,        DRF_NUM (097, _SET_DEPTH_MASK, _V, pContext->dwRenderState[D3DRENDERSTATE_ZWRITEENABLE]));
        pContext->hwState.kelvin.set1 (NV097_SET_DEPTH_FUNC,        nv097DepthFunc[CTFunc(pContext,pContext->dwRenderState[D3DRENDERSTATE_ZFUNC])]);
    }
    else {
        pContext->hwState.kelvin.set1 (NV097_SET_DEPTH_TEST_ENABLE, NV097_SET_DEPTH_TEST_ENABLE_V_FALSE);
    }

    //if no zbuffer (that's true that enable is set to false...) and in passthrough mode, disable min/max z culling
    if ((dwZEnable == D3DZB_FALSE) && (pContext->hwState.dwStateFlags & KELVIN_FLAG_PASSTHROUGHMODE)) {
        pContext->hwState.kelvin.set1 (NV097_SET_ZMIN_MAX_CONTROL, (DRF_DEF (097, _SET_ZMIN_MAX_CONTROL, _CULL_NEAR_FAR_EN, _FALSE)
                                                                  | DRF_DEF (097, _SET_ZMIN_MAX_CONTROL, _ZCLAMP_EN, _CLAMP)
                                                                  | DRF_DEF (097, _SET_ZMIN_MAX_CONTROL, _CULL_IGNORE_W, _TRUE)));
    }
    else if (dwZEnable == D3DZB_USEW) {
        pContext->hwState.kelvin.set1 (NV097_SET_ZMIN_MAX_CONTROL, (DRF_DEF (097, _SET_ZMIN_MAX_CONTROL, _CULL_NEAR_FAR_EN, _FALSE)
                                                                  | DRF_DEF (097, _SET_ZMIN_MAX_CONTROL, _ZCLAMP_EN, _CULL)
                                                                  | DRF_DEF (097, _SET_ZMIN_MAX_CONTROL, _CULL_IGNORE_W, _FALSE)));
    }
    else {
        // if z-buffering and/or not passthrough
        pContext->hwState.kelvin.set1 (NV097_SET_ZMIN_MAX_CONTROL, (DRF_DEF (097, _SET_ZMIN_MAX_CONTROL, _CULL_NEAR_FAR_EN, _TRUE)
                                                                  | DRF_DEF (097, _SET_ZMIN_MAX_CONTROL, _ZCLAMP_EN, _CULL)
                                                                  | DRF_DEF (097, _SET_ZMIN_MAX_CONTROL, _CULL_IGNORE_W, _FALSE)));
    }

    // fill mode
    switch (pContext->dwRenderState[D3DRENDERSTATE_FILLMODE]) {
        case D3DFILL_POINT:
            pContext->hwState.kelvin.set2 (NV097_SET_FRONT_POLYGON_MODE,
                                           NV097_SET_FRONT_POLYGON_MODE_V_POINT,
                                           NV097_SET_BACK_POLYGON_MODE_V_POINT);
            break;
        case D3DFILL_WIREFRAME:
            pContext->hwState.kelvin.set2 (NV097_SET_FRONT_POLYGON_MODE,
                                           NV097_SET_FRONT_POLYGON_MODE_V_LINE,
                                           NV097_SET_BACK_POLYGON_MODE_V_LINE);
            break;
        case D3DFILL_SOLID:
            pContext->hwState.kelvin.set2 (NV097_SET_FRONT_POLYGON_MODE,
                                           NV097_SET_FRONT_POLYGON_MODE_V_FILL,
                                           NV097_SET_BACK_POLYGON_MODE_V_FILL);
            break;
        default:
            DPF ("unknown FILLMODE");
            dbgD3DError();
            break;
    }

    // shading
    pContext->hwState.kelvin.set1 (NV097_SET_SHADE_MODE, (pContext->dwRenderState[D3DRENDERSTATE_SHADEMODE] == D3DSHADE_FLAT)
                                                         ? NV097_SET_SHADE_MODE_V_FLAT
                                                         : NV097_SET_SHADE_MODE_V_SMOOTH);

    // color write enable
    DWORD dwPlaneMask = pContext->dwRenderState[D3DRS_COLORWRITEENABLE];
    if (dwPlaneMask == (D3DCOLORWRITEENABLE_ALPHA |
                        D3DCOLORWRITEENABLE_RED   |
                        D3DCOLORWRITEENABLE_GREEN |
                        D3DCOLORWRITEENABLE_BLUE)) {
        // the common case
        dwMask = 0x01010101;
    }
    else {
        dwMask = 0;
        if (dwPlaneMask & D3DCOLORWRITEENABLE_ALPHA) dwMask |= (0x1 << 24);
        if (dwPlaneMask & D3DCOLORWRITEENABLE_RED)   dwMask |= (0x1 << 16);
        if (dwPlaneMask & D3DCOLORWRITEENABLE_GREEN) dwMask |= (0x1 << 8);
        if (dwPlaneMask & D3DCOLORWRITEENABLE_BLUE)  dwMask |= (0x1 << 0);
    }

    pContext->hwState.kelvin.set1 (NV097_SET_COLOR_MASK, dwMask);

    // alpha blending
    if (pContext->dwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE]) {
        pContext->hwState.kelvin.set1 (NV097_SET_BLEND_ENABLE, NV097_SET_BLEND_ENABLE_V_TRUE);
        dwSrcFactor = nv097BlendFunc[pContext->dwRenderState[D3DRENDERSTATE_SRCBLEND]];
        dwDstFactor = nv097BlendFunc[pContext->dwRenderState[D3DRENDERSTATE_DESTBLEND]];
        // for these two cases, we need to go back and override dwDstFactor
        switch (pContext->dwRenderState[D3DRENDERSTATE_SRCBLEND]) {
            case D3DBLEND_BOTHSRCALPHA:    // obsolete, but we'll do it for Dx5 and prior
                dwDstFactor = NV097_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_SRC_ALPHA;
                break;
            case D3DBLEND_BOTHINVSRCALPHA: // likewise
                dwDstFactor = NV097_SET_BLEND_FUNC_DFACTOR_V_SRC_ALPHA;
                break;
            default:
                // nada
                break;
        }
        pContext->hwState.kelvin.set2 (NV097_SET_BLEND_FUNC_SFACTOR, dwSrcFactor, dwDstFactor);
        pContext->hwState.kelvin.set1 (NV097_SET_BLEND_EQUATION,
                                       (pContext->dwDXAppVersion >= 0x0800) ?
                                       nv097BlendOp[pContext->dwRenderState[D3DRS_BLENDOP]] :
                                       DRF_DEF (097, _SET_BLEND_EQUATION, _V, _FUNC_ADD));
    }
    else {
        pContext->hwState.kelvin.set1 (NV097_SET_BLEND_ENABLE, NV097_SET_BLEND_ENABLE_V_FALSE);
    }

    //anti aliased edges
    if (getDC()->nvD3DPerfData.dwHaveAALines){
        if (pContext->dwRenderState[D3DRENDERSTATE_EDGEANTIALIAS]){
            pContext->hwState.kelvin.set1(NV097_SET_LINE_SMOOTH_ENABLE, NV097_SET_LINE_SMOOTH_ENABLE_V_TRUE);
        }
        else {
            pContext->hwState.kelvin.set1(NV097_SET_LINE_SMOOTH_ENABLE, NV097_SET_LINE_SMOOTH_ENABLE_V_FALSE);
        }
    }

    // culling
    switch (pContext->dwRenderState[D3DRENDERSTATE_CULLMODE]) {
        case D3DCULL_CW:
            pContext->hwState.kelvin.set1 (NV097_SET_CULL_FACE_ENABLE, NV097_SET_CULL_FACE_ENABLE_V_TRUE);
            pContext->hwState.kelvin.set1 (NV097_SET_FRONT_FACE,       NV097_SET_FRONT_FACE_V_CCW);
            break;
        case D3DCULL_CCW:
            pContext->hwState.kelvin.set1 (NV097_SET_CULL_FACE_ENABLE, NV097_SET_CULL_FACE_ENABLE_V_TRUE);
            pContext->hwState.kelvin.set1 (NV097_SET_FRONT_FACE,       NV097_SET_FRONT_FACE_V_CW);
            break;
        default:
            DPF ("unknown cull mode");
        case D3DCULL_NONE:
            pContext->hwState.kelvin.set1 (NV097_SET_CULL_FACE_ENABLE, NV097_SET_CULL_FACE_ENABLE_V_FALSE);
            break;
    }

    // alpha test
    if (pContext->dwRenderState[D3DRENDERSTATE_ALPHATESTENABLE]) {
        pContext->hwState.kelvin.set1 (NV097_SET_ALPHA_TEST_ENABLE, NV097_SET_ALPHA_TEST_ENABLE_V_TRUE);
        pContext->hwState.kelvin.set1 (NV097_SET_ALPHA_REF,         pContext->dwRenderState[D3DRENDERSTATE_ALPHAREF]);
        pContext->hwState.kelvin.set1 (NV097_SET_ALPHA_FUNC,        nv097AlphaFunc[pContext->dwRenderState[D3DRENDERSTATE_ALPHAFUNC]]);
    }
    else {
        pContext->hwState.kelvin.set1 (NV097_SET_ALPHA_TEST_ENABLE, NV097_SET_ALPHA_TEST_ENABLE_V_FALSE);
    }
#ifdef ALPHA_CULL
    // alpha test
#if ALPHA_CULL ==0
    pContext->alphacull_mode = 0;
    if (!pContext->dwRenderState[D3DRENDERSTATE_ALPHATESTENABLE] && pContext->dwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE] &&
        !pContext->dwRenderState[D3DRENDERSTATE_ZWRITEENABLE] && !pContext->dwRenderState[D3DRENDERSTATE_STENCILENABLE] &&
    pContext->dwEarlyCopyStrategy
       )
    {
#else
    pContext->hwState.alphacull_mode = 0;
    if (!pContext->dwRenderState[D3DRENDERSTATE_ALPHATESTENABLE] && pContext->dwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE] &&
        /*!pContext->dwRenderState[D3DRENDERSTATE_ZWRITEENABLE] &&*/ !pContext->dwRenderState[D3DRENDERSTATE_STENCILENABLE]  &&
    pContext->dwEarlyCopyStrategy
       )
#endif
    {
        pContext->hwState.alphacull_mode = 1;
        if(pContext->dwRenderState[D3DRENDERSTATE_SRCBLEND] == D3DBLEND_SRCALPHA &&
           pContext->dwRenderState[D3DRENDERSTATE_DESTBLEND] == D3DBLEND_INVSRCALPHA){
                pContext->hwState.kelvin.set1 (NV097_SET_ALPHA_TEST_ENABLE, NV097_SET_ALPHA_TEST_ENABLE_V_TRUE);
                pContext->hwState.kelvin.set1 (NV097_SET_ALPHA_REF, 0x8);
                pContext->hwState.kelvin.set1 (NV097_SET_ALPHA_FUNC, NV097_SET_ALPHA_FUNC_V_GREATER);
        }
#if ALPHA_CULL >= 2
        /*else if(pContext->dwRenderState[D3DRENDERSTATE_SRCBLEND] == D3DBLEND_ZERO &&
           pContext->dwRenderState[D3DRENDERSTATE_DESTBLEND] == D3DBLEND_SRCCOLOR &&
           pContext->hwState.dwAlphaICW[0] == 0x18200000 && pContext->hwState.dwAlphaOCW[0] == 0xc00 &&
           pContext->hwState.dwColorICW[0] == 0x08040000 && pContext->hwState.dwColorOCW[0] == 0xc00)
        {
            pContext->hwState.celsius.alphacull_mode = 2;
            pContext->hwState.celsius.set (NV056_SET_COMBINER_COLOR_ICW(0), 0x08042820);
            pContext->hwState.celsius.set (NV056_SET_COMBINER0_COLOR_OCW,   0x000010CD);
            pContext->hwState.celsius.set (NV056_SET_COMBINER_ALPHA_ICW(0), 0x18200000);
            pContext->hwState.celsius.set (NV056_SET_COMBINER_ALPHA_OCW(0), 0x00000C00);
            pContext->hwState.celsius.set (NV056_SET_COMBINER_SPECULAR_FOG_CW0, pContext->hwState.specfog_cw[0]);
            pContext->hwState.celsius.set (NV056_SET_COMBINER_SPECULAR_FOG_CW1, 0x0D00 | (pContext->hwState.specfog_cw[1] & ~0x1f00));
            pContext->hwState.celsius.set (NV056_SET_ALPHA_TEST_ENABLE, NV056_SET_ALPHA_TEST_ENABLE_V_TRUE);
            pContext->hwState.celsius.set (NV056_SET_ALPHA_REF, 0x8);
            pContext->hwState.celsius.set (NV056_SET_ALPHA_FUNC, NV056_SET_ALPHA_FUNC_V_GREATER);
        }*/
#endif
#if ALPHA_CULL >= 3
        else if(pContext->dwRenderState[D3DRENDERSTATE_SRCBLEND] == D3DBLEND_ONE &&
           pContext->dwRenderState[D3DRENDERSTATE_DESTBLEND] == D3DBLEND_ONE &&
           pContext->hwState.dwColorICW[0] == 0x08040000 && pContext->hwState.dwColorOCW[0] == 0xc00 &&
           pContext->hwState.dwAlphaICW[0] == 0x18200000 && pContext->hwState.dwAlphaOCW[0] == 0xc00 &&
           pContext->dwEarlyCopyStrategy == 3)
        {
            pContext->hwState.alphacull_mode = 3;
            pContext->hwState.kelvin.set1 (NV097_SET_COMBINER_COLOR_ICW(0), 0x08040820);
            pContext->hwState.kelvin.set1 (NV097_SET_COMBINER_COLOR_OCW(0),   0x000010CD);
            pContext->hwState.kelvin.set1 (NV097_SET_COMBINER_ALPHA_ICW(0), 0x18200000);
            pContext->hwState.kelvin.set1 (NV097_SET_COMBINER_ALPHA_OCW(0), 0x00000C00);
            pContext->hwState.kelvin.set1 (NV097_SET_COMBINER_SPECULAR_FOG_CW0, pContext->hwState.specfog_cw[0]);
            pContext->hwState.kelvin.set1 (NV097_SET_COMBINER_SPECULAR_FOG_CW1, 0x0D00 | (pContext->hwState.specfog_cw[1] & ~0x1f00));
            pContext->hwState.kelvin.set1 (NV097_SET_ALPHA_TEST_ENABLE, NV097_SET_ALPHA_TEST_ENABLE_V_TRUE);
            pContext->hwState.kelvin.set1 (NV097_SET_ALPHA_REF, 0x8);
            pContext->hwState.kelvin.set1 (NV097_SET_ALPHA_FUNC, NV097_SET_ALPHA_FUNC_V_GREATER);
        }
#endif
        else if(pContext->dwRenderState[D3DRENDERSTATE_SRCBLEND] == D3DBLEND_INVSRCALPHA &&
                pContext->dwRenderState[D3DRENDERSTATE_DESTBLEND] == D3DBLEND_SRCALPHA){
                pContext->hwState.kelvin.set1 (NV097_SET_ALPHA_TEST_ENABLE, NV097_SET_ALPHA_TEST_ENABLE_V_TRUE);
                pContext->hwState.kelvin.set1 (NV097_SET_ALPHA_REF, 0xf4);
                pContext->hwState.kelvin.set1 (NV097_SET_ALPHA_FUNC, NV097_SET_ALPHA_FUNC_V_LESS);
        }
        else if(pContext->dwRenderState[D3DRENDERSTATE_SRCBLEND] == D3DBLEND_ZERO){
            if(pContext->dwRenderState[D3DRENDERSTATE_DESTBLEND] == D3DBLEND_SRCALPHA){
                pContext->hwState.kelvin.set1 (NV097_SET_ALPHA_TEST_ENABLE, NV097_SET_ALPHA_TEST_ENABLE_V_TRUE);
                pContext->hwState.kelvin.set1 (NV097_SET_ALPHA_REF, 0xf4);
                pContext->hwState.kelvin.set1 (NV097_SET_ALPHA_FUNC, NV097_SET_ALPHA_FUNC_V_LESS);
            }
            else if(pContext->dwRenderState[D3DRENDERSTATE_DESTBLEND] == D3DBLEND_INVSRCALPHA){
                pContext->hwState.kelvin.set1 (NV097_SET_ALPHA_TEST_ENABLE, NV097_SET_ALPHA_TEST_ENABLE_V_TRUE);
                pContext->hwState.kelvin.set1 (NV097_SET_ALPHA_REF, 0x8);
                pContext->hwState.kelvin.set1 (NV097_SET_ALPHA_FUNC, NV097_SET_ALPHA_FUNC_V_GREATER);
            }
        }
    }
#endif

    // dithering
    pContext->hwState.kelvin.set1 (NV097_SET_DITHER_ENABLE,
                                DRF_NUM (097, _SET_DITHER_ENABLE, _V, pContext->dwRenderState[D3DRENDERSTATE_DITHERENABLE]));

    // Multisample mask
    pContext->kelvinAA.SetSampleMask();

    // depth bias
    if ((dwZEnable) &&
        (pContext->dwRenderState[D3DRENDERSTATE_ZBIAS])) {
        // the bias is applied to depth values in device coordinates
        // (i.e in the range [0..2^16-1] or [0..2^24-1])
        pContext->hwState.kelvin.set3 (NV097_SET_POLY_OFFSET_POINT_ENABLE,
                                    NV097_SET_POLY_OFFSET_POINT_ENABLE_V_TRUE,
                                    NV097_SET_POLY_OFFSET_LINE_ENABLE_V_TRUE,
                                    NV097_SET_POLY_OFFSET_FILL_ENABLE_V_TRUE);
        fDepthBias  = -(float)(pContext->dwRenderState[D3DRENDERSTATE_ZBIAS]);
        fDepthScale = 0.25f * fDepthBias;
        pContext->hwState.kelvin.set2f (NV097_SET_POLYGON_OFFSET_SCALE_FACTOR, fDepthScale, fDepthBias);
    }
    else {
        // renderstate_zbias==0 and/or zenable==D3DZB_FALSE
        pContext->hwState.kelvin.set3 (NV097_SET_POLY_OFFSET_POINT_ENABLE,
                                       NV097_SET_POLY_OFFSET_POINT_ENABLE_V_FALSE,
                                       NV097_SET_POLY_OFFSET_LINE_ENABLE_V_FALSE,
                                       NV097_SET_POLY_OFFSET_FILL_ENABLE_V_FALSE);
    }

    // stencil
    if (pContext->dwRenderState[D3DRENDERSTATE_STENCILENABLE]) {
        pContext->bStencilEnabled = TRUE;
        pContext->hwState.kelvin.set1 (NV097_SET_STENCIL_TEST_ENABLE, NV097_SET_STENCIL_TEST_ENABLE_V_TRUE);
        pContext->hwState.kelvin.set7 (NV097_SET_STENCIL_MASK,
                                       pContext->dwRenderState[D3DRENDERSTATE_STENCILWRITEMASK] & 0xff,
                                       nv097StencilFunc[pContext->dwRenderState[D3DRENDERSTATE_STENCILFUNC]],
                                       pContext->dwRenderState[D3DRENDERSTATE_STENCILREF]       & 0xff,
                                       pContext->dwRenderState[D3DRENDERSTATE_STENCILMASK]      & 0xff,
                                       nv097StencilOp[pContext->dwRenderState[D3DRENDERSTATE_STENCILFAIL]],
                                       nv097StencilOp[pContext->dwRenderState[D3DRENDERSTATE_STENCILZFAIL]],
                                       nv097StencilOp[pContext->dwRenderState[D3DRENDERSTATE_STENCILPASS]]);
    }
    else {
        pContext->hwState.kelvin.set1 (NV097_SET_STENCIL_TEST_ENABLE, NV097_SET_STENCIL_TEST_ENABLE_V_FALSE);
    }

    // combiner factor
    if (!pContext->pCurrentPShader) {
        for (dwHWStage=0; dwHWStage<KELVIN_NUM_COMBINERS; dwHWStage++) {
            pContext->hwState.kelvin.set1 (NV097_SET_COMBINER_FACTOR0(dwHWStage), pContext->dwRenderState[D3DRENDERSTATE_TEXTUREFACTOR]);
            pContext->hwState.kelvin.set1 (NV097_SET_COMBINER_FACTOR1(dwHWStage), pContext->dwRenderState[D3DRENDERSTATE_TEXTUREFACTOR]);
        }
    }

    // skinning
    switch (GET_VERTEXBLEND_STATE(pContext)) {
        case D3DVBF_DISABLE:
            pContext->hwState.kelvin.set1 (NV097_SET_SKIN_MODE, NV097_SET_SKIN_MODE_V_OFF);
            break;
        case D3DVBF_1WEIGHTS:
            pContext->hwState.kelvin.set1 (NV097_SET_SKIN_MODE, NV097_SET_SKIN_MODE_V_2G);
            break;
        case D3DVBF_2WEIGHTS:
            pContext->hwState.kelvin.set1 (NV097_SET_SKIN_MODE, NV097_SET_SKIN_MODE_V_3G);
            break;
        case D3DVBF_3WEIGHTS:
            pContext->hwState.kelvin.set1 (NV097_SET_SKIN_MODE, NV097_SET_SKIN_MODE_V_4G);
            break;
        default:
            DPF ("illegal vertex blend mode");
            dbgD3DError();
            break;
    }  // switch

    // point params
    if (pContext->dwDXAppVersion >= 0x800) {

        // setting POINT_PARAMS_ENABLE to true tells the HW that a screen-space point size is being
        // calculated or needs to be calculated per vertex. in fixed-pipe mode, the HW will perform
        // the calculation itself, as a function of POINT_SIZE and POINT_PARAMS. in program mode, the
        // calculation is handled by some other entity (vertex shader / SW T&L) but POINT_PARAMS_ENABLE
        // is still set true so that the HW knows to fetch the pre-calculated point size from oPts.x.
        // when POINT_PARAMS_ENABLE is false, the HW simple takes the static value from POINT_SIZE
        // and performs no additional calculations.

        DWORD dwMode = pContext->pCurrentVShader->hasProgram() ?
                           1 :
                           ((pContext->hwState.dwStateFlags & KELVIN_FLAG_PASSTHROUGHMODE) ?
                               2 :
                               3);

        BOOL bHavePSize = pContext->pCurrentVShader->bVAExists (defaultInputRegMap[D3DVSDE_PSIZE]);
        BOOL bPScaleEn  = pContext->dwRenderState[D3DRS_POINTSCALEENABLE];

        // check for incompatibility with broken HW
        if ((dwMode == 3) && (bHavePSize)) {
            DPF ("uh oh. app wants to provide a point size per vertex in fixed-pipe mode.");
            dbgD3DError();
            pContext->hwState.dwStateFlags |= KELVIN_FLAG_SETUPFAILURE;
        }

        // enable point params if...
        BOOL bPPEnable = (dwMode == 1)                  ||  // ...we have a vertex shader
                         ((dwMode == 2) && bHavePSize)  ||  // ...we're in passthrough mode and have a per-vertex point size
                         ((dwMode == 3) && bPScaleEn);      // ...we're in fixed-pipe mode and D3DRS_POINTSCALEENABLE is true

        pContext->hwState.kelvin.set2 (NV097_SET_POINT_PARAMS_ENABLE,
                                       bPPEnable ?
                                       NV097_SET_POINT_PARAMS_ENABLE_V_TRUE :
                                       NV097_SET_POINT_PARAMS_ENABLE_V_FALSE,
                                       pContext->dwRenderState[D3DRS_POINTSPRITEENABLE] ?
                                       NV097_SET_POINT_SMOOTH_ENABLE_V_TRUE :
                                       NV097_SET_POINT_SMOOTH_ENABLE_V_FALSE);

        // we need to set POINT_SIZE if...
        if (((dwMode == 2) && (!bHavePSize)) ||  // ...we're in passthrough mode without a per-vertex point size
            (dwMode == 3))                       // ...we're in fixed-pipe mode
        {
            fSizeMin = FLOAT_FROM_DWORD (pContext->dwRenderState[D3DRS_POINTSIZE_MIN]);
            fSizeMax = FLOAT_FROM_DWORD (pContext->dwRenderState[D3DRS_POINTSIZE_MAX]);
            fSize    = FLOAT_FROM_DWORD (pContext->dwRenderState[D3DRS_POINTSIZE]);

            // workaround for NV20 bug where point sprites < 0.125 get bumped to 1.0
            if ((pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) == NVCLASS_0097_KELVIN) {
                // clamp POINTSIZE_MIN to >= 0.125
                fSizeMin = max (fSizeMin, 0.125f);
            }

            fScale   = max (fSize, 0.0001f);

            fSize    = max (fSize, fSizeMin);
            fSize    = min (fSize, fSizeMax);

            if ((pContext->surfaceViewport.clipVertical.wHeight) && (pContext->dwRenderState[D3DRS_POINTSCALEENABLE])) {
                fHeight = (float)(pContext->surfaceViewport.clipVertical.wHeight);
                // have to do this loop if we want to move height into the attenuation
                // factors because valid point sprite sizes < 0.125 will be expressed
                // as zeros if we don't do something  HMH
                while ((fSize < 32.0f) && (fHeight > 2.0f)) {
                    fSize   *= 2.0f;
                    fScale  *= 2.0f;
                    fHeight *= 0.5f;
                }
            }

            dwPointSize = ((DWORD)(fSize * 8.0f)) & 0x1ff;  // convert to 6.3

            pContext->hwState.kelvin.set1 (NV097_SET_POINT_SIZE, dwPointSize);

            // finally, we must also set POINT_PARAMS if we're in fixed pipe mode with POINTSCALEENABLE set true
            if ((dwMode == 3) && bPScaleEn) {

                fPP3 = fSizeMax - fSizeMin;
                fPP4 = fPP3 ? (-fSizeMin / fPP3) : 0.0f;
                fPP5 = fSizeMin;

                fAtten  = fPP3 / (fScale * fHeight);
                fAtten *= fAtten;

                fPP0 = fAtten * FLOAT_FROM_DWORD (pContext->dwRenderState[D3DRS_POINTSCALE_A]);
                fPP1 = fAtten * FLOAT_FROM_DWORD (pContext->dwRenderState[D3DRS_POINTSCALE_B]);
                fPP2 = fAtten * FLOAT_FROM_DWORD (pContext->dwRenderState[D3DRS_POINTSCALE_C]);

                pContext->hwState.kelvin.set8f (NV097_SET_POINT_PARAMS(0), fPP0,fPP1,fPP2,fPP3,fPP3,fPP3,fPP4,fPP5);

            }
        }
    }

    dbgFlushType (NVDBG_FLUSH_STATE);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

__inline DWORD nvKelvinVertexFormat
(
    CVertexShader  *pShader,
    CVertexBuffer **ppStreams,
    DWORD           dwReg,
    BOOL            bInlineVertices,
    DWORD           dwInlineStride
)
{
    DWORD dwFormat, dwStreamSelector, dwType;

    dwStreamSelector = pShader->getVAStream (dwReg);

    if ((dwStreamSelector == CVertexShader::VA_STREAM_NONE) || (ppStreams[dwStreamSelector] == NULL)) {
        dwFormat = DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _DISABLED) |
                   DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F);
    }
    else {
        dwType   = pShader->getVAType (dwReg);
        dwFormat = (DRF_NUM (097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, kelvinVertexSize[dwType]) |
                    DRF_NUM (097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, kelvinVertexType[dwType]) |
                    DRF_NUM (097, _SET_VERTEX_DATA_ARRAY_FORMAT, _STRIDE, bInlineVertices ?
                                                                          dwInlineStride  :
                                                                          ppStreams[dwStreamSelector]->getVertexStride()));
        if (dwType == D3DVSDT_UBYTE4) {
            DPF ("app is using unsupported D3DVSDT_UBYTE4 despite D3DVTXPCAPS_NO_VSDT_UBYTE4");
            nvAssert(0);
        }
    }

    return (dwFormat);
}

//---------------------------------------------------------------------------

__inline DWORD nvKelvinVertexOffset
(
    CVertexShader  *pShader,
    CVertexBuffer **ppStreams,
    DWORD           dwReg,
    DWORD           dwBaseVertexOffset
)
{
    DWORD dwOffset;
    DWORD dwStreamSelector;
    DWORD dwOffsetAdjustment;
    DWORD dwDMAMask, dwVBOffset;

    dwStreamSelector = pShader->getVAStream (dwReg);

    if ((dwStreamSelector == CVertexShader::VA_STREAM_NONE) || (ppStreams[dwStreamSelector] == NULL)) {

        dwOffset = DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_OFFSET, _CONTEXT_DMA, _VERTEX_A) |
                   DRF_NUM (097, _SET_VERTEX_DATA_ARRAY_OFFSET, _OFFSET, 0);

    }

    else {

        // program the context dma and calculate a kelvin-specific offset adjustment:
        // kelvin wants an offset relative to a page aligned context dma, something
        // we do not know we have using the built in getOffset() methods.
        switch (ppStreams[dwStreamSelector]->getContextDMA()) {
            case NV_CONTEXT_DMA_AGP_OR_PCI:
                dwDMAMask = DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_OFFSET, _CONTEXT_DMA, _VERTEX_A);
                // compensate for ctx dma that is possibly not 4k aligned
                dwOffsetAdjustment = (ppStreams[dwStreamSelector]->getHeapLocation() == CSimpleSurface::HEAP_AGP) ?
                                     (pDriverData->GARTLinearBase & 0xfff) :      // AGP
                                     (getDC()->nvD3DTexHeapData.dwBase & 0xfff);  // PCI
                break;
            case NV_CONTEXT_DMA_VID:
                dwDMAMask = DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_OFFSET, _CONTEXT_DMA, _VERTEX_B);
                // NOTE - this is highly unlikely to not be 4k aligned...
                nvAssert ((pDriverData->BaseAddress & 0xfff) == 0);
                dwOffsetAdjustment = 0;
                break;
            default:
                DPF ("unknown context DMA");
                dbgD3DError();
                break;
        }  // switch

        dwVBOffset = ppStreams[dwStreamSelector]->getOffset() +
                     dwBaseVertexOffset +
                     pShader->getVAOffset (dwReg) +
                     dwOffsetAdjustment;

        dwOffset = dwDMAMask | DRF_NUM (097, _SET_VERTEX_DATA_ARRAY_OFFSET, _OFFSET, dwVBOffset);

    }

    return (dwOffset);
}

//---------------------------------------------------------------------------

// tell the hardware where to find vertex coordinates, normals, etc...
// the order of these is important!

HRESULT nvSetKelvinVertexFormat (PNVD3DCONTEXT pContext)
{
    DWORD  dwFormat[16], dwOffset[16];
    DWORD  dwHWStage, dwD3DStage, dwTCIndex, dwVAIndex;
    DWORD  dwInlineStride;
    BOOL   bInlineVertices;

    pContext->hwState.dwDirtyFlags &= ~KELVIN_DIRTY_FVF;

    CVertexShader  *pShader   = pContext->pCurrentVShader;
    CVertexBuffer **ppStreams = pContext->ppDX8Streams;

    // shadow the values so we know what we last sent to the HW
    pContext->hwState.dwVertexOffset = pContext->dp2.dwVertexBufferOffset;
    pContext->hwState.pVertexShader  = pContext->pCurrentVShader;
    nvMemCopy (pContext->hwState.ppStreams, pContext->ppDX8Streams, KELVIN_CAPS_MAX_STREAMS*sizeof(CVertexBuffer *));

#ifdef STOMP_TEX_COORDS
    pContext->hwState.dwStateFlags &= ~KELVIN_FLAG_STOMP_4TH_COORD_MASK;

    if (!pShader->hasProgram()) {
        for (dwHWStage=0; dwHWStage < KELVIN_NUM_TEXTURES; dwHWStage++) {
            if (pContext->hwState.dwStateFlags & KELVIN_FLAG_USERTEXCOORDSNEEDED(dwHWStage)) {
                dwTCIndex  = (pContext->hwState.dwTexCoordIndices >> (8*dwHWStage)) & 0xff;
                if ((pShader->getVASize(defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex]) == 16) &&
                    (KELVIN_GET_NUM_TEX_COORDS(pContext->hwState.dwNumTexCoordsNeeded, dwHWStage) < 4)) {
                    pContext->hwState.dwStateFlags |= KELVIN_FLAG_STOMP_4TH_COORD(dwHWStage);
                }
            }
        }
    }

    // This should only happen in WHQL.  If it's happening elsewhere, either the app
    // is really stupid, or we're doing something wrong.
    nvAssert(!(pContext->hwState.dwStateFlags & KELVIN_FLAG_STOMP_4TH_COORD_MASK));
#endif  // STOMP_TEX_COORDS

    // figure out if we can dma this vertex data
#ifdef FORCE_INLINE_VERTICES
    bInlineVertices = TRUE;
#else
#ifdef STOMP_TEX_COORDS
    bInlineVertices = ((NV_NUM_UNIQUE_STREAMS(pContext->dwStreamDMACount) > 2) ||
                       (NV_NUM_SYSTEM_STREAMS(pContext->dwStreamDMACount) > 0) ||
                       (pContext->hwState.dwStateFlags & KELVIN_FLAG_STOMP_4TH_COORD_MASK));
#else  // !STOMP_TEX_COORDS
    bInlineVertices = ((NV_NUM_UNIQUE_STREAMS(pContext->dwStreamDMACount) > 2) ||
                       (NV_NUM_SYSTEM_STREAMS(pContext->dwStreamDMACount) > 0));
#endif  // !STOMP_TEX_COORDS
#endif

    if (bInlineVertices) {
        dwInlineStride = pShader->hasProgram() ?
                         pContext->pCurrentVShader->getStride() :
                         nvKelvinInlineVertexStride (pContext);
        nvAssert ( !(dwInlineStride == 4 && !pShader->hasProgram()) );
    }
    else {
        dwInlineStride = 0;
    }
    // set context inline stride
    pContext->hwState.dwInlineVertexStride = dwInlineStride; //don't want to lose the actual stride
    //workaround for kelvin bug
    if (dwInlineStride == 4) dwInlineStride = 8; //fake out vertex setup for HW failure case

    // formats --------------------------------------------------------------

    if (pShader->hasProgram()) {

        for (DWORD dwReg = 0; dwReg < 16; dwReg++) {
            dwFormat[dwReg] = nvKelvinVertexFormat (pShader, ppStreams, dwReg, bInlineVertices, dwInlineStride);
        }
    }

    else {

        // x, y, z, [w]
        dwFormat[0] = nvKelvinVertexFormat (pShader, ppStreams, defaultInputRegMap[D3DVSDE_POSITION], bInlineVertices, dwInlineStride);

        // weights (for skinning)
        dwFormat[1] = nvKelvinVertexFormat (pShader, ppStreams, defaultInputRegMap[D3DVSDE_BLENDWEIGHT], bInlineVertices, dwInlineStride);

        // normal
        dwFormat[2] = nvKelvinVertexFormat (pShader, ppStreams, defaultInputRegMap[D3DVSDE_NORMAL], bInlineVertices, dwInlineStride);

        // diffuse
        dwFormat[3] = nvKelvinVertexFormat (pShader, ppStreams, defaultInputRegMap[D3DVSDE_DIFFUSE], bInlineVertices, dwInlineStride);
        if (dwFormat[3] == (DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _DISABLED) |
                            DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F))) {
            // no vertex diffuse. default to white
            pContext->hwState.kelvin.set1 (NV097_SET_DIFFUSE_COLOR4UB, 0xFFFFFFFF);
        }

        // specular
        dwFormat[4] = nvKelvinVertexFormat (pShader, ppStreams, defaultInputRegMap[D3DVSDE_SPECULAR], bInlineVertices, dwInlineStride);
        if (dwFormat[4] == (DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _DISABLED) |
                            DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F))) {
            // no vertex specular. default to black
            pContext->hwState.kelvin.set1 (NV097_SET_SPECULAR_COLOR4UB, 0);
        }

        // fog distance (never exists in d3d)
        dwFormat[5] = DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _DISABLED) |
                      DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F);

        // point size
        dwFormat[6] = nvKelvinVertexFormat (pShader, ppStreams, defaultInputRegMap[D3DVSDE_PSIZE], bInlineVertices, dwInlineStride);

        // back diffuse (DX8 was going to have this, but axed it)
        dwFormat[7] = DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _DISABLED) |
                      DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F);

        // back specular (DX8 was going to have this, but axed it)
        dwFormat[8] = DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _DISABLED) |
                      DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F);

        // texture 0-3
        for (dwHWStage=0; dwHWStage < KELVIN_NUM_TEXTURES; dwHWStage++) {
            if (pContext->hwState.dwStateFlags & KELVIN_FLAG_USERTEXCOORDSNEEDED(dwHWStage)) {
                // the app needs texture N and provided us with one
                dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[dwHWStage];
                nvAssert (dwD3DStage != KELVIN_UNUSED);
                dwTCIndex  = (pContext->hwState.dwTexCoordIndices >> (8*dwHWStage)) & 0xff;
                dwVAIndex  = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
                nvAssert (pShader->bVAExists(dwVAIndex));  // they better have given us coordinates
                dwFormat[9+dwHWStage] = nvKelvinVertexFormat (pShader, ppStreams, dwVAIndex, bInlineVertices, dwInlineStride);
            }
            else {
                dwFormat[9+dwHWStage] = DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _DISABLED) |
                                        DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F);
            }
        }  // for dwHWStage

        // remainder are unused
        dwFormat[13] = DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _DISABLED) |
                       DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F);
        dwFormat[14] = DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _DISABLED) |
                       DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F);
        dwFormat[15] = DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _DISABLED) |
                       DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F);

    }

    //"fix" the format if it's only one DWORD and headed towards inline.
    //workaround for kelvin bug
    if (bInlineVertices && pContext->hwState.dwInlineVertexStride == 4)
    {
        if (dwFormat[0] == 2 ) //the one actual DWORD is somewhere else (not likely)
        {
            dwFormat[0]=0x825; //hardcode to 2 DWORD stride/ 2 Short value.
        }
        else //use register 1 for bogus info
        {
            dwFormat[1]=0x825; //hardcode to 2 DWORD stride/ 2 Short value.
        }
    }
    // send the formats to the HW
    pContext->hwState.kelvin.set8 (NV097_SET_VERTEX_DATA_ARRAY_FORMAT(0),
                                   dwFormat[0],  dwFormat[1],  dwFormat[2],  dwFormat[3],
                                   dwFormat[4],  dwFormat[5],  dwFormat[6],  dwFormat[7]);
    pContext->hwState.kelvin.set8 (NV097_SET_VERTEX_DATA_ARRAY_FORMAT(8),
                                   dwFormat[8],  dwFormat[9],  dwFormat[10], dwFormat[11],
                                   dwFormat[12], dwFormat[13], dwFormat[14], dwFormat[15]);

    // offsets --------------------------------------------------------------

    // we only need to send offsets if we're dma'ing vertex data
    if (!bInlineVertices) {

        // invalidate the vertex cache since we're messing with offsets
        pContext->hwState.kelvin.set1 (NV097_INVALIDATE_VERTEX_CACHE_FILE, 0);

        if (pShader->hasProgram()) {

            for (DWORD dwReg = 0; dwReg < 16; dwReg++) {
                dwOffset[dwReg] = nvKelvinVertexOffset (pShader, ppStreams, dwReg, pContext->hwState.dwVertexOffset);
            }

        }

        else {

            // x,y,z,[w]
            dwOffset[0] = nvKelvinVertexOffset (pShader, ppStreams, defaultInputRegMap[D3DVSDE_POSITION], pContext->hwState.dwVertexOffset);

            // weights
            dwOffset[1] = nvKelvinVertexOffset (pShader, ppStreams, defaultInputRegMap[D3DVSDE_BLENDWEIGHT], pContext->hwState.dwVertexOffset);

            // normal
            dwOffset[2] = nvKelvinVertexOffset (pShader, ppStreams, defaultInputRegMap[D3DVSDE_NORMAL], pContext->hwState.dwVertexOffset);

            // diffuse
            dwOffset[3] = nvKelvinVertexOffset (pShader, ppStreams, defaultInputRegMap[D3DVSDE_DIFFUSE], pContext->hwState.dwVertexOffset);

            // specular
            dwOffset[4] = nvKelvinVertexOffset (pShader, ppStreams, defaultInputRegMap[D3DVSDE_SPECULAR], pContext->hwState.dwVertexOffset);

            // fog distance
            dwOffset[5] = DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_OFFSET, _CONTEXT_DMA, _VERTEX_A) |
                          DRF_NUM (097, _SET_VERTEX_DATA_ARRAY_OFFSET, _OFFSET, 0);

            // point size
            dwOffset[6] = nvKelvinVertexOffset (pShader, ppStreams, defaultInputRegMap[D3DVSDE_PSIZE], pContext->hwState.dwVertexOffset);

            // back diffuse
            dwOffset[7] = DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_OFFSET, _CONTEXT_DMA, _VERTEX_A) |
                          DRF_NUM (097, _SET_VERTEX_DATA_ARRAY_OFFSET, _OFFSET, 0);

            // back specular
            dwOffset[8] = DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_OFFSET, _CONTEXT_DMA, _VERTEX_A) |
                          DRF_NUM (097, _SET_VERTEX_DATA_ARRAY_OFFSET, _OFFSET, 0);

            // texture 0-3
            for (dwHWStage=0; dwHWStage < KELVIN_NUM_TEXTURES; dwHWStage++) {
                if (pContext->hwState.dwStateFlags & KELVIN_FLAG_USERTEXCOORDSNEEDED(dwHWStage)) {
                    // the app needs texture N and provided us with one
                    dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[dwHWStage];
                    nvAssert (dwD3DStage != KELVIN_UNUSED);
                    dwTCIndex  = (pContext->hwState.dwTexCoordIndices >> (8*dwHWStage)) & 0xff;
                    dwVAIndex  = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
                    nvAssert (pShader->bVAExists(dwVAIndex));
                    dwOffset[9+dwHWStage] = nvKelvinVertexOffset (pShader, ppStreams, dwVAIndex,
                                                                  pContext->hwState.dwVertexOffset);
                }
                else {
                    dwOffset[9+dwHWStage] = DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_OFFSET, _CONTEXT_DMA, _VERTEX_A) |
                                            DRF_NUM (097, _SET_VERTEX_DATA_ARRAY_OFFSET, _OFFSET, 0);
                }
            }  // for dwHWStage

            // remainder are unused
            dwOffset[13] = DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_OFFSET, _CONTEXT_DMA, _VERTEX_A) |
                           DRF_NUM (097, _SET_VERTEX_DATA_ARRAY_OFFSET, _OFFSET, 0);
            dwOffset[14] = DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_OFFSET, _CONTEXT_DMA, _VERTEX_A) |
                           DRF_NUM (097, _SET_VERTEX_DATA_ARRAY_OFFSET, _OFFSET, 0);
            dwOffset[15] = DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_OFFSET, _CONTEXT_DMA, _VERTEX_A) |
                           DRF_NUM (097, _SET_VERTEX_DATA_ARRAY_OFFSET, _OFFSET, 0);

        }

        // send the offsets to the HW
        pContext->hwState.kelvin.set8 (NV097_SET_VERTEX_DATA_ARRAY_OFFSET(0),
                                       dwOffset[0],  dwOffset[1],  dwOffset[2],  dwOffset[3],
                                       dwOffset[4],  dwOffset[5],  dwOffset[6],  dwOffset[7]);
        pContext->hwState.kelvin.set8 (NV097_SET_VERTEX_DATA_ARRAY_OFFSET(8),
                                       dwOffset[8],  dwOffset[9],  dwOffset[10], dwOffset[11],
                                       dwOffset[12], dwOffset[13], dwOffset[14], dwOffset[15]);

    }  // !bInlineVertices

    dbgFlushType (NVDBG_FLUSH_STATE);
    return (D3D_OK);
}


#ifdef PROFILE_STATE_CHANGES
// Profile number of times a given state is changed. This is quick and dirty and will be improved.
static DWORD state_count[14] =
{
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};
#endif

//---------------------------------------------------------------------------

// set all state of the kelvin object

HRESULT __stdcall nvSetKelvinState (PNVD3DCONTEXT pContext)
{


#ifdef PROFILE_STATE_CHANGES
    state_count[13]++;
#endif

#ifdef NV_PROFILE_DP2OPS
    pDriverData->pBenchmark->beginHWStateChange(pContext->hwState.dwDirtyFlags, pDriverData->nvPusher.m_dwPut);
#endif

//    These calls have been moved/deferred from nvDrawPrimitives2 to nvSetKelvinState in order to avoid spurious upsampling in AA modes
//    where we have a simple Flip-SRT-Lock-UnLock-Flip loop.  The SRT as a consequence of the Flip was causing us
//    to do an unneeded upsample when no 3D rendering actually occurred.  Defer to SetKelvinState because it is only
//    called JUST before 3D rendering happens.
    pContext->kelvinAA.GrantAccess(CKelvinAAState::BUFFER_SRT, CKelvinAAState::ACCESS_WRITE);
    pContext->kelvinAA.GrantAccess(CKelvinAAState::BUFFER_SZB, CKelvinAAState::ACCESS_WRITE);

#ifdef NV_NULL_BLEND

    if (((pContext->hwState.dwDirtyFlags & KELVIN_DIRTY_MISC_STATE)) || (pContext->hwState.dwDirtyFlags & KELVIN_DIRTY_COMBINERS_COLOR) || (pContext->hwState.dwDirtyFlags & KELVIN_DIRTY_TEXTURE_STATE)) {

    pContext->dwRenderState[D3DRENDERSTATE_SRCBLEND]           = D3DBLEND_ONE;
    pContext->dwRenderState[D3DRENDERSTATE_DESTBLEND]          = D3DBLEND_ZERO;
    DWORD dwLODBias0 = nvTranslateLODBias (0);
    pContext->dwRenderState[D3DRENDERSTATE_ALPHAFUNC]          = D3DCMP_ALWAYS;
    pContext->dwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE]   = FALSE;
    for (int i = 0; i < 8; i++) {
#ifdef NV_NULL_TEXTURES
        pContext->tssState[i].dwValue[D3DTSS_TEXTUREMAP]      = 0;
        pContext->tssState[i].dwValue[D3DTSS_ADDRESSU]        = D3DTADDRESS_WRAP;
        pContext->tssState[i].dwValue[D3DTSS_ADDRESSV]        = D3DTADDRESS_WRAP;
        pContext->tssState[i].dwValue[D3DTSS_MAGFILTER]       = D3DTFG_POINT;
        pContext->tssState[i].dwValue[D3DTSS_MINFILTER]       = D3DTFN_POINT;
        pContext->tssState[i].dwValue[D3DTSS_MIPFILTER]       = D3DTFP_POINT;
        pContext->tssState[i].dwValue[D3DTSS_COLOROP]         = D3DTOP_DISABLE;
        pContext->tssState[i].dwValue[D3DTSS_COLORARG1]       = D3DTA_TEXTURE;
        pContext->tssState[i].dwValue[D3DTSS_COLORARG2]       = D3DTA_CURRENT;
#endif
        pContext->tssState[i].dwValue[D3DTSS_ALPHAOP]         = D3DTOP_DISABLE;
        pContext->tssState[i].dwValue[D3DTSS_ALPHAARG1]       = D3DTA_TEXTURE;
        pContext->tssState[i].dwValue[D3DTSS_ALPHAARG2]       = D3DTA_CURRENT;
#ifdef NV_NULL_TEXTURES
        pContext->tssState[i].dwValue[D3DTSS_BUMPENVMAT00]    = 0;
        pContext->tssState[i].dwValue[D3DTSS_BUMPENVMAT01]    = 0;
        pContext->tssState[i].dwValue[D3DTSS_BUMPENVMAT10]    = 0;
        pContext->tssState[i].dwValue[D3DTSS_BUMPENVMAT11]    = 0;
        pContext->tssState[i].dwValue[D3DTSS_TEXCOORDINDEX]   = 0;
        pContext->tssState[i].dwValue[D3DTSS_BORDERCOLOR]     = 0x00000000;
        pContext->tssState[i].dwValue[D3DTSS_MIPMAPLODBIAS]   = 0;
        pContext->tssState[i].dwValue[D3DTSS_MAXMIPLEVEL]     = 0;
        pContext->tssState[i].dwValue[D3DTSS_MAXANISOTROPY]   = 1;
        pContext->tssState[i].dwValue[D3DTSS_BUMPENVLSCALE]   = 0;
        pContext->tssState[i].dwValue[D3DTSS_BUMPENVLOFFSET]  = 0;
        pContext->tssState[i].dwHandle                        = 0;
        pContext->tssState[i].dwLODBias                       = dwLODBias0;
#endif
    }
#ifdef NV_NULL_TEXTURES
    pContext->tssState[0].dwValue[D3DTSS_COLOROP] = D3DTOP_MODULATE;
    pContext->tssState[0].dwValue[D3DTSS_ALPHAOP] = D3DTOP_SELECTARG1;
    pContext->dwStageCount       = 1;
#endif
    }

#endif

    // clear the failure flag
    pContext->hwState.dwStateFlags &= ~KELVIN_FLAG_SETUPFAILURE;

    // if ddraw has sullied the kelvin object or if we last programmed
    // the kelvin object for a different context, start from scratch
    if ((pDriverData->dwMostRecentHWUser != MODULE_ID_D3D) ||
        (getDC()->dwLastHWContext        != (DWORD)pContext))
    {
        pDriverData->dwMostRecentHWUser = MODULE_ID_D3D;
        getDC()->dwLastHWContext        = (DWORD)pContext;
        pContext->hwState.dwDirtyFlags  = KELVIN_DIRTY_REALLY_FILTHY;
    }

    // apply out-of-context dirty flags
    // this was here because of aliasing to the celsius object.
    // lord willing we won't have the same problem with kelvin, but...
    //pContext->hwState.dwDirtyFlags |= pDriverData->dwOutOfContextKelvinDirtyFlags;
    //pDriverData->dwOutOfContextKelvinDirtyFlags = 0;

    pContext->hwState.dwDirtyFlags |= dbgForceHWRefresh;

    // mask out any non-kelvin bits
    pContext->hwState.dwDirtyFlags &= KELVIN_DIRTY_REALLY_FILTHY;

    // if nothing is dirty, just return
    if (!(pContext->hwState.dwDirtyFlags)) {
        return D3D_OK;
    }

#ifdef NV_PROFILE_CALLSTACK
    NVP_START (NVP_T_SETKELVINSTATE);
#endif

    // fundamental D3D stuff that doesn't normally change
    if (pContext->hwState.dwDirtyFlags & KELVIN_DIRTY_DEFAULTS) {
#ifdef PROFILE_STATE_CHANGES
        state_count[0]++;
#endif
        nvSetKelvinD3DDefaults (pContext);
    }

    if (pContext->hwState.dwDirtyFlags & KELVIN_DIRTY_SURFACE) {
#ifdef PROFILE_STATE_CHANGES
        state_count[1]++;
#endif
        nvSetKelvinSurfaceInfo (pContext);
    }

    // program the color combiners early since they determine the mapping
    // between hardware texture units and D3D texture stages, upon
    // which tons of other stuff depends.
    if (pContext->hwState.dwDirtyFlags & KELVIN_DIRTY_COMBINERS_COLOR) {
#ifdef PROFILE_STATE_CHANGES
        state_count[2]++;
#endif
        nvSetKelvinColorCombiners (pContext);
    }

    // If a pixel shader is enabled, use it to update the state
    if (pContext->hwState.dwDirtyFlags & KELVIN_DIRTY_PIXEL_SHADER) {
#ifdef PROFILE_STATE_CHANGES
        state_count[3]++;
#endif
        nvSetKelvinPixelShader (pContext);
    }

    // texture state
    if (pContext->hwState.dwDirtyFlags & KELVIN_DIRTY_TEXTURE_STATE) {
#ifdef PROFILE_STATE_CHANGES
        state_count[4]++;
#endif
        nvSetKelvinTextureState (pContext);
    }

    // fog / specular combiner
    if (pContext->hwState.dwDirtyFlags & KELVIN_DIRTY_COMBINERS_SPECFOG) {
#ifdef PROFILE_STATE_CHANGES
        state_count[5]++;
#endif
        nvSetKelvinSpecularFogCombiner (pContext);
    }

    // vertex shader
    if (pContext->hwState.dwDirtyFlags & KELVIN_DIRTY_VERTEX_SHADER) {
#ifdef PROFILE_STATE_CHANGES
        state_count[6]++;
#endif
        nvSetKelvinVertexShader (pContext);
    }

    // texture transform
    if (pContext->hwState.dwDirtyFlags & KELVIN_DIRTY_TEXTURE_TRANSFORM) {
#ifdef PROFILE_STATE_CHANGES
        state_count[7]++;
#endif
        nvSetKelvinTextureTransform (pContext);
    }

    // lighting
    if (pContext->hwState.dwDirtyFlags & KELVIN_DIRTY_LIGHTS) {
#ifdef PROFILE_STATE_CHANGES
        state_count[8]++;
#endif
        nvSetKelvinLights (pContext);
    }

    // transform
    if (pContext->hwState.dwDirtyFlags & KELVIN_DIRTY_TRANSFORM) {
#ifdef PROFILE_STATE_CHANGES
        state_count[9]++;
#endif
        nvSetKelvinTransform (pContext);
    }

    // control0
    if (pContext->hwState.dwDirtyFlags & KELVIN_DIRTY_CONTROL0) {
#ifdef PROFILE_STATE_CHANGES
        state_count[10]++;
#endif
        nvSetKelvinControl0 (pContext);
    }

    // remaining random stuff
    if (pContext->hwState.dwDirtyFlags & KELVIN_DIRTY_MISC_STATE) {
#ifdef PROFILE_STATE_CHANGES
        state_count[11]++;
#endif
        nvSetKelvinMiscState (pContext);
    }

    if (pContext->hwState.dwDirtyFlags & KELVIN_DIRTY_FVF) {
#ifdef PROFILE_STATE_CHANGES
        state_count[12]++;
#endif
        nvSetKelvinVertexFormat (pContext);
    }

#ifdef NV_PROFILE_CALLSTACK
    NVP_STOP(NVP_T_SETKELVINSTATE);
    nvpLogTime(NVP_T_SETKELVINSTATE,nvpTime[NVP_T_SETKELVINSTATE]);
#endif

    // make sure we're not dirty anymore. (this might happen if
    // there are interdepencies among the kelvin state routines
    // and the routines get called in the 'wrong' order)
    nvAssert (!(pContext->hwState.dwDirtyFlags));

#ifdef NV_PROFILE_DP2OPS
    pDriverData->pBenchmark->endHWStateChange(pDriverData->nvPusher.m_dwPut);
#endif

    return (D3D_OK);
}

//---------------------------------------------------------------------------

// set only the kelvin state required to clear

HRESULT __stdcall nvSetKelvinClearState (PNVD3DCONTEXT pContext)
{
    // if ddraw has sullied the kelvin object or if we last programmed
    // the kelvin object for a different context, start from scratch
    if ((pDriverData->dwMostRecentHWUser != MODULE_ID_D3D) ||
        (getDC()->dwLastHWContext        != (DWORD)pContext))
    {
        pDriverData->dwMostRecentHWUser = MODULE_ID_D3D;
        getDC()->dwLastHWContext        = (DWORD)pContext;
        pContext->hwState.dwDirtyFlags  = KELVIN_DIRTY_REALLY_FILTHY;
    }

    pContext->hwState.dwDirtyFlags |= dbgForceHWRefresh;

    // mask out any non-kelvin bits
    pContext->hwState.dwDirtyFlags &= KELVIN_DIRTY_REALLY_FILTHY;

#ifdef NV_PROFILE_CALLSTACK
    NVP_START (NVP_T_SETKELVINSTATE);
#endif

    // fundamental D3D stuff that doesn't normally change
    if (pContext->hwState.dwDirtyFlags & KELVIN_DIRTY_DEFAULTS) {
        nvSetKelvinD3DDefaults (pContext);
    }

    if (pContext->hwState.dwDirtyFlags & KELVIN_DIRTY_SURFACE) {
        nvSetKelvinSurfaceInfo (pContext);
    }

#ifdef NV_PROFILE_CALLSTACK
    NVP_STOP(NVP_T_SETKELVINSTATE);
    nvpLogTime(NVP_T_SETKELVINSTATE,nvpTime[NVP_T_SETKELVINSTATE]);
#endif

    return (D3D_OK);
}

#endif // (NVARCH >= 0x20)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\kelvin\src\nvkelvinsupertri.cpp ===
// **************************************************************************
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvKelvinSuperTri.cpp
//      Kelvin primitive rendering routines
//
// **************************************************************************
//
//  History:
//      Scott Kephart       06 Nov 00               Ported from Celsius
//
// **************************************************************************
#include "nvprecomp.h"

#if (NVARCH >= 0x20)

#include "x86.h"

#ifdef KELVIN_ILC
//////////////////////////////////////////////////////////////////////////////
// notes:
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// switches
//
//#define USE_C_LOGIC     // force c logic (easier to debug)

//////////////////////////////////////////////////////////////////////////////
// aliases
//
#define ilcData         global.dwILCData
#define ilcCount        global.dwILCCount
#define ilcMax          global.dwILCMax

#define KNIMEM(x)       ((((DWORD)&((*(KATMAI_STATE*)global.kni).x[0])) + 15) & ~15)

//////////////////////////////////////////////////////////////////////////////
// externals
//
void ILCCompile_mul                            (DWORD reg,DWORD num);
void nvKelvinILCompile_limit                 (DWORD regLimit,DWORD regDummy);

void __stdcall nvKelvinDispatchGetFreeSpace   (PNVD3DCONTEXT pContext);
void __stdcall nvKelvinDispatchGetPusherSpace (void);
#ifdef DEBUG
void __stdcall nvKelvinDispatchFlush          (void);
void __stdcall nvKelvinDispatchPrintVertex    (PNVD3DCONTEXT pContext,DWORD dwPutAddress);
#endif

/*****************************************************************************
 *****************************************************************************
 *** helpers *****************************************************************
 *****************************************************************************
 *****************************************************************************/


/*****************************************************************************
 *****************************************************************************
 *** super triangle lists *********ASSUMES KNI OR 3DNOW !*************
 *****************************************************************************
 *****************************************************************************/

DWORD nvKelvinILCompile_super_tri_list
(
    PNVD3DCONTEXT pContext,
    DWORD         dwFlags
)
{

#if 1

    if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_3DNOW)
    {
//*****************************************************************************************************
//*****************************************************************************************************
//
//      AMD Athlon
//
//*****************************************************************************************************
//*****************************************************************************************************

        //
        // align entry point
        //
        while (ilcCount & 31)
        {
            xINT3
        }
        DWORD lEntry;
        xLABEL (lEntry);

        //
        // setup stack frame
        //
        xPUSH_r     (rEBP)
        xPUSH_r     (rEBX)
        xPUSH_r     (rESI)
        xPUSH_r     (rEDI)

    #ifdef USE_C_LOGIC
        xMOV_rm_imm (rmREG(rEAX),dwFlags)
        xPUSH_r (rEAX)
        xMOV_rm_imm (rmREG(rEAX),proto)
        xCALL_rm (rmREG(rEAX))
    #else //USE_C_LOGIC

        //
        // setup push buffer
        //
        xMOV_r_i32  (rEDX,mMEM32(pDriverData))
        xMOV_r_rm   (rEDI,rmIND32(rEDX)) xOFS32(OFFSETOF(CDriverContext, nvPusher.m_dwPut))

        //
        // align push buffer
        //
        {
            DWORD skip,again;
            xMOV_rm_imm  (rmREG(rEAX),(((0 << 2) << 16) | ((NV_DD_KELVIN) << 13) | NV097_NO_OPERATION))
            xLABEL       (again)
            xMOV_r_rm    (rEBX,rmREG(rEDI))
            xAND_rm_imm  (rmREG(rEBX),0xf)
            xCMP_rm_imm  (rmREG(rEBX),8)
            xLABEL       (skip)
            xJZ          (0)
            xMOV_rm_r    (rmIND(rEDI),rEAX)
            xLEA_r_rm    (rEDI,rmIND8(rEDI)) xOFS8(4)
            xJMP         (again)
            xTARGET_b8   (skip)
        }

//         if (!(dwFlags & KELVIN_ILFLAG_NOCLIP))
//         {
//         }
//         else
        {

           xFEMMS
            //
            // start primitive
            //
            xMOVQ_r_i64  (rMM0,mMEM64(global.kelvin.qwBegin))
            xMOVQ_rm_r (rmIND(rEDI),rMM0)
            xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(8)

            //
            // setup
            //
            xMOV_r_i32  (rEAX,mMEM32(global.dwVertexSN))
            xADD_rm_imm (rmREG(rEAX),0x10000)
            xMOV_i32_r  (mMEM32(global.dwVertexSN),rEAX)

            xMOV_r_i32  (rESI,mMEM32(global.kelvin.pIndices))
            xMOV_r_i32  (rECX,mMEM32(global.kelvin.dwPrimCount))
            xLEA_r_rm   (rEAX,rmSIB) xSIB(rECX,rECX,x2)
            xMOV_i32_r  (mMEM32(global.kelvin.dwPrefetchBase),rESI)
            xLEA_r_rm   (rEAX,rmSIB) xSIB(rEAX,rEAX,x1)
            xMOV_i32_r  (mMEM32(global.kelvin.dwPrefetchMax),rEAX)

            //
            // process all triangles
            //
            DWORD again;
            xLABEL  (again)
            xPUSH_r (rECX)

            //
            DWORD cullCheck = 0;
            if (!(dwFlags & KELVIN_ILFLAG_NOCULL))
            {
                // eye point in model space

                xMOV_r_i32 (rEAX,mMEM32(global.kelvin.dwEyeAddr))
                xMOVQ_r_rm (rMM6,rmIND(rEAX)) 
                xMOVQ_r_rm (rMM7,rmIND8(rEAX)) xOFS8(8)
                // get index
                //clear EDX

                // Vertex 0
        #define STMC_PREF_DIST_AMD (0x40)
                xXOR_r_rm   (rEDX,rmREG(rEDX))

                xMOV_r_i32  (rESI,mMEM32(global.kelvin.pIndices))
                x16r xMOV_r_rm   (rDX,rmIND8(rESI)) xOFS8(0*2)
                xADD_r_i32       (rEDX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                xMOV_i32_r  (KNIMEM(dwKelvinTriDispatch) + 4 + 0*4,rEDX)

                // compute vertex address into edx
                ILCCompile_mul (rEDX,pContext->hwState.SuperTri.getSTLBStride());
                xADD_r_i32     (rEDX,mMEM32(global.kelvin.pVertices))

                xMOV_r_rm   (rEAX, rmREG(rEDX))

                xMOVQ_r_rm  (rMM0, rmIND(rEDX))             //MM0 = V0.Y V0.X
                xMOVQ_r_rm  (rMM1, rmIND8(rEDX)) xOFS8(8)   //MM1 = xxxx V0.Z

                // Vertex 1
                xXOR_r_rm   (rEDX,rmREG(rEDX))

                x16r xMOV_r_rm   (rDX,rmIND8(rESI)) xOFS8(1*2)
                xADD_r_i32       (rEDX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                xMOV_i32_r  (KNIMEM(dwKelvinTriDispatch) + 4 + 1*4,rEDX)

                // compute vertex address into edx
                ILCCompile_mul (rEDX,pContext->hwState.SuperTri.getSTLBStride());
                xADD_r_i32     (rEDX,mMEM32(global.kelvin.pVertices))

                xMOV_r_rm   (rEBX, rmREG(rEDX))
                xMOVQ_r_rm  (rMM2, rmIND(rEDX))             //MM2 = V1.Y V1.X
                xMOVQ_r_rm  (rMM3, rmIND8(rEDX)) xOFS8(8)   //MM3 = xxxx V1.Z

                xPFSUB_r_rm     (rMM6, rmREG(rMM0))     //mm6 & mm7 = eyevec
                xPFSUB_r_rm     (rMM7, rmREG(rMM1))

                // Vertex 2
                xXOR_r_rm   (rEDX,rmREG(rEDX))

                x16r xMOV_r_rm   (rDX,rmIND8(rESI)) xOFS8(2*2)
                xADD_r_i32       (rEDX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                xMOV_i32_r  (KNIMEM(dwKelvinTriDispatch) + 4 + 2*4,rEDX)

                // compute vertex address into edx
                ILCCompile_mul (rEDX,pContext->hwState.SuperTri.getSTLBStride());
                xADD_r_i32      (rEDX,mMEM32(global.kelvin.pVertices))

                xPFSUB_r_rm     (rMM2, rmREG(rMM0))     //mm2 & mm3 = v1 - v0 = v10
                xPFSUB_r_rm     (rMM3, rmREG(rMM1))


                xMOV_r_rm   (rECX, rmREG(rEDX))
                xMOVQ_r_rm  (rMM4, rmIND(rEDX))             //MM4 = V2.Y V2.X
                xMOVQ_r_rm  (rMM5, rmIND8(rEDX)) xOFS8(8)   //MM5 = xxxx V2.Z

                // Compute eye vector
//                xCMP_r_rm   (rEBX, rmREG(rEAX))


                // Compute Normal

//                xCMOVA_r_rm (rEAX, rmREG(rEBX))
                xAND_rm_imm (rmREG(rEAX), ~0x3f)
                if (pContext->hwState.SuperTri.isFixedLBStride())
                {
                    xPREFETCH_rm8(0, rmIND8(rEAX), STMC_PREF_DIST_AMD)
                }
                else
                {
                    if ((4 * pContext->hwState.SuperTri.getSTLBStride()) < 128) {
                        xPREFETCH_rm8(0, rmIND8(rEAX), 4 * pContext->hwState.SuperTri.getSTLBStride())
                    }
                    else {
                        xADD_rm_imm(rmREG(rEAX), 4 * pContext->hwState.SuperTri.getSTLBStride())
                        xPREFETCH_rm8(0, rmIND8(rEAX), 0)
                    }
                }

                xPFSUB_r_rm     (rMM4, rmREG(rMM0))     //mm4 & mm5 = v2 - v0 = v20
                xPFSUB_r_rm     (rMM5, rmREG(rMM1))

                //      0.0 V10.X   V10.Z   V10.Y
                //    * 0.0 V20.y   V20.X   V20.Z
                //    -
                //      0.0 V10.Y   V10.X   V10.Z
                //    * 0.0 V20.X   V20.Z   V20.Y



                // MM2 = V10.Y V10.X
                // MM3 = xxxxx V10.Z
                // MM4 = V20.Y V20.X
                // MM5 = xxxxx V20.Z

                xPUNPCKLDQ_r_rm (rMM3, rmREG(rMM3))     //mm3 = V10.Z V10.Z
                xPUNPCKLDQ_r_rm (rMM5, rmREG(rMM5))     //mm5 = v20.z v20.z

//                xCMP_r_rm   (rECX, rmREG(rEAX))

                // MM2 = V10.Y V10.X
                // MM3 = v10.z V10.Z
                // MM4 = V20.Y V20.X
                // MM5 = v20.z V20.Z


                xMOVQ_r_rm      (rMM0, rmREG(rMM2))
                xMOVQ_r_rm      (rMM1, rmREG(rMM4))

//                xCMOVA_r_rm (rEAX, rmREG(rECX))
                xAND_rm_imm (rmREG(rEBX), ~0x3f)
                if (pContext->hwState.SuperTri.isFixedLBStride())
                {
                    xPREFETCH_rm8(0, rmIND8(rEBX), STMC_PREF_DIST_AMD)
                }
                else
                {
                    if ((4 * pContext->hwState.SuperTri.getSTLBStride()) < 128) {
                        xPREFETCH_rm8(0, rmIND8(rEBX), 4 * pContext->hwState.SuperTri.getSTLBStride())
                    }
                    else {
                        xADD_rm_imm(rmREG(rEBX), 4 * pContext->hwState.SuperTri.getSTLBStride())
                        xPREFETCH_rm8(0, rmIND8(rEBX), 0)
                    }
                }

                xPUNPCKHDQ_r_rm (rMM0, rmREG(rMM0))
                xPUNPCKHDQ_r_rm (rMM1, rmREG(rMM1))

//                xAND_rm_imm (rmREG(rEAX), ~0x3f)
                xAND_rm_imm (rmREG(rECX), ~0x3f)

                //MM0 = V10.Y V10.Y
                //MM1 = V20.Y V20.Y

                xPFMUL_r_rm     (rMM0, rmREG(rMM4)) //mm0 = xxxx V10.Y*V20.X
                xPFMUL_r_rm     (rMM1, rmREG(rMM2)) //mm1 = xxxx v20.Y*V10.X
                xPFSUB_r_rm     (rMM1, rmREG(rMM0)) //mm1 = xxxx Z'

                xPUNPCKLDQ_r_rm (rMM3, rmREG(rMM2)) //mm3 = v10.x v10.z
                xPUNPCKLDQ_r_rm (rMM5, rmREG(rMM4)) //mm5 = v20.x v20.z

                xPUNPCKHDQ_r_rm (rMM2, rmREG(rMM2)) //mm2 = v10.Y v10.Y
                xPUNPCKHDQ_r_rm (rMM4, rmREG(rMM4)) //mm4 = V20.Y V20.Y

                xPUNPCKLDQ_r_rm (rMM2, rmREG(rMM3)) //mm2 = V10.Z V10.Y
                xPUNPCKLDQ_r_rm (rMM4, rmREG(rMM5)) //mm4 = v20.z v20.y

                xPFMUL_r_rm     (rMM2, rmREG(rMM5))
                xPFMUL_r_rm     (rMM4, rmREG(rMM3))

                if (pContext->hwState.SuperTri.isFixedLBStride())
                {
                    xPREFETCH_rm8   (0, rmIND8(rECX), STMC_PREF_DIST_AMD)
                }
                else
                {
                    if ((4 * pContext->hwState.SuperTri.getSTLBStride()) < 128) {
                        xPREFETCH_rm8(0, rmIND8(rECX), 4 * pContext->hwState.SuperTri.getSTLBStride())
                    }
                    else {
                        xADD_rm_imm(rmREG(rECX), 4 * pContext->hwState.SuperTri.getSTLBStride())
                        xPREFETCH_rm8(0, rmIND8(rECX), 0)
                    }
                }

                xPFSUB_r_rm     (rMM2, rmREG(rMM4)) //mm2 = Y' X'

                // Dot normal and eye vector

                xPFMUL_r_rm     (rMM2, rmREG(rMM6))     //mm2 = Y' * eyevec.Y   X'*eyevec.X
                xPFMUL_r_rm     (rMM1, rmREG(rMM7))     //mm1 = xxxx            Z' * eyevec.Z
                xMOVQ_r_rm      (rMM0, rmREG(rMM2))     //mm0 = Y' * eyevec.Y   X'*eyevec.X
                xPUNPCKHDQ_r_rm (rMM0, rmREG(rMM0))     //mm0 = Y' * eyevec.Y   Y'*eyevec.Y
                xPFADD_r_rm     (rMM2, rmREG(rMM1))
                xPFADD_r_rm     (rMM2, rmREG(rMM0))

                xMOV_r_i32      (rEAX,mMEM32(global.kelvin.dwCullAddr))
                xMOV_r_rm       (rEBX,rmIND(rEAX)) 

                xMOVD_rm_r      (rmREG(rEAX), rMM2)
                xSHR_rm_imm8    (rmREG(rEAX), 31)

                xXOR_r_rm       (rEAX, rmREG(rEBX))
                xXOR_rm_imm     (rmREG(rEAX), 0x00000001)
                xTEST_rm_imm    (rmREG(rEAX), 0x00000001)


                //reads EBX,ECX,EDX

                xLABEL           (cullCheck)
                xJNZ32            (0)
            }
            else
            {
                xXOR_r_rm   (rEDX,rmREG(rEDX))

                xMOV_r_i32  (rESI,mMEM32(global.kelvin.pIndices))
                x16r xMOV_r_rm   (rDX,rmIND8(rESI)) xOFS8(0*2)
                xADD_r_i32       (rEDX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                xMOV_i32_r  (KNIMEM(dwKelvinTriDispatch) + 4 + 0*4,rEDX)

                x16r xMOV_r_rm   (rDX,rmIND8(rESI)) xOFS8(1*2)
                xADD_r_i32       (rEDX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                xMOV_i32_r  (KNIMEM(dwKelvinTriDispatch) + 4 + 1*4,rEDX)

                x16r xMOV_r_rm   (rDX,rmIND8(rESI)) xOFS8(2*2)
                xADD_r_i32       (rEDX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                xMOV_i32_r  (KNIMEM(dwKelvinTriDispatch) + 4 + 2*4,rEDX)
            }

            //
            // dispatch
            //

            xMOVQ_r_i64(rMM1,KNIMEM(dwKelvinTriDispatch))
            xMOVQ_r_i64(rMM2,KNIMEM(dwKelvinTriDispatch)+8)
            xMOVNTQ_rm_r (rmIND(rEDI),rMM1)
            xMOVNTQ_rm_r (rmIND8(rEDI),rMM2) xOFS8(8)
            xLEA_r_rm      (rEDI,rmIND8(rEDI)) xOFS8(16)

            //
            // send more triangles after this one, utilizing connectivity statistics
            //
    #if 1
            if (!pContext->hwState.SuperTri.isCheckAll() || (dwFlags & KELVIN_ILFLAG_NOCULL))
            {
                const int count = 4; // do not exceed 128 words (about 14 of these)
                DWORD sendMore;
                xPOP_r      (rECX)
                xCMP_rm_imm (rmREG(rECX),count)
                xLABEL      (sendMore)
                xJLE32      (0)

                xMOV_r_i32  (rESI,mMEM32(global.kelvin.pIndices))
                for (int i = 0; i < count; i++)
                {
                    // prep tri
                    xLEA_r_rm   (rESI,rmIND8(rESI)) xOFS8(6)
                    xXOR_r_rm   (rEBX,rmREG(rEBX))
                    xMOV_r_rm   (rEAX,rmIND(rESI))
                    x16r xMOV_r_rm   (rBX,rmIND8(rESI)) xOFS8(4)
                    xADD_r_i32       (rEBX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                    xMOV_r_rm   (rEDX,rmREG(rEAX))
                    xAND_rm_imm (rmREG(rEAX),0xffff)
                    xADD_r_i32       (rEAX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                    xMOV_i32_r  (KNIMEM(dwKelvinTriDispatch) + 12,rEBX)
                    xSHR_rm_imm8(rmREG(rEDX),16)
                    xADD_r_i32       (rEDX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                    xMOV_i32_r  (KNIMEM(dwKelvinTriDispatch) + 4,rEAX)
                    xMOV_i32_r  (KNIMEM(dwKelvinTriDispatch) + 8,rEDX)

                    // dispatch
                    xMOVQ_r_i64 (rMM0,KNIMEM(dwKelvinTriDispatch))
                    xMOVQ_r_i64 (rMM1,KNIMEM(dwKelvinTriDispatch)+8)
                    xMOVNTQ_rm_r   (rmIND(rEDI),rXMM0)
                    xMOVNTQ_rm_r   (rmIND8(rEDI),rXMM1) xOFS8(8)
                    xLEA_r_rm      (rEDI,rmIND8(rEDI)) xOFS8(16)

                }
                xSUB_rm_imm (rmREG(rECX),count)
                xMOV_i32_r  (mMEM32(global.kelvin.pIndices),rESI)
                xTARGET_b32 (sendMore)
                xPUSH_r     (rECX)
            }
    #endif
            // check for pusher space
            DWORD labelSpace;
            xMOV_r_i32  (rESI,mMEM32(pDriverData))
            xCMP_r_rm   (rEDI,rmIND32(rESI)) xOFS32(OFFSETOF(CDriverContext, nvPusher.m_dwThreshold))
            xLABEL      (labelSpace)
            xJL         (0)
            {
                xMOV_rm_imm (rmREG(rEBX),(DWORD)nvKelvinDispatchGetPusherSpace)
                xMOV_rm_r   (rmIND32(rESI),rEDI) xOFS32(OFFSETOF(CDriverContext, nvPusher.m_dwPut))
                xCALL_rm    (rmREG(rEBX))
                xMOV_r_rm   (rEDI,rmIND32(rESI)) xOFS32(OFFSETOF(CDriverContext, nvPusher.m_dwPut))
            }
            xTARGET_b8  (labelSpace)

            //
            // next triangle
            //
            if (cullCheck)
            { xTARGET_b32 (cullCheck)
            }
            xMOV_r_i32  (rESI,mMEM32(global.kelvin.pIndices))
            xPOP_r      (rECX)
            xLEA_r_rm   (rESI,rmIND8(rESI)) xOFS8(6)
            xDEC_rm     (rmREG(rECX))
            xMOV_i32_r  (mMEM32(global.kelvin.pIndices),rESI)
            xJNZ32      (again)

            //
            // end primitive
            //
            xMOVQ_r_i64  (rMM0,mMEM64(global.kelvin.qwEnd))
            xMOVNTQ_rm_r (rmIND(rEDI),rMM0)
            xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(8)
            xFEMMS


        }//#endif // ~INVERSE_XFORM_CULL

        //
        // save off push buffer
        //
        xMOV_r_i32  (rEDX,mMEM32(pDriverData))
    #ifndef NV_NULL_HW_DRIVER
        xMOV_rm_r   (rmIND32(rEDX),rEDI) xOFS32(OFFSETOF(CDriverContext, nvPusher.m_dwPut))
    #endif

    #endif // USE_C_LOGIC
        //
        // clean up caching strategy
        //
        //     xMOV_r_i32  (rEAX,mMEM32(pDriverData))
        //     xMOV_rm_imm (rmREG(rEBX),rzSetAGPMTRR)
        //     xPUSH_imm   (1)
        //     xPUSH_rm    (rmIND32(rEAX)) xOFS32(OFFSETOF(GLOBALDATA, GARTPhysicalBase))
        //     xCALL_rm    (rmREG(rEBX))

        //
        // done
        //
        xPOP_r      (rEDI)
        xPOP_r      (rESI)
        xPOP_r      (rEBX)
        xPOP_r      (rEBP)
        xRET
        return lEntry;

    }

    else
    {

//*****************************************************************************************************
//*****************************************************************************************************
//
//      Intel SSE & SSE2
//
//*****************************************************************************************************
//*****************************************************************************************************


        //
        // align entry point
        //
        while (ilcCount & 31)
        {
            xINT3
        }
        DWORD lEntry;
        xLABEL (lEntry);

        //
        // setup stack frame
        //
        xPUSH_r     (rEBP)
        xPUSH_r     (rEBX)
        xPUSH_r     (rESI)
        xPUSH_r     (rEDI)

    #ifdef USE_C_LOGIC
        xMOV_rm_imm (rmREG(rEAX),dwFlags)
        xPUSH_r (rEAX)
        xMOV_rm_imm (rmREG(rEAX),proto)
        xCALL_rm (rmREG(rEAX))
    #else //USE_C_LOGIC

        //
        // setup push buffer
        //
        xMOV_r_i32  (rEDX,mMEM32(pDriverData))
        xMOV_r_rm   (rEDI,rmIND32(rEDX)) xOFS32(OFFSETOF(CDriverContext, nvPusher.m_dwPut))

        //
        // align push buffer
        //
        {
            DWORD skip,again;
            xMOV_rm_imm  (rmREG(rEAX),(((0 << 2) << 16) | ((NV_DD_KELVIN) << 13) | NV097_NO_OPERATION))
            xLABEL       (again)
            xMOV_r_rm    (rEBX,rmREG(rEDI))
#ifndef SW_WC
            xAND_rm_imm  (rmREG(rEBX),0xf)
            xCMP_rm_imm  (rmREG(rEBX),8)
#else
            xAND_rm_imm  (rmREG(rEBX),0x3f)
            xCMP_rm_imm  (rmREG(rEBX),0x38)
#endif
            xLABEL       (skip)
            xJZ          (0)
            xMOV_rm_r    (rmIND(rEDI),rEAX)
            xLEA_r_rm    (rEDI,rmIND8(rEDI)) xOFS8(4)
            xJMP         (again)
            xTARGET_b8   (skip)
        }

        //
        // setup caching strategy
        //
        //     xMOV_r_i32  (rEAX,mMEM32(pDriverData))
        //     xMOV_rm_imm (rmREG(rEBX),rzSetAGPMTRR)
        //     xPUSH_imm   (4)
        //     xPUSH_rm    (rmIND32(rEAX)) xOFS32(OFFSETOF(GLOBALDATA, GARTPhysicalBase))
        //     xCALL_rm    (rmREG(rEBX))
        if (pContext->hwState.SuperTri.isXFormCull())
        {


            //
            // load KNI matrix
            //
            if ((pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI))
            {
                xMOV_r_i32   (rEAX,mMEM32(global.kelvin.pContext_kelvinState))
                xMOVLPS_r_rm (rXMM4,rmIND32(rEAX)) xOFS32(OFFSETOF(CHardwareState, mTransform._11))
                xMOVHPS_r_rm (rXMM4,rmIND32(rEAX)) xOFS32(OFFSETOF(CHardwareState, mTransform._13))
                xMOVLPS_r_rm (rXMM5,rmIND32(rEAX)) xOFS32(OFFSETOF(CHardwareState, mTransform._21))
                xMOVHPS_r_rm (rXMM5,rmIND32(rEAX)) xOFS32(OFFSETOF(CHardwareState, mTransform._23))
                xMOVLPS_r_rm (rXMM6,rmIND32(rEAX)) xOFS32(OFFSETOF(CHardwareState, mTransform._31))
                xMOVHPS_r_rm (rXMM6,rmIND32(rEAX)) xOFS32(OFFSETOF(CHardwareState, mTransform._33))
                xMOVLPS_r_rm (rXMM7,rmIND32(rEAX)) xOFS32(OFFSETOF(CHardwareState, mTransform._41))
                xMOVHPS_r_rm (rXMM7,rmIND32(rEAX)) xOFS32(OFFSETOF(CHardwareState, mTransform._43))
            }



            //
            // start primitive
            //
            xMOVQ_r_i64  (rMM0,mMEM64(global.kelvin.qwBegin))
            xMOVNTQ_rm_r (rmIND(rEDI),rMM0)
            xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(8)
            xEMMS


            //
            // setup
            //
            xMOV_r_i32  (rEAX,mMEM32(global.dwVertexSN))
            xADD_rm_imm (rmREG(rEAX),0x10000)
            xMOV_i32_r  (mMEM32(global.dwVertexSN),rEAX)

            xMOV_r_i32  (rESI,mMEM32(global.kelvin.pIndices))
            xMOV_r_i32  (rECX,mMEM32(global.kelvin.dwPrimCount))
            xLEA_r_rm   (rEAX,rmSIB) xSIB(rECX,rECX,x2)
            xMOV_i32_r  (mMEM32(global.kelvin.dwPrefetchBase),rESI)
            xLEA_r_rm   (rEAX,rmSIB) xSIB(rEAX,rEAX,x1)
            xMOV_i32_r  (mMEM32(global.kelvin.dwPrefetchMax),rEAX)
            xXOR_r_rm   (rEAX, rmREG(rEAX))
            xMOV_i32_r  (mMEM32(global.kelvin.dwPrefMaxIdx), rEAX)

            //
            // process all triangles
            //
            {
                DWORD again;
                xLABEL  (again)
                xPUSH_r (rECX)

                //
                // prefetch HERE

                xMOV_r_i32  (rESI,mMEM32(global.kelvin.pIndices))

                const DWORD dist = 3;
                DWORD noPrefetch;
                xCMP_rm_imm     (rmREG(rECX), dist)
                xLABEL      (noPrefetch)
                xJBE32      (0)


                xMOV_r_i32  (rEAX,mMEM32(global.kelvin.dwPrefMaxIdx))
                xXOR_r_rm   (rEDX,rmREG(rEDX))
                for (int i = 0; i < 3; i++)
                {
                    x16r xMOV_r_rm   (rDX,rmIND8(rESI)) xOFS8(((dist*3)+i)*2)
                    xADD_r_i32       (rEDX, mMEM32(global.kelvin.dwBaseVertex))     //******** BV
                    if (!pContext->hwState.SuperTri.isFixedLBStride())
                        xAND_rm_imm (rmREG(rEDX), ~1)
                        DWORD noPre1=0;
                    xCMP_r_rm   (rEDX, rmREG(rEAX))
                    xLABEL      (noPre1)
                    xJBE        (0)

                    xMOV_r_rm   (rEAX, rmREG(rEDX))
                    xMOV_r_rm   (rEBX, rmREG(rEDX))
                    ILCCompile_mul (rEDX, pContext->hwState.SuperTri.getSTLBStride());
                    xADD_r_i32     (rEBX,mMEM32(global.kelvin.pVertices))
                    xPREFETCH_rm8(1, rmIND8(rEBX), 0)
                    xTARGET_b8 (noPre1)
                }

                xMOV_i32_r  (mMEM32(global.kelvin.dwPrefMaxIdx), rEAX)
                xTARGET_b32 (noPrefetch)

                //
                // do transform, outcode and w-divide calculations. use cached verts if possible
                //
                for (i = 0; i < 3; i++)
                {
                    // get index
                    //clear EDX
                    xXOR_r_rm   (rEDX,rmREG(rEDX))
                    xMOV_r_i32  (rESI,mMEM32(global.kelvin.pIndices))
                    x16r xMOV_r_rm   (rDX,rmIND8(rESI)) xOFS8(i*2)
                    xADD_r_i32       (rEDX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                    // compute cache index (save edx)
                    xMOV_r_rm   (rEAX,rmREG(rEDX))
                    xMOV_i32_r  (KNIMEM(dwKelvinTriDispatch) + 4 + i*4,rEDX)
                    xAND_rm_imm (rmREG(rEAX),VB_CACHE_SIZE - 1)
                    // arbitration (save eax,edx)
                    DWORD arb;
                    xLABEL      (arb)
                    switch (i)
                    {
                    case 1:
                        {
                            DWORD skip;

                            xCMP_r_i32  (rEAX,mMEM32(global.dwIndex0))
                            xLABEL      (skip)
                            xJNZ        (0)
                            xADD_rm_imm (rmREG(rEAX),3)
                            xAND_rm_imm (rmREG(rEAX),VB_CACHE_SIZE - 1)
                            xJMP        (arb)

                            xTARGET_b8  (skip)
                            break;
                        }
                    case 2:
                        {
                            DWORD skip1,skip2;

                            xCMP_r_i32  (rEAX,mMEM32(global.dwIndex0))
                            xLABEL      (skip1)
                            xJNZ        (0)
                            xADD_rm_imm (rmREG(rEAX),3)
                            xAND_rm_imm (rmREG(rEAX),VB_CACHE_SIZE - 1)
                            xJMP        (arb)

                            xTARGET_b8  (skip1)
                            xCMP_r_i32  (rEAX,mMEM32(global.dwIndex1))
                            xLABEL      (skip2)
                            xJNZ        (0)
                            xADD_rm_imm (rmREG(rEAX),3)
                            xAND_rm_imm (rmREG(rEAX),VB_CACHE_SIZE - 1)
                            xJMP        (arb)

                            xTARGET_b8  (skip2)
                            break;
                        }
                    }
                    xMOV_i32_r  (mMEM32(global.dwIndex0) + i*4,rEAX)
                    // compute TL vertex address (save eax,edx)
                    xMOV_r_rm   (rEBX,rmREG(rEAX))
                    xMOV_r_rm   (rECX,rmREG(rEDX))
                    ILCCompile_mul (rEBX,sizeof(KATMAI_STATE::TLVERTEX));
                    xADD_rm_imm (rmREG(rEBX),KNIMEM(adwTLVertexCache))
                    xOR_r_i32   (rECX,mMEM32(global.dwVertexSN))
                    xMOV_i32_r  (mMEM32(global.dwVertex0) + i*4,rEBX)
                    // test cache (save eax,ecx,edx)
                    DWORD cacheHit;
                    xCMP_r_rm   (rECX,rmSIB) xSIBID(rEAX,x4) xOFS32(mMEM32(global.dwVertexCacheIndex))
                    xLABEL      (cacheHit)
                    xJZ32       (0)

                    //
                    // cache miss
                    //

                    // occupy cache entry (save edx)
                    xMOV_rm_r (rmSIB,rECX) xSIBID(rEAX,x4) xOFS32(mMEM32(global.dwVertexCacheIndex))

                    // compute vertex address into edx
                    ILCCompile_mul (rEDX,pContext->hwState.SuperTri.getSTLBStride());
                    xADD_r_i32     (rEDX,mMEM32(global.kelvin.pVertices))


                    //
                    // transform vertex and apply min/max info
                    //

                    xMOV_r_i32       (rECX,mMEM32(global.dwVertex0) + i*4)

                    ///katmai
                    if ((pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI))
                    {



                        //0: 0 0 0 X
                        xMOVSS_r_rm      (rXMM0,rmIND(rEDX))
                        //1: 0 0 0 Y
                        xMOVSS_r_rm      (rXMM1,rmIND8(rEDX)) xOFS8(4)
                        //0: X X X X
                        xSHUFPS_r_rm_imm (rXMM0,rmREG(rXMM0),0)
                        //1: Y Y Y Y
                        xSHUFPS_r_rm_imm (rXMM1,rmREG(rXMM1),0)
                        //2: 0 0 0 Z
                        xMOVSS_r_rm      (rXMM2,rmIND8(rEDX)) xOFS8(8)
                        //0: 3X 2X 1X 0X
                        xMULPS_r_rm      (rXMM0,rmREG(rXMM4))
                        //2: Z Z Z Z
                        xSHUFPS_r_rm_imm (rXMM2,rmREG(rXMM2),0)
                        //1: 7y 6y 5y 4y
                        xMULPS_r_rm      (rXMM1,rmREG(rXMM5))
                        //2:11Z 10Z 9Z 8Z
                        xMULPS_r_rm      (rXMM2,rmREG(rXMM6))
                        //0: 0+1
                        xADDPS_r_rm      (rXMM0,rmREG(rXMM1))
                        //0: 0+2
                        xADDPS_r_rm      (rXMM0,rmREG(rXMM2))
                        //0: 0+7 (15 14 13 12)
                        xADDPS_r_rm (rXMM0,rmREG(rXMM7))
                        //store xformed WZYX -> XYZW
                        xMOVAPS_rm_r     (rmIND(rECX),rXMM0)

                        //!!!!stores to ECX

                        //deadbeef
                        // start w-divide (save ecx)
                        ///load wxyz into xmm1
                        xMOVAPS_r_rm     (rXMM1,rmREG(rXMM0))
                        /// spread W over xmm0
                        xSHUFPS_r_rm_imm (rXMM0,rmREG(rXMM0),0xff)
                        /// xmm1 -> w/w z/w y/w x/w
                        //                   xDIVPS_r_rm      (rXMM1,rmREG(rXMM0))
                        //                 Replace the DIVPS with approximation 1/w rcpps with 1 Newton-Raphson iteration
                        //                 This is faster on all cpu's, and is accurate to within 2 bits of precision of divps
                        // Compute 1/w
                        xRCPPS_r_rm      (rXMM2, rmREG(rXMM0))
                        xMULPS_r_rm      (rXMM0, rmREG(rXMM2))
                        xMULPS_r_rm      (rXMM0, rmREG(rXMM2))
                        xADDPS_r_rm      (rXMM2, rmREG(rXMM2))
                        xSUBPS_r_rm      (rXMM2, rmREG(rXMM0))
                        // Multiply w z y x by 1/w 1/w 1/w 1/w
                        xMULPS_r_rm      (rXMM1, rmREG(rXMM2))

                    }
                    /*
                    else
                    {
                    ///3dnow

                    //xFEMMS
                    xEMMS

                    //load EBX with matrix start
                    xMOV_r_i32   (rEBX,mMEM32(global.kelvin.pContext_celsiusState))

                    xMOV_r_i32   (rEAX,mMEM32(global.celsius.dwTouchedMin))
                    //MOVQ MM0, [EDX]
                    xMOVQ_r_rm  (rMM0,rmIND(rEDX));
                    //MOVQ MM1, [EDX+8]
                    xMOVQ_r_rm  (rMM1,rmIND8(rEDX)); xOFS8(8)

                    //MOVQ MM2, MM0
                    xMOVQ_r_rm(rMM2,rmREG(rMM0))
                    //MOVQ MM3, [EBX+M00] //1
                    xMOVQ_r_rm   (rMM3,rmIND32(rEBX)) xOFS32(OFFSETOF(CCelsiusState,mTransform) + 0)

                    xCMP_r_rm    (rEDX,rmREG(rEAX))

                    //PUNPCKLDQ MM0, MM0
                    xPUNPCKLDQ_r_rm(rMM0, rmREG(rMM0));
                    //MOVQ MM4, [EBX+M10] //2
                    xMOVQ_r_rm   (rMM4,rmIND32(rEBX)) xOFS32(OFFSETOF(CCelsiusState,mTransform) + 16)

                    xCMOVB_r_rm  (rEAX,rmREG(rEDX))

                    //PFMUL MM3, MM0
                    xPFMUL_r_rm(rMM3,rmREG(rMM0))
                    //PUNPCKHDQ MM2,MM2
                    xPUNPCKHDQ_r_rm(rMM2,rmREG(rMM2))

                    xMOV_i32_r   (mMEM32(global.celsius.dwTouchedMin),rEAX)

                    //PFMUL MM4, MM2
                    xPFMUL_r_rm(rMM4,rmREG(rMM2))
                    //MOVQ MM5, [EBX+M02] //3
                    xMOVQ_r_rm   (rMM5,rmIND32(rEBX)) xOFS32(OFFSETOF(CCelsiusState,mTransform) + 8)


                    //MOVQ MM7, [EBX+M12] //4
                    xMOVQ_r_rm   (rMM7,rmIND32(rEBX)) xOFS32(OFFSETOF(CCelsiusState,mTransform) + 24)
                    //MOVQ MM6, MM1
                    xMOVQ_r_rm(rMM6,rmREG(rMM1))


                    //==========don't move anything that's pipelined accross this line======
                    //switch to EAX for matrix base
                    xMOV_r_rm (rEAX, rmREG(rEBX))

                    //PFMUL MM5,MM0
                    xPFMUL_r_rm(rMM5,rmREG(rMM0))
                    //MOVQ MM0,[EAX+M20]  //5
                    xMOVQ_r_rm   (rMM0,rmIND32(rEAX)) xOFS32(OFFSETOF(CCelsiusState,mTransform) + 32)

                    //EBX -- merge in second part
                    xMOV_r_i32   (rEBX,mMEM32(global.celsius.dwTouchedMax))


                    //PUNPCKLDQ MM1, MM1
                    xPUNPCKLDQ_r_rm(rMM1,rmREG(rMM1))
                    //PFMUL MM7, MM2
                    xPFMUL_r_rm(rMM7,rmREG(rMM2))

                    //MOVQ MM2,[EAX+M22] //6
                    xMOVQ_r_rm   (rMM2,rmIND32(rEAX)) xOFS32(OFFSETOF(CCelsiusState,mTransform) + 40)
                    //PFMUL MM0,MM1
                    xPFMUL_r_rm(rMM0,rmREG(rMM1))

                    xCMP_r_rm    (rEDX,rmREG(rEBX))

                    //PFADD MM3, MM4
                    xPFADD_r_rm(rMM3,rmREG(rMM4))
                    //MOVQ MM4, [EAX+M30] //7
                    xMOVQ_r_rm   (rMM4,rmIND32(rEAX)) xOFS32(OFFSETOF(CCelsiusState,mTransform) + 48)

                    xCMOVA_r_rm  (rEBX,rmREG(rEDX))
                    xMOV_i32_r   (mMEM32(global.celsius.dwTouchedMax),rEBX)

                    //PFMUL MM2, MM1
                    xPFMUL_r_rm(rMM2,rmREG(rMM1))
                    //PFADD MM5, MM7
                    xPFADD_r_rm(rMM5,rmREG(rMM7))

                    //MOVQ MM1,[EAX+M32] //8
                    xMOVQ_r_rm   (rMM1,rmIND32(rEAX)) xOFS32(OFFSETOF(CCelsiusState,mTransform) + 56)
                    //PFADD MM3, MM0
                    xPFADD_r_rm(rMM3,rmREG(rMM0))

                    //PFADD MM5, MM2
                    xPFADD_r_rm(rMM5,rmREG(rMM2))
                    //PFADD MM3, MM4
                    xPFADD_r_rm(rMM3,rmREG(rMM4))

                    //MOVQ [EDX], MM3  Y X -> xy
                    xMOVQ_rm_r(rmIND(rECX),rMM3)

                    //PFADD  MM5, MM1
                    xPFADD_r_rm(rMM5,rmREG(rMM1))

                    //MOVQ [EDX+8], MM5 WZ -> zw
                    xMOVQ_rm_r(rmIND8(rECX),rMM5) xOFS8(8)


                    //xFEMMS
                    xEMMS




                    } ///xform and min/max loop
                    */

                    //             xMOV_r_i32  (rEBX,mMEM32(global.celsius.pContext))
                    //             xMOV_r_rm   (rEBX,rmIND32(rEBX)) xOFS32(OFFSETOF(NVD3DCONTEXT,dwRenderState[D3DRENDERSTATE_CLIPPING]))
                    //             xTEST_r_rm  (rEBX, rmREG(rEBX))
                    //             DWORD noClip = 0;
                    //             xLABEL      (noClip)
                    //             xJZ32       (0)


                    //
                    // generate out codes (under divide) (save ecx)
                    //

                    ///clear esi
                    xXOR_r_rm    (rESI,rmREG(rESI))
                    /// mov ebx, 1
                    xMOV_rm_imm  (rmREG(rEBX),1)
                    /// mov [ecx+16], dwtouchedmin
                    xMOV_rm_r    (rmIND8(rECX),rEAX) xOFS8(16)
                    xFLD_rm32    (rmIND8(rECX)) xOFS8(12)           // w
                    xFLD_st      (rST0)                             // w w
                    xFCHS                                           // -w w

                    // x < -w
                    xFLD_rm32    (rmIND(rECX))                      // x -w w
                    xXOR_r_rm    (rEAX,rmREG(rEAX))
                    xFCOMI_st    (rST1)                             // x -w w
                    xMOV_rm_imm  (rmREG(rEBX),1)
                    xCMOVB_r_rm  (rEAX,rmREG(rEBX))
                    xOR_r_rm     (rESI,rmREG(rEAX))

                    // x > w
                    xXOR_r_rm    (rEAX,rmREG(rEAX))
                    xFCOMIP_st   (rST2)                             // -w w
                    xMOV_rm_imm  (rmREG(rEBX),2)
                    xCMOVA_r_rm  (rEAX,rmREG(rEBX))
                    xOR_r_rm     (rESI,rmREG(rEAX))

                    // y < -w
                    xFLD_rm32    (rmIND8(rECX)) xOFS8(4)            // y -w w
                    xXOR_r_rm    (rEAX,rmREG(rEAX))
                    xFCOMI_st    (rST1)                             // y -w w
                    xMOV_rm_imm  (rmREG(rEBX),4)
                    xCMOVB_r_rm  (rEAX,rmREG(rEBX))
                    xOR_r_rm     (rESI,rmREG(rEAX))

                    // y > w
                    xXOR_r_rm    (rEAX,rmREG(rEAX))
                    xFCOMIP_st   (rST2)                             // -w w
                    xMOV_rm_imm  (rmREG(rEBX),8)
                    xCMOVA_r_rm  (rEAX,rmREG(rEBX))
                    xOR_r_rm     (rESI,rmREG(rEAX))

                    // z < 0
                    xFLDZ                                           // 0 -w w
                    xFLD_rm32    (rmIND8(rECX)) xOFS8(8)            // z 0 -w w
                    xXOR_r_rm    (rEAX,rmREG(rEAX))
                    xFCOMI_st    (rST1)                             // z 0 -w w
                    xMOV_rm_imm  (rmREG(rEBX),16)
                    xCMOVB_r_rm  (rEAX,rmREG(rEBX))
                    xOR_r_rm     (rESI,rmREG(rEAX))

                    // z > w
                    xXOR_r_rm    (rEAX,rmREG(rEAX))
                    xFCOMIP_st   (rST3)                             // 0 -w w
                    xMOV_rm_imm  (rmREG(rEBX),32)
                    xCMOVA_r_rm  (rEAX,rmREG(rEBX))
                    xOR_r_rm     (rESI,rmREG(rEAX))

                    xFFREE_st    (rST0)
                    xFINCSTP
                    xFFREE_st    (rST0)
                    xFINCSTP
                    xFFREE_st    (rST0)
                    xFINCSTP

                    xMOV_r_rm    (rEAX,rmIND8(rECX)) xOFS8(12)
                    xMOV_rm_r    (rmIND8(rECX),rESI) xOFS8(16)

                    //             xTARGET_b32  (noClip)

                    //
                    // store result of divide
                    //
                    ///katmai
                    if ((pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI))
                    {
                        ///store x/w y/w z/w w/w

                        // wzyx -> xyzw
                        xMOVAPS_rm_r (rmIND(rECX),rXMM1)
                        //!!! stores EAX tp ECX
                        xMOV_rm_r    (rmIND8(rECX),rEAX) xOFS8(20)


                    }
                    /*
                    else
                    {
                    ///3dnow, temporary, PIPELINE THE DIVIDE, REWRITE CLIP CODES TO 3DNOW AND MERGE

                    //xFEMMS
                    xEMMS

                    //reload vertex
                    //MOVQ MM0, [EDX]
                    ///0 =  Y X
                    xMOVQ_r_rm  (rMM0,rmIND(rECX));

                    //MOVQ MM1, [EDX+8]
                    ///1=  W Z
                    xMOVQ_r_rm  (rMM1,rmIND8(rECX)); xOFS8(8)

                    //2=W Z
                    xMOVQ_r_rm(rMM2,rmREG(rMM1))

                    //temp code
                    //4 = 0 W
                    xMOVD_r_rm(rMM4, rmIND8(rECX)) xOFS8(12)
                    xPFRCP_r_rm (rMM2,rmREG(rMM4))
                    xPFRCPIT1_r_rm (rMM4,rmREG(rMM2))
                    xPFRCPIT2_r_rm (rMM4,rmREG(rMM2))


                    //expand w
                    //2 = W W
                    //xPUNPCKHDQ_r_rm(rMM2,rmREG(rMM2))
                    // 1/w | 1/w
                    //xPFRCP_r_rm (rMM2,rmREG(rMM2))
                    //xPFRCPIT1_r_rm (rMM2,rmREG(rMM2))
                    //xPFRCPIT2_r_rm (rMM2,rmREG(rMM2))

                    //y/w, x/w
                    xPFMUL_r_rm(rMM0,rmREG(rMM2))  //was2
                    //w/w z/w
                    xPFMUL_r_rm(rMM1,rmREG(rMM2))  //was2

                    //store y,x
                    xMOVQ_rm_r(rmIND(rECX),rMM0);


                    //store w,z
                    xMOVQ_rm_r(rmIND8(rECX),rMM1) xOFS8(8)
                    //xPSWAPD_r_rm(rMM4,rmREG(rMM1))
                    //xMOVQ_rm_r(rmIND8(rECX),rMM4) xOFS8(8)

                    //stores EAX to ECX (kni does it)
                    xMOV_rm_r    (rmIND8(rECX),rEAX) xOFS8(20)

                    ///xFEMMS


                    xMOVD_r_rm(rMM0, rmIND8(rECX)) xOFS8(12)
                    xPFRCP_r_rm (rMM1,rmREG(rMM0))
                    xPUNPCKHDQ_r_rm(rMM0,rmREG(rMM0))
                    xPFRCPIT1_r_rm (rMM0,rmREG(rMM1))

                    xMOVQ_r_rm  (rMM2,rmIND(rECX));
                    xMOVQ_r_rm  (rMM3,rmIND8(rECX)); xOFS8(8)

                    xPFRCPIT2_r_rm (rMM0,rmREG(rMM1))

                    xPFMUL_r_rm(rMM2,rmREG(rMM0))
                    xPFMUL_r_rm(rMM3,rmREG(rMM0))

                    xMOVQ_rm_r(rmIND(rECX),rMM2);
                    xMOVQ_rm_r(rmIND8(rECX),rMM3) xOFS8(8)


                    //stores EAX to ECX (kni does it)
                    xMOV_rm_r    (rmIND8(rECX),rEAX) xOFS8(20)

                    xEMMS

                    }
                    */

                    xTARGET_b32 (cacheHit)

                    // instrumentation
    #ifdef INSTRUMENT_INNER_LOOPS
                    xMOV_rm_imm (rmREG(rEAX),global.kelvin.dwVertexStride) // not sizeof(CVertexBuffer::STVERTEX) since we compute effective efficiency
                    xADD_i32_r  (mMEM32(global.dwBytesCopied),rEAX)
    #endif
                }

                //
                // prepare for reject & cull
                //
                xMOV_r_i32  (rEBX,mMEM32(global.dwVertex0))
                xMOV_r_i32  (rECX,mMEM32(global.dwVertex1))
                xMOV_r_i32  (rEDX,mMEM32(global.dwVertex2))

                //
                // do trivial reject (save ebx,ecx,edx)
                //
                DWORD trivialReject = 0;

                xMOV_r_rm   (rEAX,rmIND8(rEBX)) xOFS8(16)
                xAND_r_rm   (rEAX,rmIND8(rECX)) xOFS8(16)
                xAND_r_rm   (rEAX,rmIND8(rEDX)) xOFS8(16)
                xLABEL      (trivialReject)
                xJNZ32      (0)

                //
                // do a cull check
                //

                DWORD cullCheck = 0;
                ///turn culling off temporarly, REMOVE
                //dwFlags |= KELVIN_ILFLAG_NOCULL;

                //katmai
                if ((pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI))
                {

                    if (!(dwFlags & KELVIN_ILFLAG_NOCULL))
                    {
                        //reads EBX,ECX,EDX

                        //0: W0 Z0 X0 Y0
                        xMOVAPS_r_rm     (rXMM0,rmIND(rEBX))
                        //1: W1 Z1 X1 Y1
                        xMOVAPS_r_rm     (rXMM1,rmIND(rECX))
                        //2: W2 Z2 X2 Y2
                        xMOVAPS_r_rm     (rXMM2,rmIND(rEDX))
                        //1: W10 Z10 Y10 X10
                        xSUBPS_r_rm      (rXMM1,rmREG(rXMM0))
                        //2: W20 Z20 Y20 X20
                        xSUBPS_r_rm      (rXMM2,rmREG(rXMM0))

                        //0: W10 Z10 Y10 X10
                        xMOVAPS_r_rm     (rXMM0,rmREG(rXMM1))
                        //3: W20 Z20 Y20 X20
                        xMOVAPS_r_rm     (rXMM3,rmREG(rXMM2))

                        //1: Y10 Y10 Y10 Y10
                        xSHUFPS_r_rm_imm (rXMM1,rmREG(rXMM1),1)
                        //2: Y20 Y20 Y20 Y20
                        xSHUFPS_r_rm_imm (rXMM3,rmREG(rXMM3),1)

                        //0: W10 Z10 Y10 X10*Y20
                        xMULSS_r_rm      (rXMM0,rmREG(rXMM3))

                        xMOV_r_rm        (rEAX,rmIND8(rEBX)) xOFS8(20)
                        xXOR_r_rm        (rEAX,rmIND8(rECX)) xOFS8(20)

                        //1: Y10 Y10 Y10 Y10*X20
                        xMULSS_r_rm      (rXMM1,rmREG(rXMM2))
                        xXOR_r_rm        (rEAX,rmIND8(rEDX)) xOFS8(20)

                        //1: Y10*Y20 - X10*X20
                        xSUBSS_r_rm      (rXMM1,rmREG(rXMM0))
                        xMOVSS_i32_r     (mMEM32(global.dwTemp),rXMM1)

                        xMOV_r_i32       (rEBX,mMEM32(global.dwTemp))
                        xXOR_r_rm        (rEBX,rmREG(rEAX))
                        xAND_rm_imm      (rmREG(rEBX),0x80000000)
                        xCMP_r_i32       (rEBX,mMEM32(global.kelvin.dwCullValue))
                        xLABEL           (cullCheck)
                        xJZ32            (0)
                    }

                }
                /*
                else
                {
                //3dnow
                if (!(dwFlags & KELVIN_ILFLAG_NOCULL))
                {

                ///xFEMMS
                xEMMS
                // Y0 | X0
                xMOVQ_r_rm     (rMM0,rmIND(rEBX))
                // Y1 | X1
                xMOVQ_r_rm     (rMM1,rmIND(rECX))
                // Y2 | X2
                xMOVQ_r_rm     (rMM2,rmIND(rEDX))
                // Y10 | X10
                xPFSUB_r_rm    (rMM1, rmREG(rMM0))
                // Y20 | X20
                xPFSUB_r_rm   (rMM2, rmREG(rMM0))
                // X10 | Y10
                xPSWAPD_r_rm (rMM1, rmREG(rMM1))
                //Y20*X10 | X20*Y10
                xPFMUL_r_rm (rMM1,rmREG(rMM2))
                // whatever | X20*Y10 - Y20*X10
                xPFNACC_r_rm (rMM1, rmREG(rMM1))

                //embed in above
                xMOV_r_rm        (rEAX,rmIND8(rEBX)) xOFS8(20)
                xXOR_r_rm        (rEAX,rmIND8(rECX)) xOFS8(20)
                xXOR_r_rm        (rEAX,rmIND8(rEDX)) xOFS8(20)


                //store that stuff
                //xMOVD_r_rm     (mMEM32(global.dwTemp),rMM1)
                xMOVD_r_rm (rEBX,rmREG(rMM1))

                //try to remove
                //xFEMMS
                xEMMS

                //this has to be after the store
                //xMOV_r_i32       (rEBX,mMEM32(global.dwTemp))
                xXOR_r_rm        (rEBX,rmREG(rEAX))
                xAND_rm_imm      (rmREG(rEBX),0x80000000)
                xCMP_r_i32       (rEBX,mMEM32(global.kelvin.dwCullValue))
                xLABEL           (cullCheck)
                xJZ32            (0)
                }
                }
                */

                //
                // dispatch
                //
                //katmai, okay
                if ((pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI))
                {

                    xMOVAPS_r_i128 (rXMM0,KNIMEM(dwKelvinTriDispatch))
                    if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_WILLAMETTE)
                    {
                        xMOVAPS_rm_r   (rmIND(rEDI),rXMM0)
                    }
                    else
                    {
                        xMOVNTPS_rm_r  (rmIND(rEDI),rXMM0)
                    }
                    xLEA_r_rm      (rEDI,rmIND8(rEDI)) xOFS8(16)

                }
                else
                {

                    //generic, if you keep emms, replace with femms.
                    xEMMS
                    xMOVQ_r_i64(rMM1,KNIMEM(dwKelvinTriDispatch))
                    xMOVQ_r_i64(rMM2,KNIMEM(dwKelvinTriDispatch)+8)
                    xMOVNTQ_rm_r (rmIND(rEDI),rMM1)
                    xMOVNTQ_rm_r (rmIND8(rEDI),rMM2) xOFS8(8)
                    xLEA_r_rm      (rEDI,rmIND8(rEDI)) xOFS8(16)
                    xEMMS
                }
                //
                // send more triangles after this one, utilizing connectivity statistics
                //
    #if 1
                // SK -- even though the super-tri code is faster now, this is still a winning bet!
                const int count = 4; // do not exceed 128 words (about 14 of these)
                DWORD sendMore;
                xPOP_r      (rECX)
                xCMP_rm_imm (rmREG(rECX),count)
                xLABEL      (sendMore)
                xJLE32      (0)

                xMOV_r_i32  (rESI,mMEM32(global.kelvin.pIndices))
                for (i = 0; i < count; i++)
                {
                    // prep tri
                    xLEA_r_rm   (rESI,rmIND8(rESI)) xOFS8(6)
                    xXOR_r_rm   (rEBX,rmREG(rEBX))
                    xMOV_r_rm   (rEAX,rmIND(rESI))
                    x16r xMOV_r_rm   (rBX,rmIND8(rESI)) xOFS8(4)
                    xMOV_r_rm   (rEDX,rmREG(rEAX))
                    xAND_rm_imm (rmREG(rEAX),0xffff)
                    xADD_r_i32  (rEBX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                    xMOV_i32_r  (KNIMEM(dwKelvinTriDispatch) + 12,rEBX)
                    xSHR_rm_imm8(rmREG(rEDX),16)
                    xADD_r_i32  (rEAX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                    xMOV_i32_r  (KNIMEM(dwKelvinTriDispatch) + 4,rEAX)
                    xADD_r_i32  (rEDX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                    xMOV_i32_r  (KNIMEM(dwKelvinTriDispatch) + 8,rEDX)

                    // dispatch
                    //katmai, eek
                    if ((pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI))
                    {
                        xMOVAPS_r_i128 (rXMM0,KNIMEM(dwKelvinTriDispatch))
                        if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_WILLAMETTE)
                        {
                            xMOVAPS_rm_r   (rmIND(rEDI),rXMM0)
                        }
                        else
                        {
                            xMOVNTPS_rm_r  (rmIND(rEDI),rXMM0)
                        }
                        xLEA_r_rm      (rEDI,rmIND8(rEDI)) xOFS8(16)
                    }
                    else
                    {

                        ////generic
                        xEMMS
                        xMOVQ_r_i64(rMM1,KNIMEM(dwKelvinTriDispatch))
                        xMOVQ_r_i64(rMM2,KNIMEM(dwKelvinTriDispatch)+8)
                        xMOVNTQ_rm_r (rmIND(rEDI),rMM1)
                        xMOVNTQ_rm_r (rmIND8(rEDI),rMM2) xOFS8(8)
                        xLEA_r_rm      (rEDI,rmIND8(rEDI)) xOFS8(16)
                        xEMMS
                    }


                }
                xSUB_rm_imm (rmREG(rECX),count)
                xMOV_i32_r  (mMEM32(global.kelvin.pIndices),rESI)
                xTARGET_b32 (sendMore)
                xPUSH_r     (rECX)
    #endif
                // check for pusher space
                DWORD labelSpace;
                xMOV_r_i32  (rESI,mMEM32(pDriverData))
                xCMP_r_rm   (rEDI,rmIND32(rESI)) xOFS32(OFFSETOF(CDriverContext, nvPusher.m_dwThreshold))
                xLABEL      (labelSpace)
                xJL         (0)
                {
                    xMOV_rm_imm (rmREG(rEBX),(DWORD)nvKelvinDispatchGetPusherSpace)
                    xMOV_rm_r   (rmIND32(rESI),rEDI) xOFS32(OFFSETOF(CDriverContext, nvPusher.m_dwPut))
                    xCALL_rm    (rmREG(rEBX))
                    xMOV_r_rm   (rEDI,rmIND32(rESI)) xOFS32(OFFSETOF(CDriverContext, nvPusher.m_dwPut))
                }
                xTARGET_b8  (labelSpace)

                //
                // next triangle
                //
                if (trivialReject)
                { xTARGET_b32 (trivialReject)
                }
                if (cullCheck)
                { xTARGET_b32 (cullCheck)
                }
                xMOV_r_i32  (rESI,mMEM32(global.kelvin.pIndices))
                xPOP_r      (rECX)
                xLEA_r_rm   (rESI,rmIND8(rESI)) xOFS8(6)
                xDEC_rm     (rmREG(rECX))
                xMOV_i32_r  (mMEM32(global.kelvin.pIndices),rESI)
                xJNZ32      (again)
            }

            //
            // end primitive
            //
            xMOVQ_r_i64  (rMM0,mMEM64(global.kelvin.qwEnd))
            xMOVNTQ_rm_r (rmIND(rEDI),rMM0)
            xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(8)
            xEMMS


            //***********************************************************************************************
            //                          Model Space Culling
            //***********************************************************************************************
        }
        else if (pContext->hwState.SuperTri.isModelCull())
        {


#ifdef SW_WC
#define NVPUSHER_NV097_ARRAY_ELELMENT32 ((((3) << 2) << 16) | ((NV_DD_KELVIN) << 13) | (NVPUSHER_NOINC(NV097_ARRAY_ELEMENT32)))
#endif
//#define NO_RAW1
//#define NO_RAW2
            //
            // start primitive
            //
            xMOVQ_r_i64  (rMM0,mMEM64(global.kelvin.qwBegin))
            xMOVNTQ_rm_r (rmIND(rEDI),rMM0)
            xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(8)
            xEMMS


            //
            // setup
            //
            xMOV_r_i32  (rEAX,mMEM32(global.dwVertexSN))
            xADD_rm_imm (rmREG(rEAX),0x10000)
            xMOV_i32_r  (mMEM32(global.dwVertexSN),rEAX)

            xMOV_r_i32  (rESI,mMEM32(global.kelvin.pIndices))
            xMOV_r_i32  (rECX,mMEM32(global.kelvin.dwPrimCount))
            xLEA_r_rm   (rEAX,rmSIB) xSIB(rECX,rECX,x2)
            xMOV_i32_r  (mMEM32(global.kelvin.dwPrefetchBase),rESI)
            xLEA_r_rm   (rEAX,rmSIB) xSIB(rEAX,rEAX,x1)
            xMOV_i32_r  (mMEM32(global.kelvin.dwPrefetchMax),rEAX)

            // eye point in model space

            xMOV_r_i32 (rEAX,mMEM32(global.kelvin.dwEyeAddr))

            xMOVLPS_r_rm (rXMM7,rmIND(rEAX)) 
            xMOVHPS_r_rm (rXMM7,rmIND8(rEAX)) xOFS8(8)

#ifdef SW_WC
            // Setup SW WC pointers
            xXOR_r_rm   (rEBP, rmREG(rEBP))

#endif

            //
            // process all triangles
            //
            DWORD again;
            xLABEL  (again)
            xPUSH_r (rECX)

            //
            DWORD cullCheck = 0;
#ifdef SW_WC
            DWORD cullCheck2 = 0;
#endif
            if (!(dwFlags & KELVIN_ILFLAG_NOCULL))
            {
                // get index
                //clear EDX

#ifdef SW_WC
                xMOV_rm_imm(rmREG(rEDX), NVPUSHER_NV097_ARRAY_ELELMENT32)
                xMOV_rm_r(rmIND32(rEBP), rEDX) xOFS32(KNIMEM(dwKelvinTriDispatch))
#endif
                // Vertex 0
//#ifdef SW_WC
//        #define STMC_PREF_DIST 0x60
//#else
        #define STMC_PREF_DIST 0x40
//#endif
                xXOR_r_rm   (rEDX,rmREG(rEDX))

                xMOV_r_i32  (rESI,mMEM32(global.kelvin.pIndices))
                x16r xMOV_r_rm   (rDX,rmIND8(rESI)) xOFS8(0*2)
                xADD_r_i32       (rEDX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
#ifdef SW_WC
                xMOV_rm_r(rmIND32(rEBP), rEDX) xOFS32(KNIMEM(dwKelvinTriDispatch)+1*4)
#else
#ifndef NO_RAW1
                xMOV_i32_r  (KNIMEM(dwKelvinTriDispatch) + 4 + 0*4,rEDX)
#endif
#endif

                // compute vertex address into edx
                ILCCompile_mul (rEDX,pContext->hwState.SuperTri.getSTLBStride());
                xADD_r_i32     (rEDX,mMEM32(global.kelvin.pVertices))

                xMOV_r_rm   (rEAX, rmREG(rEDX))
                if ((pContext->hwState.SuperTri.getSTLBStride() & 0xf) != 0)
                {
                    xMOVLPS_r_rm (rXMM0, rmIND(rEDX))
                    xMOVHPS_r_rm (rXMM0, rmIND8(rEDX)) xOFS8(8)
                }
                else
                {
                    xMOVAPS_r_rm (rXMM0, rmIND(rEDX))
                }

                // Vertex 1
                xXOR_r_rm   (rEDX,rmREG(rEDX))

                x16r xMOV_r_rm   (rDX,rmIND8(rESI)) xOFS8(1*2)
                xADD_r_i32       (rEDX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
#ifdef SW_WC
                xMOV_rm_r(rmIND32(rEBP), rEDX) xOFS32(KNIMEM(dwKelvinTriDispatch)+2*4)
#else
#ifndef NO_RAW1
                xMOV_i32_r  (KNIMEM(dwKelvinTriDispatch) + 4 + 1*4,rEDX)
#endif
#endif
                // compute vertex address into edx
                ILCCompile_mul (rEDX,pContext->hwState.SuperTri.getSTLBStride());
                xADD_r_i32     (rEDX,mMEM32(global.kelvin.pVertices))

                xMOV_r_rm   (rEBX, rmREG(rEDX))
                if ((pContext->hwState.SuperTri.getSTLBStride() & 0xf) != 0)
                {
                    xMOVLPS_r_rm (rXMM1, rmIND(rEDX))
                    xMOVHPS_r_rm (rXMM1, rmIND8(rEDX)) xOFS8(8)
                }
                else
                {
                    xMOVAPS_r_rm (rXMM1, rmIND(rEDX))
                }

                // Vertex 2
                xXOR_r_rm   (rEDX,rmREG(rEDX))

                x16r xMOV_r_rm   (rDX,rmIND8(rESI)) xOFS8(2*2)
                xADD_r_i32       (rEDX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
#ifdef SW_WC
                xMOV_rm_r(rmIND32(rEBP), rEDX) xOFS32(KNIMEM(dwKelvinTriDispatch)+3*4)
#else
#ifndef NO_RAW1
                xMOV_i32_r  (KNIMEM(dwKelvinTriDispatch) + 4 + 2*4,rEDX)
#endif
#endif

                // compute vertex address into edx
                ILCCompile_mul (rEDX,pContext->hwState.SuperTri.getSTLBStride());
                xADD_r_i32      (rEDX,mMEM32(global.kelvin.pVertices))

                xMOV_r_rm   (rECX, rmREG(rEDX))
                if ((pContext->hwState.SuperTri.getSTLBStride() & 0xf) != 0)
                {
                    xMOVLPS_r_rm    (rXMM2, rmIND(rEDX))
                    xMOVHPS_r_rm    (rXMM2, rmIND8(rEDX)) xOFS8(8)
                }
                else
                {
                    xMOVAPS_r_rm (rXMM2, rmIND(rEDX))
                }

                // Compute eye vector

                xCMP_r_rm   (rEBX, rmREG(rEAX))

                xMOVAPS_r_rm    (rXMM6, rmREG(rXMM7))       //xmm6 = eye point
                xSUBPS_r_rm     (rXMM6, rmREG(rXMM0))       //xmm6 = eye vec

                // Compute Normal
                xCMOVA_r_rm (rEAX, rmREG(rEBX))

                xSUBPS_r_rm     (rXMM1, rmREG(rXMM0))       //v1 - v0 = v10
                xMOVAPS_r_rm    (rXMM3, rmREG(rXMM1))       //v1 - v0 = v10


                xSHUFPS_r_rm_imm (rXMM1,rmREG(rXMM1),0xC9)  //xmm1 = 1.0 v10.x v10.z v10.y

                xCMP_r_rm   (rECX, rmREG(rEAX))

                xSHUFPS_r_rm_imm (rXMM3,rmREG(rXMM3),0xD2)  //xmm3 = 1.0 v10.y v10.x v10.z


                xSUBPS_r_rm     (rXMM2, rmREG(rXMM0))       //v2 - v0 = v20
                xMOVAPS_r_rm    (rXMM4, rmREG(rXMM2))       //v2 - v0 = v20


                xSHUFPS_r_rm_imm (rXMM2, rmREG(rXMM2),0xC9) //xmm2 = 1.0 v20.x v20.z v20. y
                xCMOVA_r_rm (rEAX, rmREG(rECX))
                xSHUFPS_r_rm_imm (rXMM4, rmREG(rXMM4),0xD2) //xmm4 = 1.0 v20.y v20.x v20.z

                xMULPS_r_rm     (rXMM1, rmREG(rXMM4))
                xAND_rm_imm (rmREG(rEAX), ~0x1f)
                xMULPS_r_rm     (rXMM2, rmREG(rXMM3))

                if (pContext->hwState.SuperTri.isFixedLBStride())
                {
                    xPREFETCH_rm8(1, rmIND8(rEAX), STMC_PREF_DIST)
                }
                else
                {
                    if ((4 * pContext->hwState.SuperTri.getSTLBStride()) < 128) {
                        xPREFETCH_rm8(1, rmIND8(rEAX), 4 * pContext->hwState.SuperTri.getSTLBStride())
                    }
                    else {
                        xADD_rm_imm(rmREG(rEAX), 4 * pContext->hwState.SuperTri.getSTLBStride())
                        xPREFETCH_rm8(1, rmIND8(rEAX), 0)
                    }
                }

                xSUBPS_r_rm     (rXMM1, rmREG(rXMM2))       //xmm1 = 0.0 Z' Y' X'

                // Dot eye vector with normal

                xMULPS_r_rm     (rXMM1, rmREG(rXMM6))       // xxx n.z*v.z n.y*v.y n.x*v.x
                xMOVAPS_r_rm    (rXMM0, rmREG(rXMM1))
                xMOVAPS_r_rm    (rXMM2, rmREG(rXMM1))
                xSHUFPS_r_rm_imm (rXMM0, rmREG(rXMM0), 0x01)
                xMOV_r_i32      (rEAX,mMEM32(global.kelvin.dwCullAddr))
                xMOV_r_rm       (rEBX,rmIND(rEAX)) 
                xSHUFPS_r_rm_imm (rXMM2, rmREG(rXMM2), 0x02)
                xADDSS_r_rm     (rXMM0, rmREG(rXMM1))
                xADDSS_r_rm     (rXMM0, rmREG(rXMM2))

                // Extract sign bit from dot product

                xMOVMSKPS_r_r   (rEAX, rmREG(rXMM0))
                xXOR_r_rm       (rEAX, rmREG(rEBX))

//                 xXOR_rm_imm     (rmREG(rEAX), 0x00000001)
                xTEST_rm_imm    (rmREG(rEAX), 0x00000001)


                //reads EBX,ECX,EDX

                xLABEL           (cullCheck)
//                 xJNZ32            (0)
                xJZ32            (0)


#ifdef SW_WC
                xLEA_r_rm      (rEBP,rmIND8(rEBP)) xOFS8(16)
//                 xADD_r_rm       (rEBP, rmREG(rEBX))
#endif


            }
            else
            {
#ifdef SW_WC
                xMOV_rm_imm     (rmREG(rEDX), NVPUSHER_NV097_ARRAY_ELELMENT32)
                xMOV_rm_r       (rmIND32(rEBP), rEDX) xOFS32(KNIMEM(dwKelvinTriDispatch))

                xXOR_r_rm       (rEDX,rmREG(rEDX))

                xMOV_r_i32      (rESI,mMEM32(global.kelvin.pIndices))
                x16r xMOV_r_rm  (rDX,rmIND8(rESI)) xOFS8(0*2)
                xADD_r_i32       (rEDX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                xMOV_rm_r       (rmIND32(rEBP), rEDX) xOFS32(KNIMEM(dwKelvinTriDispatch)+1*4)

                x16r xMOV_r_rm  (rDX,rmIND8(rESI)) xOFS8(1*2)
                xADD_r_i32       (rEDX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                xMOV_rm_r       (rmIND32(rEBP), rEDX) xOFS32(KNIMEM(dwKelvinTriDispatch)+2*4)

                x16r xMOV_r_rm  (rDX,rmIND8(rESI)) xOFS8(2*2)
                xADD_r_i32       (rEDX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                xMOV_rm_r       (rmIND32(rEBP), rEDX) xOFS32(KNIMEM(dwKelvinTriDispatch)+3*4)
                xLEA_r_rm       (rEBP,rmIND8(rEBP)) xOFS8(16)
#else
#ifndef NO_RAW1
                xXOR_r_rm   (rEDX,rmREG(rEDX))

                xMOV_r_i32  (rESI,mMEM32(global.kelvin.pIndices))
                x16r xMOV_r_rm   (rDX,rmIND8(rESI)) xOFS8(0*2)
                xADD_r_i32       (rEDX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                xMOV_i32_r  (KNIMEM(dwKelvinTriDispatch) + 4 + 0*4,rEDX)

                x16r xMOV_r_rm   (rDX,rmIND8(rESI)) xOFS8(1*2)
                xADD_r_i32       (rEDX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                xMOV_i32_r  (KNIMEM(dwKelvinTriDispatch) + 4 + 1*4,rEDX)

                x16r xMOV_r_rm   (rDX,rmIND8(rESI)) xOFS8(2*2)
                xADD_r_i32       (rEDX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                xMOV_i32_r  (KNIMEM(dwKelvinTriDispatch) + 4 + 2*4,rEDX)
#endif
#endif
            }

            //
            // dispatch
            //
            //katmai, okay
#ifdef SW_WC
            xCMP_rm_imm     (rmREG(rEBP), SW_WC_BYTES)
            xLABEL          (cullCheck2)
            xJNZ32          (0)


            DWORD labelFlush0;
            xMOV_rm_imm (rmREG(rESI), KNIMEM(dwKelvinTriDispatch))
            xLABEL      (labelFlush0)
            xMOV_r_rm   (rEAX, rmIND(rESI))
            xMOV_rm_r   (rmIND(rEDI), rEAX)
            xMOV_r_rm   (rEAX, rmIND8(rESI)) xOFS8(4)
            xMOV_rm_r   (rmIND8(rEDI), rEAX) xOFS8(4)
            xMOV_r_rm   (rEAX, rmIND8(rESI)) xOFS8(8)
            xMOV_rm_r   (rmIND8(rEDI), rEAX) xOFS8(8)
            xMOV_r_rm   (rEAX, rmIND8(rESI)) xOFS8(12)
            xMOV_rm_r   (rmIND8(rEDI), rEAX) xOFS8(12)
            xLEA_r_rm   (rESI, rmIND8(rESI)) xOFS8(16)
            xLEA_r_rm   (rEDI, rmIND8(rEDI)) xOFS8(16)
            xSUB_rm_imm (rmREG(rEBP), 16)
            xJNZ        (labelFlush0)

//
//             for (int i = 0;i < SW_WC_LINES2FILL ;i++)
//             {
//                 xMOVAPS_r_i128  (rXMM0,KNIMEM(dwKelvinTriDispatch)+(i*64)+0*16)
//                 xMOVAPS_r_i128  (rXMM1,KNIMEM(dwKelvinTriDispatch)+(i*64)+1*16)
//                 xMOVAPS_r_i128  (rXMM2,KNIMEM(dwKelvinTriDispatch)+(i*64)+2*16)
//                 xMOVAPS_r_i128  (rXMM3,KNIMEM(dwKelvinTriDispatch)+(i*64)+3*16)
//                 xMOVAPS_rm_r   (rmIND32(rEDI),rXMM0) xOFS32(i*64+0*16)
//                 xMOVAPS_rm_r   (rmIND32(rEDI),rXMM1) xOFS32(i*64+1*16)
//                 xMOVAPS_rm_r   (rmIND32(rEDI),rXMM2) xOFS32(i*64+2*16)
//                 xMOVAPS_rm_r   (rmIND32(rEDI),rXMM3) xOFS32(i*64+3*16)
//
//             }
//             xLEA_r_rm      (rEDI,rmIND32(rEDI)) xOFS32(SW_WC_BYTES)
            xXOR_r_rm   (rEBP, rmREG(rEBP))


#else
#ifdef NO_RAW1

                xMOV_r_i32  (rESI,mMEM32(global.kelvin.pIndices))
                xMOV_r_i32  (rEDX, KNIMEM(dwKelvinTriDispatch))
                xMOV_rm_r   (rmIND(rEDI), rEDX)

                xXOR_r_rm   (rEDX,rmREG(rEDX))

                x16r xMOV_r_rm   (rDX,rmIND(rESI))
                xADD_r_i32       (rEDX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                xMOV_rm_r  (rmIND8(rEDI),rEDX) xOFS8(1*4)

                x16r xMOV_r_rm   (rDX,rmIND8(rESI)) xOFS8(1*2)
                xADD_r_i32       (rEDX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                xMOV_rm_r  (rmIND8(rEDI),rEDX) xOFS8(2*4)

                x16r xMOV_r_rm   (rDX,rmIND8(rESI)) xOFS8(2*2)
                xADD_r_i32       (rEDX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                xMOV_rm_r  (rmIND8(rEDI),rEDX) xOFS8(3*4)
                xLEA_r_rm      (rEDI,rmIND8(rEDI)) xOFS8(16)
#else // old code
            if ((pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI))
            {

                xMOVAPS_r_i128 (rXMM0,KNIMEM(dwKelvinTriDispatch))
                if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_WILLAMETTE)
                {
                    xMOVAPS_rm_r   (rmIND(rEDI),rXMM0)
                }
                else
                {
                    xMOVNTPS_rm_r  (rmIND(rEDI),rXMM0)
                }
                xLEA_r_rm      (rEDI,rmIND8(rEDI)) xOFS8(16)

            }
            else
            {

                //generic, if you keep emms, replace with femms.
                xEMMS
                xMOVQ_r_i64(rMM1,KNIMEM(dwKelvinTriDispatch))
                xMOVQ_r_i64(rMM2,KNIMEM(dwKelvinTriDispatch)+8)
                xMOVNTQ_rm_r (rmIND(rEDI),rMM1)
                xMOVNTQ_rm_r (rmIND8(rEDI),rMM2) xOFS8(8)
                xLEA_r_rm      (rEDI,rmIND8(rEDI)) xOFS8(16)
                xEMMS
            }
#endif
#endif

#ifndef SW_WC
            //
            // send more triangles after this one, utilizing connectivity statistics
            //
    #ifdef NO_RAW2
            if (!pContext->hwState.SuperTri.isCheckAll() || (dwFlags & KELVIN_ILFLAG_NOCULL))
            {
                const int count = 4; // do not exceed 128 words (about 14 of these)
                DWORD sendMore;
                xPOP_r      (rECX)
                xCMP_rm_imm (rmREG(rECX),count)
                xLABEL      (sendMore)
                xJLE32      (0)

                xMOV_r_i32  (rESI,mMEM32(global.kelvin.pIndices))
                xMOV_r_i32  (rEDX, KNIMEM(dwKelvinTriDispatch))
                for (int i = 0; i < count; i++)
                {
                    // prep tri
                    xLEA_r_rm   (rESI,rmIND8(rESI)) xOFS8(6)
                    xMOV_rm_r   (rmIND(rEDI), rEDX)

                    xXOR_r_rm   (rEBX,rmREG(rEBX))

                    x16r xMOV_r_rm   (rBX,rmIND(rESI))
                    xADD_r_i32       (rEBX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                    xMOV_rm_r  (rmIND8(rEDI),rEBX) xOFS8(1*4)

                    x16r xMOV_r_rm   (rBX,rmIND8(rESI)) xOFS8(1*2)
                    xADD_r_i32       (rEBX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                    xMOV_rm_r  (rmIND8(rEDI),rEBX) xOFS8(2*4)

                    x16r xMOV_r_rm   (rBX,rmIND8(rESI)) xOFS8(2*2)
                    xADD_r_i32       (rEBX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                    xMOV_rm_r  (rmIND8(rEDI),rEBX) xOFS8(3*4)
                    xLEA_r_rm      (rEDI,rmIND8(rEDI)) xOFS8(16)

                }
                xSUB_rm_imm (rmREG(rECX),count)
                xMOV_i32_r  (mMEM32(global.kelvin.pIndices),rESI)
                xTARGET_b32 (sendMore)
                xPUSH_r     (rECX)
            }
    #else
            if (!pContext->hwState.SuperTri.isCheckAll() || (dwFlags & KELVIN_ILFLAG_NOCULL))
            {
                const int count = 4; // do not exceed 128 words (about 14 of these)
                DWORD sendMore;
                xPOP_r      (rECX)
                xCMP_rm_imm (rmREG(rECX),count)
                xLABEL      (sendMore)
                xJLE32      (0)

                xMOV_r_i32  (rESI,mMEM32(global.kelvin.pIndices))
                for (int i = 0; i < count; i++)
                {
                    // prep tri
                    xLEA_r_rm   (rESI,rmIND8(rESI)) xOFS8(6)
                    xXOR_r_rm   (rEBX,rmREG(rEBX))
                    xMOV_r_rm   (rEAX,rmIND(rESI))
                    x16r xMOV_r_rm   (rBX,rmIND8(rESI)) xOFS8(4)
                    xADD_r_i32       (rEBX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                    xMOV_r_rm   (rEDX,rmREG(rEAX))
                    xAND_rm_imm (rmREG(rEAX),0xffff)
                    xADD_r_i32       (rEAX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                    xMOV_i32_r  (KNIMEM(dwKelvinTriDispatch) + 12,rEBX)
                    xSHR_rm_imm8(rmREG(rEDX),16)
                    xADD_r_i32       (rEDX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                    xMOV_i32_r  (KNIMEM(dwKelvinTriDispatch) + 4,rEAX)
                    xMOV_i32_r  (KNIMEM(dwKelvinTriDispatch) + 8,rEDX)

                    // dispatch
                    //katmai, eek
                    if ((pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI))
                    {
                        xMOVAPS_r_i128 (rXMM0,KNIMEM(dwKelvinTriDispatch))
                        if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_WILLAMETTE)
                        {
                            xMOVAPS_rm_r   (rmIND(rEDI),rXMM0)
                        }
                        else
                        {
                            xMOVNTPS_rm_r  (rmIND(rEDI),rXMM0)
                        }
                        xLEA_r_rm      (rEDI,rmIND8(rEDI)) xOFS8(16)
                    }
                    else
                    {

                        ////generic
                        xEMMS
                        xMOVQ_r_i64(rMM1,KNIMEM(dwKelvinTriDispatch))
                        xMOVQ_r_i64(rMM2,KNIMEM(dwKelvinTriDispatch)+8)
                        xMOVNTQ_rm_r (rmIND(rEDI),rMM1)
                        xMOVNTQ_rm_r (rmIND8(rEDI),rMM2) xOFS8(8)
                        xLEA_r_rm      (rEDI,rmIND8(rEDI)) xOFS8(16)
                        xEMMS
                    }


                }
                xSUB_rm_imm (rmREG(rECX),count)
                xMOV_i32_r  (mMEM32(global.kelvin.pIndices),rESI)
                xTARGET_b32 (sendMore)
                xPUSH_r     (rECX)
            }
    #endif
#endif //SW_WC
            // check for pusher space
            DWORD labelSpace;
            xMOV_r_i32  (rESI,mMEM32(pDriverData))
            xCMP_r_rm   (rEDI,rmIND32(rESI)) xOFS32(OFFSETOF(CDriverContext, nvPusher.m_dwThreshold))
            xLABEL      (labelSpace)
            xJL         (0)
            {
                xMOV_rm_imm (rmREG(rEBX),(DWORD)nvKelvinDispatchGetPusherSpace)
                xMOV_rm_r   (rmIND32(rESI),rEDI) xOFS32(OFFSETOF(CDriverContext, nvPusher.m_dwPut))
                xCALL_rm    (rmREG(rEBX))
                xMOV_r_rm   (rEDI,rmIND32(rESI)) xOFS32(OFFSETOF(CDriverContext, nvPusher.m_dwPut))
            }
            xTARGET_b8  (labelSpace)

            //
            // next triangle
            //
            if (cullCheck)
            { xTARGET_b32 (cullCheck)
            }
#ifdef SW_WC
            if (cullCheck2)
            { xTARGET_b32 (cullCheck2)
            }
#endif
            xMOV_r_i32  (rESI,mMEM32(global.kelvin.pIndices))
            xPOP_r      (rECX)
            xLEA_r_rm   (rESI,rmIND8(rESI)) xOFS8(6)
            xDEC_rm     (rmREG(rECX))
            xMOV_i32_r  (mMEM32(global.kelvin.pIndices),rESI)
            xJNZ32      (again)


#ifdef  SW_WC
            // flush out remaining triangles
            DWORD labelDone;
            DWORD labelFlush;
            xTEST_r_rm  (rEBP, rmREG(rEBP))
            xLABEL      (labelDone)
            xJZ         (0)

            xMOV_rm_imm (rmREG(rESI), KNIMEM(dwKelvinTriDispatch))
            xLABEL      (labelFlush)
            xMOV_r_rm   (rEAX, rmIND(rESI))
            xMOV_rm_r   (rmIND(rEDI), rEAX)
            xMOV_r_rm   (rEAX, rmIND8(rESI)) xOFS8(4)
            xMOV_rm_r   (rmIND8(rEDI), rEAX) xOFS8(4)
            xMOV_r_rm   (rEAX, rmIND8(rESI)) xOFS8(8)
            xMOV_rm_r   (rmIND8(rEDI), rEAX) xOFS8(8)
            xMOV_r_rm   (rEAX, rmIND8(rESI)) xOFS8(12)
            xMOV_rm_r   (rmIND8(rEDI), rEAX) xOFS8(12)
            xLEA_r_rm   (rESI, rmIND8(rESI)) xOFS8(16)
            xLEA_r_rm   (rEDI, rmIND8(rEDI)) xOFS8(16)
            xSUB_rm_imm (rmREG(rEBP), 16)
            xJNZ        (labelFlush)


            xTARGET_b8  (labelDone)
#endif


            //
            // end primitive
            //
            xMOVQ_r_i64  (rMM0,mMEM64(global.kelvin.qwEnd))
            xMOVNTQ_rm_r (rmIND(rEDI),rMM0)
            xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(8)
            xEMMS


        }//#endif // ~INVERSE_XFORM_CULL

        //
        // save off push buffer
        //
        xMOV_r_i32  (rEDX,mMEM32(pDriverData))
    #ifndef NV_NULL_HW_DRIVER
        xMOV_rm_r   (rmIND32(rEDX),rEDI) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
    #endif

    #endif // USE_C_LOGIC
        //
        // clean up caching strategy
        //
        //     xMOV_r_i32  (rEAX,mMEM32(pDriverData))
        //     xMOV_rm_imm (rmREG(rEBX),rzSetAGPMTRR)
        //     xPUSH_imm   (1)
        //     xPUSH_rm    (rmIND32(rEAX)) xOFS32(OFFSETOF(GLOBALDATA,GARTPhysicalBase))
        //     xCALL_rm    (rmREG(rEBX))

        //
        // done
        //
        xPOP_r      (rEDI)
        xPOP_r      (rESI)
        xPOP_r      (rEBX)
        xPOP_r      (rEBP)
        xRET
        return lEntry;

    }

#else //#if 0

    return 0;
#endif //#if 0

}


#endif KELVIN_ILC

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\inc\D3DINC.H ===
#ifndef _D3DINC_H_
#define _D3DINC_H_
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: D3DINC.H                                                          *
*   NV specific direct 3d structure definitions.                            *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Eugene Lapidous             ??/??/96 - wrote it.                    *
*       Charles Inman (chasi)       01/02/97 - re-wrote and cleaned up.     *
*                                                                           *
\***************************************************************************/

/*
 * --------------------------------------------------------------------------
 * Vertex cache.
 * --------------------------------------------------------------------------
 */
#define VINDEX_MASK                 0x0F

/*
 * --------------------------------------------------------------------------
 * Data Cache macros
 * --------------------------------------------------------------------------
 */
#define PREFETCH(address)       ((volatile DWORD)*(DWORD*)(address))

/*
 * --------------------------------------------------------------------------
 * Texture heap management defines and structures.
 * --------------------------------------------------------------------------
 */
typedef struct _def_tex_heap_header TEXHEAPHEADER, *PTEXHEAPHEADER;

#define PACKCHARS(c0, c1, c2, c3)               \
    (((DWORD)(unsigned char)(c0))       |       \
     ((DWORD)(unsigned char)(c1) << 8)  |       \
     ((DWORD)(unsigned char)(c2) << 16) |       \
     ((DWORD)(unsigned char)(c3) << 24))

#define HEAP_SHARED                 0x04000000UL    // put heap in shared memory
#define HEAP_SIZE_ADJUST            0x00100000
#define HEAP_TAG_FREE               PACKCHARS('F', 'R', 'E', 'E')
#define HEAP_TAG_ALLOC              PACKCHARS('L', 'O', 'C', 'K')

struct _def_tex_heap_header
{
    DWORD           dwTag;
    DWORD           dwBlockSize;
    DWORD           dwBlockStartOffset;
    DWORD           dwReserved;
    PTEXHEAPHEADER  pNextFreeBlock;
    PTEXHEAPHEADER  pPrevFreeBlock;
    PTEXHEAPHEADER  pNextAllocBlock;
    PTEXHEAPHEADER  pPrevAllocBlock;
};

/*
 * --------------------------------------------------------------------------
 * General purpose constants
 * --------------------------------------------------------------------------
 */
#define CONTEXT_ARRAY_SIZE          64
#define CONTEXT_ARRAY_DELTA         64
#define TEXTURE_ARRAY_SIZE          256
#define TEXTURE_ARRAY_DELTA         256
#ifndef OLDSTUFF
#define AGPLIST_ARRAY_SIZE          1000
#else
#define AGPLIST_ARRAY_SIZE          256
#endif
#define AGPLIST_ARRAY_DELTA         256
#define NVD3D_DEFAULT_TL_NUM        0           // was: ((32 * 2048) / sizeof(D3DTLVERTEX))

#define MAX_STATE                   D3DSTATE_OVERRIDE_BIAS
#define DWORD_BITS                  32
#define DWORD_SHIFT                 5

#ifdef  DO_XF_LIGHT
#define PIPELINE_ARRAY_SIZE         64
#define PIPELINE_ARRAY_DELTA        64
#define MATERIAL_ARRAY_SIZE         64
#define MATERIAL_ARRAY_DELTA        64
#endif  // DO_XF_LIGHT

/*
 * --------------------------------------------------------------------------
 *  Data structures.
 * --------------------------------------------------------------------------
 */

/*
 * DWORD triangle
 */
typedef struct NVD3DTRIANGLE {
    union {
        struct {
            WORD v1,v2;
        };
        DWORD v1v2;
    };
    union {
        struct {
            WORD v3,wFlags;
        };
        DWORD v3wFlags;
    };
} NVD3DTRIANGLE,*LPNVD3DTRIANGLE;

/*
 * Define function pointer prototypes.
 */
typedef void  (*LPNVDRAWTRI) (DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
typedef void  (*PFNDRAWPRIMITIVEOP)(DWORD, LPD3DTLVERTEX);
typedef void  (*PFNDRAWINDEXPRIMITIVEOP)(DWORD, LPWORD, LPD3DTLVERTEX);

#ifdef  DO_XF_LIGHT
/*
 * Define the pipeline flags.
 */
typedef struct _def_nv_d3d_pipeline  NVD3DPIPELINE, *PNVD3DPIPELINE;

struct _def_nv_d3d_pipeline
{
    DWORD                       pid;            /* Process ID */
    DWORD                       hContext;       /* Context Handle */
};

/*
 * Define the material flags.
 */
typedef struct _def_nv_d3d_material  NVD3DMATERIAL, *PNVD3DMATERIAL;

struct _def_nv_d3d_material
{
    DWORD                       pid;            /* Process ID */
    DWORD                       hContext;       /* Context Handle */
};
#endif  // DO_XF_LIGHT

/*
 * Define structure type definitions.
 */
typedef struct _def_nv_d3d_texture              NVD3DTEXTURE, *PNVD3DTEXTURE;
typedef struct _def_nv_d3d_context              NVD3DCONTEXT, *PNVD3DCONTEXT;
typedef struct _def_nv_d3d_context_inner_loop   NVD3DCONTEXTINNERLOOP, *PNVD3DCONTEXTINNERLOOP;

/*
 * D3D state set data.
 */
typedef struct _nv_d3d_state_set
{
    DWORD   bits[MAX_STATE >> DWORD_SHIFT];
} NVD3DSTATESET;

/*
 * Hardware Independant Texture Flags
 * Flags specifing that a special work around is required for this texture.
 */
#define NV_TEXTURE_DEBUG_01_HEAVY_GEAR  0x00000001  // Heavy Gear Patch Color Key Workaround.

/*
 * Include hardware specific include files here.
 * In order to be compatible with old source code, these need to be
 * included here.
 */
#ifdef  NV4
#include "nv4dinc.h"
#endif  // NV4

/*
 * --------------------------------------------------------------------------
 * External data declarations.
 * --------------------------------------------------------------------------
 */
#include "global.h"

/*
 * Some statistical values.
 */

// omnitemporal texture counts
extern DWORD   statTextureOmniCountTotal;
extern DWORD   statTextureOmniCountPalette;

// omnitemporal texture sizes
extern DWORD   statTextureOmniSizeTotal;
extern DWORD   statTextureOmniSizePalette;

// extant texture counts
extern DWORD   statTextureCountTotal;
extern DWORD   statTextureCountVideo;
extern DWORD   statTextureCountAgpHeap;
extern DWORD   statTextureCountPciHeap;
extern DWORD   statTextureCountCache;

// extant texture sizes
extern DWORD   statTextureSizeTotal;
extern DWORD   statTextureSizeVideo;
extern DWORD   statTextureSizeAgpHeap;
extern DWORD   statTextureSizePciHeap;
extern DWORD   statTextureSizeCache;

// texture dimensions
extern DWORD   statTextureDimensionMinVideo;
extern DWORD   statTextureDimensionMinAgpHeap;
extern DWORD   statTextureDimensionMinPciHeap;
extern DWORD   statTextureDimensionMinCache;
extern DWORD   statTextureDimensionMaxVideo;
extern DWORD   statTextureDimensionMaxAgpHeap;
extern DWORD   statTextureDimensionMaxPciHeap;
extern DWORD   statTextureDimensionMaxCache;

// dma stats
extern DWORD   statDmaSyncLoop;
extern DWORD   statDmaSyncOverflow;
extern DWORD   statDmaBusyLoop;
extern DWORD   statDmaBusyOverflow;
extern DWORD   statDmaFlushLoop;
extern DWORD   statDmaFlushOverflow;

/*
 * --------------------------------------------------------------------------
 *  Prototypes.
 * --------------------------------------------------------------------------
 */

/*
 * d3dmini.c
 */
//BOOL __stdcall D3DGetDriverInfo(LPDDHAL_GETDRIVERINFODATA);
void D3DReadRegistry(void);
void D3DModifyCapabilities(D3DHAL_GLOBALDRIVERDATA  *pNvGlobal);
BOOL CreateItemArrays(void);

/*
 * d3dctxt.c
 */
BOOL  nvCreateContextListHeap(void);
BOOL  nvDestroyContextListHeap(void);
DWORD __stdcall nvContextCreate(LPD3DHAL_CONTEXTCREATEDATA);
DWORD __stdcall nvContextDestroy(LPD3DHAL_CONTEXTDESTROYDATA);
DWORD __stdcall nvContextDestroyAll(LPD3DHAL_CONTEXTDESTROYALLDATA);
void  nvAllocDefaultTexture(PNVD3DCONTEXT);
void  nvFreeDefaultTexture(PNVD3DCONTEXT);
void  nvD3DReenable();
BOOL  nvSetContextSurface(PNVD3DCONTEXT);
BOOL  nvSetupContext(PNVD3DCONTEXT);
BOOL  nvFinalContextCleanup(void);

/*
 * d3drendr.c
 */
void  nvDMAStartTransfer(void);
#ifndef WINNT
DWORD __stdcall nvRenderState(LPD3DHAL_RENDERSTATEDATA);
#endif
DWORD __stdcall nvSetRenderTarget(LPD3DHAL_SETRENDERTARGETDATA);
#ifndef WINNT
DWORD __stdcall nvRenderPrimitive(LPD3DHAL_RENDERPRIMITIVEDATA);
#endif
DWORD nvSetContextState(DWORD, DWORD, HRESULT *);
BOOL  nvSetHardwareState();
void  nvResetContext(PNVD3DTEXTURE);
DWORD __stdcall nvGetDmaFreeCount(long);
void  nvStartDmaBuffer(BOOL);
void  nvFlushDmaBuffers(void);
BOOL  nvD3DClearZBuffer(LPDDRAWI_DDRAWSURFACE_LCL, DWORD);

/*
 * d3dtex.c
 */

#ifdef NV_TEX2
/*
 * ver 2.0
 */
#define NV4_TEXWAIT_READACCESS      1
#define NV4_TEXWAIT_WRITEACCESS     2
#define NV4_TEXWAIT_AVAILABLENOW    4   // when semaphore is seen the resource is available
#define NV4_TEXWAIT_AVAILABLEAFTER  0   // resource is available after the next semaphore is seen

BOOL  nvTextureRef           (PNVD3DTEXTURE);
BOOL  nvTextureTestBlock     (DWORD); // report if we need to stall CPU until given texture is not in use
void  nvTextureBlock         (DWORD); // stall CPU until given texture is not in use
void  nvTextureSetBlockPoint (void);

DWORD nvTextureBlt          (LPDDHAL_BLTDATA);
DWORD nvTextureLock         (PNVD3DTEXTURE,LPDDHAL_LOCKDATA);
DWORD nvTextureUnlock       (PNVD3DTEXTURE,LPDDHAL_UNLOCKDATA);

BOOL  nvTextureAllocSwizzleSurface  (PNVD3DTEXTURE,DWORD,DWORD,DWORD);
BOOL  nvTextureFreeSwizzleSurface   (PNVD3DTEXTURE);
BOOL  nvTextureAllocLinearSurface   (PNVD3DTEXTURE,DWORD,DWORD,DWORD);
BOOL  nvTextureFreeLinearSurface    (PNVD3DTEXTURE);

BOOL  nvUpdateSwizzleSurface        (PNVD3DTEXTURE);
BOOL  nvUpdateLinearSurface         (PNVD3DTEXTURE);

#else // NV_TEX2
/*
 * ver 1.0
 */
BOOL  nvLoadTexture(PNVD3DTEXTURE);
void  nvTextureBlit16Bpp(LPDDHAL_BLTDATA);
void  nvTextureBlit32Bpp(LPDDHAL_BLTDATA);
void  nvSwizzleBlit16Bpp(DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,
                         DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD);
void  nvSwizzleBlit32Bpp(DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,
                         DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD);

#endif //NV_TEX2

/*
 * common
 */
BOOL  nvCreateTextureListHeap(void);
BOOL  nvDestroyTextureListHeap(void);
BOOL  nvDestroyTextureStructure(PNVD3DTEXTURE);
BOOL  nvDestroyTextureProcess(DWORD);
BOOL  nvDestroyTextureContext(DWORD);
BOOL  CreateAGPListArray(void);
BOOL  DestroyAGPListArray(void);
BOOL  CreateTextureHeap(void);
BOOL  DestroyTextureHeap(void);
DWORD AllocTextureHeap(DWORD);
BOOL  FreeTextureHeap(DWORD);
DWORD GetPointerTextureHeap(DWORD);
DWORD AllocAGPHeap(LPDDRAWI_DIRECTDRAW_GBL, DWORD);
BOOL  FreeAGPHeap(LPDDRAWI_DIRECTDRAW_GBL, DWORD);
BOOL  ResetAGPHeap(void);
DWORD DestroyAGPListCallback(LPVOID, HDDRVITEM, DWORD);
DWORD __stdcall nvTextureCreate(LPD3DHAL_TEXTURECREATEDATA);
DWORD __stdcall nvTextureDestroy(LPD3DHAL_TEXTUREDESTROYDATA);
DWORD __stdcall nvTextureSwap(LPD3DHAL_TEXTURESWAPDATA);
DWORD __stdcall nvTextureGetSurf(LPD3DHAL_TEXTUREGETSURFDATA);
BOOL  nvAllocateInternalTexture(PNVD3DTEXTURE);
BOOL  nvDestroyInternalTexture(PNVD3DCONTEXT, PNVD3DTEXTURE);
BOOL  nvGenerateColorKeyAutoMipMap(long, long, long, DWORD, unsigned short *);
BOOL  nvGenerateAutoMipMap(long, long, long, unsigned short *);
BOOL  nvAllocateUserTexture(PNVD3DTEXTURE);
BOOL  nvCreateTextureSurface(LPDDHAL_CREATESURFACEDATA, LPDDRAWI_DDRAWSURFACE_LCL, LPDDRAWI_DDRAWSURFACE_GBL);
BOOL  nvDestroyTextureSurface(LPDDHAL_DESTROYSURFACEDATA, LPDDRAWI_DDRAWSURFACE_LCL, LPDDRAWI_DDRAWSURFACE_GBL);
DWORD UnplugSystemMemoryTextureContext(void);
DWORD AdjustTextureLimit(DWORD, DWORD, DWORD, DWORD);
DWORD UpdateTriangleContexts(void);
BOOL  nvMarkTextureDirty(PNVD3DCONTEXT, PNVD3DTEXTURE);
BOOL  nvMarkAllTexturesDirty(PNVD3DCONTEXT);
BOOL  nvMarkTextureValid(PNVD3DCONTEXT, PNVD3DTEXTURE);

#ifndef WINNT
/*
 * d3dstate.c
 */
DWORD __stdcall nvGetState(LPD3DHAL_GETSTATEDATA);
#endif

/*
 * d3dscene.c
 */
DWORD __stdcall nvSceneCapture(LPD3DHAL_SCENECAPTUREDATA);

/*
 * d3dtri.c
 */
void  nvNoOp(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);

void  nvDmaPushTri(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriFog(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriSpecular(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriFogSpecular(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriFlat(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriFogFlat(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriSpecularFlat(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriFogSpecularFlat(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriDecal(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriFogDecal(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriSpecularDecal(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriFogSpecularDecal(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);

void  nvDmaPushTriScaled(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriScaledFog(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriScaledSpecular(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriScaledFogSpecular(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriScaledFlat(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriScaledFogFlat(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriScaledSpecularFlat(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriScaledFogSpecularFlat(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriScaledDecal(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriScaledFogDecal(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriScaledSpecularDecal(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriScaledFogSpecularDecal(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);

void  nvDmaPushSpecularPass(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushSpecularPassScaled(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushFlatSpecularPass(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushFlatSpecularPassScaled(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushFogSpecularPass(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushFogSpecularPassScaled(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushFogFlatSpecularPass(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushFogFlatSpecularPassScaled(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvNonPerspectiveTriangle(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvFogTableTriangle(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvGapFillTriangle(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriangleOnePass(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriangleOnePassSpecular(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriangleTwoPass(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriangleTwoPassSpecular(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriangleTwoPassSpecularNoZeta(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);

void nvTriangleStateChange(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);

/*
 * d3dpoint.c
 */
void  nvPointTriangle(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX, LPNVDRAWTRI, LPNVDRAWTRI, LPNVDRAWTRI);
void  nvDmaPushPointTriangle(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvPoint(DWORD, LPD3DPOINT, LPD3DTLVERTEX);
DWORD nvRenderPointDmaPush(DWORD, LPWORD, LPD3DTLVERTEX);

/*
 * d3dline.c
 */
void  nvWireframeTriangle(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX, LPNVDRAWTRI, LPNVDRAWTRI, LPNVDRAWTRI);
void  nvDmaPushWireframeTriangle(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvLine(DWORD, LPWORD, DWORD, LPD3DTLVERTEX);
DWORD nvDrawLineDmaPush(DWORD, LPWORD, DWORD, LPD3DTLVERTEX);
DWORD nvRenderLineDmaPush(DWORD, LPWORD, LPD3DTLVERTEX);

/*
 * d3dmisc.c
 */
VOID  uvFixDmaPush(D3DVALUE, LPD3DTLVERTEX, LPD3DTLVERTEX, LPD3DTLVERTEX, DWORD, DWORD);

/*
 * d3dmip.c
 */
void  nvMipMapRenderPrimitive(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvMidPointSubdivision(PNVD3DTEXTURE, D3DTLVERTEX, D3DTLVERTEX, D3DTLVERTEX, LPNVDRAWTRI);
int   nvLODCompare(int, int, DWORD, DWORD);
DWORD nvConcurrentPass (void);
DWORD nvGetCPUSpeed    (void);
BOOL  nvDetectMMX      (void);
BOOL  nvDetectKATMAI   (void);

#ifdef NV_TEX2
/*
 * nv4swiz.c
 */
#define NV_SWIZFLAG_SRCLINEAR       0x00000000
#define NV_SWIZFLAG_SRCSWIZZLED     0x00000001
#define NV_SWIZFLAG_DESTLINEAR      0x00000000
#define NV_SWIZFLAG_DESTSWIZZLED    0x00000002
#define NV_SWIZFLAG_PALETTIZED      0x00000004
#define NV_SWIZFLAG_ALLOWHW         0x80000000

#define NV_SWIZVAL_MAX              16

BOOL nvSwizzleBlt   (DWORD dwSrcAddr,DWORD dwSrcAlloc,
                          DWORD dwSrcLogW,DWORD dwSrcLogH,
                          DWORD dwSrcX0,DWORD dwSrcY0,DWORD dwSrcX1,DWORD dwSrcY1,
                          DWORD dwSrcPitch,
                          PNVD3DTEXTURE pSrcTexture,
                     DWORD dwDestAddr,DWORD dwDestAlloc,
                          DWORD dwDestLogW,DWORD dwDestLogH,
                          DWORD dwDestX,DWORD dwDestY,
                          DWORD dwDestPitch,
                          PNVD3DTEXTURE pDestTexture,
                     DWORD dwBPP,
                     DWORD dwFlags);

#endif // NV_TEX2

/*
 * d3danti.c
 */
BOOL nvAACreate           (void);
void nvAADestroy          (void);
BOOL nvAACreateBuffers    (void);
BOOL __stdcall nvAACapturePrimitive (DWORD,LPWORD,DWORD,LPBYTE);
BOOL nvAARenderPrimitive  (void);

#ifdef  DO_XF_LIGHT
/*
 * d3dmatrx.c
 */
BOOL  CreatePipelineArray(void);
BOOL  DestroyPipelineArray(void);
DWORD __stdcall nvMatrixCreate(LPD3DHAL_MATRIXCREATEDATA pmcd);
DWORD __stdcall nvMatrixDestroy(LPD3DHAL_MATRIXDESTROYDATA pmdd);
DWORD __stdcall nvMatrixSetData(LPD3DHAL_MATRIXSETDATADATA pmsd);
DWORD __stdcall nvMatrixGetData(LPD3DHAL_MATRIXGETDATADATA pmgd);
DWORD __stdcall nvSetViewportData(LPD3DHAL_SETVIEWPORTDATADATA pvsd);
DWORD DestroyPipelineCallback(LPVOID lpData, HDDRVITEM hItem, DWORD dwExtra);
DWORD DestroyPipelineProcessCallback(LPVOID, HDDRVITEM, DWORD);
DWORD DestroyPipelineContextCallback(LPVOID, HDDRVITEM, DWORD);

/*
 * d3dmater.c
 */
BOOL  CreateMaterialArray(void);
BOOL  DestroyMaterialArray(void);
DWORD __stdcall nvLightSet(LPD3DHAL_LIGHTSETDATA plsd);
DWORD __stdcall nvMaterialCreate(LPD3DHAL_MATERIALCREATEDATA pmcd);
DWORD __stdcall nvMaterialDestroy(LPD3DHAL_MATERIALDESTROYDATA pmdd);
DWORD __stdcall nvMaterialDestroy(LPD3DHAL_MATERIALDESTROYDATA pmdd);
DWORD __stdcall nvMaterialSetData(LPD3DHAL_MATERIALSETDATADATA pmsd);
DWORD __stdcall nvMaterialGetData(LPD3DHAL_MATERIALGETDATADATA pmgd);
DWORD DestroyMaterialCallback(LPVOID lpData, HDDRVITEM hItem, DWORD dwExtra);
DWORD DestroyMaterialProcessCallback(LPVOID, HDDRVITEM, DWORD);
DWORD DestroyMaterialContextCallback(LPVOID, HDDRVITEM, DWORD);
#endif  // DO_XF_LIGHT

/*
 * For easy compatability with old code.
 * These include files are protected from being loaded twice.
 */
#include    "nvd3dmac.h"

#define HEAP_ALLOC_DEPTH_WIDTH_HEIGHT        1
#define HEAP_ALLOC_SIZE                      2
#define HEAP_FREE                            3
#define HEAP_PURGE                           4
#define HEAP_INFO                            5
#define HEAP_ALLOC_TILED_PITCH_HEIGHT        6
#define TYPE_IMAGE                           0
#define TYPE_DEPTH                           1
#define TYPE_TEXTURE                         2
#define TYPE_OVERLAY                         3
#define TYPE_FONT                            4
#define TYPE_CURSOR                          5
#define TYPE_DMA                             6
#define TYPE_INSTANCE                        7
#define MEM_TYPE_IMAGE_TILED                 9
#define STATUS_SUCCESS                       (0x00000000)
#define STATUS_ERROR_INSUFFICIENT_RESOURCES  (0x00000001)
#define STATUS_ERROR_INVALID_FUNCTION        (0x00000002)
#define STATUS_ERROR_INVALID_OWNER           (0x00000003)

#ifdef NVHEAPMGR
/*
 * Heap manager interface.
 */
extern void __stdcall NvIoControl(DWORD, PVOID);

/* parameter values */
#ifndef WINNT
#ifdef MULTI_MON
#define NVHEAP_ALLOC(pvm,sz,tp)             \
{                                           \
    HeapParams.hRoot = pDriverData->dwRootHandle; \
    HeapParams.hObjectParent = NV_WIN_DEVICE; \
    HeapParams.function = HEAP_ALLOC_SIZE;  \
    HeapParams.owner    = 'NVDD';           \
    HeapParams.type     = (tp);             \
    HeapParams.size     = (sz);             \
    NvIoControl(11, (PVOID)&HeapParams);    \
    (pvm) = HeapParams.status ? 0 : HeapParams.address;\
    pDriverData->VideoHeapFree = HeapParams.free;\
}
#define NVHEAP_FREE(pvm)                    \
{                                           \
    HeapParams.hRoot = pDriverData->dwRootHandle; \
    HeapParams.hObjectParent = NV_WIN_DEVICE; \
    HeapParams.function = HEAP_FREE;        \
    HeapParams.owner    = 'NVDD';           \
    HeapParams.offset   = (U032)(pvm) - pDriverData->BaseAddress;\
    NvIoControl(11, (PVOID)&HeapParams);    \
    pDriverData->VideoHeapFree = HeapParams.free;\
}
#else   // !MULTI_HEAP
#define NVHEAP_ALLOC(pvm,sz,tp)             \
{                                           \
    HeapParams.function = HEAP_ALLOC_SIZE;  \
    HeapParams.device   = 0;                \
    HeapParams.owner    = 'NVDD';           \
    HeapParams.type     = (tp);             \
    HeapParams.size     = (sz);             \
    NvIoControl(11, (PVOID)&HeapParams);    \
    (pvm) = HeapParams.status ? 0 : HeapParams.address;\
    pDriverData->VideoHeapFree = HeapParams.free;\
}
#define NVHEAP_FREE(pvm)                    \
{                                           \
    HeapParams.function = HEAP_FREE;        \
    HeapParams.device   = 0;                \
    HeapParams.owner    = 'NVDD';           \
    HeapParams.offset   = (U032)(pvm) - pDriverData->BaseAddress;\
    NvIoControl(11, (PVOID)&HeapParams);    \
    pDriverData->VideoHeapFree = HeapParams.free;\
}
#endif  // !MULTI_HEAP
#else
#ifndef RM_HEAPMGR
#define NVHEAP_ALLOC(pvm,sz,tp)                                 \
{                                                               \
    (pvm) = heap_alloc(sz, pDriverData->ppdev->heap.heap_2d_ptr);       \
    if(!(pvm))                                                  \
    {                                                           \
        bMoveAllDfbsFromOffscreenToDibs(pDriverData->ppdev);    \
        (pvm) = heap_alloc(sz, pDriverData->ppdev->heap.heap_2d_ptr);   \
    }                                                           \
}

#define NVHEAP_FREE(pvm)             \
    heap_free((pvm), pDriverData->ppdev->heap.heap_2d_ptr)
#else
extern BOOL bMoveAllDfbsFromOffscreenToDibs(PDEV *);

#define NVHEAP_ALLOC(pvm,sz,tp)             \
{                                           \
    NVOS11_PARAMETERS   HeapParams;         \
    PVOID pParms = (PVOID) &HeapParams;     \
    DWORD cbReturned;                       \
                                            \
    if (pDriverData && !pDriverData->DDrawVideoSurfaceCount)         \
    {                                       \
        pDriverData->ppdev->cbGdiHeap = pDriverData->ppdev->VideoHeapTotal -   \
            pDriverData->ppdev->VideoHeapFree;                      \
                                                                    \
    }                                       \
                                                    \
    HeapParams.hRoot = pDriverData->ppdev->hClient;  \
    HeapParams.hObjectParent = pDriverData->ppdev->hDevice;                  \
    HeapParams.function = HEAP_ALLOC_SIZE;                      \
    HeapParams.owner    = 'NVDD';                               \
    HeapParams.type     = (tp);                                 \
    HeapParams.size     = (sz);                                 \
    EngDeviceIoControl(                         \
        pDriverData->ppdev->hDriver,            \
        (DWORD)IOCTL_NV01_ARCH_HEAP,            \
        (&pParms),                              \
        sizeof(PVOID),                          \
        pParms,                                 \
        sizeof(NVOS11_PARAMETERS),              \
        &cbReturned                             \
    );                                          \
    (pvm) = HeapParams.status ? 0 : HeapParams.offset;          \
    if (!(pvm))                                                 \
    {                                                           \
        bMoveAllDfbsFromOffscreenToDibs(pDriverData->ppdev);    \
        HeapParams.hRoot = pDriverData->ppdev->hClient;  \
        HeapParams.hObjectParent = pDriverData->ppdev->hDevice;                  \
        HeapParams.function = HEAP_ALLOC_SIZE;                      \
        HeapParams.owner    = 'NVDD';                               \
        HeapParams.type     = (tp);                                 \
        HeapParams.size     = (sz);                                 \
        EngDeviceIoControl(                         \
            pDriverData->ppdev->hDriver,            \
            (DWORD)IOCTL_NV01_ARCH_HEAP,            \
            (&pParms),                              \
            sizeof(PVOID),                          \
            pParms,                                 \
            sizeof(NVOS11_PARAMETERS),              \
            &cbReturned                             \
        );                                          \
        (pvm) = HeapParams.status ? 0 : HeapParams.offset;          \
    }                                               \
    if (pvm)                                        \
        pDriverData->ppdev->VideoHeapFree = HeapParams.free;    \
}

#define NVHEAP_ALLOC_TILED(pvm,pch,ht,tp)   \
{                                           \
    NVOS11_PARAMETERS HeapParams;           \
    PVOID pParms = (PVOID) &HeapParams;     \
    DWORD cbReturned;                       \
    HeapParams.hRoot = pDriverData->ppdev->hClient; \
    HeapParams.hObjectParent = pDriverData->ppdev->hDevice; \
    HeapParams.function = HEAP_ALLOC_TILED_PITCH_HEIGHT;\
    HeapParams.owner    = 'NVDD';           \
    HeapParams.type     = (tp);             \
    HeapParams.pitch    = (pch);            \
    HeapParams.height   = (ht);             \
    EngDeviceIoControl(                         \
        pDriverData->ppdev->hDriver,            \
        (DWORD)IOCTL_NV01_ARCH_HEAP,            \
        (&pParms),                              \
        sizeof(PVOID),                          \
        pParms,                                 \
        sizeof(NVOS11_PARAMETERS),              \
        &cbReturned                             \
    );                                          \
                                                \
    (pvm) = HeapParams.status ? 0 : HeapParams.offset;\
    (pch) = HeapParams.pitch;                   \
    if ((pvm))                                  \
        pDriverData->VideoHeapFree = HeapParams.free;\
}

#define NVHEAP_FREE(pvm)                    \
{                                           \
    NVOS11_PARAMETERS HeapParams;           \
    PVOID pParms = (PVOID) &HeapParams;     \
    DWORD cbReturned;                       \
    HeapParams.hRoot = pDriverData->ppdev->hClient;      \
    HeapParams.hObjectParent = pDriverData->ppdev->hDevice; \
    HeapParams.function = HEAP_FREE;        \
    HeapParams.owner    = 'NVDD';         \
    HeapParams.offset   = (U032)(pvm);      \
    EngDeviceIoControl(                         \
        pDriverData->ppdev->hDriver,                                \
        (DWORD)IOCTL_NV01_ARCH_HEAP,            \
        (&pParms),                              \
        sizeof(PVOID),                          \
        pParms,                                 \
        sizeof(NVOS11_PARAMETERS),              \
        &cbReturned                             \
    );                                          \
    pDriverData->ppdev->VideoHeapFree = HeapParams.free;              \
}

#endif // RM_HEAPMGR
#endif // #ifdef WINNT
#define AGP_HEAP                                    0
#else
#ifndef WINNT
#define NVHEAP_ALLOC(pvm,size,tp)                                                \
{                                                                                \
    DWORD _actual = size;                                                        \
    if ((tp) == TYPE_TEXTURE) _actual = (_actual + NV_TEXTURE_PAD + NV_TEXTURE_OFFSET_ALIGN) & ~NV_BYTE_ALIGNMENT_PAD;\
    (pvm) = DDHAL32_VidMemAlloc(pdrv, 0, _actual, 1);                            \
}
#define NVHEAP_FREE(pvm)                            DDHAL32_VidMemFree(pdrv, 0, pvm)
#define AGP_HEAP                                    1
#else
#define NVHEAP_ALLOC(pfm,size,tp) \
{                                                   \
SURFACEALIGNMENT    _align;                         \
ULONG               DummyPitch;                     \
switch (tp)                                         \
    {                                               \
    case TYPE_TEXTURE:                              \
        _align.Linear.dwSurfaceAlignment = NV_TEXTURE_OFFSET_ALIGN + 1; \
        _align.Linear.dwPitchAlignment = NV_BYTE_ALIGNMENT; \
        break;                                      \
                                                    \
    case TYPE_IMAGE:                                \
    case TYPE_OVERLAY:                              \
    case TYPE_DEPTH:                                \
        _align.Linear.dwSurfaceAlignment = _align.Linear.dwPitchAlignment = NV_BYTE_ALIGNMENT; \
        break;                                      \
                                                    \
    default:                                        \
        DPF("Bad allocation type passed to NVHEAP_ALLOC"); \
            _align.Linear.dwSurfaceAlignment = _align.Linear.dwPitchAlignment = NV_BYTE_ALIGNMENT_PAD; \
                                                    \
    }                                               \
(pfm) = HeapVidMemAllocAligned(pdrv, size, 1,       \
            &_align,                                \
            &DummyPitch                             \
            );                                      \
}

#define NVHEAP_FREE(pfm)            VidMemFree(pdrv, pfm)
#define AGP_HEAP                    0
#endif // #ifdef WINNT
#endif

#ifndef WINNT
#define NV_DELAY                                          \
{                                                         \
    __asm { push ecx                                    } \
    __asm { mov ecx,[global.dwProcessorSpeed]           } \
    __asm { shl ecx,3                                   } \
x:  __asm { loop x                                      } \
    __asm { pop ecx                                     } \
}

#define NV_DELAY_(x)                                      \
{                                                         \
    __asm { push ecx                                    } \
    __asm { mov ecx,[global.dwProcessorSpeed]           } \
    __asm { shl ecx,3                                   } \
x:  __asm { loop x                                      } \
    __asm { pop ecx                                     } \
}
#else
#define NV_DELAY
#endif // #ifdef WINNT

void WaitForVSync (void);

/*
 * wait for VSYNC strategy:
 *
 * 1) we should have the registry bit set that enable wait for VSYNC
 * 2) we should have a flip pending
 * 3) the flip should involve the current render target
 */
#define WAIT_FOR_VSYNC(_ctx)                                                                        \
{                                                                                                   \
    if (!(pDriverData->regD3DEnableBits1 & REG_BIT1_NO_WAIT_4_VSYNC) /* vsync == true */            \
      && pDriverData->flipPrimaryRecord.bFlipFlag)                                                  \
    {                                                                                               \
        /* skip wait if we do not render to any flipping surfaces */                                \
        if ((_ctx)                                                                                  \
         && (pDriverData->flipPrimaryRecord.fpFlipFrom != (_ctx)->lpLcl->lpGbl->fpVidMem)           \
         && (pDriverData->flipPrimaryRecord.fpFlipTo   != (_ctx)->lpLcl->lpGbl->fpVidMem))          \
        {                                                                                           \
            /* do nothing */                                                                        \
        }                                                                                           \
        else                                                                                        \
        {                                                                                           \
            /* have to wait for vsync */                                                            \
            WaitForVSync();                                                                         \
        }                                                                                           \
    }                                                                                               \
}


#endif // _D3DINC_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\common\src\TransInit.c ===
/***************************************************************************\
* (C) Copyright NVIDIA Corporation Inc.,                                    *
*  1996,1997, 1998. All rights reserved.                                    *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
* Module: TransInit.c                                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       schaefer           8/17/98                                          *
*                                                                           *
\***************************************************************************/
// these are intented to be called from surfaces.c setupvp and teardownvp

// MS includes
#include "windows.h"
#include "ddraw.h"
//#include "Ddrawp.h"
#include "ddrawi.h"
#include "ddmini.h"
#include "dvp.h"
#include "dmemmgr.h"
#include "ddkmmini.h"
#include "ddkmapi.h"

#ifndef NV4
#include "real3nv32.h"
#include "nvwin32.h"
#include "nvos.h"
#else
#include "realnv32.h"
#include "nvwin32.h"
#include "nvos.h"
#endif  //NV4

#include "nvrmapi.h"
#include "nvrmarch.inc"

#include "surfaces.h"
#include "transfer.h"

extern vpSurfaces*			pMySurfaces;
extern NvNotification*		nvMyVPNotifiers;
NvChannel* 			nvPtr = NULL;


U032 SetupMTM() {
	U032	i;
	U032	error;
	nvPtr = pMySurfaces->pVPChanPtr;
	
	// allocate the MTM object
	error = NvRmAllocObject(  (GLOBDATAPTR)->ROOTHANDLE,
	                     		MY_VPE_CHANNEL,
	                     		MY_MTM_OBJECT,
#ifndef NV4
										NV_MEMORY_TO_MEMORY_FORMAT
#else
										NV03_MEMORY_TO_MEMORY_FORMAT
#endif// NV4
								);    
	if(checkNvAllocArchError(error )) {
		DPF("NVDD: Cannot allocate MTM object %d",MY_EXTERNAL_DECODER_OBJECT);
		return FALSE;
	}
	

	// allocate the notify context
	error = NvRmAllocContextDma(  (GLOBDATAPTR)->ROOTHANDLE,
	                     		MY_MTM_NOTIFIER,
	                     		NV01_CONTEXT_DMA,
	                     		(	ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR |
                        				ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
	                     		(PVOID)(((U032)nvMyVPNotifiers) + NUM039OFFSET*sizeof(NvNotification)),
	                     		(sizeof( NvNotification)*NUM039NOTIFIER  - 1)
	                     );
	if(checkNvAllocArchError(error )) {
		DPF("NVDD: Cannot allocate MTM Notifier object %d",MY_EXTERNAL_DECODER_OBJECT);
		return FALSE;
	}
	
	// allocate the FROM context
	error = NvRmAllocContextDma(  (GLOBDATAPTR)->ROOTHANDLE,
	                     		MY_MTM_FROM_CONTEXT,
	                     		NV01_CONTEXT_DMA,		//NV_CONTEXT_DMA_FROM_MEMORY ?
	                     		(	ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR |
                        				ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
	                     		(PVOID)(void*)((GLOBALDATA*)(pMySurfaces->pDriverData))->BaseAddress,
	                     		((((GLOBALDATA*)(pMySurfaces->pDriverData))->VideoHeapEnd - ((GLOBALDATA*)(pMySurfaces->pDriverData))->BaseAddress)) -1
	                     );

	if(checkNvAllocArchError(error )) {
		DPF("NVDD: Cannot allocate MTM FROM context object %d",MY_EXTERNAL_DECODER_OBJECT);
		return FALSE;
	}
	
	// allocate the MTM event
	error = NvRmAllocEvent	(	(GLOBDATAPTR)->ROOTHANDLE,
	 									MY_MTM_OBJECT,
	                      		MY_MTM_EVENT,
	                      		NV01_EVENT_KERNEL_CALLBACK,
										NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0),
										(void*)pMySurfaces->pMTMNotifyCallback);		    
							
	if(checkNvAllocArchError(error )) {
		DPF("NVDD: Cannot allocate MTM event object %d",MY_EXTERNAL_DECODER_OBJECT);
		return FALSE;
	} 
#if 0	
// second one until RM is working

	error = NvRmAllocEvent	(	(GLOBDATAPTR)->ROOTHANDLE,
	 									MY_MTM_OBJECT,
	                      		MY_MTM_EVENT2,
	                      		NV01_EVENT_KERNEL_CALLBACK,
										NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0),
										(void*)pMySurfaces->pMTMNotifyCallback);		    
							
	if(checkNvAllocArchError(error )) {
		DPF("NVDD: Cannot allocate MTM event object %d",MY_EXTERNAL_DECODER_OBJECT);
		return FALSE;
	} 
// done with second one
#endif

#ifndef NV4
	nvPtr->subchannel[5].control.object = MY_MTM_OBJECT;
#else 
	nvPtr->subchannel[5].SetObject  = MY_MTM_OBJECT;
#endif // NV4
	
			
#ifndef NV4
	nvPtr->subchannel[5].memoryToMemoryFormat.SetBufferNotifyCtxDma = MY_MTM_NOTIFIER;
	nvPtr->subchannel[5].memoryToMemoryFormat.SetBufferInCtxDma = MY_MTM_FROM_CONTEXT;
#else
	nvPtr->subchannel[5].nv03MemoryToMemoryFormat.SetContextDmaNotifies = MY_MTM_NOTIFIER;
	nvPtr->subchannel[5].nv03MemoryToMemoryFormat.SetContextDmaBufferIn = MY_MTM_FROM_CONTEXT;
#endif //NV4
	
	// Null out the transfers
	for(i=0;i<MAXTRANSFERS;i++) {
		pMySurfaces->MyTransfers[i].TransferID = TRANSFERNOTINUSE;
	}
//	pMySurfaces->pLastTransfer =
	pMySurfaces->pCurrentTransfer = NULL;
	pMySurfaces->bContextCreated	= FALSE;
}



void TearDownMTM() {
	U032	i;
	U032	error;
	nvPtr = pMySurfaces->pVPChanPtr;
	
	
	// set the transfers to something useless
	for(i=0;i<MAXTRANSFERS;i++) {
		pMySurfaces->MyTransfers[i].TransferID = 0;
	}
	
	if(nvPtr != NULL ) {
#ifndef NV4
		nvPtr->subchannel[5].control.object = MY_MTM_OBJECT;
#else 
		nvPtr->subchannel[5].SetObject  = MY_MTM_OBJECT;
#endif // NV4

																			// plug in some null objects
#ifndef NV4
		nvPtr->subchannel[5].memoryToMemoryFormat.SetBufferNotifyCtxDma = 0;
		nvPtr->subchannel[5].memoryToMemoryFormat.SetBufferInCtxDma = 0;
		nvPtr->subchannel[5].memoryToMemoryFormat.SetBufferOutCtxDma = 0;
#else
		nvPtr->subchannel[5].nv03MemoryToMemoryFormat.SetContextDmaNotifies = 0;
		nvPtr->subchannel[5].nv03MemoryToMemoryFormat.SetContextDmaBufferIn = 0;
		nvPtr->subchannel[5].nv03MemoryToMemoryFormat.SetContextDmaBufferOut = 0;
#endif //NV4


	// DO a SYNC here.
		// spin waiting for empty fifo
#ifdef NV4
		while(NvGetFreeCount(nvPtr, 5) < NV06A_FIFO_GUARANTEED_SIZE );
#else
		while(NvGetFreeCount(nvPtr, 5) < NV_GUARANTEED_FIFO_SIZE );
#endif
	
	}
	
	if(pMySurfaces->bContextCreated) {
		error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, (GLOBDATAPTR)->ROOTHANDLE, MY_MTM_TO_CONTEXT);

		checkNvAllocArchError(error);
		pMySurfaces->bContextCreated = FALSE;
	
	}

#ifdef NOEVENTFREEFUNCTIONYETFOLKS	
	error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, MY_MTM_OBJECT, MY_MTM_EVENT);
   checkNvAllocArchError(error);
#if 0
	error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, MY_MTM_OBJECT, MY_MTM_EVENT2);
   checkNvAllocArchError(error);
#endif
	
#endif
	
	error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, (GLOBDATAPTR)->ROOTHANDLE, MY_MTM_NOTIFIER);
	checkNvAllocArchError(error);
	error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, (GLOBDATAPTR)->ROOTHANDLE, MY_MTM_FROM_CONTEXT);
	checkNvAllocArchError(error);
	error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, MY_VPE_CHANNEL, MY_MTM_OBJECT);
	checkNvAllocArchError(error);
	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\inc\NV3DDBG.H ===
#ifndef _NV3DDBG_H_
#define _NV3DDBG_H_
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV3DDBG.H                                                         *
*   Define debug related values.                                            *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       11/18/97 - created                      *
*                                                                           *
\***************************************************************************/

/*
 * Bit definitions for dbgLevel debug output level flags.
 */
#define NVDBG_LEVEL_ERROR           0x80000000
#define NVDBG_LEVEL_DDI_ENTRY       0x40000000
#define NVDBG_LEVEL_FUNCTION_CALL   0x20000000
#define NVDBG_LEVEL_INFO            0x10000000
#define NVDBG_LEVEL_INFO2           0x08000000
#define NVDBG_LEVEL_COLORKEY_INFO   0x04000000
#define NVDBG_LEVEL_AA_INFO         0x02000000
#define NVDBG_LEVEL_FLIP            0x01000000
#define NVDBG_LEVEL_FASTLOOPS       0x00800000

/*
 * Bit definitions for the dbgShowState debug flags.
 */
#define NVDBG_SHOW_RENDER_STATE     0x80000000
#define NVDBG_SHOW_DX5_CLASS_STATE  0x40000000
#define NVDBG_SHOW_SURFACE_STATE    0x20000000
#define NVDBG_SHOW_VERTICES         0x10000000
#define NVDBG_SHOW_MTS_STATE        0x0F000000  // Selects number of multi-texture stage state values to display.
#define NVDBG_SHOW_MTS_STATE_MAX    8
#define NVDBG_SHOW_MTS_STATE_SHIFT  24
#define NVDBG_SHOW_DX6_CLASS_STATE  0x00800000
#define NVDBG_SHOW_DRAWPRIM2_INFO   0x00400000

/*
 * Define externs and constants when DEBUG is enabled.
 */
#ifdef  DEBUG
#define DBGFRONTRENDER  1
#define DBGPREVIEWTEX   1
#define DMAVALIDATE     1

/*
 * Bit definitions for the dbgFlush debug flags.
 */
#define NVDBG_FLUSH_TRIANGLE        0x80000000
#define NVDBG_FLUSH_PRIMITIVE       0x40000000
#define NVDBG_FLUSH_DDI             0x20000000

extern BOOL     dbgShowState;
extern BOOL     dbgFlush;
extern DWORD    dbgLeve;
void dbgD3DError(void);
void dbgDisplayContextState(DWORD, PNVD3DCONTEXT);
void dbgDisplayDrawPrimitives2Info(BYTE,WORD);
void dbgDisplayVertexData(DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD);
BOOL dbgTestPushBuffer(PNVD3DCONTEXT);
BOOL dbgValidateControlRegisters(PNVD3DCONTEXT);
extern void __cdecl DPF_LEVEL(DWORD dwLeve, LPSTR szFormat, ...);
#define dbgFlushType(pctxt, type)                                       \
{                                                                       \
    if (dbgFlush & type)                                                \
    {                                                                   \
        NV_D3D_GLOBAL_SAVE();                                           \
        nvFlushDmaBuffers();                                            \
        NV_D3D_GLOBAL_SETUP();                                          \
    }                                                                   \
}
/*
 * Legacy flush routines.
 */
#define dbgFlushDmaBuffers(pctxt)   dbgFlushType(pctxt, NVDBG_FLUSH_PRIMITIVE);
#define dbgFlushTriangle(pctxt)     dbgFlushType(pctxt, NVDBG_FLUSH_TRIANGLE);
#define dbgFlushDDI(pctxt)          dbgFlushType(pctxt, NVDBG_FLUSH_DDI);
#else   // DEBUG
#define dbgShowState                        FALSE
#define dbgTestPushBuffer(noop)             TRUE
#define dbgValidateControlRegisters(noop)   TRUE
#define dbgD3DError()
#define dbgDisplayContextState(f,x)
#define dbgDisplayDrawPrimitives2Info(x,y);
#define dbgDisplayVertexData(x, y, z, w, c, s, u, v);
#define DPF_LEVEL   1 ? (void)0 : (void)
#define dbgFlushDmaBuffers(noop)
#define dbgFlushTriangle(noop)
#define dbgFlushDDI(noop)
#endif  // DEBUG

/*
 * Define externs and constants when DBGFRONTRENDER is defined.
 */
#ifdef  DBGFRONTRENDER
extern BOOL     dbgFrontRender;
extern DWORD    dbgFrontRenderPitch;
#else   // DBGFRONTRENDER
#define dbgFrontRender      FALSE
#define dbgFrontRenderPitch 0
#endif  // DBGFRONTRENDER

/*
 * Define externs and constants when DBGPREVIEWTEX is defined.
 */
#ifdef  DBGPREVIEWTEX
extern BOOL     dbgPreviewTexture;
extern BOOL     dbgPreviewLinearTexture;
extern DWORD    dbgPreviewTexturePitch;
extern BOOL     dbgPreviewTextureClearFirst;
extern DWORD    dbgPreviewTextureMagX;
extern DWORD    dbgPreviewTextureMagY;
void dbgDisplayTexture(PNVD3DCONTEXT, PNVD3DTEXTURE);
void dbgDisplayLinearTexture(LPDDRAWI_DDRAWSURFACE_LCL, LPDDRAWI_DDRAWSURFACE_LCL, DWORD);
#else   // DBGPREVIEWTEX
#define dbgPreviewTexture       FALSE
#define dbgPreviewLinearTexture FALSE
#define dbgPreviewTexturePitch  0
#define dbgPreviewTextureClearFirst FALSE
#define dbgPreviewTextureMagX 1
#define dbgPreviewTextureMagY 1
#define dbgDisplayTexture(x,y)
#define dbgDisplayLinearTexture(x,y,z)
#endif  // DBGPREVIEWTEX

/*
 * Define externs and constants when DMAVALIDATE is defined.
 */
#ifdef  DMAVALIDATE
extern BOOL     dbgValidatePushBuffer;
void dbgValidatePushBufferError(void);
#ifdef  NEW_DMAPUSH
void dbgValidatePushBufferData(DWORD, DWORD);
#else   // OLD_DMAPUSH
void dbgValidatePushBufferData(void);
#endif  // OLD_DMAPUSH
#else   // DMAVALIDATE
#define dbgValidatePushBuffer   FALSE
#define dbgValidatePushBufferError()
#ifdef  NEW_DMAPUSH
#define dbgValidatePushBufferData(x,y)
#else   // OLD_DMAPUSH
#define dbgValidatePushBufferData() 
#endif  // OLD_DMAPUSH
#endif  // DMAVALIDATE

#endif // _NV3DDBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\inc\D3DI.H ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3di.h
 *  Content:    Direct3D internal include file
 *
 ***************************************************************************/

#ifndef _D3DI_H
#define _D3DI_H

#include "ddraw.h"
#include "d3d.h"


typedef DWORD D3DI_BUFFERHANDLE, *LPD3DI_BUFFERHANDLE;

/*
 * Internal version of executedata
 */
typedef struct _D3DI_ExecuteData {
    DWORD       dwSize;
    D3DI_BUFFERHANDLE dwHandle;         /* Handle allocated by driver */
    DWORD       dwVertexOffset;
    DWORD       dwVertexCount;
    DWORD       dwInstructionOffset;
    DWORD       dwInstructionLength;
    DWORD       dwHVertexOffset;
    D3DSTATUS   dsStatus;               /* Status after execute */
} D3DI_EXECUTEDATA, *LPD3DI_EXECUTEDATA;

/*
 * Internal version of lightdata and constants for flags
 */

#define D3DLIGHTI_ATT0_IS_NONZERO       (0x00010000)    
#define D3DLIGHTI_ATT1_IS_NONZERO       (0x00020000)
#define D3DLIGHTI_ATT2_IS_NONZERO       (0x00040000)
#define D3DLIGHTI_LINEAR_FALLOFF        (0x00080000)
#define D3DLIGHTI_UNIT_SCALE            (0x00100000)
#define D3DLIGHTI_LIGHT_AT_EYE          (0x00200000)

typedef struct _D3DI_LIGHT {
    D3DLIGHTTYPE        type;
        DWORD                   version;        /* matches number on D3DLIGHT struct */
    BOOL                        valid;
    D3DVALUE            red, green, blue, shade;
    D3DVECTOR           position;
    D3DVECTOR           model_position;
    D3DVECTOR           direction;
    D3DVECTOR           model_direction;
    D3DVECTOR           halfway;
        D3DVECTOR               model_eye;              /* direction from eye in model space */
        D3DVECTOR               model_scale;    /* model scale for proper range computations */
    D3DVALUE            range;
    D3DVALUE            range_squared;
    D3DVALUE            falloff;
    D3DVALUE            attenuation0;
    D3DVALUE            attenuation1;
    D3DVALUE            attenuation2;
    D3DVALUE            cos_theta_by_2;
    D3DVALUE            cos_phi_by_2;
        DWORD                   flags;
} D3DI_LIGHT, *LPD3DI_LIGHT;


#endif /* _D3DI_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\inc\NV4dblnd.h ===
#ifndef _NV4DBLND_H_
#define _NV4DBLND_H_
#ifdef  NV4
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4DBLND.H                                                        *
*   DX6 Class Blending definitions.                                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       09/09/98 - created.                     *
*                                                                           *
\***************************************************************************/

/*
 * Combine1 Pass Thru
 */
#define DX6TRI_COMBINE1ALPHA_PASS_THRU                      \
    (DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_0,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_0, _INPUT)    \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _INVERSE)  \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_2,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_2, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD))


#define DX6TRI_COMBINE1COLOR_PASS_THRU                      \
    (DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_0,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_0,    _COLOR)    \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_0, _INPUT)    \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _INVERSE)  \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _COLOR)    \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_2,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_2,    _COLOR)    \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_2, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)    \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD))

/*
 * Combine0 Disable
 */
#define DX6TRI_COMBINE0ALPHA_DISABLE                        \
    (DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_0,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_0, _DIFFUSE)  \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)  \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD))

#define DX6TRI_COMBINE0COLOR_DISABLE                        \
    (DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_0,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_0,    _COLOR)    \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_0, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)    \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)    \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)    \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD))

/*
 * Combine1 Disable
 */
#define DX6TRI_COMBINE1ALPHA_DISABLE                        \
    (DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_0,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_0, _DIFFUSE)  \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _INVERSE)  \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_2,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_2, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD))

#define DX6TRI_COMBINE1COLOR_DISABLE                        \
    (DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_0,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_0,    _COLOR)    \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_0, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _COLOR)    \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_2,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_2,    _COLOR)    \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_2, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)    \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD))

/*
 * Default Combiner setup.
 */
#define DX6TRI_COMBINE0ALPHA_DEFAULT    DX6TRI_COMBINE0ALPHA_DISABLE

#define DX6TRI_COMBINE0COLOR_DEFAULT                            \
    (DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_0,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_0,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_0, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _DIFFUSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD))

#define DX6TRI_COMBINE1ALPHA_DEFAULT                            \
    (DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_0,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_0, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _INPUT)        \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD))

#define DX6TRI_COMBINE1COLOR_DEFAULT    DX6TRI_COMBINE1COLOR_PASS_THRU

/*
 * Bump Mapping Combiner Setup.
 */
#define DX6TRI_COMBINE0ALPHA_BUMP                               \
    (DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_0,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_0, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _TEXTURE1)     \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADDSIGNED))

#define DX6TRI_COMBINE0COLOR_BUMP                               \
    (DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_0,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_0,    _ALPHA)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_0, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _ALPHA)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _TEXTURE1)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADDSIGNED2))

#define DX6TRI_COMBINE1ALPHA_BUMP                               \
    (DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_0,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_0, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD))

#define DX6TRI_COMBINE1COLOR_BUMP                               \
    (DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_0,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_0,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_0, _INPUT)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _DIFFUSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD))

/*
 * DX6 Triangle Class combiner mappings for TEXTUREMAPBLEND_DECAL
 * cPix = cTex
 * aPix = aTex
 */
#define DX6TRI_COMBINE0ALPHA_TBLEND_DECAL                       \
    (DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_0,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_0, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD))

#define DX6TRI_COMBINE0COLOR_TBLEND_DECAL                       \
    (DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_0,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_0,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_0, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD))

/*
 * DX6 Triangle Class combiner mappings for TEXTUREMAPBLEND_MODULATE
 * cPix = cTex * cSrc
 * aPix = aTex
 */
#define DX6TRI_COMBINE0ALPHA_TBLEND_MODULATE                    \
    (DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_0,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_0, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD))

#define DX6TRI_COMBINE0COLOR_TBLEND_MODULATE                    \
    (DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_0,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_0,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_0, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _DIFFUSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD))

/*
 * DX6 Triangle Class combiner mappings for TEXTUREMAPBLEND_DECALALPHA
 * cPix = ((1 - aTex) * cSrc) + (aTex * cTex)
 * aPix = aSrc
 */
#if 0
#define DX6TRI_COMBINE0ALPHA_TBLEND_DECALALPHA                  \
    (DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_0,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_0, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD))
#else
#define DX6TRI_COMBINE0ALPHA_TBLEND_DECALALPHA                  \
    (DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_0,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_0, _DIFFUSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD))
#endif

#define DX6TRI_COMBINE0COLOR_TBLEND_DECALALPHA                  \
    (DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_0,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_0,    _ALPHA)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_0, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _DIFFUSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _ALPHA)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD))

/*
 * DX6 Triangle Class combiner mappings for TEXTUREMAPBLEND_MODULATEALPHA
 * cPix = cTex * cSrc
 * aPix = aTex * aSrc
 */
#define DX6TRI_COMBINE0ALPHA_TBLEND_MODULATEALPHA               \
    (DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_0,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_0, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _DIFFUSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD))

#define DX6TRI_COMBINE0COLOR_TBLEND_MODULATEALPHA               \
    (DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_0,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_0,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_0, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _DIFFUSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD))

/*
 * DX6 Triangle Class combiner mappings for TEXTUREMAPBLEND_DECALMASK
 * cPix = lsb(aTex) ? cTex : cSrc
 * aPix = aSrc
 */
#if 0
#define DX6TRI_COMBINE0ALPHA_TBLEND_DECALMASK                   \
    (DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_0,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_0, _DIFFUSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD))
#else
#define DX6TRI_COMBINE0ALPHA_TBLEND_DECALMASK   DX6TRI_COMBINE0ALPHA_TBLEND_DECAL
#endif

#define DX6TRI_COMBINE0COLOR_TBLEND_DECALMASK   DX6TRI_COMBINE0COLOR_TBLEND_DECAL

/*
 * DX6 Triangle Class combiner mappings for TEXTUREMAPBLEND_MODULATEMASK
 * cPix = lsb(aTex) ? cTex * cSrc : cSrc
 * aPix = aSrc
 */
#if 0
#define DX6TRI_COMBINE0ALPHA_TBLEND_MODULATEMASK                \
    (DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_0,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_0, _DIFFUSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD))
#else
#define DX6TRI_COMBINE0ALPHA_TBLEND_MODULATEMASK    DX6TRI_COMBINE0ALPHA_TBLEND_MODULATE
#endif

#define DX6TRI_COMBINE0COLOR_TBLEND_MODULATEMASK    DX6TRI_COMBINE0COLOR_TBLEND_MODULATE

/*
 * DX6 Triangle Class combiner mappings for TEXTUREMAPBLEND_COPY
 * cPix = cTex
 * aPix = aTex
 */
#define DX6TRI_COMBINE0ALPHA_TBLEND_COPY    DX6TRI_COMBINE0ALPHA_TBLEND_DECAL
#define DX6TRI_COMBINE0COLOR_TBLEND_COPY    DX6TRI_COMBINE0COLOR_TBLEND_DECAL

/*
 * DX6 Triangle Class combiner mappings for TEXTUREMAPBLEND_ADD
 * cPix = cTex + cSrc
 * aPix = aSrc
 */
#define DX6TRI_COMBINE0ALPHA_TBLEND_ADD                         \
    (DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_0,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_0, _DIFFUSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD))

#define DX6TRI_COMBINE0COLOR_TBLEND_ADD                         \
    (DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_0,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_0,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_0, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _DIFFUSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD))

#endif  // NV4
#endif  // _NV4DBLND_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\common\src\Vp.c ===
/***************************************************************************\
* (C) Copyright NVIDIA Corporation Inc.,                                    *
*  1996,1997, 1998. All rights reserved.                                    *
*                                                                           *
* Module: VP.c                                                              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       schaefer           3/26/98                                          *
*                                                                           *
\***************************************************************************/

/* #includes ---------------------------------------------*/

// MS includes
#include "windows.h"
#include "mmsystem.h"
#include "ddraw.h"
#include "ddrawi.h"
#include "ddmini.h"
#include "ddkmmini.h"
#include "minivdd.h"
#include "dvp.h"

// NV includes
#ifndef NV4
#include "nv32.h"
#include "nvwin32.h"
#else
#include "realnv32.h"
#include "realnvwin32.h"
#endif

#ifndef NV4
#include "nvddobj.h"
#endif // NV4

#include "nvdd.h"
#include "nvcm.h"

#include "surfaces.h"
								

// provides access to the global data structures in ddmini.h
extern 		GLOBALDATA*			pDriverData;


volatile U032* 	nvTimerPtr = NULL;


vpSurfaces*			pMySurfaces = NULL;
NvNotification*	nvMyVPNotifiers = NULL;

const DWORD MY_CONNECTION_CAPS=	//DDVPCONNECT_DOUBLECLOCK			|
											//DDVPCONNECT_VACT					|
											/* we're capable of inverting the polarity */
											DDVPCONNECT_INVERTPOLARITY		|					
											/* we discard at least until the V bit goes low, and potentially more depending
											  on the setting of YCROP  as well as the current VBI situation  */
											//DDVPCONNECT_DISCARDSVREFDATA	|
											/* we WILL count the halfline */
											DDVPCONNECT_HALFLINE				|
											/*  these next are "client" only 
											//DDVPCONNECT_INTERLACED			|
											//DDVPCONNECT_SHAREEVEN			|
											//DDVPCONNECT_SHAREODD				|
											*/
											0;

DDPIXELFORMAT pf[] = {
	{sizeof(DDPIXELFORMAT),DDPF_FOURCC,  mmioFOURCC('U','Y','V','Y'),16,(DWORD)-1,(DWORD)-1,(DWORD)-1},
};
/*DDPIXELFORMAT pfvbi[] = {
	{sizeof(DDPIXELFORMAT),DDPF_FOURCC,  mmioFOURCC('R','A','W','8'),8,(DWORD)-1,(DWORD)-1,(DWORD)-1},
};
*/
DDPIXELFORMAT pfvbi[] = {
	{sizeof(DDPIXELFORMAT),DDPF_FOURCC,  mmioFOURCC('R','A','W','8'),8,(DWORD)-1,(DWORD)-1,(DWORD)-1},
};



//#define TESTCALLBACK
#ifdef TESTCALLBACK

void JoeCoolDudesCallbackRoutine(sCallBack* pCallbackStruct);

#endif

U032	getMilliTime(void);


void	getCurrentNanoTimer(U032 *	Most, U032 * Least) {
	volatile U032* myTimerLo = nvTimerPtr;
	volatile U032* myTimerHi = (U032*)(((U032)nvTimerPtr)+0x10);
	ASSERT(nvTimerPtr != NULL);
	ASSERT(Most 		!= NULL);
	ASSERT(Least 		!= NULL);
	*Least = *myTimerLo;
	*Most	= *myTimerHi;
}

U032	getMilliTime(void) {
	U032	bigTime;
	U032	smallTime;
	
	getCurrentNanoTimer(&bigTime, &smallTime);
	return (smallTime / 1000000) + bigTime * (0xFFFFFFFF/1000000);
			
}
	
/*

It appears that BPC has been programmd in such a way as to violate the API for VP.
So we need to compensate.  The problem is that the following scenario can happen.
CanCreateVP   VBI
CreateVP   VBI
UpdateVP   VBI
time passes
CanCreateVP   IMAGE
CreateVP  Image
UpdateVP   VBI+Image
timepasses
Destroy VP.

The key thing here is that the video ports will use the SAME port ID. so that should help us.


*/	

DWORD __stdcall CanCreateVideoPort32 (LPDDHAL_CANCREATEVPORTDATA lpInput)
{
    /*
     * If the lpInput->lpDDVideoPortDesc can not be supported, set
     * lpInput->ddRVal to the correct error code and return
     * DDHAL_DRIVER_HANDLED
     */		
	/* 	this is only a query to see if VideoPort can handle a certain requirement, 
		no structures are defined here, or even chip query */
	DPF("***CanCreateVideoPort32");

	ASSERT(lpInput!=NULL);
	ASSERT(lpInput->lpDDVideoPortDesc !=NULL);	
	
	if( pDriverData == NULL ) {
		DPF("   ***VideoPort not creatable  -->  pDriverData = NULL!   YIKES!");
		lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
		return DDHAL_DRIVER_HANDLED;
	}
	// Ok, if we got to here that means we're talking to the VXD MiniVDD properly... onward ho!
	
	// Check structure size
	if(lpInput->lpDDVideoPortDesc->dwSize   < sizeof( DDVIDEOPORTDESC ) ) {
		DPF("   ***VideoPort not creatable  -->  stucture length is not large enough");
		lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
		return DDHAL_DRIVER_HANDLED;
	}
	
	// check input connection GUID
	if ( !IsEqualGUID(&(lpInput->lpDDVideoPortDesc->VideoPortType.guidTypeID), &DDVPTYPE_CCIR656) )	 {
		DPF("   ***VideoPort not creatable  -->  GUID should be DDVPTYPE_CCIR656");
		lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
		return DDHAL_DRIVER_HANDLED;
	}
	
	// check to see if there are ports available... by looking at local allocation
	if (pDriverData->dwVideoPortsAvailable <=0 ) {

			// check to see if there are ports available... by looking at IDs
	   if (lpInput->lpDDVideoPortDesc->dwVideoPortID != 0 ) {
			DPF("   ***VideoPort not creatable  --> not enough video ports");
			lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
			return DDHAL_DRIVER_HANDLED;
		}

		DPF("CanCreate for Second VP with same ID Allowed.... silly API");
	}
	
	// the restrictions we have FieldWidth are dependant on maximum pitch specifiable
	//  pitch is 2^13 in size...
	if (lpInput->lpDDVideoPortDesc->dwFieldWidth > NV_MAX_FIELDWIDTH) {
		DPF("   ***VideoPort not creatable  --> field Width is too great");
		lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
		return DDHAL_DRIVER_HANDLED;
	}
	
	// the restrictions we have VBIWidth are dependant on maximum pitch specifiable
	//  pitch is 2^13 in size...  but there are 2 bytes in each pixel
	if (lpInput->lpDDVideoPortDesc->dwVBIWidth > NV_MAX_VBIWIDTH) {
		DPF("   ***VideoPort not creatable  --> VBI field Width is too great");
		lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
		return DDHAL_DRIVER_HANDLED;
	}
	
	// the restrictions we have on Field Height are dependant on maximum length specifiable
	//  length is 2^19 in size... which is but there are 2 bytes in each pixel
	if (lpInput->lpDDVideoPortDesc->dwFieldHeight * lpInput->lpDDVideoPortDesc->dwFieldWidth > NV_MAX_BUFFERLENGTH) {
		DPF("   ***VideoPort not creatable  --> Maximum buffer length exceed by field height too high");
		lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
		return DDHAL_DRIVER_HANDLED;
	}

	if (lpInput->lpDDVideoPortDesc->dwMaxPixelsPerSecond > NV_MAX_PIXELRATE) {
		DPF("   ***VideoPort not creatable  --> Sorry incoming data rate is too high");
		lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
		return DDHAL_DRIVER_HANDLED;
	}

	// we don't have any restrictions on Microseconds per field that I know of....
	//    lpInput->lpDDVideoPortDesc->dwMicrosecondsPerField;	// Microseconds per video field
    
	if ( lpInput->lpDDVideoPortDesc->VideoPortType.dwPortWidth  != 8 ) {
		DPF("   ***VideoPort not creatable  --> incoming connection width is not 8");
		lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
		return DDHAL_DRIVER_HANDLED;
	}
	
#ifdef NOCHECKHERE
			// the ones I'm not capable of   ANDed   with the ones Dx is asking for
	if( (~MY_CONNECTION_CAPS) & lpInput->lpDDVideoPortDesc->VideoPortType.dwFlags ) {
		// if we get here this should indicate that Dx is asking for a capability we're incapable of
		DPF("   ***VideoPort not creatable  --> Some of the capability flags bits are wrong");
		lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
		return DDHAL_DRIVER_HANDLED;
	
	}
#endif
		
	//  Ok, we've pretty much checked everything we can possibly check here... let's tell'em that
	// we can work!		

	lpInput->ddRVal = DD_OK;
	DPF("   ***VideoPort creatable! ***");
	return DDHAL_DRIVER_HANDLED;
}


U032 	HookUpVxdStorage(void) {

	
	HANDLE 		aVXDHandle;
	U032 i;
	
	//DPF("NOW ATTEMPTING VXD stuff");
	

	
	//DPF("\n\n\n\nThe DeviceID is:%d\n\n\n\n",pDriverData->thisDeviceID);
		
	if( pDriverData->thisDeviceID == 0 ) {
		DPF("We are Primary controller! \n");
#ifdef NV4
	
		aVXDHandle = CreateFile("\\\\.\\NV4.VXD", 0,0,0, CREATE_NEW, FILE_FLAG_DELETE_ON_CLOSE, 0);
#else
		aVXDHandle = CreateFile("\\\\.\\NV3.VXD", 0,FILE_SHARE_READ,0, CREATE_NEW, FILE_FLAG_DELETE_ON_CLOSE, 0);
#endif
	
	} else {
		DPF("We are not primary controller :-( \n");
#ifdef NV4
	
		aVXDHandle = CreateFile("\\\\.\\NV4mini2.VXD", 0,0,0, CREATE_NEW, FILE_FLAG_DELETE_ON_CLOSE, 0);
#else
		aVXDHandle = CreateFile("\\\\.\\NV3mini2.VXD", 0,FILE_SHARE_READ,0, CREATE_NEW, FILE_FLAG_DELETE_ON_CLOSE, 0);
#endif
	
	
	}

	if((aVXDHandle == NULL) || (aVXDHandle ==INVALID_HANDLE_VALUE)) {
		U032	daError;
		DPF("Can't get Vxd handle   :-(");
		daError = GetLastError();
		DPF("The error was %d  or %x",daError,daError);
		if(daError == 50 ) {
			DPF("Which means most likely that you don't have a version of NVX.VXD or NVXmini2 which supports IOCTL");	
		}
		return FALSE;	
		
	} 
	
	// nother block
	{
		U032				inBuffer;
		NVVDDPROCTABLE	aTable;
		U032				outputSize = 0;
			
		// pass in the pointer to the direct draw object.. this may be useful later
//		inBuffer = (U032) lpInput->lpDD;
		
		aTable.getStoragePointer = NULL;
		aTable.dwPDDDriver = 0;
		aTable.handleBufferInterrupts = NULL;
		
		if(!DeviceIoControl(aVXDHandle,
							VDD_IOCTL_NV_FILLTABLE,		// control code of operation to perform
							&inBuffer,							// pointer to buffer to supply input data
							4,								// size of input buffer
							&aTable,					// pointer to buffer to receive output data
							sizeof(NVVDDPROCTABLE),	// size of output buffer
							&outputSize,				// pointer to variable to receive output byte count
							NULL 							// pointer to overlapped structure for asynchronous operation
		) ){
			// cool we made it.   Now copy our temporarly stuff into the real one!
			
			// first get the storage pointer
			if( aTable.getStoragePointer != NULL ) {
				pMySurfaces = (vpSurfaces*)(aTable.getStoragePointer)();
			} else {
				DPF("didn't get a valid pointer to a routine");
			
				CloseHandle(aVXDHandle);
				return FALSE;	
			}
			
			if( pMySurfaces != NULL ) {
				// we cool!  everybody get funky one more time!  and copy that stuff in
				pMySurfaces->myVXDhandle = aVXDHandle;
				memcpy (&pMySurfaces->myTable, &aTable,  sizeof (NVVDDPROCTABLE));
				
			} else {
				DPF("didn't get the storage pointer");
			
				CloseHandle(aVXDHandle);
				return FALSE;	
			}
			
		}	else {
			//	failure
			//close the VXD
			DPF("couldn't call the VXD via IOCTL properly");
			CloseHandle(aVXDHandle);
			return FALSE;	
		}
		
	}
	
	nvMyVPNotifiers = pMySurfaces->pTheNotifiers;
	pMySurfaces->numberOfSurfaces =0;

	for(i=0;i<MAXVPSURFACES;i++) {
		pMySurfaces->Surfaces[i] = NULL;
	}
	pMySurfaces->CurrentBufferSurface[4] = NOSURFACEPROGRAMED;				// to associate the HW buffer with an arrary index
			 
	pMySurfaces->CurrentScanMode =SEPERATEBUF;		// seperate or interleaved buffersx
	if(pMySurfaces->bInvertedFields ) 	{
		pMySurfaces->lastField = ODD;	// this should be even so we'll always start on odd ( hopefully... :-)
		pMySurfaces->lastVBIField = ODD;
	} else {
		pMySurfaces->lastField = EVEN;
		pMySurfaces->lastVBIField = EVEN;
	}	
	pMySurfaces->VBIstart = 0;;
	// general information
	pMySurfaces->bSkipNextField = FALSE;
	pMySurfaces->dwInHeight = 0;
	pMySurfaces->dwInWidth = 0;
	pMySurfaces->dwImageStartLine =10;				// ditch a minimum of 10 lines
	pMySurfaces->dwVBIStartLine = 0;
	pMySurfaces->dwVBIHeight = 0;
	pMySurfaces->dwPreHeight = 0;					// height and width before prescaling
	pMySurfaces->dwPreWidth = 0;
	pMySurfaces->dwOriginX = 0;						// orgins to move data within the surface
	pMySurfaces->dwOriginY = 0;
	pMySurfaces->bThreadDead = TRUE;
	pMySurfaces->bThreadRunning = FALSE;

	pMySurfaces->bStopVP = FALSE;							// indicates to the thread that it should NOT reprogram

	pMySurfaces->Timings.LoopCount=0;

	pMySurfaces->pBuffer0Mem = (U032) NULL;
	pMySurfaces->pBuffer1Mem = (U032) NULL;
	pMySurfaces->curOverlay = 0;			// this way we should start into 0
	
	// initialize all the callback stuff	
	pMySurfaces->ImageCallbackRoutine = NULL;			
	pMySurfaces->VBICallbackRoutine = NULL;			
	pMySurfaces->myIMGCallbackInfo.intCount = 0;			
	pMySurfaces->myVBICallbackInfo.intCount = 0;	
	pMySurfaces->myIMGCallbackInfo.dwFlags = 0;
	pMySurfaces->myVBICallbackInfo.dwFlags = 0;
	pMySurfaces->myIMGCallbackInfo.dwVersion = 0x100;
	pMySurfaces->myVBICallbackInfo.dwVersion = 0x100;		
	pMySurfaces->myIMGCallbackInfo.curBufferAddr = (U032)NULL;			
	pMySurfaces->myVBICallbackInfo.curBufferAddr = (U032)NULL;			
	pMySurfaces->myIMGCallbackInfo.lastBufferAddr = (U032)NULL;			
	pMySurfaces->myVBICallbackInfo.lastBufferAddr = (U032)NULL;			
	pMySurfaces->myIMGCallbackInfo.dwSize = sizeof(sCallBack);			
	pMySurfaces->myVBICallbackInfo.dwSize = sizeof(sCallBack);	
	if(pDriverData == NULL ) {
		// dude this is PROBLEM!!!
		return FALSE;
	}
	pMySurfaces->pDriverData = pDriverData;		
		
	pMySurfaces->DXIRQCallbackSources = 0;;
	pMySurfaces->pDXIRQCallback = (U032) NULL;
	pMySurfaces->dwIrqContext = 0;
	pMySurfaces->SetupComplete = FALSE;
	pMySurfaces->dwNextEmpty = 0;
	pMySurfaces->dwLastEmpty = (MAXTRANSFERS-1);
	pMySurfaces->lastSurface = 999;
	pMySurfaces->lastBuffer = 999;
	return TRUE;
}

/*
 * CreateVideoPort32
 *
 * This function is optional, define all objects if they have not already been defined.
 */
DWORD __stdcall CreateVideoPort32 (LPDDHAL_CREATEVPORTDATA lpInput)
{
    /*
     * This function allows the HAL to set internal flags and
     * become aware that a video port has been created. It should
     * always return DDHAL_DRIVER_NOTHANDLED.
     */

	/* According to DDHAL documentation, this procedure can return DDHAL_DRIVER_NOTHANDLED
	   as well, signifying that the createvideoport fn could not be completed
	   
	   DirectDraw MS layer will prevent creating more videoports that is
	   available.

	   */     
	DWORD		returnVal = DDHAL_DRIVER_HANDLED;
	// we should only have to get this once on creation
	
	if(pMySurfaces == NULL )
		if(!HookUpVxdStorage() )
		{
			lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
			return DDHAL_DRIVER_HANDLED;
		}
	if( pMySurfaces->pDriverData == NULL )
		if(!HookUpVxdStorage() )
		{
			lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
			return DDHAL_DRIVER_HANDLED;
		}
	
	
	if( pMySurfaces->SetupComplete ) {
			// we may be attempting a "second" CreateVideo port with the same ID..
			// let's check that.
			
			//CODE we should probably check here for non-duplicat VBI and Image, but we'll just let that slide for now.
			
			if (lpInput->lpDDVideoPortDesc->dwVideoPortID == 0 ) {
				// this is the second create
				DPF("***  HACKED second video port create has been called.");
				DPF("  now shunting to hyperspace modulator bypass code.  Turn reality distortion field driver code to 11");
	
				
				DPF("  Size of the DDVIDEOPORTDESC structure     %d",lpInput->lpDDVideoPortDesc->dwSize);
				DPF("  Width of the video port field.            %d",lpInput->lpDDVideoPortDesc->dwFieldWidth);
				DPF("  Width of the VBI data.                    %d",lpInput->lpDDVideoPortDesc->dwVBIWidth);
				DPF("  Height of the video port field.           %d",lpInput->lpDDVideoPortDesc->dwFieldHeight);
				DPF("  Microseconds per video field.             %d",lpInput->lpDDVideoPortDesc->dwMicrosecondsPerField);
				DPF("  Maximum pixel rate per second.            %d",lpInput->lpDDVideoPortDesc->dwMaxPixelsPerSecond);
				DPF("  Video port ID (0 - (dwMaxVideoPorts -1)). %d",lpInput->lpDDVideoPortDesc->dwVideoPortID);
				DPF("  Reserved for future use - set to zero.    %d",lpInput->lpDDVideoPortDesc->dwReserved1);
				
				DPF("  Size of the DDVIDEOPORTDESC.dwSize        %d",lpInput->lpDDVideoPortDesc->VideoPortType.dwSize);
				DPF("              DDVIDEOPORTDESC.dwPortWidth   %d",lpInput->lpDDVideoPortDesc->VideoPortType.dwPortWidth);
				DPF("              DDVIDEOPORTDESC.guidTypeID    %d",lpInput->lpDDVideoPortDesc->VideoPortType.guidTypeID);
				DPF("              DDVIDEOPORTDESC.dwFlags       %d",lpInput->lpDDVideoPortDesc->VideoPortType.dwFlags);
	
				lpInput->ddRVal = DD_OK;
				return returnVal;
			}
	}
		
	if(lpInput->lpDDVideoPortDesc->VideoPortType.dwFlags & DDVPCONNECT_INTERLACED ) {
		pMySurfaces->bInputInterLaced = TRUE;		
	} else {
		pMySurfaces->bInputInterLaced = FALSE;		
	}
	
	if(pMySurfaces->bInputInterLaced)
		pMySurfaces->CurrentCaptureMode =EVENODD;		// indicates which fields will be capture Even	
	else 
		pMySurfaces->CurrentCaptureMode =PROGRESSIVE;	// we're assuming progressive is ALWAYS even even even

		 
	 
	if(lpInput->lpDDVideoPortDesc->VideoPortType.dwFlags & DDVPCONNECT_INVERTPOLARITY ) {
		DPF("DDVPCONNECT_INVERTPOLARITY		on");
		pMySurfaces->bInvertedFields = TRUE;
		// Now check for the weird exception case when we want to skip half line as well...
		if(lpInput->lpDDVideoPortDesc->VideoPortType.dwFlags & DDVPCONNECT_HALFLINE ) {
			DPF("DDVPCONNECT_HALFLINE		on");
			pMySurfaces->bInvertedFields = FALSE;
		} else {
			DPF("DDVPCONNECT_HALFLINE		off");
		
		}
		
	} else {
		DPF("DDVPCONNECT_INVERTPOLARITY		off");
		pMySurfaces->bInvertedFields = FALSE;
	}
			 
	if(lpInput->lpDDVideoPortDesc->VideoPortType.dwFlags & DDVPCONNECT_HALFLINE ) {
		DPF("DDVPCONNECT_HALFLINE		      on");
	} else {
		DPF("DDVPCONNECT_HALFLINE		      off");
	}
		

#ifdef  MULTI_MON
	nvTimerPtr = (U032 *) NvDeviceBaseGet(NV_DEV_TIMER, pDriverData->dwDeviceIDNum );
#else   /* MULTI_MON */
	nvTimerPtr = (U032 *) NvDeviceBaseGet(NV_DEV_TIMER );
#endif  /* MULTI_MON */
	pMySurfaces->pNvTimer = nvTimerPtr;

	DPF("***CreateVideoPort32");


	DPF("  Size of the DDVIDEOPORTDESC structure     %d",lpInput->lpDDVideoPortDesc->dwSize);
	DPF("  Width of the video port field.            %d",lpInput->lpDDVideoPortDesc->dwFieldWidth);
	DPF("  Width of the VBI data.                    %d",lpInput->lpDDVideoPortDesc->dwVBIWidth);
	DPF("  Height of the video port field.           %d",lpInput->lpDDVideoPortDesc->dwFieldHeight);
	DPF("  Microseconds per video field.             %d",lpInput->lpDDVideoPortDesc->dwMicrosecondsPerField);
	DPF("  Maximum pixel rate per second.            %d",lpInput->lpDDVideoPortDesc->dwMaxPixelsPerSecond);
	DPF("  Video port ID (0 - (dwMaxVideoPorts -1)). %d",lpInput->lpDDVideoPortDesc->dwVideoPortID);
	DPF("  Reserved for future use - set to zero.    %d",lpInput->lpDDVideoPortDesc->dwReserved1);
	
	DPF("  Size of the DDVIDEOPORTDESC.dwSize        %d",lpInput->lpDDVideoPortDesc->VideoPortType.dwSize);
	DPF("              DDVIDEOPORTDESC.dwPortWidth   %d",lpInput->lpDDVideoPortDesc->VideoPortType.dwPortWidth);
	DPF("              DDVIDEOPORTDESC.guidTypeID    %d",lpInput->lpDDVideoPortDesc->VideoPortType.guidTypeID);
	DPF("              DDVIDEOPORTDESC.dwFlags       %d",lpInput->lpDDVideoPortDesc->VideoPortType.dwFlags);
	
	DPF("	Reserved for future use - set to zero.     %d",lpInput->lpDDVideoPortDesc->dwReserved2);
	DPF("	Reserved for future use - set to zero.     %d",lpInput->lpDDVideoPortDesc->dwReserved3);

	
	// We'll assume for now that since CanCreate passed that our parameters are valid at this point
	// we need to setup the entire NV object system at this point

	// theorectically we should not have a channel open... let's check that?

	// get our OWN copy of the driver data
		
	returnVal = SetupVP ( lpInput);
	

	//pMySurfaces->pVPChanPtr = (NvChannel * ) pDriverData->NvDevFlatVPE;


	// For the overlay flip, store away a channel pointer
#ifdef NV4
	pMySurfaces->pOverlayChanPtr = (NvChannel*) pDriverData->NvDevVideoFlatPio;
#else
	pMySurfaces->pOverlayChanPtr = (NvChannel*) pDriverData->NvDevFlatPio;
#endif	
	pMySurfaces->dwOverlaySubChan = NV_DD_SPARE;
	pMySurfaces->dwOverlayObjectID = NV_DD_YUV422_VIDEO_FROM_MEMORY;
	pMySurfaces->dwScalerObjectID = NV_DD_VIDEO_SCALER;
	pMySurfaces->dwDVDObjectID = NV_DD_DVD_SUBPICTURE;
	
#ifdef TESTCALLBACK

	// let's register an IMAGE callback here and see what happens
	{
		HANDLE bVXDHandle;
		U032	 inBuffer;
		//U032	 returnCode;
		U032	 outputSize;
		SETCALLBPROC	pSetCallback;
		
		inBuffer = 0;		
		
#ifdef NV4		
		bVXDHandle = CreateFile("\\\\.\\NV4", 0,0,0, CREATE_NEW, FILE_FLAG_DELETE_ON_CLOSE, 0);
#else
		bVXDHandle = CreateFile("\\\\.\\NV3", 0,0,0, CREATE_NEW, FILE_FLAG_DELETE_ON_CLOSE, 0);
#endif	// NV4		
		if(bVXDHandle != NULL ) {
			if(!DeviceIoControl(bVXDHandle,
										VDD_IOCTL_NV_GETSETCALLBACK,		// control code of operation to perform
										&inBuffer,							// pointer to buffer to supply input data
										4,										// size of input buffer
										&pSetCallback,						// pointer to buffer to receive output data
										4,										// size of output buffer
										&outputSize,						// pointer to variable to receive output byte count
										NULL 									// pointer to overlapped structure for asynchronous operation
									)
				 ){
						
						// things worked, the 
						inSCBStruct		inBuf;
						outSCBStruct	outBuf;
							// NOTE USE OF FLAGS FROM VPCALLBk.h
						inBuf.flags = IMAGESURFACE;
						inBuf.pTheCallback = JoeCoolDudesCallbackRoutine;
						
						(pSetCallback)(&inBuf,&outBuf);
						
			} else {
						
						// bummer, for some reason, we were unable to set your callback
			
			}
					
			CloseHandle(bVXDHandle);
									
		}
		
		
	}
#endif	

	// don't forget to decrement the number of video ports avail number which is 
	lpInput->ddRVal = DD_OK;
	
	return returnVal;
}


#ifdef TESTCALLBACK

void JoeCoolDudesCallbackRoutine(sCallBack* pCallbackStruct) {
	DPF("WoW we made it to JoeCoolDudesCallbackRoutine interrupt=%d",pCallbackStruct->intCount);
	
	
}


#endif
 /*
 * GetVideoPortBandwidth32
 *
 * This function is required
 */
DWORD __stdcall GetVideoPortBandwidth32 (LPDDHAL_GETVPORTBANDWIDTHDATA lpInput)
{

	DPF("***GetVideoPortBandwidth32");
	/*
	 * Determine how much bandwidth is available for the specified
	 * output format and fill in the information.
	 */
	 
	 // we are lucky in that we basically only support ONE format  YEAH!
	 
	if (lpInput->dwFlags & DDVPB_TYPE) {
		lpInput->lpBandwidth->dwCaps = DDVPBCAPS_DESTINATION;  // we are limited by the "shrink" of the overlay 			
	}
	 
	if (lpInput->dwFlags & DDVPB_VIDEOPORT) {
		// The following four should indicate the MINIMUM stretch values represented as percentages times 10
		//  so if we could not stretch below 75% of the orginal size, the we should put in 750
		// for now I'll leave these "as is" because I need to collect the correct values -CJS
		lpInput->lpBandwidth->dwOverlay 				= 1000;
		lpInput->lpBandwidth->dwColorkey 				= 1000;  // Overlay/video port/colorkey works at 1X
		lpInput->lpBandwidth->dwYInterpolate			= 1000;	 // Overlay/video port works at 1X
		lpInput->lpBandwidth->dwYInterpAndColorkey		= 1000;  // Overlay/video port/interpolation works at 2X
	}
	
	
	if (lpInput->dwFlags & DDVPB_OVERLAY) {
		DPF("   We are NOT an overlay limited device but a destination ");
		DPF("      limited device we should not have been called");
	}
	
	lpInput->ddRVal = DD_OK;
	return DDHAL_DRIVER_HANDLED; 
}

/*
 * GetVideoPortInputFormat32
 *
 * This function is required
 */
DWORD __stdcall GetVideoPortInputFormat32 (LPDDHAL_GETVPORTINPUTFORMATDATA lpInput)
{
   /* Only 1 input format supported UYVY 4:2:2 */
	/* Data stored in 32bit word as U[7:0] Y1[15:8] V[23:16] Y2[31:24] */
	DPF("   ***GetVideoPortInputFormat32");
	/*
	* The HAL is gaurenteed that the buffer in lpInput->lpddpfFormat
	* is large enough to hold the information
	*/

	
	if (lpInput->dwFlags & DDVPFORMAT_VIDEO ) {
		lpInput->dwNumFormats = 1;
		if (lpInput->lpddpfFormat != NULL) {
			memcpy (lpInput->lpddpfFormat, &pf[0],  sizeof (DDPIXELFORMAT));
		}
	}

/*
	if (lpInput->dwFlags & DDVPFORMAT_VBI ) {
		lpInput->dwNumFormats = 1;
		if (lpInput->lpddpfFormat != NULL) {
			memcpy (lpInput->lpddpfFormat, &pf[0],  sizeof (DDPIXELFORMAT));
		}
	}
*/
	if (lpInput->dwFlags & DDVPFORMAT_VBI ) {
		lpInput->dwNumFormats = 1;
		if (lpInput->lpddpfFormat != NULL) {
			memcpy (lpInput->lpddpfFormat, &pfvbi[0],  sizeof (DDPIXELFORMAT));
		}
	}

	lpInput->ddRVal = DD_OK;
	return DDHAL_DRIVER_HANDLED;
}


/*
 * GetVideoPortOutputFormat32
 *
 * This function is required
 */
DWORD __stdcall GetVideoPortOutputFormat32 (LPDDHAL_GETVPORTOUTPUTFORMATDATA lpInput)
{
  	/* OutputFormat does not convert UYUV to RGB, this would be done by Overlay control */
	/* Data stored in 32bit word as U[7:0] Y1[15:8] V[23:16] Y2[31:24] */

	DPF("***GetVideoPortOutputFormat32");

	/* OutputFormat does not convert UYUV to RGB, this would be done by Overlay control */
	/* Data stored in 32bit word as U[7:0] Y1[15:8] V[23:16] Y2[31:24] */

	// default
	lpInput->dwNumFormats = 1;
	if (lpInput->lpddpfOutputFormats != NULL) {
		memcpy (lpInput->lpddpfOutputFormats, lpInput->lpddpfInputFormat, sizeof (DDPIXELFORMAT));
	}

	// for the video data
	if (lpInput->dwFlags & DDVPFORMAT_VIDEO) {// video formats
		// is input format a FOURCC
		if (lpInput->lpddpfInputFormat->dwFlags & DDPF_FOURCC ) {
			// is it UYVY
			if (lpInput->lpddpfInputFormat->dwFourCC == mmioFOURCC('U','Y','V','Y')) {
				// translation of UYVY is UYVY (ie no translation)
   	    	lpInput->dwNumFormats = 1;
	   	   if (lpInput->lpddpfOutputFormats != NULL) {
					memcpy (lpInput->lpddpfOutputFormats, pf, sizeof (DDPIXELFORMAT) );
		    	}
			}
		}
	}
	
	// for the VBI data
	if (lpInput->dwFlags & DDVPFORMAT_VBI) {// VBI formats
		// is input format a FOURCC
		if (lpInput->lpddpfInputFormat->dwFlags & DDPF_FOURCC ) {
			// is it UYVY
			if (lpInput->lpddpfInputFormat->dwFourCC == mmioFOURCC('R','A','W','8')) {
				// translation of UYVY is UYVY (ie no translation)
   	    	lpInput->dwNumFormats = 1;
	   	   if (lpInput->lpddpfOutputFormats != NULL) {
					memcpy (lpInput->lpddpfOutputFormats, pfvbi, sizeof (DDPIXELFORMAT) );
		    	}
			} 		
		}
	}
	
	lpInput->ddRVal = DD_OK;
   return DDHAL_DRIVER_HANDLED;
}


/*
 * GetVideoPortField32
 *
 * This function is only required if readback of the current
 * field is supported.
 */
// needed defines for mediaport


DWORD __stdcall GetVideoPortField32 (LPDDHAL_GETVPORTFIELDDATA lpInput)
{
    /*
     * Make sure the video port is ON.  If not, set
     * lpInput->ddRVal to DDERR_VIDEONOTACTIVE and return.
     */

    /*
     * Readback whether the field is even or odd.  lpInput->bField is
     * set to TRUE if the current field is even.
     */
	//DPF("***GetVideoPortField32");
	
	if (pMySurfaces->dwVideoPortStatus == VP_NOT_RUNNING) {
		//DPF("   Video is not active!!!");
		lpInput->bField = 0;
	   lpInput->ddRVal = DDERR_VIDEONOTACTIVE;	
	} else {
	 /*
     * Readback the current line number and put it in
     * lpInput->dwLine
     */

		lpInput->bField = GetField();
		
		lpInput->ddRVal = DD_OK;

		lpInput->bField = 0;
	}	
	
	return DDHAL_DRIVER_HANDLED;
}

/*
 * GetVideoPortLine32
 *
 * This function is only required if readback of the current
 * video line number (0 relative) is supported.
 */
    /*
     * Make sure the video port is ON.  If not, set
     * lpInput->ddRVal to DDERR_VIDEONOTACTIVE and return.
     */

DWORD __stdcall GetVideoPortLine32 (LPDDHAL_GETVPORTLINEDATA lpInput)
{

	DPF("***GetVideoPortLine32");
 
 	// need channel poiner for this!
	if( GLOBDATAPTR->NvDevFlatVPE == (DWORD) NULL ) {
	 	lpInput->ddRVal = DDERR_SURFACELOST;
		return DDHAL_DRIVER_HANDLED; 
	}
	
	if (pMySurfaces->dwVideoPortStatus == VP_NOT_RUNNING) {
		//DPF("   Video is not active!!!");
		lpInput->dwLine = 0;
	   lpInput->ddRVal = DDERR_VIDEONOTACTIVE;	
	} else {
	 /*
     * Readback the current line number and put it in
     * lpInput->dwLine
     */

		lpInput->dwLine = getCurLine();
		lpInput->ddRVal = DD_OK;
		
	}	
	
	return DDHAL_DRIVER_HANDLED;
}


/*
 * GetVideoPortConnectInfo
 *
 * This is the old:
 * Returns the GUIDs describing the connections that can be supported.
 * Think of a GUID simply as a 128 bit FOURCC that you don't have to
 * register.  This function is required.

 * And this is the new:
 * Fills in specified array of connections
 *
 */
DWORD __stdcall GetVideoPortConnectInfo (LPDDHAL_GETVPORTCONNECTDATA lpInput)
{
    /*
     * If lpInput->lpGUIDs is NULL, simply return the number of GUIDS
     * supported
     */

	// eventually we should check dwPortId if there are more than one port in operation.
	// however since all the port will likely have the same capabilities maybe it's not an
	// issue
	
	DPF("***GetVideoPortConnectInfo");
	
	lpInput->dwNumEntries = 1;
	if(lpInput->lpConnect == NULL) {
		// this means that Dx is looking for the number of ways you can connect so that it can
		// allocate a structure for the next time around
		lpInput->ddRVal = DD_OK;
	} else {
		// fill in the one structure that we asked for..	
		memcpy (&(lpInput->lpConnect->guidTypeID), &DDVPTYPE_CCIR656, sizeof (GUID));
		lpInput->lpConnect->dwPortWidth = 8;
		lpInput->lpConnect->dwFlags = MY_CONNECTION_CAPS;	
	}

	return DDHAL_DRIVER_HANDLED;

}


/*
 * DestroyVideoPort32
 *
 * This optional function notifies the HAL when the video port
 * has been destroyed.
 */
DWORD __stdcall DestroyVideoPort32 (LPDDHAL_DESTROYVPORTDATA lpInput)
{
	
	DPF("***DestroyVideoPort32");

	
	pMySurfaces->ImageCallbackRoutine = NULL;			
	pMySurfaces->VBICallbackRoutine = NULL;			
		
	tearDownVP();

	nvTimerPtr = NULL;
	
	lpInput->ddRVal = DD_OK;
	
	CloseHandle(pMySurfaces->myVXDhandle);
	pMySurfaces->myVXDhandle = NULL;

	return DDHAL_DRIVER_HANDLED;
}


/*
 * GetVideoPortFlipStatus32
 *
 * This required function allows DDRAW to restrict access to a surface
 * until the physical flip has occurred, allowing doubled buffered capture.
 */

    /*
     * If the physical flip has not yet occurred, return
     * DDERR_WASSTILLDRAWING
     */

DWORD __stdcall GetVideoPortFlipStatus32 (LPDDHAL_GETVPORTFLIPSTATUSDATA lpInput)
{
	
	U032	dwIndex;
	
	//DPF("***GetVideoPortFlipStatus32");

#if 0
	if( GLOBDATAPTR->NvDevFlatVPE == NULL ) {
	 	lpInput->ddRVal = DDERR_SURFACELOST;
		return DDHAL_DRIVER_HANDLED; 
	}

#endif
	if( pMySurfaces->dwVideoPortStatus == VP_NOT_RUNNING ) {
   	lpInput->ddRVal = DD_OK;
		return DDHAL_DRIVER_HANDLED;
	}
	
	// search through all of our known surfaces looking for the one it's curious about
	for (dwIndex = 0; dwIndex < pMySurfaces->numberOfSurfaces ; dwIndex++) {
		if (pMySurfaces->Surfaces[dwIndex]->pVidMem == lpInput->fpSurface) {
			// this means we've found the surface that DX is curious about												
			if( pMySurfaces->Surfaces[dwIndex]->pNvNotify == NULL ) {
				ASSERT(1==0);
				DPF("   NOTIFY WAS NULL  !!!!!!!!!!!");
   			lpInput->ddRVal = DD_OK;
				return DDHAL_DRIVER_HANDLED;
			}
			
			
			if( pMySurfaces->Surfaces[dwIndex]->bAutoFlip ) {
				// in the case of auto-flipping just always say we're done...
				lpInput->ddRVal = DD_OK;
			} else {
				if (pMySurfaces->bFlipRequested == TRUE ) {
					lpInput->ddRVal = DDERR_WASSTILLDRAWING;
				} else {
					lpInput->ddRVal = DD_OK;
				}
			}
			// return here... we found the surface
			return DDHAL_DRIVER_HANDLED;
		}
	}
	
	DPF("   ***FlipStatus having trouble  --> Surface does");
	DPF("          not exist in my list of surfaces");
	lpInput->ddRVal = DD_OK;

	return DDHAL_DRIVER_HANDLED;
}


/*
 * FlipVideoPort32
 *
 * This function is required
 *
 * Issues:
 *			Correct use of notifiers
 *			Updating surface logging info
 *			What if new surface has not got same or less capabilites as replaced surface

 *			Does not work because class 66 doesn't allow insertion of buffers
 *
 */

/*
important:
			Curr surface should be known to us
			Targ surface could be new

			both surfaces should have this flag: DDSCAPS_LIVEVIDEO set in ->ddsCaps structure
*/
DWORD __stdcall FlipVideoPort32 (LPDDHAL_FLIPVPORTDATA lpInput)
{

    /*
     * Program registers to do the actual flip
     */

    /*
     * Save information for BOTH lpSurfCurr so we can know in the future
     * when the physical flip has occurred.
     */


	// Check that both surfaces are in our list
	U032	newSurfaceIndex;
	U032	oldSurfaceIndex;
        //	U032	counter;
	DPF("***FlipVideoPort32");
	if( GLOBDATAPTR->NvDevFlatVPE == (DWORD) NULL ) {
	 	lpInput->ddRVal = DDERR_SURFACELOST;
		return DDHAL_DRIVER_HANDLED; 
	}
	lpInput->ddRVal = DD_OK;
	
	oldSurfaceIndex = findSurface(lpInput->lpSurfCurr);
	if(oldSurfaceIndex  != SURFACENOTFOUND ) {
		newSurfaceIndex = findSurface(lpInput->lpSurfTarg);
		if(newSurfaceIndex == SURFACENOTFOUND ) {
			// in the case of non-interleaved surfaces this might be even more different
			// because we have essentially to replace TWO places where the old surface might be
			// residing...  not just one   non-auto flip SUCKS.  
			if( oldSurfaceIndex < pMySurfaces->VBIstart ) {
				replaceSurfaceWithSurface(oldSurfaceIndex,lpInput->lpSurfTarg, FALSE);
			} else {
				replaceSurfaceWithSurface(oldSurfaceIndex,lpInput->lpSurfTarg, TRUE);
			}
			newSurfaceIndex = oldSurfaceIndex;
		}
		pMySurfaces->bFlipRequested = TRUE;
		 
		if(newSurfaceIndex != SURFACENOTFOUND ) {
#if 0
			//  Now do some stuff... uh.. what?
			
			// Find out which of the buffers what programmed for the old surface
			U032	dwBufferIndex = NOSURFACEPROGRAMED;
			{
				U032 i;
				for(i=0;i<4;i++) {
					if(oldSurfaceIndex == pMySurfaces->CurrentBufferSurface[i] ) {
						dwBufferIndex = i;
						break;
					}
				}
				if (i == 4 ) {
					DPF("   Not sure which buffer was attached to the Current Surface in FlipVideoPort");
					return DDHAL_DRIVER_NOTHANDLED;
				}	
			}
			
			
			//  We could wait here until we know the hardware is done...
			//  instead we'll just check it real quick and print a whiner if it's not done
			//  and then fail
			{
				NvNotification* 	pNotify = pMySurfaces->Surfaces[oldSurfaceIndex]->pNvNotify;
				if(pNotify != NULL) {
					if (pNotify->status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS ) {
						DPF("   Attempting to flip out a surface which is still in progress");
						// we should hang out here until it's done....
						counter = 0;
						while((pNotify->status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS ) && (counter < 3000000)) {
							counter++;
						}
					}
					// check to see if we've had an error 
					//    there are LOTS of these....
					if ( (pNotify->status != NV04D_NOTIFICATION_STATUS_IN_PROGRESS ) |
						  (pNotify->status != NV04D_NOTIFICATION_STATUS_DONE_SUCCESS ) |
						  (pNotify->status != NV04D_NOTIFICATION_STATUS_NOT_LAUNCHED ) ){
						DPF("   Attempting to flip out a surface which had an error during capture");
						//return DDHAL_DRIVER_NOTHANDLED;
					}
				} else {
					DPF("   Attempting to flip out a surface where the notifier was NULL");
					return DDHAL_DRIVER_NOTHANDLED;
				}
			}

#endif			
			// Ok, program up the switch
			//ProgramBufferWithSurface(dwBufferIndex,newSurfaceIndex,FALSE);
			
		
		} else {
			DPF("   Unable to find Target Surface during FlipVideoPort32");
			DPF("   There was a note that we could be receiving new surfaces ");
			DPF("                      ( Tobin or MS ?)..... need to add code for this");
			
			return DDHAL_DRIVER_NOTHANDLED;
		}
	
	} else {
		DPF("   Unable to find Current Surface during FlipVideoPort32");
		return DDHAL_DRIVER_NOTHANDLED;
	}
  	
	lpInput->ddRVal = DD_OK;
	
	return DDHAL_DRIVER_HANDLED;
}

#if 0
U032 startSurfaces(U032	bInterleave, VPSTATE*	pVideoPortStatus ) {
	U032	rValue = DD_OK;
	VPSTATE	myState = *pVideoPortStatus;
	// figure out which buffers to program up and launch them...
	if(bInterleave) {
		 DPF("   Now Launching surfaces.... INTERLEAVED");
	} else {
		 DPF("   Now Launching surfaces.... NOT INTERLEAVED");
	}
	// zero out the last overlay scaler size so we're sure it gets reprogrammed
	pMySurfaces->lastsrcDeltaY = 0;
	pMySurfaces->bStopVP = FALSE;	
	if( bInterleave ) {
		// both buffers will point to the same surface
		if( pMySurfaces->VBIstart >0 ) {
			if( ProgramBufferWithSurface(0,0,FALSE) )
				rValue = DDERR_INVALIDPARAMS;
			
			// since this is interleave always start the second buffer with the first surface
			if( ProgramBufferWithSurface(1,0,FALSE) )
				rValue = DDERR_INVALIDPARAMS;
			myState |= VP_IMAGE_CAPTURING;
		}
	} else {
	
		// buffers will point to consecutive surfaces
		if( pMySurfaces->VBIstart >0 ) {
			if( ProgramBufferWithSurface(0,0,FALSE) )
				rValue = DDERR_INVALIDPARAMS;
			myState |= VP_IMAGE_CAPTURING;
		}
		// check for another surface
		if( pMySurfaces->VBIstart > 1 ) {
			if( ProgramBufferWithSurface(1,1,FALSE) )
				rValue = DDERR_INVALIDPARAMS;
		} else {
			// fire up the second buffer at the first surface
			if( ProgramBufferWithSurface(1,0,FALSE) )
				rValue = DDERR_INVALIDPARAMS;
		}
	}
			
	// Now do VBI
	// start first vbi on first surface
	if( (pMySurfaces->numberOfSurfaces - pMySurfaces->VBIstart) > 0 ) {
		if( ProgramBufferWithSurface(2,pMySurfaces->VBIstart,FALSE))
				rValue = DDERR_INVALIDPARAMS;
		myState |= VP_VBI_CAPTURING;
	
		// now check to see if we have another surface
		if( (pMySurfaces->numberOfSurfaces - pMySurfaces->VBIstart) > 1 ) {
			if( ProgramBufferWithSurface(3,pMySurfaces->VBIstart+1,FALSE))
					rValue = DDERR_INVALIDPARAMS;
		} else {
			// set second buffer to first surface
			if( ProgramBufferWithSurface(3,pMySurfaces->VBIstart+0,FALSE))
					rValue = DDERR_INVALIDPARAMS;
		}
	}	
	*pVideoPortStatus = myState;
	
	return rValue;
}

#endif 

U032 startNV3DelayedStart(U032	bInterleave, VPSTATE*	pVideoPortStatus, U032 milliSecondsOfDelay ) {
	
	// ain't nothing happenin here yet.

	// First thing we're goin to do is paint that surface BLACK so as folks don't be noticin' we's gonna do the
	// delay factor for our masters up at microsoft.
	
	if(milliSecondsOfDelay > 5 )
	{
		U032	n = 2;
		U032 	q;
		
		if(pMySurfaces->VBIstart <2 )
			n = 1;
		if(pMySurfaces->VBIstart <1 )
			return 0;
		for(q=0;q<n;q++) {
			// length in Long words
			U032	length = ( pMySurfaces->Surfaces[q]->dwPitch * pMySurfaces->Surfaces[q]->dwHeight ) / 4;
			U032	startOff = pMySurfaces->Surfaces[q]->pVidMem ;
			U032	i;
			U032*	pOverlay = (U032*) ((U032)startOff);
			for(i=0; i< length ; i++ ) {
			    *pOverlay = 0x10801080;
				pOverlay++;
			}
		}
	}
	
// deficiencies in NV32.h
#ifndef NV4
#define NV004_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV004_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV004_SET_ALARM_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#endif
	
	nvMyVPNotifiers[NUM004OFFSET].status 		= NV04D_NOTIFICATION_STATUS_NOT_LAUNCHED;
				
#ifndef NV4
	pMySurfaces->pVPChanPtr->subchannel[0].control.object = MY_TIMER_OBJECT;
#else 
	pMySurfaces->pVPChanPtr->subchannel[0].SetObject  = MY_TIMER_OBJECT;
#endif // NV4

// get a 0.75 second delay in nanoseconds
#define NV3DELAYTIME ( milliSecondsOfDelay*1000*1000 )
	{
		U032	low;
		U032	low1;
		U032	high;
		
		getCurrentNanoTimer(&high, &low);
		low1 = low;
		
		
		low = low + NV3DELAYTIME;
		if( low < low1 ) {
			high = high + 1;
		}
#ifndef NV4
		pMySurfaces->pVPChanPtr->subchannel[0].timer.SetAlarmTime.nanoseconds[0] = low;
		pMySurfaces->pVPChanPtr->subchannel[0].timer.SetAlarmTime.nanoseconds[1] = high;
		pMySurfaces->pVPChanPtr->subchannel[0].timer.SetAlarmNotify =
			NV004_SET_ALARM_NOTIFY_WRITE_THEN_AWAKEN;

#else   //NV4
		pMySurfaces->pVPChanPtr->subchannel[0].nv01Timer.SetAlarmTime.nanoseconds[0] = low;
		pMySurfaces->pVPChanPtr->subchannel[0].nv01Timer.SetAlarmTime.nanoseconds[1] = high;
		pMySurfaces->pVPChanPtr->subchannel[0].nv01Timer.SetAlarmNotify =
			NV004_SET_ALARM_NOTIFY_WRITE_THEN_AWAKEN;
#endif  //NV4			
		
		// ok, 3/4 second later we should get a notify!
	}
	
	//return startSurfaces(bInterleave, pVideoPortStatus );
	return DD_OK;

}


/*
 * UpdateVideoPort32
 *
 * This required function sets up the video port
 */

/* Questions:
 *			What if I want VBI latching while image is not latching ?
 */
 
DWORD __stdcall UpdateVideoPort32 (LPDDHAL_UPDATEVPORTDATA lpInput)
{

	VPERRORS myErrors;
	U032		bAutoflip;
#ifndef NV4
	U032		bDelayNV3;
#endif
	
	DPF("***UpdateVideoPort32");
	if( GLOBDATAPTR->NvDevFlatVPE == (DWORD) NULL ) {
	 	lpInput->ddRVal = DDERR_SURFACELOST;
		return DDHAL_DRIVER_HANDLED; 
	}

// Since bruce changed the order of initialization, we should check if we need to reload this
	if(pMySurfaces->pOverlayChanPtr == NULL) {
		DPF("Late overlay channel update!");

#ifdef NV4
		pMySurfaces->pOverlayChanPtr = (NvChannel*) pDriverData->NvDevVideoFlatPio;
#else
		pMySurfaces->pOverlayChanPtr = (NvChannel*) pDriverData->NvDevFlatPio;
#endif	

	}
	
	
	lpInput->ddRVal = DD_OK;
		
	{		
		/*
		 * Turn off the video port
		 */
//CODE
		DPF("   now Stopping the Video Port");
		// prevent future interrupts from doing anything
		pMySurfaces->bThreadRunning = FALSE;
		// tell the classes to stop
		StopVP();
		// zero out the notifiers
		
		{
			U032 i;
			for(i=0;i<NUM04DNOTIFIER;i++ ) 
				nvMyVPNotifiers[i+NUM04DOFFSET].status = NV04D_NOTIFICATION_STATUS_NOT_LAUNCHED;
				nvMyVPNotifiers[i+NUM04DOFFSET].info32 = 0;
				nvMyVPNotifiers[i+NUM04DOFFSET].info16 = 0;
				nvMyVPNotifiers[i+NUM04DOFFSET].timeStamp.nanoseconds[0] = 0;
				nvMyVPNotifiers[i+NUM04DOFFSET].timeStamp.nanoseconds[1] = 0;
		}
		pMySurfaces->dwVideoPortStatus = VP_NOT_RUNNING;
    
	} 
	
	if (lpInput->dwFlags != DDRAWI_VPORTSTOP) { 
#ifndef NV4
		bDelayNV3 = FALSE;
#endif //NV4
		if (lpInput->dwFlags == DDRAWI_VPORTSTART) {
			DPF("   now Starting Video Port for the first time");

		// This is the first round....
#ifndef NV4
			bDelayNV3 = TRUE;
#endif	//NV4

		} 
		
		DPF("   now updating the video port");

		{
			
			
			// print some stuff out about the flags we're lookin at:
			if( pMySurfaces->bInvertedFields ) {
				DPF("      field polarity               inverted");	
			} else {
				DPF("      field polarity               normal");	
			}
			
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_AUTOFLIP	) {
				DPF("      FLAG DVP_AUTOFLIP            on");	
			} else {
				DPF("      FLAG DVP_AUTOFLIP            off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_CONVERT		) {
				DPF("      FLAG DDVP_CONVERT            on");	
			} else {
				DPF("      FLAG DDVP_CONVERT            off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_CROP					) {
				DPF("      FLAG DDVP_CROP               on");	
			} else {
				DPF("      FLAG DDVP_CROP               off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_INTERLEAVE			) {
				DPF("      FLAG DDVP_INTERLEAVE         on");	
			} else {
				DPF("      FLAG DDVP_INTERLEAVE         off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_MIRRORLEFTRIGHT		) {
				DPF("      FLAG DDVP_MIRRORLEFTRIGHT    on");	
			} else {
				DPF("      FLAG DDVP_MIRRORLEFTRIGHT    off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_MIRRORUPDOWN			) {
				DPF("      FLAG DDVP_MIRRORUPDOWN       on");	
			} else {
				DPF("      FLAG DDVP_MIRRORUPDOWN       off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_PRESCALE				) {
				DPF("      FLAG DDVP_PRESCALE           on");	
			} else {
				DPF("      FLAG DDVP_PRESCALE           off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_SKIPEVENFIELDS		) {
				DPF("      FLAG DDVP_SKIPEVENFIELDS     on");	
			} else {
				DPF("      FLAG DDVP_SKIPEVENFIELDS     off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_SKIPODDFIELDS			) {
				DPF("      FLAG DDVP_SKIPODDFIELDS      on");	
			} else {
				DPF("      FLAG DDVP_SKIPODDFIELDS      off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_SYNCMASTER				) {
				DPF("      FLAG DDVP_SYNCMASTER         on");	
			} else {
				DPF("      FLAG DDVP_SYNCMASTER         off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_VBICONVERT				) {
				DPF("      FLAG DDVP_VBICONVERT         on");	
			} else {
				DPF("      FLAG DDVP_VBICONVERT         off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_VBINOSCALE				) {
				DPF("      FLAG DDVP_VBINOSCALE         on");	
			} else {
				DPF("      FLAG DDVP_VBINOSCALE         off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_OVERRIDEBOBWEAVE		) {
				DPF("      FLAG DDVP_OVERRIDEBOBWEAVE   on");	
			} else {
				DPF("      FLAG DDVP_OVERRIDEBOBWEAVE   off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_IGNOREVBIXCROP		) {
				DPF("      FLAG DDVP_IGNOREVBIXCROP     on");	
			} else {
				DPF("      FLAG DDVP_IGNOREVBIXCROP     off");	
			}
			
		
		}
		
		// Decide which capture mode to be in given if we're trying to skip some types of fields
		
		
		if( lpInput->lpVideoInfo->dwVPFlags & DDVP_SKIPEVENFIELDS ) {
			pMySurfaces->CurrentCaptureMode = ODDODD;
		} else if ( lpInput->lpVideoInfo->dwVPFlags & DDVP_SKIPODDFIELDS ) {
			pMySurfaces->CurrentCaptureMode = EVENEVEN;
		} else {
			if(pMySurfaces->bInputInterLaced)
				pMySurfaces->CurrentCaptureMode = EVENODD;
			else
				pMySurfaces->CurrentCaptureMode = PROGRESSIVE;
		}
		
		if( lpInput->lpVideoInfo->dwVPFlags & DDVP_AUTOFLIP ) {
			bAutoflip = TRUE;
		} else {
			bAutoflip = FALSE;
		}
		
		if( lpInput->lpVideoInfo->dwVPFlags & DDVP_INTERLEAVE ) {
			pMySurfaces->CurrentScanMode = INTERLEAVBUF;
		} else {
			pMySurfaces->CurrentScanMode = SEPERATEBUF;
		}
		
		{	
			// Here's where we're going to try to figure out where to put things in the vertical and horz
			// dimensions
			
			// At key thing here are the two different modes which people are using to capture VBI
			// one is that the VBI data is captured to the very beginning of the VIDEO surface in one big surface
			// the other mode is with a seperate surface
			
			// we can detect which mode by examining the number of VBI surface if > 0 we're in the second mode
		
			// When there ARE VBI surfaces, then we should jam the Video data right to the very beginning of the
			// video surface, since we know this is where it will be expected.
			
			// additionally we've reported DDVPCONNECT_DISCARDSVREFDATA is true which means 
			// "/*
			//	 * Indicates that any data written to the video port during the VREF
			//	 * period will not be written into the frame buffer. This flag is read only.
			//	 */"
		   //  MS of course not really defining what the VREF period means in their land.
			
				
#define VBIVALIDDATALINE  (0x2)	

			
			if( lpInput->lplpDDVBISurface == NULL ) {
				// this indicates that there are NO VBI surfaces associated with this video port update.
				// therefore we should send all the line to the Image surface
				
				
				pMySurfaces->dwImageStartLine = 0;	// send all the data after line 0
				
				if ( lpInput->lpVideoInfo->dwVPFlags & DDVP_CROP ) {
					if(lpInput->lpVideoInfo->rCrop.top > (signed long) pMySurfaces->dwImageStartLine ) {
						pMySurfaces->dwImageStartLine = lpInput->lpVideoInfo->rCrop.top;
					}
				}
				
			} else {
				// there are some VBI surfaces associated with this video port,
				// so we should send the data to the VBI surfaces where applicable
				pMySurfaces->dwVBIStartLine = VBIVALIDDATALINE;	// at least we're not starting with zero this first four are always
																			// empty as best as I know
			
				pMySurfaces->dwVBIHeight = lpInput->lpVideoInfo->dwVBIHeight;
			
				// Image start line should be one line after the the sum of these two
				pMySurfaces->dwImageStartLine = 1 + pMySurfaces->dwVBIHeight + pMySurfaces->dwVBIStartLine - VBIVALIDDATALINE;
				// if  	dwImageStartLine < 1  then things don't work to well
				if(pMySurfaces->dwImageStartLine < 1) pMySurfaces->dwImageStartLine = 1;
				
				if ( lpInput->lpVideoInfo->dwVPFlags & DDVP_CROP ) {
					if(lpInput->lpVideoInfo->rCrop.top > (signed long) pMySurfaces->dwImageStartLine ) {
						pMySurfaces->dwImageStartLine = lpInput->lpVideoInfo->rCrop.top;
					}
				}
			}
						
			
			
			// this is the only way I know how to do the check for vertical cropping
			if ( lpInput->lpVideoInfo->dwVPFlags & DDVP_CROP ) {
				pMySurfaces->dwInHeight = (DWORD)lpInput->lpVideoInfo->rCrop.bottom - lpInput->lpVideoInfo->rCrop.top;				
				pMySurfaces->dwInWidth  = lpInput->lpVideoInfo->rCrop.right - lpInput->lpVideoInfo->rCrop.left;		
				DPF("   UPDATE:         crop TOP %d",lpInput->lpVideoInfo->rCrop.top);						
			} else {
				pMySurfaces->dwInHeight = lpInput->lpVideoPort->ddvpDesc.dwFieldHeight;
				pMySurfaces->dwInWidth  = lpInput->lpVideoPort->ddvpDesc.dwFieldWidth;
			}
			
			// this is something of a hack I suppose
			pMySurfaces->dwInHeight = pMySurfaces->dwInHeight;			
						
			// if we're prescaling then do something
			if (DDVP_PRESCALE & lpInput->lpVideoInfo->dwVPFlags) {
				pMySurfaces->dwPreHeight = lpInput->lpVideoInfo->dwPrescaleHeight;				
				pMySurfaces->dwPreWidth  = lpInput->lpVideoInfo->dwPrescaleWidth;
			} else {
				pMySurfaces->dwPreHeight = pMySurfaces->dwInHeight;
				pMySurfaces->dwPreWidth = pMySurfaces->dwInWidth;
			}
			
			
			pMySurfaces->dwOriginX = lpInput->lpVideoInfo->dwOriginX;
			pMySurfaces->dwOriginY = lpInput->lpVideoInfo->dwOriginY;
		}
		
		switch (pMySurfaces->CurrentCaptureMode) {
				case EVENODD:
					DPF("   UPDATE:     capture mode EVENODD");	
					break;
				case EVENEVEN:
					DPF("   UPDATE:     capture mode EVENEVEN");							
					break;
				case ODDODD:
					DPF("   UPDATE:     capture mode ODDODD");	
					break;
		}
		switch (pMySurfaces->CurrentScanMode) {
				case SEPERATEBUF:
					DPF("   UPDATE:        scan mode SEPERATEBUF");	
					break;
				case INTERLEAVBUF:
					DPF("   UPDATE:        scan mode INTERLEAVBUF");	
					break;
		}
		
		DPF("   UPDATE: image start line %d",pMySurfaces->dwImageStartLine);
		DPF("   UPDATE: image in dimens %d,%d",pMySurfaces->dwInWidth,pMySurfaces->dwInHeight);
		DPF("   UPDATE: image pre dimens %d,%d",pMySurfaces->dwPreWidth,pMySurfaces->dwPreHeight);
		DPF("   UPDATE:   image position %d,%d",pMySurfaces->dwOriginX,pMySurfaces->dwOriginY);

		myErrors = replaceSurfaceList(lpInput->dwNumAutoflip,lpInput->dwNumVBIAutoflip,
										lpInput->lplpDDSurface, lpInput->lplpDDVBISurface,bAutoflip);
		
		pMySurfaces->dwVPFlags = lpInput->lpVideoInfo->dwVPFlags;
		if( myErrors == NOVPERROR ) {
#ifndef NV4
			if(bDelayNV3) {
				lpInput->ddRVal = startNV3DelayedStart(lpInput->lpVideoInfo->dwVPFlags & DDVP_INTERLEAVE, &(pMySurfaces->dwVideoPortStatus), 1000*3/4);
				
			
			} else {
				lpInput->ddRVal = startNV3DelayedStart(lpInput->lpVideoInfo->dwVPFlags & DDVP_INTERLEAVE, &(pMySurfaces->dwVideoPortStatus), 0);
				
				//lpInput->ddRVal = startSurfaces( lpInput->lpVideoInfo->dwVPFlags & DDVP_INTERLEAVE, &(pMySurfaces->dwVideoPortStatus));
			}
#else
			{
				lpInput->ddRVal = startNV3DelayedStart(lpInput->lpVideoInfo->dwVPFlags & DDVP_INTERLEAVE, &(pMySurfaces->dwVideoPortStatus), 0);
				
				//lpInput->ddRVal = startSurfaces( lpInput->lpVideoInfo->dwVPFlags & DDVP_INTERLEAVE, &(pMySurfaces->dwVideoPortStatus));
			}
#endif //NV4
#ifndef NV4
						
		} else {
			DPF("   Problem updating the Video Port = %d",myErrors);

			switch (myErrors) {
					case CANTCREATESURFACE:
						lpInput->ddRVal = DDERR_OUTOFMEMORY;
						break;
					case TOOMANYSURFACESERROR:
					case  SURFACENOTFOUND:
					default:
						lpInput->ddRVal = DDERR_INVALIDPARAMS;
						break;
			}
				
			return DDHAL_DRIVER_HANDLED;
	
		
			
#endif //NV4
		}	// NOVPERROR
	}  // DDRAWI_VPORTSTOP

	// this is sort of a big hack since things aren't actually running yet, but DirectShow seems to require it
	pMySurfaces->dwVideoPortStatus = VP_BOTH_CAPTURING;
	
	return DDHAL_DRIVER_HANDLED;
}



/*
 * GetVideoSignalStatus32
 *
 * This function is required
 */
 
DWORD __stdcall GetVideoSignalStatus32 ( LPDDHAL_GETVPORTSIGNALDATA lpInput) {	
	
	U032	dwIndex;
	ASSERT(lpInput != NULL);

	DPF("***GetVideoSignalStatus32");
	if( GLOBDATAPTR->NvDevFlatVPE == (DWORD) NULL ) {
	 	lpInput->ddRVal = DDERR_SURFACELOST;
		return DDHAL_DRIVER_HANDLED; 
	}
	
	if( lpInput == NULL)
	{
		DPF("   Input NULL in GetVideoSignalStatus32");
		return DDHAL_DRIVER_NOTHANDLED;
	}
	// If the video port is not running, then we just don't know...
	if( pMySurfaces->dwVideoPortStatus == VP_NOT_RUNNING ) {
		DPF("   could not get the signal status, the video port is not running");
		// we'll return no signal in this case....
		lpInput->dwStatus = DDVPSQ_NOSIGNAL;
		lpInput->ddRVal = DDERR_VIDEONOTACTIVE;

		return DDHAL_DRIVER_HANDLED;
	}
	
	lpInput->ddRVal = DD_OK;
	// default for now is that the signal is good
	lpInput->dwStatus = DDVPSQ_SIGNALOK;
	// first check the notifiers to see if there has been ANY sync
	//     do this by seeing if the notify times are none zero

return DDHAL_DRIVER_HANDLED;
	
	{
		U032	probablyRunning = FALSE;
		for (dwIndex=0;dwIndex<pMySurfaces->numberOfSurfaces;dwIndex++) {
			if( pMySurfaces->Surfaces[dwIndex]->pNvNotify != NULL ) {
				if (pMySurfaces->Surfaces[dwIndex]->pNvNotify->timeStamp.nanoseconds[0]!=0) {
					probablyRunning = TRUE;
					break;
				}
			}
		}
		
		// if the timer are zero then wait at least 1/24 of a second and check again.
		if(!probablyRunning) {
			// find current time
			U032	 tempTime;
			tempTime = getMilliTime();
			//now wait for 1/24 of a second
			while(tempTime + (1000/24) > getMilliTime()); 
			// and then check one more time for a possible completion
			for (dwIndex=0;dwIndex<pMySurfaces->numberOfSurfaces;dwIndex++) {
				if( pMySurfaces->Surfaces[dwIndex]->pNvNotify != NULL ) {
					if (pMySurfaces->Surfaces[dwIndex]->pNvNotify->timeStamp.nanoseconds[0]!=0) {
						probablyRunning = TRUE;
						break;
					}
				}
			}
			
			// if it's still non zero report no signal
			if(!probablyRunning) {
				lpInput->dwStatus = DDVPSQ_NOSIGNAL;
			}

		}	
	}
	
	// have we already decided that the signal is bad...?
	if( lpInput->dwStatus != DDVPSQ_NOSIGNAL ) {
		
		// Now the default is that the signal is bad
		lpInput->dwStatus = DDVPSQ_NOSIGNAL;
		
		// check to see that at least one of of the notifiers is LESS than 1/24 of a second
		// hopefully there's been _some_ event in video land in the last 1/24 of a second
		for (dwIndex=0;dwIndex<pMySurfaces->numberOfSurfaces;dwIndex++) {
			if( pMySurfaces->Surfaces[dwIndex]->pNvNotify != NULL ) {
				if (pMySurfaces->Surfaces[dwIndex]->pNvNotify->timeStamp.nanoseconds[0]!=0) {
					U032 diff;
					// ok, we've got a non-zero surface, let's check to see how recent it is
					U032	BigCurrentTime;
					U032	SmallCurrentTime;
					
					getCurrentNanoTimer(&BigCurrentTime,&SmallCurrentTime);
					if(pMySurfaces->Surfaces[dwIndex]->pNvNotify->timeStamp.nanoseconds[1] < BigCurrentTime ) {
						// we've got a wrap around situation.  this means that we need to work in weirder math
						diff = (
									((0x80000000)  - (pMySurfaces->Surfaces[dwIndex]->pNvNotify->timeStamp.nanoseconds[0] >> 1))
									+  (SmallCurrentTime >> 1)
								 ) << 1;
					} else {
						// do a simple subtraction
						diff = SmallCurrentTime - pMySurfaces->Surfaces[dwIndex]->pNvNotify->timeStamp.nanoseconds[0];
					}
					//diff now has the delta between the notify and "now"  
					// if the notifier is LESS than a frame period then we've got a signal
					if(diff < MAXFRAMEPERIOD ) {
						lpInput->dwStatus = DDVPSQ_SIGNALOK;
					} else {
						diff = 0;
						// this is a place for chris's break point's while debugging
					}
					
				}
			}
		}

	}
	
	return DDHAL_DRIVER_HANDLED;
}


/*
 * WaitForVideoPortSync32
 *
 * This function is required
 */


DWORD __stdcall WaitForVideoPortSync32 (LPDDHAL_WAITFORVPORTSYNCDATA lpInput)
{
	DPF("***WaitForVideoPortSync32");
	
	if( GLOBDATAPTR->NvDevFlatVPE == (DWORD) NULL ) {
	 	lpInput->ddRVal = DDERR_SURFACELOST;
		return DDHAL_DRIVER_HANDLED; 
	}
	
	lpInput->ddRVal = DDVPSQ_NOSIGNAL;
	
	// if the port is running then
	if (pMySurfaces->dwVideoPortStatus != VP_NOT_RUNNING) {
		if( lpInput->dwFlags & DDVPWAIT_BEGIN ) {
			// wait for a vsync start.   timeout in lpInput->dwTimeOut
			U032	bigTime;
			U032	smallTime;
			U032	milliTime;
			U032	recentTime[MAXVPSURFACES];
			U032 	dwIndex;
			U032	searchMAX;
	
		// find out what time it is now
			getCurrentNanoTimer(&bigTime, &smallTime);
			milliTime = getMilliTime();
			
			if( pMySurfaces->VBIstart == 0 ) {
				// we're only running VBI so check ALL the surfaces
				searchMAX = pMySurfaces->numberOfSurfaces;
			} else {
				// there is at least one image surface, so check for that
				searchMAX = pMySurfaces->VBIstart;
			}
			//find the current notifiers for the IMAGE surfaces
			for (dwIndex=0;dwIndex<searchMAX;dwIndex++) {
				if( pMySurfaces->Surfaces[dwIndex]->pNvNotify != NULL ) {
					recentTime[dwIndex] = pMySurfaces->Surfaces[dwIndex]->pNvNotify->timeStamp.nanoseconds[0];
				} else {
					recentTime[dwIndex] = 0;
				}
			}
			while( (getMilliTime() < ( milliTime + lpInput->dwTimeOut)) && ( lpInput->ddRVal == DDVPSQ_NOSIGNAL) ) {
				for (dwIndex=0;dwIndex<searchMAX;dwIndex++) {
					if( pMySurfaces->Surfaces[dwIndex]->pNvNotify != NULL ) {
						if( recentTime[dwIndex] < pMySurfaces->Surfaces[dwIndex]->pNvNotify->timeStamp.nanoseconds[0] ) {
							// ok, ONE Of the notifiers moved foward
							lpInput->ddRVal = DD_OK; 	//  We found a sync
						}
					}
				}
			}
			// start a while		
		} else if (lpInput->dwFlags & DDVPWAIT_END ) {
			//  timeout in lpInput->dwTimeOut
			// we could wait for ysync that then see which buffer we're on then wait for the line counter
			// to change  .. YUCK
			DPF("   Sorry, don't handle waiting for the end");
	
			return DDHAL_DRIVER_NOTHANDLED;
		} else if (lpInput->dwFlags & DDVPWAIT_LINE ) {
			//timeout in lpInput->dwTimeOut
				// lpInput ->dwLine
			DPF("   Sorry, can't wait for a particular line");
			return DDHAL_DRIVER_NOTHANDLED;
		};
		
	}// videoport status
	
	return DDHAL_DRIVER_HANDLED;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\inc\arb_fifo.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************** ARB Structures ****************************\
*                                                                           *
* Module: ARB_FIFO.H                                                        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#ifndef _ARB_FIFO_H

#define ARB_FIFO_H

#define DEFAULT_GR_LWM 100
#define DEFAULT_VID_LWM 100
#define DEFAULT_GR_BURST_SIZE 256
#define DEFAULT_VID_BURST_SIZE 128


typedef struct {

  int graphics_lwm;  // GR LWM
  int video_lwm;    // Video LWM

  int graphics_burst_size;
  int video_burst_size;

  int valid;  // good values

} fifo_info;

typedef struct {
  int pclk_khz;
  int mclk_khz;
  int nvclk_khz;
  char mem_page_miss;
  char mem_latency; //cas_latency
  int memory_width;
  char enable_video;
  char gr_during_vid;
  char pix_bpp;
  char mem_aligned;
  char enable_mp;
} sim_state;

#define VIDEO		0
#define GRAPHICS	1
#define MPORT		2
#define ENGINE		3


#define GFIFO_SIZE	320 	/* Graphics Fifo Sizes */
#define GFIFO_SIZE_128	256 /* Graphics Fifo Sizes */
#define MFIFO_SIZE	120	    /* MP  Fifo Sizes */
#define VFIFO_SIZE	256	    /* Video Fifo Sizes */

#define	ABS(a)	(a>0?a:-a)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\inc\GLOBAL.H ===
#ifndef _global_h // multiple include protection
#define _global_h

//////////////////////////////////////////////////////////////////////////////
// global flags
//
#define FS_MMX          0x00000001      //  ) do not change - some code 
#define FS_KATMAI       0x00000002      // )          relies on these values

//////////////////////////////////////////////////////////////////////////////
// All globals go into the 'global' structure. We divie the big structure up into
// banks. Every bank is a multiple of 32 bytes big. We place globals that are used 
// together in inner loops in the same bank. This way we minimize pentium cache 
// misses
//
// we assume that this structure starts 32-byte aligned. Will be so once all globs 
// are placed here - and the C libraries do not mess with us... Look at .map output
// for alignment info
//
#pragma pack(push,1) // we control alignment
typedef struct {
//////////
// debug and retail banks
    // bank 1
    PNVD3DCONTEXT pCurrentContext;
    DWORD         nvFifo;
    DWORD         nvFreeCount;
    DWORD         nvDmaPushOffsetMax;
    DWORD         nvDmaPushBase;
    DWORD         nvDmaLastPutAddr;
    DWORD         nvDmaMinPushCount;
    DWORD         dwCPUFeatureSet;

#ifdef NV_FASTLOOPS
    // bank 2.0
    DWORD         dwPrimCount;          // # of primitives to render
    DWORD         dwStrides;            // primitive stride info
    DWORD         pVertices;            // vertex base
    DWORD         pIndices;             // index base
    DWORD         dwIndex0;             // )
    DWORD         dwIndex1;             //  ) current index
    DWORD         dwIndex2;             // )
    DWORD         dwVertexSN;           // current vertex cache serial number
    // bank 2.1
    DWORD         dwVertex0;            // )
    DWORD         dwVertex1;            //  ) current vertex
    DWORD         dwVertex2;            // )
    DWORD         dwPrimSubCount;       // # of primitives in this batch
    DWORD        *pdwUVOffset;          // dx6 uv coord offset array
    DWORD         dwStripFanData;       // strip & fan storage (cull history & cull sense)
    DWORD         dwCullMask1;          //  ) cull masks
    DWORD         dwCullMask2;          // )
    // bank 2.2
    DWORD         dwTemp;               // temp for culling and fog calculations
    float         fRWFar;               // fixed w buffer scale
    DWORD         dwSpecCurr;           // )
    DWORD         dwBlend;              //  ) spec hack
    DWORD         dwSpecCount;          //  )
    DWORD         dwSpecularState;      // )
    DWORD         _pad2_2[2];
    // bank 2.3
    DWORD         dwVertexCache[16];    // vertex cache
    // bank 2.4
    float         fFogTableDensity;     // )
    float         fFogTableLinearScale; //  )
    float         fFogTableEnd;         //   ) fog parameters
    float         fFogC1;               //  )
    float         fFogC2;               // )
    DWORD         dwWMask1;             // ) w parameters
    DWORD         dwWMask2;             // )
    float         fTriangleArea;
    // bank 2.5
    DWORD         dwVertexGatherBuf[8];
    // bank 2.6
    DWORD         dwVertexGatherBuf2[3];
    BYTE*         dwILCData;
    DWORD         dwILCCount;
    DWORD         dwILCMax;
    DWORD         dwMemCopyOffset;
    float         fCTC1;
    DWORD         _pad2_6[1];
#else //!NV_FASTLOOPS
    // bank 2.1
    DWORD         dwVertexSN;
    DWORD         _pad2_1[7];
    // bank 2.2
    DWORD         dwVertexCache[16];
#endif //!NV_FASTLOOPS

#ifdef  NVD3D_DX6
    // bank 3
    NVD3DFVFDATA    fvfData;
#endif  // NVD3D_DX6

    // bank 4
    DWORD         dwProcessorSpeed;
    DWORD         dwHWTextureDate;
    DWORD         dwSWTextureDate;
    DWORD         _pad2[3];

//////////
// debug only banks
#ifdef _DEBUG
#endif

} global_struc;
extern global_struc global;
#pragma pack(pop)

//////////////////////////////////////////////////////////////////////////////
// To simplify implementation, the #define list below alias original names
#define nvDmaPushOffsetMax              global.nvDmaPushOffsetMax
#define nvDmaPushBase                   global.nvDmaPushBase
#define nvDmaLastPutAddr                global.nvDmaLastPutAddr
#define VCacheSerialNumber              global.VCacheSerialNumber
#define nvFifo                          global.nvFifo
#define nvFreeCount                     global.nvFreeCount
#define nvDmaMinPushCount               global.nvDmaMinPushCount
#define pCurrentContext                 global.pCurrentContext

#ifndef NV_FASTLOOPS
#define dwVertexSN                      global.dwVertexSN
#define dwVertexCache                   global.dwVertexCache
#endif //!NV_FASTLOOPS

#ifdef  NVD3D_DX6
#define fvfData                         global.fvfData
#endif  // NVD3D_DX6


//////////////////////////////////////////////////////////////////////////////
// this function initializes globals - see global.c
void init_globals (void);

//////////////////////////////////////////////////////////////////////////////
// Inter Process Memory
void* AllocIPM (unsigned size);
void* ReallocIPM (void* ptr,unsigned size);
void FreeIPM (void* ptr);
void DestroyIPM (void);

//////////////////////////////////////////////////////////////////////////////
// nvidia mem copy
#define NV_MEMCOPY_DONTCARE             0   // default to dest aligned
#define NV_MEMCOPY_WANTSRCALIGNED       1
#define NV_MEMCOPY_WANTDESTALIGNED      2

void nvMemCopy  (DWORD dwDest,DWORD dwSrc,DWORD dwCount,DWORD dwFlags);
void nvMemTouch (DWORD dwSrc,DWORD dwCount);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\inc\NV4DCAPS.H ===
#ifndef _NV4DCAPS_H_
#define _NV4DCAPS_H_
#ifdef  NV4
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4DCAPS.H                                                        *
*   Define the capabilities of the NV4 D3D driver.                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/26/98 - created                      *
*                                                                           *
\***************************************************************************/

/*
 * --------------------------------------------------------------------------
 *  Direct 3D HAL Capabilities
 * --------------------------------------------------------------------------
 */

/*
 * Define which fields of the D3DDEVICECAPS structure are valid.
 */
#define NV4_DEVDESC_FLAGS           D3DDD_COLORMODEL                    |   \
                                    D3DDD_DEVCAPS                       |   \
                                    D3DDD_LINECAPS                      |   \
                                    D3DDD_TRICAPS                       |   \
                                    D3DDD_DEVICERENDERBITDEPTH          |   \
                                    D3DDD_DEVICEZBUFFERBITDEPTH

/*
 * Define the color model for the D3D driver.
 */
#define NV4_COLORMODEL              D3DCOLOR_RGB

/*
 * Define the device capabilities.
 */
#define NV4_DEVCAPS_FLAGS           D3DDEVCAPS_EXECUTESYSTEMMEMORY      |   \
                                    D3DDEVCAPS_FLOATTLVERTEX            |   \
                                    D3DDEVCAPS_TEXTUREVIDEOMEMORY       |   \
                                    D3DDEVCAPS_TLVERTEXSYSTEMMEMORY     |   \
                                    D3DDEVCAPS_DRAWPRIMTLVERTEX         |   \
                                    D3DDEVCAPS_TEXTURENONLOCALVIDMEM
//                                    D3DDEVCAPS_CANRENDERAFTERFLIP

/*
 * Define the transformation capabilities.
 */
#define NV4_TRANSFORMCAPS_FLAGS     0
#define NV4_TRANSFORMCAPS                                                   \
{                                                                           \
    sizeof(D3DTRANSFORMCAPS),                                               \
    NV4_TRANSFORMCAPS_FLAGS                                                 \
}

/*
 * Define 3D clipping capabilities.
 */
#define NV4_3DCLIPPINGCAPS          FALSE

/*
 * Define the lighting capabilities.
 */
#define NV4_LIGHTINGCAPS_FLAGS      0
#define NV4_LIGHTINGCAPS                                                    \
{                                                                           \
    sizeof(D3DLIGHTINGCAPS),                                                \
    NV4_LIGHTINGCAPS_FLAGS                                                  \
}

/*
 * Define NULL primary capabilities.
 */
#define NV4_PRIMCAPS_NULL           0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

/*
 * Define the line capabilities.
 *
 * Miscellaneous capabilities (dwMiscCaps)
 */
#define NV4_LINECAPS_MISC           D3DPMISCCAPS_MASKZ                  |   \
                                    D3DPMISCCAPS_CULLNONE               |   \
                                    D3DPMISCCAPS_CULLCW                 |   \
                                    D3DPMISCCAPS_CULLCCW

/*
 * Raster capabilities (dwRasterCaps)
 */
#define NV4_LINECAPS_RASTER         D3DPRASTERCAPS_DITHER               |   \
                                    D3DPRASTERCAPS_SUBPIXEL             |   \
                                    D3DPRASTERCAPS_FOGVERTEX            |   \
                                    D3DPRASTERCAPS_WFOG                 |   \
                                    D3DPRASTERCAPS_MIPMAPLODBIAS        |   \
                                    D3DPRASTERCAPS_ANISOTROPY           |   \
                                    D3DPRASTERCAPS_WBUFFER

/*
 * Z Compare capabilities (dwZCmpCaps)
 */
#define NV4_LINECAPS_ZCMP           D3DPCMPCAPS_NEVER                   |   \
                                    D3DPCMPCAPS_LESS                    |   \
                                    D3DPCMPCAPS_EQUAL                   |   \
                                    D3DPCMPCAPS_LESSEQUAL               |   \
                                    D3DPCMPCAPS_GREATER                 |   \
                                    D3DPCMPCAPS_NOTEQUAL                |   \
                                    D3DPCMPCAPS_GREATEREQUAL            |   \
                                    D3DPCMPCAPS_ALWAYS

/*
 * Source blend capabilities (dwSrcBlendCaps)
 */
#define NV4_LINECAPS_SRCBLEND       D3DPBLENDCAPS_ZERO                  |   \
                                    D3DPBLENDCAPS_ONE                   |   \
                                    D3DPBLENDCAPS_SRCCOLOR              |   \
                                    D3DPBLENDCAPS_INVSRCCOLOR           |   \
                                    D3DPBLENDCAPS_SRCALPHA              |   \
                                    D3DPBLENDCAPS_INVSRCALPHA           |   \
                                    D3DPBLENDCAPS_DESTALPHA             |   \
                                    D3DPBLENDCAPS_INVDESTALPHA          |   \
                                    D3DPBLENDCAPS_DESTCOLOR             |   \
                                    D3DPBLENDCAPS_INVDESTCOLOR          |   \
                                    D3DPBLENDCAPS_SRCALPHASAT           |   \
                                    D3DPBLENDCAPS_BOTHSRCALPHA          |   \
                                    D3DPBLENDCAPS_BOTHINVSRCALPHA

/*
 * Destination blend capabilities (dwDestBlendCaps)
 */
#define NV4_LINECAPS_DESTBLEND      D3DPBLENDCAPS_ZERO                  |   \
                                    D3DPBLENDCAPS_ONE                   |   \
                                    D3DPBLENDCAPS_SRCCOLOR              |   \
                                    D3DPBLENDCAPS_INVSRCCOLOR           |   \
                                    D3DPBLENDCAPS_SRCALPHA              |   \
                                    D3DPBLENDCAPS_INVSRCALPHA           |   \
                                    D3DPBLENDCAPS_DESTALPHA             |   \
                                    D3DPBLENDCAPS_INVDESTALPHA          |   \
                                    D3DPBLENDCAPS_DESTCOLOR             |   \
                                    D3DPBLENDCAPS_INVDESTCOLOR          |   \
                                    D3DPBLENDCAPS_SRCALPHASAT           |   \
                                    D3DPBLENDCAPS_BOTHSRCALPHA          |   \
                                    D3DPBLENDCAPS_BOTHINVSRCALPHA

/*
 * Alpha compare capabilities (dwAlphaCmpCaps)
 */
#define NV4_LINECAPS_ALPHACMP       D3DPCMPCAPS_NEVER                   |   \
                                    D3DPCMPCAPS_LESS                    |   \
                                    D3DPCMPCAPS_EQUAL                   |   \
                                    D3DPCMPCAPS_LESSEQUAL               |   \
                                    D3DPCMPCAPS_GREATER                 |   \
                                    D3DPCMPCAPS_NOTEQUAL                |   \
                                    D3DPCMPCAPS_GREATEREQUAL            |   \
                                    D3DPCMPCAPS_ALWAYS

/*
 * Shading capabilities (dwShadeCaps)
 */
#define NV4_LINECAPS_SHADE          D3DPSHADECAPS_COLORFLATMONO         |   \
                                    D3DPSHADECAPS_COLORFLATRGB          |   \
                                    D3DPSHADECAPS_COLORGOURAUDMONO      |   \
                                    D3DPSHADECAPS_COLORGOURAUDRGB       |   \
                                    D3DPSHADECAPS_SPECULARFLATRGB       |   \
                                    D3DPSHADECAPS_SPECULARGOURAUDRGB    |   \
                                    D3DPSHADECAPS_ALPHAFLATBLEND        |   \
                                    D3DPSHADECAPS_ALPHAGOURAUDBLEND     |   \
                                    D3DPSHADECAPS_FOGFLAT               |   \
                                    D3DPSHADECAPS_FOGGOURAUD

/*
 * Texture capabilities (dwTextureCaps)
 */
#define NV4_LINECAPS_TEXTURE        D3DPTEXTURECAPS_PERSPECTIVE         |   \
                                    D3DPTEXTURECAPS_POW2                |   \
                                    D3DPTEXTURECAPS_ALPHA               |   \
                                    D3DPTEXTURECAPS_TRANSPARENCY

// ???                                   D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE

/*
 * Texture filtering capabilities (dwTextureFilterCaps)
 */
#ifdef  NVD3D_DX6
#define NV4_LINECAPS_TEXTUREFILTER  D3DPTFILTERCAPS_NEAREST             |   \
                                    D3DPTFILTERCAPS_LINEAR              |   \
                                    D3DPTFILTERCAPS_MIPNEAREST          |   \
                                    D3DPTFILTERCAPS_MIPLINEAR           |   \
                                    D3DPTFILTERCAPS_LINEARMIPNEAREST    |   \
                                    D3DPTFILTERCAPS_LINEARMIPLINEAR     |   \
                                    D3DPTFILTERCAPS_MINFPOINT           |   \
                                    D3DPTFILTERCAPS_MINFLINEAR          |   \
                                    D3DPTFILTERCAPS_MIPFPOINT           |   \
                                    D3DPTFILTERCAPS_MIPFLINEAR          |   \
                                    D3DPTFILTERCAPS_MAGFPOINT           |   \
                                    D3DPTFILTERCAPS_MAGFLINEAR

// ???                                    D3DPTFILTERCAPS_MINFANISOTROPIC
// ???                                    D3DPTFILTERCAPS_MAGFANISOTROPIC

#else   // !NVD3D_DX6
#define NV4_LINECAPS_TEXTUREFILTER  D3DPTFILTERCAPS_NEAREST             |   \
                                    D3DPTFILTERCAPS_LINEAR              |   \
                                    D3DPTFILTERCAPS_MIPNEAREST          |   \
                                    D3DPTFILTERCAPS_MIPLINEAR           |   \
                                    D3DPTFILTERCAPS_LINEARMIPNEAREST    |   \
                                    D3DPTFILTERCAPS_LINEARMIPLINEAR
#endif  // !NVD3D_DX6

/*
 * Texture blending capabilities (dwTextureBlendCaps)
 */
#define NV4_LINECAPS_TEXTUREBLEND   D3DPTBLENDCAPS_DECAL                |   \
                                    D3DPTBLENDCAPS_MODULATE             |   \
                                    D3DPTBLENDCAPS_DECALALPHA           |   \
                                    D3DPTBLENDCAPS_MODULATEALPHA        |   \
                                    D3DPTBLENDCAPS_DECALMASK            |   \
                                    D3DPTBLENDCAPS_MODULATEMASK         |   \
                                    D3DPTBLENDCAPS_COPY                 |   \
                                    D3DPTBLENDCAPS_ADD

/*
 * Texture addressing capabilities (dwTextureAddressCaps)
 */
#define NV4_LINECAPS_TEXTUREADDRESS D3DPTADDRESSCAPS_WRAP               |   \
                                    D3DPTADDRESSCAPS_MIRROR             |   \
                                    D3DPTADDRESSCAPS_CLAMP              |   \
                                    D3DPTADDRESSCAPS_INDEPENDENTUV

/*
 * Maximum stipple dimensions.
 */
#define NV4_LINECAPS_STIPPLEWIDTH    0
#define NV4_LINECAPS_STIPPLEHEIGHT   0

/*
 * Put all the line capabilities into the structure.
 */
#define NV4_LINECAPS                                                        \
{                                                                           \
    sizeof(D3DPRIMCAPS),                                                    \
    NV4_LINECAPS_MISC,                                                      \
    NV4_LINECAPS_RASTER,                                                    \
    NV4_LINECAPS_ZCMP,                                                      \
    NV4_LINECAPS_SRCBLEND,                                                  \
    NV4_LINECAPS_DESTBLEND,                                                 \
    NV4_LINECAPS_ALPHACMP,                                                  \
    NV4_LINECAPS_SHADE,                                                     \
    NV4_LINECAPS_TEXTURE,                                                   \
    NV4_LINECAPS_TEXTUREFILTER,                                             \
    NV4_LINECAPS_TEXTUREBLEND,                                              \
    NV4_LINECAPS_TEXTUREADDRESS,                                            \
    NV4_LINECAPS_STIPPLEWIDTH,                                              \
    NV4_LINECAPS_STIPPLEHEIGHT                                              \
}

/*
 * Define the triangle capabilities.
 *
 * Miscellaneous capabilities (dwMiscCaps)
 */
#define NV4_TRICAPS_MISC            D3DPMISCCAPS_MASKZ                  |   \
                                    D3DPMISCCAPS_CULLNONE               |   \
                                    D3DPMISCCAPS_CULLCW                 |   \
                                    D3DPMISCCAPS_CULLCCW
                                    
/*
 * Raster capabilities (dwRasterCaps)
 */
#define NV4_TRICAPS_RASTER          D3DPRASTERCAPS_DITHER               |   \
                                    D3DPRASTERCAPS_SUBPIXEL             |   \
                                    D3DPRASTERCAPS_FOGVERTEX            |   \
                                    D3DPRASTERCAPS_FOGTABLE             |   \
                                    D3DPRASTERCAPS_WFOG                 |   \
                                    D3DPRASTERCAPS_MIPMAPLODBIAS        |   \
                                    D3DPRASTERCAPS_ANISOTROPY           |   \
                                    D3DPRASTERCAPS_WBUFFER

/*
 * Z Compare capabilities (dwZCmpCaps)
 */
#define NV4_TRICAPS_ZCMP            D3DPCMPCAPS_NEVER                   |   \
                                    D3DPCMPCAPS_LESS                    |   \
                                    D3DPCMPCAPS_EQUAL                   |   \
                                    D3DPCMPCAPS_LESSEQUAL               |   \
                                    D3DPCMPCAPS_GREATER                 |   \
                                    D3DPCMPCAPS_NOTEQUAL                |   \
                                    D3DPCMPCAPS_GREATEREQUAL            |   \
                                    D3DPCMPCAPS_ALWAYS

/*
 * Source blend capabilities (dwSrcBlendCaps)
 */
#define NV4_TRICAPS_SRCBLEND        D3DPBLENDCAPS_ZERO                  |   \
                                    D3DPBLENDCAPS_ONE                   |   \
                                    D3DPBLENDCAPS_SRCCOLOR              |   \
                                    D3DPBLENDCAPS_INVSRCCOLOR           |   \
                                    D3DPBLENDCAPS_SRCALPHA              |   \
                                    D3DPBLENDCAPS_INVSRCALPHA           |   \
                                    D3DPBLENDCAPS_DESTALPHA             |   \
                                    D3DPBLENDCAPS_INVDESTALPHA          |   \
                                    D3DPBLENDCAPS_DESTCOLOR             |   \
                                    D3DPBLENDCAPS_INVDESTCOLOR          |   \
                                    D3DPBLENDCAPS_SRCALPHASAT           |   \
                                    D3DPBLENDCAPS_BOTHSRCALPHA          |   \
                                    D3DPBLENDCAPS_BOTHINVSRCALPHA

/*
 * Destination blend capabilities (dwDestBlendCaps)
 */
#define NV4_TRICAPS_DESTBLEND       D3DPBLENDCAPS_ZERO                  |   \
                                    D3DPBLENDCAPS_ONE                   |   \
                                    D3DPBLENDCAPS_SRCCOLOR              |   \
                                    D3DPBLENDCAPS_INVSRCCOLOR           |   \
                                    D3DPBLENDCAPS_SRCALPHA              |   \
                                    D3DPBLENDCAPS_INVSRCALPHA           |   \
                                    D3DPBLENDCAPS_DESTALPHA             |   \
                                    D3DPBLENDCAPS_INVDESTALPHA          |   \
                                    D3DPBLENDCAPS_DESTCOLOR             |   \
                                    D3DPBLENDCAPS_INVDESTCOLOR          |   \
                                    D3DPBLENDCAPS_SRCALPHASAT           |   \
                                    D3DPBLENDCAPS_BOTHSRCALPHA          |   \
                                    D3DPBLENDCAPS_BOTHINVSRCALPHA

/*
 * Alpha compare capabilities (dwAlphaCmpCaps)
 */
#define NV4_TRICAPS_ALPHACMP        D3DPCMPCAPS_NEVER                   |   \
                                    D3DPCMPCAPS_LESS                    |   \
                                    D3DPCMPCAPS_EQUAL                   |   \
                                    D3DPCMPCAPS_LESSEQUAL               |   \
                                    D3DPCMPCAPS_GREATER                 |   \
                                    D3DPCMPCAPS_NOTEQUAL                |   \
                                    D3DPCMPCAPS_GREATEREQUAL            |   \
                                    D3DPCMPCAPS_ALWAYS

/*
 * Shading capabilities (dwShadeCaps)
 */
#define NV4_TRICAPS_SHADE           D3DPSHADECAPS_COLORFLATMONO         |   \
                                    D3DPSHADECAPS_COLORFLATRGB          |   \
                                    D3DPSHADECAPS_COLORGOURAUDMONO      |   \
                                    D3DPSHADECAPS_COLORGOURAUDRGB       |   \
                                    D3DPSHADECAPS_SPECULARFLATRGB       |   \
                                    D3DPSHADECAPS_SPECULARGOURAUDRGB    |   \
                                    D3DPSHADECAPS_ALPHAFLATBLEND        |   \
                                    D3DPSHADECAPS_ALPHAGOURAUDBLEND     |   \
                                    D3DPSHADECAPS_FOGFLAT               |   \
                                    D3DPSHADECAPS_FOGGOURAUD

/*
 * Texture capabilities (dwTextureCaps)
 */
#define NV4_TRICAPS_TEXTURE         D3DPTEXTURECAPS_PERSPECTIVE         |   \
                                    D3DPTEXTURECAPS_POW2                |   \
                                    D3DPTEXTURECAPS_ALPHA               |   \
                                    D3DPTEXTURECAPS_TRANSPARENCY

// ???                                   D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE

/*
 * Texture filtering capabilities (dwTextureFilterCaps)
 */
#ifdef  NVD3D_DX6
#define NV4_TRICAPS_TEXTUREFILTER   D3DPTFILTERCAPS_NEAREST             |   \
                                    D3DPTFILTERCAPS_LINEAR              |   \
                                    D3DPTFILTERCAPS_MIPNEAREST          |   \
                                    D3DPTFILTERCAPS_MIPLINEAR           |   \
                                    D3DPTFILTERCAPS_LINEARMIPNEAREST    |   \
                                    D3DPTFILTERCAPS_LINEARMIPLINEAR     |   \
                                    D3DPTFILTERCAPS_MINFPOINT           |   \
                                    D3DPTFILTERCAPS_MINFLINEAR          |   \
                                    D3DPTFILTERCAPS_MIPFPOINT           |   \
                                    D3DPTFILTERCAPS_MIPFLINEAR          |   \
                                    D3DPTFILTERCAPS_MAGFPOINT           |   \
                                    D3DPTFILTERCAPS_MAGFLINEAR          |   \
                                    D3DPTFILTERCAPS_MINFANISOTROPIC     |   \
                                    D3DPTFILTERCAPS_MAGFANISOTROPIC

#else   // !NVD3D_DX6
#define NV4_TRICAPS_TEXTUREFILTER   D3DPTFILTERCAPS_NEAREST             |   \
                                    D3DPTFILTERCAPS_LINEAR              |   \
                                    D3DPTFILTERCAPS_MIPNEAREST          |   \
                                    D3DPTFILTERCAPS_MIPLINEAR           |   \
                                    D3DPTFILTERCAPS_LINEARMIPNEAREST    |   \
                                    D3DPTFILTERCAPS_LINEARMIPLINEAR
#endif  // !NVD3D_DX6

/*
 * Texture blending capabilities (dwTextureBlendCaps)
 */
#define NV4_TRICAPS_TEXTUREBLEND    D3DPTBLENDCAPS_DECAL                |   \
                                    D3DPTBLENDCAPS_MODULATE             |   \
                                    D3DPTBLENDCAPS_DECALALPHA           |   \
                                    D3DPTBLENDCAPS_MODULATEALPHA        |   \
                                    D3DPTBLENDCAPS_DECALMASK            |   \
                                    D3DPTBLENDCAPS_MODULATEMASK         |   \
                                    D3DPTBLENDCAPS_COPY                 |   \
                                    D3DPTBLENDCAPS_ADD

/*
 * Texture addressing capabilities (dwTextureAddressCaps)
 */
#define NV4_TRICAPS_TEXTUREADDRESS  D3DPTADDRESSCAPS_WRAP               |   \
                                    D3DPTADDRESSCAPS_MIRROR             |   \
                                    D3DPTADDRESSCAPS_CLAMP              |   \
                                    D3DPTADDRESSCAPS_INDEPENDENTUV

/*
 * Maximum stipple dimensions.
 */
#define NV4_TRICAPS_STIPPLEWIDTH    0
#define NV4_TRICAPS_STIPPLEHEIGHT   0

/*
 * Put all the triangle capabilities into the structure.
 */
#define NV4_TRICAPS                                                         \
{                                                                           \
    sizeof(D3DPRIMCAPS),                                                    \
    NV4_TRICAPS_MISC,                                                       \
    NV4_TRICAPS_RASTER,                                                     \
    NV4_TRICAPS_ZCMP,                                                       \
    NV4_TRICAPS_SRCBLEND,                                                   \
    NV4_TRICAPS_DESTBLEND,                                                  \
    NV4_TRICAPS_ALPHACMP,                                                   \
    NV4_TRICAPS_SHADE,                                                      \
    NV4_TRICAPS_TEXTURE,                                                    \
    NV4_TRICAPS_TEXTUREFILTER,                                              \
    NV4_TRICAPS_TEXTUREBLEND,                                               \
    NV4_TRICAPS_TEXTUREADDRESS,                                             \
    NV4_TRICAPS_STIPPLEWIDTH,                                               \
    NV4_TRICAPS_STIPPLEHEIGHT                                               \
}

/*
 * Define the render bit depth capabilites.
 */
#define NV4_RENDERBITDEPTHCAPS      (DDBD_16 | DDBD_32)

/*
 * Define the Z buffer bit depth capabilities.
 */
#define NV4_ZBUFFERBITDEPTHCAPS     (DDBD_16 | DDBD_24)

/*
 * Define the maximum execute buffer size capabilites.
 */
#define NV4_MAXBUFFERSIZE           0

/*
 * Define the maximum vertex count
 */
#define NV4_MAXVERTEXCOUNT          NVD3D_DEFAULT_TL_NUM

#ifdef  NVD3D_DX6
#define NV_CAPS_MAX_TEXTURE_REPEAT          0
#define NV_CAPS_MAX_TEXTURE_ASPECT_RATIO    0
#define NV_CAPS_MAX_ANISOTROPY              2 // Means we support anisotropic filtering.
#define NV_CAPS_GUARD_BAND_LEFT             -2048
#define NV_CAPS_GUARD_BAND_TOP              -2048
#define NV_CAPS_GUARD_BAND_RIGHT            2047
#define NV_CAPS_GUARD_BAND_BOTTOM           2047
#define NV_CAPS_EXTENTS_ADJUST              0
#define NV_CAPS_MAX_UV_PAIRS                8 // Number of texture uv's supported.
#define NV_CAPS_FVF_CAPS                    (NV_CAPS_MAX_UV_PAIRS | D3DFVFCAPS_DONOTSTRIPELEMENTS)
#define NV_CAPS_MAX_TEXTURE_BLEND_STATES    4
#define NV_CAPS_MAX_SIMULTANEOUS_TEXTURES   2
#endif  // NVD3D_DX6

#endif  // NV4
#endif  // _NV4DCAPS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\inc\nv4dinc.h ===
#ifndef _NV4DINC_H_
#define _NV4DINC_H_
#ifdef  NV4
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4DINC.H                                                         *
*   NV4 specific direct 3d structure definitions.                           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/31/97 - created.                     *
*                                                                           *
\***************************************************************************/

/*
 * Always build for D3D.
 * Always build a non-syncing driver.
 */
#ifndef WINNT
#define NVD3D       1
#endif // #ifndef WINNT
#define D3D_NOSYNC  1
/*
 * Specular contribution check.
 */
#define SPEC_HACK   1
#ifdef  SPEC_HACK
#define SPEC_CHECK(SpecState, SpecCurr, S0, S1, S2, count, blend)           \
{                                                                           \
    if (SpecState)                                                          \
    {                                                                       \
        if (((S0) | (S1) | (S2)) & 0x00FCFCFC)                              \
        {                                                                   \
            if (!SpecCurr)                                                  \
            {                                                               \
                (blend) |= DRF_DEF(054, _BLEND, _SPECULARENABLE, _TRUE);    \
                while (nvFreeCount < 2)                                     \
                    nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, 2);  \
                ((DWORD *)(nvFifo))[0] = (((1 << 2) << 16) | (NV_DD_SPARE << 13) | NV054_BLEND); \
                ((DWORD *)(nvFifo))[1] = (blend);                           \
                nvFreeCount -= 2;                                           \
                (DWORD *)nvFifo += 2;                                       \
                (count) = 0;                                                \
                (SpecCurr) = TRUE;                                          \
            }                                                               \
        }                                                                   \
        else                                                                \
        {                                                                   \
            (count)++;                                                      \
            if ((count) == 5)                                               \
            {                                                               \
                (blend) &= 0xFFFF0FFF;                                      \
                while (nvFreeCount < 2)                                     \
                    nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, 2);  \
                ((DWORD *)(nvFifo))[0] = (((1 << 2) << 16) | (NV_DD_SPARE << 13) | NV054_BLEND); \
                ((DWORD *)(nvFifo))[1] = (blend);                           \
                nvFreeCount -= 2;                                           \
                (DWORD *)nvFifo += 2;                                       \
                (SpecCurr) = FALSE;                                         \
            }                                                               \
        }                                                                   \
    }                                                                       \
}
#else   // !SPEC_HACK
#define SPEC_CHECK(SpecState, SpecCurr, S0, S1, S2, count, blend)
#endif  // !SPEC_HACK

/*
 * Check current FVF vertex type to determine if recalculation is needed.
 */
#define NVFVF_NOTEXTURE_VERTEX  (D3DFVF_TLVERTEX & ~D3DFVF_TEXCOUNT_MASK)
#define CHECK_FVF_DATA_AND_LOAD_TL(_fvfData,_vertexType,_dwVertexStride,_bNeedFVFReload)\
{                                                                           \
    (_bNeedFVFReload) = FALSE;                                              \
    if ((_fvfData).dwVertexType != (_vertexType))                           \
    {                                                                       \
        if ((_vertexType) == D3DFVF_TLVERTEX) /* load TL vertex */          \
        {                                                                   \
            extern NVD3DFVFDATA   constFVFData;                             \
            (_fvfData)          = constFVFData;                             \
            (_dwVertexStride)   = 32;                                       \
        }                                                                   \
        else if (((_vertexType) & ~D3DFVF_TEXCOUNT_MASK) == NVFVF_NOTEXTURE_VERTEX) \
        {                                                                   \
            extern NVD3DFVFDATA   constFVFData;                             \
            extern D3DTLVERTEX    tlvDefault;                               \
            DWORD dwUVCount;                                                \
            DPF_LEVEL(NVDBG_LEVEL_INFO, "D3D:Calculate TLVERTEX with extra UV data"); \
            dwUVCount = (((_vertexType) & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT); \
            (_fvfData)          = constFVFData;                             \
            (_dwVertexStride)   = 24 + (dwUVCount * 2 * 4);                 \
            (_fvfData).dwVertexType   = (_vertexType);                      \
            (_fvfData).dwVertexStride = (_dwVertexStride);                  \
            (_fvfData).dwUVCount      = dwUVCount;                          \
            if (!dwUVCount)                                                 \
            {                                                               \
                (_fvfData).dwUVMask   = 0x00000000;                         \
                (_fvfData).dwUVOffset = (DWORD)&tlvDefault.tu;              \
            }                                                               \
        }                                                                   \
        else                                  /* tag external fvfData calc*/\
        {                                                                   \
            (_bNeedFVFReload) = TRUE;                                       \
        }                                                                   \
    }                                                                       \
    else                                      /* load cached stride */      \
    {                                                                       \
        (_dwVertexStride) = (_fvfData).dwVertexStride;                      \
    }                                                                       \
}

#ifdef  NVD3D_DX6
typedef struct _def_nv_d3d_fvf_data     NVD3DFVFDATA, *PNVD3DFVFDATA;
struct _def_nv_d3d_fvf_data
{
    DWORD   dwVertexType;
    DWORD   dwVertexStride;
    DWORD   dwXYZMask;
    DWORD   dwXYZOffset;
    DWORD   dwRHWMask;
    DWORD   dwRHWOffset;
    DWORD   dwARGBMask;
    DWORD   dwARGBOffset;
    DWORD   dwSpecularMask;
    DWORD   dwSpecularOffset;
    DWORD   dwUVMask;
    DWORD   dwUVOffset;
    DWORD   dwUVCount;
    DWORD   _pad0;
    DWORD   _pad1;
    DWORD   _pad2;
};

typedef DWORD (*PFNRENDERPRIMITIVEOP)(DWORD, LPBYTE, LPD3DTLVERTEX);
typedef void  (*LPNVINDEXEDPRIM)     (DWORD, LPWORD, DWORD, LPD3DTLVERTEX);
typedef void  (*LPNVDRAWPRIM)        ( WORD,         DWORD, LPD3DTLVERTEX);
typedef void  (*LPNVFVFINDEXEDPRIM)  (DWORD, LPWORD, DWORD, LPBYTE);
typedef void  (*LPNVFVFDRAWPRIM)     ( WORD,         DWORD, LPBYTE);

#define NV_UV_COORDINATE_COUNT_MAX          2
#endif  // NVD3D_DX6

/*
 * Anti Aliasing context
 */
#define AA_MODE_SUPER                       0x00000001  // super sampled AA enabled
#define AA_MODE_SINGLECHUNK                 0x00000002  // single chunk super aa
#define AA_MODE_EDGE                        0x00000004  // edge AA enabled
#define AA_ENABLED_MASK                     0x0000000f  // all types of AA
#define AA_BUFALLOC_SUPER                   0x00000010  // super sampled aa buffers allocated
#define AA_BUFALLOC_SINGLECHUNK             0x00000020  // single chunk super sampled aa buffers allocated
#define AA_BUFALLOC_EDGE                    0x00000040  // edge aa buffers allocated
#define AA_BUFALLOC_MASK                    0x000000f0  // internal buffers allocated
#define AA_INVALID_SEMANTICS                0x00000100  // app behaves badly - aa is disabled
#define AA_CAPTURE_PUSHBUFFER               0x00000200  // aa captures to sysmem push buffer
#define AA_RENDER                           0x00000400  // aa is rendering
#define AA_CLEAR_SCREEN                     0x00000800  // set when we need to clear buffers
#define AA_CHECK_SEMANTICS                  0x00001000  // used to detect bad semantics (2d during 3d)
#define AA_COPY_SCREEN                      0x00002000  // copy frame buffer to super buffer instead of clear
#define AA_PENDING_DATA                     0x00004000  // set in singlechunk mode if we actually have rendered tris
#define AA_IN_SCENE                         0x00008000  // inside a scene - 2d is not tolerated
#define AA_2D_ADD                           0x10000000  // see below
#define AA_2D_MAX                           0x50000000  // see below ... max 2d to disable
#define AA_2D_COUNT_MASK                    0x70000000  // used to detect the app mixing 2d & 3d
#define AA_MIX_DP_NOAA                      0x00010000  // we drew primitives without aa
#define AA_MIX_DP_AA                        0x00020000  // we drew primitives with aa
#define AA_MIX_MASK                         0x00030000  // both

#define NV_AA_SEMANTICS_SETUP(_ctx)                                                 \
{                                                                                   \
    DPF_LEVEL(NVDBG_LEVEL_AA_INFO,"macro NV_AA_SEMANTICS_SETUP");                   \
    if ((_ctx)->dwAntiAliasFlags & (AA_MODE_SUPER | AA_MODE_SINGLECHUNK))           \
    {                                                                               \
        if (pDriverData->TwoDRenderingOccurred)                                     \
        {                                                                           \
            DPF_LEVEL(NVDBG_LEVEL_AA_INFO,"    2D rendering Occurred");             \
            (_ctx)->dwAntiAliasFlags |= AA_COPY_SCREEN;                             \
        }                                                                           \
        (_ctx)->dwAntiAliasFlags &= ~(AA_2D_COUNT_MASK | AA_MIX_MASK);              \
    }                                                                               \
    DPF_LEVEL(NVDBG_LEVEL_AA_INFO,"endm");                                          \
}
#define NV_AA_SEMANTICS_CHECK(_ctx)                                                 \
{                                                                                   \
    DPF_LEVEL(NVDBG_LEVEL_AA_INFO,"macro NV_AA_SEMANTICS_CHECK");                   \
    if ((_ctx)->dwAntiAliasFlags & (AA_MODE_SUPER | AA_MODE_SINGLECHUNK))           \
    {                                                                               \
        if (pDriverData->TwoDRenderingOccurred)                                     \
        {                                                                           \
            DPF_LEVEL(NVDBG_LEVEL_AA_INFO,"    2D rendering Occurred");             \
            (_ctx)->dwAntiAliasFlags += AA_2D_ADD;                                  \
            if (((_ctx)->dwAntiAliasFlags & AA_2D_COUNT_MASK) > AA_2D_MAX)          \
            {                                                                       \
                DPF_LEVEL(NVDBG_LEVEL_AA_INFO,"    Invalid Semantics Tagged");      \
                (_ctx)->dwAntiAliasFlags &= ~(AA_2D_COUNT_MASK | AA_ENABLED_MASK);  \
                (_ctx)->dwAntiAliasFlags |=  AA_2D_ADD | AA_INVALID_SEMANTICS;      \
                NV_FORCE_TRI_SETUP(_ctx);                                           \
                NV_D3D_GLOBAL_SAVE();                                               \
                nvFlushDmaBuffers();                                                \
                NV_D3D_GLOBAL_SETUP();                                              \
                pDriverData->lpLast3DSurfaceRendered = 0;                           \
                nvSetD3DSurfaceState (_ctx);                                        \
            }                                                                       \
            else                                                                    \
            {                                                                       \
                if (!((_ctx)->dwAntiAliasFlags & AA_PENDING_DATA))                  \
                {                                                                   \
                    (_ctx)->dwAntiAliasFlags |= AA_COPY_SCREEN;                     \
                }                                                                   \
            }                                                                       \
        }                                                                           \
    }                                                                               \
    DPF_LEVEL(NVDBG_LEVEL_AA_INFO,"endm");                                          \
}

typedef struct
{
    // bank 0
    DWORD dwChunkWidth;         // screen chunk width
    DWORD dwChunkHeight;        // screen chunk height
    DWORD dwSuperAddr;          // address of super buffer
    DWORD dwSuperOffset;        // aligned HW offset of super buffer
    DWORD dwSuperPitch;         // super surface pitch
    DWORD dwSuperWidth;         // super surface dimensions
    DWORD dwSuperHeight;        // super surface dimensions
    DWORD dwBPP;                // bytes per pixel
    // bank 1
    union {
        DWORD dwCapAddr;        // capture buffer address (chunking / edge)
        DWORD dwSuperZAddr;     // z buffer (single chunk)
    };
    union {
        DWORD dwCapSize;        // capture buffer size (chunking / edge)
        DWORD dwSuperZOffset;   // z buffer offset (single chunk)
    };
    union {
        DWORD dwCapIndex;       // capture index (chunking / edge)
        DWORD dwSuperZPitch;    // z buffer offset (single chunk)
    };
    float fAAScaleX;            // super sample in X
    float fAAScaleY;            // super sample in Y
    DWORD dwAASuperMode;        // lut index
    DWORD dwCFill;              // c fill     (super)
    DWORD dwZFill;              // z fill     (super)
} NVAACONTEXT,*PNVAACONTEXT;

/*
 * --------------------------------------------------------------------------
 * Define NV4 specific texture heap constants
 * --------------------------------------------------------------------------
 */
#define NV_MIN_TEXTURE_SIZE         ((1 * 2) * 1)
#define NV_MIN_TEXTURE_HEAP_SIZE    0x00100000
#define NV_TEXTURE_PAD              512
#define NV_TEXTURE_OFFSET_ALIGN     255

/*
 * Define Application DirectX version levels.
 */
#define APP_VERSION_DX2             0
#define APP_VERSION_DX3             0
#define APP_VERSION_DX5             1
#define APP_VERSION_DX6             2

/*
 * Define texture attributes
 */
#define NV4_TEXDEFAULT_AUTOMIPMAPTIME   3           // # of scenes before automips kick in
#define NV4_TEXDEFAULT_MAXBLTCOUNT      10          // # of CPU swizzle blits to take before staging
#define NV3_TEXDEFAULT_MIPSPERSCENE     3           // # if auto mips we allow to be generated per scene

#ifdef NV_TEX2
/*
 * texture manager 2.0 flags
 */
#define NV4_TEXCOUNT_SWIZZLE            8           // # of possible swizzle surface (must be power of 2)

#define NV4_TEXFLAG_SWIZZLE_INDEX       0x0000000f  // index of current swizzle surface
#define NV4_TEXFLAG_SWIZZLE_INDEX_MAX   0x000000f0  // max index of current swizzle surface

#define NV4_TEXFLAG_LINEAR_VALID        0x00010000  // linear copy has valid texels (up to date)
#define NV4_TEXMASK_LINEAR_LOCATION     0x00000f00  // linear copy location (vid,agp or pci)
#define NV4_TEXMASK_LINEAR_SHIFT        8

#define NV4_TEXFLAG_HANDLE_ALLOCATED    0x00020000  // Texture handle allocated for this texture.
#define NV4_TEXFLAG_AUTOMIPMAP          0x00040000  // we are allowed to automipmap this texture
#define NV4_TEXFLAG_AUTOMIPMAP_VALID    0x00080000  // we have valid automipmapped texels
#define NV4_TEXFLAG_USER_MIP_LEVEL      0x00100000  // This texture is a user defined mip level.
#define NV4_TEXFLAG_PALETTIZED          0x00200000  // set if texture is 8-bit palettized

#define NV4_TEXLOC_NOWHERE              0           // surface is not allocated
#define NV4_TEXLOC_VID                  1           // surface is (or may go) in video  (hw r/w)
#define NV4_TEXLOC_AGP                  2           // surface is (or may go) in agp    (hw r/-)
#define NV4_TEXLOC_PCI                  4           // surface is (or may go) in pci    (hw r/-)
#define NV4_TEXLOC_SYS                  8           // surface is (or may go) in sysmem (hw -/-)
#define NV4_TEXLOC_ANYWHERE             15          // texture may go anywhere

/*
 * swizzle surface flags
 */
#define NV4_TEXMASK_LOCATION            0x0000000f  // location of swizzle texture (do not move - hard coded)
#define NV4_TEXMASK_MIPMASK             0x0000fff0  // mask if updated mipmaps for this texture (0 means valid)
#define NV4_TEXFLAG_VALID               0x00010000  // texture is valid (mips dont have to be all valid)

/*
 * handy macros
 */
#define TEX_SWIZZLE_INDEX(flags)        ((flags) & NV4_TEXFLAG_SWIZZLE_INDEX)
#define TEX_SWIZZLE_ADDR(tex,flags)     ((tex)->dwSwizzleAddr[TEX_SWIZZLE_INDEX(flags)])
#define TEX_SWIZZLE_OFFSET(tex,flags)   ((tex)->dwSwizzleOffset[TEX_SWIZZLE_INDEX(flags)])
#define TEX_SWIZZLE_FLAGS(tex,flags)    ((tex)->dwSwizzleFlags[TEX_SWIZZLE_INDEX(flags)])
#define TEX_SWIZZLE_DATE(tex,flags)     ((tex)->dwSwizzleDate[TEX_SWIZZLE_INDEX(flags)])

#else //NV_TEX2
/*
 * texture manager 1.0 flags
 */
#define NV3_TEXTURE_VIDEO_MEMORY        0x00000001
#define NV3_TEXTURE_BLIT_UPDATE         0x00000002  // Texture modified with a DDRAW blit.
#define NV4_TEXTURE_CAN_AUTO_MIPMAP     0x00000004  // Specifies a texture can be automipmaped.
#define NV3_TEXTURE_MODIFIED            0x00000008  // texture memory has changed - force a internal reload
#define NV3_TEXTURE_IS_LOCKED           0x00000010  // texture is currently locked 
#define NV3_TEXTURE_MUST_RELOAD         0x00000020  // force current buffre DMA before reload (blt during scene)
#define NV3_TEXTURE_HANDLE_ALLOCATED    0x00000040  // Texture handle allocated for this texture.
#define NV3_TEXTURE_SURFACE_ALLOCATED   0x00000080  // Texture surface allocated for this texture.
#define NV3_TEXTURE_USER_ALLOCATED      0x00000100  // User system memory texture surface is allocated.
#define NV3_TEXTURE_INTERNAL_ALLOCATED  0x00000200  // Internal texture surface is allocated.
#define NV3_TEXTURE_USER_MIP_LEVEL      0x00000400  // This texture is a user defined mip level.
#define NV4_TEXTURE_WAS_IN_VIDEO_MEMORY 0x00000800  // texture was move from video memory by AA
#define NV4_TEXTURE_AUTOMIPMAPPED       0x00001000  // texture mipmaps are driver supplied (auto mipmapped)
#endif //NV_TEX2

/*
 * common flags
 */

struct _def_nv_d3d_texture
{
    /*
     * Second (final) pass texture definition.
     */
    DWORD                       pid;                /* Process ID */
    DWORD                       hContext;           /* Context Handle */
    DWORD                       hMipBaseTexture;    /* User Mip Base Texture Handle */

    LPDDRAWI_DIRECTDRAW_GBL     lpDriverObject;     /* Driver object used for allocating memory */
#ifndef WINNT
    LPDIRECTDRAWSURFACE         lpDDS;              /* Texture Surface */
#else
    HANDLE                      hDDS;               /* NT texture handle */
#endif
    LPDDRAWI_DDRAWSURFACE_LCL   lpLcl;              /* Texture */
    DWORD                       dwDriverData;       /* address of pDriverData */

    /*
     * Basic texture characteristics.
     */
    DWORD                       dwWidth;
    DWORD                       dwHeight;
    DWORD                       dwPitch;
#ifdef NV_TEX2
    DWORD                       dwBPP;               // bytes per pixel
    DWORD                       dwLockUpdateCount;   // # of lock performed
    DWORD                       dwBlitUpdateCount;   // # of blits performed
#else
    DWORD                       dwUpdateCount;       /* # of texture blts / locks performed */
#endif

    /*
     * MipMap Texture Information.
     */
    DWORD                       dwMipMapLevels;
    DWORD                       dwMipMapBaseU;
    DWORD                       dwMipMapBaseV;
    DWORD                       dwMipMapSizeBytes;

    /*
     * Internal hardware texture format information.
     */
    HANDLE                      hTextureMem;
    DWORD                       dwTextureFlags;
    DWORD                       dwTextureContextDma;
    DWORD                       dwTextureColorFormat;
#ifdef NV_TEX2
    DWORD                       dwSwizzleAddr  [NV4_TEXCOUNT_SWIZZLE];    // actual swizle surface address (not aligned)
    DWORD                       dwSwizzleOffset[NV4_TEXCOUNT_SWIZZLE];    // offset of swizzle surface
    DWORD                       dwSwizzleFlags [NV4_TEXCOUNT_SWIZZLE];    // flags for this surface
    DWORD                       dwSwizzleDate  [NV4_TEXCOUNT_SWIZZLE];    // scene it retires in
    DWORD                       dwRetireDate   [NV4_TEXCOUNT_SWIZZLE+1];  // when the texture surface retires, extra is for linear
    DWORD                       dwLinearAddr;       // actual linear address (not aligned)
    DWORD                       dwLinearOffset;     // offset of linear surface
#else
    DWORD                       dwTexturePointer;
    DWORD                       dwTextureOffset;    /* Texture offset within heap */
#endif

    /*
     * Reference pointer to texture data.
     * This is used only for validation and checking to see if the texture
     * pointer in the texture surface has changed.  This may occur during
     * texture flipping.  If this pointer does not match what is stored in
     * in the texture surface, then the texture needs to be reloaded.
     */
    FLATPTR                     fpTexture;

#ifdef NV_TEX2
    /*
     * auto mipmap code
     */
    DWORD                       dwAutoMipMapScene;      // scene # that automips kick in
    DWORD                       dwAutoMipMapCount;      // mipmap count (when activated)
    /*
     * dirty rectangle
     */
    DWORD                       dwDirtyX0;              // dirty rect (for efficient lin<->swiz)
    DWORD                       dwDirtyY0;              // dirty rect (for efficient lin<->swiz)
    DWORD                       dwDirtyX1;              // dirty rect (for efficient lin<->swiz)
    DWORD                       dwDirtyY1;              // dirty rect (for efficient lin<->swiz)
#else // !NV_TEX2
    /*
     * User texture surface allocated for this texture.
     */
    HANDLE                      hUserTexture;
    FLATPTR                     fpUserTexture;
#endif // !NV_TEX2

    /*
     * Application Texture Bug Workarounds.
     * Just handy for fixing developers bugs while we wait for the
     * real fix.
     */
    DWORD                       dwDebugFlags01;
    DWORD                       dwDebugFlags02;

    PNVD3DTEXTURE               pTexturePrev;
    PNVD3DTEXTURE               pTextureNext;
};

/*
 * Look in D3DTYPES.H to determine what this value is.
 * I'm not including any of the stipple state on purpose.
 */
#ifdef  NVD3D_DX6
#define D3D_RENDERSTATE_MAX     D3DRENDERSTATE_WRAP7
#else   // !NVD3D_DX6
#define D3D_RENDERSTATE_MAX     D3DRENDERSTATE_FLUSHBATCH
#endif  // !NVD3D_DX6

/*
 * Cache aligned inner loop context data.
 * Note also, that the hardware registers should be defined in the order that
 * they appear in the in the object class.
 */
struct _def_nv_d3d_context_inner_loop
{
// bank 0       !!!Don't change bank or element ordering!!!
    /*
     * Current rendering state.
     */
    DWORD                       dwColorKey;
    DWORD                       dwTextureOffset;       // Offset within DMA context to start of texture.
    DWORD                       dwFormat;
    DWORD                       dwFilter;              // Current filtering state.
    DWORD                       dwBlend;
    DWORD                       dwControl;
    DWORD                       dwFogColor;             // Current fog color.
    DWORD                       _dwPad0[1];

// bank 1       !!!Don't change bank or element ordering!!!!
#ifdef  SPEC_HACK
    /*
     * Values used for temporarily disabling hardware specular enable bit when
     * the vertex specular components do not contribute any specular highlight.
     * This is so that we can get two pixels per clock out of the DX5 class
     * whenever possible.

     */
    DWORD                       dwCurrentBlend;
    DWORD                       dwCurrentSpecularState;
    DWORD                       dwNoSpecularTriangleCount;
    DWORD                       _dwPad1[5];
#endif  // SPEC_HACK
};
#ifdef  NVD3D_DX6
typedef struct _def_nv_d3d_texture_stage_state NVD3DTEXSTAGESTATE, *PNVD3DTEXSTAGESTATE;
struct _def_nv_d3d_texture_stage_state
{
    DWORD   dwTextureMap;
    DWORD   dwAddressU;
    DWORD   dwAddressV;
    DWORD   dwMagFilter;
    DWORD   dwMinFilter;
    DWORD   dwMipFilter;
    DWORD   dwColorOp;
    DWORD   dwColorArg1;
    DWORD   dwColorArg2;
    DWORD   dwAlphaOp;
    DWORD   dwAlphaArg1;
    DWORD   dwAlphaArg2;
    DWORD   dwBumpEnvMat00;
    DWORD   dwBumpEnvMat01;
    DWORD   dwBumpEnvMat10;
    DWORD   dwBumpEnvMat11;
    DWORD   dwTexCoordIndex;
    DWORD   dwBorderColor;
    DWORD   dwMipMapLODBias;
    DWORD   dwMaxMipLevel;
    DWORD   dwMaxAnisotropy;
    DWORD   dwBumpEnvlScale;
    DWORD   dwBumpEnvlOffset;
    /*
     * Extra per stage state.
     */
    BYTE    bStageNumber;
    BYTE    bWrapU;
    BYTE    bWrapV;
    BYTE    bLODBias;
};

typedef struct _def_nv_d3d_multi_texture_state NVD3DMULTITEXTURESTATE, *PNVD3DMULTITEXTURESTATE;
struct _def_nv_d3d_multi_texture_state
{
    DWORD   dwTextureOffset[2];
    DWORD   dwTextureFormat[2];
    DWORD   dwTextureFilter[2];
    DWORD   dwCombine0Alpha;
    DWORD   dwCombine0Color;
    DWORD   dwCombine1Alpha;
    DWORD   dwCombine1Color;
    DWORD   dwCombineFactor;
    DWORD   dwBlend;
    DWORD   dwControl0;
    DWORD   dwControl1;
    DWORD   dwControl2;
    DWORD   dwFogColor;

    /*
     * The hardware requires the the UVx texture coordinates match up with
     * TEXTUREx.  i.e. tu0, tv0 are the coordinates for TEXTURE0, and tu1,
     * tv1 are the coordinates for TEXTURE1.
     * To simplify life, I am making TEXTURE0 always correspond to texture
     * stage 0, TEXTURE1 will always correspond to texture stage 1, etc.
     * However, there does not always have to be a one to one correspondence
     * to the Texture stage and the order in which the UV coordinate pairs
     * appear in the FVF Vertices.  The texture stage state defines which
     * set of UV coordinates applies to the texture in that stage.  This
     * allows for a single set of UV coordinates to be used for the multiple
     * texture stages.
     * The following offset array gives the byte offset from the start of the
     * FVF UV corrdinate pairs to the actual UV coordinates to be used for
     * a particular UVx pair.  They are initialized when the multi-texture state
     * is caclulated.
     */
    DWORD   dwUVOffset[8];

    /*
     * This flag defines if the current texture stage state is
     * valid.  This flag basicly defines whether or not multi-texturing
     * is possible with the current state.
     * This flag can be used during the ValidateTextureStageState callback
     * to report whether we can mulit-texture with the current state.
     * If the state is not valid, ddrval will contain the error that should
     * be returned during a ValidateTextureStageState callback.
     */
    BOOL    bTSSValid;
    HRESULT ddrval;
};
#endif  // NVD3D_DX6

/*
 * Define the context flags.
 */
#define NV_CONTEXT_ZETA_BUFFER_MISMATCH         0x00000001
#define NV_CONTEXT_TBLEND_UNINITIALIZED         0x00000002  // This flag will be cleared after the first TBLEND call.

#ifdef NV_CONTROLTRAFFIC
#define NV_CT_DISABLED          0x00000000
#define NV_CT_ENABLED           0x00000001
#define NV_CT_FRONT             0x00000002
#define NV_CT_DRAWPRIM          0x00010000
#endif //NV_CONTROLTRAFFIC

/*
 * Define the context header.
 */
struct _def_nv_d3d_context
{
    /*
     * The following structure is designed for a fast copy from the context data structure
     * to cache aligned global data for fast access within the inner loops.
     */
    NVD3DCONTEXTINNERLOOP       ctxInnerLoop;           // Context data used within inner loops.
    NVD3DCONTEXTINNERLOOP       ctxInnerLoopShadow;     // hw image of above

    /*
     * Application DX version.
     */
    DWORD                       dwDXVersionLevel;       // Tells the applications DX version level.
                                                        // 0=DX2, DX3; 1=DX5; 2=DX6

    /*
     * D3D Context Flags.
     */
    DWORD                       dwContextFlags;         // Various context related flags.

    /*
     * Default texture state for this context.
     */
    DWORD                       dwDefaultTextureContextDma;  // Default texture rendering object.
    DWORD                       dwDefaultTextureBase;
    DWORD                       dwDefaultTextureOffset;      // Offset within DMA context to start of default texture.
    DWORD                       dwDefaultTextureColorFormat; // Default texture format.

#ifdef NV_TEX2
    PNVD3DTEXTURE               pTexture0;              // texture HW is currently setup with
    PNVD3DTEXTURE               pTexture1;              // texture HW is currently setup with
    
    DWORD                       dwTexturePaletteStagingHandle;
    DWORD                       dwTexturePaletteAddr;   // address of palette staging area
    DWORD                       dwTexturePaletteOffset; // offset of palette staging area
#endif

    /*
     * Surface clip rectangle.
     */
    struct  _surface_viewport                           // Surface clip region.
    {
        union
        {
            DWORD   dwClipHorizontal;
            struct  _clip_horizontal
            {
                WORD    wX;                             // Surface left edge
                WORD    wWidth;                         // Surface Clip Width
            } clipHorizontal;
        };
        union
        {
            DWORD   dwClipVertical;
            struct  _clip_vertical
            {
                WORD    wY;                             // Surface top edge
                WORD    wHeight;                        // Surface Clip Height
            } clipVertical;
        };
    } surfaceViewport;

    /*
     * Surface Pitch
     */
    union
    {
        DWORD   dwSurfacePitch;                         // Surface pitches.
        struct _surface_pitch
        {
            WORD    wColorPitch;                        // Render target pitch.
            WORD    wZetaPitch;                         // Zeta buffer pitch.
        } surfacePitch;
    };

    /*
     * Current Surface.
     */
    DWORD                       dwSurfaceAddr;
    DWORD                       dwSurfaceOffset;
    DWORD                       dwSurfaceFormat;

    /*
     * Current Z Buffer address.
     */
    DWORD                       ZBufferAddr;            // Pointer to Z Buffer
    DWORD                       ZBufferOffset;

    /*
     * Current rendering state.
     */
    DWORD                       dwStateChange;
    DWORD                       dwRenderState[D3D_RENDERSTATE_MAX];
    DWORD                       dwFogTableMode;         // Current fog table mode.
    float                       fFogTableStart;         // Current fog table start.
    float                       fFogTableEnd;           // Current fog table end.
    float                       fFogTableDensity;       // Current fog table density.
    float                       fFogTableLinearScale;   // Current fog table linear scale.
    DWORD                       dwFunctionLookup;       // Lookup index for the appropriate render function.
    DWORD                       dwMipMapLODBias;        // LOD Bias value to stuff into the hardware.
    DWORD                       dwSceneCount;           // # of scenes we have rendered in this context
    DWORD                       dwMipMapsInThisScene;   // # of auto mips generated in this scene

    /*
     * Anti aliasing context storage
     */
    DWORD                       dwAntiAliasFlags;
    NVAACONTEXT                *pAAContext;

    /*
     * Optimized Z data
     */
#ifdef NV_CONTROLTRAFFIC
    DWORD                       dwCTFlags;
#endif

    /*
     * Miscellaneous context data.
     */
    LPDDRAWI_DDRAWSURFACE_LCL   lpLcl;                  // Rendering surface.
    LPDDRAWI_DDRAWSURFACE_LCL   lpLclZ;                 // Z surface.
    DWORD                       pid;                    // Process ID
    NVD3DSTATESET               overrides;              // Render state override bits.

    DWORD                       dwContextReset;         // This is set when a mode switch occurs.
    PNVD3DCONTEXT               pContextPrev;
    PNVD3DCONTEXT               pContextNext;

#ifdef  NVD3D_DX6
    /*
     * DX6 Texture Stage State.
     */
    DWORD                       dwStageCount;           // Number of enabled/valid texture stages.
    BOOL                        bUseDX6Class;           // Use DX6 Multi-Texture Triangle Class.
    BOOL                        bUseTBlendSettings;     //
    DWORD                       dwTBlendCombine0Alpha;
    DWORD                       dwTBlendCombine0Color;
    NVD3DMULTITEXTURESTATE      mtsState;               // DX6 Multi-Texture Triangle State.
    NVD3DMULTITEXTURESTATE      mtsShadowState;         //  for state update optimizations
    NVD3DTEXSTAGESTATE          tssState[8];            // Texture Stage State.

    /*
     * Near/Far Clip planes.
     */
    D3DVALUE                    dvWNear;
    D3DVALUE                    dvWFar;
    D3DVALUE                    dvRWFar;                // Reciprocal of WFar.
#endif  // NVD3D_DX6
#ifdef WINNT
    /*
     * Need this for Winnt to access the PDEV state struct maintained by display
     * driver. PDEV also contains a ptr to the GLOBALDATA struct.
     *
     */
    PDD_DIRECTDRAW_GLOBAL        lpDD;
#endif // #ifdef WINNT
};

/*
 * Function Prototypes
 */
void nvD3DCreateObjects(void);
void nvD3DDestroyObjects(void);
#ifndef WINNT
DWORD __stdcall Clear32(LPD3DHAL_CLEARDATA);
#endif

void  nvSetD3DSurfaceState(PNVD3DCONTEXT);
void  nvSetD3DSurfaceViewport(PNVD3DCONTEXT);
void  nvSetDx5TriangleState(PNVD3DCONTEXT);
DWORD nvRenderNoOp(DWORD, LPBYTE, LPD3DTLVERTEX);
DWORD nvRenderTriangle(DWORD, LPBYTE, LPD3DTLVERTEX);
DWORD nvRenderPoint(DWORD, LPBYTE, LPD3DTLVERTEX);
DWORD nvRenderLine(DWORD, LPBYTE, LPD3DTLVERTEX);

#ifndef WINNT
DWORD nvClear(LPD3DHAL_CLEARDATA);
#endif
void  nvTriangle(DWORD, LPD3DTRIANGLE, LPD3DTLVERTEX);
void  nvIndexedTriangle(DWORD, WORD, LPWORD, LPD3DTLVERTEX);

#ifdef  MULTI_MON
void D3DDestroyTextureContexts(void);
#endif  // MULTI_MON
#ifndef WINNT
/*
 * Non-Indexed Primitive Routines.
 */
DWORD __stdcall DrawOnePrimitive32(LPD3DHAL_DRAWONEPRIMITIVEDATA);
DWORD __stdcall DrawPrimitives32(LPD3DHAL_DRAWPRIMITIVESDATA);
DWORD nvDrawOnePrimitive(LPD3DHAL_DRAWONEPRIMITIVEDATA);
DWORD nvDrawPrimitives(LPD3DHAL_DRAWPRIMITIVESDATA);

/*
 * Indexed Primitive Routines.
 */
DWORD __stdcall DrawOneIndexedPrimitive32(LPD3DHAL_DRAWONEINDEXEDPRIMITIVEDATA);
DWORD nvDrawOneIndexedPrimitive(LPD3DHAL_DRAWONEINDEXEDPRIMITIVEDATA);
#endif
void nvDrawLine(DWORD, DWORD, LPD3DTLVERTEX);
void nvIndexedLine(DWORD, LPWORD, DWORD, LPD3DTLVERTEX);
void nvDrawPointList(DWORD, LPD3DTLVERTEX);

void nvIndexedWireframeTriangle(DWORD, LPWORD, DWORD, LPD3DTLVERTEX);
void nvDrawWireframeTriangle(DWORD, DWORD, LPD3DTLVERTEX);
void nvIndexedPointTriangle(DWORD, LPWORD, DWORD, LPD3DTLVERTEX);
void nvDrawPointTriangle(DWORD, DWORD, LPD3DTLVERTEX);

#ifdef  NVD3D_DX6
DWORD FAR PASCAL DrawPrimitives2(LPD3DHAL_DRAWPRIMITIVES2DATA);
DWORD FAR PASCAL Clear2(LPD3DHAL_CLEAR2DATA pc2d);

void  nvSetMultiTextureHardwareState(void);
DWORD FAR PASCAL nvValidateTextureStageState(LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA);
DWORD nvDrawPrimitives2(LPD3DHAL_DRAWPRIMITIVES2DATA);
DWORD nvClear2(LPD3DHAL_CLEAR2DATA pc2d);

void nvFVFDrawLine(DWORD, DWORD, LPBYTE);
void nvFVFIndexedLine(DWORD, LPWORD, DWORD, LPBYTE);
void nvFVFDrawPointList(DWORD, LPBYTE);

void nvFVFIndexedWireframeTriangle(DWORD, LPWORD, DWORD, LPBYTE);
void nvFVFDrawWireframeTriangle(DWORD, DWORD, LPBYTE);
void nvFVFIndexedPointTriangle(DWORD, LPWORD, DWORD, LPBYTE);
void nvFVFDrawPointTriangle(DWORD, DWORD, LPBYTE);

void nvSetDx6MultiTextureState(PNVD3DCONTEXT);
#endif  // NVD3D_DX6

/*
 * External data.
 */
extern PFNRENDERPRIMITIVEOP     pfnRenderPrimitiveOperation[];
extern DWORD                    uvInterleave[];

#ifdef  NVD3D_DX6
extern PFND3DPARSEUNKNOWNCOMMAND    fnD3DParseUnknownCommandCallback;
/* - not used anymore ?
extern LPNVFVFDRAWPRIM              fnMultiDrawTriangleList[];
extern LPNVFVFDRAWPRIM              fnMultiDrawTriangleStrip[];
extern LPNVFVFDRAWPRIM              fnMultiDrawTriangleFan[];
extern LPNVFVFINDEXEDPRIM           fnMultiIndexedTriangleList[];
extern LPNVFVFINDEXEDPRIM           fnMultiIndexedTriangleStrip[];
extern LPNVFVFINDEXEDPRIM           fnMultiIndexedTriangleFan[];
*/
#endif  // NVD3D_DX6

/*
 * Texture Staging Manager Functions
 */
//#define TM_STAGER_IN_AGP
#define TM_STAGESPACE              (2*1024*1024) // 2048k

#define NV_PN_TEX_RETIRE           0    // depreciated in for nv_tex2
#define NV_PN_SPOOFED_FLIP_COUNT   4
#define NV_PN_TEXTURE_RETIRE       8

void __stdcall nvFastCopy          (DWORD,DWORD,DWORD);
DWORD nvPlacePsuedoNotifier        (DWORD,DWORD);
DWORD nvTMCreate                   (void);
void  nvTMDestroy                  (void);
DWORD nvTMAllocTextureStagingSpace (DWORD,DWORD*,DWORD*);
void  nvTMUpdateRetirementDate     (DWORD);
void  nvTMVideoTextureBlt          (DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD);

/*
 * Embedded Profiler Functions
 */
#ifdef NV_PROFILE

#if 0
/*
 * Constants
 */
#define NVP_T_CLOCK                 0x00    // 00000001
#define NVP_T_FLUSH                 0x01    // 00000002
#define NVP_T_SCENE                 0x02    // 00000004
#define NVP_T_FLIP                  0x03    // 00000008
#define NVP_T_DP2                   0x04    // 00000010
#define NVP_T_FREECOUNT             0x05    // 00000020
#define NVP_T_TSTAGE                0x06    // 00000040

#define NVP_E_PUT                   0x10    // 00010000
#define NVP_E_BEGINSCENE            0x11    // 00020000

#define NVP_C_PENDING               0x18    // 01000000

#define NVP_EVERYTHING                       0x0103007f

/*
 * Macros
 */
#define _NVP_PUSH  __asm push eax __asm push edx __asm push ebx
#define _NVP_POP   __asm pop ebx __asm pop edx __asm pop eax
#define _NVP_SYNC  __asm xchg al,al __asm nop __asm nop
#define _NVP_RDTSC _NVP_SYNC __asm _emit 0x0f __asm _emit 0x31

#define NVP_START(_t) { nvpTime[_t]=0; NVP_RESTART(_t); }
#define NVP_RESTART(_t) { _NVP_PUSH _NVP_RDTSC __asm mov ebx,(OFFSET nvpTime+(_t)*8) __asm sub [ebx],eax __asm sbb [ebx+4],edx _NVP_POP }
#define NVP_STOP(_t)  { _NVP_PUSH _NVP_RDTSC __asm mov ebx,(OFFSET nvpTime+(_t)*8) __asm add [ebx],eax __asm adc [ebx+4],edx _NVP_POP }

extern __int64 nvpTime[256];

/*
 * protoypes
 */
void nvpFlush    (void);
void nvpCreate   (void);
void nvpDestroy  (void);
void nvpLogCount (DWORD id,__int64 count);
void nvpLogTime  (DWORD id,__int64 time);
void nvpLogEvent (DWORD id);
#endif // 0

#if 1

/*
 * Constants
 */
#define NVP_E_BEGINSCENE            0
#define NVP_E_PUT                   1
#define NVP_E_TRIDISP               2

#define NVP_T_SCENE                 3
#define NVP_T_FREECOUNT             4
#define NVP_T_FLIP                  5
#define NVP_T_TSTAGE                6
#define NVP_T_DP2                   7
#define NVP_T_HDFLUSH               8
#define NVP_T_TEXWAIT               9
#define NVP_T_TEXSWBLT              10
#define NVP_T_TEXHWBLT              11
#define NVP_T_INNERLOOP             12
#define NVP_T_BUILDLOOP             13

#define NVP_C_PENDING               14
#define NVP_C_BLTSIZE               15
#define NVP_C_1PIXCLK               16
#define NVP_C_2PIXCLK               17
#define NVP_C_TRIAREA               18
#define NVP_C_PIXPERSEC             19
#define NVP_C_TRICOUNT              20

/*
 * Macros
 */
#define _NVP_PUSH  __asm push eax __asm push edx __asm push ebx
#define _NVP_POP   __asm pop ebx __asm pop edx __asm pop eax
#define _NVP_SYNC  __asm xchg al,al __asm nop __asm nop
#define _NVP_RDTSC _NVP_SYNC __asm _emit 0x0f __asm _emit 0x31

#define NVP_START(_t) { nvpTime[_t]=0; NVP_RESTART(_t); }
#define NVP_RESTART(_t) { _NVP_PUSH _NVP_RDTSC __asm mov ebx,(OFFSET nvpTime+(_t)*8) __asm sub [ebx],eax __asm sbb [ebx+4],edx _NVP_POP }
#define NVP_STOP(_t)  { _NVP_PUSH _NVP_RDTSC __asm mov ebx,(OFFSET nvpTime+(_t)*8) __asm add [ebx],eax __asm adc [ebx+4],edx _NVP_POP }

extern __int64 nvpTime[256];
extern DWORD   nvpEnableBits;
extern DWORD   nvpTriPerSecWindow;

/*
 * functions
 */
void nvpCreate   (void);
void nvpDestroy  (void);
void nvpFlush    (void);
void nvpLogEvent (DWORD id);
void nvpLogCount (DWORD id,int count);
void nvpLogTime  (DWORD id,__int64 time);

#endif // 1

#endif // NV_PROFILE

#ifdef NV_FASTLOOPS
/*
 * nv4comp.h
 */
typedef void (__stdcall *PFNDRAWPRIMITIVE)(DWORD dwPrimCount,LPWORD pIndices,DWORD dwStrides,LPBYTE pVertices);

#endif //NV_FASTLOOPS

#endif  // NV4
#endif  // _NV4DINC_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\inc\NV4DMAC.H ===
#ifndef _NV4DMAC_H_
#define _NV4DMAC_H_

#ifdef  NV4
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4DMAC.H                                                         *
*   Define various macros used in the D3D driver.                           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       1/26/98 - Created                       *
*                                                                           *
\***************************************************************************/

/*
 * Defining this macro will cause the driver to use the PIO hardware registers
 * when the driver is compiled for PIO.
 * When this macro is not defined, a system memory buffer will be allocated and
 * used in place of the real hardware registers.
 */
#define D3D_HARDWARE
#define DDPUSH

/* 
 * NV Reference Manual register access definitions.
 */
#define BIT(b)                  (1<<(b))
#define DEVICE_BASE(d)          (0?d)
#define DEVICE_EXTENT(d)        (1?d)
#define DRF_SHIFT(drf)          ((0?drf) % 32)
#define DRF_MASK(drf)           (0xFFFFFFFF>>(31-((1?drf) % 32)+((0?drf) % 32)))
#define DRF_DEF(d,r,f,c)        ((NV ## d ## r ## f ## c)<<DRF_SHIFT(NV ## d ## r ## f))
#define DRF_NUM(d,r,f,n)        (((n)&DRF_MASK(NV ## d ## r ## f))<<DRF_SHIFT(NV ## d ## r ## f))
#define DRF_VAL(d,r,f,v)        (((v)>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))
#define REG_WR_DRF_NUM(d,r,f,n) REG_WR32(NV ## d ## r, DRF_NUM(d,r,f,n))
#define REG_WR_DRF_DEF(d,r,f,c) REG_WR32(NV ## d ## r, DRF_DEF(d,r,f,c))
#define FLD_WR_DRF_NUM(d,r,f,n) REG_WR32(NV##d##r,(REG_RD32(NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define FLD_WR_DRF_DEF(d,r,f,c) REG_WR32(NV##d##r,(REG_RD32(NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define REG_RD_DRF(d,r,f)       (((REG_RD32(NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

/*
 * Fast floating point operations.
 */
#define nvFloor(fp,fretval)                             \
{                                                       \
    int fpbits;                                         \
    int expo;                                           \
                                                        \
    if (fp < 0.0f) fp -= 0.9999999f;                    \
    fpbits = *(int *)&fp;                               \
    if ((fpbits >= 0) && (fpbits < 0x3F800000)) {       \
        fretval = 0.0f;                                 \
    }                                                   \
    else {                                              \
        expo = 150 - ((fpbits >> 23) & 0xFF);           \
        if (expo < 1) {                                 \
            fretval = fp;                               \
        }                                               \
        else {                                          \
            fpbits &= 0xFFFFFFFF << expo;               \
            fretval = *(float *)&fpbits;                \
        }                                               \
    }                                                   \
}

/*
 * Number of DWORDS the push macros set.
 */
#define sizeSetSurfaceDmaPush   0
#define sizeSetZBufferDmaPush   0
#define sizeSetHeaderDmaPush    0

/*
 * --------------------------------------------------------------------------
 *  Define some handy macros.
 * --------------------------------------------------------------------------
 */

#ifdef  NVD3D_DX6
#define NEXTINSTRUCTION(ptr, type, num, extrabytes)                             \
    ptr = (LPD3DHAL_DP2COMMAND)((LPBYTE)ptr + sizeof(D3DHAL_DP2COMMAND) +       \
                                ((num) * sizeof(type)) + (extrabytes))

#define NEXTINSTRUCTION_S(ptr, typesize, num, extrabytes)                       \
    ptr = (LPD3DHAL_DP2COMMAND)((LPBYTE)ptr + sizeof(D3DHAL_DP2COMMAND) +       \
                                ((num) * (typesize)) + (extrabytes))

#define GET_FVF_POINTER(ptr, lpvert, mask, offset, index, stride)               \
    (ptr) = (DWORD)((((DWORD)(lpvert) + ((index) * (stride))) & (DWORD)(mask))  \
          + (offset));
#endif  // NVD3D_DX6

/*
 * Function index calculation
 *      4 fog modes - straight, supersampled, edgeAA (only for non-alphablended)
 */
#ifndef NV_FASTLOOPS
#ifdef FLOAT_W
#define _CALC_FUNCTION_INDEX(_ctx_ptr)                                                              \
                                   ((_ctx_ptr)->dwRenderState[D3DRENDERSTATE_FOGENABLE]             \
                                 ?  (_ctx_ptr)->dwRenderState[D3DRENDERSTATE_FOGTABLEMODE]          \
                                 :  0)
#else // fixed w
#define _CALC_FUNCTION_INDEX(_ctx_ptr)                                                              \
                                  (((_ctx_ptr)->dwRenderState[D3DRENDERSTATE_FOGENABLE]             \
                                 ?  (_ctx_ptr)->dwRenderState[D3DRENDERSTATE_FOGTABLEMODE]          \
                                 :  0)                                                              \
                                | (((_ctx_ptr)->dwRenderState[D3DRENDERSTATE_ZENABLE] == D3DZB_USEW)\
                                 ?  4                                                               \
                                 :  0))
#endif // fixed w
#define CALC_FUNCTION_INDEX(_ctx_ptr)                                                       \
{                                                                                           \
    (_ctx_ptr)->dwFunctionLookup = ((_ctx_ptr)->dwAntiAliasFlags & AA_ENABLED_MASK)         \
                                 ? NV_AA_FUNCTION_INDEX                                     \
                                 : (_CALC_FUNCTION_INDEX(_ctx_ptr));                        \
}
#else //NV_FASTLOOPS
/*
// basic flags
#define FIFLAG_FOGMODE          0x00000003
#define FIFLAG_INDEXED          0x00000004
#define FIFLAG_FVF              0x00000008
#define FIFLAG_DX6              0x00000010
#define FIFLAG_MMX              0x00000020
#define FIFLAG_MAXIMUM          0x0000003f

// flag macros
#define MODFLAGS_DX5(x)             (((x) & (FIFLAG_FOGMODE)))
#define MODFLAGS_DX5FVF(x)          (((x) & (FIFLAG_FOGMODE)) | (FIFLAG_FVF))
#define MODFLAGS_DX5INDEXED(x)      (((x) & (FIFLAG_FOGMODE)) | (FIFLAG_INDEXED))
#define MODFLAGS_DX5FVFINDEXED(x)   (((x) & (FIFLAG_FOGMODE)) | (FIFLAG_FVF | FIFLAG_INDEXED))

// aa not included
#define _CALC_FUNCTION_INDEX(_ctx,_indices,_storage)                    \
        (((_ctx)->dwRenderState[D3DRENDERSTATE_FOGENABLE] ? (_ctx)->dwRenderState[D3DRENDERSTATE_FOGTABLEMODE] : 0)\
       | ((_inidices) ? FIFLAG_INDEXED : 0)                             \
       | ((fxfData.dwVertexType == D3DFVF_TLVERTEX) ? 0 : FIFLAG_FVF)   \
       | ((_ctx)->bUseDX6Class ? (FIFLAG_DX6 | FIFLAG_FVF) : 0)         \
       | (global.bIsMMX ? FIFLAG_MMX : 0))

// aa included
#define CALC_FUNCTION_INDEX(_ctx,_indices,_storage)              \
{                                                                \
    (_storage)  = ((_ctx)->dwAntiAliasFlags & AA_ENABLED_MASK)   \
                ? NV_AA_FUNCTION_INDEX                           \
                : _CALC_FUNCTION_INDEX(_ctx,_indices,_storage);  \
}
// code creation code
#define LOAD_FUNCTION_INDEX(_funcIndex)                                 \
{                                                                       \
    if (!fnDrawPrimitiveTabel[_funcIndex])                              \
        fnDrawPrimitiveTabel[_funcIndex] = ILCCompileCode(_funcIndex);  \
}
*/
#endif //NV_FASTLOOPS

/*
 * Need to make sure that an unfriendly mode switch didn't sneak and not cause
 * us to get re-enabled properly.
 */
#define DOS_FULLSCREEN_CHECK(pp)

/*
 * Set up all the current context state per call.  This should be as efficient as
 * possible as it is executed for every rendering entrypoint.
 */
#define SET_CURRENT_CONTEXT(pp)                                                 \
{                                                                               \
    if (!(pCurrentContext = (PNVD3DCONTEXT)(pp)->dwhContext))                   \
    {                                                                           \
        DPF("D3D: - Bad Context");                                              \
        (pp)->ddrval = D3DHAL_CONTEXT_BAD;                                      \
        return (DDHAL_DRIVER_HANDLED);                                          \
    }                                                                           \
    if (!pCurrentContext->lpLcl)                                                \
    {                                                                           \
        (pp)->ddrval = D3DHAL_CONTEXT_BAD;                                      \
        return (DDHAL_DRIVER_HANDLED);                                          \
    }                                                                           \
}

/*
 * Macro for fog table calculation. (others are elsewhere, should consolidate).
 */
#define FP_NORM_TO_BIT24(i,p)                                                \
{                                                                            \
    float _n = (p) + 1.0f;                                                   \
    (i) = *(int *)&_n;                                                       \
    if ((i) >= 0x40000000)     (i) = 0xFF000000;                             \
    else if ((i) <=0x3F800000) (i) = 0;                                      \
    else (i) = ((i) << 9) & 0xFF000000;                                      \
}

/*
 * Some cool macros for use during texture swizzling.
 */

// the goal here is to interleave bits (pushing all higher order
// bits to the left as we go) until the texture width exceeds the
// height. at that point, we treat square chunks of the texture as 
// swizzled 'blocks' that are indexed linearly by the higher order
// bits above those that are interleaved. (thus, we freeze the value
// of 'shift' when bit == h) 
 
#define U_INTERLEAVE(u,uu,w,h)                              \
{                                                           \
    int bit,shift;                                          \
    u = 0;                                                  \
    if (uu != 0)                                            \
    {                                                       \
        shift = 0;                                          \
        for (bit = 1; bit < (int)(w); bit <<= 1)            \
        {                                                   \
            u |= (uu & bit) << shift;                       \
            if (bit < (int)(h)) shift++;                    \
        }                                                   \
    }                                                       \
}
#define U_UNINTERLEAVE(u,uu,w,h)                            \
{                                                           \
    int bit, shift;                                         \
    u = 0;                                                  \
    shift = 0;                                              \
    for (bit = 1; bit < (int)(w); bit << = 1)               \
    {                                                       \
        u |= (uu >> shift) & bit;                           \
        if (bit < (int)(h)) shift++;                        \
    }                                                       \
}
#define V_INTERLEAVE(v,vv,w,h)                              \
{                                                           \
    int bit,shift;                                          \
    v = 0;                                                  \
    if (vv != 0)                                            \
    {                                                       \
        shift = 0;                                          \
        for (bit = 1; bit < (int)(h); bit <<= 1)            \
        {                                                   \
            if (bit < (int)(w)) shift++;                    \
            v |= (vv & bit) << shift;                       \
        }                                                   \
    }                                                       \
}
#define V_UNINTERLEAVE(v,vv,w,h)                            \
{                                                           \
    int bit,shift;                                          \
    v = 0;                                                  \
    shift = 0;                                              \
    for (bit = 1; bit < (int)(h); bit <<= 1)                \
    {                                                       \
        if (bit < (int)(w)) shift++;                        \
        v |= (vv >> shift) & bit;                           \
    }                                                       \
}
#define U_INC_MASK(i,m,h)                                   \
{                                                           \
    int logh;                                               \
    int hh = (int)(h) - 1;                                  \
    for (logh = 0; hh != 0; hh >>= 1, logh++);              \
    m = ((1 << (2 * logh)) - 1);                            \
    i = (0xAAAAAAAA & m) + 1;                               \
    m = (0x55555555 & m) | (~m);                            \
}
#define U_INC2_MASK(i1,i2,m,h)                              \
{                                                           \
    int logh;                                               \
    int hh = (int)(h) - 1;                                  \
    for (logh = 0; hh != 0; hh >>= 1,logh++);               \
    m = ((1 << (2 * logh)) - 1);                            \
    i1 = (0xAAAAAAAA & m) + 1;                              \
    i2 = (0xAAAAAAAA & m) + 2;                              \
    m = (0x55555555 & m) | (~m);                            \
}
#define V_INC_MASK(i,m,w)                                   \
{                                                           \
    int logw;                                               \
    int ww = (int)(w) - 1;                                  \
    for (logw = 0; ww != 0; ww >>= 1, logw++);              \
    m = ((1 << (2 * logw)) - 1);                            \
    i = (0x55555555 & m) + 1;                               \
    m = (0xAAAAAAAA & m) | (~m);                            \
}
#define UV_INC(uv,i,m)      (((uv) + i) & m)
#define UV_OFFSET(uu,vv)    ((uu) | (vv))

/*
 *
 */
#define NV_D3D_GLOBAL_SETUP()                                               \
{                                                                           \
    nvDmaPushBase      = pDriverData->NvDmaPusherBufferBase;                \
    nvDmaPushOffsetMax = pDriverData->dwDmaPushOffsetMax;                   \
    nvFifo             = pDriverData->NvDmaPusherPutAddress;                \
    if (pDriverData->TwoDRenderingOccurred)                                 \
        nvDmaLastPutAddr = nvFifo;                                          \
}
#define NV_D3D_GLOBAL_SAVE()                                                \
{                                                                           \
    pDriverData->NvDmaPusherPutAddress = nvFifo;                            \
}

#define NV_D3D_CONTEXT_SETUP()                                              \
{                                                                           \
}

#if D3D_PUSH
/*
 * Hardware connection macros.
 */
#ifdef  D3D_HARDWARE
#define nvglOpenChannel(handle, address, size, fifo)                        \
{                                                                           \
    if (pDriverData->GARTLinearBase > 0)                                    \
    {                                                                       \
        (handle) = (DWORD)AllocAGPHeap(pCurrentContext->lpLcl->lpGbl->lpDD, size); \
        (address) = (handle);                                               \
    }                                                                       \
    else                                                                    \
    {                                                                       \
        (handle)  = (DWORD)HeapCreate(HEAP_SHARED, (size), 0);              \
        (address) = (DWORD)HeapAlloc((HANDLE)(handle), HEAP_ZERO_MEMORY, (size)); \
    }                                                                       \
    (fifo)    = NvOpenDma(0, NvGetFlatDataSelector(), (int)(address), (int)((size) - 1)); \
}
#define nvglCloseChannel(handle, address, fifo)                             \
{                                                                           \
    NvClose((NvChannel *)(fifo));                                           \
    if (pDriverData->GARTLinearBase > 0)                                    \
    {                                                                       \
        FreeAGPHeap(pCurrentContext->lpLcl->lpGbl->lpDD, (handle));         \
    }                                                                       \
    else                                                                    \
    {                                                                       \
        HeapFree((HANDLE)(handle), 0, (PVOID)(address));                    \
        HeapDestroy((HANDLE)(handle));                                      \
    }                                                                       \
    (fifo)    = 0;                                                          \
    (handle)  = (DWORD)0;                                                   \
    (address) = (DWORD)0;                                                   \
}
#else   // D3D_EMULATION
#define nvglOpenChannel(handle, address, size, fifo)                        \
{                                                                           \
    (handle)  = (DWORD)HeapCreate(HEAP_SHARED, (size), 0);                  \
    (address) = (DWORD)HeapAlloc((HANDLE)(handle), HEAP_ZERO_MEMORY, (size)); \
    (fifo)    = 0;                                                          \
}
#define nvglCloseChannel(handle, address, fifo)                             \
{                                                                           \
    HeapFree((HANDLE)(handle), 0, (PVOID)(address));                        \
    HeapDestroy((HANDLE)(handle));                                          \
    (fifo)    = 0;                                                          \
    (handle)  = (DWORD)0;                                                   \
    (address) = (DWORD)0;                                                   \
}
#endif  // D3D_EMULATION

/*
 * DMA Pusher macros
 */
#define nvglGetFreeCount(fifo, freecount, ch, size)                         \
    (freecount) = nvGetDmaFreeCount((long)(size));

#define sizeSetObject                       2
#define nvglSetObject(fifo, freecount, ch, obj)                             \
{                                                                           \
    ((DWORD *)(fifo))[0] = (0x00040000 | ((ch) << 13));                     \
    ((DWORD *)(fifo))[1] = obj;                                             \
    (DWORD *)(fifo) += sizeSetObject;                                       \
    freecount -= sizeSetObject;                                             \
}
#define sizeSetStartMethod                  1
#define nvglSetStartMethod(fifo, freecount, ch, method, methodcount)        \
{                                                                           \
    ((DWORD *)(fifo))[0] = ((((methodcount) << 2) << 16) | ((ch) << 13) | (method)); \
    (DWORD *)(fifo) += sizeSetStartMethod;                                  \
    freecount -= sizeSetStartMethod;                                        \
}
#define sizeSetData                         1
#define nvglSetData(fifo, freecount, data)                                  \
{                                                                           \
    ((DWORD *)(fifo))[0] = (data);                                          \
    (DWORD *)(fifo) += sizeSetData;                                         \
    freecount -= sizeSetData;                                               \
}

/*
 * Create Object macro.
 */
#define sizeCreateObjectMthdCnt             1
#define sizeCreateObject                    2
#define nvglCreateObject(fifo, freecount, ch, obj)                          \
{                                                                           \
    ((DWORD *)(fifo))[0] = NVFFF_CREATE((ch)) | ((sizeCreateObjectMthdCnt << 2) << 16); \
    ((DWORD *)(fifo))[1] = (obj);                                           \
    (DWORD *)(fifo) += sizeCreateObject;                                    \
    freecount -= sizeCreateObject;                                          \
}

/*
 * Destroy Object macro.
 */
#define sizeDestroyObjectMthdCnt            1
#define sizeDestroyObject                   2
#define nvglDestroyObject(fifo, freecount, ch, obj)                         \
{                                                                           \
    ((DWORD *)(fifo))[0] = NVFFF_DESTROY((ch)) | ((sizeDestroyObjectMthdCnt << 2) << 16); \
    ((DWORD *)(fifo))[1] = (obj);                                           \
    (DWORD *)(fifo) += sizeDestroyObject;                                   \
    freecount -= sizeDestroyObject;                                         \
}

/*
 * Define DX5 Triangle class macros.
 */
#define sizeSetDx5TriangleContextsMthdCnt   2
#define sizeSetDx5TriangleContexts          3
#define nvglSetDx5TriangleContexts(fifo, freecount, ch, ctxa, ctxb)         \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSetDx5TriangleContextsMthdCnt << 2) << 16) | ((ch) << 13) | NV054_SET_CONTEXT_DMA_A); \
    ((DWORD *)(fifo))[1] = (ctxa);                                          \
    ((DWORD *)(fifo))[2] = (ctxb);                                          \
    (DWORD *)(fifo) += sizeSetDx5TriangleContexts;                          \
    freecount -= sizeSetDx5TriangleContexts;                                \
}
#define sizeSetDx5TriangleSurfaceMthdCnt    1
#define sizeSetDx5TriangleSurface           2
#define nvglSetDx5TriangleSurface(fifo, freecount, ch, ctxs)                \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSetDx5TriangleSurfaceMthdCnt << 2) << 16) | ((ch) << 13) | NV054_SET_CONTEXT_SURFACES); \
    ((DWORD *)(fifo))[1] = (ctxs);                                          \
    (DWORD *)(fifo) += sizeSetDx5TriangleSurface;                           \
    freecount -= sizeSetDx5TriangleSurface;                                 \
}
#define sizeDx5TriangleStateMthdCnt         7
#define sizeDx5TriangleState                8
#define nvglDx5TriangleState(fifo, freecount, ch,                           \
                             ckey, offset, format, filter,                  \
                             blend, control, fogcolor)                      \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeDx5TriangleStateMthdCnt << 2) << 16) | ((ch) << 13) | NV054_COLOR_KEY); \
    ((DWORD *)(fifo))[1] = (ckey);                                          \
    ((DWORD *)(fifo))[2] = (offset);                                        \
    ((DWORD *)(fifo))[3] = (format);                                        \
    ((DWORD *)(fifo))[4] = (filter);                                        \
    ((DWORD *)(fifo))[5] = (blend);                                         \
    ((DWORD *)(fifo))[6] = (control);                                       \
    ((DWORD *)(fifo))[7] = (fogcolor);                                      \
    (DWORD *)(fifo) += sizeDx5TriangleState;                                \
    freecount -= sizeDx5TriangleState;                                      \
}

/*
 * Unused Vertex Macros - good reference
 */
/*
#define sizeDx5TriangleTLVertexMthdCnt      8
#define sizeDx5TriangleTLVertex             9
#define nvglDx5TriangleTLVertex(fifo, freecount, ch, alias, vd)             \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeDx5TriangleTLVertexMthdCnt << 2) << 16) | ((ch) << 13) | NV054_TLVERTEX((alias))); \
    ((DWORD *)(fifo))[1] = *(U032 *)&(vd.sx);                               \
    ((DWORD *)(fifo))[2] = *(U032 *)&(vd.sy);                               \
    ((DWORD *)(fifo))[3] = *(U032 *)&(vd.sz);                               \
    ((DWORD *)(fifo))[4] = *(U032 *)&(vd.rhw);                              \
    ((DWORD *)(fifo))[5] = (vd.color);                                      \
    ((DWORD *)(fifo))[6] = (vd.specular);                                   \
    ((DWORD *)(fifo))[7] = *(U032 *)&(vd.tu);                               \
    ((DWORD *)(fifo))[8] = *(U032 *)&(vd.tv);                               \
    (DWORD *)(fifo) += sizeDx5TriangleTLVertex;                             \
    freecount -= sizeDx5TriangleTLVertex;                                   \
    dbgDisplayVertexData(*(DWORD *)&(vd.sx),  *(DWORD *)&(vd.sy),  *(DWORD *)&(vd.sz),  \
                         *(DWORD *)&(vd.rhw),  (DWORD)vd.color,     (DWORD)vd.specular, \
                         *(DWORD *)&(vd.tu),  *(DWORD *)&(vd.tv));                      \
}
#define nvglDx5TriangleTLVertexExpFog(fifo, freecount, ch, alias, vd)       \
{                                                                           \
    float ffog, z;                                                          \
    int   ifog, specular;                                                   \
    specular  = (vd.specular) & 0x00FFFFFF;                                 \
    FP_INV(z, (vd.rhw));                                                    \
    ffog  = z * pCurrentContext->fFogTableDensity;                          \
    FP_EXP(ffog, ffog);                                                     \
    FP_NORM_TO_BIT24(ifog, ffog);                                           \
    specular |= ifog;                                                       \
    ((DWORD *)(fifo))[0] = (((sizeDx5TriangleTLVertexMthdCnt << 2) << 16) | ((ch) << 13) | NV054_TLVERTEX((alias))); \
    ((DWORD *)(fifo))[1] = *(U032 *)&(vd.sx);                               \
    ((DWORD *)(fifo))[2] = *(U032 *)&(vd.sy);                               \
    ((DWORD *)(fifo))[3] = *(U032 *)&(vd.sz);                               \
    ((DWORD *)(fifo))[4] = *(U032 *)&(vd.rhw);                              \
    ((DWORD *)(fifo))[5] = (vd.color);                                      \
    ((DWORD *)(fifo))[6] = specular;                                        \
    ((DWORD *)(fifo))[7] = *(U032 *)&(vd.tu);                               \
    ((DWORD *)(fifo))[8] = *(U032 *)&(vd.tv);                               \
    (DWORD *)(fifo) += sizeDx5TriangleTLVertex;                             \
    freecount -= sizeDx5TriangleTLVertex;                                   \
    dbgDisplayVertexData(*(DWORD *)&(vd.sx),  *(DWORD *)&(vd.sy),  *(DWORD *)&(vd.sz),  \
                         *(DWORD *)&(vd.rhw),  (DWORD)vd.color,     (DWORD)vd.specular, \
                         *(DWORD *)&(vd.tu),  *(DWORD *)&(vd.tv));                      \
}
#define nvglDx5TriangleTLVertexExp2Fog(fifo, freecount, ch, alias, vd)      \
{                                                                           \
    float ffog, z;                                                          \
    int   ifog, specular;                                                   \
    specular  = (vd.specular) & 0x00FFFFFF;                                 \
    FP_INV(z, (vd.rhw));                                                    \
    ffog  = z * pCurrentContext->fFogTableDensity;                          \
    ffog *= ffog;                                                           \
    FP_EXP(ffog, ffog);                                                     \
    FP_NORM_TO_BIT24(ifog, ffog);                                           \
    specular |= ifog;                                                       \
    ((DWORD *)(fifo))[0] = (((sizeDx5TriangleTLVertexMthdCnt << 2) << 16) | ((ch) << 13) | NV054_TLVERTEX((alias))); \
    ((DWORD *)(fifo))[1] = *(U032 *)&(vd.sx);                               \
    ((DWORD *)(fifo))[2] = *(U032 *)&(vd.sy);                               \
    ((DWORD *)(fifo))[3] = *(U032 *)&(vd.sz);                               \
    ((DWORD *)(fifo))[4] = *(U032 *)&(vd.rhw);                              \
    ((DWORD *)(fifo))[5] = (vd.color);                                      \
    ((DWORD *)(fifo))[6] = specular;                                        \
    ((DWORD *)(fifo))[7] = *(U032 *)&(vd.tu);                               \
    ((DWORD *)(fifo))[8] = *(U032 *)&(vd.tv);                               \
    (DWORD *)(fifo) += sizeDx5TriangleTLVertex;                             \
    freecount -= sizeDx5TriangleTLVertex;                                   \
    dbgDisplayVertexData(*(DWORD *)&(vd.sx),  *(DWORD *)&(vd.sy),  *(DWORD *)&(vd.sz),  \
                         *(DWORD *)&(vd.rhw),  (DWORD)vd.color,     (DWORD)vd.specular, \
                         *(DWORD *)&(vd.tu),  *(DWORD *)&(vd.tv));                      \
}
#define nvglDx5TriangleTLVertexLinearFog(fifo, freecount, ch, alias, vd)    \
{                                                                           \
    float ffog, z;                                                          \
    int   ifog, specular;                                                   \
    specular  = (vd.specular) & 0x00FFFFFF;                                 \
    FP_INV(z, (vd.rhw));                                                    \
    ffog = (pCurrentContext->fFogTableEnd - z) * pCurrentContext->fFogTableLinearScale; \
    FP_NORM_TO_BIT24(ifog, ffog);                                           \
    specular |= ifog;                                                       \
    ((DWORD *)(fifo))[0] = (((sizeDx5TriangleTLVertexMthdCnt << 2) << 16) | ((ch) << 13) | NV054_TLVERTEX((alias))); \
    ((DWORD *)(fifo))[1] = *(U032 *)&(vd.sx);                               \
    ((DWORD *)(fifo))[2] = *(U032 *)&(vd.sy);                               \
    ((DWORD *)(fifo))[3] = *(U032 *)&(vd.sz);                               \
    ((DWORD *)(fifo))[4] = *(U032 *)&(vd.rhw);                              \
    ((DWORD *)(fifo))[5] = (vd.color);                                      \
    ((DWORD *)(fifo))[6] = specular;                                        \
    ((DWORD *)(fifo))[7] = *(U032 *)&(vd.tu);                               \
    ((DWORD *)(fifo))[8] = *(U032 *)&(vd.tv);                               \
    (DWORD *)(fifo) += sizeDx5TriangleTLVertex;                             \
    freecount -= sizeDx5TriangleTLVertex;                                   \
    dbgDisplayVertexData(*(DWORD *)&(vd.sx),  *(DWORD *)&(vd.sy),  *(DWORD *)&(vd.sz),  \
                         *(DWORD *)&(vd.rhw),  (DWORD)vd.color,     (DWORD)vd.specular, \
                         *(DWORD *)&(vd.tu),  *(DWORD *)&(vd.tv));                      \
}
*/

#define sizeDx5TriangleDrawPrimitiveMthdCnt 1
#define sizeDx5TriangleDrawPrimitive        2
#define nvglDx5TriangleDrawPrimitive(fifo, freecount, ch, alias, vertices)  \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeDx5TriangleDrawPrimitiveMthdCnt << 2) << 16) | ((ch) << 13) | NV054_DRAW_PRIMITIVE((alias))); \
    ((DWORD *)(fifo))[1] = (vertices);                                      \
    (DWORD *)(fifo) += sizeDx5TriangleDrawPrimitive;                        \
    freecount -= sizeDx5TriangleDrawPrimitive;                              \
}
#define sizeDx5TriangleNotify               4
#define nvglDx5TriangleNotify(fifo, freecount, ch)                          \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((1 << 2) << 16) | ((ch) << 13) | NV054_NOTIFY);\
    ((DWORD *)(fifo))[1] = NV054_NOTIFY_WRITE_ONLY;                         \
    ((DWORD *)(fifo))[2] = (((1 << 2) << 16) | ((ch) << 13) | NV054_NO_OPERATION); \
    ((DWORD *)(fifo))[3] = 0x00000000;                                      \
    (DWORD *)(fifo) += sizeDx5TriangleNotify;                               \
    freecount -= sizeDx5TriangleNotify;                                     \
}

/*
 * Define DX6 Triangle class macros.
 */
#define sizeSetDx6TriangleContextsMthdCnt   2
#define sizeSetDx6TriangleContexts          3
#define nvglSetDx6TriangleContexts(fifo, freecount, ch, ctxa, ctxb)         \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSetDx6TriangleContextsMthdCnt << 2) << 16) | ((ch) << 13) | NV055_SET_CONTEXT_DMA_A); \
    ((DWORD *)(fifo))[1] = (ctxa);                                          \
    ((DWORD *)(fifo))[2] = (ctxb);                                          \
    (DWORD *)(fifo) += sizeSetDx6TriangleContexts;                          \
    freecount -= sizeSetDx6TriangleContexts;                                \
}
#define sizeSetDx6TriangleSurfaceMthdCnt    1
#define sizeSetDx6TriangleSurface           2
#define nvglSetDx6TriangleSurface(fifo, freecount, ch, ctxs)                \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSetDx6TriangleSurfaceMthdCnt << 2) << 16) | ((ch) << 13) | NV055_SET_CONTEXT_SURFACES); \
    ((DWORD *)(fifo))[1] = (ctxs);                                          \
    (DWORD *)(fifo) += sizeSetDx6TriangleSurface;                           \
    freecount -= sizeSetDx6TriangleSurface;                                 \
}
#define sizeDx6TriangleOffsetMthdCnt        1
#define sizeDx6TriangleOffset               2
#define nvglDx6TriangleOffset(fifo, freecount, ch,                          \
                              offset, buffer)                               \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeDx6TriangleOffsetMthdCnt << 2) << 16) | ((ch) << 13) | NV055_OFFSET(buffer)); \
    ((DWORD *)(fifo))[1] = (offset);                                        \
    (DWORD *)(fifo) += sizeDx6TriangleOffset;                               \
    freecount -= sizeDx6TriangleOffset;                                     \
}
#define sizeDx6TriangleFormatMthdCnt        1
#define sizeDx6TriangleFormat               2
#define nvglDx6TriangleFormat(fifo, freecount, ch,                          \
                              format, buffer)                               \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeDx6TriangleFormatMthdCnt << 2) << 16) | ((ch) << 13) | NV055_FORMAT(buffer)); \
    ((DWORD *)(fifo))[1] = (format);                                        \
    (DWORD *)(fifo) += sizeDx6TriangleFormat;                               \
    freecount -= sizeDx6TriangleFormat;                                     \
}
#define sizeDx6TriangleFilterMthdCnt        1
#define sizeDx6TriangleFilter               2
#define nvglDx6TriangleFilter(fifo, freecount, ch,                          \
                              filter, buffer)                               \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeDx6TriangleFilterMthdCnt << 2) << 16) | ((ch) << 13) | NV055_FILTER(buffer)); \
    ((DWORD *)(fifo))[1] = (filter);                                        \
    (DWORD *)(fifo) += sizeDx6TriangleFilter;                               \
    freecount -= sizeDx6TriangleFilter;                                     \
}
#define sizeDx6TriangleStageState           12
#define nvglDx6TriangleStageState(fifo, freecount, ch,                      \
                                  c0alpha, c0color, c1alpha, c1color,       \
                                  factor, blend,                            \
                                  control0, control1, control2,             \
                                  fogcolor)                                 \
{                                                                           \
    ((DWORD *)(fifo))[0]  = (((2 << 2) << 16) | ((ch) << 13) | NV055_COMBINE_0_ALPHA); \
    ((DWORD *)(fifo))[1]  = (c0alpha);                                      \
    ((DWORD *)(fifo))[2]  = (c0color);                                      \
    ((DWORD *)(fifo))[3]  = (((8 << 2) << 16) | ((ch) << 13) | NV055_COMBINE_1_ALPHA); \
    ((DWORD *)(fifo))[4]  = (c1alpha);                                      \
    ((DWORD *)(fifo))[5]  = (c1color);                                      \
    ((DWORD *)(fifo))[6]  = (factor);                                       \
    ((DWORD *)(fifo))[7]  = (blend);                                        \
    ((DWORD *)(fifo))[8]  = (control0);                                     \
    ((DWORD *)(fifo))[9]  = (control1);                                     \
    ((DWORD *)(fifo))[10] = (control2);                                     \
    ((DWORD *)(fifo))[11] = (fogcolor);                                     \
    (DWORD *)(fifo) += sizeDx6TriangleStageState;                           \
    freecount -= sizeDx6TriangleStageState;                                 \
}
#define sizeDX6TriangleState    (((sizeDx6TriangleOffset + sizeDx6TriangleFormat + sizeDx6TriangleFilter) * 2) + sizeDx6TriangleStageState)

#define sizeDx6TriangleTLVertexMthdCnt      10
#define sizeDx6TriangleTLVertex1            11
#define nvglDx6TriangleTLVertex(fifo, freecount, ch, alias, vd)             \
{                                                                           \
    ((DWORD *)(fifo))[0]  = (((sizeDx6TriangleTLVertexMthdCnt << 2) << 16) | ((ch) << 13) | NV055_TLMTVERTEX((alias))); \
    ((DWORD *)(fifo))[1]  = *(U032 *)&(vd.sx);                              \
    ((DWORD *)(fifo))[2]  = *(U032 *)&(vd.sy);                              \
    ((DWORD *)(fifo))[3]  = *(U032 *)&(vd.sz);                              \
    ((DWORD *)(fifo))[4]  = *(U032 *)&(vd.rhw);                             \
    ((DWORD *)(fifo))[5]  = (vd.color);                                     \
    ((DWORD *)(fifo))[6]  = (vd.specular);                                  \
    ((DWORD *)(fifo))[7]  = *(U032 *)&(vd.tu);                              \
    ((DWORD *)(fifo))[8]  = *(U032 *)&(vd.tv);                              \
    ((DWORD *)(fifo))[9]  = 0;                                              \
    ((DWORD *)(fifo))[10] = 0;                                              \
    (DWORD *)(fifo) += sizeDx6TriangleTLVertex1;                            \
    freecount -= sizeDx6TriangleTLVertex1;                                  \
    dbgDisplayVertexData(*(DWORD *)&(vd.sx),  *(DWORD *)&(vd.sy),  *(DWORD *)&(vd.sz),  \
                         *(DWORD *)&(vd.rhw),  (DWORD)vd.color,     (DWORD)vd.specular, \
                         *(DWORD *)&(vd.tu),  *(DWORD *)&(vd.tv));          \
}

#define sizeDx6TriangleDrawPrimitiveMthdCnt 1
#define sizeDx6TriangleDrawPrimitive        2
#define nvglDx6TriangleDrawPrimitive(fifo, freecount, ch, alias, vertices)  \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeDx6TriangleDrawPrimitiveMthdCnt << 2) << 16) | ((ch) << 13) | NV055_DRAW_PRIMITIVE((alias))); \
    ((DWORD *)(fifo))[1] = (vertices);                                      \
    (DWORD *)(fifo) += sizeDx6TriangleDrawPrimitive;                        \
    freecount -= sizeDx6TriangleDrawPrimitive;                              \
}

/*
 * Define NV4 Render Solid Rectangle class macros.
 */
#define sizeSetNv4SolidRectangleSurfaceMthdCnt  1
#define sizeSetNv4SolidRectangleSurface         2
#define nvglSetNv4SolidRectangleSurface(fifo, freecount, ch, ctx)           \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSetNv4SolidRectangleSurfaceMthdCnt << 2) << 16) | ((ch) << 13) | NV05E_SET_CONTEXT_SURFACE); \
    ((DWORD *)(fifo))[1] = (ctx);                                           \
    (DWORD *)(fifo) += sizeSetNv4SolidRectangleSurface;                     \
    freecount -= sizeSetNv4SolidRectangleSurface;                           \
}

#define sizeSetNv4SolidRectangleOperationMthdCnt    1
#define sizeSetNv4SolidRectangleOperation           2
#define nvglSetNv4SolidRectangleOperation(fifo, freecount, ch, op)          \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSetNv4SolidRectangleOperationMthdCnt << 2) << 16) | ((ch) << 13) | NV05E_SET_OPERATION); \
    ((DWORD *)(fifo))[1] = (op);                                            \
    (DWORD *)(fifo) += sizeSetNv4SolidRectangleOperation;                   \
    freecount -= sizeSetNv4SolidRectangleOperation;                         \
}

#define sizeSetNv4SolidRectangleColorFormatMthdCnt  1
#define sizeSetNv4SolidRectangleColorFormat         2
#define nvglSetNv4SolidRectangleColorFormat(fifo, freecount, ch, cfmt)      \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSetNv4SolidRectangleColorFormatMthdCnt << 2) << 16) | ((ch) << 13) | NV05E_SET_COLOR_FORMAT); \
    ((DWORD *)(fifo))[1] = (cfmt);                                          \
    (DWORD *)(fifo) += sizeSetNv4SolidRectangleColorFormat;                 \
    freecount -= sizeSetNv4SolidRectangleColorFormat;                       \
}

#define sizeNv4SolidRectangleColorMthdCnt           1
#define sizeNv4SolidRectangleColor                  2
#define nvglNv4SolidRectangleColor(fifo, freecount, ch, color)              \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeNv4SolidRectangleColorMthdCnt << 2) << 16) | ((ch) << 13) | NV05E_COLOR); \
    ((DWORD *)(fifo))[1] = (color);                                         \
    (DWORD *)(fifo) += sizeNv4SolidRectangleColor;                          \
    freecount -= sizeNv4SolidRectangleColor;                                \
}

#define sizeNv4SolidRectanglePointSizeMthdCnt       2
#define sizeNv4SolidRectanglePointSize              3
#define nvglNv4SolidRectanglePointSize(fifo, freecount, ch,                 \
                                       x, y, width, height)                 \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeNv4SolidRectanglePointSizeMthdCnt << 2) << 16) | ((ch) << 13) | NV05E_RECTANGLE(0)); \
    ((DWORD *)(fifo))[1] = ((((y) & 0x0000FFFF) << 16) | ((x) & 0x0000FFFF)); \
    ((DWORD *)(fifo))[2]  = ((((height) & 0x0000FFFF) << 16) | ((width) & 0x0000FFFF)); \
    (DWORD *)(fifo) += sizeNv4SolidRectanglePointSize;                      \
    freecount -= sizeNv4SolidRectanglePointSize;                            \
}

/*
 * Define Context Surfaces ARGB Zeta/Stencil macros.
 */
#define sizeSetRenderTargetContextsMthdCnt  2
#define sizeSetRenderTargetContexts         3
#define nvglSetRenderTargetContexts(fifo, freecount, ch,                    \
                                    ctxdmacolor, ctxdmazeta)                \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSetRenderTargetContextsMthdCnt << 2) << 16) | ((ch) << 13) | NV053_SET_CONTEXT_DMA_COLOR); \
    ((DWORD *)(fifo))[1] = (ctxdmacolor);                                   \
    ((DWORD *)(fifo))[2] = (ctxdmazeta);                                    \
    (DWORD *)(fifo) += sizeSetRenderTargetContexts;                         \
    freecount -= sizeSetRenderTargetContexts;                               \
}

#define sizeSetRenderTarget                 8
#define nvglSetRenderTarget(fifo, freecount, ch,                            \
                            cliphorizontal, clipvertical, format, pitch,    \
                            coloroffset, zetaoffset)                        \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((3 << 2) << 16) | ((ch) << 13) | NV053_SET_CLIP_HORIZONTAL); \
    ((DWORD *)(fifo))[1] = (cliphorizontal);                                \
    ((DWORD *)(fifo))[2] = (clipvertical);                                  \
    ((DWORD *)(fifo))[3] = (format);                                        \
    ((DWORD *)(fifo))[4] = (((3 << 2) << 16) | ((ch) << 13) | NV053_SET_PITCH); \
    ((DWORD *)(fifo))[5] = (pitch);                                         \
    ((DWORD *)(fifo))[6] = (coloroffset);                                   \
    ((DWORD *)(fifo))[7] = (zetaoffset);                                    \
    (DWORD *)(fifo) += sizeSetRenderTarget;                                 \
    freecount -= sizeSetRenderTarget;                                       \
}

#define sizeSetRenderTarget2MthdCnt         5
#define sizeSetRenderTarget2                6
#define nvglSetRenderTarget2(fifo, freecount, ch,                           \
                            format, clipsize, pitch,                        \
                            coloroffset, zetaoffset)                        \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSetRenderTarget2MthdCnt << 2) << 16) | ((ch) << 13) | NV053_SET_FORMAT); \
    ((DWORD *)(fifo))[1] = (format);                                        \
    ((DWORD *)(fifo))[2] = (clipsize);                                      \
    ((DWORD *)(fifo))[3] = (pitch);                                         \
    ((DWORD *)(fifo))[4] = (coloroffset);                                   \
    ((DWORD *)(fifo))[5] = (zetaoffset);                                    \
    (DWORD *)(fifo) += sizeSetRenderTarget2;                                \
    freecount -= sizeSetRenderTarget2;                                      \
}

#define sizeSetRenderTargetViewportMthdCnt  2
#define sizeSetRenderTargetViewport         3
#define nvglSetRenderTargetViewport(fifo, freecount, ch,                    \
                            cliphorizontal, clipvertical)                   \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSetRenderTargetViewportMthdCnt << 2) << 16) | ((ch) << 13) | NV053_SET_CLIP_HORIZONTAL); \
    ((DWORD *)(fifo))[1] = (cliphorizontal);                                \
    ((DWORD *)(fifo))[2] = (clipvertical);                                  \
    (DWORD *)(fifo) += sizeSetRenderTargetViewport;                         \
    freecount -= sizeSetRenderTargetViewport;                               \
}

/*
 * Swizzled surface context setup macros.
 */
#define sizeSetSwizzledSurfaceContextImageMthdCnt   1
#define sizeSetSwizzledSurfaceContextImage          2
#define nvglSetSwizzledSurfaceContextImage(fifo, freecount, ch,             \
                                     ctxdmaimage)                           \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSetSwizzledSurfaceContextImageMthdCnt << 2) << 16) | ((ch) << 13) | NV052_SET_CONTEXT_DMA_IMAGE); \
    ((DWORD *)(fifo))[1] = (ctxdmaimage);                                   \
    (DWORD *)(fifo) += sizeSetSwizzledSurfaceContextImage;                  \
    freecount -= sizeSetSwizzledSurfaceContextImage;                        \
}

#define sizeSetSwizzledSurfaceMthdCnt        2
#define sizeSetSwizzledSurface               3
#define nvglSetSwizzledSurface(fifo, freecount, ch,                         \
                              format, offset)                               \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSetSwizzledSurfaceMthdCnt << 2) << 16) | ((ch) << 13) | NV052_SET_FORMAT); \
    ((DWORD *)(fifo))[1] = (format);                                        \
    ((DWORD *)(fifo))[2] = (offset);                                        \
    (DWORD *)(fifo) += sizeSetSwizzledSurface;                              \
    freecount -= sizeSetSwizzledSurface;                                    \
}

/*
 * Indexed Image from CPU setup macros
 */
#define sizeSetIndexedImageDmaNotifiesMthdCnt           1
#define sizeSetIndexedImageDmaNotifies                  2
#define nvglSetIndexedImageDmaNotifies(fifo, freecount, ch,             \
                                      ctxdmanotify)                     \
{                                                                       \
    ((DWORD *)(fifo))[0] = (((sizeSetIndexedImageDmaNotifiesMthdCnt << 2) << 16) | ((ch) << 13) | NV060_SET_CONTEXT_DMA_NOTIFIES); \
    ((DWORD *)(fifo))[1] = (ctxdmanotify);                              \
    (DWORD *)(fifo) += sizeSetIndexedImageDmaNotifies;                  \
    freecount -= sizeSetIndexedImageDmaNotifies;                        \
}

#define sizeSetIndexedImageContextDmaLUTMthdCnt           1
#define sizeSetIndexedImageContextDmaLUT                  2
#define nvglSetIndexedImageContextDmaLUT(fifo, freecount, ch,           \
                                         handle)                        \
{                                                                       \
    ((DWORD *)(fifo))[0] = (((sizeSetIndexedImageContextDmaLUTMthdCnt << 2) << 16) | ((ch) << 13) | NV060_SET_CONTEXT_DMA_LUT); \
    ((DWORD *)(fifo))[1] = (handle);                                    \
    (DWORD *)(fifo) += sizeSetIndexedImageContextDmaLUT;                \
    freecount -= sizeSetIndexedImageContextDmaLUT;                      \
}

#define sizeSetIndexedImageContextSurfaceMthdCnt        1
#define sizeSetIndexedImageContextSurface               2
#define nvglSetIndexedImageContextSurface(fifo, freecount, ch,          \
                                          surface)                      \
{                                                                       \
    ((DWORD *)(fifo))[0] = (((sizeSetIndexedImageContextSurfaceMthdCnt << 2) << 16) | ((ch) << 13) | NV060_SET_CONTEXT_SURFACE); \
    ((DWORD *)(fifo))[1] = (surface);                                   \
    (DWORD *)(fifo) += sizeSetIndexedImageContextSurface;               \
    freecount -= sizeSetIndexedImageContextSurface;                     \
}

#define sizeSetIndexedImageOperationMthdCnt     1
#define sizeSetIndexedImageOperation            2
#define nvglSetIndexedImageOperation(fifo, freecount, ch,               \
                                     operation)                         \
{                                                                       \
    ((DWORD *)(fifo))[0] = (((sizeSetIndexedImageOperationMthdCnt << 2) << 16) | ((ch) << 13) | NV060_SET_OPERATION); \
    ((DWORD *)(fifo))[1] = (operation);                                 \
    (DWORD *)(fifo) += sizeSetIndexedImageOperation;                    \
    freecount -= sizeSetIndexedImageOperation;                          \
}

#define sizeSetIndexedImageColorFormatMthdCnt   1
#define sizeSetIndexedImageColorFormat          2
#define nvglSetIndexedImageColorFormat(fifo, freecount, ch,             \
                                       colorformat)                     \
{                                                                       \
    ((DWORD *)(fifo))[0] = (((sizeSetIndexedImageColorFormatMthdCnt << 2) << 16) | ((ch) << 13) | NV060_SET_COLOR_FORMAT); \
    ((DWORD *)(fifo))[1] = (colorformat);                               \
    (DWORD *)(fifo) += sizeSetIndexedImageColorFormat;                  \
    freecount -= sizeSetIndexedImageColorFormat;                        \
}

#define sizeSetIndexedImageIndexFormatMthdCnt   1
#define sizeSetIndexedImageIndexFormat          2
#define nvglSetIndexedImageIndexFormat(fifo, freecount, ch,             \
                                       indexformat)                     \
{                                                                       \
    ((DWORD *)(fifo))[0] = (((sizeSetIndexedImageIndexFormatMthdCnt << 2) << 16) | ((ch) << 13) | NV060_INDEX_FORMAT); \
    ((DWORD *)(fifo))[1] = (indexformat);                               \
    (DWORD *)(fifo) += sizeSetIndexedImageIndexFormat;                  \
    freecount -= sizeSetIndexedImageIndexFormat;                        \
}

#define sizeSetIndexedImageLUTOffsetMthdCnt     1
#define sizeSetIndexedImageLUTOffset            2
#define nvglSetIndexedImageLUTOffset(fifo, freecount, ch,               \
                                     offset)                            \
{                                                                       \
    ((DWORD *)(fifo))[0] = (((sizeSetIndexedImageLUTOffsetMthdCnt << 2) << 16) | ((ch) << 13) | NV060_LUT_OFFSET); \
    ((DWORD *)(fifo))[1] = (offset);                                    \
    (DWORD *)(fifo) += sizeSetIndexedImageLUTOffset;                    \
    freecount -= sizeSetIndexedImageLUTOffset;                          \
}

#define sizeSetIndexedImagePointMthdCnt         1
#define sizeSetIndexedImagePoint                2
#define nvglSetIndexedImagePoint(fifo, freecount, ch,                   \
                                 x, y)                                  \
{                                                                       \
    ((DWORD *)(fifo))[0] = (((sizeSetIndexedImagePointMthdCnt << 2) << 16) | ((ch) << 13) | NV060_POINT); \
    ((DWORD *)(fifo))[1] = ( (((x) & 0x0000ffff) << 0) |                \
                             (((y) & 0x0000ffff) << 16) );              \
    (DWORD *)(fifo) += sizeSetIndexedImagePoint;                        \
    freecount -= sizeSetIndexedImagePoint;                              \
}

#define sizeSetIndexedImageSizesMthdCnt         2
#define sizeSetIndexedImageSizes                3
#define nvglSetIndexedImageSizes(fifo, freecount, ch,                   \
                                 w_out, h_out, w_in, h_in)              \
{                                                                       \
    ((DWORD *)(fifo))[0] = (((sizeSetIndexedImageSizesMthdCnt << 2) << 16) | ((ch) << 13) | NV060_SIZE_OUT); \
    ((DWORD *)(fifo))[1] = ( (((w_out) & 0x0000ffff) << 0) |            \
                             (((h_out) & 0x0000ffff) << 16) );          \
    ((DWORD *)(fifo))[2] = ( (((w_in) & 0x0000ffff) << 0) |             \
                             (((h_in) & 0x0000ffff) << 16) );           \
    (DWORD *)(fifo) += sizeSetIndexedImageSizes;                        \
    freecount -= sizeSetIndexedImageSizes;                              \
}

#define nvglSetIndexedImageIndices(fifo, freecount, ch,                 \
                                   dataSizeInWords, indices)            \
{                                                                       \
    DWORD ii;                                                           \
    ((DWORD *)(fifo))[0] = (((dataSizeInWords << 2) << 16) | ((ch) << 13) | NV060_INDICES(0)); \
    (DWORD *)(fifo) += 1;                                               \
    for (ii=0; ii<dataSizeInWords; ii++) {                              \
        *(DWORD *)fifo = *(DWORD *)indices;                             \
        (DWORD *)fifo += 1;                                             \
        (DWORD *)indices += 1;                                          \
    }                                                                   \
    freecount -= (1 + dataSizeInWords);                                 \
}

/*
 * Scaled image from memory context setup macros.
 */
#define sizeSetScaledImageContextNotifiesMthdCnt    1
#define sizeSetScaledImageContextNotifies           2
#define nvglSetScaledImageContextNotifies(fifo, freecount, ch,              \
                                       ctxdmanotify)                        \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSetScaledImageContextNotifiesMthdCnt << 2) << 16) | ((ch) << 13) | NV077_SET_CONTEXT_DMA_NOTIFIES); \
    ((DWORD *)(fifo))[1] = (ctxdmanotify);                                  \
    (DWORD *)(fifo) += sizeSetScaledImageContextNotifies;                   \
    freecount -= sizeSetScaledImageContextNotifies;                         \
}

#define sizeSetScaledImageContextImageMthdCnt       1
#define sizeSetScaledImageContextImage              2
#define nvglSetScaledImageContextImage(fifo, freecount, ch,                 \
                                       ctxdmaimage)                         \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSetScaledImageContextImageMthdCnt << 2) << 16) | ((ch) << 13) | NV077_SET_CONTEXT_DMA_IMAGE); \
    ((DWORD *)(fifo))[1] = (ctxdmaimage);                                   \
    (DWORD *)(fifo) += sizeSetScaledImageContextImage;                      \
    freecount -= sizeSetScaledImageContextImage;                            \
}

#define sizeSetScaledImageContextSurfaceMthdCnt     1
#define sizeSetScaledImageContextSurface            2
#define nvglSetScaledImageContextSurface(fifo, freecount, ch,               \
                                       ctxdmasurface)                       \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSetScaledImageContextSurfaceMthdCnt << 2) << 16) | ((ch) << 13) | NV077_SET_CONTEXT_SURFACE); \
    ((DWORD *)(fifo))[1] = (ctxdmasurface);                                 \
    (DWORD *)(fifo) += sizeSetScaledImageContextSurface;                    \
    freecount -= sizeSetScaledImageContextSurface;                          \
}

#define sizeSetScaledImageFormatMthdCnt             1
#define sizeSetScaledImageFormat                    2
#define nvglSetScaledImageFormat(fifo, freecount, ch,                       \
                                 format)                                    \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSetScaledImageFormatMthdCnt << 2) << 16) | ((ch) << 13) | NV077_SET_COLOR_FORMAT); \
    ((DWORD *)(fifo))[1] = (format);                                        \
    (DWORD *)(fifo) += sizeSetScaledImageFormat;                            \
    freecount -= sizeSetScaledImageFormat;                                  \
}

#define sizeSetScaledImageOperationMthdCnt          1
#define sizeSetScaledImageOperation                 2
#define nvglSetScaledImageOperation(fifo, freecount, ch,                    \
                                    operation)                              \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSetScaledImageOperationMthdCnt << 2) << 16) | ((ch) << 13) | NV077_SET_OPERATION); \
    ((DWORD *)(fifo))[1] = (operation);                                     \
    (DWORD *)(fifo) += sizeSetScaledImageOperation;                         \
    freecount -= sizeSetScaledImageOperation;                               \
}

#define sizeScaledImageClipMthdCnt                  2
#define sizeScaledImageClip                         3
#define nvglScaledImageClip(fifo, freecount, ch,                            \
                            x, y, width, height)                            \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeScaledImageClipMthdCnt << 2) << 16) | ((ch) << 13) | NV077_CLIP_POINT); \
    ((DWORD *)(fifo))[1] = ((((y) & 0x0000FFFF) << 16) | ((x) & 0x0000FFFF)); \
    ((DWORD *)(fifo))[2] = ((((height) & 0x0000FFFF) << 16) | ((width) & 0x0000FFFF)); \
    (DWORD *)(fifo) += sizeScaledImageClip;                                 \
    freecount -= sizeScaledImageClip;                                       \
}

#define sizeScaledImageOutMthdCnt                   2
#define sizeScaledImageOut                          3
#define nvglScaledImageOut(fifo, freecount, ch,                             \
                           x, y, width, height)                             \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeScaledImageOutMthdCnt << 2) << 16) | ((ch) << 13) | NV077_IMAGE_OUT_POINT); \
    ((DWORD *)(fifo))[1] = ((((y) & 0x0000FFFF) << 16) | ((x) & 0x0000FFFF)); \
    ((DWORD *)(fifo))[2] = ((((height) & 0x0000FFFF) << 16) | ((width) & 0x0000FFFF)); \
    (DWORD *)(fifo) += sizeScaledImageOut;                                  \
    freecount -= sizeScaledImageOut;                                        \
}

#define sizeScaledImageDeltaDuDxDvDyMthdCnt         2
#define sizeScaledImageDeltaDuDxDvDy                3
#define nvglScaledImageDeltaDuDxDvDy(fifo, freecount, ch,                   \
                                     dudx, dvdy)                            \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeScaledImageDeltaDuDxDvDyMthdCnt << 2) << 16) | ((ch) << 13) | NV077_DELTA_DU_DX); \
    ((DWORD *)(fifo))[1] = (dudx);                                          \
    ((DWORD *)(fifo))[2] = (dvdy);                                          \
    (DWORD *)(fifo) += sizeScaledImageDeltaDuDxDvDy;                        \
    freecount -= sizeScaledImageDeltaDuDxDvDy;                              \
}

#define sizeScaledImageInSizeMthdCnt                1
#define sizeScaledImageInSize                       2
#define nvglScaledImageInSize(fifo, freecount, ch,                          \
                              width, height)                                \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeScaledImageInSizeMthdCnt << 2) << 16) | ((ch) << 13) | NV077_IMAGE_IN_SIZE); \
    ((DWORD *)(fifo))[1] = ((((height) & 0x0000FFFF) << 16) | ((width) & 0x0000FFFF)); \
    (DWORD *)(fifo) += sizeScaledImageInSize;                               \
    freecount -= sizeScaledImageInSize;                                     \
}

#define sizeScaledImageInFormatMthdCnt              1
#define sizeScaledImageInFormat                     2
#define nvglScaledImageInFormat(fifo, freecount, ch,                        \
                                format)                                     \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeScaledImageInFormatMthdCnt << 2) << 16) | ((ch) << 13) | NV077_IMAGE_IN_FORMAT); \
    ((DWORD *)(fifo))[1] = (format);                                        \
    (DWORD *)(fifo) += sizeScaledImageInFormat;                             \
    freecount -= sizeScaledImageInFormat;                                   \
}

#define sizeScaledImageInOffsetMthdCnt              1
#define sizeScaledImageInOffset                     2
#define nvglScaledImageInOffset(fifo, freecount, ch,                        \
                                offset)                                     \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeScaledImageInOffsetMthdCnt << 2) << 16) | ((ch) << 13) | NV077_IMAGE_IN_OFFSET); \
    ((DWORD *)(fifo))[1] = (offset);                                        \
    (DWORD *)(fifo) += sizeScaledImageInOffset;                             \
    freecount -= sizeScaledImageInOffset;                                   \
}

#define sizeScaledImageInPointMthdCnt               1
#define sizeScaledImageInPoint                      2
#define nvglScaledImageInPoint(fifo, freecount, ch,                         \
                               x, y)                                        \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeScaledImageInPointMthdCnt << 2) << 16) | ((ch) << 13) | NV077_IMAGE_IN); \
    ((DWORD *)(fifo))[1] = ((((y) & 0x0000FFFF) << 16) | ((x) & 0x0000FFFF)); \
    (DWORD *)(fifo) += sizeScaledImageInPoint;                              \
    freecount -= sizeScaledImageInPoint;                                    \
}

#define sizeScaledImageNotify                       4
#define nvglScaledImageNotify(fifo, freecount, ch)                          \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((1 << 2) << 16) | ((ch) << 13) | NV077_NOTIFY); \
    ((DWORD *)(fifo))[1] = NV077_NOTIFY_WRITE_ONLY;                         \
    ((DWORD *)(fifo))[2] = (((1 << 2) << 16) | ((ch) << 13) | NV077_NO_OPERATION); \
    ((DWORD *)(fifo))[3] = 0;                                               \
    (DWORD *)(fifo) += sizeScaledImageNotify;                               \
    freecount -= sizeScaledImageNotify;                                     \
}

/*
 * Context DMA from memory setup macros.
 */
#define sizeSetDmaFromMemoryMthdCnt                 3
#define sizeSetDmaFromMemory                        4
#define nvglSetDmaFromMemory(fifo, freecount, ch,                           \
                            base, selector, limit)                          \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSetDmaFromMemoryMthdCnt << 2) << 16) | ((ch) << 13) | 0x300); \
    ((DWORD *)(fifo))[1] = (base);                                          \
    ((DWORD *)(fifo))[2] = (selector);                                      \
    ((DWORD *)(fifo))[3] = (limit);                                         \
    (DWORD *)(fifo) += sizeSetDmaFromMemory;                                \
    freecount -= sizeSetDmaFromMemory;                                      \
}

#define sizeSetDmaFromMemoryContextNotifyMthdCnt    1
#define sizeSetDmaFromMemoryContextNotify           2
#define nvglSetDmaFromMemoryContextNotify(fifo, freecount, ch,              \
                                       ctxdmanotify)                        \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSetDmaFromMemoryContextNotifyMthdCnt << 2) << 16) | ((ch) << 13) | 0x180); \
    ((DWORD *)(fifo))[1] = (ctxdmanotify);                                  \
    (DWORD *)(fifo) += sizeSetDmaFromMemoryContextNotify;                   \
    freecount -= sizeSetDmaFromMemoryContextNotify;                         \
}

#define sizeSetDmaFromMemoryNotify                  7
#define nvglSetDmaFromMemoryNotify(fifo, freecount, ch,                     \
                                   base, selector, limit, notify)           \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((2 << 2) << 16) | ((ch) << 13) | 0x300);       \
    ((DWORD *)(fifo))[1] = (base);                                          \
    ((DWORD *)(fifo))[2] = (selector);                                      \
    ((DWORD *)(fifo))[3] = (((1 << 2) << 16) | ((ch) << 13) | 0x104);       \
    ((DWORD *)(fifo))[4] = (notify);                                        \
    ((DWORD *)(fifo))[5] = (((1 << 2) << 16) | ((ch) << 13) | 0x308);       \
    ((DWORD *)(fifo))[6] = (limit);                                         \
    (DWORD *)(fifo) += sizeSetDmaFromMemoryNotify;                          \
    freecount -= sizeSetDmaFromMemoryNotify;                                \
}

/*
 * Context DMA to memory setup macros.
 */
#define sizeSetDmaToMemoryMthdCnt                 3
#define sizeSetDmaToMemory                        4
#define nvglSetDmaToMemory(fifo, freecount, ch,                             \
                           base, selector, limit)                           \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSetDmaToMemoryMthdCnt << 2) << 16) | ((ch) << 13) | 0x300); \
    ((DWORD *)(fifo))[1] = (base);                                          \
    ((DWORD *)(fifo))[2] = (selector);                                      \
    ((DWORD *)(fifo))[3] = (limit);                                         \
    (DWORD *)(fifo) += sizeSetDmaToMemory;                                  \
    freecount -= sizeSetDmaToMemory;                                        \
}

#define sizeSetDmaToMemoryContextNotifyMthdCnt    1
#define sizeSetDmaToMemoryContextNotify           2
#define nvglSetDmaToMemoryContextNotify(fifo, freecount, ch,                \
                                       ctxdmanotify)                        \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSetDmaToMemoryContextNotifyMthdCnt << 2) << 16) | ((ch) << 13) | 0x180); \
    ((DWORD *)(fifo))[1] = (ctxdmanotify);                                  \
    (DWORD *)(fifo) += sizeSetDmaToMemoryContextNotify;                     \
    freecount -= sizeSetDmaToMemoryContextNotify;                           \
}

#define sizeSetDmaToMemoryNotify                  7
#define nvglSetDmaToMemoryNotify(fifo, freecount, ch,                       \
                                 base, selector, limit, notify)             \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((2 << 2) << 16) | ((ch) << 13) | 0x300);       \
    ((DWORD *)(fifo))[1] = (base);                                          \
    ((DWORD *)(fifo))[2] = (selector);                                      \
    ((DWORD *)(fifo))[3] = (((1 << 2) << 16) | ((ch) << 13) | 0x104);       \
    ((DWORD *)(fifo))[4] = (notify);                                        \
    ((DWORD *)(fifo))[5] = (((1 << 2) << 16) | ((ch) << 13) | 0x308);       \
    ((DWORD *)(fifo))[6] = (limit);                                         \
    (DWORD *)(fifo) += sizeSetDmaToMemoryNotify;                            \
    freecount -= sizeSetDmaToMemoryNotify;                                  \
}

/*
 * Context DMA in memory setup macros.
 */
#define sizeSetDmaInMemoryMthdCnt                 3
#define sizeSetDmaInMemory                        4
#define nvglSetDmaInMemory(fifo, freecount, ch,                             \
                           base, selector, limit)                           \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSetDmaInMemoryMthdCnt << 2) << 16) | ((ch) << 13) | 0x300); \
    ((DWORD *)(fifo))[1] = (base);                                          \
    ((DWORD *)(fifo))[2] = (selector);                                      \
    ((DWORD *)(fifo))[3] = (limit);                                         \
    (DWORD *)(fifo) += sizeSetDmaInMemory;                                  \
    freecount -= sizeSetDmaInMemory;                                        \
}

#define sizeSetDmaInMemoryContextNotifyMthdCnt    1
#define sizeSetDmaInMemoryContextNotify           2
#define nvglSetDmaInMemoryContextNotify(fifo, freecount, ch,                \
                                       ctxdmanotify)                        \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSetDmaInMemoryContextNotifyMthdCnt << 2) << 16) | ((ch) << 13) | 0x180); \
    ((DWORD *)(fifo))[1] = (ctxdmanotify);                                  \
    (DWORD *)(fifo) += sizeSetDmaInMemoryContextNotify;                     \
    freecount -= sizeSetDmaInMemoryContextNotify;                           \
}

#define sizeSetDmaInMemoryNotify                  7
#define nvglSetDmaInMemoryNotify(fifo, freecount, ch,                       \
                                 base, selector, limit, notify)             \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((2 << 2) << 16) | ((ch) << 13) | 0x300);       \
    ((DWORD *)(fifo))[1] = (base);                                          \
    ((DWORD *)(fifo))[2] = (selector);                                      \
    ((DWORD *)(fifo))[3] = (((1 << 2) << 16) | ((ch) << 13) | 0x104);       \
    ((DWORD *)(fifo))[4] = (notify);                                        \
    ((DWORD *)(fifo))[5] = (((1 << 2) << 16) | ((ch) << 13) | 0x308);       \
    ((DWORD *)(fifo))[6] = (limit);                                         \
    (DWORD *)(fifo) += sizeSetDmaInMemoryNotify;                            \
    freecount -= sizeSetDmaInMemoryNotify;                                  \
}

/*
 * DrawRopRectAndText macros.
 */
#define sizeDrawRopRectAndTextColor1AMthdCnt        1 
#define sizeDrawRopRectAndTextColor1A               2
#define nvglDrawRopRectAndTextColor1A(fifo, freecount, ch, color)           \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeDrawRopRectAndTextColor1AMthdCnt << 2) << 16) | ((ch) << 13) | NV04A_COLOR1_A); \
    ((DWORD *)(fifo))[1] = (color);                                         \
    (DWORD *)(fifo) += sizeDrawRopRectAndTextColor1A;                       \
    freecount -= sizeDrawRopRectAndTextColor1A;                             \
}

#define sizeDrawRopRectAndTextPointSizeMthdCnt      2
#define sizeDrawRopRectAndTextPointSize             3
#define nvglDrawRopRectAndTextPointSize(fifo, freecount, ch,                \
                                        x, y, width, height)                \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeDrawRopRectAndTextPointSizeMthdCnt << 2) << 16) | ((ch) << 13) | NV04A_UNCLIPPED_RECTANGLE_POINT(0)); \
    ((DWORD *)(fifo))[1] = ((((x) & 0x0000FFFF) << 16) | ((y) & 0x0000FFFF)); \
    ((DWORD *)(fifo))[2] = ((((width) & 0x0000FFFF) << 16) | ((height) & 0x0000FFFF)); \
    (DWORD *)(fifo) += sizeDrawRopRectAndTextPointSize;                     \
    freecount -= sizeDrawRopRectAndTextPointSize;                           \
}

/*
 * Surfaces2D macros.
 */
#define sizeSet2DSurfacesContextsMthdCnt            2
#define sizeSet2DSurfacesContexts                   3
#define nvglSet2DSurfacesContexts(fifo, freecount, ch, ctxsrc, ctxdest)     \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSet2DSurfacesContextsMthdCnt << 2) << 16) | ((ch) << 13) | NV042_SET_CONTEXT_DMA_IMAGE_SOURCE); \
    ((DWORD *)(fifo))[1] = (ctxsrc);                                        \
    ((DWORD *)(fifo))[2] = (ctxdest);                                       \
    (DWORD *)(fifo) += sizeSet2DSurfacesContexts;                           \
    freecount -= sizeSet2DSurfacesContexts;                                 \
}

#define sizeSet2DSurfacesColorFormatMthdCnt         1
#define sizeSet2DSurfacesColorFormat                2
#define nvglSet2DSurfacesColorFormat(fifo, freecount, ch, format)           \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSet2DSurfacesColorFormatMthdCnt << 2) << 16) | ((ch) << 13) | NV042_SET_COLOR_FORMAT); \
    ((DWORD *)(fifo))[1] = (format);                                        \
    (DWORD *)(fifo) += sizeSet2DSurfacesColorFormat;                        \
    freecount -= sizeSet2DSurfacesColorFormat;                              \
}

#define sizeSet2DSurfacesDestinationMthdCnt         1
#define sizeSet2DSurfacesDestination                2
#define nvglSet2DSurfacesDestination(fifo, freecount, ch, offset)           \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSet2DSurfacesDestinationMthdCnt << 2) << 16) | ((ch) << 13) | NV042_SET_OFFSET_DESTIN); \
    ((DWORD *)(fifo))[1] = (offset);                                        \
    (DWORD *)(fifo) += sizeSet2DSurfacesDestination;                        \
    freecount -= sizeSet2DSurfacesDestination;                              \
}

#define sizeSet2DSurfacesPitchMthdCnt               1
#define sizeSet2DSurfacesPitch                      2
#define nvglSet2DSurfacesPitch(fifo, freecount, ch,                         \
                               srcpitch, dstpitch)                          \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSet2DSurfacesPitchMthdCnt << 2) << 16) | ((ch) << 13) | NV042_SET_PITCH); \
    ((DWORD *)(fifo))[1] = ((((dstpitch) & 0x0000FFFF) << 16) | ((srcpitch) & 0x0000FFFF)); \
    (DWORD *)(fifo) += sizeSet2DSurfacesPitch;                              \
    freecount -= sizeSet2DSurfacesPitch;                                    \
}


/*
 * Set image black rectangle
 */
#define sizeSetClipMthdCnt                          2
#define sizeSetClip                                 3
#define nvglSetClip(fifo, freecount, ch,                                    \
                    x, y, w, h)                                             \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSetClipMthdCnt << 2) << 16) | ((ch) << 13) | NV019_SET_POINT); \
    ((DWORD *)(fifo))[1] = ((DWORD)y << 16) | (DWORD)x;                     \
    ((DWORD *)(fifo))[2] = ((DWORD)h << 16) | (DWORD)w;                     \
    (DWORD *)(fifo) += sizeSetClip;                                         \
    freecount -= sizeSetClip;                                               \
}

/*
 * Rop5 macros.
 */
#define sizeSetRop5MthdCnt                          1
#define sizeSetRop5                                 2
#define nvglSetRop5(fifo, freecount, ch, rop5)                              \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSetRop5MthdCnt << 2) << 16) | ((ch) << 13) | NV043_SET_ROP5); \
    ((DWORD *)(fifo))[1] = (rop5);                                          \
    (DWORD *)(fifo) += sizeSetRop5;                                         \
    freecount -= sizeSetRop5;                                               \
}

/*
 * Define the DMA jump operation.
 */
#define sizeDmaJump         1
#define nvglDmaJump(fifo, freecount, ch, offset)                            \
{                                                                           \
    ((DWORD *)(fifo))[0] = (0x20000000 | (offset));                         \
    (DWORD *)(fifo) += sizeDmaJump;                                         \
    freecount -= sizeDmaJump;                                               \
}

/*
 *
 */
#define nvglIdleKickoff(minsize)                                            \
{                                                                           \
}



#define DMA_PUSHER_SYNC()                                                   \
{                                                                           \
}
#else   // D3D_CPU
/*
 * Hardware connection macros.
 */
#ifdef  D3D_HARDWARE
#define nvglOpenChannel(handle, address, size, fifo)                        \
{                                                                           \
    (address) = (DWORD)NvOpen(0);                                           \
    (fifo)    = (Nv4ControlDma *)0;                                         \
}
#define nvglCloseChannel(handle, address, fifo)                             \
{                                                                           \
    NvClose((NvChannel *)(address));                                        \
    (fifo)    = 0;                                                          \
    (handle)  = (DWORD)0;                                                   \
    (address) = (DWORD)0;                                                   \
}
#else   // D3D_EMULATION
#define nvglOpenChannel(handle, address, size, fifo)                        \
{                                                                           \
    (handle)  = (DWORD)HeapCreate(HEAP_SHARED, sizeof(Nv03ChannelPio), 0);  \
    (address) = (DWORD)HeapAlloc((HANDLE)(handle), HEAP_ZERO_MEMORY, sizeof(Nv03ChannelPio)); \
    (fifo)    = (Nv4ControlDma *)0;                                         \
}
#define nvglCloseChannel(handle, address, fifo)                             \
{                                                                           \
    HeapFree((HANDLE)(handle), 0, (PVOID)(address));                        \
    HeapDestroy((HANDLE)(handle));                                          \
    (fifo)    = 0;                                                          \
    (handle)  = (DWORD)0;                                                   \
    (address) = (DWORD)0;                                                   \
}
#endif  // D3D_EMULATION

/*
 * CPU Pushing macros.
 */
#ifdef  D3D_HARDWARE
#define nvglGetFreeCount(fifo, freecount, ch, size, retval)                 \
{                                                                           \
    (freecount) = ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].control.Free;\
    (retval) = FALSE;                                                       \
}
#else   // D3D_EMULATION
#define nvglGetFreeCount(fifo, freecount, ch, size, retval)                 \
{                                                                           \
    nvGetDmaFreeCount(size);                                                \
    (retval) = FALSE;                                                       \
}
#endif  // D3D_EMULATION.

#define sizeSetObjectMthdCnt    1
#define sizeSetObject           (sizeSetObjectMthdCnt * 4)
#define nvglSetObject(fifo, freecount, ch, obj)                             \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].SetObject = (obj);         \
    freecount -= sizeSetObject;                                             \
}

/*
 * Multiple data setting macros don't convert well from DMA to CPU pushing
 * methodologies.  These will need to be special cased.
 */
#define sizeSetStartMethod   0
#define nvglSetStartMethod(fifo, freecount, ch, method, methodcount)
#define sizeSetData          0
#define nvglSetData(fifo, freecount, data)

/*
 * Create Object macro.
 */
#define sizeCreateObjectMthdCnt             1
#define sizeCreateObject                    (sizeCreateObjectMthdCnt * 4)
#define nvglCreateObject(fifo, freecount, ch, obj)                          \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nvClass.Create = (obj);    \
    freecount -= sizeCreateObject;                                          \
}

/*
 * Destroy Object macro.
 */
#define sizeDestroyObjectMthdCnt            1
#define sizeDestroyObject                   (sizeDestroyObjectMthdCnt * 4)
#define nvglDestroyObject(fifo, freecount, ch, obj)                         \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nvClass.Destroy = (obj);   \
    freecount -= sizeDestroyObject;                                         \
}

/*
 * Define DX5 Triangle class macros.
 */
#define sizeSetDx5TriangleContextsMthdCnt   2
#define sizeSetDx5TriangleContexts          (sizeSetDx5TriangleContextsMthdCnt * 4)
#define nvglSetDx5TriangleContexts(fifo, freecount, ch, ctxa, ctxb)         \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.SetContextDmaA = (ctxa); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.SetContextDmaB = (ctxb); \
    freecount -= sizeSetDx5TriangleContexts;                                \
}
#define sizeSetDx5TriangleSurfaceMthdCnt    1
#define sizeSetDx5TriangleSurface           (sizeSetDx5TriangleSurfaceMthdCnt * 4)
#define nvglSetDx5TriangleSurface(fifo, freecount, ch, ctxs)                \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.SetContextSurfaces = (ctxs); \
    freecount -= sizeSetDx5TriangleSurface;                                 \
}
#define sizeDx5TriangleStateMthdCnt         7
#define sizeDx5TriangleState                (sizeDx5TriangleStateMthdCnt * 4)
#define nvglDx5TriangleState(fifo, freecount, ch,                           \
                             ckey, offset, format, filter,                  \
                             blend, control, fogcolor)                      \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.ColorKey = (ckey);     \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Offset   = (offset);   \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Format   = (format);   \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Filter   = (filter);   \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Blend    = (blend);    \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Control  = (control);  \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.FogColor = (fogcolor); \
    freecount -= sizeDx5TriangleState;                                      \
}
#define sizeDx5TriangleTLVertexMthdCnt      8
#define sizeDx5TriangleTLVertex             (sizeDx5TriangleTLVertexMthdCnt * 4)
#define nvglDx5TriangleTLVertex(fifo, freecount, ch, alias, vd)                                                   \
{                                                                                                                 \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].sx       = vd.sx;       \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].sy       = vd.sy;       \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].sz       = vd.sz;       \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].rhw      = vd.rhw;      \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].color    = vd.color;    \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].specular = vd.specular; \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].tu       = vd.tu;       \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].tv       = vd.tv;       \
    freecount -= sizeDx5TriangleTLVertex;                                                                         \
    dbgDisplayVertexData(*(DWORD *)&(vd.sx),  *(DWORD *)&(vd.sy),  *(DWORD *)&(vd.sz),                            \
                         *(DWORD *)&(vd.rhw),  (DWORD)vd.color,     (DWORD)vd.specular,                           \
                         *(DWORD *)&(vd.tu),  *(DWORD *)&(vd.tv));                                                \
}
#define nvglDx5TriangleTLVertexExpFog(fifo, freecount, ch, alias, vd)                                             \
{                                                                                                                 \
    float ffog, z;                                                                                                \
    int   ifog, specular;                                                                                         \
    specular  = (vd.specular) & 0x00FFFFFF;                                                                       \
    FP_INV(z, (vd.rhw));                                                                                          \
    ffog  = z * pCurrentContext->fFogTableDensity;                                                                \
    FP_EXP(ffog, ffog);                                                                                           \
    FP_NORM_TO_BIT24(ifog, ffog);                                                                                 \
    specular |= ifog;                                                                                             \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].sx       = vd.sx;       \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].sy       = vd.sy;       \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].sz       = vd.sz;       \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].rhw      = vd.rhw;      \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].color    = vd.color;    \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].specular = specular;    \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].tu       = vd.tu;       \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].tv       = vd.tv;       \
    freecount -= sizeDx5TriangleTLVertex;                                                                         \
    dbgDisplayVertexData(*(DWORD *)&(vd.sx),  *(DWORD *)&(vd.sy),  *(DWORD *)&(vd.sz),                            \
                         *(DWORD *)&(vd.rhw),  (DWORD)vd.color,     (DWORD)vd.specular,                           \
                         *(DWORD *)&(vd.tu),  *(DWORD *)&(vd.tv));                                                \
}
#define nvglDx5TriangleTLVertexExp2Fog(fifo, freecount, ch, alias, vd)                                            \
{                                                                                                                 \
    float ffog, z;                                                                                                \
    int   ifog, specular;                                                                                         \
    specular  = (vd.specular) & 0x00FFFFFF;                                                                       \
    FP_INV(z, (vd.rhw));                                                                                          \
    ffog  = z * pCurrentContext->fFogTableDensity;                                                                \
    ffog *= ffog;                                                                                                 \
    FP_EXP(ffog, ffog);                                                                                           \
    FP_NORM_TO_BIT24(ifog, ffog);                                                                                 \
    specular |= ifog;                                                                                             \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].sx       = vd.sx;       \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].sy       = vd.sy;       \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].sz       = vd.sz;       \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].rhw      = vd.rhw;      \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].color    = vd.color;    \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].specular = specular;    \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].tu       = vd.tu;       \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].tv       = vd.tv;       \
    freecount -= sizeDx5TriangleTLVertex;                                                                         \
    dbgDisplayVertexData(*(DWORD *)&(vd.sx),  *(DWORD *)&(vd.sy),  *(DWORD *)&(vd.sz),                            \
                         *(DWORD *)&(vd.rhw),  (DWORD)vd.color,     (DWORD)vd.specular,                           \
                         *(DWORD *)&(vd.tu),  *(DWORD *)&(vd.tv));                                                \
}
#define nvglDx5TriangleTLVertexLinearFog(fifo, freecount, ch, alias, vd)                                          \
{                                                                                                                 \
    float ffog, z;                                                                                                \
    int   ifog, specular;                                                                                         \
    specular  = (vd.specular) & 0x00FFFFFF;                                                                       \
    FP_INV(z, (vd.rhw));                                                                                          \
    ffog = (pCurrentContext->fFogTableEnd - z) * pCurrentContext->fFogTableLinearScale;                           \
    FP_NORM_TO_BIT24(ifog, ffog);                                                                                 \
    specular |= ifog;                                                                                             \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].sx       = vd.sx;       \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].sy       = vd.sy;       \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].sz       = vd.sz;       \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].rhw      = vd.rhw;      \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].color    = vd.color;    \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].specular = specular;    \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].tu       = vd.tu;       \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].tv       = vd.tv;       \
    freecount -= sizeDx5TriangleTLVertex;                                                                         \
    dbgDisplayVertexData(*(DWORD *)&(vd.sx),  *(DWORD *)&(vd.sy),  *(DWORD *)&(vd.sz),                            \
                         *(DWORD *)&(vd.rhw),  (DWORD)vd.color,     (DWORD)vd.specular,                           \
                         *(DWORD *)&(vd.tu),  *(DWORD *)&(vd.tv));                                                \
}
#define sizeDx5TriangleDrawPrimitiveMthdCnt 1
#define sizeDx5TriangleDrawPrimitive        (sizeDx5TriangleDrawPrimitiveMthdCnt * 4)
#define nvglDx5TriangleDrawPrimitive(fifo, freecount, ch, alias, vertices)  \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.DrawPrimitive[(alias)] = (vertices); \
    freecount -= sizeDx5TriangleDrawPrimitive;                              \
}
#define sizeDx5TriangleNotifyMthdCnt        2
#define sizeDx5TriangleNotify               (sizeDx5TriangleNotifyMthdCnt * 4)
#define nvglDx5TriangleNotify(fifo, freecount, ch)                          \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Notify      = NV054_NOTIFY_WRITE_ONLY; \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.NoOperation = 0x00000000;              \
    freecount -= sizeDx5TriangleNotify;                                     \
}

/*
 * Define DX6 Triangle class macros.
 */
#define sizeSetDx6TriangleContextsMthdCnt   2
#define sizeSetDx6TriangleContexts          (sizeSetDx6TriangleContextsMthdCnt * 4)
#define nvglSetDx6TriangleContexts(fifo, freecount, ch, ctxa, ctxb)         \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6MultiTexturedTriangle.SetContextDmaA = (ctxa); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6MultiTexturedTriangle.SetContextDmaB = (ctxb); \
    freecount -= sizeSetDx6TriangleContexts;                                \
}
#define sizeSetDx6TriangleSurfaceMthdCnt    1
#define sizeSetDx6TriangleSurface           (sizeSetDx6TriangleSurfaceMthdCnt * 4)
#define nvglSetDx6TriangleSurface(fifo, freecount, ch, ctxs)                \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6MultiTexturedTriangle.SetContextSurfaces = (ctxs); \
    freecount -= sizeSetDx6TriangleSurface;                                 \
}
#define sizeDx6TriangleOffsetMthdCnt        1
#define sizeDx6TriangleOffset               (sizeDx6TriangleOffsetMthdCnt * 4)
#define nvglDx6TriangleOffset(fifo, freecount, ch,                          \
                              offset, buffer)                               \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6TexturedTriangle.Offset[buffer] = (offset); \
    freecount -= sizeDx6TriangleOffset;                                     \
}
#define sizeDx6TriangleFormatMthdCnt        1
#define sizeDx6TriangleFormat               (sizeDx6TriangleFormatMthdCnt * 4)
#define nvglDx6TriangleFormat(fifo, freecount, ch,                          \
                              format, buffer)                               \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6TexturedTriangle.Format[buffer] = (format); \
    freecount -= sizeDx6TriangleFormat;                                     \
}
#define sizeDx6TriangleFilterMthdCnt        1
#define sizeDx6TriangleFilter               (sizeDx6TriangleFormatMthdCnt * 4)
#define nvglDx6TriangleFilter(fifo, freecount, ch,                          \
                              filter, buffer)                               \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6TexturedTriangle.Filter[buffer] = (filter); \
    freecount -= sizeDx6TriangleFilter;                                     \
}


#define sizeDx6TriangleStageStateMthdCnt    1
#define sizeDx6TriangleStageState           (sizeDx6TriangleStageStateMthdCnt * 4)
#define nvglDx6TriangleStageState(fifo, freecount, ch,                      \
                                  c0alpha, c0color, c1alpha, c1color,       \
                                  factor, blend,                            \
                                  control0, control1, control2,             \
                                  fogcolor)                                 \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6TexturedTriangle.Combine0Alpha = (c0alpha); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6TexturedTriangle.Combine0Color = (c0color); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6TexturedTriangle.Combine1Alpha = (c1alpha); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6TexturedTriangle.Combine1Color = (c1color); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6TexturedTriangle.CombineFactor = (factor);  \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6TexturedTriangle.Blend = (blend);           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6TexturedTriangle.Control0 = (control0);     \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6TexturedTriangle.Control1 = (control1);     \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6TexturedTriangle.Control2 = (control2);     \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6TexturedTriangle.FogColor = (fogcolor);     \
    freecount -= sizeDx6TriangleStageState;                                 \
}
#define sizeDx6TriangleTLVertexMthdCnt      8
#define sizeDx6TriangleTLVertex             (sizeDx6TriangleTLVertexMthdCnt * 4)
#define nvglDx6TriangleTLVertex(fifo, freecount, ch, alias, vd)                                                   \
{                                                                                                                 \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6TexturedTriangle.Tlvertex[(alias)].sx       = vd.sx;       \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6TexturedTriangle.Tlvertex[(alias)].sy       = vd.sy;       \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6TexturedTriangle.Tlvertex[(alias)].sz       = vd.sz;       \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6TexturedTriangle.Tlvertex[(alias)].rhw      = vd.rhw;      \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6TexturedTriangle.Tlvertex[(alias)].color    = vd.color;    \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6TexturedTriangle.Tlvertex[(alias)].specular = vd.specular; \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6TexturedTriangle.Tlvertex[(alias)].tu0      = vd.tu;       \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6TexturedTriangle.Tlvertex[(alias)].tv0      = vd.tv;       \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6TexturedTriangle.Tlvertex[(alias)].tu1      = 0;           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6TexturedTriangle.Tlvertex[(alias)].tv1      = 0;           \
    freecount -= sizeDx6TriangleTLVertex;                                                                         \
    dbgDisplayVertexData(*(DWORD *)&(vd.sx),  *(DWORD *)&(vd.sy),  *(DWORD *)&(vd.sz),                            \
                         *(DWORD *)&(vd.rhw),  (DWORD)vd.color,     (DWORD)vd.specular,                           \
                         *(DWORD *)&(vd.tu),  *(DWORD *)&(vd.tv));                                                \
}
#define sizeDx6TriangleDrawPrimitiveMthdCnt 1
#define sizeDx6TriangleDrawPrimitive        (sizeDx6TriangleDrawPrimitiveMthdCnt * 4)
#define nvglDx6TriangleDrawPrimitive(fifo, freecount, ch, alias, vertices)  \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6TexturedTriangle.DrawPrimitive[(alias)] = (vertices); \
    freecount -= sizeDx6TriangleDrawPrimitive;                              \
}

/*
 * Define NV4 Render Solid Rectangle class macros.
 */
#define sizeSetNv4SolidRectangleSurfaceMthdCnt  1
#define sizeSetNv4SolidRectangleSurface         (sizeSetNv4SolidRectangleSurfaceMthdCnt * 4)
#define nvglSetNv4SolidRectangleSurface(fifo, freecount, ch, ctx)           \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4RenderSolidRectangle.SetContextSurface = (ctx); \
    freecount -= sizeSetNv4SolidRectangleSurface;                           \
}

#define sizeSetNv4SolidRectangleOperationMthdCnt    1
#define sizeSetNv4SolidRectangleOperation           (sizeSetNv4SolidRectangleOperationMthdCnt * 4)
#define nvglSetNv4SolidRectangleOperation(fifo, freecount, ch, op)          \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4RenderSolidRectangle.SetOperation = (op); \
    freecount -= sizeSetNv4SolidRectangleOperation;                         \
}

#define sizeSetNv4SolidRectangleColorFormatMthdCnt  1
#define sizeSetNv4SolidRectangleColorFormat         (sizeSetNv4SolidRectangleColorFormatMthdCnt * 4)
#define nvglSetNv4SolidRectangleColorFormat(fifo, freecount, ch, cfmt)      \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4RenderSolidRectangle.SetColorFormat = (cfmt); \
    freecount -= sizeSetNv4SolidRectangleColorFormat;                       \
}

#define sizeNv4SolidRectangleColorMthdCnt           1
#define sizeNv4SolidRectangleColor                  (sizeNv4SolidRectangleColorMthdCnt * 4)
#define nvglNv4SolidRectangleColor(fifo, freecount, ch, color)              \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4RenderSolidRectangle.Color = (color); \
    freecount -= sizeNv4SolidRectangleColor;                                \
}

#define sizeNv4SolidRectanglePointSizeMthdCnt       2
#define sizeNv4SolidRectanglePointSize              (sizeNv4SolidRectanglePointSizeMthdCnt * 4)
#define nvglNv4SolidRectanglePointSize(fifo, freecount, ch,                 \
                                       x, y, width, height)                 \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4RenderSolidRectangle.Rectangle[0].point = ((((y) & 0x0000FFFF) << 16) | ((x) & 0x0000FFFF)); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4RenderSolidRectangle.Rectangle[0].size  = ((((height) & 0x0000FFFF) << 16) | ((width) & 0x0000FFFF)); \
    freecount -= sizeNv4SolidRectanglePointSize;                            \
}

/*
 * Define Context Surfaces ARGB Zeta/Stencil macros.
 */
#define sizeSetRenderTargetContextsMthdCnt  2
#define sizeSetRenderTargetContexts         (sizeSetRenderTargetContextsMthdCnt * 4)
#define nvglSetRenderTargetContexts(fifo, freecount, ch,                    \
                                    ctxdmacolor, ctxdmazeta)                \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ContextSurfacesArgbZs.SetContextDmaColor = (ctxdmacolor);                        \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ContextSurfacesArgbZs.SetContextDmaZeta  = (ctxdmazeta);                         \
    freecount -= sizeSetRenderTargetContexts;                               \
}

#define sizeSetRenderTargetMthdCnt          5
#define sizeSetRenderTarget                 (sizeSetRenderTargetMthdCnt * 4)
#define nvglSetRenderTarget(fifo, freecount, ch,                            \
                            format, clipsize, pitch,                        \
                            coloroffset, zetaoffset)                        \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ContextSurfacesArgbZs.SetFormat      = (format);      \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ContextSurfacesArgbZs.SetClipSize    = (clipsize);    \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ContextSurfacesArgbZs.SetPitch       = (pitch);       \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ContextSurfacesArgbZs.SetOffsetColor = (coloroffset); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ContextSurfacesArgbZs.SetOffsetZeta  = (zetaoffset);  \
    freecount -= sizeSetRenderTarget;                                       \
}

/*
 * Swizzled surface context setup macros.
 */
#define sizeSetSwizzledSurfaceContextImageMthdCnt   1
#define sizeSetSwizzledSurfaceContextImage      (sizeSetSwizzledSurfaceContextImageMthdCnt * 4)
#define nvglSetSwizzledSurfaceContextImage(fifo, freecount, ch,             \
                                          ctxdmaimage)                      \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ContextSurfaceSwizzled.SetContextDmaImage = (ctxdmaimage); \
    freecount -= sizeSetSwizzledSurfaceContextImage;                        \
}

#define sizeSetSwizzledSurfaceMthdCnt               2
#define sizeSetSwizzledSurface                      (sizeSetSwizzledSurfaceMthdCnt * 4)
#define nvglSetSwizzledSurface(fifo, freecount, ch,                         \
                              format, offset)                               \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ContextSurfaceSwizzled.SetFormat = (format); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ContextSurfaceSwizzled.SetOffset = (offset); \
    freecount -= sizeSetSwizzledSurface;                                    \
}

/*
 * Scaled image from memory context setup macros.
 */
#define sizeSetScaledImageContextNotifiesMthdCnt     1
#define sizeSetScaledImageContextNotifies           (sizeSetScaledImageContextNotifiesMthdCnt * 4)
#define nvglSetScaledImageContextNotifies(fifo, freecount, ch,              \
                                       ctxdmanotify)                        \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ScaledImageFromMemory.SetContextDmaNotifies = (ctxdmanotify); \
    freecount -= sizeSetScaledImageContextNotifies;                         \
}

#define sizeSetScaledImageContextImageMthdCnt       1
#define sizeSetScaledImageContextImage              (sizeSetScaledImageContextImageMthdCnt * 4)
#define nvglSetScaledImageContextImage(fifo, freecount, ch,                 \
                                       ctxdmaimage)                         \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ScaledImageFromMemory.SetContextDmaImage = (ctxdmaimage); \
    freecount -= sizeSetScaledImageContextImage;                            \
}

#define sizeSetScaledImageContextSurfaceMthdCnt     1
#define sizeSetScaledImageContextSurface            (sizeSetScaledImageContextSurfaceMthdCnt * 4)
#define nvglSetScaledImageContextSurface(fifo, freecount, ch,               \
                                       ctxdmasurface)                       \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ScaledImageFromMemory.SetContextSurface = (ctxdmasurface); \
    freecount -= sizeSetScaledImageContextSurface;                          \
}

#define sizeSetScaledImageFormatMthdCnt             1
#define sizeSetScaledImageFormat                    (sizeSetScaledImageFormatMthdCnt * 4)
#define nvglSetScaledImageFormat(fifo, freecount, ch,                       \
                                 format)                                    \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ScaledImageFromMemory.SetColorFormat = (format); \
    freecount -= sizeSetScaledImageFormat;                                  \
}

#define sizeSetScaledImageOperationMthdCnt          1
#define sizeSetScaledImageOperation                 (sizeSetScaledImageOperationMthdCnt * 4)
#define nvglSetScaledImageOperation(fifo, freecount, ch,                    \
                                    operation)                              \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ScaledImageFromMemory.SetOperation = (operation); \
    freecount -= sizeSetScaledImageOperation;                               \
}



#define sizeScaledImageClipMthdCnt                  2
#define sizeScaledImageClip                         (sizeScaledImageClipMthdCnt * 4)
#define nvglScaledImageClip(fifo, freecount, ch,                            \
                            x, y, width, height)                            \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ScaledImageFromMemory.ClipPoint = ((((y) & 0x0000FFFF) << 16) | ((x) & 0x0000FFFF)); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ScaledImageFromMemory.ClipSize  = ((((height) & 0x0000FFFF) << 16) | ((width) & 0x0000FFFF)); \
    freecount -= sizeScaledImageClip;                                       \
}

#define sizeScaledImageOutMthdCnt                   2
#define sizeScaledImageOut                          (sizeScaledImageOutMthdCnt * 4)
#define nvglScaledImageOut(fifo, freecount, ch,                             \
                           x, y, width, height)                             \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ScaledImageFromMemory.ImageOutPoint = ((((y) & 0x0000FFFF) << 16) | ((x) & 0x0000FFFF)); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ScaledImageFromMemory.ImageOutSize  = ((((height) & 0x0000FFFF) << 16) | ((width) & 0x0000FFFF)); \
    freecount -= sizeScaledImageOut;                                        \
}

#define sizeScaledImageDeltaDuDxDvDyMthdCnt         2
#define sizeScaledImageDeltaDuDxDvDy                (sizeScaledImageDeltaDuDxDvDyMthdCnt * 4)
#define nvglScaledImageDeltaDuDxDvDy(fifo, freecount, ch,                   \
                                     dudx, dvdy)                            \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ScaledImageFromMemory.DeltaDuDx = (dudx); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ScaledImageFromMemory.DeltaDvDy = (dvdy); \
    freecount -= sizeScaledImageDeltaDuDxDvDy;                              \
}

#define sizeScaledImageInSizeMthdCnt                1
#define sizeScaledImageInSize                       (sizeScaledImageInSizeMthdCnt * 4)
#define nvglScaledImageInSize(fifo, freecount, ch,                          \
                              width, height)                                \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ScaledImageFromMemory.ImageInSize = ((((height) & 0x0000FFFF) << 16) | ((width) & 0x0000FFFF)); \
    freecount -= sizeScaledImageInSize;                                     \
}

#define sizeScaledImageInFormatMthdCnt              1
#define sizeScaledImageInFormat                     (sizeScaledImageInFormatMthdCnt * 4)
#define nvglScaledImageInFormat(fifo, freecount, ch,                        \
                                format)                                     \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ScaledImageFromMemory.ImageInFormat = (format); \
    freecount -= sizeScaledImageInFormat;                                   \
}

#define sizeScaledImageInOffsetMthdCnt              1
#define sizeScaledImageInOffset                     (sizeScaledImageInOffsetMthdCnt * 4)
#define nvglScaledImageInOffset(fifo, freecount, ch,                        \
                                offset)                                     \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ScaledImageFromMemory.ImageInOffset = (offset); \
    freecount -= sizeScaledImageInOffset;                                   \
}

#define sizeScaledImageInPointMthdCnt               1
#define sizeScaledImageInPoint                      (sizeScaledImageInPointMthdCnt * 4)
#define nvglScaledImageInPoint(fifo, freecount, ch,                         \
                               x, y)                                        \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ScaledImageFromMemory.ImageInPoint = ((((y) & 0x0000FFFF) << 16) | ((x) & 0x0000FFFF)); \
    freecount -= sizeScaledImageInPoint;                                    \
}

#define sizeScaledImageNotifyMthdCnt                2
#define sizeScaledImageNotify                       (sizeScaledImageNotifyMthdCnt * 4)
#define nvglScaledImageNotify(fifo, freecount, ch)                          \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ScaledImageFromMemory.Notify = NV077_NOTIFY_WRITE_ONLY; \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ScaledImageFromMemory.NoOperation = 0; \
    freecount -= sizeScaledImageNotify;                                     \
}

/*
 * Context DMA from memory setup macros.
 */
#define sizeSetDmaFromMemoryMthdCnt                 3
#define sizeSetDmaFromMemory                        (sizeSetDmaFromMemoryMthdCnt * 4)
#define nvglSetDmaFromMemory(fifo, freecount, ch,                           \
                            base, selector, ctxlimit)                       \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].contextDmaFromMemory.SetDmaSpecifier.address[0] = (base); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].contextDmaFromMemory.SetDmaSpecifier.address[1] = (selector); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].contextDmaFromMemory.SetDmaSpecifier.limit = (ctxlimit); \
    freecount -= sizeSetDmaFromMemory;                                      \
}

#define sizeSetDmaFromMemoryContextNotifyMthdCnt    1
#define sizeSetDmaFromMemoryContextNotify           (sizeSetDmaFromMemoryContextNotifyMthdCnt * 4)
#define nvglSetDmaFromMemoryContextNotify(fifo, freecount, ch,              \
                                       ctxdmanotify)                        \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].contextDmaFromMemory.SetNotifyCtxDma = (ctxdmanotify); \
    freecount -= sizeSetDmaFromMemoryContextNotify;                         \
}

#define sizeSetDmaFromMemoryNotifyMthdCnt           4
#define sizeSetDmaFromMemoryNotify                  (sizeSetDmaFromMemoryNotifyMthdCnt * 4)
#define nvglSetDmaFromMemoryNotify(fifo, freecount, ch,                     \
                                   base, selector, ctxlimit, notify)        \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].contextDmaFromMemory.SetDmaSpecifier.address[0] = (base); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].contextDmaFromMemory.SetDmaSpecifier.address[1] = (selector); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].contextDmaFromMemory.SetNotify = (notify); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].contextDmaFromMemory.SetDmaSpecifier.limit = (ctxlimit); \
    freecount -= sizeSetDmaFromMemoryNotify;                                \
}

/*
 * Context DMA to memory setup macros.
 */
#define sizeSetDmaToMemoryMthdCnt                   3
#define sizeSetDmaToMemory                          (sizeSetDmaToMemoryMthdCnt * 4)
#define nvglSetDmaToMemory(fifo, freecount, ch,                             \
                            base, selector, ctxlimit)                       \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].contextDmaToMemory.SetDmaSpecifier.address[0] = (base); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].contextDmaToMemory.SetDmaSpecifier.address[1] = (selector); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].contextDmaToMemory.SetDmaSpecifier.limit = (ctxlimit); \
    freecount -= sizeSetDmaToMemory;                                        \
}

#define sizeSetDmaToMemoryContextNotifyMthdCnt      1
#define sizeSetDmaToMemoryContextNotify             (sizeSetDmaToMemoryContextNotifyMthdCnt * 4)
#define nvglSetDmaToMemoryContextNotify(fifo, freecount, ch,                \
                                       ctxdmanotify)                        \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].contextDmaToMemory.SetNotifyCtxDma = (ctxdmanotify); \
    freecount -= sizeSetDmaToMemoryContextNotify;                           \
}

#define sizeSetDmaToMemoryNotifyMthdCnt             4
#define sizeSetDmaToMemoryNotify                    (sizeSetDmaToMemoryNotifyMthdCnt * 4)
#define nvglSetDmaToMemoryNotify(fifo, freecount, ch,                       \
                                   base, selector, ctxlimit, notify)        \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].contextDmaToMemory.SetDmaSpecifier.address[0] = (base); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].contextDmaToMemory.SetDmaSpecifier.address[1] = (selector); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].contextDmaToMemory.SetNotify = (notify); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].contextDmaToMemory.SetDmaSpecifier.limit = (ctxlimit); \
    freecount -= sizeSetDmaToMemoryNotify;                                  \
}

/*
 * Context DMA in memory setup macros.
 */
#define sizeSetDmaInMemoryMthdCnt                   3
#define sizeSetDmaInMemory                          (sizeSetDmaInMemoryMthdCnt * 4)
#define nvglSetDmaInMemory(fifo, freecount, ch,                             \
                            base, selector, ctxlimit)                       \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].contextDmaInMemory.SetDmaSpecifier.address[0] = (base); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].contextDmaInMemory.SetDmaSpecifier.address[1] = (selector); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].contextDmaInMemory.SetDmaSpecifier.limit = (ctxlimit); \
    freecount -= sizeSetDmaToMemory;                                        \
}

#define sizeSetDmaInMemoryContextNotifyMthdCnt      1
#define sizeSetDmaInMemoryContextNotify             (sizeSetDmaInMemoryContextNotifyMthdCnt * 4)
#define nvglSetDmaInMemoryContextNotify(fifo, freecount, ch,                \
                                       ctxdmanotify)                        \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].contextDmaInMemory.SetNotifyCtxDma = (ctxdmanotify); \
    freecount -= sizeSetDmaInMemoryContextNotify;                           \
}

#define sizeSetDmaInMemoryNotifyMthdCnt             4
#define sizeSetDmaInMemoryNotify                    (sizeSetDmaInMemoryNotifyMthdCnt * 4)
#define nvglSetDmaInMemoryNotify(fifo, freecount, ch,                       \
                                   base, selector, ctxlimit, notify)        \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].contextDmaInMemory.SetDmaSpecifier.address[0] = (base); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].contextDmaInMemory.SetDmaSpecifier.address[1] = (selector); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].contextDmaInMemory.SetNotify = (notify); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].contextDmaInMemory.SetDmaSpecifier.limit = (ctxlimit); \
    freecount -= sizeSetDmaInMemoryNotify;                                  \
}

/*
 * DrawRopRectAndText macros.
 */
#define sizeDrawRopRectAndTextColor1AMthdCnt        1 
#define sizeDrawRopRectAndTextColor1A               (sizeDrawRopRectAndTextColor1AMthdCnt * 4)
#define nvglDrawRopRectAndTextColor1A(fifo, freecount, ch, color)           \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4GdiRectangleText.Color1A = (color); \
    freecount -= sizeDrawRopRectAndTextColor1A;                             \
}

#define sizeDrawRopRectAndTextPointSizeMthdCnt      2
#define sizeDrawRopRectAndTextPointSize             (sizeDrawRopRectAndTextPointSizeMthdCnt * 4)
#define nvglDrawRopRectAndTextPointSize(fifo, freecount, ch,                \
                                        x, y, width, height)                \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4GdiRectangleText.UnclippedRectangle[0].point = ((((x) & 0x0000FFFF) << 16) | ((y) & 0x0000FFFF)); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4GdiRectangleText.UnclippedRectangle[0].size  = ((((width) & 0x0000FFFF) << 16) | ((height) & 0x0000FFFF)); \
    freecount -= sizeDrawRopRectAndTextPointSize;                           \
}

/*
 * Surfaces2D macros.
 */
#define sizeSet2DSurfacesContextsMthdCnt            2
#define sizeSet2DSurfacesContexts                   (sizeSet2DSurfacesContextsMthdCnt * 4)
#define nvglSet2DSurfacesContexts(fifo, freecount, ch, ctxsrc, ctxdest)     \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ContextSurfaces2D.SetContextDmaImageSource = (ctxsrc); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ContextSurfaces2D.SetContextDmaImageDestin = (ctxdest); \
    freecount -= sizeSet2DSurfacesContexts;                                 \
}

#define sizeSet2DSurfacesColorFormatMthdCnt         1
#define sizeSet2DSurfacesColorFormat                (sizeSet2DSurfacesColorFormatMthdCnt * 4)
#define nvglSet2DSurfacesColorFormat(fifo, freecount, ch, format)           \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ContextSurfaces2D.SetColorFormat = (format); \
    freecount -= sizeSet2DSurfacesColorFormat;                              \
}

#define sizeSet2DSurfacesDestinationMthdCnt         1
#define sizeSet2DSurfacesDestination                (sizeSet2DSurfacesDestinationMthdCnt * 4)
#define nvglSet2DSurfacesDestination(fifo, freecount, ch, offset)           \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ContextSurfaces2D.SetOffsetDestin = (offset); \
    freecount -= sizeSet2DSurfacesDestination;                              \
}

#define sizeSet2DSurfacesPitchMthdCnt               1
#define sizeSet2DSurfacesPitch                      (sizeSet2DSurfacesPitchMthdCnt * 4)
#define nvglSet2DSurfacesPitch(fifo, freecount, ch,                         \
                               srcpitch, dstpitch)                          \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ContextSurfaces2D.SetPitch = ((((dstpitch) & 0x0000FFFF) << 16) | ((srcpitch) & 0x0000FFFF)); \
    freecount -= sizeSet2DSurfacesPitch;                                    \
}

/*
 * Rop5 macros.
 */
#define sizeSetRop5MthdCnt                          1
#define sizeSetRop5                                 (sizeSetRop5MthdCnt * 4)
#define nvglSetRop5(fifo, freecount, ch, rop5)                              \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv3ContextRop.SetRop5 = (rop5); \
    freecount -= sizeSetRop5;                                               \
}

/*
 * Define the DMA jump operation.
 */
#define sizeDmaJump         0
#define nvglDmaJump(fifo, freecount, ch, offset)                            \
{                                                                           \
}

/*
 *
 */
#define nvglIdleKickoff(minsize)                                            \
{                                                                           \
}

#define DMA_PUSHER_SYNC()                                                   \
{                                                                           \
}
#endif  // D3D_CPU

#endif  // NV4
#endif  // _NV4DMAC_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\inc\NVD3DCAP.H ===
#ifndef _NVD3DCAP_H_
#define _NVD3DCAP_H_
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NVD3DCAP.H                                                        *
*   Define the capabilities of the NV D3D driver.                           *
*   This is mainly just a hardware selection include file.  The specific    *
*   hardware device capabilities are in the files:                          *
*   nv3dcaps.h, nv4dcaps.h, ...                                             *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/31/98 - created.                     *
*                                                                           *
\***************************************************************************/
/*
 * Select the NV3 hardware capabilities.
 */
#ifdef  NV3
#include    "nv3dcaps.h"

#define NV_DEVDESC_FLAGS            NV3_DEVDESC_FLAGS
#define NV_COLORMODEL               NV3_COLORMODEL
#define NV_DEVCAPS_FLAGS            NV3_DEVCAPS_FLAGS
#define NV_TRANSFORMCAPS            NV3_TRANSFORMCAPS
#define NV_3DCLIPPINGCAPS           NV3_3DCLIPPINGCAPS
#define NV_LIGHTINGCAPS             NV3_LIGHTINGCAPS
#define NV_LINECAPS                 NV3_LINECAPS
#define NV_TRICAPS                  NV3_TRICAPS
#define NV_RENDERBITDEPTHCAPS       NV3_RENDERBITDEPTHCAPS
#define NV_ZBUFFERBITDEPTHCAPS      NV3_ZBUFFERBITDEPTHCAPS
#define NV_MAXBUFFERSIZE            NV3_MAXBUFFERSIZE
#define NV_MAXVERTEXCOUNT           NV3_MAXVERTEXCOUNT
#endif  // NV3

/*
 * Select the NV4 hardware capabilities.
 */
#ifdef  NV4
#include    "nv4dcaps.h"

#define NV_DEVDESC_FLAGS            NV4_DEVDESC_FLAGS
#define NV_COLORMODEL               NV4_COLORMODEL
#define NV_DEVCAPS_FLAGS            NV4_DEVCAPS_FLAGS
#define NV_TRANSFORMCAPS            NV4_TRANSFORMCAPS
#define NV_3DCLIPPINGCAPS           NV4_3DCLIPPINGCAPS
#define NV_LIGHTINGCAPS             NV4_LIGHTINGCAPS
#define NV_LINECAPS                 NV4_LINECAPS
#define NV_TRICAPS                  NV4_TRICAPS
#define NV_RENDERBITDEPTHCAPS       NV4_RENDERBITDEPTHCAPS
#define NV_ZBUFFERBITDEPTHCAPS      NV4_ZBUFFERBITDEPTHCAPS
#define NV_MAXBUFFERSIZE            NV4_MAXBUFFERSIZE
#define NV_MAXVERTEXCOUNT           NV4_MAXVERTEXCOUNT
#endif  // NV4
#endif  // _NVD3DCAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\inc\nv4vxmac.h ===
/*
 * **** MACHINE GENERATED - DO NOT EDIT ****
 * **** MACHINE GENERATED - DO NOT EDIT ****
 * **** MACHINE GENERATED - DO NOT EDIT ****
 *
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */

/*
 * Inner Loop Prototypes and Vertex Macros
 */

/*
 * General Constants
 */
#define NV_FORCE_TRI_SETUP(_ctx) (_ctx)->dwFunctionLookup = NV_SETUP_FUNCTION_INDEX;

#ifdef NV_FASTLOOPS
#define NV_DX6_FUNCTION_ADJUST      2
#define NV_FIXED_FUNCTION_INDEX     1024
#define NV_AA_FUNCTION_INDEX        1024
#define NV_SETUP_FUNCTION_INDEX     1025
#else //!NV_FASTLOOPS
#define NV_AA_FUNCTION_INDEX        8
#define NV_SETUP_FUNCTION_INDEX     10
#endif //!NV_FASTLOOPS

#define sizeDX5TriangleVertex       9
#define sizeDx5TriangleTLVertex     sizeDX5TriangleVertex

#define sizeDX6TriangleVertex       11
#define sizeDx6TriangleTLVertex     sizeDX6TriangleVertex

#define LIST_STRIDES                0x00000303
#define STRIP_STRIDES               0x01010101
#define FAN_STRIDES                 0x02000001
#define LEGACY_STRIDES              0x03000404

#ifdef NV_FASTLOOPS

void __stdcall nvTriangleDispatch (DWORD, LPWORD, DWORD, LPBYTE);
void __stdcall nvDX5TriangleSetup (DWORD, LPWORD, DWORD, LPBYTE);
void __stdcall nvDX6TriangleSetup (DWORD, LPWORD, DWORD, LPBYTE);

extern DWORD dwDrawPrimitiveTable[];

#else //!NV_FASTLOOPS

/*
 * Inner Loop Prototypes
 */
void nvDX5Triangle                            ( WORD,         DWORD, LPD3DTLVERTEX);
void nvDX5TriangleExpFog                      ( WORD,         DWORD, LPD3DTLVERTEX);
void nvDX5TriangleExp2Fog                     ( WORD,         DWORD, LPD3DTLVERTEX);
void nvDX5TriangleLinearFog                   ( WORD,         DWORD, LPD3DTLVERTEX);
void nvDX5TriangleWBuf                        ( WORD,         DWORD, LPD3DTLVERTEX);
void nvDX5TriangleExpFogWBuf                  ( WORD,         DWORD, LPD3DTLVERTEX);
void nvDX5TriangleExp2FogWBuf                 ( WORD,         DWORD, LPD3DTLVERTEX);
void nvDX5TriangleLinearFogWBuf               ( WORD,         DWORD, LPD3DTLVERTEX);
void nvDX5TriangleIndexed                     (DWORD, LPWORD, DWORD, LPD3DTLVERTEX);
void nvDX5TriangleExpFogIndexed               (DWORD, LPWORD, DWORD, LPD3DTLVERTEX);
void nvDX5TriangleExp2FogIndexed              (DWORD, LPWORD, DWORD, LPD3DTLVERTEX);
void nvDX5TriangleLinearFogIndexed            (DWORD, LPWORD, DWORD, LPD3DTLVERTEX);
void nvDX5TriangleIndexedWBuf                 (DWORD, LPWORD, DWORD, LPD3DTLVERTEX);
void nvDX5TriangleExpFogIndexedWBuf           (DWORD, LPWORD, DWORD, LPD3DTLVERTEX);
void nvDX5TriangleExp2FogIndexedWBuf          (DWORD, LPWORD, DWORD, LPD3DTLVERTEX);
void nvDX5TriangleLinearFogIndexedWBuf        (DWORD, LPWORD, DWORD, LPD3DTLVERTEX);
void nvDX5TriangleAACapture                   ( WORD,         DWORD, LPD3DTLVERTEX);
void nvDX5TriangleAACaptureWBuf               ( WORD,         DWORD, LPD3DTLVERTEX);
void nvDX5TriangleIndexedAACapture            (DWORD, LPWORD, DWORD, LPD3DTLVERTEX);
void nvDX5TriangleIndexedAACaptureWBuf        (DWORD, LPWORD, DWORD, LPD3DTLVERTEX);
void nvDX5FlexTriangle                        ( WORD,         DWORD, LPBYTE);
void nvDX5FlexTriangleExpFog                  ( WORD,         DWORD, LPBYTE);
void nvDX5FlexTriangleExp2Fog                 ( WORD,         DWORD, LPBYTE);
void nvDX5FlexTriangleLinearFog               ( WORD,         DWORD, LPBYTE);
void nvDX5FlexTriangleWBuf                    ( WORD,         DWORD, LPBYTE);
void nvDX5FlexTriangleExpFogWBuf              ( WORD,         DWORD, LPBYTE);
void nvDX5FlexTriangleExp2FogWBuf             ( WORD,         DWORD, LPBYTE);
void nvDX5FlexTriangleLinearFogWBuf           ( WORD,         DWORD, LPBYTE);
void nvDX5FlexTriangleIndexed                 (DWORD, LPWORD, DWORD, LPBYTE);
void nvDX5FlexTriangleExpFogIndexed           (DWORD, LPWORD, DWORD, LPBYTE);
void nvDX5FlexTriangleExp2FogIndexed          (DWORD, LPWORD, DWORD, LPBYTE);
void nvDX5FlexTriangleLinearFogIndexed        (DWORD, LPWORD, DWORD, LPBYTE);
void nvDX5FlexTriangleIndexedWBuf             (DWORD, LPWORD, DWORD, LPBYTE);
void nvDX5FlexTriangleExpFogIndexedWBuf       (DWORD, LPWORD, DWORD, LPBYTE);
void nvDX5FlexTriangleExp2FogIndexedWBuf      (DWORD, LPWORD, DWORD, LPBYTE);
void nvDX5FlexTriangleLinearFogIndexedWBuf    (DWORD, LPWORD, DWORD, LPBYTE);
void nvDX5FlexTriangleAACapture               ( WORD,         DWORD, LPBYTE);
void nvDX5FlexTriangleAACaptureWBuf           ( WORD,         DWORD, LPBYTE);
void nvDX5FlexTriangleIndexedAACapture        (DWORD, LPWORD, DWORD, LPBYTE);
void nvDX5FlexTriangleIndexedAACaptureWBuf    (DWORD, LPWORD, DWORD, LPBYTE);
void nvDX6FlexTriangle                        ( WORD,         DWORD, LPBYTE);
void nvDX6FlexTriangleExpFog                  ( WORD,         DWORD, LPBYTE);
void nvDX6FlexTriangleExp2Fog                 ( WORD,         DWORD, LPBYTE);
void nvDX6FlexTriangleLinearFog               ( WORD,         DWORD, LPBYTE);
void nvDX6FlexTriangleWBuf                    ( WORD,         DWORD, LPBYTE);
void nvDX6FlexTriangleExpFogWBuf              ( WORD,         DWORD, LPBYTE);
void nvDX6FlexTriangleExp2FogWBuf             ( WORD,         DWORD, LPBYTE);
void nvDX6FlexTriangleLinearFogWBuf           ( WORD,         DWORD, LPBYTE);
void nvDX6FlexTriangleIndexed                 (DWORD, LPWORD, DWORD, LPBYTE);
void nvDX6FlexTriangleExpFogIndexed           (DWORD, LPWORD, DWORD, LPBYTE);
void nvDX6FlexTriangleExp2FogIndexed          (DWORD, LPWORD, DWORD, LPBYTE);
void nvDX6FlexTriangleLinearFogIndexed        (DWORD, LPWORD, DWORD, LPBYTE);
void nvDX6FlexTriangleIndexedWBuf             (DWORD, LPWORD, DWORD, LPBYTE);
void nvDX6FlexTriangleExpFogIndexedWBuf       (DWORD, LPWORD, DWORD, LPBYTE);
void nvDX6FlexTriangleExp2FogIndexedWBuf      (DWORD, LPWORD, DWORD, LPBYTE);
void nvDX6FlexTriangleLinearFogIndexedWBuf    (DWORD, LPWORD, DWORD, LPBYTE);
void nvDX6FlexTriangleAACapture               ( WORD,         DWORD, LPBYTE);
void nvDX6FlexTriangleAACaptureWBuf           ( WORD,         DWORD, LPBYTE);
void nvDX6FlexTriangleIndexedAACapture        (DWORD, LPWORD, DWORD, LPBYTE);
void nvDX6FlexTriangleIndexedAACaptureWBuf    (DWORD, LPWORD, DWORD, LPBYTE);

extern LPNVDRAWPRIM fnDX5Table[];
void nvDX5TriangleSetup  ( WORD,         DWORD, LPD3DTLVERTEX);
extern LPNVINDEXEDPRIM fnDX5IndexedTable[];
void nvDX5IndexedTriangleSetup  (DWORD, LPWORD, DWORD, LPD3DTLVERTEX);
extern LPNVFVFDRAWPRIM fnDX5FlexTable[];
void nvDX5FlexTriangleSetup  ( WORD,         DWORD, LPBYTE);
extern LPNVFVFINDEXEDPRIM fnDX5FlexIndexedTable[];
void nvDX5FlexIndexedTriangleSetup  (DWORD, LPWORD, DWORD, LPBYTE);
extern LPNVFVFDRAWPRIM fnDX6FlexTable[];
void nvDX6FlexTriangleSetup  ( WORD,         DWORD, LPBYTE);
extern LPNVFVFINDEXEDPRIM fnDX6FlexIndexedTable[];
void nvDX6FlexIndexedTriangleSetup  (DWORD, LPWORD, DWORD, LPBYTE);

#endif //!NV_FASTLOOPS
/*
 * Vertex Macros
 */

#define nvglDX5TriangleVertex(fifo,freecount,ch,alias,vertex)\
{\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    memcpy ((void*)(fifo + 4),(void*)(vertex),32);\
    dbgDisplayVertexData(((DWORD*)nvFifo)[1],((DWORD*)nvFifo)[2],((DWORD*)nvFifo)[3],\
                         ((DWORD*)nvFifo)[4],((DWORD*)nvFifo)[5],((DWORD*)nvFifo)[6],\
                         ((DWORD*)nvFifo)[7],((DWORD*)nvFifo)[8]);\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5TriangleVertexExpFog(fifo,freecount,ch,alias,vertex)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = (*(DWORD*)(vertex + 12));\
    *(DWORD*)(fifo + 16) = dwrhw = dwTemp;\
    *(DWORD*)(fifo + 20) = (*(DWORD*)(vertex + 16));\
    dwTemp = (*(DWORD*)(vertex + 20));\
    zmask = ((*(DWORD *)&(pCurrentContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pCurrentContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = *(float*)&dwrhw;\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = *(float *)&dwz;\
    ffog  = fz * pCurrentContext->fFogTableDensity;\
    FP_EXP (ffog,ffog);\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    *(DWORD*)(fifo + 28) = (*(DWORD*)(vertex + 24));\
    *(DWORD*)(fifo + 32) = (*(DWORD*)(vertex + 28));\
    dbgDisplayVertexData(((DWORD*)nvFifo)[1],((DWORD*)nvFifo)[2],((DWORD*)nvFifo)[3],\
                         ((DWORD*)nvFifo)[4],((DWORD*)nvFifo)[5],((DWORD*)nvFifo)[6],\
                         ((DWORD*)nvFifo)[7],((DWORD*)nvFifo)[8]);\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5TriangleVertexExp2Fog(fifo,freecount,ch,alias,vertex)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = (*(DWORD*)(vertex + 12));\
    *(DWORD*)(fifo + 16) = dwrhw = dwTemp;\
    *(DWORD*)(fifo + 20) = (*(DWORD*)(vertex + 16));\
    dwTemp = (*(DWORD*)(vertex + 20));\
    zmask = ((*(DWORD *)&(pCurrentContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pCurrentContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = *(float*)&dwrhw;\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = *(float *)&dwz;\
    ffog  = fz * pCurrentContext->fFogTableDensity;\
    ffog *= ffog;\
    FP_EXP (ffog,ffog);\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    *(DWORD*)(fifo + 28) = (*(DWORD*)(vertex + 24));\
    *(DWORD*)(fifo + 32) = (*(DWORD*)(vertex + 28));\
    dbgDisplayVertexData(((DWORD*)nvFifo)[1],((DWORD*)nvFifo)[2],((DWORD*)nvFifo)[3],\
                         ((DWORD*)nvFifo)[4],((DWORD*)nvFifo)[5],((DWORD*)nvFifo)[6],\
                         ((DWORD*)nvFifo)[7],((DWORD*)nvFifo)[8]);\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5TriangleVertexLinearFog(fifo,freecount,ch,alias,vertex)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = (*(DWORD*)(vertex + 12));\
    *(DWORD*)(fifo + 16) = dwrhw = dwTemp;\
    *(DWORD*)(fifo + 20) = (*(DWORD*)(vertex + 16));\
    dwTemp = (*(DWORD*)(vertex + 20));\
    zmask = ((*(DWORD *)&(pCurrentContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pCurrentContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = *(float*)&dwrhw;\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = *(float *)&dwz;\
    ffog = (fz >= pCurrentContext->fFogTableEnd) ? 0.0f :\
           (fz <= pCurrentContext->fFogTableStart) ? 1.0f :\
           (pCurrentContext->fFogTableEnd - fz) * pCurrentContext->fFogTableLinearScale;\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    *(DWORD*)(fifo + 28) = (*(DWORD*)(vertex + 24));\
    *(DWORD*)(fifo + 32) = (*(DWORD*)(vertex + 28));\
    dbgDisplayVertexData(((DWORD*)nvFifo)[1],((DWORD*)nvFifo)[2],((DWORD*)nvFifo)[3],\
                         ((DWORD*)nvFifo)[4],((DWORD*)nvFifo)[5],((DWORD*)nvFifo)[6],\
                         ((DWORD*)nvFifo)[7],((DWORD*)nvFifo)[8]);\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5TriangleVertexWBuf(fifo,freecount,ch,alias,vertex)\
{\
    DWORD dwTemp;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = (*(DWORD*)(vertex +  8));\
    dwTemp = (*(DWORD*)(vertex + 12));\
    frhw = (*(float*)&dwTemp) * pCurrentContext->dvRWFar;\
    *(DWORD*)(fifo + 16) = *(DWORD*)&frhw;\
    *(DWORD*)(fifo + 20) = (*(DWORD*)(vertex + 16));\
    dwTemp = (*(DWORD*)(vertex + 20));\
    *(DWORD*)(fifo + 24) = dwTemp;\
    *(DWORD*)(fifo + 28) = (*(DWORD*)(vertex + 24));\
    *(DWORD*)(fifo + 32) = (*(DWORD*)(vertex + 28));\
    dbgDisplayVertexData(((DWORD*)nvFifo)[1],((DWORD*)nvFifo)[2],((DWORD*)nvFifo)[3],\
                         ((DWORD*)nvFifo)[4],((DWORD*)nvFifo)[5],((DWORD*)nvFifo)[6],\
                         ((DWORD*)nvFifo)[7],((DWORD*)nvFifo)[8]);\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5TriangleVertexExpFogWBuf(fifo,freecount,ch,alias,vertex)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = (*(DWORD*)(vertex + 12));\
    frhw = (*(float*)&dwTemp) * pCurrentContext->dvRWFar;\
    *(DWORD*)(fifo + 16) = dwrhw = *(DWORD*)&frhw;\
    *(DWORD*)(fifo + 20) = (*(DWORD*)(vertex + 16));\
    dwTemp = (*(DWORD*)(vertex + 20));\
    zmask = ((*(DWORD *)&(pCurrentContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pCurrentContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = *(float*)&dwrhw;\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = *(float *)&dwz;\
    ffog  = fz * pCurrentContext->fFogTableDensity;\
    FP_EXP (ffog,ffog);\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    *(DWORD*)(fifo + 28) = (*(DWORD*)(vertex + 24));\
    *(DWORD*)(fifo + 32) = (*(DWORD*)(vertex + 28));\
    dbgDisplayVertexData(((DWORD*)nvFifo)[1],((DWORD*)nvFifo)[2],((DWORD*)nvFifo)[3],\
                         ((DWORD*)nvFifo)[4],((DWORD*)nvFifo)[5],((DWORD*)nvFifo)[6],\
                         ((DWORD*)nvFifo)[7],((DWORD*)nvFifo)[8]);\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5TriangleVertexExp2FogWBuf(fifo,freecount,ch,alias,vertex)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = (*(DWORD*)(vertex + 12));\
    frhw = (*(float*)&dwTemp) * pCurrentContext->dvRWFar;\
    *(DWORD*)(fifo + 16) = dwrhw = *(DWORD*)&frhw;\
    *(DWORD*)(fifo + 20) = (*(DWORD*)(vertex + 16));\
    dwTemp = (*(DWORD*)(vertex + 20));\
    zmask = ((*(DWORD *)&(pCurrentContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pCurrentContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = *(float*)&dwrhw;\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = *(float *)&dwz;\
    ffog  = fz * pCurrentContext->fFogTableDensity;\
    ffog *= ffog;\
    FP_EXP (ffog,ffog);\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    *(DWORD*)(fifo + 28) = (*(DWORD*)(vertex + 24));\
    *(DWORD*)(fifo + 32) = (*(DWORD*)(vertex + 28));\
    dbgDisplayVertexData(((DWORD*)nvFifo)[1],((DWORD*)nvFifo)[2],((DWORD*)nvFifo)[3],\
                         ((DWORD*)nvFifo)[4],((DWORD*)nvFifo)[5],((DWORD*)nvFifo)[6],\
                         ((DWORD*)nvFifo)[7],((DWORD*)nvFifo)[8]);\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5TriangleVertexLinearFogWBuf(fifo,freecount,ch,alias,vertex)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = (*(DWORD*)(vertex + 12));\
    frhw = (*(float*)&dwTemp) * pCurrentContext->dvRWFar;\
    *(DWORD*)(fifo + 16) = dwrhw = *(DWORD*)&frhw;\
    *(DWORD*)(fifo + 20) = (*(DWORD*)(vertex + 16));\
    dwTemp = (*(DWORD*)(vertex + 20));\
    zmask = ((*(DWORD *)&(pCurrentContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pCurrentContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = *(float*)&dwrhw;\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = *(float *)&dwz;\
    ffog = (fz >= pCurrentContext->fFogTableEnd) ? 0.0f :\
           (fz <= pCurrentContext->fFogTableStart) ? 1.0f :\
           (pCurrentContext->fFogTableEnd - fz) * pCurrentContext->fFogTableLinearScale;\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    *(DWORD*)(fifo + 28) = (*(DWORD*)(vertex + 24));\
    *(DWORD*)(fifo + 32) = (*(DWORD*)(vertex + 28));\
    dbgDisplayVertexData(((DWORD*)nvFifo)[1],((DWORD*)nvFifo)[2],((DWORD*)nvFifo)[3],\
                         ((DWORD*)nvFifo)[4],((DWORD*)nvFifo)[5],((DWORD*)nvFifo)[6],\
                         ((DWORD*)nvFifo)[7],((DWORD*)nvFifo)[8]);\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5FlexTriangleVertex(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    *(DWORD*)(fifo + 16) = dwTemp;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwARGBMask) + fvf.dwARGBOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset;\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    dbgDisplayVertexData(((DWORD*)nvFifo)[1],((DWORD*)nvFifo)[2],((DWORD*)nvFifo)[3],\
                         ((DWORD*)nvFifo)[4],((DWORD*)nvFifo)[5],((DWORD*)nvFifo)[6],\
                         ((DWORD*)nvFifo)[7],((DWORD*)nvFifo)[8]);\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5FlexTriangleVertexExpFog(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    *(DWORD*)(fifo + 16) = dwrhw = dwTemp;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwARGBMask) + fvf.dwARGBOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    zmask = ((*(DWORD *)&(pCurrentContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pCurrentContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = *(float*)&dwrhw;\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = *(float *)&dwz;\
    ffog  = fz * pCurrentContext->fFogTableDensity;\
    FP_EXP (ffog,ffog);\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset;\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    dbgDisplayVertexData(((DWORD*)nvFifo)[1],((DWORD*)nvFifo)[2],((DWORD*)nvFifo)[3],\
                         ((DWORD*)nvFifo)[4],((DWORD*)nvFifo)[5],((DWORD*)nvFifo)[6],\
                         ((DWORD*)nvFifo)[7],((DWORD*)nvFifo)[8]);\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5FlexTriangleVertexExp2Fog(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    *(DWORD*)(fifo + 16) = dwrhw = dwTemp;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwARGBMask) + fvf.dwARGBOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    zmask = ((*(DWORD *)&(pCurrentContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pCurrentContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = *(float*)&dwrhw;\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = *(float *)&dwz;\
    ffog  = fz * pCurrentContext->fFogTableDensity;\
    ffog *= ffog;\
    FP_EXP (ffog,ffog);\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset;\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    dbgDisplayVertexData(((DWORD*)nvFifo)[1],((DWORD*)nvFifo)[2],((DWORD*)nvFifo)[3],\
                         ((DWORD*)nvFifo)[4],((DWORD*)nvFifo)[5],((DWORD*)nvFifo)[6],\
                         ((DWORD*)nvFifo)[7],((DWORD*)nvFifo)[8]);\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5FlexTriangleVertexLinearFog(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    *(DWORD*)(fifo + 16) = dwrhw = dwTemp;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwARGBMask) + fvf.dwARGBOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    zmask = ((*(DWORD *)&(pCurrentContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pCurrentContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = *(float*)&dwrhw;\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = *(float *)&dwz;\
    ffog = (fz >= pCurrentContext->fFogTableEnd) ? 0.0f :\
           (fz <= pCurrentContext->fFogTableStart) ? 1.0f :\
           (pCurrentContext->fFogTableEnd - fz) * pCurrentContext->fFogTableLinearScale;\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset;\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    dbgDisplayVertexData(((DWORD*)nvFifo)[1],((DWORD*)nvFifo)[2],((DWORD*)nvFifo)[3],\
                         ((DWORD*)nvFifo)[4],((DWORD*)nvFifo)[5],((DWORD*)nvFifo)[6],\
                         ((DWORD*)nvFifo)[7],((DWORD*)nvFifo)[8]);\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5FlexTriangleVertexWBuf(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    frhw = (*(float*)&dwTemp) * pCurrentContext->dvRWFar;\
    *(DWORD*)(fifo + 16) = *(DWORD*)&frhw;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwARGBMask) + fvf.dwARGBOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset;\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    dbgDisplayVertexData(((DWORD*)nvFifo)[1],((DWORD*)nvFifo)[2],((DWORD*)nvFifo)[3],\
                         ((DWORD*)nvFifo)[4],((DWORD*)nvFifo)[5],((DWORD*)nvFifo)[6],\
                         ((DWORD*)nvFifo)[7],((DWORD*)nvFifo)[8]);\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5FlexTriangleVertexExpFogWBuf(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    frhw = (*(float*)&dwTemp) * pCurrentContext->dvRWFar;\
    *(DWORD*)(fifo + 16) = dwrhw = *(DWORD*)&frhw;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwARGBMask) + fvf.dwARGBOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    zmask = ((*(DWORD *)&(pCurrentContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pCurrentContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = *(float*)&dwrhw;\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = *(float *)&dwz;\
    ffog  = fz * pCurrentContext->fFogTableDensity;\
    FP_EXP (ffog,ffog);\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset;\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    dbgDisplayVertexData(((DWORD*)nvFifo)[1],((DWORD*)nvFifo)[2],((DWORD*)nvFifo)[3],\
                         ((DWORD*)nvFifo)[4],((DWORD*)nvFifo)[5],((DWORD*)nvFifo)[6],\
                         ((DWORD*)nvFifo)[7],((DWORD*)nvFifo)[8]);\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5FlexTriangleVertexExp2FogWBuf(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    frhw = (*(float*)&dwTemp) * pCurrentContext->dvRWFar;\
    *(DWORD*)(fifo + 16) = dwrhw = *(DWORD*)&frhw;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwARGBMask) + fvf.dwARGBOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    zmask = ((*(DWORD *)&(pCurrentContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pCurrentContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = *(float*)&dwrhw;\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = *(float *)&dwz;\
    ffog  = fz * pCurrentContext->fFogTableDensity;\
    ffog *= ffog;\
    FP_EXP (ffog,ffog);\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset;\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    dbgDisplayVertexData(((DWORD*)nvFifo)[1],((DWORD*)nvFifo)[2],((DWORD*)nvFifo)[3],\
                         ((DWORD*)nvFifo)[4],((DWORD*)nvFifo)[5],((DWORD*)nvFifo)[6],\
                         ((DWORD*)nvFifo)[7],((DWORD*)nvFifo)[8]);\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5FlexTriangleVertexLinearFogWBuf(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    frhw = (*(float*)&dwTemp) * pCurrentContext->dvRWFar;\
    *(DWORD*)(fifo + 16) = dwrhw = *(DWORD*)&frhw;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwARGBMask) + fvf.dwARGBOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    zmask = ((*(DWORD *)&(pCurrentContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pCurrentContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = *(float*)&dwrhw;\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = *(float *)&dwz;\
    ffog = (fz >= pCurrentContext->fFogTableEnd) ? 0.0f :\
           (fz <= pCurrentContext->fFogTableStart) ? 1.0f :\
           (pCurrentContext->fFogTableEnd - fz) * pCurrentContext->fFogTableLinearScale;\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset;\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    dbgDisplayVertexData(((DWORD*)nvFifo)[1],((DWORD*)nvFifo)[2],((DWORD*)nvFifo)[3],\
                         ((DWORD*)nvFifo)[4],((DWORD*)nvFifo)[5],((DWORD*)nvFifo)[6],\
                         ((DWORD*)nvFifo)[7],((DWORD*)nvFifo)[8]);\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX6FlexTriangleVertex(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    *(DWORD*)(fifo +  0) = ((sizeDX6TriangleVertex-1)<<18) | ((ch)<<13) | NV055_TLMTVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    *(DWORD*)(fifo + 16) = dwTemp;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwARGBMask) + fvf.dwARGBOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset;\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    *(DWORD*)(fifo + 36) = *(DWORD*)(dwTemp + (uvoff)[1] + 0);\
    *(DWORD*)(fifo + 40) = *(DWORD*)(dwTemp + (uvoff)[1] + 4);\
    dbgDisplayVertexData(((DWORD*)nvFifo)[1],((DWORD*)nvFifo)[2],((DWORD*)nvFifo)[3],\
                         ((DWORD*)nvFifo)[4],((DWORD*)nvFifo)[5],((DWORD*)nvFifo)[6],\
                         ((DWORD*)nvFifo)[7],((DWORD*)nvFifo)[8]);\
    fifo      += sizeDX6TriangleVertex * 4;\
    freecount -= sizeDX6TriangleVertex;\
}

#define nvglDX6FlexTriangleVertexExpFog(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX6TriangleVertex-1)<<18) | ((ch)<<13) | NV055_TLMTVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    *(DWORD*)(fifo + 16) = dwrhw = dwTemp;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwARGBMask) + fvf.dwARGBOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    zmask = ((*(DWORD *)&(pCurrentContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pCurrentContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = *(float*)&dwrhw;\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = *(float *)&dwz;\
    ffog  = fz * pCurrentContext->fFogTableDensity;\
    FP_EXP (ffog,ffog);\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset;\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    *(DWORD*)(fifo + 36) = *(DWORD*)(dwTemp + (uvoff)[1] + 0);\
    *(DWORD*)(fifo + 40) = *(DWORD*)(dwTemp + (uvoff)[1] + 4);\
    dbgDisplayVertexData(((DWORD*)nvFifo)[1],((DWORD*)nvFifo)[2],((DWORD*)nvFifo)[3],\
                         ((DWORD*)nvFifo)[4],((DWORD*)nvFifo)[5],((DWORD*)nvFifo)[6],\
                         ((DWORD*)nvFifo)[7],((DWORD*)nvFifo)[8]);\
    fifo      += sizeDX6TriangleVertex * 4;\
    freecount -= sizeDX6TriangleVertex;\
}

#define nvglDX6FlexTriangleVertexExp2Fog(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX6TriangleVertex-1)<<18) | ((ch)<<13) | NV055_TLMTVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    *(DWORD*)(fifo + 16) = dwrhw = dwTemp;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwARGBMask) + fvf.dwARGBOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    zmask = ((*(DWORD *)&(pCurrentContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pCurrentContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = *(float*)&dwrhw;\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = *(float *)&dwz;\
    ffog  = fz * pCurrentContext->fFogTableDensity;\
    ffog *= ffog;\
    FP_EXP (ffog,ffog);\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset;\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    *(DWORD*)(fifo + 36) = *(DWORD*)(dwTemp + (uvoff)[1] + 0);\
    *(DWORD*)(fifo + 40) = *(DWORD*)(dwTemp + (uvoff)[1] + 4);\
    dbgDisplayVertexData(((DWORD*)nvFifo)[1],((DWORD*)nvFifo)[2],((DWORD*)nvFifo)[3],\
                         ((DWORD*)nvFifo)[4],((DWORD*)nvFifo)[5],((DWORD*)nvFifo)[6],\
                         ((DWORD*)nvFifo)[7],((DWORD*)nvFifo)[8]);\
    fifo      += sizeDX6TriangleVertex * 4;\
    freecount -= sizeDX6TriangleVertex;\
}

#define nvglDX6FlexTriangleVertexLinearFog(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX6TriangleVertex-1)<<18) | ((ch)<<13) | NV055_TLMTVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    *(DWORD*)(fifo + 16) = dwrhw = dwTemp;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwARGBMask) + fvf.dwARGBOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    zmask = ((*(DWORD *)&(pCurrentContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pCurrentContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = *(float*)&dwrhw;\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = *(float *)&dwz;\
    ffog = (fz >= pCurrentContext->fFogTableEnd) ? 0.0f :\
           (fz <= pCurrentContext->fFogTableStart) ? 1.0f :\
           (pCurrentContext->fFogTableEnd - fz) * pCurrentContext->fFogTableLinearScale;\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset;\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    *(DWORD*)(fifo + 36) = *(DWORD*)(dwTemp + (uvoff)[1] + 0);\
    *(DWORD*)(fifo + 40) = *(DWORD*)(dwTemp + (uvoff)[1] + 4);\
    dbgDisplayVertexData(((DWORD*)nvFifo)[1],((DWORD*)nvFifo)[2],((DWORD*)nvFifo)[3],\
                         ((DWORD*)nvFifo)[4],((DWORD*)nvFifo)[5],((DWORD*)nvFifo)[6],\
                         ((DWORD*)nvFifo)[7],((DWORD*)nvFifo)[8]);\
    fifo      += sizeDX6TriangleVertex * 4;\
    freecount -= sizeDX6TriangleVertex;\
}

#define nvglDX6FlexTriangleVertexWBuf(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX6TriangleVertex-1)<<18) | ((ch)<<13) | NV055_TLMTVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    frhw = (*(float*)&dwTemp) * pCurrentContext->dvRWFar;\
    *(DWORD*)(fifo + 16) = *(DWORD*)&frhw;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwARGBMask) + fvf.dwARGBOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset;\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    *(DWORD*)(fifo + 36) = *(DWORD*)(dwTemp + (uvoff)[1] + 0);\
    *(DWORD*)(fifo + 40) = *(DWORD*)(dwTemp + (uvoff)[1] + 4);\
    dbgDisplayVertexData(((DWORD*)nvFifo)[1],((DWORD*)nvFifo)[2],((DWORD*)nvFifo)[3],\
                         ((DWORD*)nvFifo)[4],((DWORD*)nvFifo)[5],((DWORD*)nvFifo)[6],\
                         ((DWORD*)nvFifo)[7],((DWORD*)nvFifo)[8]);\
    fifo      += sizeDX6TriangleVertex * 4;\
    freecount -= sizeDX6TriangleVertex;\
}

#define nvglDX6FlexTriangleVertexExpFogWBuf(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX6TriangleVertex-1)<<18) | ((ch)<<13) | NV055_TLMTVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    frhw = (*(float*)&dwTemp) * pCurrentContext->dvRWFar;\
    *(DWORD*)(fifo + 16) = dwrhw = *(DWORD*)&frhw;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwARGBMask) + fvf.dwARGBOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    zmask = ((*(DWORD *)&(pCurrentContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pCurrentContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = *(float*)&dwrhw;\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = *(float *)&dwz;\
    ffog  = fz * pCurrentContext->fFogTableDensity;\
    FP_EXP (ffog,ffog);\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset;\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    *(DWORD*)(fifo + 36) = *(DWORD*)(dwTemp + (uvoff)[1] + 0);\
    *(DWORD*)(fifo + 40) = *(DWORD*)(dwTemp + (uvoff)[1] + 4);\
    dbgDisplayVertexData(((DWORD*)nvFifo)[1],((DWORD*)nvFifo)[2],((DWORD*)nvFifo)[3],\
                         ((DWORD*)nvFifo)[4],((DWORD*)nvFifo)[5],((DWORD*)nvFifo)[6],\
                         ((DWORD*)nvFifo)[7],((DWORD*)nvFifo)[8]);\
    fifo      += sizeDX6TriangleVertex * 4;\
    freecount -= sizeDX6TriangleVertex;\
}

#define nvglDX6FlexTriangleVertexExp2FogWBuf(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX6TriangleVertex-1)<<18) | ((ch)<<13) | NV055_TLMTVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    frhw = (*(float*)&dwTemp) * pCurrentContext->dvRWFar;\
    *(DWORD*)(fifo + 16) = dwrhw = *(DWORD*)&frhw;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwARGBMask) + fvf.dwARGBOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    zmask = ((*(DWORD *)&(pCurrentContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pCurrentContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = *(float*)&dwrhw;\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = *(float *)&dwz;\
    ffog  = fz * pCurrentContext->fFogTableDensity;\
    ffog *= ffog;\
    FP_EXP (ffog,ffog);\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset;\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    *(DWORD*)(fifo + 36) = *(DWORD*)(dwTemp + (uvoff)[1] + 0);\
    *(DWORD*)(fifo + 40) = *(DWORD*)(dwTemp + (uvoff)[1] + 4);\
    dbgDisplayVertexData(((DWORD*)nvFifo)[1],((DWORD*)nvFifo)[2],((DWORD*)nvFifo)[3],\
                         ((DWORD*)nvFifo)[4],((DWORD*)nvFifo)[5],((DWORD*)nvFifo)[6],\
                         ((DWORD*)nvFifo)[7],((DWORD*)nvFifo)[8]);\
    fifo      += sizeDX6TriangleVertex * 4;\
    freecount -= sizeDX6TriangleVertex;\
}

#define nvglDX6FlexTriangleVertexLinearFogWBuf(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX6TriangleVertex-1)<<18) | ((ch)<<13) | NV055_TLMTVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    frhw = (*(float*)&dwTemp) * pCurrentContext->dvRWFar;\
    *(DWORD*)(fifo + 16) = dwrhw = *(DWORD*)&frhw;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwARGBMask) + fvf.dwARGBOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    zmask = ((*(DWORD *)&(pCurrentContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pCurrentContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = *(float*)&dwrhw;\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = *(float *)&dwz;\
    ffog = (fz >= pCurrentContext->fFogTableEnd) ? 0.0f :\
           (fz <= pCurrentContext->fFogTableStart) ? 1.0f :\
           (pCurrentContext->fFogTableEnd - fz) * pCurrentContext->fFogTableLinearScale;\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset;\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    *(DWORD*)(fifo + 36) = *(DWORD*)(dwTemp + (uvoff)[1] + 0);\
    *(DWORD*)(fifo + 40) = *(DWORD*)(dwTemp + (uvoff)[1] + 4);\
    dbgDisplayVertexData(((DWORD*)nvFifo)[1],((DWORD*)nvFifo)[2],((DWORD*)nvFifo)[3],\
                         ((DWORD*)nvFifo)[4],((DWORD*)nvFifo)[5],((DWORD*)nvFifo)[6],\
                         ((DWORD*)nvFifo)[7],((DWORD*)nvFifo)[8]);\
    fifo      += sizeDX6TriangleVertex * 4;\
    freecount -= sizeDX6TriangleVertex;\
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\inc\nvHeap.h ===
#ifndef _NV_HEAP_H
#define _NV_HEAP_H

/*
 * heap manager interface
 */
#ifdef  MULTI_MON
#include "nvrmapi.h"
#include "nvrmarch.inc"
#endif  // MULTI_MON

#ifdef NVHEAPMGR
#define AGP_HEAP 0
#else
#define AGP_HEAP 1
#endif

#ifdef NVHEAPMGR
#ifdef MULTI_MON
static NVIOControl_Param HeapParams;
#else   // !MULTI_MON
static struct
{
  U032 function;
  U032 device;
  U032 owner;
  U032 type;
  U032 depth;
  U032 width;
  U032 height;
  S032 pitch;
  U032 offset;
  U032 size;
  U032 address;
  U032 limit;
  U032 total;
  U032 free;
  V032 status;
} HeapParams;
#endif  // !MULTI_MON
#endif  // NVHEAPMGR

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\inc\NVD3DMAC.H ===
#ifndef _NVD3DMAC_H_
#define _NVD3DMAC_H_
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NVD3DMAC.H                                                        *
*   Define various macros used in the D3D driver.                           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/31/98 - Created.                     *
*                                                                           *
\***************************************************************************/
#ifdef  NV4
#include    "nv4dmac.h"
#endif

/*
 * Global memory allocation macros.
 */
#ifdef  WINNT
#define HEAPCREATE(nop)                 (!NULL)
#define HEAPDESTROY(heap)               ((heap) = NULL)
#define HEAPALLOC(nop, size)            EngAllocMem(FL_ZERO_MEMORY, (size), 'amxD')
#define HEAPFREE(nop, ptr)              { \
    if (ptr != NULL)            \
    {                           \
    EngFreeMem((ptr));          \
    (ptr) = NULL;               \
    }                           \
}
#define HEAPREALLOC(nop, ptr, size)     {   \
                                            HEAPFREE(nop, (ptr)); \
                                            (ptr) = HEAPALLOC(nop, size); \
                                        }
/*
 * User mode memory allocation functions. There are no Globalxxx fcts in NT
 * kernel mode.
 */
#define GlobalAlloc(nop, size)  \
    EngAllocUserMem((size), 'amxD')
#define GlobalLock(ptr)  (ptr)
#define GlobalUnlock(nop)
#define GlobalFree(ptr)         \
    {                           \
    if (ptr != NULL)            \
    {                           \
    EngFreeUserMem(ptr);        \
    (ptr) = NULL;               \
    }                           \
    }
#else   // !WINNT
#define HEAPCREATE(size)                HeapCreate(HEAP_SHARED, (size), 0)
#define HEAPDESTROY(handle)             HeapDestroy((HANDLE)(handle))
#define HEAPALLOC(handle, size)         HeapAlloc((HANDLE)(handle), HEAP_ZERO_MEMORY, (size))
#define HEAPFREE(handle, ptr)           HeapFree((HANDLE)(handle), 0, (VOID *)(ptr))
#define HEAPREALLOC(handle, ptr, size)  (ptr) = HeapReAlloc((HANDLE)(handle), 0, (ptr), (size))

#endif  // !WINNT

/*
 * Convert th FP representation into a DWORD.  Used for magnitude comparisons.
 */
#define FP_BITS(fp) (*(DWORD *)&(fp))
#define FP_ABS_BITS(fp) (FP_BITS(fp)&0x7FFFFFFF)
#define FP_SIGN_BIT(fp) (FP_BITS(fp)&0x80000000)
#define FP_ONE_BITS 0x3F800000
/*
 * Some FP macros used in table fog. Thanks Jim!
 */
#define FP_INV(r,p)                                                          \
{                                                                            \
    int _i = 2 * FP_ONE_BITS - *(int *)&(p);                                 \
    r = *(float *)&_i;                                                       \
    r = r * (2.0f - (p) * r);                                                \
}
#define FP_EXP(e,p)                                                          \
{                                                                            \
    int _i;                                                                  \
    e = -1.44269504f * (float)0x00800000 * (p);                              \
    _i = (int)e + 0x3F800000;                                                \
    e = *(float *)&_i;                                                       \
}
#define FP_NORM_TO_BYTE(i,p)                                                 \
{                                                                            \
    float _n = (p) + 1.0f;                                                   \
    (i) = *(int *)&_n;                                                       \
    if ((i) >= 0x40000000)     (i) = 0xFF;                                   \
    else if ((i) <=0x3F800000) (i) = 0;                                      \
    else (i) = ((i) >> 15) & 0xFF;                                           \
}

/*
 * D3D state macros.
 */

#define IS_OVERRIDE(type)       ((DWORD)(type) > D3DSTATE_OVERRIDE_BIAS)
#define GET_OVERRIDE(type)      ((DWORD)(type) - D3DSTATE_OVERRIDE_BIAS)

#define STATESET_MASK(set, state)                                           \
        (set).bits[((state) - 1) >> DWORD_SHIFT]

#define STATESET_BIT(state)     (1 << (((state) - 1) & (DWORD_BITS - 1)))

#define STATESET_ISSET(set, state)                                          \
        STATESET_MASK(set, state) & STATESET_BIT(state)

#define STATESET_SET(set, state)                                            \
        STATESET_MASK(set, state) |= STATESET_BIT(state)

#define STATESET_CLEAR(set, state)                                          \
        STATESET_MASK(set, state) &= ~STATESET_BIT(state)

#define STATESET_INIT(set)      memset(&(set), 0, sizeof(set))

#if 0
/*
 * Memory management macros.
 */
#define GlobalUnlockPtr32(lp)                                               \
        GlobalUnlock(GlobalHandle((LPCVOID)lp))

#define GlobalAllocPtr32(flags, cb)                                         \
        (GlobalLock(GlobalAlloc((flags), (cb))))

#define GlobalFreePtr32(lp)                                                 \
        (GlobalUnlockPtr32(lp), (BOOL)GlobalFree(GlobalHandle((LPCVOID)lp)))
#endif

#ifdef  DO_XF_LIGHT
// TODO move dwCurrentPipelineHandle into pDriverData structure
// TODO move dwCurrentPipelinePtr into pDriverData structure
#define GET_PIPELINE_PTR(ptr, harray, hpipeline)                            \
{                                                                           \
    if ((hpipeline) != dwCurrentPipelineHandle)                             \
    {                                                                       \
        (ptr) = (PNVD3DPIPELINE)DDrvItemArrayGetPtr((harray), (HDDRVITEM)(hpipeline));\
        dwCurrentPipelineHandle = (DWORD)(hpipeline);                       \
        dwCurrentPipelinePtr    = (DWORD)(ptr);                             \
    }                                                                       \
    else                                                                    \
        (ptr) = (PNVD3DPIPELINE)dwCurrentPipelinePtr;                       \
}

#define DESTROY_PIPELINES_FROM_PROCESS(pid)                                 \
{                                                                           \
    DDrvItemArrayApplyValid(pDriverData->hPipelines_gbl,                    \
                            DestroyPipelineProcessCallback,                 \
                            pid);                                           \
}

#define DESTROY_PIPELINES_FROM_CONTEXT(hctx)                                \
{                                                                           \
    DDrvItemArrayApplyValid(pDriverData->hPipelines_gbl,                    \
                            DestroyPipelineContextCallback,                 \
                            hctx);                                          \
}

// TODO move dwCurrentMaterialHandle into pDriverData structure
// TODO move dwCurrentMaterialPtr into pDriverData structure
#define GET_MATERIAL_PTR(ptr, harray, hmaterial)                            \
{                                                                           \
    if ((hmaterial) != dwCurrentMaterialHandle)                             \
    {                                                                       \
        (ptr) = (PNVD3DMATERIAL)DDrvItemArrayGetPtr((harray), (HDDRVITEM)(hmaterial));\
        dwCurrentMaterialHandle = (DWORD)(hmaterial);                       \
        dwCurrentMaterialPtr    = (DWORD)(ptr);                             \
    }                                                                       \
    else                                                                    \
        (ptr) = (PNVD3DMATERIAL)dwCurrentMaterialPtr;                       \
}

#define DESTROY_MATERIALS_FROM_PROCESS(pid)                                 \
{                                                                           \
    DDrvItemArrayApplyValid(pDriverData->hMaterials_gbl,                    \
                            DestroyMaterialProcessCallback,                 \
                            pid);                                           \
}

#define DESTROY_MATERIALS_FROM_CONTEXT(hctx)                                \
{                                                                           \
    DDrvItemArrayApplyValid(pDriverData->hMaterials_gbl,                    \
                            DestroyMaterialContextCallback,                 \
                            hctx);                                          \
}

#endif  // DO_XF_LIGHT

#ifndef WINNT
#define NV_LOCK_TEXTURE_SURFACE(pTex)
#define NV_UNLOCK_TEXTURE_SURFACE(pTex)
#else
#define NV_LOCK_TEXTURE_SURFACE(pTex) \
    pTex->lpLcl = EngLockDirectDrawSurface(pTex->hDDS)

#define NV_UNLOCK_TEXTURE_SURFACE(pTex) \
{                                            \
    EngUnlockDirectDrawSurface(pTex->lpLcl); \
    pTex->lpLcl = NULL;                      \
}
#endif // #ifdef WINNT

#endif  // _NVD3DMAC_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\inc\NV4DREG.H ===
#ifndef _NV4DREG_H_
#define _NV4DREG_H_
#ifdef  NV4
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4DREG.H                                                         *
*   Define the D3D driver registry strings and default settings.            *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/31/98 - Created.                     *
*                                                                           *
\***************************************************************************/

#define REG_BIT1_FOG_TABLE_ENABLE           0x00000001
#define REG_BIT1_ANTI_ALIAS_ENABLE          0x00000002
#define REG_BIT1_USER_MIPMAPS_ENABLE        0x00000004
#define REG_BIT1_VIDEO_TEXTURE_ENABLE       0x00000008
#define REG_BIT1_DMA_PUSH_SIZE_OVERRIDE     0x00000010
#define REG_BIT1_DMA_PUSH_COUNT_OVERRIDE    0x00000020
#define REG_BIT1_MIPMAP_DITHER_ENABLE       0x00000040
#define REG_BIT1_NO_WAIT_4_VSYNC            0x00000080
#define REG_BIT1_RESTRICT_AUTO_MIPMAPS      0x00000100
#define REG_BIT1_CKCOMPATABILITY_ENABLE     0x00000200
#define REG_BIT1_CONTROLTRAFFIC             0x00000400

/*
 * Value defines for some registry settings.
 * These are the values that are actually set in the registry.
 */
/*
 * FogTableEnable definitioans.
 */
#define REG_FTE_DISABLE                     0           // Disable Fog Table support.
#define REG_FTE_ENABLE                      1           // Enable Fog Table support
#define REG_FTE_MAX                         1

/*
 * AntiAliasEnable definitioans.
 */
#define REG_AAE_DISABLE                     0           // Disable Anti-Aliasing support.
#define REG_AAE_ENABLE                      1           // Enable Anti-Aliasing support.
#define REG_AAE_MAX                         1

/*
 * UserMipmaps definitioans.
 */
#define REG_UMM_DISABLE                     0           // Disable User supplied mipmaps.
#define REG_UMM_ENABLE                      1           // Enable User supplied mipmaps.
#define REG_UMM_MAX                         1

/*
 * VideoTexture definitioans.
 */
#define REG_VT_DISABLE                      0           // Disable texturing from video memory.
#define REG_VT_ENABLE                       1           // Enable texturing from video memory.
#define REG_VT_MAX                          1

/*
 * MipmapLevels definitioans.
 */
#define REG_MML_DISABLE                     0           // Disable Auto generated mipmaps.
#define REG_MML_ENABLE                      12          // Enable Auto generated mipmaps.
#define REG_MML_RESTRICTED                  13          // Restrict auto generation to non-colorkey/non-alpha textures.
#define REG_MML_MAX                         13

/*
 * AutoMipMapMethod definitions
 */
#define REG_AMMM_BILINEAR                   0
#define REG_AMMM_TRILINEAR                  1
#define REG_AMMM_MAX                        1

/*
 * TexelAlignment definitions.
 * Bit flags (bit 0 = ZOH, bit 1 = FOH, bit 2 = Texel Origin)
 */
#define REG_TA_ZOH_CENTER                   0x00
#define REG_TA_ZOH_CORNER                   0x01
#define REG_TA_FOH_CENTER                   0x00
#define REG_TA_FOH_CORNER                   0x02
#define REG_TA_TEXEL_CENTER                 0x00
#define REG_TA_TEXEL_CORNER                 0x04
#define REG_TA_MAX                          0x07
#define REG_TA_ZOH_MASK                     0x01
#define REG_TA_FOH_MASK                     0x02
#define REG_TA_TEXEL_MASK                   0x04

/*
 * MipMapDitherEnable definitions.
 */
#define REG_MMDE_FALSE                      0           // Disable mipmap dithering (true trilinear)
#define REG_MMDE_TRUE                       1           // Enable mipmap dithering (fake trilinear)
#define REG_MMDE_MAX                        1

/*
 * Pal8TextureConvert definitions
 */
#define REG_P8TC_NONE                       0           // Don't support 8 bit palettized textures.
#define REG_P8TC_8TOR5G6B5                  1           // Convert 8 bit palettized textures to 16 bit R5G6B5 textures.
#define REG_P8TC_8TOX1R5G5B5                2           // Convert 8 bit palettized textures to 16 bit X1R5G5B5 textures.
#define REG_P8TC_8TOA1R5G5B5                3           // Convert 8 bit palettized textures to 16 bit A1R5G5B5 textures.
#define REG_P8TC_8TOX8R8G8B8                4           // Convert 8 bit palettized textures to 32 bit X8R8G8B8 textures.
#define REG_P8TC_8TOA8R8G8B8                5           // Convert 8 bit palettized textures to 32 bit A8R8G8B8 textures.
#define REG_P8TC_Y8ONLY                     6           // Support Luminance Textures only
#define REG_P8TC_MAX                        6

/*
 * DX6Enable definitions.
 */
#define REG_DX6E_DISABLE                    0           // Don't export DX6 callbacks (DX5 Equivalent)
#define REG_DX6E_OPTIMIZED                  1           // Enable optimal DX6 functionality.
#define REG_DX6E_FORCE_FVF                  2           // Force use of FVF inner loops for non-multi pass cases.
#define REG_DX6E_FORCE_MULTI                3           // Force use of DX6 Multi-Texture inner loops for all cases.
#define REG_DX6E_MAX                        3

/*
 * Prerender limits
 */
#define REG_PRERENDER_MIN                   1
#define REG_PRERENDER_MAX                   100

/*
 * AAMethod limits
 */
#define REG_AAMETHOD_MIN                    0
#define REG_AAMETHOD_2x1                    0
#define REG_AAMETHOD_2x2                    1
#define REG_AAMETHOD_3x2                    2
#define REG_AAMETHOD_3x3                    3
#define REG_AAMETHOD_4x2                    4
#define REG_AAMETHOD_4x3                    5
#define REG_AAMETHOD_4x4                    6
#define REG_AAMETHOD_MAX                    6

/*
 * ValidateZMethod definitions.
 */
#define REG_VZM_STRICT                      0           // Z-Buffer must always match rendering depth.
#define REG_VZM_MIXED                       1           // DX6 applications = STRICT, DX5 applications = flexible
#define REG_VZM_FLEXIBLE                    2           // Driver will match z-buffer to rendering depth.
#define REG_VZM_MAX                         2

/*
 * Colorkey Reference Values range.
 */
#define REG_CKREF_MIN                       0x00
#define REG_CKREF_MAX                       0x7F

/*
 * CKCompatabilityEnable definitions.
 */
#define REG_CKCE_FALSE                      0x00
#define REG_CKCE_TRUE                       0x01
#define REG_CKCE_MAX                        0x01

#define NV4D3D_APP_STRING                       "SOFTWARE\\NVIDIA Corporation\\RIVA TNT\\Direct3D"
/*
 * Driver registry strings.
 *
 * Enable/Disable settings.
 */
#define NVD3D_FOG_TABLE_STRING                  "FOGTABLEENABLE"
#define NVD3D_ANTI_ALIAS_ENABLE_STRING          "ANTIALIASENABLE"
#define NVD3D_USER_MIPMAPS_STRING               "USERMIPMAPS"
#define NVD3D_VIDEO_TEXTURE_STRING              "VIDEOTEXTURE"
#define NVD3D_NO_WAIT_4_VSYNC_STRING            "NOVSYNC"
#define NVD3D_TEXEL_ALIGNMENT_STRING            "TEXELALIGNMENT"
#define NVD3D_MIPMAP_DITHER_ENABLE_STRING       "MIPMAPDITHERENABLE"
#define NVD3D_CKCOMPATABILITY_ENABLE_STRING     "CKCOMPATABILITYENABLE"
#define NVD3D_CKREF_STRING                      "CKREF"
#define NVD3D_CONTROLTRAFFIC_STRING             "CONTROLTRAFFIC"

/*
 * Value defined settings.
 */
#define NVD3D_MIPMAP_LEVELS_STRING              "MIPMAPLEVELS"
#define NVD3D_AUTO_MIPMAP_METHOD_STRING         "AUTOMIPMAPMETHOD"
#define NVD3D_TEX_HEAP_STRING                   "TEXHEAP"
#define NVD3D_MIN_VIDEO_TEX_SIZE_STRING         "MINVIDEOTEXSIZE"
#define NVD3D_DMA_MIN_PUSH_COUNT_STRING         "DMAMINPUSHCOUNT"
#define NVD3D_DMA_PUSH_BUFFER_SIZE_MAX_STRING   "DMAPUSHBUFFERSIZEMAX"
#define NVD3D_CONTEXT_MAX_STRING                "D3DCONTEXTMAX"
#define NVD3D_TEXTURE_MAX_STRING                "D3DTEXTUREMAX"
#define NVD3D_LOD_BIAS_ADJUST_STRING            "LODBIASADJUST"
#define NVD3D_PAL8_TEXTURE_CONVERT_STRING       "PAL8TEXTURECONVERT"
#define NVD3D_DX6_ENABLE_STRING                 "DX6ENABLE"
#define NVD3D_PRERENDER_LIMIT_STRING            "NOVSYNCPRERENDERLIMIT"
#define NVD3D_AAMETHOD_STRING                   "AAMETHOD"
#define NVD3D_VALIDATE_Z_METHOD_STRING          "VALIDATEZMETHOD"
#define NVD3D_AGPTEXTURE_CUTOFF                 "AGPTEXCUTOFF"

/*
 * Default values for registry configurable driver settings.
 */
#define DEFAULT_FOG_TABLE               REG_BIT1_FOG_TABLE_ENABLE       // Enable software implemented fog table support.
#define DEFAULT_ANTI_ALIAS_ENABLE       0//REG_BIT1_ANTI_ALIAS_ENABLE      // Enable software implemented Anti Aliasing.
#define DEFAULT_USER_MIPMAPS            REG_BIT1_USER_MIPMAPS_ENABLE    // Enable use of user supplied mip maps.
#define DEFAULT_VIDEO_TEXTURE           REG_BIT1_VIDEO_TEXTURE_ENABLE   // Enable texturing from video memory.
#define DEFAULT_NO_WAIT_4_VSYNC         0                               // Enable Proper VSync & Flip
#define DEFAULT_TEXEL_ALIGNMENT         (REG_TA_ZOH_CORNER | REG_TA_FOH_CORNER | REG_TA_TEXEL_CENTER)
#define DEFAULT_MIPMAP_DITHER_ENABLE    0                               //
#define DEFAULT_PRERENDER_LIMIT         5
#define DEFAULT_CKCOMPATABILITY_ENABLE  REG_BIT1_CKCOMPATABILITY_ENABLE // Perform application colorkey fixups.
#define DEFAULT_CONTROLTRAFFIC          0

/*
 * The definitions for ZOH and ZOH_MS are reversed.
 * The way they are implemented in hardware is actually:
 * ZOH_MS = 0
 * ZOH    = 1
 * The mode we really want to use by default is ZOH_MS.
 */
#define DEFAULT_MIPMAP_LEVELS           REG_MML_DISABLE                 // Set max number of mip map levels to auto-generate.
#define DEFAULT_AUTO_MIPMAP_METHOD      REG_AMMM_BILINEAR               // Bilinearly filter auto-generated mipmaps.
#define DEFAULT_TEX_HEAP                0x00500000                      // Set maximum size of PCI system memory texture heap.
#define DEFAULT_MIN_VIDEO_TEX_SIZE      1                               // Set minimum texture size to be placed in video memory.
#define DEFAULT_DMA_MIN_PUSH_COUNT_PCI  0x600                           // Set the minimum push count.
#define DEFAULT_DMA_MIN_PUSH_COUNT_AGP  0x900                           // Set the minimum push count.
#define DEFAULT_PUSH_BUFFER_SIZE_MAX_PCI 0x40000                        // Set the maximum push buffer size.
#define DEFAULT_PUSH_BUFFER_SIZE_MAX_AGP 0x200000                       // Set the maximum push buffer size.
#define DEFAULT_D3D_CONTEXT_MAX         64                              // D3D Context heap allocation max.
#define DEFAULT_D3D_TEXTURE_MAX         1024                            // D3D Texture heap allocation max.
#define DEFAULT_LOD_BIAS_ADJUST         0                               //
#define DEFAULT_PAL8_TEXTURE_CONVERT    REG_P8TC_NONE                   //
#define DEFAULT_AAMETHOD                REG_AAMETHOD_2x2                // 2x2 Supersampling.
#define DEFAULT_VALIDATE_Z_METHOD       REG_VZM_FLEXIBLE                // REG_VZM_MIXED
#define DEFAULT_CKREF                   REG_CKREF_MIN
#define DEFAULT_AGPTEX_CUTOFF           1024

/*
 * This will eventually go away.
 */
#define DEFAULT_DX6_ENABLE              REG_DX6E_OPTIMIZED
#endif  // NV4
#endif _NV4DREG_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\inc\UVWRAP.H ===
#define WRAP(uv, wrap)                      \
{                                           \
    if (wrap)                               \
    {                                       \
        float el,er,em;                     \
        el=(float)fabs(uv##2 - uv##0);      \
        er=(float)fabs(uv##1 - uv##2);      \
        em=(float)fabs(uv##0 - uv##1);      \
        if (el > 0.5f && er > 0.5f)         \
        {                                   \
            if (uv##2 < uv##1)              \
            {                               \
                uv##2 += 1.0f;              \
            }                               \
            else                            \
            {                               \
                uv##1 += 1.0f;              \
                uv##0 += 1.0f;              \
            }                               \
        }                                   \
        else if (er > 0.5f && em > 0.5f)    \
        {                                   \
            if (uv##1 < uv##0)              \
            {                               \
                uv##1 += 1.0f;              \
            }                               \
            else                            \
            {                               \
                uv##0 += 1.0f;              \
                uv##2 += 1.0f;              \
            }                               \
        }                                   \
        else if (em > 0.5f && el > 0.5f)    \
        {                                   \
            if (uv##0 < uv##2)              \
            {                               \
                uv##0 += 1.0f;              \
            }                               \
            else                            \
            {                               \
                uv##2 += 1.0f;              \
                uv##1 += 1.0f;              \
            }                               \
        }                                   \
    }                                       \
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\inc\NVTEXFMT.H ===
#ifndef _NVTEXFMT_H_
#define _NVTEXFMT_H_
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NVTEXFMT.H                                                        *
*   Define the texture format available for the NV D3D driver.              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/31/98 - created.                     *
*                                                                           *
\***************************************************************************/

/*
 * Define the various texture format definitions.
 * For any given hardware, the texture format definitions don't change,
 * just the formats that are available on that hardware change.
 */
/*
 * RGB 16 BPP (R5xG5xB5)
 */
#define NV_TFMT_X1R5G5B5                                                        \
{                                                                               \
    sizeof(DDSURFACEDESC),              /* dwSize */                            \
    DDSD_CAPS | DDSD_PIXELFORMAT,       /* dwFlags */                           \
    0,                                  /* dwHeight */                          \
    0,                                  /* dwWidth */                           \
    0,                                  /* lPitch */                            \
    0,                                  /* dwBackBufferCount */                 \
    0,                                  /* dwZBufferBitDepth */                 \
    0,                                  /* dwAlphaBitDepth */                   \
    0,                                  /* dwReserved */                        \
    NULL,                               /* lpSurface */                         \
    { 0, 0 },                           /* ddckCKDestOverlay */                 \
    { 0, 0 },                           /* ddckCKDestBlt */                     \
    { 0, 0 },                           /* ddckCKSrcOverlay */                  \
    { 0, 0 },                           /* ddckCKSrcBlt */                      \
    {                                                                           \
      sizeof(DDPIXELFORMAT),            /* ddpfPixelFormat.dwSize */            \
      DDPF_RGB,                         /* ddpfPixelFormat.dwFlags */           \
      0,                                /* FOURCC code */                       \
      16,                               /* ddpfPixelFormat.dwRGBBitCount */     \
      0x7C00,                                                                   \
      0x03E0,                                                                   \
      0x001F,                                                                   \
      0x0000                                                                    \
    },                                                                          \
    DDSCAPS_TEXTURE,                    /* ddscaps.dwCaps */                    \
}

/*
 * RGB 16 BPP Alpha (A1xR5xG5xB5)
 */
#define NV_TFMT_A1R5G5B5                                                        \
{                                                                               \
    sizeof(DDSURFACEDESC),              /* dwSize */                            \
    DDSD_CAPS | DDSD_PIXELFORMAT,       /* dwFlags */                           \
    0,                                  /* dwHeight */                          \
    0,                                  /* dwWidth */                           \
    0,                                  /* lPitch */                            \
    0,                                  /* dwBackBufferCount */                 \
    0,                                  /* dwZBufferBitDepth */                 \
    0,                                  /* dwAlphaBitDepth */                   \
    0,                                  /* dwReserved */                        \
    NULL,                               /* lpSurface */                         \
    { 0, 0 },                           /* ddckCKDestOverlay */                 \
    { 0, 0 },                           /* ddckCKDestBlt */                     \
    { 0, 0 },                           /* ddckCKSrcOverlay */                  \
    { 0, 0 },                           /* ddckCKSrcBlt */                      \
    {                                                                           \
      sizeof(DDPIXELFORMAT),            /* ddpfPixelFormat.dwSize */            \
      DDPF_RGB | DDPF_ALPHAPIXELS,      /* ddpfPixelFormat.dwFlags */           \
      0,                                /* FOURCC code */                       \
      16,                               /* ddpfPixelFormat.dwRGBBitCount */     \
      0x7C00,                                                                   \
      0x03E0,                                                                   \
      0x001F,                                                                   \
      0x8000                                                                    \
    },                                                                          \
    DDSCAPS_TEXTURE,                    /* ddscaps.dwCaps */                    \
}

/*
 * RGB 16 BPP Alpha (A4xR4xG4xB4)
 */
#define NV_TFMT_A4R4G4B4                                                        \
{                                                                               \
    sizeof(DDSURFACEDESC),              /* dwSize */                            \
    DDSD_CAPS | DDSD_PIXELFORMAT,       /* dwFlags */                           \
    0,                                  /* dwHeight */                          \
    0,                                  /* dwWidth */                           \
    0,                                  /* lPitch */                            \
    0,                                  /* dwBackBufferCount */                 \
    0,                                  /* dwZBufferBitDepth */                 \
    0,                                  /* dwAlphaBitDepth */                   \
    0,                                  /* dwReserved */                        \
    NULL,                               /* lpSurface */                         \
    { 0, 0 },                           /* ddckCKDestOverlay */                 \
    { 0, 0 },                           /* ddckCKDestBlt */                     \
    { 0, 0 },                           /* ddckCKSrcOverlay */                  \
    { 0, 0 },                           /* ddckCKSrcBlt */                      \
    {                                                                           \
      sizeof(DDPIXELFORMAT),            /* ddpfPixelFormat.dwSize */            \
      DDPF_RGB | DDPF_ALPHAPIXELS,      /* ddpfPixelFormat.dwFlags */           \
      0,                                /* FOURCC code */                       \
      16,                               /* ddpfPixelFormat.dwRGBBitCount */     \
      0x0F00,                                                                   \
      0x00F0,                                                                   \
      0x000F,                                                                   \
      0xF000                                                                    \
    },                                                                          \
    DDSCAPS_TEXTURE,                    /* ddscaps.dwCaps */                    \
}

/*
 * RGB 16 BPP (R5xG6xB5)
 */
#define NV_TFMT_R5G6B5                                                          \
{                                                                               \
    sizeof(DDSURFACEDESC),              /* dwSize */                            \
    DDSD_CAPS | DDSD_PIXELFORMAT,       /* dwFlags */                           \
    0,                                  /* dwHeight */                          \
    0,                                  /* dwWidth */                           \
    0,                                  /* lPitch */                            \
    0,                                  /* dwBackBufferCount */                 \
    0,                                  /* dwZBufferBitDepth */                 \
    0,                                  /* dwAlphaBitDepth */                   \
    0,                                  /* dwReserved */                        \
    NULL,                               /* lpSurface */                         \
    { 0, 0 },                           /* ddckCKDestOverlay */                 \
    { 0, 0 },                           /* ddckCKDestBlt */                     \
    { 0, 0 },                           /* ddckCKSrcOverlay */                  \
    { 0, 0 },                           /* ddckCKSrcBlt */                      \
    {                                                                           \
      sizeof(DDPIXELFORMAT),            /* ddpfPixelFormat.dwSize */            \
      DDPF_RGB,                         /* ddpfPixelFormat.dwFlags */           \
      0,                                /* FOURCC code */                       \
      16,                               /* ddpfPixelFormat.dwRGBBitCount */     \
      0xF800,                                                                   \
      0x07E0,                                                                   \
      0x001F,                                                                   \
      0x0000                                                                    \
    },                                                                          \
    DDSCAPS_TEXTURE,                    /* ddscaps.dwCaps */                    \
}

/*
 * RGB 32 BPP (X8xR8xG8xB8)
 */
#define NV_TFMT_X8R8G8B8                                                        \
{                                                                               \
    sizeof(DDSURFACEDESC),              /* dwSize */                            \
    DDSD_CAPS | DDSD_PIXELFORMAT,       /* dwFlags */                           \
    0,                                  /* dwHeight */                          \
    0,                                  /* dwWidth */                           \
    0,                                  /* lPitch */                            \
    0,                                  /* dwBackBufferCount */                 \
    0,                                  /* dwZBufferBitDepth */                 \
    0,                                  /* dwAlphaBitDepth */                   \
    0,                                  /* dwReserved */                        \
    NULL,                               /* lpSurface */                         \
    { 0, 0 },                           /* ddckCKDestOverlay */                 \
    { 0, 0 },                           /* ddckCKDestBlt */                     \
    { 0, 0 },                           /* ddckCKSrcOverlay */                  \
    { 0, 0 },                           /* ddckCKSrcBlt */                      \
    {                                                                           \
      sizeof(DDPIXELFORMAT),            /* ddpfPixelFormat.dwSize */            \
      DDPF_RGB,                         /* ddpfPixelFormat.dwFlags */           \
      0,                                /* FOURCC code */                       \
      32,                               /* ddpfPixelFormat.dwRGBBitCount */     \
      0x00FF0000,                       /* Red Component Mask */                \
      0x0000FF00,                       /* Green Component Mask */              \
      0x000000FF,                       /* Blue Component Mask */               \
      0x00000000                        /* Alpha Component Mask */              \
    },                                                                          \
    DDSCAPS_TEXTURE,                    /* ddscaps.dwCaps */                    \
}

/*
 * RGB 32 BPP (A8xR8xG8xB8)
 */
#define NV_TFMT_A8R8G8B8                                                        \
{                                                                               \
    sizeof(DDSURFACEDESC),              /* dwSize */                            \
    DDSD_CAPS | DDSD_PIXELFORMAT,       /* dwFlags */                           \
    0,                                  /* dwHeight */                          \
    0,                                  /* dwWidth */                           \
    0,                                  /* lPitch */                            \
    0,                                  /* dwBackBufferCount */                 \
    0,                                  /* dwZBufferBitDepth */                 \
    0,                                  /* dwAlphaBitDepth */                   \
    0,                                  /* dwReserved */                        \
    NULL,                               /* lpSurface */                         \
    { 0, 0 },                           /* ddckCKDestOverlay */                 \
    { 0, 0 },                           /* ddckCKDestBlt */                     \
    { 0, 0 },                           /* ddckCKSrcOverlay */                  \
    { 0, 0 },                           /* ddckCKSrcBlt */                      \
    {                                                                           \
      sizeof(DDPIXELFORMAT),            /* ddpfPixelFormat.dwSize */            \
      DDPF_RGB | DDPF_ALPHAPIXELS,      /* ddpfPixelFormat.dwFlags */           \
      0,                                /* FOURCC code */                       \
      32,                               /* ddpfPixelFormat.dwRGBBitCount */     \
      0x00FF0000,                       /* Red Component Mask */                \
      0x0000FF00,                       /* Green Component Mask */              \
      0x000000FF,                       /* Blue Component Mask */               \
      0xFF000000                        /* Alpha Component Mask */              \
    },                                                                          \
    DDSCAPS_TEXTURE,                    /* ddscaps.dwCaps */                    \
}

/*
 * RGB 24 BPP (R8xG8xB8)
 * Hardware doesn't actually support this.  The texture would actually
 * have to be expanded to a 32bpp X8xR8xG8xB8 format.
 * Haven't decided if I really want to do this.
 */
#define NV_TFMT_R8G8B8                                                          \
{                                                                               \
    sizeof(DDSURFACEDESC),              /* dwSize */                            \
    DDSD_CAPS | DDSD_PIXELFORMAT,       /* dwFlags */                           \
    0,                                  /* dwHeight */                          \
    0,                                  /* dwWidth */                           \
    0,                                  /* lPitch */                            \
    0,                                  /* dwBackBufferCount */                 \
    0,                                  /* dwZBufferBitDepth */                 \
    0,                                  /* dwAlphaBitDepth */                   \
    0,                                  /* dwReserved */                        \
    NULL,                               /* lpSurface */                         \
    { 0, 0 },                           /* ddckCKDestOverlay */                 \
    { 0, 0 },                           /* ddckCKDestBlt */                     \
    { 0, 0 },                           /* ddckCKSrcOverlay */                  \
    { 0, 0 },                           /* ddckCKSrcBlt */                      \
    {                                                                           \
      sizeof(DDPIXELFORMAT),            /* ddpfPixelFormat.dwSize */            \
      DDPF_RGB,                         /* ddpfPixelFormat.dwFlags */           \
      0,                                /* FOURCC code */                       \
      24,                               /* ddpfPixelFormat.dwRGBBitCount */     \
      0x00FF0000,                       /* Red Component Mask */                \
      0x0000FF00,                       /* Green Component Mask */              \
      0x000000FF,                       /* Blue Component Mask */               \
      0x00000000                        /* Alpha Component Mask */              \
    },                                                                          \
    DDSCAPS_TEXTURE,                    /* ddscaps.dwCaps */                    \
}

/*
 * FFVII REQUIRES 8bit textures.  What a pain.  Of course so does PC98/PC99.
 */
#define NV_TFMT_RGB8                                                            \
{                                                                               \
    sizeof(DDSURFACEDESC),              /* dwSize */                            \
    DDSD_CAPS | DDSD_PIXELFORMAT,       /* dwFlags */                           \
    0,                                  /* dwHeight */                          \
    0,                                  /* dwWidth */                           \
    0,                                  /* lPitch */                            \
    0,                                  /* dwBackBufferCount */                 \
    0,                                  /* dwZBufferBitDepth */                 \
    0,                                  /* dwAlphaBitDepth */                   \
    0,                                  /* dwReserved */                        \
    NULL,                               /* lpSurface */                         \
    { 0, 0 },                           /* ddckCKDestOverlay */                 \
    { 0, 0 },                           /* ddckCKDestBlt */                     \
    { 0, 0 },                           /* ddckCKSrcOverlay */                  \
    { 0, 0 },                           /* ddckCKSrcBlt */                      \
    {                                                                           \
      sizeof(DDPIXELFORMAT),            /* ddpfPixelFormat.dwSize */            \
      DDPF_RGB | DDPF_PALETTEINDEXED8,  /* ddpfPixelFormat.dwFlags */           \
      0,                                /* FOURCC code */                       \
      8,                                /* ddpfPixelFormat.dwRGBBitCount */     \
      0x00000000,                       /* Red Component Mask */                \
      0x00000000,                       /* Green Component Mask */              \
      0x00000000,                       /* Blue Component Mask */               \
      0x00000000                        /* Alpha Component Mask */              \
    },                                                                          \
    DDSCAPS_TEXTURE,                    /* ddscaps.dwCaps */                    \
}

/*
 * Y8 Texture Format
 */
#define NV_TFMT_Y8                                                              \
{                                                                               \
    sizeof(DDSURFACEDESC),              /* dwSize */                            \
    DDSD_CAPS | DDSD_PIXELFORMAT,       /* dwFlags */                           \
    0,                                  /* dwHeight */                          \
    0,                                  /* dwWidth */                           \
    0,                                  /* lPitch */                            \
    0,                                  /* dwBackBufferCount */                 \
    0,                                  /* dwZBufferBitDepth */                 \
    0,                                  /* dwAlphaBitDepth */                   \
    0,                                  /* dwReserved */                        \
    NULL,                               /* lpSurface */                         \
    { 0, 0 },                           /* ddckCKDestOverlay */                 \
    { 0, 0 },                           /* ddckCKDestBlt */                     \
    { 0, 0 },                           /* ddckCKSrcOverlay */                  \
    { 0, 0 },                           /* ddckCKSrcBlt */                      \
    {                                                                           \
      sizeof(DDPIXELFORMAT),            /* ddpfPixelFormat.dwSize */            \
      DDPF_LUMINANCE,                   /* ddpfPixelFormat.dwFlags */           \
      0,                                /* FOURCC code */                       \
      8,                                /* ddpfPixelFormat.dwRGBBitCount */     \
      0x000000FF,                       /* Red Component Mask */                \
      0x00000000,                       /* Green Component Mask */              \
      0x00000000,                       /* Blue Component Mask */               \
      0x00000000                        /* Alpha Component Mask */              \
    },                                                                          \
    DDSCAPS_TEXTURE,                    /* ddscaps.dwCaps */                    \
}

/*
 * Potentially need 4bpp and 8bpp palettized textures.
 */

/*
 * Define the texture formats available on NV3 hardware.
 * NV_TFMT_R5G6B5 texture format should be the last format in the
 * structure so it can be easily enabled/disabled at runtime.
 */
#define NV3_TEXTURE_FORMATS NV_TFMT_X1R5G5B5,   \
                            NV_TFMT_A1R5G5B5,   \
                            NV_TFMT_A4R4G4B4,   \
                            NV_TFMT_R5G6B5

/*
 * Define the texture formats available on NV4 hardware.
 */
#define NV_NUM_8BIT_TEXTURE_FORMATS             2
#define NV_NUM_8BIT_Y8ONLY_TEXTURE_FORMATS      (NV_NUM_8BIT_TEXTURE_FORMATS - 1)
#define NV4_TEXTURE_FORMATS NV_TFMT_X1R5G5B5,   \
                            NV_TFMT_A1R5G5B5,   \
                            NV_TFMT_A4R4G4B4,   \
                            NV_TFMT_R5G6B5,     \
                            NV_TFMT_X8R8G8B8,   \
                            NV_TFMT_A8R8G8B8,   \
                            NV_TFMT_Y8,         \
                            NV_TFMT_RGB8

/*
 * Based on the compile flag choose the texture formats available
 * for this driver build.
 */
#ifdef  NV3
#define NV_TEXTURE_FORMATS  NV3_TEXTURE_FORMATS
#endif  // NV3
#ifdef  NV4
#define NV_TEXTURE_FORMATS  NV4_TEXTURE_FORMATS
#endif  // NV4
#endif  // _NVTEXFMT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\MakeTri\main.cpp ===
#include <stdio.h>
#include <string.h>

//////////////////////////////////////////////////////////////////////////////
// constants

// output files
#define VXMAC_FILE      "nv4vxmac.h"
#define VXIMP_FILE      "nv4vx.c"

// combinations
typedef enum { DX5,DX6 } MTClass;
typedef enum { None,ExpFog,Exp2Fog,LinFog } MTFogMode;
typedef enum { NoAA,AA } MTScaleMode;
typedef enum { FixedVF,FlexVF } MTVFormat;
//typedef enum { List,Strip,Fan,Ind } MTGeometry;
typedef enum { NonIndexed,Indexed,NA } MTIndexType;
typedef enum { w0,w1 } MTW;

// strings
char *szMTClass[]     = { "DX5","DX6" };
char *szMTFogMode[]   = { "","ExpFog","Exp2Fog","LinearFog" };
char *szMTScaleMode[] = { "","AACapture" };
char *szMTVFormat[]   = { "","Flex" };
//char *szMTGeometry[]  = { "List","Strip","Fan","" } ;
char *szMTIndexType[] = { "","Indexed","" } ;
char *szMTW[]         = { "","WBuf"} ;


//////////////////////////////////////////////////////////////////////////////
// macros
#define SUCC(x,y)       (x)(y+1)
#define FOR_ALL_COMBINATIONS_VX\
    for (mtClass=DX5; mtClass<=DX6; mtClass=SUCC(MTClass,mtClass)) {\
      for (mtVFormat=(mtClass==DX6)?FlexVF:FixedVF; mtVFormat<=FlexVF; mtVFormat=SUCC(MTVFormat,mtVFormat)) {\
        for (mtScaleMode=NoAA; mtScaleMode<=AA; mtScaleMode=SUCC(MTScaleMode,SUCC(MTScaleMode,mtScaleMode))) {\
          mtIndexType = NA;/*for (mtIndexType=NonIndexed; mtIndexType<=Indexed; mtIndexType=SUCC(MTIndexType,mtIndexType)) */{\
          for (mtW=w0; mtW<=w1; mtW=SUCC(MTW,mtW)) {\
            for (mtFogMode=None; mtFogMode<=LinFog; mtFogMode=SUCC(MTFogMode,mtFogMode)) {\
              {\
                init();
#define FOR_ALL_COMBINATIONS_PROC\
    for (mtClass=DX5; mtClass<=DX6; mtClass=SUCC(MTClass,mtClass)) {\
      for (mtVFormat=(mtClass==DX6)?FlexVF:FixedVF; mtVFormat<=FlexVF; mtVFormat=SUCC(MTVFormat,mtVFormat)) {\
        for (mtScaleMode=NoAA; mtScaleMode<=AA; mtScaleMode=SUCC(MTScaleMode,mtScaleMode)) {\
          for (mtIndexType=NonIndexed; mtIndexType<=Indexed; mtIndexType=SUCC(MTIndexType,mtIndexType)) {\
            for (mtW=w0; mtW<=w1; mtW=SUCC(MTW,mtW)) {\
              for (mtFogMode=None; mtFogMode<=((mtScaleMode!=NoAA)?None:LinFog); mtFogMode=SUCC(MTFogMode,mtFogMode)) {\
                {/*for (mtGeometry=(mtIndexType==Indexed?Ind:List); mtGeometry<=(mtIndexType==Indexed?Ind:Fan); mtGeometry=SUCC(MTGeometry,mtGeometry)) {*/\
                  init();
#define NEXT    } } } } } } }

//////////////////////////////////////////////////////////////////////////////
// globals
FILE       *fHdr;
FILE       *fImp;
MTClass     mtClass;
MTVFormat   mtVFormat;
MTScaleMode mtScaleMode;
MTFogMode   mtFogMode;
MTW         mtW;
//MTGeometry  mtGeometry;
MTIndexType mtIndexType;
char        szTableName[512];
char        szProcName[512];
char        szVertexName[512];
char        szILParameter[512];

/*
typedef void  (*LPNVINDEXEDPRIM) (DWORD, LPWORD, DWORD,DWORD, LPD3DTLVERTEX);
typedef void  (*LPNVDRAWPRIM) (WORD, DWORD,DWORD, LPD3DTLVERTEX);

typedef void  (*LPNVFVFINDEXEDPRIM) (DWORD, LPWORD, DWORD,DWORD, LPBYTE);
typedef void  (*LPNVFVFDRAWPRIM) (WORD, DWORD,DWORD, LPBYTE);
*/

char *szHeader = 
"/*\n"
" * **** MACHINE GENERATED - DO NOT EDIT ****\n"
" * **** MACHINE GENERATED - DO NOT EDIT ****\n"
" * **** MACHINE GENERATED - DO NOT EDIT ****\n"
" *\n"
" * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.\n"
" *\n"
" * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO\n"
" * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY\n"
" * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.\n"
" */\n\n"
"/********************************* Direct 3D *******************************\\\n"
"*                                                                           *\n"
"* Module: NV4VX.C                                                           *\n"
"*   NV4 Triangle Inner Loops. (Originally Machine Generated)                *\n"
"*                                                                           *\n"
"*****************************************************************************\n"
"*                                                                           *\n"
"* History:                                                                  *\n"
"*       Ben de Waal                 05/23/98 - NV4 development.             *\n"
"*                                                                           *\n"
"\\***************************************************************************/\n"
"#include <math.h>\n"
"#include <windows.h>\n"
"#include \"ddrawi.h\"\n"
"#include \"ddrvmem.h\"\n"
"#include \"ddmini.h\"\n"
"#include \"nv432.h\"\n"
"#include \"nvddobj.h\"\n"
"#include \"d3d.h\"\n"
"#include \"d3dhal.h\"\n"
"#include \"d3dinc.h\"\n"
"#include \"nvd3dmac.h\"\n"
"#include \"nv3ddbg.h\"\n"
"#include \"nv4vxmac.h\"\n"
"\n"
"#ifdef NV_FASTLOOPS\n"
"\n"
"DWORD dwDrawPrimitiveTable[] =\n"
"{\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x040*/\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x080*/\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x0c0*/\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x100*/\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x140*/\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x180*/\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x1c0*/\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x200*/\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x240*/\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x280*/\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x2c0*/\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x300*/\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x340*/\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x380*/\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x3c0*/\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x400*/\n"
"   (DWORD)nvAACapturePrimitive,\n"
"   (DWORD)nvDX5TriangleSetup,\n"
"   (DWORD)nvAACapturePrimitive,\n"
"   (DWORD)nvDX6TriangleSetup,\n"
"};\n"
"\n"
"#else //~NV_FASTLOOPS\n"
"\n";

//////////////////////////////////////////////////////////////////////////////
// create names
void init (void) {
// inner loops
    sprintf(szProcName,"nv%s%sTriangle%s%s%s%s",
                        szMTClass[mtClass],
                        szMTVFormat[mtVFormat],
                        szMTFogMode[mtFogMode],
                        szMTIndexType[mtIndexType],
                        //szMTGeometry[mtGeometry],
                        szMTScaleMode[mtScaleMode],
                        szMTW[mtW]);
    while (strlen(szProcName)<40) strcat (szProcName," ");
    if (mtVFormat == FlexVF) {
        if (mtIndexType == Indexed) {
            strcpy (szILParameter,"DWORD, LPWORD, DWORD, LPBYTE");
        } else {
            strcpy (szILParameter," WORD,         DWORD, LPBYTE");
        }
    } else {
        if (mtIndexType == Indexed) {
            strcpy (szILParameter,"DWORD, LPWORD, DWORD, LPD3DTLVERTEX");
        } else {
            strcpy (szILParameter," WORD,         DWORD, LPD3DTLVERTEX");
        }
    }
// vertex macro
    sprintf(szVertexName,"nvgl%s%sTriangleVertex%s%s%s",
                        szMTClass[mtClass],
                        szMTVFormat[mtVFormat],
                        /*szMTIndexType[mtIndexType],*/
                        szMTScaleMode[mtScaleMode],
                        szMTFogMode[mtFogMode],
                        szMTW[mtW]);
}

//////////////////////////////////////////////////////////////////////////////
// main
int main (void) {
// create files
    fHdr = fopen(VXMAC_FILE,"wt");
    if (!fHdr) return 1;
    fImp = fopen(VXIMP_FILE,"wt");
    if (!fImp) return 1;

// emit basic stuff
    fprintf (fHdr,"/*\n");
    fprintf (fHdr," * **** MACHINE GENERATED - DO NOT EDIT ****\n");
    fprintf (fHdr," * **** MACHINE GENERATED - DO NOT EDIT ****\n");
    fprintf (fHdr," * **** MACHINE GENERATED - DO NOT EDIT ****\n");
    fprintf (fHdr," *\n");
    fprintf (fHdr," * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.\n");
    fprintf (fHdr," *\n");
    fprintf (fHdr," * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO\n");
    fprintf (fHdr," * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY\n");
    fprintf (fHdr," * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.\n");
    fprintf (fHdr," */\n\n");
    fprintf (fHdr,"/*\n * Inner Loop Prototypes and Vertex Macros\n */\n\n");
    fprintf (fHdr,"/*\n * General Constants\n */\n");
    fprintf (fHdr,"#define NV_FORCE_TRI_SETUP(_ctx) (_ctx)->dwFunctionLookup = NV_SETUP_FUNCTION_INDEX;\n\n");
    fprintf (fHdr,"#ifdef NV_FASTLOOPS\n");
    fprintf (fHdr,"#define NV_DX6_FUNCTION_ADJUST      2\n");
    fprintf (fHdr,"#define NV_FIXED_FUNCTION_INDEX     1024\n");
    fprintf (fHdr,"#define NV_AA_FUNCTION_INDEX        1024\n");
    fprintf (fHdr,"#define NV_SETUP_FUNCTION_INDEX     1025\n");
    fprintf (fHdr,"#else //!NV_FASTLOOPS\n");
    fprintf (fHdr,"#define NV_AA_FUNCTION_INDEX        8\n");
    fprintf (fHdr,"#define NV_SETUP_FUNCTION_INDEX     10\n");
    fprintf (fHdr,"#endif //!NV_FASTLOOPS\n");
    fprintf (fHdr,"\n");
    fprintf (fHdr,"#define sizeDX5TriangleVertex       9\n");
    fprintf (fHdr,"#define sizeDx5TriangleTLVertex     sizeDX5TriangleVertex\n");
    fprintf (fHdr,"\n");
    fprintf (fHdr,"#define sizeDX6TriangleVertex       11\n");
    fprintf (fHdr,"#define sizeDx6TriangleTLVertex     sizeDX6TriangleVertex\n");
    fprintf (fHdr,"\n");
    fprintf (fHdr,"#define LIST_STRIDES                0x00000303\n");
    fprintf (fHdr,"#define STRIP_STRIDES               0x01010101\n");
    fprintf (fHdr,"#define FAN_STRIDES                 0x02000001\n");
    fprintf (fHdr,"#define LEGACY_STRIDES              0x03000404\n");
    fprintf (fHdr,"\n");

    fprintf (fImp,"%s",szHeader);

// emit inner loop prototypes
    fprintf (fHdr,"#ifdef NV_FASTLOOPS\n\n");
    fprintf (fHdr,"void __stdcall nvTriangleDispatch (DWORD, LPWORD, DWORD, LPBYTE);\n");
    fprintf (fHdr,"void __stdcall nvDX5TriangleSetup (DWORD, LPWORD, DWORD, LPBYTE);\n");
    fprintf (fHdr,"void __stdcall nvDX6TriangleSetup (DWORD, LPWORD, DWORD, LPBYTE);\n\n");
    fprintf (fHdr,"extern DWORD dwDrawPrimitiveTable[];\n\n");
    fprintf (fHdr,"#else //!NV_FASTLOOPS\n\n");

    fprintf (fHdr,"/*\n * Inner Loop Prototypes\n */\n");
    FOR_ALL_COMBINATIONS_PROC
        fprintf (fHdr,"void %s (%s);\n",szProcName,szILParameter);
    NEXT
    fprintf (fHdr,"\n");

// emit inner loop tables
    fprintf (fImp,"/*\n * Function Tables\n */\n");
    for (mtClass=DX5; mtClass<=DX6; mtClass=SUCC(MTClass,mtClass)) {\
      for (mtVFormat=(mtClass==DX6)?FlexVF:FixedVF; mtVFormat<=FlexVF; mtVFormat=SUCC(MTVFormat,mtVFormat)) {\
        for (mtIndexType=NonIndexed; mtIndexType<=Indexed; mtIndexType=SUCC(MTIndexType,mtIndexType)) {\
            /*for (mtGeometry=(mtIndexType==Indexed?Ind:List); mtGeometry<=(mtIndexType==Indexed?Ind:Fan); mtGeometry=SUCC(MTGeometry,mtGeometry)) */{\
            char sz[256];
            sprintf(sz,"%s%s%s",
                        szMTClass[mtClass],
                        szMTVFormat[mtVFormat],
                        szMTIndexType[mtIndexType]/*,
                        szMTGeometry[mtGeometry]*/);
            char *rt = (mtIndexType == Indexed) ? ((mtVFormat == FixedVF) ? "LPNVINDEXEDPRIM" : "LPNVFVFINDEXEDPRIM")
                                                : ((mtVFormat == FixedVF) ? "LPNVDRAWPRIM" : "LPNVFVFDRAWPRIM");
            sprintf(szTableName,"%s fn%sTable",rt,sz);
            fprintf (fImp,"%s[] =\n{\n",szTableName);
            for (mtScaleMode=NoAA; mtScaleMode<=AA; mtScaleMode=SUCC(MTScaleMode,mtScaleMode)) {\
              for (mtW=w0; mtW<=w1; mtW=SUCC(MTW,mtW)) {\
                for (mtFogMode=None; mtFogMode<=((mtScaleMode!=NoAA)?None:LinFog); mtFogMode=SUCC(MTFogMode,mtFogMode)) {\
                  init();
                  fprintf (fImp,"    %s,\n",szProcName);
                }
              }
            }
            fprintf (fImp,"    nv%sTriangleSetup\n",sz);
            fprintf (fImp,"};\n\n");

                        fprintf (fHdr,"extern %s fn%sTable[];\n",rt,sz);
                        fprintf (fHdr,"void nv%sTriangleSetup  (%s);\n",sz,szILParameter);
          }
        }
      }
    }
    fprintf (fImp,"\n");
                        fprintf (fHdr,"\n");

// emit inner loops
    fprintf (fImp,"/*\n * Function declarations\n */\n\n");
    FOR_ALL_COMBINATIONS_PROC
        char *size = (mtClass == DX5) ? "sizeDX5TriangleVertex" : "sizeDX6TriangleVertex";
                                    fprintf (fImp,"// %s\n",szProcName);
                                    fprintf (fImp,"#define  PROC_        \"%s\"\n",szProcName);
                                    fprintf (fImp,"#define  PROC         %s\n",szProcName);
                                    fprintf (fImp,"#define  VERTEX       %s\n",szVertexName);
        if (mtClass == DX6)         fprintf (fImp,"#define  DX6\n");
                                    fprintf (fImp,"#define  VXSIZE       %s\n",size);
        if (mtFogMode != None)      fprintf (fImp,"#define  FOG          %d\n",mtFogMode);
        if (mtW == w1)              fprintf (fImp,"#define  WBUFFER\n");
        if (mtIndexType == Indexed) fprintf (fImp,"#define  INDEXED\n");
        if (mtVFormat == FlexVF)    fprintf (fImp,"#define  FVF\n");
        if (mtScaleMode == AA)      fprintf (fImp,"#define  ANTIALIAS\n");
        //if (mtIndexType != Indexed) fprintf (fImp,"#define  GEOMETRY     %d\n",mtGeometry);
                                    //fprintf (fImp,"#ifdef NV_FASTLOOPS2\n");
                                    //fprintf (fImp,"#include \"nv4fast.c\"\n");
                                    //fprintf (fImp,"#else //!NV_FASTLOOPS2\n");
                                    fprintf (fImp,"#include \"nv4loop.c\"\n");
                                    //fprintf (fImp,"#endif //!NV_FASTLOOPS2\n");
        //if (mtIndexType != Indexed) fprintf (fImp,"#undef   GEOMETRY\n");
        if (mtScaleMode == AA)      fprintf (fImp,"#undef   ANTIALIAS\n");
        if (mtVFormat == FlexVF)    fprintf (fImp,"#undef   FVF\n");
        if (mtIndexType == Indexed) fprintf (fImp,"#undef   INDEXED\n");
        if (mtW == w1)              fprintf (fImp,"#undef   WBUFFER\n");
        if (mtFogMode != None)      fprintf (fImp,"#undef   FOG\n");
                                    fprintf (fImp,"#undef   VXSIZE\n");
        if (mtClass == DX6)         fprintf (fImp,"#undef   DX6\n");
                                    fprintf (fImp,"#undef   VERTEX\n");
                                    fprintf (fImp,"#undef   PROC\n");
                                    fprintf (fImp,"#undef   PROC_\n");
        fprintf (fImp,"\n");
    NEXT

// emit vertex macros
    fprintf (fHdr,"#endif //!NV_FASTLOOPS\n");

    fprintf (fHdr,"/*\n * Vertex Macros\n */\n\n");
    FOR_ALL_COMBINATIONS_VX
        char *size = (mtClass == DX5) ? "sizeDX5TriangleVertex" : "sizeDX6TriangleVertex";
            //fprintf (fHdr,"// vertex macro for %s\n",szProcName);
            fprintf (fHdr,"#define %s(fifo,freecount,ch,alias,vertex%s)\\\n",szVertexName,
                            (mtVFormat == FlexVF) ? ",fvf,uvoff" : "");

        if (!strcmp(szVertexName,"nvglDX5TriangleVertex"))
        {
            fprintf (fHdr,"{\\\n");
            fprintf (fHdr,"    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\\\n");
            fprintf (fHdr,"    memcpy ((void*)(fifo + 4),(void*)(vertex),32);\\\n");
            /*
            fprintf (fHdr,"    __asm { mov eax,[vertex]              }\\\n");
            fprintf (fHdr,"    __asm { mov ebx,[fifo]                }\\\n");
            fprintf (fHdr,"    __asm { movq mm0,qword ptr [eax+ 0]   }\\\n");
            fprintf (fHdr,"    __asm { movq mm1,qword ptr [eax+ 8]   }\\\n");
            fprintf (fHdr,"    __asm { movq mm2,qword ptr [eax+16]   }\\\n");
            fprintf (fHdr,"    __asm { movq mm3,qword ptr [eax+24]   }\\\n");
            fprintf (fHdr,"    __asm { movq qword ptr [ebx+ 0+4],mm0 }\\\n");
            fprintf (fHdr,"    __asm { movq qword ptr [ebx+ 8+4],mm1 }\\\n");
            fprintf (fHdr,"    __asm { movq qword ptr [ebx+16+4],mm2 }\\\n");
            fprintf (fHdr,"    __asm { movq qword ptr [ebx+24+4],mm3 }\\\n");
            fprintf (fHdr,"    __asm { emms                          }\\\n");
            */

        }
        else
        {
            fprintf (fHdr,"{\\\n");
            fprintf (fHdr,"    DWORD dwTemp;\\\n");
            if (mtFogMode != None) {
                fprintf (fHdr,"    DWORD zmask,dwrhw,dwz;\\\n");
                fprintf (fHdr,"    int   ifog;\\\n");
                fprintf (fHdr,"    float ffog,fz,fw;\\\n");
            }
            if ((mtW == w1) || (mtFogMode != None)) {
                fprintf (fHdr,"    float frhw;\\\n");
            }
            // placement
            fprintf (fHdr,"    *(DWORD*)(fifo +  0) = ((%s-1)<<18) | ((ch)<<13) | %s((alias));\\\n",size,(mtClass == DX5) ? "NV054_TLVERTEX" : "NV055_TLMTVERTEX");
            // sx & sy
            if (mtScaleMode == AA) {
                fprintf (fHdr,"    *(float*)(fifo +  4) = (*(float*)(vertex +  0)) * fAAScaleX + fAAOffsetX;\\\n");
                fprintf (fHdr,"    *(float*)(fifo +  8) = (*(float*)(vertex +  4)) * fAAScaleY + fAAOffsetY;\\\n");
            } else {
                fprintf (fHdr,"    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\\\n");
                fprintf (fHdr,"    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\\\n");
            }
            // sz
            fprintf (fHdr,"    *(DWORD*)(fifo + 12) = ");
            if (mtFogMode != None) fprintf (fHdr,"dwz = ");
            fprintf (fHdr,"(*(DWORD*)(vertex +  8));\\\n");
            // rhw
            if (mtVFormat == FlexVF) {
                fprintf (fHdr,"    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\\\n");
            } else {
                fprintf (fHdr,"    dwTemp = (*(DWORD*)(vertex + 12));\\\n");
            }
            if (mtW == w1) {
                fprintf (fHdr,"    frhw = (*(float*)&dwTemp) * pCurrentContext->dvRWFar;\\\n");
                fprintf (fHdr,"    *(DWORD*)(fifo + 16) = ");
                if (mtFogMode != None) fprintf (fHdr,"dwrhw = ");
                fprintf (fHdr,"*(DWORD*)&frhw;\\\n");
            }
            else {
                fprintf (fHdr,"    *(DWORD*)(fifo + 16) = ");
                if (mtFogMode != None) fprintf (fHdr,"dwrhw = ");
                fprintf (fHdr,"dwTemp;\\\n");
            }
            // color
            if (mtVFormat == FlexVF) {
                fprintf (fHdr,"    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwARGBMask) + fvf.dwARGBOffset);\\\n");
            } else {
                fprintf (fHdr,"    *(DWORD*)(fifo + 20) = (*(DWORD*)(vertex + 16));\\\n");
            }
            // specular
            if (mtVFormat == FlexVF) {
                fprintf (fHdr,"    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\\\n");
            } else {
                fprintf (fHdr,"    dwTemp = (*(DWORD*)(vertex + 20));\\\n");
            }
            // fog
            if (mtFogMode != None) {
                // wnear and wfar both equal to 1.0 means the projection is affine
                fprintf (fHdr,"    zmask = ((*(DWORD *)&(pCurrentContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pCurrentContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\\\n");
                fprintf (fHdr,"    frhw = *(float*)&dwrhw;\\\n");
                fprintf (fHdr,"    FP_INV (fw, frhw);\\\n");
                fprintf (fHdr,"    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\\\n");  // select between z and 1/(1/rhw)
                fprintf (fHdr,"    fz = *(float *)&dwz;\\\n");
                if (mtFogMode == LinFog) {
                    fprintf (fHdr,"    ffog = (fz >= pCurrentContext->fFogTableEnd) ? 0.0f :\\\n");
                    fprintf (fHdr,"           (fz <= pCurrentContext->fFogTableStart) ? 1.0f :\\\n");
                    fprintf (fHdr,"           (pCurrentContext->fFogTableEnd - fz) * pCurrentContext->fFogTableLinearScale;\\\n");
                } else {
                    fprintf (fHdr,"    ffog  = fz * pCurrentContext->fFogTableDensity;\\\n");
                    if (mtFogMode == Exp2Fog) {
                        fprintf (fHdr,"    ffog *= ffog;\\\n");
                    }
                    fprintf (fHdr,"    FP_EXP (ffog,ffog);\\\n");
                }
                fprintf (fHdr,"    FP_NORM_TO_BIT24 (ifog,ffog);\\\n");
                fprintf (fHdr,"    dwTemp = (dwTemp & 0x00ffffff) | ifog;\\\n");
            }
            fprintf (fHdr,"    *(DWORD*)(fifo + 24) = dwTemp;\\\n");
            // uv (uv2)
            if (mtVFormat == FlexVF) {
                fprintf (fHdr,"    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset;\\\n");
                fprintf (fHdr,"    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\\\n");
                fprintf (fHdr,"    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\\\n");
                if (mtClass == DX6) {
                    fprintf (fHdr,"    *(DWORD*)(fifo + 36) = *(DWORD*)(dwTemp + (uvoff)[1] + 0);\\\n");
                    fprintf (fHdr,"    *(DWORD*)(fifo + 40) = *(DWORD*)(dwTemp + (uvoff)[1] + 4);\\\n");
                }
            } else {
                fprintf (fHdr,"    *(DWORD*)(fifo + 28) = (*(DWORD*)(vertex + 24));\\\n");
                fprintf (fHdr,"    *(DWORD*)(fifo + 32) = (*(DWORD*)(vertex + 28));\\\n");
                if (mtClass == DX6) {
                    fprintf (fHdr,"    *(DWORD*)(fifo + 36) = 0;\\\n");
                    fprintf (fHdr,"    *(DWORD*)(fifo + 40) = 0;\\\n");
                }
            }
        }
            fprintf (fHdr,"    dbgDisplayVertexData(((DWORD*)nvFifo)[1],((DWORD*)nvFifo)[2],((DWORD*)nvFifo)[3],\\\n");
            fprintf (fHdr,"                         ((DWORD*)nvFifo)[4],((DWORD*)nvFifo)[5],((DWORD*)nvFifo)[6],\\\n");
            fprintf (fHdr,"                         ((DWORD*)nvFifo)[7],((DWORD*)nvFifo)[8]);\\\n");
            fprintf (fHdr,"    fifo      += %s * 4;\\\n",size);
            fprintf (fHdr,"    freecount -= %s;\\\n",size);
            fprintf (fHdr,"}\n\n");
    NEXT

    fprintf (fImp,"#endif //!NV_FASTLOOPS\n");

// close files
    fclose (fHdr);
    fclose (fImp);

// done
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\blt3232.c ===
/*==========================================================================;
 *
 *  Copyright (C) 1995, 1998 NVidia Corporation.  All Rights Reserved.
 *
 *  File:       blt3232.c
 *  Content:    Windows95 DirectDraw 32 bit driver
 *
 ***************************************************************************/

#include "windows.h"
#include <conio.h>
#include "nvd3ddrv.h"
#include "nv32.h"
#include "nvddobj.h"
#include "ddrvmem.h"
#include "d3dinc.h"
#include "nvrmapi.h"
#include "nvrmarch.inc"
#include "nvheap.h"

extern DWORD ResetNV();

/*
 * Blt32bpp32
 *
 * 32-bit Blt function for 32bpp surfaces.
 */
DWORD __stdcall Blt32bpp32( LPDDHAL_BLTDATA pbd )
{
    FAST Nv10ControlDma *npDev;
    DWORD               dwFlags;
#ifdef  DX7
    DWORD               dwAFlags;
#endif  /* DX7 */
    DWORD               dwDDFX = 0;
    DWORD               dwDstCaps;
    DWORD               dwSrcCaps;
    DWORD               dwRop;
    NVCOORD             wXYext;
    NVCOORD             wDestXY;
    NVCOORD             wSrcXY;
    BYTE                wStretch = 0;
    BYTE                doMirrorUpDown = 0;
    BYTE                doBilinearFiltering = 0;
    BYTE                isVideo = 0;
    BYTE                isAlphaBlt = 0;
    BYTE                isZBlt = 0;
    BYTE                isNoAlphaSrc = 0;
    BYTE                isKeySrc = 0;
    BYTE                isClipped = 0;

    DWORD               dwFillColor;
    DWORD               dwMultipliers;
    DWORD               dwColorKey;

    DWORD               dwDstOffset;
    DWORD               dwDstPitch;
    DWORD               dwDstWidth;
    DWORD               dwDstHeight;

    DWORD               dwSrcOffset;
    DWORD               dwSrcPitch;
    DWORD               dwSrcWidth;
    DWORD               dwSrcHeight;

    LPDDRAWI_DDRAWSURFACE_LCL  srcx;
    LPDDRAWI_DDRAWSURFACE_LCL  dstx;
    LPDDRAWI_DDRAWSURFACE_GBL  src;
    LPDDRAWI_DDRAWSURFACE_GBL  dst;

    unsigned long       *dmaPusherPutAddress =
                            (unsigned long *)pDriverData->NvDmaPusherPutAddress;
    unsigned long       *dmaPusherBufferBase =
                            (unsigned long *)pDriverData->NvDmaPusherBufferBase;
    long                freeCount;

    dstx = pbd->lpDDDestSurface;
    dst = dstx->lpGbl;

    /*
     * NOTES:
     *
     * Everything you need is in pdb->bltFX .
     * Look at pdb->dwFlags to determine what kind of blt you are doing,
     * DDBLT_xxxx are the flags.
     *
     * Z BUFFER NOTES:
     *
     * ZBuffer ALWAYS comes in BLTFX.   You don't need to go looking for
     * the attached surface. If DDBLT_ZBUFFER is specified, then either a
     * constant z or z buffer surface has been specified for the source and
     * destination. Just look for the DDBLT_ZBUFFERDESTOVERRIDE,
     * DDBLT_ZBUFFERSRCOVERRIDE, DDBLT_ZBUFFERCONSTANTDESTOVERRIDE, or
     * DDBLT_ZBUFFERCONSTANTSRCOVERRIDE.
     *
     * COLORKEY NOTES:
     *
     * ColorKey ALWAY comes in BLTFX.   You don't have to look it up in
     * the surface.
     */

    dwFlags   = pbd->dwFlags;
    dwDstCaps = dstx->ddsCaps.dwCaps;

#ifdef  DX7
    /*
     * Check for AlphaBlt call
     */
    dwAFlags  = pbd->dwAFlags;

    if ((dwFlags & DDBLT_AFLAGS) && (dwAFlags & DDABLT_SRCOVERDEST)) {
        isAlphaBlt = 1;
        if (dwAFlags & DDABLT_KEYDEST) {
            DPF("AlphaBlt Dest color key failed");
            pbd->ddRVal = DDERR_NOCOLORKEYHW;
            return DDHAL_DRIVER_HANDLED;
        }
        if (dwAFlags & DDABLT_MIRRORLEFTRIGHT) {
            DPF("AlphaBlt mirror left/right failed");
            pbd->ddRVal = DDERR_NOMIRRORHW;
            return DDHAL_DRIVER_HANDLED;
        }
        if (pbd->IsClipped)
            isClipped = 1;
    }
#endif  /* DX7 */

    // check for z buffer blit
    // assume that DD runtime has enough sense to make alpha blits mutually exclusive
    if ((dwDstCaps & DDSCAPS_ZBUFFER) && (dstx->dwFlags & DDRAWISURF_HASPIXELFORMAT)) {
        if (dst->ddpfSurface.dwZBufferBitDepth == 32)
            isZBlt = NV042_SET_COLOR_FORMAT_LE_Y32;
        else if (dst->ddpfSurface.dwZBufferBitDepth == 16)
            isZBlt = NV042_SET_COLOR_FORMAT_LE_Y16;
    }

    if (dwFlags & DDBLT_DDFX)
        dwDDFX = pbd->bltFX.dwDDFX;

    if (dwFlags & (DDBLT_KEYDEST | DDBLT_KEYDESTOVERRIDE)) {
        DPF("Dest color key failed");
        pbd->ddRVal = DDERR_NOCOLORKEYHW;
        return DDHAL_DRIVER_HANDLED;
    }

    /*
     * get offset, width, and height for destination
     */
    dwDstOffset = dst->fpVidMem     - pDriverData->BaseAddress;
    dwDstPitch  = dst->lPitch;
    dwDstWidth  = pbd->rDest.right  - pbd->rDest.left;
    dwDstHeight = pbd->rDest.bottom - pbd->rDest.top;
    wXYext.wh16.w = (unsigned short)dwDstWidth;
    wXYext.wh16.h = (unsigned short)dwDstHeight;

    wDestXY.xy16.x = (short)pbd->rDest.left;
    wDestXY.xy16.y = (short)pbd->rDest.top;

#ifndef NV_TEX2
    /*
     * Check for a 32 Bpp texture blit right away.
     */
    if (dwDstCaps & DDSCAPS_TEXTURE) {

#ifdef WINNT
    /*
     * Some MS apps insist on passing us DX7 AlphaBlts even though we never
     * claim DX7 support. Our texblt code requires a source, so return
     * an error if the src is not present.
     */
        if (!pbd->lpDDSrcSurface) {
            pbd->ddRVal = DDERR_INVALIDPARAMS;
            return DDHAL_DRIVER_HANDLED;
        }
#endif
        /*
         * Call the special D3D Texture blit code to handle this blit.
         */
        nvTextureBlit32Bpp(pbd);

        /*
         * Return successfully.
         */
        pbd->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;
    }
#endif //!NV_TEX2

    if (dwDstCaps & (DDSCAPS_SYSTEMMEMORY | DDSCAPS_NONLOCALVIDMEM))
        return DDHAL_DRIVER_NOTHANDLED;

    /*
     * Let 3D code know we did some 2D rendering
     */
    pDriverData->TwoDRenderingOccurred = 1;

    npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;

    if (npDev == NULL) {
        if (!ResetNV()) {
            pbd->ddRVal = DDERR_GENERIC;
            return(DDHAL_DRIVER_HANDLED);
        }
        pDriverData->fReset = FALSE;
        npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;

        if (npDev == NULL) {
            pbd->ddRVal = DDERR_SURFACELOST;
            return DDHAL_DRIVER_HANDLED;
        }
    }

    dmaPusherPutAddress = (unsigned long *)pDriverData->NvDmaPusherPutAddress;

#ifdef  CACHE_FREECOUNT
    freeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
    NvCheckCachedFreeCount(freeCount, dmaPusherPutAddress);
#endif  /* DEBUG */
#else   /* CACHE_FREECOUNT */
    freeCount = 0;
#endif  /* CACHE_FREECOUNT */

    if (pDriverData->ddClipUpdate) {

        while (freeCount < 7)
            NvGetDmaBufferFreeCount(npDev, freeCount, 7, dmaPusherPutAddress);
        freeCount -= 7;

        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000;
        dmaPusherPutAddress[1] = NV_DD_IMAGE_BLACK_RECTANGLE;
        dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
            IMAGE_BLACK_RECTANGLE_POINT_OFFSET | 0x80000;
        dmaPusherPutAddress[3] = 0;
        dmaPusherPutAddress[4] = asmMergeCoords(NV_MAX_X_CLIP, NV_MAX_Y_CLIP);
        dmaPusherPutAddress[5] = dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000;
        dmaPusherPutAddress[6] = NV_DD_SURFACES_2D;

        dmaPusherPutAddress += 7;

        pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

        /* Force write combine buffer to flush */
        pDriverData->NvDmaPusherBufferEnd[0] = 0;
        /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
        _outp (0x3d0,0);

        pDriverData->dwDmaPusherFreeCount = freeCount;

        npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

        pDriverData->dwSharedClipChangeCount++;

        pDriverData->dwDDMostRecentClipChangeCount = pDriverData->dwSharedClipChangeCount;

        pDriverData->ddClipUpdate = FALSE;
    }

    /*
     * If async, then only work if bltter isn't busy
     * This should probably be a little more specific to each call, but
     * waiting for 32 is pretty close
     */
    if( dwFlags & DDBLT_ASYNC ) {

        NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);

        pDriverData->dwDmaPusherFreeCount = freeCount;

        /* Must save pointer in case it was changed by above macro */
        pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

        if (freeCount < 10) {
            DPF("ASYNC FAILED");
            pbd->ddRVal = DDERR_WASSTILLDRAWING;
            return DDHAL_DRIVER_HANDLED;
        }
    }

    /* Check for AlphaBlt fill operation */
    if ((isAlphaBlt) && (pbd->lpDDSrcSurface == 0)) {

        while (freeCount < 12)
            NvGetDmaBufferFreeCount(npDev, freeCount, 12, dmaPusherPutAddress);
        freeCount -= 12;

        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SURFACES) +
            SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x40000;
        dmaPusherPutAddress[1] = NV042_SET_COLOR_FORMAT_LE_A8R8G8B8;

        dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
            SURFACES_2D_DEST_OFFSET | 0x40000;
        dmaPusherPutAddress[3] = dwDstOffset;
        dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SURFACES) +
            SURFACES_2D_PITCH_OFFSET | 0x40000;
        dmaPusherPutAddress[5] = (dwDstPitch << 16) | dwDstPitch;

        dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
        dmaPusherPutAddress[7] = NV_DD_CONTEXT_BETA4;
#ifdef  DX7
        dwMultipliers = pbd->ddrgbaScaleFactors.alpha << 24;
        dwMultipliers |= pbd->ddrgbaScaleFactors.red << 16;
        dwMultipliers |= pbd->ddrgbaScaleFactors.green << 8;
        dwMultipliers |= pbd->ddrgbaScaleFactors.blue;
#endif  /* DX7 */
        dmaPusherPutAddress[8] = dDrawSubchannelOffset(NV_DD_SPARE) +
            BETA4_SET_BETA_FACTOR_OFFSET | 0x40000;
        dmaPusherPutAddress[9] = dwMultipliers;

        dmaPusherPutAddress[10] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) | 0x40000;
        dmaPusherPutAddress[11] = NV_DD_ABLEND_RECT_AND_TEXT;

        dmaPusherPutAddress += 12;

        if (isClipped) {
            DWORD nRects = pbd->dwRectCnt;
            LPRECT pClipRects = pbd->prDestRects;
            NVCOORD clipPoint0;
            NVCOORD clipPoint1;

            wDestXY.xy16.x = (short)pbd->rOrigDest.left;
            wDestXY.xy16.y = (short)pbd->rOrigDest.top;
            wXYext.xy16.x  = (short)pbd->rOrigDest.right;
            wXYext.xy16.y  = (short)pbd->rOrigDest.bottom;

            while (freeCount < 2)
                NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
            freeCount -= 2;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                RECT_AND_TEXT_COLOR1A_OFFSET | 0x40000;
            dmaPusherPutAddress[1] = 0xFFFFFFFF;

            dmaPusherPutAddress += 2;

            while (--nRects >= 0) {

                clipPoint0.xy16.x = (short)pClipRects->left;
                clipPoint0.xy16.y = (short)pClipRects->top;
                clipPoint1.xy16.x = (short)pClipRects->right;
                clipPoint1.xy16.y = (short)pClipRects->bottom;
                pClipRects++;

                while (freeCount < 6)
                    NvGetDmaBufferFreeCount(npDev, freeCount, 6, dmaPusherPutAddress);
                freeCount -= 6;

                dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                    RECT_AND_TEXT_CLIPPOINT0B_OFFSET | 0x80000;
                dmaPusherPutAddress[1] = clipPoint0.xy;
                dmaPusherPutAddress[2] = clipPoint1.xy;
                dmaPusherPutAddress[3] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                    RECT_AND_TEXT_CLIPPEDRECT_POINT0_OFFSET | 0x80000;
                dmaPusherPutAddress[4] = wDestXY.xy;
                dmaPusherPutAddress[5] = wXYext.xy;

                dmaPusherPutAddress += 6;
            }

        } else {

            /* unclipped AlphaBlt MUST clip to destination */
            if (wDestXY.xy16.x < 0)
                wDestXY.xy16.x = 0;
            if (wDestXY.xy16.y < 0)
                wDestXY.xy16.y = 0;
            if (wDestXY.xy16.x + wXYext.wh16.w > dst->wWidth)
                wXYext.wh16.w = dst->wWidth - wDestXY.xy16.x;
            if (wDestXY.xy16.y + wXYext.wh16.h > dst->wHeight)
                wXYext.wh16.h = dst->wHeight - wDestXY.xy16.y;
            /* handle NULL destination rectangle case */
            if ((wDestXY.xy16.x == 0) && (wXYext.wh16.w == 0))
                wXYext.wh16.w = dst->wWidth;
            if ((wDestXY.xy16.y == 0) && (wXYext.wh16.h == 0))
                wXYext.wh16.h = dst->wHeight;

            while (freeCount < 4)
                NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
            freeCount -= 4;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                RECT_AND_TEXT_COLOR1A_OFFSET | 0xC0000;
            dmaPusherPutAddress[1] = 0xFFFFFFFF;
            dmaPusherPutAddress[2] = asmMergeCoords(wDestXY.xy16.y, wDestXY.xy16.x);
            dmaPusherPutAddress[3] = asmMergeCoords(wXYext.wh16.h, wXYext.wh16.w);

            dmaPusherPutAddress += 4;
        }

        while (freeCount < 4)
            NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
        freeCount -= 4;

        /* Restore default objects */
        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) | 0x40000;
        dmaPusherPutAddress[1] = NV_DD_ROP_GDI_RECT_AND_TEXT;

        /* Restore default destination color format */
        dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
            SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x40000;
        dmaPusherPutAddress[3] = NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8;

        dmaPusherPutAddress += 4;

        pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

        /* Force write combine buffer to flush */
        pDriverData->NvDmaPusherBufferEnd[0] = 0;
        /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
        _outp (0x3d0,0);

        pDriverData->dwDmaPusherFreeCount = freeCount;

        npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

        pbd->ddRVal = DD_OK;

        return DDHAL_DRIVER_HANDLED;
    }

    if ((dwFlags & DDBLT_ROP) || ((isAlphaBlt) && (pbd->lpDDSrcSurface != 0))) {

        // set pixel depth for z buffer blit
        if (isZBlt) {
            while (freeCount < 2)
                NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
            freeCount -= 2;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x40000;
            dmaPusherPutAddress[1] = isZBlt;

            dmaPusherPutAddress += 2;
        }

        if (isAlphaBlt)
            dwRop = SRCCOPYINDEX;
        else
            dwRop = pbd->bltFX.dwROP >> 16;

        if ((dwRop == BLACKNESSINDEX) || (dwRop == WHITENESSINDEX)) {

            while (freeCount < 10)
                NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);
            freeCount -= 10;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
                SET_ROP_OFFSET | 0x40000;
            dmaPusherPutAddress[1] = dwRop;

            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                SURFACES_2D_DEST_OFFSET | 0x40000;
            dmaPusherPutAddress[3] = dwDstOffset;
            dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                SURFACES_2D_PITCH_OFFSET | 0x40000;
            dmaPusherPutAddress[5] = (dwDstPitch << 16) | dwDstPitch;

            dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                RECT_AND_TEXT_COLOR1A_OFFSET | 0xC0000;
            dmaPusherPutAddress[7] = 0;
            dmaPusherPutAddress[8] = asmMergeCoords(wDestXY.xy16.y, wDestXY.xy16.x);
            dmaPusherPutAddress[9] = asmMergeCoords(wXYext.wh16.h, wXYext.wh16.w);

            dmaPusherPutAddress += 10;

        } else if ((dwRop == PATCOPYINDEX) || (dwRop == PATINVERTINDEX)) {

            dwFillColor = pbd->bltFX.dwFillColor & pDriverData->physicalColorMask;

            if (dwRop == PATCOPYINDEX)
                dwRop = SRCCOPYINDEX;
            else if (dwRop == PATINVERTINDEX)
                dwRop = SRCINVERTINDEX;

            while (freeCount < 10)
                NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);
            freeCount -= 10;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
                SET_ROP_OFFSET | 0x40000;
            dmaPusherPutAddress[1] = dwRop;

            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                SURFACES_2D_DEST_OFFSET | 0x40000;
            dmaPusherPutAddress[3] = dwDstOffset;
            dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                SURFACES_2D_PITCH_OFFSET | 0x40000;
            dmaPusherPutAddress[5] = (dwDstPitch << 16) | dwDstPitch;

            dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                RECT_AND_TEXT_COLOR1A_OFFSET | 0xC0000;
            dmaPusherPutAddress[7] = dwFillColor;
            dmaPusherPutAddress[8] = asmMergeCoords(wDestXY.xy16.y, wDestXY.xy16.x);
            dmaPusherPutAddress[9] = asmMergeCoords(wXYext.wh16.h, wXYext.wh16.w);

            dmaPusherPutAddress += 10;

        } else if ((dwRop == SRCCOPYINDEX) || (dwRop == SRCPAINTINDEX) ||
                   (dwRop == SRCANDINDEX) || (dwRop == NOTSRCCOPYINDEX) ||
                   (dwRop == SRCINVERTINDEX) || (dwRop == MERGEPAINTINDEX) ||
                   (dwRop == SRCERASEINDEX) || (dwRop == NOTSRCERASEINDEX)) {

            srcx = pbd->lpDDSrcSurface;
            src = srcx->lpGbl;

            dwSrcCaps = srcx->ddsCaps.dwCaps;

            /* We must treat AGP source memory as system memory */
            if (dwSrcCaps & DDSCAPS_NONLOCALVIDMEM)
                dwSrcCaps &= ~(DDSCAPS_VIDEOMEMORY | DDSCAPS_NONLOCALVIDMEM);

            dwSrcOffset = src->fpVidMem    - pDriverData->BaseAddress;
            dwSrcPitch  = src->lPitch;
            dwSrcWidth  = pbd->rSrc.right  - pbd->rSrc.left;
            dwSrcHeight = pbd->rSrc.bottom - pbd->rSrc.top;

            dwColorKey  = pbd->bltFX.ddckSrcColorkey.dwColorSpaceLowValue;

            wSrcXY.xy16.x = (short)pbd->rSrc.left;
            wSrcXY.xy16.y = (short)pbd->rSrc.top;

            if (srcx->dwFlags & DDRAWISURF_HASPIXELFORMAT) {
                if (src->ddpfSurface.dwFlags & DDPF_ALPHAPREMULT) {
                   if ((src->ddpfSurface.dwRGBAlphaBitMask != 0xFF000000) ||
                       (src->ddpfSurface.dwRBitMask != 0x00FF0000) ||
                       (src->ddpfSurface.dwGBitMask != 0x0000FF00) ||
                       (src->ddpfSurface.dwBBitMask != 0x000000FF)) {
                           pbd->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                           return DDHAL_DRIVER_HANDLED;
                       }
                } else if (src->ddpfSurface.dwFlags & DDPF_FOURCC) {

                   if (src->ddpfSurface.dwFourCC == FOURCC_RGB0) {
                       if ((src->ddpfSurface.dwRBitMask == 0x00FF0000) &&
                           (src->ddpfSurface.dwGBitMask == 0x0000FF00) &&
                           (src->ddpfSurface.dwBBitMask == 0x000000FF)) {
                           if (dwSrcCaps & DDSCAPS_SYSTEMMEMORY)
                               isVideo = 1;
                           goto srcRGB;
                       } else {
                           pbd->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                           return DDHAL_DRIVER_HANDLED;
                       }
                   } else if (src->ddpfSurface.dwFourCC == FOURCC_RAW8) {
                       pbd->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                       return DDHAL_DRIVER_HANDLED;
                   }

                   while (freeCount < 6)
                       NvGetDmaBufferFreeCount(npDev, freeCount, 6, dmaPusherPutAddress);
                   freeCount -= 6;

                   dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
                       SET_ROP_OFFSET | 0x40000;
                   dmaPusherPutAddress[1] = SRCCOPYINDEX;

                   dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                       SURFACES_2D_DEST_OFFSET | 0x40000;
                   dmaPusherPutAddress[3] = dwDstOffset;
                   dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                       SURFACES_2D_PITCH_OFFSET | 0x40000;
                   dmaPusherPutAddress[5] = (dwDstPitch << 16) | dwDstPitch;

                   dmaPusherPutAddress += 6;

                   /* Just in case we return unexpectedly */
                   pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

                   switch (src->ddpfSurface.dwFourCC) {
                       case FOURCC_UYVY:
                       case FOURCC_UYNV:
                       case FOURCC_YUY2:
                       case FOURCC_YUNV:
    //                     if (dwSrcWidth & 1) {  NEC MPEG CODEC DOESN'T RESPOND TO THIS ERROR
    //                           pbd->ddRVal = DDERR_INVALIDRECT;
    //                           return DDHAL_DRIVER_HANDLED;
    //                       }

                           if (wSrcXY.xy16.x & 1) {
                               pbd->ddRVal = DDERR_INVALIDRECT;
                               return DDHAL_DRIVER_HANDLED;
                           }

                           if ((src->ddpfSurface.dwFourCC == FOURCC_UYVY) ||
                               (src->ddpfSurface.dwFourCC == FOURCC_UYNV)) {
                               isVideo = 2;
                               // Is this surface DMAable ?
                               if ((pDriverData->fNvActiveFloatingContexts &
                                    NV_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY) &&
                                   (pDriverData->NvFloating0UYVYSurfaceMem == src->fpVidMem))
                                       isVideo = 4;
                               else if ((pDriverData->fNvActiveFloatingContexts &
                                    NV_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY) &&
                                   (pDriverData->NvFloating1UYVYSurfaceMem == src->fpVidMem))
                                       isVideo = 5;
                           } else { // YUY2
                               isVideo = 3;
                               // Is this surface DMAable ?
                               if ((pDriverData->fNvActiveFloatingContexts &
                                    NV_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY) &&
                                   (pDriverData->NvFloating0YUYVSurfaceMem == src->fpVidMem))
                                       isVideo = 6;
                               else if ((pDriverData->fNvActiveFloatingContexts &
                                    NV_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY) &&
                                   (pDriverData->NvFloating1YUYVSurfaceMem == src->fpVidMem))
                                       isVideo = 7;
                           }
                           goto srcRGB;
                       break;

                       case FOURCC_YV12:
                           // Size has to be always * 4, to use VU subsampling
                           if ((dwSrcWidth & 3) || (dwSrcHeight & 3)) {
                               pbd->ddRVal = DDERR_INVALIDRECT;
                               return DDHAL_DRIVER_HANDLED;
                           }
                           return DDHAL_DRIVER_HANDLED;
                       break;
                   }
                   pbd->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                   return DDHAL_DRIVER_HANDLED;
                }
            }

srcRGB:     if (dwDDFX & DDBLTFX_MIRRORUPDOWN)
                doMirrorUpDown = 1;
#ifdef  DX7
            if ((isAlphaBlt) && (dwAFlags & DDABLT_MIRRORUPDOWN))
                doMirrorUpDown = 1;
#endif  /* DX7 */
            if ((dwSrcWidth != dwDstWidth) || (dwSrcHeight != dwDstHeight)) {
                wStretch = 1;
#ifdef  DX7
                if ((isAlphaBlt) && (dwAFlags & DDABLT_BILINEARFILTER))
                    doBilinearFiltering = 1;
#endif  /* DX7 */
            }

            if (isVideo > 1) { /* YUV video */
                wStretch = 1;
                doBilinearFiltering = 1;
            }

#ifdef  DX7
            if ((dwFlags & DDBLT_KEYSRCOVERRIDE)  || ((isAlphaBlt) && (dwAFlags & DDABLT_KEYSRC))) {
#else   /* DX7 */
            if (dwFlags & DDBLT_KEYSRCOVERRIDE) {
#endif  /* DX7 */
               if (isAlphaBlt) { /* NV4 doesn't support source color key in blended image blit operations */
                   isKeySrc = 1;
                   dwColorKey = srcx->ddckCKSrcBlt.dwColorSpaceLowValue;
               } else
                   dwColorKey = pbd->bltFX.ddckSrcColorkey.dwColorSpaceLowValue;

               /* Let D3D know that we changed the object in subchannel 6 */
               pDriverData->dDrawSpareSubchannel6Object = NV_DD_CONTEXT_COLOR_KEY;

               while (freeCount < 4)
                   NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
               freeCount -= 4;

               // load and enable chroma key
               dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_TRANSCOLOR) | 0x40000;
               dmaPusherPutAddress[1] = NV_DD_CONTEXT_COLOR_KEY;
               dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_TRANSCOLOR) +
                   SET_TRANSCOLOR_OFFSET | 0x40000;
               dmaPusherPutAddress[3] =
                    (dwColorKey & pDriverData->physicalColorMask) | NV_ALPHA_1_032;

               dmaPusherPutAddress += 4;

               pDriverData->dwDmaPusherFreeCount = freeCount;

               /* Just in case we return unexpectedly */
               pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

            }

            // screen to screen bitblt
            if (wStretch == 0) {
                if ((dwDstCaps & DDSCAPS_VIDEOMEMORY) &&
                    (dwSrcCaps & DDSCAPS_VIDEOMEMORY) &&
                    ((dwSrcCaps & DDSCAPS_TEXTURE) == 0) &&
                    (isNoAlphaSrc == 0) &&
                    (isKeySrc == 0) &&
                    (doMirrorUpDown == 0) &&
                    (isVideo == 0)) {

                    if (isAlphaBlt) {

                        while (freeCount < 9)
                            NvGetDmaBufferFreeCount(npDev, freeCount, 9, dmaPusherPutAddress);
                        freeCount -= 9;

                        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                            SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x100000;
                        dmaPusherPutAddress[1] = NV042_SET_COLOR_FORMAT_LE_A8R8G8B8;
                        dmaPusherPutAddress[2] = (dwDstPitch << 16) | dwSrcPitch;
                        dmaPusherPutAddress[3] = dwSrcOffset;
                        dmaPusherPutAddress[4] = dwDstOffset;

                        dmaPusherPutAddress[5] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                        dmaPusherPutAddress[6] = NV_DD_CONTEXT_BETA4;
#ifdef  DX7
                        dwMultipliers = pbd->ddrgbaScaleFactors.alpha << 24;
                        dwMultipliers |= pbd->ddrgbaScaleFactors.red << 16;
                        dwMultipliers |= pbd->ddrgbaScaleFactors.green << 8;
                        dwMultipliers |= pbd->ddrgbaScaleFactors.blue;
#endif  /* DX7 */
                        dmaPusherPutAddress[7] = dDrawSubchannelOffset(NV_DD_SPARE) +
                            BETA4_SET_BETA_FACTOR_OFFSET | 0x40000;
                        dmaPusherPutAddress[8] = dwMultipliers;

                        dmaPusherPutAddress += 9;

                        if (isClipped) {
                            DWORD nRects = pbd->dwRectCnt;
                            LPRECT pClipRects = pbd->prDestRects;
                            NVCOORD wOrigDestXY;
                            NVCOORD wOrigSrcXY;

                            wOrigDestXY.xy16.x = (short)pbd->rOrigDest.left;
                            wOrigDestXY.xy16.y = (short)pbd->rOrigDest.top;
                            wOrigSrcXY.xy16.x  = (short)pbd->rOrigSrc.left;
                            wOrigSrcXY.xy16.y  = (short)pbd->rOrigSrc.top;
#ifdef  DX7
                            if (dwAFlags & DDABLT_NOBLEND) {

                                while (freeCount < 2)
                                    NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
                                freeCount -= 2;

                                dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_BLIT) | 0x40000;
                                dmaPusherPutAddress[1] = NV_DD_SRCCOPY_IMAGE_BLIT;

                                dmaPusherPutAddress += 2;
                            }
#endif  /* DX7 */
                            /* This will need redone to deal with directional copying */
                            while (--nRects >= 0) {
                                wDestXY.xy16.x = (short)pClipRects->left;
                                wDestXY.xy16.y = (short)pClipRects->top;
                                wXYext.wh16.w = (unsigned short)(pClipRects->right - pClipRects->left);
                                wXYext.wh16.h = (unsigned short)(pClipRects->bottom - pClipRects->top);
                                pClipRects++;

                                wSrcXY.xy16.x = wOrigSrcXY.xy16.x +
                                    wDestXY.xy16.x - wOrigDestXY.xy16.x;
                                wSrcXY.xy16.y = wOrigSrcXY.xy16.y +
                                    wDestXY.xy16.y - wOrigDestXY.xy16.y;

                                while (freeCount < 4)
                                    NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
                                freeCount -= 4;

                                dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_BLIT) +
                                    BLIT_POINT_IN_OFFSET | 0xC0000;
                                dmaPusherPutAddress[1] = wSrcXY.xy;
                                dmaPusherPutAddress[2] = wDestXY.xy;
                                dmaPusherPutAddress[3] = wXYext.wh;

                                dmaPusherPutAddress += 4;
                            }
#ifdef  DX7
                            if (dwAFlags & DDABLT_NOBLEND) {

                                while (freeCount < 2)
                                    NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
                                freeCount -= 2;

                                dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_BLIT) | 0x40000;
                                dmaPusherPutAddress[1] = NV_DD_IMAGE_BLIT;

                                dmaPusherPutAddress += 2;
                            }
#endif  /* DX7 */
                        } else { /* unclipped */
#ifdef  DX7
                            if (dwAFlags & DDABLT_NOBLEND) {

                                while (freeCount < 2)
                                    NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
                                freeCount -= 2;

                                dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_BLIT) | 0x40000;
                                dmaPusherPutAddress[1] = NV_DD_SRCCOPY_IMAGE_BLIT;

                                dmaPusherPutAddress += 2;
                            }
#endif  /* DX7 */
                            /* unclipped AlphaBlt MUST clip to destination */
                            if (wDestXY.xy16.x < 0)
                                wDestXY.xy16.x = 0;
                            if (wDestXY.xy16.y < 0)
                                wDestXY.xy16.y = 0;
                            if (wDestXY.xy16.x + wXYext.wh16.w > dst->wWidth)
                                wXYext.wh16.w = dst->wWidth - wDestXY.xy16.x;
                            if (wDestXY.xy16.y + wXYext.wh16.h > dst->wHeight)
                                wXYext.wh16.h = dst->wHeight - wDestXY.xy16.y;
                            /* handle NULL destination rectangle case */
                            if ((wDestXY.xy16.x == 0) && (wXYext.wh16.w == 0))
                                wXYext.wh16.w = dst->wWidth;
                            if ((wDestXY.xy16.y == 0) && (wXYext.wh16.h == 0))
                                wXYext.wh16.h = dst->wHeight;

                            while (freeCount < 4)
                                NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
                            freeCount -= 4;

                            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_BLIT) +
                                BLIT_POINT_IN_OFFSET | 0xC0000;
                            dmaPusherPutAddress[1] = wSrcXY.xy;
                            dmaPusherPutAddress[2] = wDestXY.xy;
                            dmaPusherPutAddress[3] = wXYext.wh;

                            dmaPusherPutAddress += 4;
#ifdef  DX7
                            if (dwAFlags & DDABLT_NOBLEND) {

                                while (freeCount < 2)
                                    NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
                                freeCount -= 2;

                                dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_BLIT) | 0x40000;
                                dmaPusherPutAddress[1] = NV_DD_IMAGE_BLIT;

                                dmaPusherPutAddress += 2;
                            }
#endif  /* DX7 */
                        }

                        while (freeCount < 2)
                            NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
                        freeCount -= 2;

                        /* Restore default destination color format */
                        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                            SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x80000;
                        dmaPusherPutAddress[1] = NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8;

                        dmaPusherPutAddress += 2;

                    } else { /* regular non-alpha blit */

                        while (freeCount < 10)
                            NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);
                        freeCount -= 10;

                        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
                            SET_ROP_OFFSET | 0x40000;
                        dmaPusherPutAddress[1] = dwRop;

                        dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                            SURFACES_2D_PITCH_OFFSET | 0xC0000;
                        dmaPusherPutAddress[3] = (dwDstPitch << 16) | dwSrcPitch;
                        dmaPusherPutAddress[4] = dwSrcOffset;
                        dmaPusherPutAddress[5] = dwDstOffset;

                        dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_BLIT) +
                            BLIT_POINT_IN_OFFSET | 0xC0000;
                        dmaPusherPutAddress[7] = wSrcXY.xy;
                        dmaPusherPutAddress[8] = wDestXY.xy;
                        dmaPusherPutAddress[9] = wXYext.wh;

                        dmaPusherPutAddress += 10;
                    }

                } else {
                    // memory to screen blt (src may be in system memory or in video memory)
                   unsigned long temp;
                   long srcScanLength;
                   long nxtSrcScan;
                   short n = wXYext.wh16.h;
                   FAST short pxlCount;
                   unsigned long *pSrcInitBits;

                   pSrcInitBits = (unsigned long *)src->fpVidMem;
                   srcScanLength = src->lPitch >> 2;

                   if (doMirrorUpDown)
                       wSrcXY.xy16.y += (n - 1);

                   pSrcInitBits += (wSrcXY.xy16.y * srcScanLength);

                   temp = wXYext.wh16.w;

                   nxtSrcScan = srcScanLength - temp;

                   if (doMirrorUpDown)
                       nxtSrcScan = -srcScanLength - temp;

                   pSrcInitBits += wSrcXY.xy16.x;

                   if (isAlphaBlt) {

                       while (freeCount < 12)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 12, dmaPusherPutAddress);
                       freeCount -= 12;

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                           SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x40000;
                       dmaPusherPutAddress[1] = NV042_SET_COLOR_FORMAT_LE_A8R8G8B8;

                       dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                           SURFACES_2D_DEST_OFFSET | 0x40000;
                       dmaPusherPutAddress[3] = dwDstOffset;
                       dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                           SURFACES_2D_PITCH_OFFSET | 0x40000;
                       dmaPusherPutAddress[5] = (dwDstPitch << 16) | dwDstPitch;

                       dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                       dmaPusherPutAddress[7] = NV_DD_CONTEXT_BETA4;
#ifdef  DX7
                       dwMultipliers = pbd->ddrgbaScaleFactors.alpha << 24;
                       dwMultipliers |= pbd->ddrgbaScaleFactors.red << 16;
                       dwMultipliers |= pbd->ddrgbaScaleFactors.green << 8;
                       dwMultipliers |= pbd->ddrgbaScaleFactors.blue;
#endif  /* DX7 */
                       dmaPusherPutAddress[8] = dDrawSubchannelOffset(NV_DD_SPARE) +
                           BETA4_SET_BETA_FACTOR_OFFSET | 0x40000;
                       dmaPusherPutAddress[9] = dwMultipliers;
#ifdef  DX7
                       dmaPusherPutAddress[10] = dDrawSubchannelOffset(NV_DD_IMAGE) | 0x40000;

                       if (dwAFlags & DDABLT_NOBLEND)
                           dmaPusherPutAddress[11] =
                               NV_DD_SRCCOPY_IMAGE_FROM_CPU;
                       else
                           dmaPusherPutAddress[11] =
                               NV_DD_ABLEND_IMAGE_FROM_CPU;

                       dmaPusherPutAddress += 12;
#else   /* DX7 */
                       dmaPusherPutAddress += 10;
#endif  /* DX7 */

                       if (isClipped) {
                           DWORD nRects = pbd->dwRectCnt;
                           LPRECT pClipRects = pbd->prDestRects;
                           NVCOORD wOrigDestXY;
                           NVCOORD wOrigSrcXY;

                           wOrigDestXY.xy16.x = (short)pbd->rOrigDest.left;
                           wOrigDestXY.xy16.y = (short)pbd->rOrigDest.top;
                           wOrigSrcXY.xy16.x  = (short)pbd->rOrigSrc.left;
                           wOrigSrcXY.xy16.y  = (short)pbd->rOrigSrc.top;

                           while (--nRects >= 0) {
                               wDestXY.xy16.x = (short)pClipRects->left;
                               wDestXY.xy16.y = (short)pClipRects->top;
                               wXYext.wh16.w = (unsigned short)(pClipRects->right - pClipRects->left);
                               wXYext.wh16.h = (unsigned short)(pClipRects->bottom - pClipRects->top);
                               pClipRects++;

                               wSrcXY.xy16.x = wOrigSrcXY.xy16.x +
                                   wDestXY.xy16.x - wOrigDestXY.xy16.x;
                               wSrcXY.xy16.y = wOrigSrcXY.xy16.y +
                                   wDestXY.xy16.y - wOrigDestXY.xy16.y;

                               pSrcInitBits = (unsigned long *)src->fpVidMem;

                               n = wXYext.wh16.h;

                               if (doMirrorUpDown)
                                   wSrcXY.xy16.y += (n - 1);

                               pSrcInitBits += (wSrcXY.xy16.y * srcScanLength);

                               temp = wXYext.wh16.w;

                               nxtSrcScan = srcScanLength - temp;

                               if (doMirrorUpDown)
                                   nxtSrcScan = -srcScanLength - temp;

                               pSrcInitBits += wSrcXY.xy16.x;

                               while (freeCount < 4)
                                   NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
                               freeCount -= 4;

                               dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                                   IMAGE_FROM_CPU_POINT_OFFSET | 0xC0000;
                               dmaPusherPutAddress[1] = wDestXY.xy;
                               dmaPusherPutAddress[2] = wXYext.wh;
                               dmaPusherPutAddress[3] = wXYext.wh;

                               dmaPusherPutAddress += 4;

                               {
                                   FAST unsigned long *pSrcBits = (unsigned long *)pSrcInitBits;
                                   FAST unsigned long tmpPxls0, tmpPxls1, tmpPxls2;

                                   if (temp < 1792) {
                                       while (--n >= 0) {
                                           pxlCount = (short)temp;

                                           // Get enough buffer space for this scanline
                                           while (freeCount < (long)(1 + temp))
                                               NvGetDmaBufferFreeCount(npDev, freeCount, (long)(1 + temp), dmaPusherPutAddress);
                                           freeCount -= (long)(1 + temp);

                                           dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                                               IMAGE_FROM_CPU_COLOR_OFFSET | (temp << 18);

                                           dmaPusherPutAddress += 1;

                                           while (pxlCount >= 16) {
                                               pxlCount -= 16;

                                               tmpPxls0 = pSrcBits[0];
                                               tmpPxls1 = pSrcBits[1];
                                               dmaPusherPutAddress[0] = tmpPxls0;
                                               tmpPxls2 = pSrcBits[2];
                                               dmaPusherPutAddress[1] = tmpPxls1;
                                               tmpPxls0 = pSrcBits[3];
                                               tmpPxls1 = pSrcBits[4];
                                               dmaPusherPutAddress[2] = tmpPxls2;
                                               dmaPusherPutAddress[3] = tmpPxls0;
                                               tmpPxls2 = pSrcBits[5];
                                               tmpPxls0 = pSrcBits[6];
                                               dmaPusherPutAddress[4] = tmpPxls1;
                                               dmaPusherPutAddress[5] = tmpPxls2;
                                               tmpPxls1 = pSrcBits[7];
                                               tmpPxls2 = pSrcBits[8];
                                               dmaPusherPutAddress[6] = tmpPxls0;
                                               dmaPusherPutAddress[7] = tmpPxls1;
                                               tmpPxls0 = pSrcBits[9];
                                               tmpPxls1 = pSrcBits[10];
                                               dmaPusherPutAddress[8] = tmpPxls2;
                                               dmaPusherPutAddress[9] = tmpPxls0;
                                               tmpPxls2 = pSrcBits[11];
                                               tmpPxls0 = pSrcBits[12];
                                               dmaPusherPutAddress[10] = tmpPxls1;
                                               dmaPusherPutAddress[11] = tmpPxls2;
                                               tmpPxls1 = pSrcBits[13];
                                               tmpPxls2 = pSrcBits[14];
                                               dmaPusherPutAddress[12] = tmpPxls0;
                                               dmaPusherPutAddress[13] = tmpPxls1;
                                               tmpPxls0 = pSrcBits[15];
                                               dmaPusherPutAddress[14] = tmpPxls2;
                                               pSrcBits += 16;
                                               dmaPusherPutAddress[15] = tmpPxls0;
                                               dmaPusherPutAddress += 16;
                                           }

                                           if (pxlCount > 0) {
                                               while (--pxlCount >= 0) {
                                                   tmpPxls0 = pSrcBits[0];
                                                   pSrcBits += 1;
                                                   dmaPusherPutAddress[0] = tmpPxls0;
                                                   dmaPusherPutAddress++;
                                               }
                                           }

                                           pSrcBits += nxtSrcScan;

                                           /* Force write combine buffer to flush */
                                           pDriverData->NvDmaPusherBufferEnd[0] = 0;
                                           /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                                           _outp (0x3d0,0);

                                           pDriverData->dwDmaPusherFreeCount = freeCount;

                                           npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;
                                       }
                                   } else { /* more than 1792 pixels per scanline */
                                       while (--n >= 0) {
                                           pxlCount = (short)temp;

                                           while (pxlCount >= 16) {
                                               pxlCount -= 16;

                                               while (freeCount < (1 + 16))
                                                   NvGetDmaBufferFreeCount(npDev, freeCount, (1 + 16), dmaPusherPutAddress);
                                               freeCount -= (1 + 16);

                                               dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                                                   IMAGE_FROM_CPU_COLOR_OFFSET | (16 << 18);

                                               tmpPxls0 = pSrcBits[0];
                                               tmpPxls1 = pSrcBits[1];
                                               dmaPusherPutAddress[1] = tmpPxls0;
                                               tmpPxls2 = pSrcBits[2];
                                               dmaPusherPutAddress[2] = tmpPxls1;
                                               tmpPxls0 = pSrcBits[3];
                                               tmpPxls1 = pSrcBits[4];
                                               dmaPusherPutAddress[3] = tmpPxls2;
                                               dmaPusherPutAddress[4] = tmpPxls0;
                                               tmpPxls2 = pSrcBits[5];
                                               tmpPxls0 = pSrcBits[6];
                                               dmaPusherPutAddress[5] = tmpPxls1;
                                               dmaPusherPutAddress[6] = tmpPxls2;
                                               tmpPxls1 = pSrcBits[7];
                                               tmpPxls2 = pSrcBits[8];
                                               dmaPusherPutAddress[7] = tmpPxls0;
                                               dmaPusherPutAddress[8] = tmpPxls1;
                                               tmpPxls0 = pSrcBits[9];
                                               tmpPxls1 = pSrcBits[10];
                                               dmaPusherPutAddress[9] = tmpPxls2;
                                               dmaPusherPutAddress[10] = tmpPxls0;
                                               tmpPxls2 = pSrcBits[11];
                                               tmpPxls0 = pSrcBits[12];
                                               dmaPusherPutAddress[11] = tmpPxls1;
                                               dmaPusherPutAddress[12] = tmpPxls2;
                                               tmpPxls1 = pSrcBits[13];
                                               tmpPxls2 = pSrcBits[14];
                                               dmaPusherPutAddress[13] = tmpPxls0;
                                               dmaPusherPutAddress[14] = tmpPxls1;
                                               tmpPxls0 = pSrcBits[15];
                                               dmaPusherPutAddress[15] = tmpPxls2;
                                               pSrcBits += 16;
                                               dmaPusherPutAddress[16] = tmpPxls0;

                                               dmaPusherPutAddress += 17;
                                           }

                                           if (pxlCount > 0) {
                                               while (freeCount < (1 + pxlCount))
                                                   NvGetDmaBufferFreeCount(npDev, freeCount, (1 + pxlCount), dmaPusherPutAddress);
                                               freeCount -= (1 + pxlCount);

                                               dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                                                   IMAGE_FROM_CPU_COLOR_OFFSET | (pxlCount << 18);

                                               dmaPusherPutAddress += 1;

                                               while (--pxlCount >= 0) {
                                                   tmpPxls0 = pSrcBits[0];
                                                   pSrcBits += 1;
                                                   dmaPusherPutAddress[0] = tmpPxls0;
                                                   dmaPusherPutAddress++;
                                               }
                                           }

                                           pSrcBits += nxtSrcScan;

                                           /* Force write combine buffer to flush */
                                           pDriverData->NvDmaPusherBufferEnd[0] = 0;
                                           /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                                           _outp (0x3d0,0);

                                           pDriverData->dwDmaPusherFreeCount = freeCount;

                                           npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;
                                       }
                                   }
                               }
                           }
                       } else { // unclipped

                           /* unclipped AlphaBlt MUST clip to destination */
                           if (wDestXY.xy16.x < 0)
                               wDestXY.xy16.x = 0;
                           if (wDestXY.xy16.y < 0)
                               wDestXY.xy16.y = 0;
                           if (wDestXY.xy16.x + wXYext.wh16.w > dst->wWidth)
                               wXYext.wh16.w = dst->wWidth - wDestXY.xy16.x;
                           if (wDestXY.xy16.y + wXYext.wh16.h > dst->wHeight)
                               wXYext.wh16.h = dst->wHeight - wDestXY.xy16.y;
                           /* handle NULL destination rectangle case */
                           if ((wDestXY.xy16.x == 0) && (wXYext.wh16.w == 0))
                               wXYext.wh16.w = dst->wWidth;
                           if ((wDestXY.xy16.y == 0) && (wXYext.wh16.h == 0))
                               wXYext.wh16.h = dst->wHeight;

                           while (freeCount < 4)
                               NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
                           freeCount -= 4;

                           dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                               IMAGE_FROM_CPU_POINT_OFFSET | 0xC0000;
                           dmaPusherPutAddress[1] = wDestXY.xy;
                           dmaPusherPutAddress[2] = wXYext.wh;
                           dmaPusherPutAddress[3] = wXYext.wh;

                           dmaPusherPutAddress += 4;

                           {
                               FAST unsigned long *pSrcBits = (unsigned long *)pSrcInitBits;
                               FAST unsigned long tmpPxls0, tmpPxls1, tmpPxls2;

                               if (temp < 1792) {

                                   while (--n >= 0) {
                                       pxlCount = (short)temp;

                                       // Get enough buffer space for this scanline
                                       while (freeCount < (long)(1 + temp))
                                           NvGetDmaBufferFreeCount(npDev, freeCount, (long)(1 + temp), dmaPusherPutAddress);
                                       freeCount -= (long)(1 + temp);

                                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                                           IMAGE_FROM_CPU_COLOR_OFFSET | (temp << 18);

                                       dmaPusherPutAddress += 1;

                                       while (pxlCount >= 16) {
                                           pxlCount -= 16;

                                           tmpPxls0 = pSrcBits[0];
                                           tmpPxls1 = pSrcBits[1];
                                           dmaPusherPutAddress[0] = tmpPxls0;
                                           tmpPxls2 = pSrcBits[2];
                                           dmaPusherPutAddress[1] = tmpPxls1;
                                           tmpPxls0 = pSrcBits[3];
                                           tmpPxls1 = pSrcBits[4];
                                           dmaPusherPutAddress[2] = tmpPxls2;
                                           dmaPusherPutAddress[3] = tmpPxls0;
                                           tmpPxls2 = pSrcBits[5];
                                           tmpPxls0 = pSrcBits[6];
                                           dmaPusherPutAddress[4] = tmpPxls1;
                                           dmaPusherPutAddress[5] = tmpPxls2;
                                           tmpPxls1 = pSrcBits[7];
                                           tmpPxls2 = pSrcBits[8];
                                           dmaPusherPutAddress[6] = tmpPxls0;
                                           dmaPusherPutAddress[7] = tmpPxls1;
                                           tmpPxls0 = pSrcBits[9];
                                           tmpPxls1 = pSrcBits[10];
                                           dmaPusherPutAddress[8] = tmpPxls2;
                                           dmaPusherPutAddress[9] = tmpPxls0;
                                           tmpPxls2 = pSrcBits[11];
                                           tmpPxls0 = pSrcBits[12];
                                           dmaPusherPutAddress[10] = tmpPxls1;
                                           dmaPusherPutAddress[11] = tmpPxls2;
                                           tmpPxls1 = pSrcBits[13];
                                           tmpPxls2 = pSrcBits[14];
                                           dmaPusherPutAddress[12] = tmpPxls0;
                                           dmaPusherPutAddress[13] = tmpPxls1;
                                           tmpPxls0 = pSrcBits[15];
                                           dmaPusherPutAddress[14] = tmpPxls2;
                                           pSrcBits += 16;
                                           dmaPusherPutAddress[15] = tmpPxls0;
                                           dmaPusherPutAddress += 16;
                                       }

                                       if (pxlCount > 0) {
                                           while (--pxlCount >= 0) {
                                               tmpPxls0 = pSrcBits[0];
                                               pSrcBits += 1;
                                               dmaPusherPutAddress[0] = tmpPxls0;
                                               dmaPusherPutAddress++;
                                           }
                                       }

                                       pSrcBits += nxtSrcScan;

                                       /* Force write combine buffer to flush */
                                       pDriverData->NvDmaPusherBufferEnd[0] = 0;
                                       /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                                       _outp (0x3d0,0);

                                       pDriverData->dwDmaPusherFreeCount = freeCount;

                                       npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;
                                   }
                               } else { /* more than 1792 pixels per scanline */

                                   while (--n >= 0) {
                                       pxlCount = (short)temp;

                                       while (pxlCount >= 16) {
                                           pxlCount -= 16;

                                           while (freeCount < (1 + 16))
                                               NvGetDmaBufferFreeCount(npDev, freeCount, (1 + 16), dmaPusherPutAddress);
                                           freeCount -= (1 + 16);

                                           dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                                               IMAGE_FROM_CPU_COLOR_OFFSET | (16 << 18);

                                           tmpPxls0 = pSrcBits[0];
                                           tmpPxls1 = pSrcBits[1];
                                           dmaPusherPutAddress[1] = tmpPxls0;
                                           tmpPxls2 = pSrcBits[2];
                                           dmaPusherPutAddress[2] = tmpPxls1;
                                           tmpPxls0 = pSrcBits[3];
                                           tmpPxls1 = pSrcBits[4];
                                           dmaPusherPutAddress[3] = tmpPxls2;
                                           dmaPusherPutAddress[4] = tmpPxls0;
                                           tmpPxls2 = pSrcBits[5];
                                           tmpPxls0 = pSrcBits[6];
                                           dmaPusherPutAddress[5] = tmpPxls1;
                                           dmaPusherPutAddress[6] = tmpPxls2;
                                           tmpPxls1 = pSrcBits[7];
                                           tmpPxls2 = pSrcBits[8];
                                           dmaPusherPutAddress[7] = tmpPxls0;
                                           dmaPusherPutAddress[8] = tmpPxls1;
                                           tmpPxls0 = pSrcBits[9];
                                           tmpPxls1 = pSrcBits[10];
                                           dmaPusherPutAddress[9] = tmpPxls2;
                                           dmaPusherPutAddress[10] = tmpPxls0;
                                           tmpPxls2 = pSrcBits[11];
                                           tmpPxls0 = pSrcBits[12];
                                           dmaPusherPutAddress[11] = tmpPxls1;
                                           dmaPusherPutAddress[12] = tmpPxls2;
                                           tmpPxls1 = pSrcBits[13];
                                           tmpPxls2 = pSrcBits[14];
                                           dmaPusherPutAddress[13] = tmpPxls0;
                                           dmaPusherPutAddress[14] = tmpPxls1;
                                           tmpPxls0 = pSrcBits[15];
                                           dmaPusherPutAddress[15] = tmpPxls2;
                                           pSrcBits += 16;
                                           dmaPusherPutAddress[16] = tmpPxls0;
                                           dmaPusherPutAddress += 17;
                                       }

                                       if (pxlCount > 0) {
                                           while (freeCount < (1 + pxlCount))
                                               NvGetDmaBufferFreeCount(npDev, freeCount, (1 + pxlCount), dmaPusherPutAddress);
                                           freeCount -= (1 + pxlCount);

                                           dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                                               IMAGE_FROM_CPU_COLOR_OFFSET | (pxlCount << 18);

                                           dmaPusherPutAddress += 1;

                                           while (--pxlCount >= 0) {
                                               tmpPxls0 = pSrcBits[0];
                                               pSrcBits += 1;
                                               dmaPusherPutAddress[0] = tmpPxls0;
                                               dmaPusherPutAddress++;
                                           }
                                       }

                                       pSrcBits += nxtSrcScan;

                                       /* Force write combine buffer to flush */
                                       pDriverData->NvDmaPusherBufferEnd[0] = 0;
                                       /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                                       _outp (0x3d0,0);

                                       pDriverData->dwDmaPusherFreeCount = freeCount;

                                       npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;
                                   }
                               }
                           }
                       }

                       while (freeCount < 4)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
                       freeCount -= 4;

                       /* Restore default destination color format */
                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                           SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x80000;
                       dmaPusherPutAddress[1] = NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8;

                       /* Restore default object */
                       dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_IMAGE) | 0x40000;
                       dmaPusherPutAddress[3] = NV_DD_IMAGE_FROM_CPU;

                       dmaPusherPutAddress += 4;

                   } else { /* non-alpha blit */

                       FAST unsigned long *pSrcBits = (unsigned long *)pSrcInitBits;
                       FAST unsigned long tmpPxls0, tmpPxls1, tmpPxls2;

                       while (freeCount < 10)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);
                       freeCount -= 10;

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
                           SET_ROP_OFFSET | 0x40000;
                       dmaPusherPutAddress[1] = dwRop;

                       dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                           SURFACES_2D_DEST_OFFSET | 0x40000;
                       dmaPusherPutAddress[3] = dwDstOffset;
                       dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                           SURFACES_2D_PITCH_OFFSET | 0x40000;
                       dmaPusherPutAddress[5] = (dwDstPitch << 16) | dwDstPitch;

                       dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                           IMAGE_FROM_CPU_POINT_OFFSET | 0xC0000;
                       dmaPusherPutAddress[7] = wDestXY.xy;
                       dmaPusherPutAddress[8] = wXYext.wh;
                       dmaPusherPutAddress[9] = wXYext.wh;

                       dmaPusherPutAddress += 10;

                       if (temp < 1792) {

                           while (--n >= 0) {
                               pxlCount = (short)temp;

                               // Get enough buffer space for this scanline
                               while (freeCount < (long)(1 + temp))
                                   NvGetDmaBufferFreeCount(npDev, freeCount, (long)(1 + temp), dmaPusherPutAddress);
                               freeCount -= (long)(1 + temp);

                               dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                                   IMAGE_FROM_CPU_COLOR_OFFSET | (temp << 18);

                               dmaPusherPutAddress += 1;

                               while (pxlCount >= 16) {
                                   pxlCount -= 16;

                                   tmpPxls0 = pSrcBits[0];
                                   tmpPxls1 = pSrcBits[1];
                                   dmaPusherPutAddress[0] = tmpPxls0;
                                   tmpPxls2 = pSrcBits[2];
                                   dmaPusherPutAddress[1] = tmpPxls1;
                                   tmpPxls0 = pSrcBits[3];
                                   tmpPxls1 = pSrcBits[4];
                                   dmaPusherPutAddress[2] = tmpPxls2;
                                   dmaPusherPutAddress[3] = tmpPxls0;
                                   tmpPxls2 = pSrcBits[5];
                                   tmpPxls0 = pSrcBits[6];
                                   dmaPusherPutAddress[4] = tmpPxls1;
                                   dmaPusherPutAddress[5] = tmpPxls2;
                                   tmpPxls1 = pSrcBits[7];
                                   tmpPxls2 = pSrcBits[8];
                                   dmaPusherPutAddress[6] = tmpPxls0;
                                   dmaPusherPutAddress[7] = tmpPxls1;
                                   tmpPxls0 = pSrcBits[9];
                                   tmpPxls1 = pSrcBits[10];
                                   dmaPusherPutAddress[8] = tmpPxls2;
                                   dmaPusherPutAddress[9] = tmpPxls0;
                                   tmpPxls2 = pSrcBits[11];
                                   tmpPxls0 = pSrcBits[12];
                                   dmaPusherPutAddress[10] = tmpPxls1;
                                   dmaPusherPutAddress[11] = tmpPxls2;
                                   tmpPxls1 = pSrcBits[13];
                                   tmpPxls2 = pSrcBits[14];
                                   dmaPusherPutAddress[12] = tmpPxls0;
                                   dmaPusherPutAddress[13] = tmpPxls1;
                                   tmpPxls0 = pSrcBits[15];
                                   dmaPusherPutAddress[14] = tmpPxls2;
                                   pSrcBits += 16;
                                   dmaPusherPutAddress[15] = tmpPxls0;
                                   dmaPusherPutAddress += 16;
                               }

                               if (pxlCount > 0) {
                                   while (--pxlCount >= 0) {
                                       tmpPxls0 = pSrcBits[0];
                                       pSrcBits += 1;
                                       dmaPusherPutAddress[0] = tmpPxls0;
                                       dmaPusherPutAddress++;
                                   }
                               }

                               pSrcBits += nxtSrcScan;

                               /* Force write combine buffer to flush */
                               pDriverData->NvDmaPusherBufferEnd[0] = 0;
                               /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                               _outp (0x3d0,0);

                               pDriverData->dwDmaPusherFreeCount = freeCount;

                               npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;
                           }
                       } else { /* more than 1792 pixels per scanline */

                           while (--n >= 0) {
                               pxlCount = (short)temp;

                               while (pxlCount >= 16) {
                                   pxlCount -= 16;

                                   while (freeCount < (1 + 16))
                                       NvGetDmaBufferFreeCount(npDev, freeCount, (1 + 16), dmaPusherPutAddress);
                                   freeCount -= (1 + 16);

                                   dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                                       IMAGE_FROM_CPU_COLOR_OFFSET | (16 << 18);

                                   tmpPxls0 = pSrcBits[0];
                                   tmpPxls1 = pSrcBits[1];
                                   dmaPusherPutAddress[1] = tmpPxls0;
                                   tmpPxls2 = pSrcBits[2];
                                   dmaPusherPutAddress[2] = tmpPxls1;
                                   tmpPxls0 = pSrcBits[3];
                                   tmpPxls1 = pSrcBits[4];
                                   dmaPusherPutAddress[3] = tmpPxls2;
                                   dmaPusherPutAddress[4] = tmpPxls0;
                                   tmpPxls2 = pSrcBits[5];
                                   tmpPxls0 = pSrcBits[6];
                                   dmaPusherPutAddress[5] = tmpPxls1;
                                   dmaPusherPutAddress[6] = tmpPxls2;
                                   tmpPxls1 = pSrcBits[7];
                                   tmpPxls2 = pSrcBits[8];
                                   dmaPusherPutAddress[7] = tmpPxls0;
                                   dmaPusherPutAddress[8] = tmpPxls1;
                                   tmpPxls0 = pSrcBits[9];
                                   tmpPxls1 = pSrcBits[10];
                                   dmaPusherPutAddress[9] = tmpPxls2;
                                   dmaPusherPutAddress[10] = tmpPxls0;
                                   tmpPxls2 = pSrcBits[11];
                                   tmpPxls0 = pSrcBits[12];
                                   dmaPusherPutAddress[11] = tmpPxls1;
                                   dmaPusherPutAddress[12] = tmpPxls2;
                                   tmpPxls1 = pSrcBits[13];
                                   tmpPxls2 = pSrcBits[14];
                                   dmaPusherPutAddress[13] = tmpPxls0;
                                   dmaPusherPutAddress[14] = tmpPxls1;
                                   tmpPxls0 = pSrcBits[15];
                                   dmaPusherPutAddress[15] = tmpPxls2;
                                   pSrcBits += 16;
                                   dmaPusherPutAddress[16] = tmpPxls0;
                                   dmaPusherPutAddress += 17;
                               }

                               if (pxlCount > 0) {
                                   while (freeCount < (1 + pxlCount))
                                       NvGetDmaBufferFreeCount(npDev, freeCount, (1 + pxlCount), dmaPusherPutAddress);
                                   freeCount -= (1 + pxlCount);

                                   dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                                       IMAGE_FROM_CPU_COLOR_OFFSET | (pxlCount << 18);

                                   dmaPusherPutAddress += 1;

                                   while (--pxlCount >= 0) {
                                       tmpPxls0 = pSrcBits[0];
                                       pSrcBits += 1;
                                       dmaPusherPutAddress[0] = tmpPxls0;
                                       dmaPusherPutAddress++;
                                   }
                               }

                               pSrcBits += nxtSrcScan;

                               /* Force write combine buffer to flush */
                               pDriverData->NvDmaPusherBufferEnd[0] = 0;
                               /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                               _outp (0x3d0,0);

                               pDriverData->dwDmaPusherFreeCount = freeCount;

                               npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;
                           }
                       }
                   }
               }
            } else { // stretch
                RECT rDummy;
                BOOL isOverlappingVmem = FALSE;
                FLATPTR lpSurfTemp = 0;
                DWORD dwSrcBitsPP = 32;
                BOOL useStretched = FALSE;

                /*
                 *  Fractional positioning bands of the SCALED IMAGE class when downscaling
                 *  vertically by small amounts is just too hard to get correct so we switch to the
                 *  STRETCHED IMAGE class when that occurs.
                 */

                if ((!(dwSrcCaps & DDSCAPS_VIDEOMEMORY)) && (dwSrcHeight > dwDstHeight))
                    useStretched = TRUE;

                // if the source and destination overlap, then we must do this in 2 passes, first copy the source
                // image somewhere else, and then so the stretch from there.
                if ((dwSrcCaps & DDSCAPS_VIDEOMEMORY) && dwSrcOffset == dwDstOffset && IntersectRect(&rDummy, (LPRECT)(&pbd->rSrc), (LPRECT)(&pbd->rDest))) {
                    NVHEAP_ALLOC(lpSurfTemp, dwSrcHeight * ((dwSrcWidth * dwSrcBitsPP / 8 + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad), TYPE_IMAGE);
                    if (lpSurfTemp) {
                        isOverlappingVmem = TRUE;
                        if (pDriverData->dwSharedClipChangeCount != pDriverData->dwDDMostRecentClipChangeCount) {

                            while (freeCount < 7)
                                NvGetDmaBufferFreeCount(npDev, freeCount, 7, dmaPusherPutAddress);
                            freeCount -= 7;

                            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000;
                            dmaPusherPutAddress[1] = NV_DD_IMAGE_BLACK_RECTANGLE;
                            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                                IMAGE_BLACK_RECTANGLE_POINT_OFFSET | 0x80000;
                            dmaPusherPutAddress[3] = 0;
                            dmaPusherPutAddress[4] = asmMergeCoords(NV_MAX_X_CLIP, NV_MAX_Y_CLIP);
                            dmaPusherPutAddress[5] = dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000;
                            dmaPusherPutAddress[6] = NV_DD_SURFACES_2D;

                            dmaPusherPutAddress += 7;

                            pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

                            /* Force write combine buffer to flush */
                            pDriverData->NvDmaPusherBufferEnd[0] = 0;
                            /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                            _outp (0x3d0,0);

                            pDriverData->dwDmaPusherFreeCount = freeCount;

                            npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                            pDriverData->dwSharedClipChangeCount++;

                            pDriverData->dwDDMostRecentClipChangeCount = pDriverData->dwSharedClipChangeCount;
                        }

                        while (freeCount < 10)
                            NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);
                        freeCount -= 10;

                        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
                            SET_ROP_OFFSET | 0x40000;
                        dmaPusherPutAddress[1] = dwRop;

                        dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                            SURFACES_2D_PITCH_OFFSET | 0xC0000;
                        dmaPusherPutAddress[3] = ((((dwSrcWidth * dwSrcBitsPP / 8 + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad)) << 16) | dwSrcPitch;
                        dmaPusherPutAddress[4] = dwSrcOffset;
                        dmaPusherPutAddress[5] = lpSurfTemp - pDriverData->BaseAddress;

                        dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_BLIT) +
                            BLIT_POINT_IN_OFFSET | 0xC0000;
                        dmaPusherPutAddress[7] = wSrcXY.xy;
                        dmaPusherPutAddress[8] = 0;
                        dmaPusherPutAddress[9] = wXYext.wh;

                        dmaPusherPutAddress += 10;

                        dwSrcOffset = lpSurfTemp - pDriverData->BaseAddress;
                        dwSrcPitch = ((dwSrcWidth * dwSrcBitsPP / 8 + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad);
                        wSrcXY.xy = 0;
                        wSrcXY.xy16.x = 0;
                        wSrcXY.xy16.y = 0;
                    } else {
                        // FIXME: vmem heap alloc failed, must do system mem alloc and copy there
                    }
                }
                // WARNING: carefully consider each use of src->fpVidMem and src->lPitch beyond this point
                //          it could screw up overlapping stretchblits

               if ((dwFlags & DDBLT_KEYSRCOVERRIDE) || (isKeySrc) || (useStretched)) { // If color key then MUST use STRETCHED IMAGE instead of SCALED IMAGE
                   NvNotification *pDmaBufferNotifier;
                   unsigned char *pScanlineBuffer;
                   long srcScanLength;
                   long nxtSrcScan;
                   long n;
                   short m;
                   FAST short pxlCount;
                   unsigned char *pSrcInitBits;
                   unsigned char *pSaveSrcBits;
                   unsigned char *pSrcCurScan;
                   long deltaX;
                   long deltaY;
                   long curDstY;
                   long lastDstY;
                   NVCOORD wSrcExt;
                   NVCOORD wDstPoint;
                   unsigned long srcStrtX;
                   BYTE srcInVideoMemory = 0;
                   BYTE bufState = 0;
                   short skipV = 0;
                   DWORD nRects;
                   LPRECT pClipRects;
                   NVCOORD wOrigDestXY;
                   NVCOORD wOrigSrcXY;
                   unsigned long dwSrcXPos;
                   unsigned long dwSrcYPos;

//                   pSrcInitBits = (unsigned char *)src->fpVidMem;
//                   srcScanLength = src->lPitch;
                   pSrcInitBits = (unsigned char *)(dwSrcOffset + pDriverData->BaseAddress);
                   srcScanLength = dwSrcPitch;

                   if (dwSrcPitch <= 1600)
                       m = 8;
                   else if (dwSrcPitch <= 3200)
                       m = 4;
                   else
                       m = 2;

                   if (isAlphaBlt) {

                       while (freeCount < 12)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 12, dmaPusherPutAddress);
                       freeCount -= 12;

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                           SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x40000;
                       dmaPusherPutAddress[1] = NV042_SET_COLOR_FORMAT_LE_A8R8G8B8;

                       dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                           SURFACES_2D_DEST_OFFSET | 0x40000;
                       dmaPusherPutAddress[3] = dwDstOffset;
                       dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                           SURFACES_2D_PITCH_OFFSET | 0x40000;
                       dmaPusherPutAddress[5] = (dwDstPitch << 16) | dwDstPitch;

                       dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                       dmaPusherPutAddress[7] = NV_DD_CONTEXT_BETA4;
#ifdef  DX7
                       dwMultipliers = pbd->ddrgbaScaleFactors.alpha << 24;
                       dwMultipliers |= pbd->ddrgbaScaleFactors.red << 16;
                       dwMultipliers |= pbd->ddrgbaScaleFactors.green << 8;
                       dwMultipliers |= pbd->ddrgbaScaleFactors.blue;
#endif  /* DX7 */
                       dmaPusherPutAddress[8] = dDrawSubchannelOffset(NV_DD_SPARE) +
                           BETA4_SET_BETA_FACTOR_OFFSET | 0x40000;
                       dmaPusherPutAddress[9] = dwMultipliers;
#ifdef  DX7
                       dmaPusherPutAddress[10] = dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000;

                       if (dwAFlags & DDABLT_NOBLEND)
                           dmaPusherPutAddress[11] =
                               NV_DD_SRCCOPY_STRETCHED_IMAGE_FROM_CPU;
                       else
                           dmaPusherPutAddress[11] =
                               NV_DD_ABLEND_STRETCHED_IMAGE_FROM_CPU;

                       dmaPusherPutAddress += 12;
#else   DX7
                       dmaPusherPutAddress += 10;
#endif  /* DX7 */
                   } else { // regular blit

                       while (freeCount < 8)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 8, dmaPusherPutAddress);
                       freeCount -= 8;

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
                           SET_ROP_OFFSET | 0x40000;
                       dmaPusherPutAddress[1] = dwRop;

                       dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                           SURFACES_2D_DEST_OFFSET | 0x40000;
                       dmaPusherPutAddress[3] = dwDstOffset;
                       dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                           SURFACES_2D_PITCH_OFFSET | 0x40000;
                       dmaPusherPutAddress[5] = (dwDstPitch << 16) | dwDstPitch;

                       dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000;
                       dmaPusherPutAddress[7] = NV_DD_STRETCHED_IMAGE_FROM_CPU;

                       dmaPusherPutAddress += 8;
                   }

                   if (isClipped) {

                       nRects = pbd->dwRectCnt;
                       pClipRects = pbd->prDestRects;

                       wOrigDestXY.xy16.x = (short)pbd->rOrigDest.left;
                       wOrigDestXY.xy16.y = (short)pbd->rOrigDest.top;
                       wOrigSrcXY.xy16.x  = (short)pbd->rOrigSrc.left;
                       wOrigSrcXY.xy16.y  = (short)pbd->rOrigSrc.top;

                       dwDstWidth = pbd->rOrigDest.right - pbd->rOrigDest.left;
                       dwDstHeight = pbd->rOrigDest.bottom - pbd->rOrigDest.top;
                       dwSrcWidth = pbd->rOrigSrc.right - pbd->rOrigSrc.left;
                       dwSrcHeight = pbd->rOrigSrc.bottom - pbd->rOrigSrc.top;

                       /* calculate deltas in 12.20 format */
                       deltaX = dwDstWidth << 20;
                       deltaX /= dwSrcWidth;

                       if ((deltaX > 0x100000) && (deltaX & 0xFFFFF)) {
                           long xStretch = deltaX & 0xFFF00000;
                           deltaX = (dwDstWidth << 20) + xStretch;
                           deltaX /= dwSrcWidth;
                       }

                       if ((deltaX < 0x100000) && (deltaX & 0xFFFFF)) {
                           deltaX = (dwDstWidth << 20) + 0x100000;
                           deltaX /= dwSrcWidth;
                       }

                       deltaY = dwDstHeight << 20;
                       deltaY /= dwSrcHeight;

                       if ((deltaY > 0x100000) && (deltaY & 0xFFFFF)) {
                           long yStretch = deltaY & 0xFFF00000;
                           deltaY = (dwDstHeight << 20) + yStretch;
                           deltaY /= dwSrcHeight;
                       }

                       if ((deltaY < 0x100000) && (deltaY & 0xFFFFF)) {
                           deltaY = (dwDstHeight << 20) + 0x100000;
                           deltaY /= dwSrcHeight;
                       }
                   } else { // unclipped

                       /* calculate deltas in 12.20 format */
                       deltaX = dwDstWidth << 20;
                       deltaX /= dwSrcWidth;

                       if ((deltaX > 0x100000) && (deltaX & 0xFFFFF)) {
                           long xStretch = deltaX & 0xFFF00000;
                           deltaX = (dwDstWidth << 20) + xStretch;
                           deltaX /= dwSrcWidth;
                       }

                       if ((deltaX < 0x100000) && (deltaX & 0xFFFFF)) {
                           deltaX = (dwDstWidth << 20) + 0x100000;
                           deltaX /= dwSrcWidth;
                       }

                       deltaY = dwDstHeight << 20;
                       deltaY /= dwSrcHeight;

                       if ((deltaY > 0x100000) && (deltaY & 0xFFFFF)) {
                           long yStretch = deltaY & 0xFFF00000;
                           deltaY = (dwDstHeight << 20) + yStretch;
                           deltaY /= dwSrcHeight;
                       }

                       if ((deltaY < 0x100000) && (deltaY & 0xFFFFF)) {
                           deltaY = (dwDstHeight << 20) + 0x100000;
                           deltaY /= dwSrcHeight;
                       }
                   }

nxtStretchedRect:  if (isClipped) {

                       skipV = 0;

                       wDestXY.xy16.x = (short)pClipRects->left;
                       wDestXY.xy16.y = (short)pClipRects->top;
                       wXYext.wh16.w = (unsigned short)(pClipRects->right - pClipRects->left);
                       wXYext.wh16.h = (unsigned short)(pClipRects->bottom - pClipRects->top);
                       pClipRects++;

                       /* calculate starting source X position */
                       dwSrcXPos = (long)(wDestXY.xy16.x - wOrigDestXY.xy16.x) << 20;

                       if (deltaX >= 0x100000)
                           dwSrcXPos /= (deltaX >> 16); /* result is 16:16 */
                       else {
                           dwSrcXPos /= deltaX; /* result is 16:00 */
                           dwSrcXPos <<= 16;
                       }
                                                           /* truncate fraction */
                       wSrcXY.xy16.x = wOrigSrcXY.xy16.x + (short)(dwSrcXPos >> 16);

                       /* calculate starting source Y position */
                       dwSrcYPos = (long)(wDestXY.xy16.y - wOrigDestXY.xy16.y) << 20;

                       if (deltaY >= 0x100000)
                           dwSrcYPos /= (deltaY >> 16); /* result is 16:16 */
                       else {
                           dwSrcYPos /= deltaY; /* result is 16:00 */
                           dwSrcYPos <<= 16;
                       }
                                                           /* truncate fraction */
                       wSrcXY.xy16.y = wOrigSrcXY.xy16.y + (short)(dwSrcYPos >> 16);

//                       pSrcInitBits = (unsigned char *)src->fpVidMem;
                       pSrcInitBits = (unsigned char *)(dwSrcOffset + pDriverData->BaseAddress);

                       /* calculate source X extent */
                       dwSrcWidth = (unsigned long)wXYext.wh16.w << 20;

                       if (deltaX >= 0x100000)
                           dwSrcWidth /= (deltaX >> 16); /* result is 16:16 */
                       else {
                           dwSrcWidth /= deltaX; /* result is 16:00 */
                           dwSrcWidth <<= 16;
                       }

                       /* calculate source Y extent */
                       dwSrcHeight = (unsigned long)wXYext.wh16.h << 20;

                       if (deltaY >= 0x100000)
                           dwSrcHeight /= (deltaY >> 16); /* result is 16:16 */
                       else {
                           dwSrcHeight /= deltaY; /* result is 16:00 */
                           dwSrcHeight <<= 16;
                       }

                       wSrcExt.wh16.w = (unsigned short)(dwSrcXPos + dwSrcWidth) >> 16;
                       wSrcExt.wh16.h = (unsigned short)(dwSrcYPos + dwSrcHeight) >> 16;
                   } else {
                       wSrcExt.wh16.w = (unsigned short)dwSrcWidth;
                       wSrcExt.wh16.h = (unsigned short)dwSrcHeight;
                   }

                   n = (short)wSrcExt.wh16.h;

                   if (wSrcXY.xy16.y + n > src->wHeight)
                       n = src->wHeight - wSrcXY.xy16.y;

                   nxtSrcScan = srcScanLength;

                   if (doMirrorUpDown) {
                       wSrcXY.xy16.y += (n - 1);
                       nxtSrcScan = -nxtSrcScan;
                   }

                   if ((dwSrcCaps & DDSCAPS_VIDEOMEMORY) &&
                       ((dwSrcCaps & DDSCAPS_TEXTURE) == 0) &&
                       ((src->fpVidMem >= pDriverData->BaseAddress) || isOverlappingVmem)) {
                       srcInVideoMemory = 1;
                   } else {
                       pSaveSrcBits = (unsigned char *)(pSrcInitBits +
                                      (wSrcXY.xy16.y * srcScanLength));
                       pSaveSrcBits += (wSrcXY.xy16.x << 2);
                       pSrcCurScan = pSaveSrcBits;
                   }

                   if (srcInVideoMemory) {
                       pDmaBufferNotifier = (NvNotification *)pDriverData->NvDmaBufferNotifierFlat;
                       pDmaBufferNotifier++;
                       pScanlineBuffer = (unsigned char *)pDriverData->NvScanlineBufferFlat;

                       if (isClipped)
                           wSrcExt.wh16.w = (unsigned short)(dwSrcXPos + dwSrcWidth) >> 16;
                       else
                           wSrcExt.wh16.w = (unsigned short)dwSrcWidth;

                       wSrcExt.wh16.h = m;

                       srcStrtX = wSrcXY.xy16.x;

                       while (freeCount < 2)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
                       freeCount -= 2;

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) | 0x40000;
                       dmaPusherPutAddress[1] = NV_DD_VIDEO_MEMORY_TO_SYSTEM_MEMORY_FORMAT;

                       dmaPusherPutAddress += 2;

                       // wait for any pending notification operation to finish
                       while ((volatile)pDmaBufferNotifier->status == NV_IN_PROGRESS);

                       pDmaBufferNotifier->status = NV_IN_PROGRESS;

                       while (freeCount < 9)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 9, dmaPusherPutAddress);
                       freeCount -= 9;

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                           MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000;

                       dmaPusherPutAddress[1] = dwSrcOffset +
                           (dwSrcPitch * (unsigned long)wSrcXY.xy16.y) +
                           ((unsigned long)wSrcXY.xy16.x << 2);

                       dmaPusherPutAddress[2] = NV_DD_NOTIFIER_BLOCK_SIZE + (srcStrtX << 2);

                       dmaPusherPutAddress[3] = dwSrcPitch;

                       dmaPusherPutAddress[4] = dwSrcPitch;

                       dmaPusherPutAddress[5] = (unsigned long)(wSrcExt.wh16.w << 2);

                       dmaPusherPutAddress[6] = m;

                       dmaPusherPutAddress[7] = (1 << 8) | 1;

                       dmaPusherPutAddress[8] = 0;

                       dmaPusherPutAddress += 9;

                       /* Force write combine buffer to flush */
                       pDriverData->NvDmaPusherBufferEnd[0] = 0;
                       /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                       _outp (0x3d0,0);

                       pDriverData->dwDmaPusherFreeCount = freeCount;

                       npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                       // wait for Dma operation to finish
                       while ((volatile)pDmaBufferNotifier->status == NV_IN_PROGRESS);

                       if (doMirrorUpDown)
                           wSrcXY.xy16.y -= (m + skipV);
                       else
                           wSrcXY.xy16.y += (m + skipV);
                   }

                   /* Convert to 12.4 format */
                   wDstPoint.xy16.x = (wDestXY.xy16.x << 4);
                   wDstPoint.xy16.y = (wDestXY.xy16.y << 4);

                   /* convert to 16.16 */
                   lastDstY = (long)(wDestXY.xy16.y + wXYext.wh16.h) << 16;

                   /* convert to 16.16 */
                   curDstY = ((long)wDestXY.xy16.y << 16);

                   while (freeCount < 7)
                       NvGetDmaBufferFreeCount(npDev, freeCount, 7, dmaPusherPutAddress);
                   freeCount -= 7;

                   dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                       STRETCHED_IMAGE_SIZE_IN_OFFSET | 0x180000;
                   dmaPusherPutAddress[1] = wSrcExt.wh;
                   dmaPusherPutAddress[2] = deltaX;
                   dmaPusherPutAddress[3] = deltaY;
                   dmaPusherPutAddress[4] = wDestXY.xy;
                   dmaPusherPutAddress[5] = wXYext.wh;
                   dmaPusherPutAddress[6] = wDstPoint.xy;

                   dmaPusherPutAddress += 7;

                   while ((n > 0) && (curDstY < lastDstY)) {
                       FAST unsigned long *pSrcBits;
                       FAST unsigned long tmpPxls0, tmpPxls1, tmpPxls2;

                       if (srcInVideoMemory) {
                           if (bufState == 0)
                               pSrcBits = (unsigned long *)(pScanlineBuffer +
                                   (srcStrtX << 2));
                           else
                               pSrcBits = (unsigned long *)(pScanlineBuffer +
                                   (NV_DD_COMMON_DMA_BUFFER_SIZE >> 1) +
                                   (srcStrtX << 2));

                           pSrcCurScan = (unsigned char *)pSrcBits;

                           if (m > 0) {
                               pDmaBufferNotifier->status = NV_IN_PROGRESS;

                               while (freeCount < 9)
                                   NvGetDmaBufferFreeCount(npDev, freeCount, 9, dmaPusherPutAddress);
                               freeCount -= 9;

                               dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                                   MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000;

                               dmaPusherPutAddress[1] = dwSrcOffset +
                                   (dwSrcPitch * (unsigned long)wSrcXY.xy16.y) +
                                   ((unsigned long)wSrcXY.xy16.x << 2);

                               if (bufState == 0)
                                   dmaPusherPutAddress[2] =
                                       NV_DD_NOTIFIER_BLOCK_SIZE +
                                       (NV_DD_COMMON_DMA_BUFFER_SIZE >> 1) +
                                       (srcStrtX << 2);
                               else
                                   dmaPusherPutAddress[2] =
                                       NV_DD_NOTIFIER_BLOCK_SIZE +
                                       (srcStrtX << 2);

                               dmaPusherPutAddress[3] = dwSrcPitch;

                               dmaPusherPutAddress[4] = dwSrcPitch;

                               dmaPusherPutAddress[5] = (unsigned long)(wSrcExt.wh16.w << 2);

                               dmaPusherPutAddress[6] = m;

                               dmaPusherPutAddress[7] = (1 << 8) | 1;

                               dmaPusherPutAddress[8] = 0;

                               dmaPusherPutAddress += 9;

                               /* Force write combine buffer to flush */
                               pDriverData->NvDmaPusherBufferEnd[0] = 0;
                               /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                               _outp (0x3d0,0);

                               pDriverData->dwDmaPusherFreeCount = freeCount;

                               npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                               bufState ^= 1;

                               if (doMirrorUpDown)
                                   wSrcXY.xy16.y -= (m + skipV);
                               else
                                   wSrcXY.xy16.y += (m + skipV);

                               while (freeCount < 7)
                                   NvGetDmaBufferFreeCount(npDev, freeCount, 7, dmaPusherPutAddress);
                               freeCount -= 7;

                               dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                                   STRETCHED_IMAGE_SIZE_IN_OFFSET | 0x180000;

                               dmaPusherPutAddress[1] = wSrcExt.wh;

                               dmaPusherPutAddress[2] = deltaX;

                               dmaPusherPutAddress[3] = deltaY;

                               dmaPusherPutAddress[4] = wDestXY.xy;

                               dmaPusherPutAddress[5] = wXYext.wh;

                               dmaPusherPutAddress[6] = wDstPoint.xy;

                               dmaPusherPutAddress += 7;

                               /* Force write combine buffer to flush */
                               pDriverData->NvDmaPusherBufferEnd[0] = 0;
                               /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                               _outp (0x3d0,0);

                               pDriverData->dwDmaPusherFreeCount = freeCount;

                               npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;
                           }
                       } else { // source in system memory
                           pSrcBits = (unsigned long *)pSrcCurScan;
                           pSrcCurScan += nxtSrcScan;
                           n--;
                       }

doNxtBltSrcScan:       if (isClipped) {
                           pxlCount = (short)(dwSrcXPos + dwSrcWidth) >> 16; /* Include fractional starting position */

                           pxlCount -= (short)(dwSrcXPos >> 16);
                       } else {
                           pxlCount = (short)dwSrcWidth;
                       }

                       if (pxlCount < 1792) {

                           // Get enough room for this scanline
                           while (freeCount < (1 + pxlCount))
                               NvGetDmaBufferFreeCount(npDev, freeCount, (1 + pxlCount), dmaPusherPutAddress);
                           freeCount -= (1 + pxlCount);

                           dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                               STRETCHED_IMAGE_COLOR_OFFSET | (pxlCount << 18);

                           dmaPusherPutAddress += 1;

                           while (pxlCount >= 16) {

                               pxlCount -= 16;

                               tmpPxls0 = pSrcBits[0];
                               tmpPxls1 = pSrcBits[1];
                               dmaPusherPutAddress[0] = tmpPxls0;
                               tmpPxls2 = pSrcBits[2];
                               dmaPusherPutAddress[1] = tmpPxls1;
                               tmpPxls0 = pSrcBits[3];
                               tmpPxls1 = pSrcBits[4];
                               dmaPusherPutAddress[2] = tmpPxls2;
                               dmaPusherPutAddress[3] = tmpPxls0;
                               tmpPxls2 = pSrcBits[5];
                               tmpPxls0 = pSrcBits[6];
                               dmaPusherPutAddress[4] = tmpPxls1;
                               dmaPusherPutAddress[5] = tmpPxls2;
                               tmpPxls1 = pSrcBits[7];
                               tmpPxls2 = pSrcBits[8];
                               dmaPusherPutAddress[6] = tmpPxls0;
                               dmaPusherPutAddress[7] = tmpPxls1;
                               tmpPxls0 = pSrcBits[9];
                               tmpPxls1 = pSrcBits[10];
                               dmaPusherPutAddress[8] = tmpPxls2;
                               dmaPusherPutAddress[9] = tmpPxls0;
                               tmpPxls2 = pSrcBits[11];
                               tmpPxls0 = pSrcBits[12];
                               dmaPusherPutAddress[10] = tmpPxls1;
                               dmaPusherPutAddress[11] = tmpPxls2;
                               tmpPxls1 = pSrcBits[13];
                               tmpPxls2 = pSrcBits[14];
                               dmaPusherPutAddress[12] = tmpPxls0;
                               dmaPusherPutAddress[13] = tmpPxls1;
                               tmpPxls0 = pSrcBits[15];
                               dmaPusherPutAddress[14] = tmpPxls2;
                               pSrcBits += 16;
                               dmaPusherPutAddress[15] = tmpPxls0;

                               dmaPusherPutAddress += 16;
                           }

                           while (pxlCount >= 8) {

                               pxlCount -= 8;

                               tmpPxls0 = pSrcBits[0];
                               tmpPxls1 = pSrcBits[1];
                               dmaPusherPutAddress[0] = tmpPxls0;
                               tmpPxls2 = pSrcBits[2];
                               dmaPusherPutAddress[1] = tmpPxls1;
                               tmpPxls0 = pSrcBits[3];
                               tmpPxls1 = pSrcBits[4];
                               dmaPusherPutAddress[2] = tmpPxls2;
                               dmaPusherPutAddress[3] = tmpPxls0;
                               tmpPxls2 = pSrcBits[5];
                               tmpPxls0 = pSrcBits[6];
                               dmaPusherPutAddress[4] = tmpPxls1;
                               dmaPusherPutAddress[5] = tmpPxls2;
                               tmpPxls1 = pSrcBits[7];
                               pSrcBits += 8;
                               dmaPusherPutAddress[6] = tmpPxls0;
                               dmaPusherPutAddress[7] = tmpPxls1;

                               dmaPusherPutAddress += 8;
                           }

                           while (--pxlCount >= 0) {
                               tmpPxls0 = pSrcBits[0];
                               pSrcBits += 1;
                               dmaPusherPutAddress[0] = tmpPxls0;

                               dmaPusherPutAddress += 1;
                           }

                       } else { /* more than 1792 pixels per scanline */
                           while (pxlCount >= 16) {

                               pxlCount -= 16;

                               while (freeCount < (1 + 16))
                                   NvGetDmaBufferFreeCount(npDev, freeCount, (1 + 16), dmaPusherPutAddress);
                               freeCount -= (1 + 16);

                               dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                                   STRETCHED_IMAGE_COLOR_OFFSET | (16 << 18);

                               dmaPusherPutAddress += 1;

                               tmpPxls0 = pSrcBits[0];
                               tmpPxls1 = pSrcBits[1];
                               dmaPusherPutAddress[0] = tmpPxls0;
                               tmpPxls2 = pSrcBits[2];
                               dmaPusherPutAddress[1] = tmpPxls1;
                               tmpPxls0 = pSrcBits[3];
                               tmpPxls1 = pSrcBits[4];
                               dmaPusherPutAddress[2] = tmpPxls2;
                               dmaPusherPutAddress[3] = tmpPxls0;
                               tmpPxls2 = pSrcBits[5];
                               tmpPxls0 = pSrcBits[6];
                               dmaPusherPutAddress[4] = tmpPxls1;
                               dmaPusherPutAddress[5] = tmpPxls2;
                               tmpPxls1 = pSrcBits[7];
                               tmpPxls2 = pSrcBits[8];
                               dmaPusherPutAddress[6] = tmpPxls0;
                               dmaPusherPutAddress[7] = tmpPxls1;
                               tmpPxls0 = pSrcBits[9];
                               tmpPxls1 = pSrcBits[10];
                               dmaPusherPutAddress[8] = tmpPxls2;
                               dmaPusherPutAddress[9] = tmpPxls0;
                               tmpPxls2 = pSrcBits[11];
                               tmpPxls0 = pSrcBits[12];
                               dmaPusherPutAddress[10] = tmpPxls1;
                               dmaPusherPutAddress[11] = tmpPxls2;
                               tmpPxls1 = pSrcBits[13];
                               tmpPxls2 = pSrcBits[14];
                               dmaPusherPutAddress[12] = tmpPxls0;
                               dmaPusherPutAddress[13] = tmpPxls1;
                               tmpPxls0 = pSrcBits[15];
                               dmaPusherPutAddress[14] = tmpPxls2;
                               pSrcBits += 16;
                               dmaPusherPutAddress[15] = tmpPxls0;

                               dmaPusherPutAddress += 16;
                           }

                           while (pxlCount >= 8) {

                               pxlCount -= 8;

                               while (freeCount < (1 + 8))
                                   NvGetDmaBufferFreeCount(npDev, freeCount, (1 + 8), dmaPusherPutAddress);
                               freeCount -= (1 + 8);

                               dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                                   STRETCHED_IMAGE_COLOR_OFFSET | (8 << 18);

                               dmaPusherPutAddress += 1;

                               tmpPxls0 = pSrcBits[0];
                               tmpPxls1 = pSrcBits[1];
                               dmaPusherPutAddress[0] = tmpPxls0;
                               tmpPxls2 = pSrcBits[2];
                               dmaPusherPutAddress[1] = tmpPxls1;
                               tmpPxls0 = pSrcBits[3];
                               tmpPxls1 = pSrcBits[4];
                               dmaPusherPutAddress[2] = tmpPxls2;
                               dmaPusherPutAddress[3] = tmpPxls0;
                               tmpPxls2 = pSrcBits[5];
                               tmpPxls0 = pSrcBits[6];
                               dmaPusherPutAddress[4] = tmpPxls1;
                               dmaPusherPutAddress[5] = tmpPxls2;
                               tmpPxls1 = pSrcBits[7];
                               pSrcBits += 8;
                               dmaPusherPutAddress[6] = tmpPxls0;
                               dmaPusherPutAddress[7] = tmpPxls1;

                               dmaPusherPutAddress += 8;
                           }

                           if (pxlCount > 0) {
                               while (freeCount < (1 + pxlCount))
                                   NvGetDmaBufferFreeCount(npDev, freeCount, (1 + pxlCount), dmaPusherPutAddress);
                               freeCount -= (1 + pxlCount);

                               dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                                   STRETCHED_IMAGE_COLOR_OFFSET | (pxlCount << 18);

                               dmaPusherPutAddress++;
                           }

                           while (--pxlCount >= 0) {
                               tmpPxls0 = pSrcBits[0];
                               pSrcBits += 1;
                               dmaPusherPutAddress[0] = tmpPxls0;

                               dmaPusherPutAddress++;
                           }
                       }

                       /* Force write combine buffer to flush */
                       pDriverData->NvDmaPusherBufferEnd[0] = 0;
                       /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                       _outp (0x3d0,0);

                       pDriverData->dwDmaPusherFreeCount = freeCount;

                       npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                       if (srcInVideoMemory) {
                           if (--m > 0) {
                               pSrcCurScan += dwSrcPitch;

                               pSrcBits = (unsigned long *)pSrcCurScan;

                               goto doNxtBltSrcScan;
                           } else {
                               if (dwSrcPitch <= 1600) {
                                   m = 8;
                                   curDstY += (deltaY >> 1);
                               } else if (dwSrcPitch <= 3200) {
                                   m = 4;
                                   curDstY += (deltaY >> 2);
                               } else {
                                   m = 2;
                                   curDstY += (deltaY >> 3);
                               }
                                                   /* convert 16.16 to 12.4 */
                               wDstPoint.xy16.y = (short)(curDstY >> 12);

                               // wait for DMA operation to finish
                               while ((volatile)pDmaBufferNotifier->status == NV_IN_PROGRESS);
                           }
                       }
                   }

                   if (isClipped) {
                       if (--nRects > 0)
                           goto nxtStretchedRect;
                   }

                   if (srcInVideoMemory) {
                       while (freeCount < 2)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
                       freeCount -= 2;

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) | 0x40000;
                       dmaPusherPutAddress[1] = NV_DD_IMAGE_FROM_CPU;

                       dmaPusherPutAddress += 2;
                   }

                   /* restore default object */
                   while (freeCount < 2)
                       NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
                   freeCount -= 2;

                   dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000;
                   dmaPusherPutAddress[1] = NV_DD_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY;

                   dmaPusherPutAddress += 2;

                   if (isAlphaBlt) {
                       /* Restore default destination color format */
                       while (freeCount < 2)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
                       freeCount -= 2;

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                           SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x40000;

                       dmaPusherPutAddress[1] =
                           NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8;

                       dmaPusherPutAddress += 2;
                   }

               } else { // OK to use SCALED IMAGE
                   NvNotification *pDmaDmaFromMemNotifier;
                   unsigned char *pScanlineBuffer;
                   unsigned char *npPixelBuf;
                   long srcScanLength;
                   long nxtSrcScan;
                   unsigned long n;
                   unsigned char *pSrcInitBits;
                   unsigned char *pSaveSrcInitBits;
                   unsigned long *pSaveSrcBits;
                   unsigned long *pSrcCurScan;
                   long srcDeltaX;
                   long srcDeltaY;
                   long skipDeltaY = 0;
                   unsigned long dstDeltaScans;
                   unsigned long dstDeltaX;
                   long dstDeltaY;
                   long srcInitFract;
                   long srcStartFract;
                   long srcStartY;
                   long srcCurFract;
                   long srcCurY;
                   long srcDeltaYPerBand;
                   long srcDeltaScans;
                   long srcCurDeltaScans;
                   long xStretch;
                   long yStretch;
                   long srcBufferPitch;
                   long skipSrcBytes = 0;
                   long dstStartY;
                   long dstCurY;
                   long curV;
                   long skipV = 0;
                   long m;
                   NVCOORD wSrcPoint;
                   NVCOORD wSrcExt;
                   NVCOORD wDstPoint;
                   NVCOORD wDstExt;
                   BYTE srcInVideoMemory = 0;
                   BYTE srcTooWide = 0;
                   short curBuffer;
                   DWORD nRects = 0;
                   LPRECT pClipRects;
                   NVCOORD wOrigDestXY;
                   NVCOORD wOrigSrcXY;
                   long origSrcDeltaX;
                   long origSrcDeltaY;
                   long srcClippedInitFract;
//// These are for working around NV4 scaled image bug
                   DWORD scaledImageObjectID = NV_DD_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY;
                   DWORD curClipPoint;
                   DWORD curClipExtent;
                   DWORD curDUDX;
                   DWORD curDVDY;
//// End of NV4 workaround variables

//                   pSrcInitBits = (unsigned char *)src->fpVidMem;
                   pSrcInitBits = (unsigned char *)(dwSrcOffset + pDriverData->BaseAddress);

                   if (isVideo < 2)
//                       srcScanLength = src->lPitch;
                       srcScanLength = dwSrcPitch;
                   else
//                       srcScanLength = src->lPitch >> 1;
                       srcScanLength = dwSrcPitch >> 1;

                   if (isAlphaBlt) {

                       while (freeCount < 12)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 12, dmaPusherPutAddress);
                       freeCount -= 12;

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                           SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x40000;
                       dmaPusherPutAddress[1] = NV042_SET_COLOR_FORMAT_LE_A8R8G8B8;

                       dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                           SURFACES_2D_DEST_OFFSET | 0x40000;
                       dmaPusherPutAddress[3] = dwDstOffset;
                       dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                           SURFACES_2D_PITCH_OFFSET | 0x40000;
                       dmaPusherPutAddress[5] = (dwDstPitch << 16) | dwDstPitch;

                       dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                       dmaPusherPutAddress[7] = NV_DD_CONTEXT_BETA4;
#ifdef  DX7
                       dwMultipliers = pbd->ddrgbaScaleFactors.alpha << 24;
                       dwMultipliers |= pbd->ddrgbaScaleFactors.red << 16;
                       dwMultipliers |= pbd->ddrgbaScaleFactors.green << 8;
                       dwMultipliers |= pbd->ddrgbaScaleFactors.blue;
#endif  /* DX7 */
                       dmaPusherPutAddress[8] = dDrawSubchannelOffset(NV_DD_SPARE) +
                           BETA4_SET_BETA_FACTOR_OFFSET | 0x40000;
                       dmaPusherPutAddress[9] = dwMultipliers;
#ifdef  DX7
                       dmaPusherPutAddress[10] = dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000;

                       if (dwAFlags & DDABLT_NOBLEND)
                           scaledImageObjectID =
                               NV_DD_SRCCOPY_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY;
                       else
                           scaledImageObjectID =
                               NV_DD_ABLEND_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY;

                       dmaPusherPutAddress[11] = scaledImageObjectID;

                       dmaPusherPutAddress += 12;
#else   /* DX7 */
                       dmaPusherPutAddress += 10;
#endif  /* DX7 */
                   } else { // regular blit

                       while (freeCount < 6)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 6, dmaPusherPutAddress);
                       freeCount -= 6;

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
                           SET_ROP_OFFSET | 0x40000;
                       dmaPusherPutAddress[1] = dwRop;

                       dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                           SURFACES_2D_DEST_OFFSET | 0x40000;
                       dmaPusherPutAddress[3] = dwDstOffset;
                       dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                           SURFACES_2D_PITCH_OFFSET | 0x40000;
                       dmaPusherPutAddress[5] = (dwDstPitch << 16) | dwDstPitch;

                       dmaPusherPutAddress += 6;
                   }

                   pDriverData->dwDmaPusherFreeCount = freeCount;

                   /* Just in case we return unexpectedly */
                   pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

                   if (isClipped) {

                       nRects = pbd->dwRectCnt;
                       pClipRects = pbd->prDestRects;

                       wOrigDestXY.xy16.x = (short)pbd->rOrigDest.left;
                       wOrigDestXY.xy16.y = (short)pbd->rOrigDest.top;
                       wOrigSrcXY.xy16.x  = (short)pbd->rOrigSrc.left;
                       wOrigSrcXY.xy16.y  = (short)pbd->rOrigSrc.top;

                       dwDstWidth = pbd->rOrigDest.right - pbd->rOrigDest.left;
                       dwDstHeight = pbd->rOrigDest.bottom - pbd->rOrigDest.top;
                       dwSrcWidth = pbd->rOrigSrc.right - pbd->rOrigSrc.left;
                       dwSrcHeight = pbd->rOrigSrc.bottom - pbd->rOrigSrc.top;

                       /* check for divide by 0 */
                       if ((dwDstWidth < 1) || (dwDstHeight < 1)) {
                           pbd->ddRVal = DDERR_INVALIDRECT;
                           return DDHAL_DRIVER_HANDLED;
                       }

                       /* Check if within NV hardware supported range */
                       if ((dwDstWidth > 2047) || (dwDstHeight > 2047)) {
                           return DDHAL_DRIVER_NOTHANDLED;
                       }

                       origSrcDeltaX = dwSrcWidth << 20;
                       origSrcDeltaX /= dwDstWidth;

                       origSrcDeltaY = dwSrcHeight << 20;
                       origSrcDeltaY /= dwDstHeight;

                       /* Algorithm can't handle a scale factor that is too large */
                       if (origSrcDeltaY > 0x40000000) {
                           pbd->ddRVal = DDERR_INVALIDRECT;
                           return DDHAL_DRIVER_HANDLED;
                       }

                   } else { // unclipped

                       /* check for divide by 0 */
                       if ((dwDstWidth < 1) || (dwDstHeight < 1)) {
                           pbd->ddRVal = DDERR_INVALIDRECT;
                           return DDHAL_DRIVER_HANDLED;
                       }

                       /* Check if within NV hardware supported range */
                       if ((dwDstWidth > 2047) || (dwDstHeight > 2047)) {
                           return DDHAL_DRIVER_NOTHANDLED;
                       }

                       origSrcDeltaX = dwSrcWidth << 20;
                       origSrcDeltaX /= dwDstWidth;

                       /*
                        * This fudge factor prevents us from running out of source pixels
                        * when the source starting position is fractional resulting in
                        * a true final width of dwSrcWidth - fraction. Unfortunately
                        * this fudge factor also causes problems when it is important
                        * to end on exactly the right source pixel.  The uglier of the 2 cases
                        * is to run out of source pixels so I opted to leave the fudge
                        * factor in. It works by enlarging the destination by a factor
                        * equivalent to 1 source pixel resulting in slightly enlarging
                        * the stretch factor on each source pixel.
                        */

                       if (origSrcDeltaX < 0x100000) {
                           xStretch = 0x40000000 / (origSrcDeltaX >> 10);
                           xStretch >>= 20;
                           origSrcDeltaX = dwSrcWidth << 20;
                           origSrcDeltaX /= (dwDstWidth + xStretch);
                       }

                       origSrcDeltaY = dwSrcHeight << 20;
                       origSrcDeltaY /= dwDstHeight;

                       /* Algorithm can't handle a scale factor that is too large */
                       if (origSrcDeltaY > 0x40000000) {
                           pbd->ddRVal = DDERR_INVALIDRECT;
                           return DDHAL_DRIVER_HANDLED;
                       }

                   }

nxtScaledRect:     srcDeltaX = origSrcDeltaX;
                   srcDeltaY = origSrcDeltaY;

                   if (isClipped) {
                       unsigned long dwSrcXPos;
                       unsigned long dwSrcYPos;

                       skipDeltaY = 0;
                       skipSrcBytes = 0;
                       skipV = 0;
                       srcTooWide = 0;

                       wDestXY.xy16.x = (short)pClipRects->left;
                       wDestXY.xy16.y = (short)pClipRects->top;
                       wXYext.wh16.w = (unsigned short)(pClipRects->right - pClipRects->left);
                       wXYext.wh16.h = (unsigned short)(pClipRects->bottom - pClipRects->top);
                       pClipRects++;

                       dwDstWidth = (unsigned long)wXYext.wh16.w;
                       dwDstHeight = (unsigned long)wXYext.wh16.h;

                       /* calculate starting source X position */
                       dwSrcXPos = (long)(wDestXY.xy16.x - wOrigDestXY.xy16.x);

                       dwSrcXPos *= origSrcDeltaX; /* result is 12:20 */

                                                           /* truncate fraction */
                       wSrcXY.xy16.x = wOrigSrcXY.xy16.x + (short)(dwSrcXPos >> 20);

                       wSrcPoint.xy16.x = (short)((dwSrcXPos & 0xFFFFF) >> 16);

                       /* calculate starting source Y position */
                       dwSrcYPos = (long)(wDestXY.xy16.y - wOrigDestXY.xy16.y);

                       dwSrcYPos *= origSrcDeltaY; /* result is 12.20 */

                                                           /* truncate fraction */
                       wSrcXY.xy16.y = wOrigSrcXY.xy16.y + (short)(dwSrcYPos >> 20);

                       srcClippedInitFract = dwSrcYPos & 0xFFFFF;

                       /* calculate source X extent */
                       dwSrcWidth = (unsigned long)wXYext.wh16.w;

                       dwSrcWidth *= origSrcDeltaX; /* result is 12.20 */

                       dwSrcWidth += (dwSrcXPos & 0xFFFFF); /* include starting fraction of source */

                       dwSrcWidth >>= 20; /* we lose precision here, may need changed later */

                       if (wSrcXY.xy16.x + dwSrcWidth > src->wWidth)
                           dwSrcWidth = src->wWidth - wSrcXY.xy16.x;

                       /* calculate source Y extent */
                       dwSrcHeight = (unsigned long)wXYext.wh16.h;

                       dwSrcHeight *= origSrcDeltaY; /* result is 12.20 */

                       dwSrcHeight += (dwSrcYPos & 0xFFFFF); /* include starting fraction of source */

                       dwSrcHeight >>= 20; /* we lose precision here, may need changed later */


                   }

                   if (isVideo < 2)
                       srcBufferPitch = dwSrcWidth << 2;
                   else
                       srcBufferPitch = dwSrcWidth << 1;

                   srcDeltaScans = (NV_DD_COMMON_DMA_BUFFER_SIZE >> 1) -   /* allow for 2 extra src scanlines */
                            NV_DD_NOTIFIER_BLOCK_SIZE - (srcBufferPitch << 1); /* buffer contains several separate notifiers */

                   srcDeltaScans /= srcBufferPitch;

                   /* limiting source scans per DMA increases parallelism */
                   if (srcDeltaScans > 32)
                       srcDeltaScans = 32;
                   else if (srcDeltaScans > 16)
                       srcDeltaScans = 16;
                   else if (srcDeltaScans > 8)
                       srcDeltaScans = 8;
                   else if (srcDeltaScans > 4)
                       srcDeltaScans = 4;
                   else
                       srcDeltaScans = 2;


                   /* If shrinking in vertical direction then adjust to skip src scanlines */
                   if (srcDeltaY >= (srcDeltaScans << 20)) { /* limit Y delta range to acceptable range */
                       skipDeltaY = srcDeltaY;
                       skipSrcBytes = srcScanLength;
                       skipV = 1;
                       while (srcDeltaY >= (srcDeltaScans << 20)) {
                           srcDeltaY >>= 1;
                           skipSrcBytes <<= 1;
                           skipV <<= 1;
                           skipDeltaY <<= 1;
                       }
                       skipSrcBytes -= srcScanLength;
                       skipV -= 1;
                       skipDeltaY -= srcDeltaY;
                   }

                   /* Algorithm can't handle scale factor that is too small */
                   if ((srcDeltaY & 0xFFFFFC00) == 0) {
                       pbd->ddRVal = DDERR_INVALIDRECT;
                       return DDHAL_DRIVER_HANDLED;
                   }

                   yStretch = 0x40000000 / ((srcDeltaY + 0x00000200) >> 10);

                   dstDeltaY = srcDeltaScans * yStretch;  // how many dst scanlines will srcDeltaScans scanlines generate

                   dstDeltaScans = dstDeltaY >> 20;

                   if (dstDeltaScans == 0) { /* if shrinking too much then can't handle */
                       return DDHAL_DRIVER_NOTHANDLED;
                   }

                   if (wSrcXY.xy16.y + dwSrcHeight > src->wHeight)
                       dwSrcHeight = src->wHeight - wSrcXY.xy16.y;

                   if (isVideo < 2)
                       nxtSrcScan = (srcScanLength >> 2);
                   else
                       nxtSrcScan = (srcScanLength >> 1);

                   srcDeltaYPerBand = dstDeltaScans * (srcDeltaY + skipDeltaY);

                   if (doMirrorUpDown) {
                       wSrcXY.xy16.y += (short)(dwSrcHeight - 1);
                       srcDeltaY = -srcDeltaY;
                       srcDeltaYPerBand = -srcDeltaYPerBand;
                       skipDeltaY = -skipDeltaY;
                       nxtSrcScan = -nxtSrcScan;
                       skipSrcBytes = -skipSrcBytes;
                   }

                   pDmaDmaFromMemNotifier = (NvNotification *)pDriverData->NvDmaDmaFromMemNotifierFlat;
                   pScanlineBuffer = (unsigned char *)pDriverData->NvScanlineBufferFlat;

                   if (srcDeltaY > 0)
                       srcCurY = 0;
                   else
                       srcCurY = ((long)dwSrcHeight << 20);

                   /* Calculate initial source fractional X */
                   if ((srcDeltaX > 0x40000000) || ((srcDeltaX & 0xFFFFFC00) == 0)) {
                       pbd->ddRVal = DDERR_INVALIDRECT;
                       return DDHAL_DRIVER_HANDLED;
                   }

                   if (!(isClipped)) {
                       wSrcPoint.xy = 0;

                       /* Do this math in 16.16 precision to avoid 12. overflow */
                       dstDeltaX = ((long)wSrcXY.xy16.x << 16) / (srcDeltaX >> 4);

                       /* Do this math in 16.16 precision to avoid 12. overflow */
                       srcInitFract = dstDeltaX * (srcDeltaX >> 4);

                       /* Do this math in 16.16 precision to avoid 12. overflow */
                       while (srcInitFract >> 16 < wSrcXY.xy16.x)
                           srcInitFract += (srcDeltaX >> 4);

                       /* Convert to 12.4 format */
                       wSrcPoint.xy16.x = (short)(srcInitFract & 0xFFFF) >> 12;
                   }

                       // DMAable ?
                   if ((isVideo > 3) || ((dwSrcCaps & DDSCAPS_VIDEOMEMORY) &&
                       ((dwSrcCaps & DDSCAPS_TEXTURE) == 0) &&
                       ((src->fpVidMem >= pDriverData->BaseAddress) || isOverlappingVmem))) {

                       if (isClipped) {
                           srcInitFract = srcClippedInitFract;
                       } else {
                           srcInitFract = 0;

                           if (srcDeltaY > 0) {
                               /* Calculate initial source fractional Y */
                               /* Do this math in 16.16 precision to avoid 12. overflow */
                               dstDeltaY = ((long)wSrcXY.xy16.y << 16) / (srcDeltaY  >> 4);

                               /* Do this math in 16.16 precision to avoid 12. overflow */
                               srcInitFract = dstDeltaY * (srcDeltaY >> 4);

                               /* Do this math in 16.16 precision to avoid 12. overflow */
                               while (srcInitFract >> 16 < wSrcXY.xy16.y)
                                   srcInitFract += (srcDeltaY >> 4);

                               /* Convert result back to 12.20 precision */
                               srcInitFract <<= 4;

                               srcInitFract &= 0xFFFFF;
                           }
                       }

                       srcCurY += srcInitFract;

                       srcCurFract = srcInitFract;

                       if (isVideo < 4) {
                           srcInVideoMemory = 1;

                           if (doMirrorUpDown) {
                               pSaveSrcBits = (unsigned long *)
                                  (pSrcInitBits - pDriverData->BaseAddress);
                               wSrcPoint.xy16.y += ((short)(dwSrcHeight - 1) << 4);
                           } else {
                               wSrcPoint.xy16.y += (short)(srcCurFract >> 16);

                               if (isVideo < 2)
                                   pSaveSrcBits = (unsigned long *)
                                      ((pSrcInitBits - pDriverData->BaseAddress) +
                                       (wSrcXY.xy16.y * srcScanLength));
                               else
                                   pSaveSrcBits = (unsigned long *)
                                      ((pSrcInitBits - pDriverData->BaseAddress) +
                                       (wSrcXY.xy16.y * (srcScanLength << 1)));
                           }
                       } else {

                           if (doMirrorUpDown) {
                               pSaveSrcBits = 0;
                               wSrcPoint.xy16.y += ((short)(dwSrcHeight - 1) << 4);
                           } else {
                               wSrcPoint.xy16.y += (short)(srcCurFract >> 16);

                               pSaveSrcBits = (unsigned long *)
                                   (wSrcXY.xy16.y * (srcScanLength << 1));
                           }
                       }

                       if (isVideo < 2)
                           pSaveSrcBits += wSrcXY.xy16.x;
                       else
                           pSaveSrcBits += (wSrcXY.xy16.x >> 1);

                       while (freeCount < 2)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
                       freeCount -= 2;

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000;

                       if (isAlphaBlt) {
#ifdef  DX7
                           if (dwAFlags & DDABLT_NOBLEND)
                               scaledImageObjectID =
                                   NV_DD_SRCCOPY_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY;
                           else
                               scaledImageObjectID =
                                   NV_DD_ABLEND_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY;
#endif  /* DX7 */
                       } else if (isVideo < 2)
                           scaledImageObjectID =
                               NV_DD_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY;
                       else if (isVideo == 2)
                           scaledImageObjectID =
                               NV_DD_SCALED_UYVY_IMAGE_FROM_VIDEO_MEMORY;
                       else if (isVideo == 3)
                           scaledImageObjectID =
                               NV_DD_SCALED_YUYV_IMAGE_FROM_VIDEO_MEMORY;
                       else if (isVideo == 4)
                           scaledImageObjectID =
                               NV_DD_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
                       else if (isVideo == 5)
                           scaledImageObjectID =
                               NV_DD_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
                       else if (isVideo == 6)
                           scaledImageObjectID =
                               NV_DD_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
                       else if (isVideo == 7)
                           scaledImageObjectID =
                               NV_DD_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;

                       dmaPusherPutAddress[1] = scaledImageObjectID;

                       dmaPusherPutAddress += 2;

                   } else {
                       if (isVideo < 2) {
                           pSaveSrcBits = (unsigned long *)(pSrcInitBits +
                               (wSrcXY.xy16.y * srcScanLength));
                           pSaveSrcBits += wSrcXY.xy16.x;
                       } else {
                           pSaveSrcBits = (unsigned long *)(pSrcInitBits +
                               (wSrcXY.xy16.y * (srcScanLength << 1)));
                           pSaveSrcBits += (wSrcXY.xy16.x >> 1);
                       }

                       pSrcCurScan = pSaveSrcBits;

                       while (freeCount < 2)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
                       freeCount -= 2;

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000;

                       if (isVideo == 2)
                           scaledImageObjectID = NV_DD_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
                       else if (isVideo == 3)
                           scaledImageObjectID = NV_DD_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;

                       /* NOTE: This may load the default scaledImageObjectID */
                       dmaPusherPutAddress[1] = scaledImageObjectID;

                       dmaPusherPutAddress += 2;
                   }

                   pSaveSrcInitBits = (unsigned char *)pSaveSrcBits;

                   curClipPoint = wDestXY.xy;
                   curClipExtent = wXYext.wh;
                   curDUDX = srcDeltaX;
                   if (srcDeltaY > 0)
                       curDVDY = srcDeltaY;
                   else
                       curDVDY = -srcDeltaY;

                   while (freeCount < 6)
                       NvGetDmaBufferFreeCount(npDev, freeCount, 6, dmaPusherPutAddress);
                   freeCount -= 6;

                   dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                       SCALED_IMAGE_CLIPPOINT_OFFSET | 0x80000;
                   dmaPusherPutAddress[1] = curClipPoint;
                   dmaPusherPutAddress[2] = curClipExtent;
                   dmaPusherPutAddress[3] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                       SCALED_IMAGE_DELTADUDX_OFFSET | 0x80000;
                   dmaPusherPutAddress[4] = curDUDX;
                   dmaPusherPutAddress[5] = curDVDY;

                   dmaPusherPutAddress += 6;

                   wDstExt.wh = wXYext.wh;

                   /* NV4 Scaled Image class requires source width to be even */
                   dwSrcWidth = (dwSrcWidth + 1) & ~1;

                   /* NV3 hardware can only handle a maximum source width of 1024 */
                   if (dwSrcWidth > 1024) {
                       srcTooWide = 1;
                       xStretch = 0x40000000 / (srcDeltaX >> 10);
                       dstDeltaX = (xStretch * 1024) >> 20;
                       wDstExt.wh16.w = (unsigned short)dstDeltaX;
                       srcBufferPitch = 4096;
                   }

                   // Let the world know we are doing DMA operations
//                   pDriverData->NvDmaFromMemSurfaceMem = src->fpVidMem;
                   pDriverData->NvDmaFromMemSurfaceMem = dwSrcOffset + pDriverData->BaseAddress;

oneMorePass:       n = dwDstHeight;

                   srcCurY &= 0xFFF00000;

                   if (isClipped) {
                       srcInitFract = srcClippedInitFract;
                   } else {
                       srcInitFract = 0;

                       if (srcDeltaY > 0) {
                           /* Calculate initial source fractional Y */
                           /* Do this math in 16.16 precision to avoid 12. overflow */
                           dstDeltaY = ((long)wSrcXY.xy16.y << 16) / (srcDeltaY  >> 4);

                           /* Do this math in 16.16 precision to avoid 12. overflow */
                           srcInitFract = dstDeltaY * (srcDeltaY >> 4);

                           /* Do this math in 16.16 precision to avoid 12. overflow */
                           while (srcInitFract >> 16 < wSrcXY.xy16.y)
                               srcInitFract += (srcDeltaY >> 4);

                           /* Convert result back to 12.20 precision */
                           srcInitFract <<= 4;

                           srcInitFract &= 0xFFFFF;
                       }
                   }

                   srcCurY += srcInitFract;

                   srcCurFract = srcInitFract;

                   curV = srcCurY >> 20;

                   wDstPoint.xy = wDestXY.xy;

                   dstStartY = dstCurY = wDestXY.xy16.y;

                   curBuffer = 0;

                   if ((srcInVideoMemory) || (isVideo > 3)) { // DMAable ?

                       // wait for any pending notification operation to finish
//this shouldn't be necessary  while ((volatile)pDmaDmaFromMemNotifier->status == NV_IN_PROGRESS);

                       pDmaDmaFromMemNotifier->status = NV_IN_PROGRESS;

                       while (freeCount < 11)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
                       freeCount -= 11;

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_IMAGE_OUT_POINT_OFFSET | 0x80000;
                       dmaPusherPutAddress[1] = wDstPoint.xy;
                       dmaPusherPutAddress[2] = wDstExt.wh;
                       dmaPusherPutAddress[3] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_IMAGE_IN_SIZE_OFFSET | 0xC0000;

                       if ((dwSrcWidth < 16) && (isVideo < 4)) { // workaround for NV3 Rev B hardware bug (only happens if source is in video memory)
                           dmaPusherPutAddress[4] =
                               asmMergeCoords(dwSrcPitch, dwSrcHeight);
                       } else {
                           dmaPusherPutAddress[4] =
                               asmMergeCoords(dwSrcWidth, dwSrcHeight);
                       }

                       if ((isAlphaBlt) && (doBilinearFiltering == 0))
                           dmaPusherPutAddress[5] =
                               (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_ZOH << 24) |
                               (NV077_IMAGE_IN_FORMAT_ORIGIN_CORNER << 16) |
                               dwSrcPitch;
                       else // filter
                           dmaPusherPutAddress[5] =
                               (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24) |
                               (NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16) |
                               dwSrcPitch;

                       dmaPusherPutAddress[6] = (unsigned long)pSaveSrcBits;

                       dmaPusherPutAddress[7] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_NOTIFY_OFFSET | 0x40000;
                       dmaPusherPutAddress[8] = 0;
                       dmaPusherPutAddress[9] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_IMAGE_IN_POINT_OFFSET | 0x40000;
                       dmaPusherPutAddress[10] = wSrcPoint.xy;

                       dmaPusherPutAddress += 11;

                       /* Force write combine buffer to flush */
                       pDriverData->NvDmaPusherBufferEnd[0] = 0;
                       /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                       _outp (0x3d0,0);

                       pDriverData->dwDmaPusherFreeCount = freeCount;

                       npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                       n = 0;
                   } else {
                       // wait for any pending notification operation to finish
                       while ((volatile)pDmaDmaFromMemNotifier->status == NV_IN_PROGRESS);
                   }

                   while (n >= dstDeltaScans) {
                       FAST unsigned long *pSrcBits;

                       n -= dstDeltaScans;
                       srcStartY = srcCurY;
                       srcStartFract = srcCurFract;
                       srcCurY += srcDeltaYPerBand;

                       if (doMirrorUpDown) {
                           if (((srcCurY - 0x100000) >> 20) < 0)
                               srcCurY = 0x100000;
                       } else {
                           if (((srcCurY + 0x100000) >> 20) >  ((long)dwSrcHeight - 1))
                               srcCurY = ((long)dwSrcHeight - 2) << 20;
                       }

                       srcCurFract = srcCurY & 0xFFFFF;

                       if (curBuffer == 0)
                           npPixelBuf = (unsigned char *)pScanlineBuffer;
                       else
                           npPixelBuf = (unsigned char *)(pScanlineBuffer +
                               (NV_DD_COMMON_DMA_BUFFER_SIZE >> 1));

                       /* Must recalculate on each pass since src scanlines may be used more than once */
                       pSrcBits = (unsigned long *)(pSaveSrcInitBits +
                           (curV * (nxtSrcScan << 2)));

                       pSrcCurScan = pSrcBits;

                       if (doMirrorUpDown)
                           m = (srcStartY >> 20) - ((srcCurY - 0x100000) >> 20);
                       else
                           m = ((srcCurY + 0x100000) >> 20) - (srcStartY >> 20);

                       srcCurDeltaScans = 0;

                       /* Copy and convert a block of source pixels to transfer buffer */
                       while (--m >= 0) {
                           if (pSrcBits >= (unsigned long *)pSrcInitBits) {
  //                           asmCopyScan(pSrcBits, npPixelBuf, srcBufferPitch);
                               _asm
                               {
#ifdef P6
                                   mov ecx, dword ptr srcBufferPitch
                                   mov esi, dword ptr pSrcBits
                                   shr ecx, 5
                     nxtCacheLine: mov eax, [esi]
                                   add esi, 32
                                   dec ecx
                                   jg nxtCacheLine
#endif /* P6 */
                                   mov ecx, dword ptr srcBufferPitch
                                   mov esi, dword ptr pSrcBits
                                   shr ecx, 2
                                   mov edi, dword ptr npPixelBuf
                                   test ecx, 1
                                   jz doQwords
                                   mov eax, [esi]
                                   add esi, 4
                                   mov [edi], eax
                                   add edi, 4
                         doQwords: shr ecx, 1
                                   jz copyDone
                         nxtQword: mov eax, [esi]
                                   mov edx, [esi+4]
                                   add edi, 8
                                   add esi, 8
                                   dec ecx
                                   mov [edi-8], eax
                                   mov [edi-4], edx
                         copyDone: jg nxtQword
                               }
                           }
                           npPixelBuf += srcBufferPitch;
                           pSrcCurScan += (nxtSrcScan + skipSrcBytes);
                           pSrcBits = (unsigned long *)pSrcCurScan;
                           srcCurDeltaScans++;
                           m -= skipV;
                       }

                       /* wait for Dma operation to finish */
                       while (pDmaDmaFromMemNotifier->status == NV_IN_PROGRESS);

                       pDmaDmaFromMemNotifier->status = NV_IN_PROGRESS;

                       wDstPoint.xy16.y = (short)dstCurY;
                       wDstExt.wh16.h = (unsigned short)dstDeltaScans;
                       wSrcPoint.xy16.y = (short)(srcStartFract >> 16); /* convert V to 12.4 */
                       wSrcExt.wh = srcCurDeltaScans;
                       wSrcExt.wh <<= 16;    /* shift V extent into place */
                       wSrcExt.wh |= dwSrcWidth;

//// BEGIN WORKAROUND FOR NV4 SCALED IMAGE HARDWARE BUG

                       while (freeCount < 8)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 8, dmaPusherPutAddress);
                       freeCount -= 8;

                       /* Reload object */
                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000;
                       dmaPusherPutAddress[1] = scaledImageObjectID;
                       /* Reinitialize volatile methods */
                       dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_CLIPPOINT_OFFSET | 0x80000;
                       dmaPusherPutAddress[3] = curClipPoint;
                       dmaPusherPutAddress[4] = curClipExtent;
                       dmaPusherPutAddress[5] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_DELTADUDX_OFFSET | 0x80000;
                       dmaPusherPutAddress[6] = curDUDX;
                       dmaPusherPutAddress[7] = curDVDY;

                       dmaPusherPutAddress += 8;

//// END WORKAROUND FOR NV4 SCALED IMAGE HARDWARE BUG

                       while (freeCount < 11)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
                       freeCount -= 11;

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_IMAGE_OUT_POINT_OFFSET | 0x80000;
                       dmaPusherPutAddress[1] = wDstPoint.xy;
                       dmaPusherPutAddress[2] = wDstExt.wh;
                       dmaPusherPutAddress[3] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_IMAGE_IN_SIZE_OFFSET | 0xC0000;
                       dmaPusherPutAddress[4] = wSrcExt.wh;

                       if ((isAlphaBlt) && (doBilinearFiltering == 0))
                           dmaPusherPutAddress[5] =
                               (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_ZOH << 24) |
                               (NV077_IMAGE_IN_FORMAT_ORIGIN_CORNER << 16) |
                               srcBufferPitch;
                       else // filter
                           dmaPusherPutAddress[5] =
                               (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24) |
                               (NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16) |
                               srcBufferPitch;

                       if (curBuffer == 0)
                           dmaPusherPutAddress[6] =
                               NV_DD_NOTIFIER_BLOCK_SIZE; /* There are several notifiers in the buffer */
                       else
                           dmaPusherPutAddress[6] =
                               NV_DD_NOTIFIER_BLOCK_SIZE + (NV_DD_COMMON_DMA_BUFFER_SIZE >> 1);

                       dmaPusherPutAddress[7] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_NOTIFY_OFFSET | 0x40000;
                       dmaPusherPutAddress[8] = 0;
                       dmaPusherPutAddress[9] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_IMAGE_IN_POINT_OFFSET | 0x40000;
                       dmaPusherPutAddress[10] = wSrcPoint.xy;

                       dmaPusherPutAddress += 11;

                       /* Force write combine buffer to flush */
                       pDriverData->NvDmaPusherBufferEnd[0] = 0;
                       /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                       _outp (0x3d0,0);

                       pDriverData->dwDmaPusherFreeCount = freeCount;

                       npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                       curBuffer ^= 1;

                       dstCurY += dstDeltaScans;

                       curV = srcCurY >> 20;
                   }

                   if (n > 0) {
                       FAST unsigned long *pSrcBits;

                       srcStartY = srcCurY;
                       srcStartFract = srcCurFract;
                       srcCurY += srcDeltaYPerBand;

                       if (doMirrorUpDown) {
                           if (((srcCurY - 0x100000) >> 20) < 0)
                               srcCurY = 0x100000;
                       } else {
                           if (((srcCurY + 0x100000) >> 20) > ((long)dwSrcHeight - 1))
                               srcCurY = ((long)dwSrcHeight - 2) << 20;
                       }

                       srcCurFract = srcCurY & 0xFFFFF;

                       if (curBuffer == 0)
                           npPixelBuf = (unsigned char *)pScanlineBuffer;
                       else
                           npPixelBuf = (unsigned char *)(pScanlineBuffer +
                               (NV_DD_COMMON_DMA_BUFFER_SIZE >> 1));

                       /* Must recalculate since src scanlines may be used more than once */
                       pSrcBits = (unsigned long *)(pSaveSrcInitBits +
                           (curV * (nxtSrcScan << 2)));

                       pSrcCurScan = pSrcBits;

                       if (doMirrorUpDown)
                           m = (srcStartY >> 20) - ((srcCurY - 0x100000) >> 20);
                       else
                           m = ((srcCurY + 0x100000) >> 20) - (srcStartY >> 20);

                       srcCurDeltaScans = 0;

                       /* Copy and convert a block of source pixels to transfer buffer */
                       while (--m >= 0) {
                           if (pSrcBits >= (unsigned long *)pSrcInitBits) {
  //                           asmCopyScan(pSrcBits, npPixelBuf, srcBufferPitch);
                               _asm
                               {
#ifdef P6
                                   mov ecx, dword ptr srcBufferPitch
                                   mov esi, dword ptr pSrcBits
                                   shr ecx, 5
                    nxtCacheLine2: mov eax, [esi]
                                   add esi, 32
                                   dec ecx
                                   jg nxtCacheLine2
#endif /* P6 */
                                   mov ecx, dword ptr srcBufferPitch
                                   mov esi, dword ptr pSrcBits
                                   shr ecx, 2
                                   mov edi, dword ptr npPixelBuf
                                   test ecx, 1
                                   jz doQwords2
                                   mov eax, [esi]
                                   add esi, 4
                                   mov [edi], eax
                                   add edi, 4
                        doQwords2: shr ecx, 1
                                   jz copyDone2
                        nxtQword2: mov eax, [esi]
                                   mov edx, [esi+4]
                                   add edi, 8
                                   add esi, 8
                                   dec ecx
                                   mov [edi-8], eax
                                   mov [edi-4], edx
                        copyDone2: jg nxtQword2
                               }
                           }
                           npPixelBuf += srcBufferPitch;
                           pSrcCurScan += (nxtSrcScan + skipSrcBytes);
                           pSrcBits = (unsigned long *)pSrcCurScan;
                           srcCurDeltaScans++;
                           m -= skipV;
                       }

                       /* wait for Dma operation to finish */
                       while (pDmaDmaFromMemNotifier->status == NV_IN_PROGRESS);

                       pDmaDmaFromMemNotifier->status = NV_IN_PROGRESS;

                       wDstPoint.xy16.y = (short)dstCurY;
                       wDstExt.wh16.h = (unsigned short)n;
                       wSrcPoint.xy16.y = (short)(srcStartFract >> 16); /* convert V to 12.4 */
                       wSrcExt.wh = srcCurDeltaScans;
                       wSrcExt.wh <<= 16;    /* shift V extent into place */
                       wSrcExt.wh |= dwSrcWidth;

//// BEGIN WORKAROUND FOR NV4 SCALED IMAGE HARDWARE BUG

                       while (freeCount < 8)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 8, dmaPusherPutAddress);
                       freeCount -= 8;

                       /* Reload object */
                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000;
                       dmaPusherPutAddress[1] = scaledImageObjectID;
                       /* Reinitialize volatile methods */
                       dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_CLIPPOINT_OFFSET | 0x80000;
                       dmaPusherPutAddress[3] = curClipPoint;
                       dmaPusherPutAddress[4] = curClipExtent;
                       dmaPusherPutAddress[5] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_DELTADUDX_OFFSET | 0x80000;
                       dmaPusherPutAddress[6] = curDUDX;
                       dmaPusherPutAddress[7] = curDVDY;

                       dmaPusherPutAddress += 8;

//// END WORKAROUND FOR NV4 SCALED IMAGE HARDWARE BUG

                       while (freeCount < 11)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
                       freeCount -= 11;

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_IMAGE_OUT_POINT_OFFSET | 0x80000;
                       dmaPusherPutAddress[1] = wDstPoint.xy;
                       dmaPusherPutAddress[2] = wDstExt.wh;
                       dmaPusherPutAddress[3] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_IMAGE_IN_SIZE_OFFSET | 0xC0000;
                       dmaPusherPutAddress[4] = wSrcExt.wh;

                       if ((isAlphaBlt) && (doBilinearFiltering == 0))
                           dmaPusherPutAddress[5] =
                               (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_ZOH << 24) |
                               (NV077_IMAGE_IN_FORMAT_ORIGIN_CORNER << 16) |
                               srcBufferPitch;
                       else // filter
                           dmaPusherPutAddress[5] =
                               (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24) |
                               (NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16) |
                               srcBufferPitch;

                       if (curBuffer == 0)
                           dmaPusherPutAddress[6] =
                               NV_DD_NOTIFIER_BLOCK_SIZE; /* There are several notifiers in the buffer */
                       else
                           dmaPusherPutAddress[6] =
                               NV_DD_NOTIFIER_BLOCK_SIZE + (NV_DD_COMMON_DMA_BUFFER_SIZE >> 1);

                       dmaPusherPutAddress[7] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_NOTIFY_OFFSET | 0x40000;
                       dmaPusherPutAddress[8] = 0;
                       dmaPusherPutAddress[9] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_IMAGE_IN_POINT_OFFSET | 0x40000;
                       dmaPusherPutAddress[10] = wSrcPoint.xy;

                       dmaPusherPutAddress += 11;

                       /* Force write combine buffer to flush */
                       pDriverData->NvDmaPusherBufferEnd[0] = 0;
                       /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                       _outp (0x3d0,0);

                       pDriverData->dwDmaPusherFreeCount = freeCount;

                       npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;
                   }

                   if (srcTooWide) {
                       srcTooWide = 0;
                       wDestXY.xy16.x += (short)dstDeltaX;
                       wDstExt.wh16.w = wXYext.wh16.w - wDstExt.wh16.w;
                       if ((srcInVideoMemory) || (isVideo > 3))
                           wSrcPoint.xy16.x += (1024 << 4);
                       srcBufferPitch = dwSrcWidth << 2;
                       srcBufferPitch -= 4096;
                       pSaveSrcInitBits += 1024;
                       pSaveSrcBits = (unsigned long *)pSaveSrcInitBits;
                       pSrcCurScan = pSaveSrcBits;
                       srcCurY = ((long)wSrcXY.xy16.y << 20);
                       goto oneMorePass;
                   }

                   if (isClipped) {
                       if (--nRects > 0)
                           goto nxtScaledRect;
                   }
               }    // stretch

               if (isOverlappingVmem && lpSurfTemp) {
                   // FIXME: wait for blt to complete
                   NVHEAP_FREE(lpSurfTemp);
               }
            }

            if (dwFlags & DDBLT_KEYSRCOVERRIDE) {
                /* disable chroma key */
                while (freeCount < 2)
                    NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
                freeCount -= 2;

                dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_TRANSCOLOR) +
                    SET_TRANSCOLOR_OFFSET | 0x40000;
                dmaPusherPutAddress[1] = 0;

                dmaPusherPutAddress += 2;
            }

            if (isAlphaBlt) {
                /* Restore default destination color format */
                while (freeCount < 2)
                    NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
                freeCount -= 2;

                dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                    SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x40000;

                dmaPusherPutAddress[1] =
                    NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8;

                dmaPusherPutAddress += 2;
            }

        } else {
            DPF("BLT     blt not handled by driver");
            return DDHAL_DRIVER_NOTHANDLED;
        }

        // restore pixel depth for z blts
        if (isZBlt) {
            while (freeCount < 2)
                NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
            freeCount -= 2;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x40000;
            dmaPusherPutAddress[1] = NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8;

            dmaPusherPutAddress += 2;
        }

    } else if (dwFlags & DDBLT_COLORFILL) {
        dwFillColor = pbd->bltFX.dwFillColor & pDriverData->physicalColorMask;

        while (freeCount < 10)
            NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);
        freeCount -= 10;

        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
            SET_ROP_OFFSET | 0x40000;
        dmaPusherPutAddress[1] = SRCCOPYINDEX;

        dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
            SURFACES_2D_DEST_OFFSET | 0x40000;
        dmaPusherPutAddress[3] = dwDstOffset;
        dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SURFACES) +
            SURFACES_2D_PITCH_OFFSET | 0x40000;
        dmaPusherPutAddress[5] = (dwDstPitch << 16) | dwDstPitch;

        dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
            RECT_AND_TEXT_COLOR1A_OFFSET | 0xC0000;
        dmaPusherPutAddress[7] = dwFillColor;
        dmaPusherPutAddress[8] = asmMergeCoords(wDestXY.xy16.y, wDestXY.xy16.x);
        dmaPusherPutAddress[9] = asmMergeCoords(wXYext.wh16.h, wXYext.wh16.w);

        dmaPusherPutAddress += 10;

    } else if (dwFlags & DDBLT_DEPTHFILL) {

        if (!(dwDstCaps & DDSCAPS_ZBUFFER)) {
            pbd->ddRVal = DDERR_INVALIDSURFACETYPE;
            return DDHAL_DRIVER_HANDLED;
        }

        pDriverData->dwDmaPusherFreeCount = freeCount;
        (unsigned long *)pDriverData->NvDmaPusherPutAddress = dmaPusherPutAddress;

        nvD3DClearZBuffer(dstx, pbd->bltFX.dwFillDepth);

        dmaPusherPutAddress = (unsigned long *)pDriverData->NvDmaPusherPutAddress;
#ifdef  CACHE_FREECOUNT
        freeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
        NvCheckCachedFreeCount(freeCount, dmaPusherPutAddress);
#endif  /* DEBUG */
#else   /* CACHE_FREECOUNT */
        freeCount = 0;
#endif  /* CACHE_FREECOUNT */

    } else {
        /* We don't handle any other type of BLT operation */
        return DDHAL_DRIVER_NOTHANDLED;
    }

    pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

    /* Force write combine buffer to flush */
    pDriverData->NvDmaPusherBufferEnd[0] = 0;
    /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
    _outp (0x3d0,0);

    pDriverData->dwDmaPusherFreeCount = freeCount;

    npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

    pbd->ddRVal = DD_OK;

    return DDHAL_DRIVER_HANDLED;

} /* Blt32bpp32 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\d3danti.c ===
#ifdef NV4
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: D3DANTI.C                                                         *
*   AntiAliased Triangles                                                   *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal (bdw)           04/27/97 - NV4 port                     *
*                                                                           *
\***************************************************************************/

#include <math.h>
#include <windows.h>
#include "nvd3ddrv.h"
#include "ddrvmem.h"
#include "nv32.h"
#include "d3dinc.h"
#include "nv3ddbg.h"
#include "nvddobj.h"
#include "nv4vxmac.h"
#include "nvheap.h"

/*****************************************************************************

SuperSampled AA Algorithm:

  * Calls to Clear only logs the color and zbuffer value
  * Calls to render geometry are captured and sorted into buckets. nothing
     is rendered at this point
  * All state are logged as well
  * at EndScene we render the buckets one by one into the super buffer and
     filter it down to screen.
  * ZBuffer will be corrupt at EndScene.

Limitations:
  * Multiple Begin/EndScene apps that rely on z-buffer will not work
  * Texture destroy or blts during the scene will corrupt at playback time
     since the texels are not captured

******************************************************************************

Edge AA Algorithm:

  * Calls to clear are performed normally
  * Calls to render geometry are captured and also rendered. Edges are
     placed in tables for 2nd pass (only for triangles that do not
     alpha blend)
  * All state are logged
  * At EndScene we render the edges as quads
  * ZBuffer will be okay

Limitations:
  * Multiple Begin/EndScene apps with 2d in between will occationally have
     edges appear over 2D.
  * Texture destroy or blts during the scene will corrupt edges at playback
     time since the texels are not captured

*****************************************************************************/

/*
 * constants
 */
#define AA_ALIGNPITCH                       32
#define AA_MIN                              -2047.0f
#define AA_MAX                               2047.0f

#define VF_NEGX                             0x00000001
#define VF_POSX                             0x00000002
#define VF_NEGY                             0x00000004
#define VF_POSY                             0x00000008
#define VF_OUTCODEMASK                      0x0000000f
#define VF_RESTORE                          0x80000000

/*
 * macros
 */
#define AA_ALLOC(x)                         while ((dwIndex + (x)) >= dwSize) { dwSize += 4096; dwAddr=(DWORD)ReallocIPM((void*)dwAddr,dwSize); if (!dwAddr) return FALSE; }
#define AACOMBINE(a,b)                      (((a)<<16)|(b))
#define ISDX6(x)                            ((x) == ((sizeDx6TriangleTLVertex - 1) * 4))

#define IF_NOT_CULLED_BEGIN(v0,v1,v2,cv) {             \
    DWORD _sx0  = v0 + 0;                              \
    DWORD _sy0  = v0 + 4;                              \
    DWORD _sx1  = v1 + 0;                              \
    DWORD _sy1  = v1 + 4;                              \
    DWORD _sx2  = v2 + 0;                              \
    DWORD _sy2  = v2 + 4;                              \
    float _dx10 = *(float*)_sx1 - *(float*)_sx0;       \
    float _dy10 = *(float*)_sy1 - *(float*)_sy0;       \
    float _dx20 = *(float*)_sx2 - *(float*)_sx0;       \
    float _dy20 = *(float*)_sy2 - *(float*)_sy0;       \
           cv   = _dx10*_dy20  - _dx20*_dy10;          \
    if (((*(DWORD*)&cv) ^ dwCullMask1) & dwCullMask2) {
#define IF_NOT_CULLED_END } }

/*
 * externals
 */
#ifndef WINNT
FLATPTR EXTERN_DDAPI DDHAL32_VidMemAlloc  (LPDDRAWI_DIRECTDRAW_GBL pdrv, int heap, DWORD dwXDim, DWORD dwYDim);
void    EXTERN_DDAPI DDHAL32_VidMemFree   (LPDDRAWI_DIRECTDRAW_GBL pdrv, int heap, FLATPTR ptr);
#endif
void nvSetClearSurface  (DWORD,DWORD,DWORD,DWORD,DWORD);
void nvClearSurfaceRect (DWORD,DWORD,DWORD,DWORD);
void nvReset2DSurfaceFormat (void);
void nvAASingleChunkRenderPrimitive (DWORD,LPWORD,DWORD,LPBYTE);

/*
 * tables
 */
typedef struct
{
    float fScaleX;
    float fScaleY;
    DWORD dwSrcPass1;
    DWORD dwDXPass1;
    DWORD dwDYPass1;
    DWORD dwSrcPass2;
    DWORD dwDXPass2;
    DWORD dwDYPass2;
    DWORD dwDU;
    DWORD dwDV;
} NVAATABLE;

NVAATABLE nvAATable[] =
{
    //* test */{ 1.0f, 1.0f, 0x00000000,(1<<20),(1<<20), 0,0,0 },
    /*0*/ { 2.0f, 1.0f, 0x00000008,(2<<20),(1<<20), 0,0,0,                      (1<<20)/2,(1<<20)/1}, // 2x1
    /*1*/ { 2.0f, 2.0f, 0x00080008,(2<<20),(2<<20), 0,0,0,                      (1<<20)/2,(1<<20)/2}, // 2x2
    /*2*/ { 3.0f, 2.0f, 0x00000008,(1<<20),(1<<20), 0x00080008,(3<<20),(2<<20), (1<<20)/3,(1<<20)/2}, // 3x2
    /*3*/ { 3.0f, 3.0f, 0x00080008,(1<<20),(1<<20), 0x00080008,(3<<20),(3<<20), (1<<20)/3,(1<<20)/3}, // 3x3
    /*4*/ { 4.0f, 2.0f, 0x00080008,(2<<20),(2<<20), 0x00000008,(2<<20),(1<<20), (1<<20)/4,(1<<20)/2}, // 4x2
    /*5*/ { 4.0f, 3.0f, 0x00000008,(1<<20),(1<<20), 0x00080008,(2<<20),(3<<20), (1<<20)/4,(1<<20)/3}, // 4x3
    /*6*/ { 4.0f, 4.0f, 0x00080008,(2<<20),(2<<20), 0x00080008,(2<<20),(2<<20), (1<<20)/4,(1<<20)/4}  // 4x4
};

/*
 * nvAACreate
 *
 * creates an AA context - called at createContext time
 */
BOOL nvAACreate
(
    void
)
{
    PNVAACONTEXT pCtx;

    DPF_LEVEL (NVDBG_LEVEL_FUNCTION_CALL, "nvAACreate");

    /*
     * assume AA unavailable
     */
    pCurrentContext->pAAContext       = NULL;
    pCurrentContext->dwAntiAliasFlags = 0;

    /*
     * allocate aa context memory
     */
    pCtx = pCurrentContext->pAAContext = (NVAACONTEXT*)AllocIPM(sizeof(NVAACONTEXT));
    if (!pCtx)
    {
        DPF_LEVEL (NVDBG_LEVEL_ERROR,"nvAACreate: failed to allocate AA Context");
        return FALSE;
    }

    /*
     * setup super sampling constants
     */
    pCtx->dwAASuperMode = pDriverData->regAAMethod;
    pCtx->fAAScaleX     = nvAATable[pCtx->dwAASuperMode].fScaleX;
    pCtx->fAAScaleY     = nvAATable[pCtx->dwAASuperMode].fScaleY;

    /*
     * initialize context
     */
    pCtx->dwChunkWidth  = pCurrentContext->lpLcl->lpGbl->wWidth  / (DWORD)pCtx->fAAScaleX;
    pCtx->dwSuperWidth  = pCurrentContext->lpLcl->lpGbl->wWidth;//pCtx->dwChunkWidth  * (DWORD)pCtx->fAAScaleX;
    pCtx->dwChunkHeight = pCurrentContext->lpLcl->lpGbl->wHeight / (DWORD)pCtx->fAAScaleY;
    pCtx->dwSuperHeight = pCurrentContext->lpLcl->lpGbl->wHeight;//pCtx->dwChunkHeight * (DWORD)pCtx->fAAScaleY;
    if (pCurrentContext->lpLcl->dwFlags & DDRAWISURF_HASPIXELFORMAT)
        pCtx->dwBPP     = pCurrentContext->lpLcl->lpGbl->ddpfSurface.dwRGBBitCount / 8;
    else
        pCtx->dwBPP     = pDriverData->bi.biBitCount / 8;
    pCtx->dwCFill       = 0x00000000;
    pCtx->dwZFill       = 0xffffffff;

    /*
     * success
     */
    return TRUE;
}

/*
 * nvAADestroy
 *
 * free up AA context memory
 */
void nvAADestroy
(
    void
)
{
    PNVAACONTEXT pCtx;

    DPF_LEVEL (NVDBG_LEVEL_FUNCTION_CALL, "nvAADestroy");

    /*
     * get context
     */
    pCtx = pCurrentContext->pAAContext;

    /*
     * free surface memory (if any)
     */
    if (pCtx->dwSuperAddr)
    {
        NVHEAP_FREE(pCtx->dwSuperAddr);
    }

    /*
     * free capture memory
     */
    if (pCtx->dwCapAddr)
    {
        FreeIPM ((void*)(pCtx->dwCapAddr));
    }

    /*
     * free context memory
     */
    FreeIPM (pCtx);

    /*
     * tag AA unavailable
     */
    pCurrentContext->pAAContext       = NULL;
    pCurrentContext->dwAntiAliasFlags = 0;
}

/*
 * nvAACreateBuffers
 *
 * create buffers for AA
 */
BOOL nvAACreateBuffers
(
    void
)
{
    PNVAACONTEXT pCtx;

    DPF_LEVEL (NVDBG_LEVEL_FUNCTION_CALL, "nvAACreateBuffers");

    /*
     * get context
     */
    pCtx = pCurrentContext->pAAContext;

    /*
     * assume buffers not allocated
     */
    pCurrentContext->dwAntiAliasFlags &= ~AA_BUFALLOC_MASK;

    switch (pCurrentContext->dwAntiAliasFlags & AA_ENABLED_MASK)
    {
        /*
         * allocate super sampled buffers
         */
        case AA_MODE_SUPER:
        case AA_MODE_SINGLECHUNK: // not selectable from registry - automatic detection
            {
                DWORD dwSize;

                /*
                 * attempt to allocate the whole super buffer for single-chunk super-sampled aa
                 */
                {
                    DWORD dwSCWidth;
                    DWORD dwSCHeight;
                    DWORD dwSCPitch;
                    DWORD dwSCFAddr = 0;
                    DWORD dwSCZAddr = 0;

                    /*
                     * calc width & check if it will fit to HW limits for single chunk
                     */
                    dwSCWidth = pCtx->dwSuperWidth * (DWORD)pCtx->fAAScaleX;
                    if (dwSCWidth <= AA_MAX)
                    {
                        dwSCHeight = pCtx->dwSuperHeight * (DWORD)pCtx->fAAScaleY;
                        dwSCPitch = ((dwSCWidth * pCtx->dwBPP) + AA_ALIGNPITCH - 1) & ~(AA_ALIGNPITCH - 1);
                        dwSize    = dwSCPitch * dwSCHeight;
                        NVHEAP_ALLOC (dwSCFAddr,dwSize,TYPE_IMAGE);
                        if (dwSCFAddr)
                        {
                            NVHEAP_ALLOC (dwSCZAddr,dwSize,TYPE_DEPTH);
                            if (dwSCZAddr)
                            {
                                /*
                                 * enough memory present - select SCSSAA
                                 */
                                pCtx->dwChunkWidth   = pCtx->dwSuperWidth;   // the window width
                                pCtx->dwSuperWidth   = dwSCWidth;            // scaled width
                                pCtx->dwChunkHeight  = pCtx->dwSuperHeight;  // the window height
                                pCtx->dwSuperHeight  = dwSCHeight;           // scaled height

                                pCtx->dwSuperAddr    = dwSCFAddr;
                                pCtx->dwSuperZAddr   = dwSCZAddr;
                                pCtx->dwSuperOffset  = dwSCFAddr - pDriverData->BaseAddress;
                                pCtx->dwSuperZOffset = dwSCZAddr - pDriverData->BaseAddress;
                                pCtx->dwSuperPitch   = dwSCPitch;
                                pCtx->dwSuperZPitch  = dwSCPitch;

                                /*
                                 * tag buffers allocated
                                 */
                                pCurrentContext->dwAntiAliasFlags &= ~AA_ENABLED_MASK;
                                pCurrentContext->dwAntiAliasFlags |=  AA_MODE_SINGLECHUNK
                                                                  |   AA_BUFALLOC_SINGLECHUNK
                                                                  |   AA_CLEAR_SCREEN;

                                /*
                                 * clear the buffers - courtesy to app
                                 */
                                memset ((void*)pCtx->dwSuperAddr,0,dwSize);
                                memset ((void*)pCtx->dwSuperZAddr,0xff,dwSize);

                                /*
                                 * success
                                 */
                                return TRUE;
                            }
                            else
                            {
                                /*
                                 * free frame buffer
                                 */
                                NVHEAP_FREE (dwSCFAddr);
                                dwSCFAddr = 0;
                            }
                        }
                    }
                }

                /*
                 * compute super buffer size for chunking super sampled AA
                 */
                pCtx->dwSuperPitch = ((pCtx->dwSuperWidth * pCtx->dwBPP) + AA_ALIGNPITCH - 1) & ~(AA_ALIGNPITCH - 1);
                dwSize             = pCtx->dwSuperPitch * pCtx->dwSuperHeight;

                /*
                 * allocate the buffer (allow for alignment)
                 */
                NVHEAP_ALLOC (pCtx->dwSuperAddr,dwSize,TYPE_IMAGE);
                if (!pCtx->dwSuperAddr)
                {
                    /*
                     * fail to allocate memory
                     */
                    return FALSE;
                }

                /*
                 * setup super surface
                 */
                pCtx->dwSuperOffset = pCtx->dwSuperAddr - pDriverData->BaseAddress;

                /*
                 * tag buffers allocated
                 */
                pCurrentContext->dwAntiAliasFlags |= AA_BUFALLOC_SUPER
                                                  |  AA_CLEAR_SCREEN;
            }
            break;
        /*
         * allocate edge buffers
         */
        case AA_MODE_EDGE:
            {
            }
            return FALSE;
            // aatodo - implement

            /*
             * tag buffers allocated
             */
            pCurrentContext->dwAntiAliasFlags |= AA_BUFALLOC_EDGE;
            break;
    }

    /*
     * allocate geometry capture area
     */
    pCtx->dwCapIndex = 0;
    pCtx->dwCapSize  = 4096;
    pCtx->dwCapAddr  = (DWORD)AllocIPM(pCtx->dwCapSize);
    if (!pCtx->dwCapAddr)
    {
        /*
         * not enough memory - fail
         */
        pCurrentContext->dwAntiAliasFlags &= ~AA_BUFALLOC_MASK;
        return FALSE;
    }

    /*
     * success
     */
    return TRUE;
}

/*
 * nvAACapturePrimitive
 *
 * capture triangles for 2nd pass. aa mode == edge will pass this batch
 * through to be rendered as well.
 */
BOOL __stdcall nvAACapturePrimitive
(
    DWORD  nPrimCount,
    LPWORD pIndices,        // NULL for non-indexed cases
    DWORD  dwStrides,
    LPBYTE pVertices
)
{
    PNVAACONTEXT pCtx;
    DWORD        dwOldFifo;
    DWORD        dwOldFreeCount;
#ifndef NV_FASTLOOPS
    DWORD        dwFlags;
#endif

    DPF_LEVEL (NVDBG_LEVEL_FUNCTION_CALL, "nvAACapturePrimitive");
    DPF_LEVEL (NVDBG_LEVEL_AA_INFO,"nvAACapturePrimitive: aa = %08x",pCurrentContext->dwAntiAliasFlags);

    /*
     * check for single-chunking
     */
    if (pCurrentContext->dwAntiAliasFlags & AA_MODE_SINGLECHUNK)
    {
        /*
         * render triangles
         */
        nvAASingleChunkRenderPrimitive (nPrimCount,pIndices,dwStrides,pVertices);

        /*
         * success
         */
        return TRUE;
    }

    /*
     * get context
     */
    pCtx = pCurrentContext->pAAContext;

    /*
     * override fifo
     */
    dwOldFifo      = (DWORD)nvFifo;
    dwOldFreeCount = nvFreeCount;
    nvFifo         = pCtx->dwCapAddr + pCtx->dwCapIndex;
    nvFreeCount    = (pCtx->dwCapSize - pCtx->dwCapIndex) >> 2;
#ifndef NV_FASTLOOPS
    dwFlags        = _CALC_FUNCTION_INDEX(pCurrentContext);
#endif

    /*
     * start fifo capture
     */
    pCurrentContext->dwAntiAliasFlags |= AA_CAPTURE_PUSHBUFFER;

    /*
     * render
     */
    pDriverData->dDrawSpareSubchannelObject = 0;

#ifndef NV_FASTLOOPS
    if (pCurrentContext->bUseDX6Class)
    {
        /*
         * force state load
         */
        nvSetDx6MultiTextureState(pCurrentContext);
        /*
         * dispatch triangles
         */
        if (pIndices)
            fnDX6FlexIndexedTable[dwFlags](nPrimCount,pIndices,dwStrides,pVertices);
        else
            fnDX6FlexTable[dwFlags]((WORD)nPrimCount,dwStrides,pVertices);
    }
    else
    {
        /*
         * force state load
         */
        nvSetDx5TriangleState(pCurrentContext);
        /*
         * dispatch triangles
         */
        if (pIndices)
            fnDX5FlexIndexedTable[dwFlags](nPrimCount,pIndices,dwStrides,pVertices);
        else
            fnDX5FlexTable[dwFlags]((WORD)nPrimCount,dwStrides,pVertices);
    }
#else //NV_FASTLOOPS
    /*
     * force state update
     */
    pCurrentContext->dwStateChange    = TRUE;
    pCurrentContext->dwFunctionLookup = NV_SETUP_FUNCTION_INDEX;
    /*
     * draw them
     */
    nvTriangleDispatch(nPrimCount,pIndices,dwStrides,pVertices);
    /*
     * force innerloop reset since the capturing spoofed the index
     */
    pCurrentContext->dwFunctionLookup = NV_SETUP_FUNCTION_INDEX;
#endif //NV_FASTLOOPS

    /*
     * reset fifo
     */
    pCurrentContext->dwAntiAliasFlags &= ~AA_CAPTURE_PUSHBUFFER;
    pCtx->dwCapIndex = nvFifo - pCtx->dwCapAddr;
    nvFifo           = dwOldFifo;
    nvFreeCount      = dwOldFreeCount;

    /*
     * kill subchannel
     */
    pDriverData->dDrawSpareSubchannelObject = 0;

    /*
     * success
     */
    return TRUE;
}

/*
 * nvAABlt
 *
 * Arbitrary filter blt
 */
void __inline nvAABlt
(
    DWORD dwSrcOffset,
    DWORD dwSrcPitch,
    DWORD dwSrcYX,          // 12.4 12.4
    DWORD dwSrcHW,
    DWORD dwDstOffset,
    DWORD dwDstPitch,
    DWORD dwDstYX,
    DWORD dwDstHW,
    DWORD dwClpYX,
    DWORD dwClpHW,
    DWORD dwDUDX,
    DWORD dwDVDY,
    DWORD dwFormat
)
{
    while (nvFreeCount < 21) nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, 21);
    *(DWORD*)(nvFifo+ 0) = dDrawSubchannelOffset(NV_DD_ROP) + SET_ROP_OFFSET | 0x40000;
    *(DWORD*)(nvFifo+ 4) = SRCCOPYINDEX;
    *(DWORD*)(nvFifo+ 8) = dDrawSubchannelOffset(NV_DD_SURFACES) + SURFACES_2D_DEST_OFFSET | 0x40000;
    *(DWORD*)(nvFifo+12) = dwDstOffset;
    *(DWORD*)(nvFifo+16) = dDrawSubchannelOffset(NV_DD_SURFACES) + SURFACES_2D_PITCH_OFFSET | 0x40000;
    *(DWORD*)(nvFifo+20) = (dwDstPitch << 16) | dwSrcPitch;
    *(DWORD*)(nvFifo+24) = dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000;
    *(DWORD*)(nvFifo+28) = NV_DD_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY;
    *(DWORD*)(nvFifo+32) = dDrawSubchannelOffset(NV_DD_STRETCH) + SCALED_IMAGE_CLIPPOINT_OFFSET | 0x80000;
    *(DWORD*)(nvFifo+36) = dwClpYX;                  // clip point
    *(DWORD*)(nvFifo+40) = dwClpHW;                  // clip size
    *(DWORD*)(nvFifo+44) = dDrawSubchannelOffset(NV_DD_STRETCH) + SCALED_IMAGE_IMAGE_OUT_POINT_OFFSET | 0x100000;
    *(DWORD*)(nvFifo+48) = dwDstYX;                  // dst point
    *(DWORD*)(nvFifo+52) = dwDstHW;                  // dst size
    *(DWORD*)(nvFifo+56) = dwDUDX;                   // dudx
    *(DWORD*)(nvFifo+60) = dwDVDY;                   // dvdy
    *(DWORD*)(nvFifo+64) = dDrawSubchannelOffset(NV_DD_STRETCH) + SCALED_IMAGE_IMAGE_IN_SIZE_OFFSET | 0x100000;
    *(DWORD*)(nvFifo+68) = dwSrcHW;                  // src size
    *(DWORD*)(nvFifo+72) = dwSrcPitch | dwFormat; // src format
    *(DWORD*)(nvFifo+76) = dwSrcOffset;              // src offset
    *(DWORD*)(nvFifo+80) = dwSrcYX;                  // src point x.4
    nvFifo      += 84;
    nvFreeCount -= 21;

    pDriverData->dDrawSpareSubchannelObject = 0;
    //pDriverData->TwoDRenderingOccurred   = TRUE;
    pDriverData->ThreeDRenderingOccurred = 0;
}

/*
 * nvAACut
 *
 * subdivides an edge in 2. with t==0 c=a, t==1 c=b.
 */
void __inline nvAACut
(
    float t,
    DWORD len,
    DWORD a,
    DWORD b,
    DWORD c
)
{
    PREFETCH (a);
    PREFETCH (b);

    /*
     * boundary cases
     */
    if (t <= 0.0f)
    {
        memcpy ((void*)c,(void*)a,len);
        return;
    }
    if (t >= 1.0f)
    {
        memcpy ((void*)c,(void*)b,len);
        return;
    }

    /*
     * harder (real-world) case
     */
    if (ISDX6(len))
    {
        PREFETCH (a+32);
        PREFETCH (b+32);
    }
    {
        float nt   = 1.0f - t;
        float w,rhw,rhw0,rhw1;

        /*
         * sx,sy,sz
         */
        *(float*)(c+0) = nt * (*(float*)(a+0)) + t * (*(float*)(b+0));
        *(float*)(c+4) = nt * (*(float*)(a+4)) + t * (*(float*)(b+4));
        *(float*)(c+8) = nt * (*(float*)(a+8)) + t * (*(float*)(b+8));

        /*
         * 1/w aka rhw
         */
        rhw0 = *(float*)(a+12);
        rhw1 = *(float*)(b+12);
        *(float*)(c+12) = rhw = nt * rhw0 + t * rhw1;
        w   = (rhw == 0.0f) ? 1.0f : (1.0f / rhw);
        t  *= w * rhw1;
        nt *= w * rhw0;

        /*
         * color
         */
        {
            DWORD v0 = *(DWORD*)(a+16);
            DWORD v1 = *(DWORD*)(b+16);
            if (v0 == v1)
            {
                *(DWORD*)(c+16) = v0;
            }
            else
            {
                DWORD a = 0xff000000 & (DWORD)(nt * (float)(v0 & 0xff000000) + t * (float)(v1 & 0xff000000));
                DWORD r = 0x00ff0000 & (DWORD)(nt * (float)(v0 & 0x00ff0000) + t * (float)(v1 & 0x00ff0000));
                DWORD g = 0x0000ff00 & (DWORD)(nt * (float)(v0 & 0x0000ff00) + t * (float)(v1 & 0x0000ff00));
                DWORD b = 0x000000ff & (DWORD)(nt * (float)(v0 & 0x000000ff) + t * (float)(v1 & 0x000000ff));
                *(DWORD*)(c+16) = a | r | g | b;
            }
        }

        /*
         * specular
         */
        {
            DWORD v0 = *(DWORD*)(a+20);
            DWORD v1 = *(DWORD*)(b+20);
            if (v0 == v1)
            {
                *(DWORD*)(c+20) = v0;
            }
            else
            {
                DWORD a = 0xff000000 & (DWORD)(nt * (float)(v0 & 0xff000000) + t * (float)(v1 & 0xff000000));
                DWORD r = 0x00ff0000 & (DWORD)(nt * (float)(v0 & 0x00ff0000) + t * (float)(v1 & 0x00ff0000));
                DWORD g = 0x0000ff00 & (DWORD)(nt * (float)(v0 & 0x0000ff00) + t * (float)(v1 & 0x0000ff00));
                DWORD b = 0x000000ff & (DWORD)(nt * (float)(v0 & 0x000000ff) + t * (float)(v1 & 0x000000ff));
                *(DWORD*)(c+20) = a | r | g | b;
            }
        }

        /*
         * uv0
         */
        *(float*)(c+24) = nt * (*(float*)(a+24)) + t * (*(float*)(b+24));
        *(float*)(c+28) = nt * (*(float*)(a+28)) + t * (*(float*)(b+28));

        /*
         * uv1
         */
        if (ISDX6(len))
        {
            *(float*)(c+32) = nt * (*(float*)(a+32)) + t * (*(float*)(b+32));
            *(float*)(c+36) = nt * (*(float*)(a+36)) + t * (*(float*)(b+36));
        }
    }
}

/*
 * nvAAClip
 *
 * clip triangle to AA_MIN - AA_MAX
 */
void __inline nvAAClip
(
    DWORD i0,
    DWORD i1,
    DWORD i2,
    DWORD len,
    float *XYCache,
    DWORD *VCache,
    DWORD *VFlags
)
{
    DWORD vertex[2 * 6 * 16];
    DWORD *vx0,*vx1,vm0,vm1;
    DWORD o,e,i;

    /*
     * trivial reject
     */
    if (VFlags[i0] & VFlags[i1] & VFlags[i2] & VF_OUTCODEMASK) return;

    /*
     * do the evil copy of vertices. Really simplifies coding. Viva Data Cache.
     */
    vertex[0*16 + 0] = *(DWORD*)&XYCache[i0*2+0];
    vertex[0*16 + 1] = *(DWORD*)&XYCache[i0*2+1];
    memcpy (vertex + 0*16 + 2,(void*)(VCache[i0]+8),len-8);
    vertex[1*16 + 0] = *(DWORD*)&XYCache[i1*2+0];
    vertex[1*16 + 1] = *(DWORD*)&XYCache[i1*2+1];
    memcpy (vertex + 1*16 + 2,(void*)(VCache[i1]+8),len-8);
    vertex[2*16 + 0] = *(DWORD*)&XYCache[i2*2+0];
    vertex[2*16 + 1] = *(DWORD*)&XYCache[i2*2+1];
    memcpy (vertex + 2*16 + 2,(void*)(VCache[i2]+8),len-8);

    /*
     * setup
     */
    vx0 = vertex + 0*16;
    vm0 = 3;
    vx1 = vertex + 6*16;
    vm1 = 0;
    o   = (VFlags[i0] | VFlags[i1] | VFlags[i2]) & VF_OUTCODEMASK;

    /*
     * for four edges
     */
    for (e=1; e<16; e<<=1)
    {
        /*
         * quick edge clip reject
         */
        if (!(o & e))
            continue;

        /*
         * traverse triangle
         */
        for (i=0; i<vm0; i++)
        {
            float edge;
            DWORD index;
            DWORD j  = (i+1) % vm0;
            float *vi = ((float*)vx0) + i*16;
            float *vj = ((float*)vx0) + j*16;
            DWORD oi = 0;
            DWORD oj = 0;

            /*
             * determine outcodes
             */
            switch (e)
            {
                case 1: if (vi[0] < AA_MIN) oi=1;
                        if (vj[0] < AA_MIN) oj=1;
                        edge = AA_MIN; index = 0;
                        break;
                case 2: if (vi[0] > AA_MAX) oi=1;
                        if (vj[0] > AA_MAX) oj=1;
                        edge = AA_MAX; index = 0;
                        break;
                case 4: if (vi[1] < AA_MIN) oi=1;
                        if (vj[1] < AA_MIN) oj=1;
                        edge = AA_MIN; index = 1;
                        break;
                case 8: if (vi[1] > AA_MAX) oi=1;
                        if (vj[1] > AA_MAX) oj=1;
                        edge = AA_MAX; index = 1;
                        break;
            }

            /*
             * outside-outside
             */
            if (oi && oj)
            {
                continue;
            }

            /*
             * inside-outside or outside-inside
             */
            if (oi != oj) // (!oi && oj) || (oi && !oj)
            {
                if (vj[index] > vi[index])
                {
                    float t = vj[index] - vi[index];
                          t = (t == 0.0f) ? 0.5f : ((edge - vi[index]) / t);
                    nvAACut (t,len,(DWORD)vi,(DWORD)vj,(DWORD)&vx1[vm1*16]);
                    vm1++;
                }
                else
                {
                    float t = vi[index] - vj[index];
                          t = (t == 0.0f) ? 0.5f : ((edge - vj[index]) / t);
                    nvAACut (t,len,(DWORD)vj,(DWORD)vi,(DWORD)&vx1[vm1*16]);
                    vm1++;
                }
            }

            /*
             * inside-inside or outside-inside
             */
            if (!oj) // (!oi && !oj) || (oi && !oj)
            {
                memcpy (&vx1[vm1*16],vj,len);
                vm1++;
            }
        }

        /*
         * early exit
         */
        if (vm1 < 3) return;

        /*
         * next edge
         */
        {
            DWORD *t = vx0; vx0 = vx1; vx1 = t;
        }
        vm0 = vm1;
        vm1 = 0;
    }

    /*
     * now that we have clipped - emit triangle fan
     */
    {
        DWORD f[16]; // table to make sure we do not punt used vertices
        DWORD m = ISDX6(len) ? 7 : 15;
        DWORD launch;

        /*
         * tag all as unused
         */
        memset (f,0,sizeof(f));

        /*
         * for all vertices in clipped polygon
         */
        for (i=0; i<vm0; i++)
        {
            DWORD j;

            /*
             * displace vertex entry
             */
            for (j=m; j>0; j--)
            {
                /*
                 * find 1) an uninitialized or 2) invalid entry or 3) an entry that needs restoring already
                 */
                if (!f[j] && (!VCache[j] || VFlags[j]))
                {
                    /*
                     * tag as used & no need to restore
                     */
                    f[j] = 1;
                    goto emit;
                }
            }
            for (j=m; j>0; j--)
            {
                /*
                 * find any entry that we haven't used before
                 */
                if (!f[j])
                {
                    /*
                     * tag as used & need restore
                     */
                    f[j] = 1;
                    VFlags[j] |= VF_RESTORE;
                    goto emit;
                }
            }
            /*
             * control cannot go here unless we clip a triangle into more than 15 vertices and
             *  since we only have 4 clip planes you cannot end up with more than 6.
             * j == 0 at this point which will not cause a crash but will cause degenerate
             *  triangles.
             */
#ifdef DEBUG
            __asm int 3;
#endif

            /*
             * emit vertex
             */
        emit:
            if (ISDX6(len))
            {
                while (nvFreeCount < sizeDx6TriangleTLVertex)
                    nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, sizeDx6TriangleTLVertex);
                *(DWORD*)(nvFifo + 0) = ((sizeDx6TriangleTLVertex-1)<<18) | ((NV_DD_SPARE)<<13) | NV055_TLMTVERTEX((j));
                memcpy ((void*)(nvFifo+4),vx0+i*16,len);
                nvFifo      += sizeDx6TriangleTLVertex * 4;
                nvFreeCount -= sizeDx6TriangleTLVertex;
            }
            else
            {
                while (nvFreeCount < sizeDx5TriangleTLVertex)
                    nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, sizeDx5TriangleTLVertex);
                *(DWORD*)(nvFifo + 0) = ((sizeDx5TriangleTLVertex-1)<<18) | ((NV_DD_SPARE)<<13) | NV054_TLVERTEX((j));
                memcpy ((void*)(nvFifo+4),vx0+i*16,len);
                nvFifo      += sizeDx5TriangleTLVertex * 4;
                nvFreeCount -= sizeDx5TriangleTLVertex;
            }
            /*
             * store launch codes & launch if needed
             */
            if (i==0)
                launch  = j << 8;
            else
            if (i==1)
                launch |= j << 4;
            else
            {
                launch |= j;
                // note: assume sizeDx5TriangleDrawPrimitive == sizeDx6TriangleDrawPrimitive
                while (nvFreeCount < sizeDx5TriangleDrawPrimitive)
                    nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, sizeDx5TriangleDrawPrimitive);
                if (ISDX6(len))
                {
                    nvglDx6TriangleDrawPrimitive (nvFifo, nvFreeCount, NV_DD_SPARE, 0, launch);
                }
                else
                {
                    nvglDx5TriangleDrawPrimitive (nvFifo, nvFreeCount, NV_DD_SPARE, 0, launch);
                }
                launch = (launch & 0xf00) | (j << 4);
            }
        }
    }
}

/*
 * nvAARenderPrimitive
 *
 * play back captured data - called at endScene
 */
BOOL nvAARenderPrimitive
(
    void
)
{
    PNVAACONTEXT pCtx;
    DWORD        dwAddr;
    DWORD        dwIndex;
    DWORD        dwScreenOffset;
    DWORD        dwScreenPitch;
    DWORD        dwScreenHW;
    DWORD        dwScreenYX;
    DWORD        dwSuperHW;
    DWORD        dwChunkHW;
    DWORD        dwClipYX;
    DWORD        dwClipHW;
    float        fAAScaleX;
    float        fAAScaleY;
    float        fAAOffsetX;
    float        fAAOffsetY;

    DPF_LEVEL (NVDBG_LEVEL_FUNCTION_CALL, "nvAARenderPrimitive");
    DPF_LEVEL (NVDBG_LEVEL_AA_INFO,"nvAARenderPrimitive: aa = %08x",pCurrentContext->dwAntiAliasFlags);

    /*
     * get context
     */
    pCtx           = pCurrentContext->pAAContext;

    /*
     * get state
     */
    dwAddr         = pCtx->dwCapAddr;
    dwIndex        = pCtx->dwCapIndex;
    dwScreenOffset = pCurrentContext->dwSurfaceOffset;
    dwScreenPitch  = pCurrentContext->surfacePitch.wColorPitch;
    dwScreenHW     = AACOMBINE(pCurrentContext->lpLcl->lpGbl->wHeight,pCurrentContext->lpLcl->lpGbl->wWidth);
    dwSuperHW      = AACOMBINE(pCtx->dwSuperHeight,pCtx->dwSuperWidth);
    dwChunkHW      = AACOMBINE(pCtx->dwChunkHeight,pCtx->dwChunkWidth);
    fAAScaleX      = pCtx->fAAScaleX;
    fAAScaleY      = pCtx->fAAScaleY;
    dwClipYX       = AACOMBINE(pCurrentContext->surfaceViewport.clipVertical.wY,pCurrentContext->surfaceViewport.clipHorizontal.wX);
    dwClipHW       = AACOMBINE(pCurrentContext->surfaceViewport.clipVertical.wHeight,pCurrentContext->surfaceViewport.clipHorizontal.wWidth);

    /*
     * get an accurate freecount reading
     */
/*
    nvFreeCount = nvGetDmaFreeCount(1);
*/

/*
    //early abort
    pCtx->dwCapIndex = 0;
    return 1;
/**/

    /*
     * play back
     */
    switch (pCurrentContext->dwAntiAliasFlags & AA_ENABLED_MASK)
    {
        case AA_MODE_SUPER:
        {
            DWORD VCache[16];
            DWORD VFlags[16];
            float XYCache[32];
            float chunkW = pCtx->fAAScaleX * (float)pCtx->dwChunkWidth;
            float chunkH = pCtx->fAAScaleY * (float)pCtx->dwChunkHeight;
            DWORD scrnX;
            DWORD scrnY;
            DWORD chunkX;
            DWORD chunkY;
            DWORD chunkMaxX = (DWORD)pCtx->fAAScaleX;
            DWORD chunkMaxY = (DWORD)pCtx->fAAScaleY;
            DWORD dwRectColorFormat;
            DWORD dwSurfColorFormat;

            /*
             * early exit if nothing todo
             */
            if (!pCtx->dwCapIndex)
            {
                return TRUE;
            }

            /*
             * setup
             */
            switch (pCtx->dwBPP)
            {
                case 2:
                    dwRectColorFormat = NV05E_SET_COLOR_FORMAT_LE_X16R5G6B5;
                    dwSurfColorFormat = NV042_SET_COLOR_FORMAT_LE_Y16;
                    break;
                case 3:
                case 4:
                    dwRectColorFormat = NV05E_SET_COLOR_FORMAT_LE_X8R8G8B8;
                    dwSurfColorFormat = NV042_SET_COLOR_FORMAT_LE_Y32;
                    break;
            }

            /*
             * set render phase tag
             */
            pCurrentContext->dwAntiAliasFlags |= AA_RENDER;
            pDriverData->lpLast3DSurfaceRendered = 0;
            nvSetD3DSurfaceState (pCurrentContext);

            /*
             * for all chunks
             */
            fAAOffsetY = 0.0f;
            scrnY      = 0;
            for (chunkY=0; chunkY<chunkMaxY; chunkY++)
            {
                fAAOffsetX = 0.0f;
                scrnX      = 0;

                for (chunkX=0; chunkX<chunkMaxX; chunkX++)
                {
                    DWORD ptr,end,cls;

                    /*
                     * setup
                     */
                    dwScreenYX = AACOMBINE(scrnY,scrnX);

                    /*
                     * clear z buffer and frame buffer of scaled chunk
                     */
                    if (pCurrentContext->lpLclZ)
                    {
                        nvSetClearSurface(
                            pCurrentContext->lpLclZ->lpGbl->fpVidMem - pDriverData->BaseAddress,
                            (WORD)pCurrentContext->lpLclZ->lpGbl->lPitch,
                            dwSurfColorFormat,dwRectColorFormat,pCtx->dwZFill);
                        nvClearSurfaceRect(0,0,pCtx->dwSuperWidth,pCtx->dwSuperHeight);
                    }
                    if (pCurrentContext->dwAntiAliasFlags & AA_CLEAR_SCREEN)
                    {
                        nvSetClearSurface(
                            pCtx->dwSuperOffset,pCtx->dwSuperPitch,
                            dwSurfColorFormat,dwRectColorFormat,pCtx->dwCFill);
                        nvClearSurfaceRect(0,0,pCtx->dwSuperWidth,pCtx->dwSuperHeight);
                    }
                    else
                    {
                        nvReset2DSurfaceFormat();
                        nvAABlt (dwScreenOffset,dwScreenPitch,          dwScreenYX<<4,dwScreenHW,
                                 pCtx->dwSuperOffset,pCtx->dwSuperPitch,0x00000000,dwSuperHW,
                                                                        0x00000000,dwSuperHW,
                                 nvAATable[pCtx->dwAASuperMode].dwDU,nvAATable[pCtx->dwAASuperMode].dwDV,
                                 (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_ZOH << 24) | (NV077_IMAGE_IN_FORMAT_ORIGIN_CORNER << 16));
                    }
                    nvReset2DSurfaceFormat();

                    /*
                     * blt target chunk to scaled chunk
                     */
                    /* keep for future reference
                    nvAABlt (dwScreenOffset,dwScreenPitch,          dwScreenYX<<4,dwChunkHW,
                             pCtx->dwSuperOffset,pCtx->dwSuperPitch,0,dwSuperHW,
                                                                    0,dwSuperHW,
                             (1<<20)/AA_SCALE,(1<<20)/AA_SCALE,
                             (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_ZOH << 24) | (NV077_IMAGE_IN_FORMAT_ORIGIN_CORNER << 16));
                    */

                    /*
                     * play back geometry
                     */
                    ptr = dwAddr;
                    end = dwAddr + dwIndex;
                    cls = 0;
                    memset (VCache,0,sizeof(VCache)); // reset cache for clipper vc displacement algo
                    memset (VFlags,0,sizeof(VFlags));
                    while (ptr < end)
                    {
                        DWORD data = *(DWORD*)ptr;
                        DWORD size = 1 + ((data >> 18) & 0x3f);
                        DWORD skip = size << 2;

                        /*
                        if (nvFreeCount < 128)
                        {
                             nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, 128);
                        }
                        */
                        /*
                        if (data & 0xc0000000)
                        {
                            __asm lea eax,dword ptr [global]
                            __asm int 3;
                        }
                        /**/

                        switch (data)
                        {
                            /*
                             * object
                             */
                            case (0x040000 | (NV_DD_SPARE << 13)):
                            {
                                cls = *(DWORD*)(ptr+4);
                                goto copy;
                            }
                            break;
                            /*
                             * tri launch
                             */
                            case (0x040000 | (NV_DD_SPARE << 13) | NV054_DRAW_PRIMITIVE(0)):
                            case (0x040000 | (NV_DD_SPARE << 13) | NV055_DRAW_PRIMITIVE(0)):
                            {
                                DWORD len    = (data == (0x040000 | (NV_DD_SPARE << 13) | NV055_DRAW_PRIMITIVE(0)))
                                             ? ((sizeDx6TriangleTLVertex - 1) * 4)
                                             : ((sizeDx5TriangleTLVertex - 1) * 4);
                                DWORD launch = *(DWORD*)(ptr+4);

                                /*
                                 * extract vertices of triangle
                                 */
                                DWORD i0     = (launch >> 8)     ;
                                DWORD i1     = (launch >> 4) & 15;
                                DWORD i2     = (launch     ) & 15;

                                /*
                                 * check for clipping
                                 */
                                if ((VFlags[i0] | VFlags[i1] | VFlags[i2]) & VF_OUTCODEMASK)
                                {
                                    /*
                                     * clip
                                     */
                                    nvAAClip (i0,i1,i2,len,XYCache,VCache,VFlags);
                                    /*
                                     * suppress copy
                                     */
                                    break;
                                }

                                /*
                                 * restore punted vertices
                                 */
                                {
                                    DWORD i;
                                    for (i=0; i<3; i++)
                                    {
                                        DWORD x = launch & 15;
                                        launch >>= 4;
                                        if (VFlags[x] & VF_RESTORE)
                                        {
                                            VFlags[x] &= ~VF_RESTORE;
                                            if (ISDX6(len))
                                            {
                                                while (nvFreeCount < sizeDx6TriangleTLVertex)
                                                    nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, sizeDx6TriangleTLVertex);
                                                *(DWORD*)(nvFifo + 0) = ((sizeDx6TriangleTLVertex-1)<<18) | ((NV_DD_SPARE)<<13) | NV055_TLMTVERTEX((x));
                                                *(float*)(nvFifo + 4) = XYCache[x*2+0];
                                                *(float*)(nvFifo + 8) = XYCache[x*2+1];
                                                memcpy ((void*)(nvFifo+12),(void*)(VCache[x]+8),len-8);
                                                nvFifo      += sizeDx6TriangleTLVertex * 4;
                                                nvFreeCount -= sizeDx6TriangleTLVertex;
                                            }
                                            else
                                            {
                                                while (nvFreeCount < sizeDx5TriangleTLVertex)
                                                    nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, sizeDx5TriangleTLVertex);
                                                *(DWORD*)(nvFifo + 0) = ((sizeDx5TriangleTLVertex-1)<<18) | ((NV_DD_SPARE)<<13) | NV054_TLVERTEX((x));
                                                *(float*)(nvFifo + 4) = XYCache[x*2+0];
                                                *(float*)(nvFifo + 8) = XYCache[x*2+1];
                                                memcpy ((void*)(nvFifo+12),(void*)(VCache[x]+8),len-8);
                                                nvFifo      += sizeDx5TriangleTLVertex * 4;
                                                nvFreeCount -= sizeDx5TriangleTLVertex;
                                            }
                                        }
                                    }
                                }

                                /*
                                 * launch tri
                                 */
                                goto copy;
                            }
                            break;
                            /*
                             * something else
                             */
                            default:
                            {
                                DWORD method = data & 0x7ff;
                                /*
                                 * vertex
                                 */
                                if (((cls == D3D_DX5_TEXTURED_TRIANGLE)      && (method >= 0x400) && (method < 0x600))
                                 || ((cls == D3D_DX6_MULTI_TEXTURE_TRIANGLE) && (method >= 0x400) && (method < 0x540)))
                                {
                                    DWORD idx = (cls == D3D_DX5_TEXTURED_TRIANGLE) ? ((method-0x400)/0x20) : ((method-0x400)/0x28);
                                    float sx,sy;

                                    VCache[idx] = ptr+4;
                                    VFlags[idx] = VF_RESTORE; // load on demand

                                    sx = *(float*)(ptr+4) * fAAScaleX + fAAOffsetX;
                                    if (sx < AA_MIN) VFlags[idx] |= VF_NEGX; else
                                    if (sx > AA_MAX) VFlags[idx] |= VF_POSX;
                                    XYCache[idx*2+0] = sx;

                                    sy = *(float*)(ptr+8) * fAAScaleY + fAAOffsetY;
                                    if (sy < AA_MIN) VFlags[idx] |= VF_NEGY; else
                                    if (sy > AA_MAX) VFlags[idx] |= VF_POSY;
                                    XYCache[idx*2+1] = sy;

                                    break;
                                }
                                /*
                                 * blind copy
                                 */
                            copy:
                                while (nvFreeCount < size)
                                    nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, size);
                                memcpy ((void*)nvFifo,(void*)ptr,skip);
                                nvFifo      += skip;
                                nvFreeCount -= size;
                            }
                            break;
                        }
                        ptr += skip;
                    }

                    /*
                     * filter down
                     */
                    if (nvAATable[pCtx->dwAASuperMode].dwDXPass2)
                    {
                        /*
                         * 2-pass filter
                         */
                        nvAABlt (pCtx->dwSuperOffset,pCtx->dwSuperPitch,nvAATable[pCtx->dwAASuperMode].dwSrcPass1,dwSuperHW,
                                 pCtx->dwSuperOffset,pCtx->dwSuperPitch,0x00000000,dwSuperHW,
                                                                        0x00000000,dwSuperHW,
                                 nvAATable[pCtx->dwAASuperMode].dwDXPass1,nvAATable[pCtx->dwAASuperMode].dwDYPass1,
                                 (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24) | (NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16));
                        nvAABlt (pCtx->dwSuperOffset,pCtx->dwSuperPitch,nvAATable[pCtx->dwAASuperMode].dwSrcPass2,dwSuperHW,
                                 dwScreenOffset,dwScreenPitch,          dwScreenYX,dwChunkHW,
                                                                        dwClipYX,dwClipHW,
                                 nvAATable[pCtx->dwAASuperMode].dwDXPass2,nvAATable[pCtx->dwAASuperMode].dwDYPass2,
                                 (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24) | (NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16));
                    }
                    else
                    {
                        /*
                         * 1-pass filter
                         */
                        nvAABlt (pCtx->dwSuperOffset,pCtx->dwSuperPitch,nvAATable[pCtx->dwAASuperMode].dwSrcPass1,dwSuperHW,
                                 dwScreenOffset,dwScreenPitch,          dwScreenYX,dwChunkHW,
                                                                        dwClipYX,dwClipHW,
                                 nvAATable[pCtx->dwAASuperMode].dwDXPass1,nvAATable[pCtx->dwAASuperMode].dwDYPass1,
                                 (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24) | (NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16));
                    }
                    nvReset2DSurfaceFormat();
                    /* unfiltered blt
                    nvAABlt (pCtx->dwSuperOffset,pCtx->dwSuperPitch,0x00000000,dwSuperHW,
                             dwScreenOffset,dwScreenPitch,          0x00000000,dwSuperHW,
                                                                    0x00000000,dwSuperHW,
                             (1<<20),(1<<20),
                             (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_ZOH << 24) | (NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16));
                    */

                    /*
                     * kick off
                     */
                    nvStartDmaBuffer (FALSE);

                    /*
                     * next
                     */
                    fAAOffsetX -= chunkW;
                    scrnX      += pCtx->dwChunkWidth;
                }

                fAAOffsetY -= chunkH;
                scrnY      += pCtx->dwChunkHeight;
            }

            /*
             * reset render phase tag
             */
            pCurrentContext->dwAntiAliasFlags &= ~(AA_RENDER | AA_CLEAR_SCREEN | AA_COPY_SCREEN);
            pCtx->dwCapIndex = 0;
        }
        break;
        case AA_MODE_SINGLECHUNK:
        {
            if (pCurrentContext->dwAntiAliasFlags & AA_PENDING_DATA)
            {
                /*
                 * force the blitter to operate properly (test on simply3d)
                 */
                nvReset2DSurfaceFormat();

                /*
                 * scale down super buffer
                 */
                if (nvAATable[pCtx->dwAASuperMode].dwDXPass2)
                {
                    /*
                     * 2-pass filter
                     */
                    nvAABlt (pCtx->dwSuperOffset,pCtx->dwSuperPitch,nvAATable[pCtx->dwAASuperMode].dwSrcPass1,dwSuperHW,
                             pCtx->dwSuperOffset,pCtx->dwSuperPitch,0x00000000,dwSuperHW,
                                                                    0x00000000,dwSuperHW,
                             nvAATable[pCtx->dwAASuperMode].dwDXPass1,nvAATable[pCtx->dwAASuperMode].dwDYPass1,
                             (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24) | (NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16));
                    nvAABlt (pCtx->dwSuperOffset,pCtx->dwSuperPitch,nvAATable[pCtx->dwAASuperMode].dwSrcPass2,dwSuperHW,
                             dwScreenOffset,dwScreenPitch,          0,dwChunkHW,
                                                                    dwClipYX,dwClipHW,
                             nvAATable[pCtx->dwAASuperMode].dwDXPass2,nvAATable[pCtx->dwAASuperMode].dwDYPass2,
                             (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24) | (NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16));
                }
                else
                {
                    /*
                     * 1-pass filter
                     */
                    nvAABlt (pCtx->dwSuperOffset,pCtx->dwSuperPitch,nvAATable[pCtx->dwAASuperMode].dwSrcPass1,dwSuperHW,
                             dwScreenOffset,dwScreenPitch,          0,dwChunkHW,
                                                                    dwClipYX,dwClipHW,
                             nvAATable[pCtx->dwAASuperMode].dwDXPass1,nvAATable[pCtx->dwAASuperMode].dwDYPass1,
                             (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24) | (NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16));
                }
                pCurrentContext->dwAntiAliasFlags &= ~AA_PENDING_DATA;
            }
        }
        break;
        case AA_MODE_EDGE:
        {
            /*
             * early exit if nothing todo
             */
            if (!pCtx->dwCapIndex)
            {
                return TRUE;
            }
            //aatodo - implement
            pCtx->dwCapIndex = 0;
        }
        break;
    }

    /*
     * reset counters for next frame
     */
    pDriverData->dDrawSpareSubchannelObject = 0;
    //pDriverData->TwoDRenderingOccurred      = TRUE;
    pDriverData->ThreeDRenderingOccurred    = 0;
    nvReset2DSurfaceFormat();

    /*
     * success
     */
    return TRUE;
}

/*
 * nvAASingleChunkRenderPrimitive
 *
 * renders triangles into super buffer
 */
void nvAASingleChunkRenderPrimitive
(
    DWORD  nPrimCount,
    LPWORD pIndices,        // NULL for non-indexed cases
    DWORD  dwStrides,
    LPBYTE pVertices
)
{
    PNVAACONTEXT pCtx;
    DWORD        a0,a1,a2;
    DWORD        dwVertexStride;
    float        fAAScaleX;
    float        fAAScaleY;
    DWORD        dwCullMask1;
    DWORD        dwCullMask2;
    DWORD        dwFogMode;
    DWORD       *dwUVOffset;

    DPF_LEVEL (NVDBG_LEVEL_FUNCTION_CALL, "nvAASingleChunkRenderPrimitive");

    /*
     * get context
     */
    pCtx = pCurrentContext->pAAContext;
    pCurrentContext->dwAntiAliasFlags |= AA_PENDING_DATA;

    /*
     * clear render target if needed, always clear z buffer
     */
    if (pCurrentContext->dwAntiAliasFlags & (AA_CLEAR_SCREEN | AA_COPY_SCREEN))
    {
        DWORD dwRectColorFormat;
        DWORD dwSurfColorFormat;

        /*
         * setup formats
         */
        switch (pCtx->dwBPP)
        {
            case 2:
                dwRectColorFormat = NV05E_SET_COLOR_FORMAT_LE_X16R5G6B5;
                dwSurfColorFormat = NV042_SET_COLOR_FORMAT_LE_Y16;
                break;
            case 3:
            case 4:
                dwRectColorFormat = NV05E_SET_COLOR_FORMAT_LE_X8R8G8B8;
                dwSurfColorFormat = NV042_SET_COLOR_FORMAT_LE_Y32;
                break;
        }

        /*
         * do clear
         */
        if  (pCurrentContext->lpLclZ)
        {
            nvSetClearSurface(
                pCtx->dwSuperZOffset,pCtx->dwSuperZPitch,
                dwSurfColorFormat,dwRectColorFormat,pCtx->dwZFill);
            nvClearSurfaceRect(0,0,pCtx->dwSuperWidth,pCtx->dwSuperHeight);
            nvReset2DSurfaceFormat();
        }

        if (pCurrentContext->dwAntiAliasFlags & AA_CLEAR_SCREEN)
        {
            nvSetClearSurface(
                pCtx->dwSuperOffset,pCtx->dwSuperPitch,
                dwSurfColorFormat,dwRectColorFormat,pCtx->dwCFill);
            nvClearSurfaceRect(0,0,pCtx->dwSuperWidth,pCtx->dwSuperHeight);
            nvReset2DSurfaceFormat();
            /*
             * tag as clear (clear takes precedence over copy)
             */
            pCurrentContext->dwAntiAliasFlags &= ~(AA_CLEAR_SCREEN | AA_COPY_SCREEN);
        }
        /*
         * do copy
         */
        else
        {
            DWORD dwScreenOffset;
            DWORD dwScreenPitch;
            DWORD dwScreenHW;
            DWORD dwSuperHW;

            /*
             * setup
             */
            dwScreenOffset = pCurrentContext->dwSurfaceOffset;
            dwScreenPitch  = pCurrentContext->surfacePitch.wColorPitch;
            dwScreenHW     = AACOMBINE(pCurrentContext->lpLcl->lpGbl->wHeight,pCurrentContext->lpLcl->lpGbl->wWidth);
            dwSuperHW      = AACOMBINE(pCtx->dwSuperHeight,pCtx->dwSuperWidth);

            /*
             * copy screen
             */
            nvAABlt (dwScreenOffset,dwScreenPitch,          0x00000000,dwScreenHW,
                     pCtx->dwSuperOffset,pCtx->dwSuperPitch,0x00000000,dwSuperHW,
                                                            0x00000000,dwSuperHW,
                     nvAATable[pCtx->dwAASuperMode].dwDU,nvAATable[pCtx->dwAASuperMode].dwDV,
                     (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_ZOH << 24) | (NV077_IMAGE_IN_FORMAT_ORIGIN_CORNER << 16));

            /*
             * tag as copied
             */
            pCurrentContext->dwAntiAliasFlags &= ~AA_COPY_SCREEN;
        }

        /*
         * set render target
         */
        pDriverData->lpLast3DSurfaceRendered = 0;
        nvSetD3DSurfaceState (pCurrentContext);

        /*
         * reset triangle object
         */
        if (pCurrentContext->bUseDX6Class)
        {
            nvSetDx6MultiTextureState (pCurrentContext);
        }
        else
        {
            nvSetDx5TriangleState (pCurrentContext);
        }

        /*
         * let it rip while we send some triangles
         */
        nvStartDmaBuffer (FALSE);
    }

    /*
     * setup
     */
    a0 = 0;
    a1 = 1;
    a2 = 2;
    dwVertexStride = fvfData.dwVertexStride;
    fAAScaleX      = pCtx->fAAScaleX;
    fAAScaleY      = pCtx->fAAScaleY;
    dwCullMask1    = (pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_CCW)  ? 0x80000000 : 0x00000000;
    dwCullMask2    = (pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_NONE) ? 0xffffffff : 0x80000000;
    dwFogMode      = pCurrentContext->dwRenderState[D3DRENDERSTATE_FOGENABLE]
                   ? pCurrentContext->dwRenderState[D3DRENDERSTATE_FOGTABLEMODE]
                   : 0;
    dwUVOffset     = ((PNVD3DMULTITEXTURESTATE)(&pCurrentContext->mtsState))->dwUVOffset;

    /*
     * for all primitives
     */
    while (nPrimCount)
    {
        DWORD v0,v1,v2;
        float cv;

        /*
         * extract vertices
         */
        if (pIndices)
        {
            v0 = (DWORD)pVertices + dwVertexStride * (DWORD)pIndices[a0];
            PREFETCH (v0);
            v1 = (DWORD)pVertices + dwVertexStride * (DWORD)pIndices[a1];
            PREFETCH (v1);
            v2 = (DWORD)pVertices + dwVertexStride * (DWORD)pIndices[a2];
            PREFETCH (v2);
        }
        else
        {
            v0 = (DWORD)pVertices + dwVertexStride * a0;
            PREFETCH (v0);
            v1 = (DWORD)pVertices + dwVertexStride * a1;
            PREFETCH (v1);
            v2 = (DWORD)pVertices + dwVertexStride * a2;
            PREFETCH (v2);
        }

        /*
         * cull check
         */
        IF_NOT_CULLED_BEGIN(v0,v1,v2,cv)
            DWORD o0,o1,o2;
            float x0,x1,x2;
            float y0,y1,y2;
            DWORD s0[11],s1[11],s2[11];

            /*
             * scale vertices & compute outcodes
             */
            o0 = 0;
            x0 = *(float*)(v0 + 0) * fAAScaleX;
            if (x0 < AA_MIN) o0 |= VF_NEGX;
            if (x0 > AA_MAX) o0 |= VF_POSX;
            y0 = *(float*)(v0 + 4) * fAAScaleY;
            if (y0 < AA_MIN) o0 |= VF_NEGY;
            if (y0 > AA_MAX) o0 |= VF_POSY;

            o1 = 0;
            x1 = *(float*)(v1 + 0) * fAAScaleX;
            if (x1 < AA_MIN) o1 |= VF_NEGX;
            if (x1 > AA_MAX) o1 |= VF_POSX;
            y1 = *(float*)(v1 + 4) * fAAScaleY;
            if (y1 < AA_MIN) o1 |= VF_NEGY;
            if (y1 > AA_MAX) o1 |= VF_POSY;

            o2 = 0;
            x2 = *(float*)(v2 + 0) * fAAScaleX;
            if (x2 < AA_MIN) o2 |= VF_NEGX;
            if (x2 > AA_MAX) o2 |= VF_POSX;
            y2 = *(float*)(v2 + 4) * fAAScaleY;
            if (y2 < AA_MIN) o2 |= VF_NEGY;
            if (y2 > AA_MAX) o2 |= VF_POSY;

            /*
             * expand vertices into TL format
             */
            if (pCurrentContext->bUseDX6Class)
            {
                DWORD ptr,fc=0;
                switch (dwFogMode)
                {
                    case 0: ptr = (DWORD)s0;
                            nvglDX6FlexTriangleVertex(ptr,fc,NV_DD_SPARE,0,v0,fvfData,dwUVOffset);
                            ptr = (DWORD)s1;
                            nvglDX6FlexTriangleVertex(ptr,fc,NV_DD_SPARE,1,v1,fvfData,dwUVOffset);
                            ptr = (DWORD)s2;
                            nvglDX6FlexTriangleVertex(ptr,fc,NV_DD_SPARE,2,v2,fvfData,dwUVOffset);
                            break;
                    case 1: ptr = (DWORD)s0;
                            nvglDX6FlexTriangleVertexExpFog(ptr,fc,NV_DD_SPARE,0,v0,fvfData,dwUVOffset);
                            ptr = (DWORD)s1;
                            nvglDX6FlexTriangleVertexExpFog(ptr,fc,NV_DD_SPARE,1,v1,fvfData,dwUVOffset);
                            ptr = (DWORD)s2;
                            nvglDX6FlexTriangleVertexExpFog(ptr,fc,NV_DD_SPARE,2,v2,fvfData,dwUVOffset);
                            break;
                    case 2: ptr = (DWORD)s0;
                            nvglDX6FlexTriangleVertexExp2Fog(ptr,fc,NV_DD_SPARE,0,v0,fvfData,dwUVOffset);
                            ptr = (DWORD)s1;
                            nvglDX6FlexTriangleVertexExp2Fog(ptr,fc,NV_DD_SPARE,1,v1,fvfData,dwUVOffset);
                            ptr = (DWORD)s2;
                            nvglDX6FlexTriangleVertexExp2Fog(ptr,fc,NV_DD_SPARE,2,v2,fvfData,dwUVOffset);
                            break;
                    case 3: ptr = (DWORD)s0;
                            nvglDX6FlexTriangleVertexLinearFog(ptr,fc,NV_DD_SPARE,0,v0,fvfData,dwUVOffset);
                            ptr = (DWORD)s1;
                            nvglDX6FlexTriangleVertexLinearFog(ptr,fc,NV_DD_SPARE,1,v1,fvfData,dwUVOffset);
                            ptr = (DWORD)s2;
                            nvglDX6FlexTriangleVertexLinearFog(ptr,fc,NV_DD_SPARE,2,v2,fvfData,dwUVOffset);
                            break;
                }
            }
            else
            {
                DWORD ptr,fc=0;
                switch (dwFogMode)
                {
                    case 0: ptr = (DWORD)s0;
                            nvglDX5FlexTriangleVertex(ptr,fc,NV_DD_SPARE,0,v0,fvfData,dwUVOffset);
                            ptr = (DWORD)s1;
                            nvglDX5FlexTriangleVertex(ptr,fc,NV_DD_SPARE,1,v1,fvfData,dwUVOffset);
                            ptr = (DWORD)s2;
                            nvglDX5FlexTriangleVertex(ptr,fc,NV_DD_SPARE,2,v2,fvfData,dwUVOffset);
                            break;
                    case 1: ptr = (DWORD)s0;
                            nvglDX5FlexTriangleVertexExpFog(ptr,fc,NV_DD_SPARE,0,v0,fvfData,dwUVOffset);
                            ptr = (DWORD)s1;
                            nvglDX5FlexTriangleVertexExpFog(ptr,fc,NV_DD_SPARE,1,v1,fvfData,dwUVOffset);
                            ptr = (DWORD)s2;
                            nvglDX5FlexTriangleVertexExpFog(ptr,fc,NV_DD_SPARE,2,v2,fvfData,dwUVOffset);
                            break;
                    case 2: ptr = (DWORD)s0;
                            nvglDX5FlexTriangleVertexExp2Fog(ptr,fc,NV_DD_SPARE,0,v0,fvfData,dwUVOffset);
                            ptr = (DWORD)s1;
                            nvglDX5FlexTriangleVertexExp2Fog(ptr,fc,NV_DD_SPARE,1,v1,fvfData,dwUVOffset);
                            ptr = (DWORD)s2;
                            nvglDX5FlexTriangleVertexExp2Fog(ptr,fc,NV_DD_SPARE,2,v2,fvfData,dwUVOffset);
                            break;
                    case 3: ptr = (DWORD)s0;
                            nvglDX5FlexTriangleVertexLinearFog(ptr,fc,NV_DD_SPARE,0,v0,fvfData,dwUVOffset);
                            ptr = (DWORD)s1;
                            nvglDX5FlexTriangleVertexLinearFog(ptr,fc,NV_DD_SPARE,1,v1,fvfData,dwUVOffset);
                            ptr = (DWORD)s2;
                            nvglDX5FlexTriangleVertexLinearFog(ptr,fc,NV_DD_SPARE,2,v2,fvfData,dwUVOffset);
                            break;
                }
            }

            /*
             * clip if needed
             */
            if (o0 | o1 | o2)
            {
                static DWORD VFlags[16] = { VF_RESTORE,VF_RESTORE,VF_RESTORE,VF_RESTORE,
                                            VF_RESTORE,VF_RESTORE,VF_RESTORE,VF_RESTORE,
                                            VF_RESTORE,VF_RESTORE,VF_RESTORE,VF_RESTORE,
                                            VF_RESTORE,VF_RESTORE,VF_RESTORE,VF_RESTORE };
                DWORD  VCache[3] = {(DWORD)&s0[1], (DWORD)&s1[1], (DWORD)&s2[1]};
                float XYCache[6] = {x0,y0,x1,y1,x2,y2};
                DWORD len        = pCurrentContext->bUseDX6Class
                                 ? ((sizeDx6TriangleTLVertex - 1) * 4)
                                 : ((sizeDx5TriangleTLVertex - 1) * 4);

                VFlags[0] = VF_RESTORE | o0;
                VFlags[1] = VF_RESTORE | o1;
                VFlags[2] = VF_RESTORE | o2;

                nvAAClip (2,1,0,len,XYCache,VCache,VFlags);
            }
            else
            {
                /*
                 * assign scaled x & y values
                 */
                *(float*)(&s0[1]) = x0;
                *(float*)(&s0[2]) = y0;
                *(float*)(&s1[1]) = x1;
                *(float*)(&s1[2]) = y1;
                *(float*)(&s2[1]) = x2;
                *(float*)(&s2[2]) = y2;

                /*
                 * send to HW
                 */
                if (pCurrentContext->bUseDX6Class)
                {
                    while (nvFreeCount < (sizeDx6TriangleTLVertex * 3 + sizeDx6TriangleDrawPrimitive))
                        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeDx6TriangleTLVertex * 3 + sizeDx6TriangleDrawPrimitive));
                    memcpy ((DWORD*)(nvFifo +  0),s0,sizeDx6TriangleTLVertex * 4);
                    memcpy ((DWORD*)(nvFifo + 44),s1,sizeDx6TriangleTLVertex * 4);
                    memcpy ((DWORD*)(nvFifo + 88),s2,sizeDx6TriangleTLVertex * 4);
                    *(DWORD*)(nvFifo + 132) = (((sizeDx6TriangleDrawPrimitiveMthdCnt << 2) << 16) | ((NV_DD_SPARE) << 13) | NV055_DRAW_PRIMITIVE((0)));
                    *(DWORD*)(nvFifo + 136) = 0x210;
                    nvFifo      += (sizeDx6TriangleTLVertex * 3 + sizeDx6TriangleDrawPrimitive) * 4;
                    nvFreeCount -=  sizeDx6TriangleTLVertex * 3 + sizeDx6TriangleDrawPrimitive;
                }
                else
                {
                    while (nvFreeCount < (sizeDx5TriangleTLVertex * 3 + sizeDx5TriangleDrawPrimitive))
                        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeDx5TriangleTLVertex * 3 + sizeDx5TriangleDrawPrimitive));
                    memcpy ((DWORD*)(nvFifo +  0),s0,sizeDx5TriangleTLVertex * 4);
                    memcpy ((DWORD*)(nvFifo + 36),s1,sizeDx5TriangleTLVertex * 4);
                    memcpy ((DWORD*)(nvFifo + 72),s2,sizeDx5TriangleTLVertex * 4);
                    *(DWORD*)(nvFifo + 108) = (((sizeDx5TriangleDrawPrimitiveMthdCnt << 2) << 16) | ((NV_DD_SPARE) << 13) | NV054_DRAW_PRIMITIVE((0)));
                    *(DWORD*)(nvFifo + 112) = 0x210;
                    nvFifo      += (sizeDx5TriangleTLVertex * 3 + sizeDx5TriangleDrawPrimitive) * 4;
                    nvFreeCount -=  sizeDx5TriangleTLVertex * 3 + sizeDx5TriangleDrawPrimitive;
                }
            }

        IF_NOT_CULLED_END

        /*
         * next
         */
        a0 += (dwStrides & 0x00ff00) >> 8;
        a1 +=  dwStrides & 0x0000ff;
        a2 +=  dwStrides & 0x0000ff;
        if (dwStrides & 0xff0000) a1 ^= a2 , a2 ^= a1 , a1 ^= a2;
        nPrimCount--;
    }

    /*
     * kick off if needed
     */
    nvStartDmaBuffer (TRUE);

}

#endif  // NV4
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\D3dctxt.c ===
/*
 * Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 * (C) Copyright NVIDIA Corporation Inc., 1996,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: D3DCTXT.C                                                         *
*   The Direct 3d Context Management routines.                              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/02/97 - re-wrote and cleaned up.     *
*                                                                           *
\***************************************************************************/
#include <windows.h>
#include "nvd3ddrv.h"
#include "ddrvmem.h"
#include "nv32.h"
#include "d3dinc.h"
#include "nv3ddbg.h"
#include "nvheap.h"

#ifdef NV_DISASM
HANDLE nvPusherFile               = 0;
BOOL   nvPusherDisassemblerEnable = 0;
#endif

//#define NV_TETRIS
#ifdef NV_TETRIS

/*
 * nvTetrisTile
 *
 * reorgs memory to cancel tiling reorg
 */
void nvTetrisTile
(
    DWORD  dwTetrisShift,
    DWORD  dwTetrisMode
)
{
    DWORD dwBase  = pDriverData->BaseAddress;
    DWORD dwSize  = pDriverData->TotalVRAM;

    DWORD dwMask2 = ((1 << dwTetrisMode) - 1) << (10 + dwTetrisShift);
    DWORD dwMask3 = dwMask2 >> dwTetrisMode;
    DWORD dwMask1 = ~(dwMask2 | dwMask3);

    DWORD dwGran  = 1 << (10 + dwTetrisShift - dwTetrisMode);

    BYTE  *p1     = GlobalAlloc(GPTR,dwGran);
    BYTE  *p2     = GlobalAlloc(GPTR,dwGran);

    DWORD dwAddr1;
    DWORD dwAddr2;

    for (dwAddr1 = 0; dwAddr1 < dwSize; dwAddr1 += dwGran)
    {
        dwAddr2 = (dwAddr1 & dwMask1)
                | ((dwAddr1 >> dwTetrisMode) & dwMask3)
                | ((dwAddr1 << dwTetrisMode) & dwMask2);

        if (dwAddr2 > dwAddr1)
        {
            memcpy (p1,(void*)(dwBase + dwAddr1),dwGran);
            memcpy (p2,(void*)(dwBase + dwAddr2),dwGran);
            memcpy ((void*)(dwBase + dwAddr1),p2,dwGran);
            memcpy ((void*)(dwBase + dwAddr2),p1,dwGran);
        }
    }

    GlobalFree (p1);
    GlobalFree (p2);
}

/*
 * nvTetrisTilingEnable
 *
 * safely enables tetris tiling
 */
void nvTetrisTilingEnable
(
    DWORD  dwTetrisShift,
    DWORD  dwTetrisMode
)
{
    DWORD dwCtrl   = ((DWORD)pDriverData->NvBaseFlat) + 0x100200;
    DWORD t;

    /*
     * read/modify register
     */
    t  = *(DWORD*)dwCtrl;
    t &= 0xfff00000;
    t |= 0x2000 | (dwTetrisMode << 15) | (dwTetrisShift << 18);

    /*
     * clear ints
     */
    __asm cli;

    /*
     * restore memory
     */
    nvTetrisTile (dwTetrisShift,dwTetrisMode);

    /*
     * write register
     */
    *(DWORD*)dwCtrl = t;

    /*
     * enable ints
     */
    __asm sti;
}

/*
 * nvTetrisTilingDisable
 *
 * safely enables tetris tiling
 */
void nvTetrisTilingDisable
(
    DWORD  dwTetrisShift,
    DWORD  dwTetrisMode
)
{
    DWORD dwCtrl   = ((DWORD)pDriverData->NvBaseFlat) + 0x100200;
    DWORD t;

    /*
     * read/modify register
     */
    t  = *(DWORD*)dwCtrl;
    t &= 0xfff00000;
    t |= 0x00001114;

    /*
     * clear ints
     */
    __asm cli;

    /*
     * restore memory
     */
    nvTetrisTile (dwTetrisShift,dwTetrisMode);

    /*
     * write register
     */
    *(DWORD*)dwCtrl = t;

    /*
     * enable ints
     */
    __asm sti;
}

#endif //NV_TETRIS

/*
 * Miscellaneous D3D context related routines.
 */
BOOL nvCreateContextListHeap
(
    void
)
{
    /*
     * Create a global heap to allocate internal D3D Context data structures out of.
     * The number of D3D Contexts available can be adjusted by a setting in the registry.
     * It is set reasonably large by default, so hopefully the registry override will never
     * be needed....but just in case.
     */
#ifndef OLDSTUFF
    pDriverData->hContexts_gbl = (DWORD)HEAPCREATE((pDriverData->regD3DContextMax * sizeof(NVD3DCONTEXT)));
#else
    pDriverData->hContexts_gbl = (DWORD)HeapCreate(HEAP_SHARED,
                                                   (pDriverData->regD3DContextMax * sizeof(NVD3DCONTEXT)),
                                                   0);
#endif
    if (!pDriverData->hContexts_gbl)
    {
        DPF_LEVEL (NVDBG_LEVEL_ERROR, "nvCreateContextListHeap - Could not create context list heap!");
        return (FALSE);
    }
    return (TRUE);
}
BOOL nvDestroyContextListHeap
(
    void
)
{
    PNVD3DCONTEXT   pContext;
    PNVD3DCONTEXT   pContextNext;

    /*
     * If there's no heap currently allocated, then there is no heap to destroy.
     */
    if (!pDriverData->hContexts_gbl)
        return (TRUE);

    /*
     * Free any contexts that are still allocated.
     */
    pContext = (PNVD3DCONTEXT)pDriverData->dwContextListHead;
    while (pContext)
    {
        pContextNext = pContext->pContextNext;
#ifndef OLDSTUFF
        HEAPFREE(pDriverData->hContexts_gbl, pContext);
#else
        HeapFree((HANDLE)pDriverData->hContexts_gbl, 0, pContext);
#endif
        pDriverData->dwD3DContextCount--;
        pContext = pContextNext;
    }

    /*
     * Destroy the heap.
     */
#ifndef OLDSTUFF
    HEAPDESTROY(pDriverData->hContexts_gbl);
#else
    HeapDestroy((HANDLE)pDriverData->hContexts_gbl);
#endif
    pDriverData->hContexts_gbl = (DWORD)NULL;
    return (TRUE);
}

/*
 * D3D HAL context callback routines
 */

/*
 * --------------------------------------------------------------------------
 * NvContextCreate
 *
 * LPD3DHAL_CONTEXTCREATEDATA pccd
 *    Pointer to a structure containing things including the current
 *    rendering surface, the current Z surface, and the DirectX object
 *    handle, etc.
 * --------------------------------------------------------------------------
 */
DWORD __stdcall nvContextCreate
(
    LPD3DHAL_CONTEXTCREATEDATA  pccd
)
{
    unsigned char              *pData = 0;
    HDDRVITEM                   hContext;
    LPDDRAWI_DDRAWSURFACE_LCL   lpLcl  = 0;
    LPDDRAWI_DDRAWSURFACE_GBL   lpGbl  = 0;
    LPDDRAWI_DDRAWSURFACE_LCL   lpLclZ = 0;

    /*
     * analyzer markers
     */
#ifdef NV_MARKER
    {
        extern DWORD dwMarkerCount;
        dwMarkerCount = 0;
    }
#endif
#ifdef NV_STATS
    {
        extern DWORD dwSceneCount;
        dwSceneCount = 0;
    }
#endif
    /*
     * push buffer disassembler
     */
#ifdef NV_DISASM
    {
        nvPusherFile = CreateFile("\\PushData.bin",GENERIC_WRITE,0,0,CREATE_ALWAYS,0,0);
        if (nvPusherFile == INVALID_HANDLE_VALUE)
        {
            nvPusherFile = 0;
        }
    }
#endif

    /*
     * Validate the direct draw surface pointers.
     */
    if ((pccd->lpDDS) == NULL)
    {
        pccd->ddrval = DDERR_CURRENTLYNOTAVAIL;
        return (DDHAL_DRIVER_HANDLED);
    }
    if ((lpLcl = DDS_LCL(pccd->lpDDS)) == NULL)
    {
        pccd->ddrval = DDERR_CURRENTLYNOTAVAIL;
        return (DDHAL_DRIVER_HANDLED);
    }
    if (lpLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
    {
        pccd->ddrval = DDERR_CURRENTLYNOTAVAIL;
        return (DDHAL_DRIVER_HANDLED);
    }
    if ((lpGbl = lpLcl->lpGbl) == NULL)
    {
        pccd->ddrval = DDERR_CURRENTLYNOTAVAIL;
        return DDHAL_DRIVER_HANDLED;
    }
    if ((pccd->lpDDSZ != NULL)
     && ((lpLclZ = DDS_LCL(pccd->lpDDSZ)) == NULL))
    {
        pccd->ddrval = DDERR_CURRENTLYNOTAVAIL;
        return (DDHAL_DRIVER_HANDLED);
    }
    if (lpLclZ && (lpLclZ->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY))
    {
        pccd->ddrval = DDERR_CURRENTLYNOTAVAIL;
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Get pointer to global driver data structure.
     */
    NvSetDriverDataPtr(pccd->lpDDGbl);

    /*
     * Setup frequently accessed globals.
     */
    NV_D3D_GLOBAL_SETUP();

#ifdef NV_TETRIS
    /*
     * enable tetris tiling
     */
    nvTetrisTilingEnable (1/* dwBPP / 8 - 1 */,4 /* # lines for a 4:1 aspect tile */);
#endif

    /*
     * NOTES:
     *
     * This callback is invoked when a new surface is to be used as a
     * rendering target.
     * The context handled returned will be used whenever rendering
     * to this surface is to be performed.
     *
     * Allocate a new context from the context array.
     */
#ifndef  OLDSTUFF
    hContext = (HDDRVITEM)HEAPALLOC(pDriverData->hContexts_gbl, sizeof(NVD3DCONTEXT));
#else
    hContext = (HDDRVITEM)HeapAlloc((HANDLE)pDriverData->hContexts_gbl,
                                    HEAP_ZERO_MEMORY,
                                    sizeof(NVD3DCONTEXT));
#endif

    /*
     * Get the pointer to the newly allocated context.
     */
    pCurrentContext = (PNVD3DCONTEXT)hContext;
    if (!pCurrentContext)
    {
        DPF_LEVEL (NVDBG_LEVEL_ERROR, "nvContextCreate - Bad Context");
        NV_D3D_GLOBAL_SAVE();
        pccd->ddrval = D3DHAL_OUTOFCONTEXTS;
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Start with a clean slate.
     */
    memset(pCurrentContext, 0, sizeof(NVD3DCONTEXT));

    /*
     * Save off the applications DirectX version level.
     */
    pCurrentContext->dwDXVersionLevel = pccd->dwhContext;

    /*
     * Return the handle of the new context.
     */
    pccd->dwhContext = hContext;

    /*
     * Set the process ID for the context.
     */
    pCurrentContext->pid = pccd->dwPID;
#ifdef WINNT
    pCurrentContext->lpDD = pccd->lpDDGbl;
#endif // #ifdef WINNT

    /*
     * Initialize the surface specific context data.
     */
    pCurrentContext->lpLcl  = lpLcl;
    pCurrentContext->lpLclZ = lpLclZ;

    /*
     * Do the hardware specific context setup.
     */
    if (!nvSetupContext(pCurrentContext))
    {
        /*
         * When this call fails, it means there was some sort of problem with the
         * surface format.  Either an unsupported pixel format was specified or
         * an unsupported pixel/zeta format was specified.
         * Free the context memory and return an error.
         */
#ifndef OLDSTUFF
        HEAPFREE(pDriverData->hContexts_gbl, pCurrentContext);
#else
        HeapFree((HANDLE)pDriverData->hContexts_gbl, 0, (PVOID)pCurrentContext);
#endif
        pccd->dwhContext = 0;
        pCurrentContext  = 0;
        NV_D3D_GLOBAL_SAVE();
        pccd->ddrval = DDERR_INVALIDPIXELFORMAT;
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Update the open context count.
     */
    pDriverData->dwD3DContextCount++;

    /*
     * Update the context list.
     */
    pCurrentContext->pContextPrev = (PNVD3DCONTEXT)NULL;
    pCurrentContext->pContextNext = (PNVD3DCONTEXT)pDriverData->dwContextListHead;
    if (pCurrentContext->pContextNext)
        pCurrentContext->pContextNext->pContextPrev = pCurrentContext;
    pDriverData->dwContextListHead = (DWORD)pCurrentContext;

    /*
     * Init scene counter
     */
    pCurrentContext->dwSceneCount = 0;


    /*
     * Initiate Anti-Aliasing runtime
     */
    if (!nvAACreate()) {
        DPF_LEVEL (NVDBG_LEVEL_ERROR, "Cannot create AA Context.");
        NV_D3D_GLOBAL_SAVE();
        pccd->ddrval = D3DHAL_OUTOFCONTEXTS;
        return (DDHAL_DRIVER_HANDLED);
    }

#ifdef HW_PAL8
    // allocate some video memory for texture palettes
    //    pCurrentContext->dwTexturePaletteStagingHandle =
    //    nvTMAllocTextureStagingSpace(256*sizeof(DWORD),
    //                                 &(pCurrentContext->dwTexturePaletteAddr),
    //                                 &(pCurrentContext->dwTexturePaletteOffset));
    NVHEAP_ALLOC(pCurrentContext->dwTexturePaletteAddr, 512*sizeof(DWORD), TYPE_IMAGE);
    if (!pCurrentContext->dwTexturePaletteAddr) dbgD3DError();
    pCurrentContext->dwTexturePaletteOffset =
        pCurrentContext->dwTexturePaletteAddr - pDriverData->BaseAddress;
#endif

#ifdef NV_PROFILE
    // Start up profiler
    nvpCreate();
#endif //NV_PROFILE

#ifdef NV_MARKER
    *(DWORD*)(pDriverData->BaseAddress) = 0xcccccccc;
#endif

    /*
     * Context creation complete, return successfully.
     */
    NV_D3D_GLOBAL_SAVE();
    pccd->ddrval = DD_OK;
    return (DDHAL_DRIVER_HANDLED);
}

DWORD __stdcall nvContextDestroy
(
    LPD3DHAL_CONTEXTDESTROYDATA pcdd
)
{

    /*
     * NOTES:
     * This callback is invoked when a context is to be destroyed.
     * Perform any cleanup required.
     *
     * Get pointer to context being destroyed.
     */
    pCurrentContext = (PNVD3DCONTEXT)pcdd->dwhContext;
    if (!pCurrentContext)
    {
        DPF_LEVEL (NVDBG_LEVEL_ERROR, "nvContextDestroy - Bad Context");
        pcdd->ddrval = D3DHAL_CONTEXT_BAD;
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Get pointer to global driver data structure.
     */
    NvSetDriverDataPtrFromContext(pCurrentContext);

    if (pDriverData->dwD3DContextCount == 0)
    {
        pcdd->ddrval = DD_OK;
        return (DDHAL_DRIVER_HANDLED);
    }

#ifdef NV_MARKER
    *(DWORD*)(pDriverData->BaseAddress) = 0xdddddddd;
#endif

    /*
     * push buffer disassembler
     */
#ifdef NV_DISASM
    {
        if (nvPusherFile)
        {
            CloseHandle (nvPusherFile);
            nvPusherFile = 0;
        }
    }
#endif

#ifdef NV_PROFILE
    /*
     * Shut down profiler
     */
    nvpDestroy();
#endif //NV_PROFILE

    /*
     * Shutdown Anti-Aliasing runtime
     */
    if (pCurrentContext->pAAContext) nvAADestroy();

    /*
     * Setup frequently accessed globals.
     */
    NV_D3D_GLOBAL_SETUP();

#ifdef NV_TETRIS
    /*
     * disable tetris tiling
     */
    nvTetrisTilingDisable (1/* dwBPP / 8 - 1 */,4 /* # lines for a 4:1 aspect tile */);
#endif

    /*
     * Destroy all textures associated with this context. The Win2K D3D runtimes
     * seem to dissociate textures from contexts, and will call nvTextureDestroy
     * for each texture created in the context. Thus under Win2K only we defer
     * destroying the textures created in this context.
     */
    nvDestroyTextureContext(pcdd->dwhContext);

    /*
     * Free any default texture associated with this context.
     */
    nvFreeDefaultTexture(pCurrentContext);

    if (pCurrentContext->pContextPrev)
        pCurrentContext->pContextPrev->pContextNext = pCurrentContext->pContextNext;
    if (pCurrentContext->pContextNext)
        pCurrentContext->pContextNext->pContextPrev = pCurrentContext->pContextPrev;
    if (pDriverData->dwContextListHead == (DWORD)pCurrentContext)
        pDriverData->dwContextListHead = (DWORD)pCurrentContext->pContextNext;
#ifndef OLDSTUFF
    HEAPFREE(pDriverData->hContexts_gbl, pCurrentContext);
#else
    HeapFree((HANDLE)pDriverData->hContexts_gbl, 0, (PVOID)pCurrentContext);
#endif
    pDriverData->dwD3DContextCount--;

    /*
     * If there are no more open D3D contexts.  Do any neccessary cleanup.
     */
    if (!pDriverData->dwD3DContextCount)
        nvFinalContextCleanup();

    /*
     * Reset the global context and texture handles.
     */
    pCurrentContext = NULL;
    pDriverData->dwCurrentContextHandle = 0;

    /*
     * Return successfully.
     */
    NV_D3D_GLOBAL_SAVE();
    pcdd->ddrval = DD_OK;
    return (DDHAL_DRIVER_HANDLED);
}
DWORD __stdcall nvContextDestroyAll
(
    LPD3DHAL_CONTEXTDESTROYALLDATA  pcdd
)
{
    PNVD3DCONTEXT   pContext     = 0;
    PNVD3DCONTEXT   pContextNext = 0;

    /*
     * BUGBUG WINNT only - We believe this is an obsolete fct and therefore
     * will never be called, therefore we don't worry about loading
     * pDriverData.
     */

    /*
     * This routine is legacy and will only ever be called in non-mulitmonitor
     * situations, so it's ok to trust what has been previously loaded into
     * pDriverData.
     */
    if (pDriverData->dwD3DContextCount == 0)
    {
        pcdd->ddrval = DD_OK;
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Setup frequently accessed globals.
     */
    NV_D3D_GLOBAL_SETUP();

    /*
     * NOTES:
     *
     * This callback is invoked when a process dies.  All the contexts
     * which were created by this context need to be destroyed.
     *
     * Destroy all valid texture's associated with this process ID.
     */
    nvDestroyTextureProcess(pcdd->dwPID);

    pContext = (PNVD3DCONTEXT)pDriverData->dwContextListHead;
    while (pContext)
    {
        pContextNext = pContext->pContextNext;
        if (pContext->pid == pcdd->dwPID)
        {
            if (pContext->pContextPrev)
                pContext->pContextPrev->pContextNext = pContext->pContextNext;
            if (pContext->pContextNext)
                pContext->pContextNext->pContextPrev = pContext->pContextPrev;
            if (pDriverData->dwContextListHead == (DWORD)pContext)
                pDriverData->dwContextListHead = (DWORD)pContext->pContextNext;

#ifndef OLDSTUFF
            HEAPFREE(pDriverData->hContexts_gbl, pContext);
#else
            HeapFree((HANDLE)pDriverData->hContexts_gbl, 0, pContext);
#endif
            pDriverData->dwD3DContextCount--;
        }
        pContext = pContextNext;
    }

    /*
     * If there are no more open D3D contexts.  Do any neccessary cleanup.
     */
    if (!pDriverData->dwD3DContextCount)
        nvFinalContextCleanup();

    /*
     * Reset the global context and texture handles.
     */
    pDriverData->dwCurrentContextHandle = 0;
    NV_D3D_GLOBAL_SAVE();
    pcdd->ddrval = DD_OK;
    return (DDHAL_DRIVER_HANDLED);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\blt1632.c ===
/*==========================================================================;
 *
 *  Copyright (C) 1995, 1998 NVidia Corporation.  All Rights Reserved.
 *
 *  File:       blt1632.c
 *  Content:    Windows95 DirectDraw 32 bit driver
 *
 ***************************************************************************/

#include "windows.h"
#include <conio.h>
#include "nvd3ddrv.h"
#include "nv32.h"
#include "nvddobj.h"
#include "ddrvmem.h"
#include "d3dinc.h"
#include "global.h"
#include "nvheap.h"

extern DWORD ResetNV();

/*
 * Blt16bpp32
 *
 * 32-bit Blt function for 16bpp surfaces.
 */
DWORD __stdcall Blt16bpp32( LPDDHAL_BLTDATA pbd )
{
    FAST Nv10ControlDma *npDev;
    DWORD               dwFlags;
#ifdef  DX7
    DWORD               dwAFlags;
#endif  /* DX7 */
    DWORD               dwDstCaps;
    DWORD               dwSrcCaps;
    DWORD               dwDDFX = 0;
    DWORD               dwRop;
    NVCOORD             wXYext;
    NVCOORD             wDestXY;
    NVCOORD             wSrcXY;
    BYTE                isZBlt = 0;
    BYTE                wStretch = 0;
    BYTE                doMirrorUpDown = 0;
    BYTE                isVideo = 0;

    DWORD               dwFillColor;
    DWORD               dwColorKey;

    DWORD               dwDstOffset;
    DWORD               dwDstPitch;
    DWORD               dwDstWidth;
    DWORD               dwDstHeight;

    DWORD               dwSrcOffset;
    DWORD               dwSrcPitch;
    DWORD               dwSrcWidth;
    DWORD               dwSrcHeight;

    LPDDRAWI_DDRAWSURFACE_LCL  srcx;
    LPDDRAWI_DDRAWSURFACE_LCL  dstx;
    LPDDRAWI_DDRAWSURFACE_GBL  src;
    LPDDRAWI_DDRAWSURFACE_GBL  dst;

    unsigned long       *dmaPusherPutAddress =
                            (unsigned long *)pDriverData->NvDmaPusherPutAddress;
    unsigned long       *dmaPusherBufferBase =
                            (unsigned long *)pDriverData->NvDmaPusherBufferBase;
    long                freeCount;

    dstx = pbd->lpDDDestSurface;
    dst = dstx->lpGbl;

    /*
     * NOTES:
     *
     * Everything you need is in pdb->bltFX .
     * Look at pdb->dwFlags to determine what kind of blt you are doing,
     * DDBLT_xxxx are the flags.
     *
     * Z BUFFER NOTES:
     *
     * ZBuffer ALWAYS comes in BLTFX.   You don't need to go looking for
     * the attached surface. If DDBLT_ZBUFFER is specified, then either a
     * constant z or z buffer surface has been specified for the source and
     * destination. Just look for the DDBLT_ZBUFFERDESTOVERRIDE,
     * DDBLT_ZBUFFERSRCOVERRIDE, DDBLT_ZBUFFERCONSTANTDESTOVERRIDE, or
     * DDBLT_ZBUFFERCONSTANTSRCOVERRIDE.
     *
     * COLORKEY NOTES:
     *
     * ColorKey ALWAY comes in BLTFX.   You don't have to look it up in
     * the surface.
     */

    dwFlags   = pbd->dwFlags;
    dwDstCaps = dstx->ddsCaps.dwCaps;
#ifdef  DX7
    dwAFlags  = pbd->dwAFlags;

    if ((dwFlags & DDBLT_AFLAGS) && (dwAFlags & DDABLT_SRCOVERDEST)) {
        DPF("ALPHA ON 16BPP SURFACE FAILED");
        pbd->ddRVal = DDERR_NOALPHAHW;
        return DDHAL_DRIVER_HANDLED;
    }
#endif  /* DX7 */

#ifndef NVD3D
    if (dwDstCaps & (DDSCAPS_SYSTEMMEMORY | DDSCAPS_TEXTURE | DDSCAPS_NONLOCALVIDMEM))
        return DDHAL_DRIVER_NOTHANDLED;
#else   // NVD3D

#ifndef NV_TEX2
    /*
     * Check for a 16 Bpp texture blit right ways.
     */
    if (dwDstCaps & DDSCAPS_TEXTURE) {
#ifdef WINNT
    /*
     * Some MS apps insist on passing us DX7 AlphaBlts even though we never
     * claim DX7 support. Our texblt code requires a source, so return
     * an error if the src is not present.
     */
        if (!pbd->lpDDSrcSurface) {
            pbd->ddRVal = DDERR_INVALIDPARAMS;
            return DDHAL_DRIVER_HANDLED;
        }
#endif
        /*
         * Call the special D3D Texture blit code to handle this blit.
         */
        nvTextureBlit16Bpp(pbd);

        /*
         * Return successfully.
         */
        pbd->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;
    }
#endif //!NV_TEX2

    /*
     * Check for any non video memory blits and reject them right away.
     */
    if (dwDstCaps & (DDSCAPS_SYSTEMMEMORY | DDSCAPS_NONLOCALVIDMEM))
        return DDHAL_DRIVER_NOTHANDLED;
#endif  // NVD3D

    // check for z buffer blit
    // assume that DD runtime has enough sense to make alpha blits mutually exclusive
    if ((dwDstCaps & DDSCAPS_ZBUFFER) && (dstx->dwFlags & DDRAWISURF_HASPIXELFORMAT)) {
        if (dst->ddpfSurface.dwZBufferBitDepth == 32)
            isZBlt = NV042_SET_COLOR_FORMAT_LE_Y32;
        else if (dst->ddpfSurface.dwZBufferBitDepth == 16)
            isZBlt = NV042_SET_COLOR_FORMAT_LE_Y16;
    }

    if (dwFlags & DDBLT_DDFX)
        dwDDFX = pbd->bltFX.dwDDFX;

    if (dwFlags & (DDBLT_KEYDEST | DDBLT_KEYDESTOVERRIDE)) {
        DPF("Dest color key failed");
        pbd->ddRVal = DDERR_NOCOLORKEYHW;
        return DDHAL_DRIVER_HANDLED;
    }

    /*
     * Let 3D code know we did some 2D rendering
     */
    pDriverData->TwoDRenderingOccurred = 1;

    /*
     * get offset, width, and height for destination
     */
    dwDstOffset = dst->fpVidMem     - pDriverData->BaseAddress;
    dwDstPitch  = dst->lPitch;
    dwDstWidth  = pbd->rDest.right  - pbd->rDest.left;
    dwDstHeight = pbd->rDest.bottom - pbd->rDest.top;
    wXYext.wh16.w = (unsigned short)dwDstWidth;
    wXYext.wh16.h = (unsigned short)dwDstHeight;

    wDestXY.xy16.x = (short)pbd->rDest.left;
    wDestXY.xy16.y = (short)pbd->rDest.top;

    npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;

    if (npDev == NULL) {
        if (!ResetNV()) {
            pbd->ddRVal = DDERR_GENERIC;
            return DDHAL_DRIVER_HANDLED;
        }
        pDriverData->fReset = FALSE;
        npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;

        if (npDev == NULL) {
            pbd->ddRVal = DDERR_SURFACELOST;
            return DDHAL_DRIVER_HANDLED;
        }
    }

    /*
     * Flag blits to the primary surface.  D3D will use this information
     * at end scene.
     * This is probably not needed and on top of that it has a significant
     * impact on 3D Winbench 98 for some reason.
     */
//    if (dwDstCaps & DDSCAPS_PRIMARYSURFACE)
//        dstx->dwReserved1 |= NV_D3D_HAS_FLIPPED;

    dmaPusherPutAddress = (unsigned long *)pDriverData->NvDmaPusherPutAddress;

#ifdef  CACHE_FREECOUNT
    freeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
    NvCheckCachedFreeCount(freeCount, dmaPusherPutAddress);
#endif  /* DEBUG */
#else   /* CACHE_FREECOUNT */
    freeCount = 0;
#endif  /* CACHE_FREECOUNT */

    if (pDriverData->ddClipUpdate) {

        while (freeCount < 7)
            NvGetDmaBufferFreeCount(npDev, freeCount, 7, dmaPusherPutAddress);
        freeCount -= 7;

        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000;
        dmaPusherPutAddress[1] = NV_DD_IMAGE_BLACK_RECTANGLE;
        dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
            IMAGE_BLACK_RECTANGLE_POINT_OFFSET | 0x80000;
        dmaPusherPutAddress[3] = 0;
        dmaPusherPutAddress[4] = asmMergeCoords(NV_MAX_X_CLIP,
                                                NV_MAX_Y_CLIP);
        dmaPusherPutAddress[5] = dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000;
        dmaPusherPutAddress[6] = NV_DD_SURFACES_2D;

        dmaPusherPutAddress += 7;

        pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

        /* Force write combine buffer to flush */
        pDriverData->NvDmaPusherBufferEnd[0] = 0;
        /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
        _outp (0x3d0,0);

        pDriverData->dwDmaPusherFreeCount = freeCount;

        npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

        pDriverData->dwSharedClipChangeCount++;

        pDriverData->dwDDMostRecentClipChangeCount = pDriverData->dwSharedClipChangeCount;

        pDriverData->ddClipUpdate = FALSE;
    }

    /*
     * If async, then only work if bltter isn't busy
     * This should probably be a little more specific to each call, but
     * waiting for 32 is pretty close
     */
    if( dwFlags & DDBLT_ASYNC ) {

        NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);

        pDriverData->dwDmaPusherFreeCount = freeCount;

        /* Must save pointer in case it was changed by above macro */
        pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

        if (freeCount < 10) {
            DPF("Asynchronous blit failed");
            pbd->ddRVal = DDERR_WASSTILLDRAWING;
            return DDHAL_DRIVER_HANDLED;
        }
    }

    if (dwFlags & DDBLT_ROP) {
        dwRop = pbd->bltFX.dwROP >> 16;

        // set pixel depth for z buffer blit
        if (isZBlt) {
            while (freeCount < 2)
                NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
            freeCount -= 2;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x40000;
            dmaPusherPutAddress[1] = isZBlt;

            dmaPusherPutAddress += 2;
        }

        if ((dwRop == BLACKNESSINDEX) || (dwRop == WHITENESSINDEX)) {

            while (freeCount < 10)
                NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);
            freeCount -= 10;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
                SET_ROP_OFFSET | 0x40000;
            dmaPusherPutAddress[1] = dwRop;

            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                SURFACES_2D_DEST_OFFSET | 0x40000;
            dmaPusherPutAddress[3] = dwDstOffset;
            dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                SURFACES_2D_PITCH_OFFSET | 0x40000;
            dmaPusherPutAddress[5] = (dwDstPitch << 16) | dwDstPitch;

            dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                RECT_AND_TEXT_COLOR1A_OFFSET | 0xC0000;
            dmaPusherPutAddress[7] = 0;
            dmaPusherPutAddress[8] = asmMergeCoords(wDestXY.xy16.y, wDestXY.xy16.x);
            dmaPusherPutAddress[9] = asmMergeCoords(wXYext.wh16.h, wXYext.wh16.w);

            dmaPusherPutAddress += 10;

        } else if ((dwRop == PATCOPYINDEX) || (dwRop == PATINVERTINDEX)) {

            dwFillColor = pbd->bltFX.dwFillColor & pDriverData->physicalColorMask;

            if (dwRop == PATCOPYINDEX)
                dwRop = SRCCOPYINDEX;
            else if (dwRop == PATINVERTINDEX)
                dwRop = SRCINVERTINDEX;

            while (freeCount < 10)
                NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);
            freeCount -= 10;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
                SET_ROP_OFFSET | 0x40000;
            dmaPusherPutAddress[1] = dwRop;

            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                SURFACES_2D_DEST_OFFSET | 0x40000;
            dmaPusherPutAddress[3] = dwDstOffset;
            dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                SURFACES_2D_PITCH_OFFSET | 0x40000;
            dmaPusherPutAddress[5] = (dwDstPitch << 16) | dwDstPitch;

            dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                RECT_AND_TEXT_COLOR1A_OFFSET | 0xC0000;
            dmaPusherPutAddress[7] = dwFillColor;
            dmaPusherPutAddress[8] = asmMergeCoords(wDestXY.xy16.y, wDestXY.xy16.x);
            dmaPusherPutAddress[9] = asmMergeCoords(wXYext.wh16.h, wXYext.wh16.w);

            dmaPusherPutAddress += 10;

        } else if ((dwRop == SRCCOPYINDEX) || (dwRop == SRCPAINTINDEX) ||
                   (dwRop == SRCANDINDEX) || (dwRop == NOTSRCCOPYINDEX) ||
                   (dwRop == SRCINVERTINDEX) || (dwRop == MERGEPAINTINDEX) ||
                   (dwRop == SRCERASEINDEX) || (dwRop == NOTSRCERASEINDEX)) {

            srcx = pbd->lpDDSrcSurface;
            src = srcx->lpGbl;

            dwSrcCaps = srcx->ddsCaps.dwCaps;

            /* We must treat AGP source memory as system memory */
            if (dwSrcCaps & DDSCAPS_NONLOCALVIDMEM) {
                dwSrcCaps &= ~(DDSCAPS_VIDEOMEMORY | DDSCAPS_NONLOCALVIDMEM);
            }

            dwSrcOffset = VIDMEM_OFFSET(src->fpVidMem);
            dwSrcPitch  = src->lPitch;
            dwSrcWidth  = pbd->rSrc.right  - pbd->rSrc.left;
            dwSrcHeight = pbd->rSrc.bottom - pbd->rSrc.top;
            dwColorKey  = pbd->bltFX.ddckSrcColorkey.dwColorSpaceLowValue;

            wSrcXY.xy16.x = (short)pbd->rSrc.left;
            wSrcXY.xy16.y = (short)pbd->rSrc.top;

            if((srcx->dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
               (src->ddpfSurface.dwFlags & DDPF_FOURCC)) {

               if (src->ddpfSurface.dwFourCC == FOURCC_RGB0) {
                   if ((src->ddpfSurface.dwRBitMask == 0x0000F800) &&
                       (src->ddpfSurface.dwGBitMask == 0x000007E0) &&
                       (src->ddpfSurface.dwBBitMask == 0x0000001F)) {
                       if (dwSrcCaps & DDSCAPS_SYSTEMMEMORY)
                           isVideo = 1;
                       goto srcRGB;
                   } else {
                       pbd->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                       return DDHAL_DRIVER_HANDLED;
                   }
               } else if (src->ddpfSurface.dwFourCC == FOURCC_RAW8) {
                   pbd->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                   return DDHAL_DRIVER_HANDLED;
               }

               while (freeCount < 6)
                   NvGetDmaBufferFreeCount(npDev, freeCount, 6, dmaPusherPutAddress);
               freeCount -= 6;

               dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
                   SET_ROP_OFFSET | 0x40000;
               dmaPusherPutAddress[1] = SRCCOPYINDEX;

               dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                   SURFACES_2D_DEST_OFFSET | 0x40000;
               dmaPusherPutAddress[3] = dwDstOffset;
               dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                   SURFACES_2D_PITCH_OFFSET | 0x40000;
               dmaPusherPutAddress[5] = (dwDstPitch << 16) | dwDstPitch;

               dmaPusherPutAddress += 6;

               pDriverData->dwDmaPusherFreeCount = freeCount;

               /* Just in case we return unexpectedly */
               pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

               switch (src->ddpfSurface.dwFourCC) {
                   case FOURCC_UYVY:
                   case FOURCC_UYNV:
                   case FOURCC_YUY2:
                   case FOURCC_YUNV:
//                     if (dwSrcWidth & 1) {  NEC MPEG CODEC DOESN'T RESPOND TO THIS ERROR
//                           pbd->ddRVal = DDERR_INVALIDRECT;
//                           return DDHAL_DRIVER_HANDLED;
//                       }

                       if (wSrcXY.xy16.x & 1) {
                           pbd->ddRVal = DDERR_INVALIDRECT;
                           return DDHAL_DRIVER_HANDLED;
                       }

                       if ((src->ddpfSurface.dwFourCC == FOURCC_UYVY) ||
                           (src->ddpfSurface.dwFourCC == FOURCC_UYNV)) {
                           isVideo = 2;
                           // Is this surface DMAable ?
                           if ((pDriverData->fNvActiveFloatingContexts &
                                NV_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY) &&
                               (pDriverData->NvFloating0UYVYSurfaceMem == src->fpVidMem))
                                   isVideo = 4;
                           else if ((pDriverData->fNvActiveFloatingContexts &
                                NV_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY) &&
                               (pDriverData->NvFloating1UYVYSurfaceMem == src->fpVidMem))
                                   isVideo = 5;
                       } else { // YUY2
                           isVideo = 3;
                           // Is this surface DMAable ?
                           if ((pDriverData->fNvActiveFloatingContexts &
                                NV_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY) &&
                               (pDriverData->NvFloating0YUYVSurfaceMem == src->fpVidMem))
                                   isVideo = 6;
                           else if ((pDriverData->fNvActiveFloatingContexts &
                                NV_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY) &&
                               (pDriverData->NvFloating1YUYVSurfaceMem == src->fpVidMem))
                                   isVideo = 7;
                       }
                       goto srcRGB;
                   break;

                   case FOURCC_YV12:
                       // Size has to be always * 4, to use VU subsampling
                       if ((dwSrcWidth & 3) || (dwSrcHeight & 3)) {
                           pbd->ddRVal = DDERR_INVALIDRECT;
                           return DDHAL_DRIVER_HANDLED;
                       }
                       return DDHAL_DRIVER_HANDLED;
                   break;
               }
               pbd->ddRVal = DDERR_UNSUPPORTEDFORMAT;
               return DDHAL_DRIVER_HANDLED;
            }

srcRGB:     if (dwDDFX & DDBLTFX_MIRRORUPDOWN)
                doMirrorUpDown = 1;

            if ((dwSrcWidth != dwDstWidth) || (dwSrcHeight != dwDstHeight))
                wStretch = 1;

            if (isVideo > 1) /* YUV video */
                wStretch = 1;

            if (dwFlags & DDBLT_KEYSRCOVERRIDE) {

               dwColorKey = pbd->bltFX.ddckSrcColorkey.dwColorSpaceLowValue;

               /* Let D3D know that we changed the object in subchannel 6 */
               pDriverData->dDrawSpareSubchannel6Object = NV_DD_CONTEXT_COLOR_KEY;

               while (freeCount < 4)
                   NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
               freeCount -= 4;

               // load and enable chroma key
               dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_TRANSCOLOR) | 0x40000;
               dmaPusherPutAddress[1] = NV_DD_CONTEXT_COLOR_KEY;
               dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_TRANSCOLOR) +
                   SET_TRANSCOLOR_OFFSET | 0x40000;
               dmaPusherPutAddress[3] =
                    (dwColorKey & pDriverData->physicalColorMask) | NV_ALPHA_1_016;

               dmaPusherPutAddress += 4;

               pDriverData->dwDmaPusherFreeCount = freeCount;

               /* Just in case we return unexpectedly */
               pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;
            }

            // screen to screen bitblt
            if (wStretch == 0) {

                if ((dwDstCaps & DDSCAPS_VIDEOMEMORY) &&
                    (dwSrcCaps & DDSCAPS_VIDEOMEMORY) &&
                    ((dwSrcCaps & DDSCAPS_TEXTURE) == 0) &&
                    (doMirrorUpDown == 0) &&
                    (isVideo == 0)) {

                    if (pDriverData->dwSharedClipChangeCount != pDriverData->dwDDMostRecentClipChangeCount) {

                        while (freeCount < 7)
                            NvGetDmaBufferFreeCount(npDev, freeCount, 7, dmaPusherPutAddress);
                        freeCount -= 7;

                        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000;
                        dmaPusherPutAddress[1] = NV_DD_IMAGE_BLACK_RECTANGLE;
                        dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                            IMAGE_BLACK_RECTANGLE_POINT_OFFSET | 0x80000;
                        dmaPusherPutAddress[3] = 0;
                        dmaPusherPutAddress[4] = asmMergeCoords(NV_MAX_X_CLIP, NV_MAX_Y_CLIP);
                        dmaPusherPutAddress[5] = dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000;
                        dmaPusherPutAddress[6] = NV_DD_SURFACES_2D;

                        dmaPusherPutAddress += 7;

                        pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

                        /* Force write combine buffer to flush */
                        pDriverData->NvDmaPusherBufferEnd[0] = 0;
                        /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                        _outp (0x3d0,0);

                        pDriverData->dwDmaPusherFreeCount = freeCount;

                        npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                        pDriverData->dwSharedClipChangeCount++;

                        pDriverData->dwDDMostRecentClipChangeCount = pDriverData->dwSharedClipChangeCount;
                    }

                    while (freeCount < 10)
                        NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);
                    freeCount -= 10;

                    dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
                        SET_ROP_OFFSET | 0x40000;
                    dmaPusherPutAddress[1] = dwRop;

                    dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                        SURFACES_2D_PITCH_OFFSET | 0xC0000;
                    dmaPusherPutAddress[3] = (dwDstPitch << 16) | dwSrcPitch;
                    dmaPusherPutAddress[4] = dwSrcOffset;
                    dmaPusherPutAddress[5] = dwDstOffset;

                    dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_BLIT) +
                        BLIT_POINT_IN_OFFSET | 0xC0000;
                    dmaPusherPutAddress[7] = wSrcXY.xy;
                    dmaPusherPutAddress[8] = wDestXY.xy;
                    dmaPusherPutAddress[9] = wXYext.wh;

                    dmaPusherPutAddress += 10;

                } else {
                    // memory to screen blt (src may be in system memory or in video memory)
                   unsigned long temp;
                   long srcScanLength;
                   long nxtSrcScan;
                   short n = wXYext.wh16.h;
                   FAST short pxlCount;
                   unsigned long srcOffset;
                   unsigned char *pSrcInitBits;

                   pSrcInitBits = (unsigned char *)src->fpVidMem;
                   srcScanLength = src->lPitch;

                   if (doMirrorUpDown)
                       wSrcXY.xy16.y += (n - 1);

                   pSrcInitBits += (wSrcXY.xy16.y * srcScanLength);

                   srcOffset = wSrcXY.xy16.x & 1;

                   temp = ((wXYext.wh16.w + 1 + srcOffset) & 0xFFFE);

                   nxtSrcScan = (srcScanLength >> 1) - temp;

                   if (doMirrorUpDown)
                       nxtSrcScan = -(srcScanLength >> 1) - temp;

                   pSrcInitBits += ((wSrcXY.xy16.x & 0xFFFE) << 1);

                   while (freeCount < 15)
                       NvGetDmaBufferFreeCount(npDev, freeCount, 15, dmaPusherPutAddress);
                   freeCount -= 15;

                   if (pDriverData->dDrawSpareSubchannelObject !=
                       NV_DD_IMAGE_BLACK_RECTANGLE) {

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                       dmaPusherPutAddress[1] = NV_DD_IMAGE_BLACK_RECTANGLE;

                       dmaPusherPutAddress += 2;

                       pDriverData->dDrawSpareSubchannelObject =
                       NV_DD_IMAGE_BLACK_RECTANGLE;
                   }

                   /* Let others know that we changed the clip */
                   pDriverData->dwSharedClipChangeCount++;

                   // changing canvas clip avoids manually aligning 16-bit source /
                   dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) +
                       IMAGE_BLACK_RECTANGLE_POINT_OFFSET | 0x80000;
                   dmaPusherPutAddress[1] = wDestXY.xy;
                   dmaPusherPutAddress[2] = wXYext.wh;

                   dmaPusherPutAddress[3] = dDrawSubchannelOffset(NV_DD_ROP) +
                       SET_ROP_OFFSET | 0x40000;
                   dmaPusherPutAddress[4] = dwRop;

                   dmaPusherPutAddress[5] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                       SURFACES_2D_DEST_OFFSET | 0x40000;
                   dmaPusherPutAddress[6] = dwDstOffset;
                   dmaPusherPutAddress[7] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                       SURFACES_2D_PITCH_OFFSET | 0x40000;
                   dmaPusherPutAddress[8] = (dwDstPitch << 16) | dwDstPitch;

                   dmaPusherPutAddress[9] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                       IMAGE_FROM_CPU_POINT_OFFSET | 0xC0000;
                   dmaPusherPutAddress[10] =
                       asmMergeCoords((wDestXY.xy16.x - srcOffset), wDestXY.xy16.y);
                   dmaPusherPutAddress[11] =
                       asmMergeCoords(wXYext.wh16.w + srcOffset, wXYext.wh16.h);
                   dmaPusherPutAddress[12] =
                       asmMergeCoords(temp, wXYext.wh16.h);

                   dmaPusherPutAddress += 13;

                   {
                       FAST unsigned short *pSrcBits = (unsigned short *)pSrcInitBits;
                       FAST unsigned long tmpPxls0, tmpPxls1, tmpPxls2;

                       if (temp < (1792 << 1)) {
                           while (--n >= 0) {
                               pxlCount = (short)temp;

                               // Get enough buffer space for this scanline
                               while (freeCount < (long)(1 + (temp >> 1)))
                                   NvGetDmaBufferFreeCount(npDev, freeCount, (long)(1 + (temp >> 1)), dmaPusherPutAddress);
                               freeCount -= (long)(1 + (temp >> 1));

                               dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                                   IMAGE_FROM_CPU_COLOR_OFFSET | (temp << 17);
                               dmaPusherPutAddress += 1;

                               while (pxlCount >= 16) {
                                   pxlCount -= 16;

                                   tmpPxls0 = *(unsigned long *)&pSrcBits[0];
                                   tmpPxls1 = *(unsigned long *)&pSrcBits[2];
                                   dmaPusherPutAddress[0] = tmpPxls0;
                                   tmpPxls2 = *(unsigned long *)&pSrcBits[4];
                                   dmaPusherPutAddress[1] = tmpPxls1;
                                   tmpPxls0 = *(unsigned long *)&pSrcBits[6];
                                   tmpPxls1 = *(unsigned long *)&pSrcBits[8];
                                   dmaPusherPutAddress[2] = tmpPxls2;
                                   dmaPusherPutAddress[3] = tmpPxls0;
                                   tmpPxls2 = *(unsigned long *)&pSrcBits[10];
                                   tmpPxls0 = *(unsigned long *)&pSrcBits[12];
                                   dmaPusherPutAddress[4] = tmpPxls1;
                                   dmaPusherPutAddress[5] = tmpPxls2;
                                   tmpPxls1 = *(unsigned long *)&pSrcBits[14];
                                   dmaPusherPutAddress[6] = tmpPxls0;
                                   pSrcBits += 16;
                                   dmaPusherPutAddress[7] = tmpPxls1;

                                   dmaPusherPutAddress += 8;
                               }

                               if (pxlCount > 0) {

                                   while (pxlCount >= 4) {
                                       pxlCount -= 4;
                                       tmpPxls0 = *(unsigned long *)&pSrcBits[0];
                                       tmpPxls1 = *(unsigned long *)&pSrcBits[2];
                                       pSrcBits += 4;
                                       dmaPusherPutAddress[0] = tmpPxls0;
                                       dmaPusherPutAddress[1] = tmpPxls1;

                                       dmaPusherPutAddress += 2;
                                   }

                                   if (pxlCount > 0) {
                                       tmpPxls0 = *(unsigned long *)&pSrcBits[0];
                                       pSrcBits += 2;
                                       dmaPusherPutAddress[0] = tmpPxls0;

                                       dmaPusherPutAddress++;
                                   }
                               }
                               pSrcBits += nxtSrcScan;
                               /* Force write combine buffer to flush */
                               pDriverData->NvDmaPusherBufferEnd[0] = 0;
                               /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                               _outp (0x3d0,0);

                               pDriverData->dwDmaPusherFreeCount = freeCount;

                               npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;
                           }
                       } else { /* more than 1792 dwords per scanline */

                           while (--n >= 0) {
                               pxlCount = (short)temp;

                               while (pxlCount >= 16) {
                                   pxlCount -= 16;

                                   while (freeCount < (1 + (16 >> 1)))
                                       NvGetDmaBufferFreeCount(npDev, freeCount, (1 + (16 >> 1)), dmaPusherPutAddress);
                                   freeCount -= (1 + (16 >> 1));

                                   dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                                       IMAGE_FROM_CPU_COLOR_OFFSET | (16 << 17);

                                   tmpPxls0 = *(unsigned long *)&pSrcBits[0];
                                   tmpPxls1 = *(unsigned long *)&pSrcBits[2];
                                   dmaPusherPutAddress[1] = tmpPxls0;
                                   tmpPxls2 = *(unsigned long *)&pSrcBits[4];
                                   dmaPusherPutAddress[2] = tmpPxls1;
                                   tmpPxls0 = *(unsigned long *)&pSrcBits[6];
                                   tmpPxls1 = *(unsigned long *)&pSrcBits[8];
                                   dmaPusherPutAddress[3] = tmpPxls2;
                                   dmaPusherPutAddress[4] = tmpPxls0;
                                   tmpPxls2 = *(unsigned long *)&pSrcBits[10];
                                   tmpPxls0 = *(unsigned long *)&pSrcBits[12];
                                   dmaPusherPutAddress[5] = tmpPxls1;
                                   dmaPusherPutAddress[6] = tmpPxls2;
                                   tmpPxls1 = *(unsigned long *)&pSrcBits[14];
                                   dmaPusherPutAddress[7] = tmpPxls0;
                                   pSrcBits += 16;
                                   dmaPusherPutAddress[8] = tmpPxls1;

                                   dmaPusherPutAddress += 9;
                               }

                               if (pxlCount > 0) {

                                   while (freeCount < (1 + (pxlCount >> 1)))
                                       NvGetDmaBufferFreeCount(npDev, freeCount, (1 + (pxlCount >> 1)), dmaPusherPutAddress);
                                   freeCount -= (1 + (pxlCount >> 1));

                                   dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                                       IMAGE_FROM_CPU_COLOR_OFFSET | (pxlCount << 17);
                                   dmaPusherPutAddress += 1;

                                   while (pxlCount >= 4) {
                                       pxlCount -= 4;
                                       tmpPxls0 = *(unsigned long *)&pSrcBits[0];
                                       tmpPxls1 = *(unsigned long *)&pSrcBits[2];
                                       pSrcBits += 4;
                                       dmaPusherPutAddress[0] = tmpPxls0;
                                       dmaPusherPutAddress[1] = tmpPxls1;

                                       dmaPusherPutAddress += 2;
                                   }

                                   if (pxlCount > 0) {
                                       tmpPxls0 = *(unsigned long *)&pSrcBits[0];
                                       pSrcBits += 2;
                                       dmaPusherPutAddress[0] = tmpPxls0;

                                       dmaPusherPutAddress++;
                                   }
                               }
                               pSrcBits += nxtSrcScan;
                               /* Force write combine buffer to flush */
                               pDriverData->NvDmaPusherBufferEnd[0] = 0;
                               /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                               _outp (0x3d0,0);

                               pDriverData->dwDmaPusherFreeCount = freeCount;

                               npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;
                           }
                       }
                   }

                   pDriverData->dwSharedClipChangeCount++;

                   pDriverData->dwDDMostRecentClipChangeCount = pDriverData->dwSharedClipChangeCount;

                   while (freeCount < 3)
                       NvGetDmaBufferFreeCount(npDev, freeCount, 3, dmaPusherPutAddress);
                   freeCount -= 3;

                   // restore canvas clip
                   dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) +
                       IMAGE_BLACK_RECTANGLE_POINT_OFFSET | 0x80000;
                   dmaPusherPutAddress[1] = 0;
                   dmaPusherPutAddress[2] = asmMergeCoords(NV_MAX_X_CLIP, NV_MAX_Y_CLIP);
                   dmaPusherPutAddress += 3;
                }
            } else { // stretch
                RECT rDummy;
                BOOL isOverlappingVmem = FALSE;
                FLATPTR lpSurfTemp = 0;
                DWORD dwSrcBitsPP = 16;
                BOOL useStretched = FALSE;

                /*
                 *  Fractional positioning bands of the SCALED IMAGE class when downscaling
                 *  vertically by small amounts is just too hard to get correct so we switch to the
                 *  STRETCHED IMAGE class when that occurs.
                 */

                if ((!(dwSrcCaps & DDSCAPS_VIDEOMEMORY)) && (dwSrcHeight > dwDstHeight))
                    useStretched = TRUE;

                // if the source and destination overlap, then we must do this in 2 passes, first copy the source
                // image somewhere else, and then so the stretch from there.
                if ((dwSrcCaps & DDSCAPS_VIDEOMEMORY) && dwSrcOffset == dwDstOffset && IntersectRect(&rDummy, (LPRECT)(&pbd->rSrc), (LPRECT)(&pbd->rDest))) {
                    NVHEAP_ALLOC(lpSurfTemp, dwSrcHeight * ((dwSrcWidth * dwSrcBitsPP / 8 + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad), TYPE_IMAGE);
                    if (lpSurfTemp) {
                        isOverlappingVmem = TRUE;
                        if (pDriverData->dwSharedClipChangeCount != pDriverData->dwDDMostRecentClipChangeCount) {

                            while (freeCount < 7)
                                NvGetDmaBufferFreeCount(npDev, freeCount, 7, dmaPusherPutAddress);
                            freeCount -= 7;

                            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000;
                            dmaPusherPutAddress[1] = NV_DD_IMAGE_BLACK_RECTANGLE;
                            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                                IMAGE_BLACK_RECTANGLE_POINT_OFFSET | 0x80000;
                            dmaPusherPutAddress[3] = 0;
                            dmaPusherPutAddress[4] = asmMergeCoords(NV_MAX_X_CLIP, NV_MAX_Y_CLIP);
                            dmaPusherPutAddress[5] = dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000;
                            dmaPusherPutAddress[6] = NV_DD_SURFACES_2D;

                            dmaPusherPutAddress += 7;

                            pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

                            /* Force write combine buffer to flush */
                            pDriverData->NvDmaPusherBufferEnd[0] = 0;
                            /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                            _outp (0x3d0,0);

                            pDriverData->dwDmaPusherFreeCount = freeCount;

                            npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                            pDriverData->dwSharedClipChangeCount++;

                            pDriverData->dwDDMostRecentClipChangeCount = pDriverData->dwSharedClipChangeCount;
                        }

                        while (freeCount < 10)
                            NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);
                        freeCount -= 10;

                        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
                            SET_ROP_OFFSET | 0x40000;
                        dmaPusherPutAddress[1] = dwRop;

                        dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                            SURFACES_2D_PITCH_OFFSET | 0xC0000;
                        dmaPusherPutAddress[3] = ((((dwSrcWidth * dwSrcBitsPP / 8 + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad)) << 16) | dwSrcPitch;
                        dmaPusherPutAddress[4] = dwSrcOffset;
                        dmaPusherPutAddress[5] = lpSurfTemp - pDriverData->BaseAddress;

                        dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_BLIT) +
                            BLIT_POINT_IN_OFFSET | 0xC0000;
                        dmaPusherPutAddress[7] = wSrcXY.xy;
                        dmaPusherPutAddress[8] = 0;
                        dmaPusherPutAddress[9] = wXYext.wh;

                        dmaPusherPutAddress += 10;

                        dwSrcOffset = lpSurfTemp - pDriverData->BaseAddress;
                        dwSrcPitch = ((dwSrcWidth * dwSrcBitsPP / 8 + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad);
                        wSrcXY.xy = 0;
                        wSrcXY.xy16.x = 0;
                        wSrcXY.xy16.y = 0;
                    } else {
                        // FIXME: vmem heap alloc failed, must do system mem alloc and copy there
                    }
                }
                // WARNING: carefully consider each use of src->fpVidMem and src->lPitch beyond this point
                //          it could screw up overlapping stretchblits

               if ((dwFlags & DDBLT_KEYSRCOVERRIDE) || (useStretched)) { // If color key then MUST use STRETCHED IMAGE instead of SCALED IMAGE
                   NvNotification *pDmaBufferNotifier;
                   unsigned char *pScanlineBuffer;
                   long srcScanLength;
                   long nxtSrcScan;
                   long n;
                   short m;
                   FAST short pxlCount;
                   unsigned char *pSrcInitBits;
                   unsigned char *pSaveSrcBits;
                   unsigned char *pSrcCurScan;
                   long deltaX;
                   long deltaY;
                   long curDstY;
                   long lastDstY;
                   long skipSrcBytes = 0;
                   NVCOORD wSrcExt;
                   NVCOORD wDstPoint;
                   unsigned long srcStrtX;
                   BYTE srcInVideoMemory = 0;
                   BYTE bufState = 0;
                   short skipV = 0;

//                   pSrcInitBits = (unsigned char *)src->fpVidMem;
//                   srcScanLength = src->lPitch;
                   pSrcInitBits = (unsigned char *)(dwSrcOffset + pDriverData->BaseAddress);
                   srcScanLength = dwSrcPitch;

                   if (dwSrcPitch <= 800)
                       m = 16;
                   else if (dwSrcPitch <= 1600)
                       m = 8;
                   else
                       m = 4;

                   while (freeCount < 8)
                       NvGetDmaBufferFreeCount(npDev, freeCount, 8, dmaPusherPutAddress);
                   freeCount -= 8;

                   dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
                       SET_ROP_OFFSET | 0x40000;
                   dmaPusherPutAddress[1] = dwRop;

                   dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                       SURFACES_2D_DEST_OFFSET | 0x40000;
                   dmaPusherPutAddress[3] = dwDstOffset;
                   dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                       SURFACES_2D_PITCH_OFFSET | 0x40000;
                   dmaPusherPutAddress[5] = (dwDstPitch << 16) | dwDstPitch;

                   dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000;
                   dmaPusherPutAddress[7] = NV_DD_STRETCHED_IMAGE_FROM_CPU;

                   dmaPusherPutAddress += 8;

                   /* calculate deltas in 12.20 format */

                   deltaX = dwDstWidth << 20;
                   deltaX /= dwSrcWidth;

                   if ((deltaX > 0x100000) && (deltaX & 0xFFFFF)) {
                       long xStretch = deltaX & 0xFFF00000;
                       deltaX = (dwDstWidth << 20) + xStretch;
                       deltaX /= dwSrcWidth;
                   }

                   if ((deltaX < 0x100000) && (deltaX & 0xFFFFF)) {
                       deltaX = (dwDstWidth << 20) + 0x100000;
                       deltaX /= dwSrcWidth;
                   }

                   deltaY = dwDstHeight << 20;
                   deltaY /= dwSrcHeight;

                   if ((deltaY > 0x100000) && (deltaY & 0xFFFFF)) {
                       long yStretch = deltaY & 0xFFF00000;
                       deltaY = (dwDstHeight << 20) + yStretch;
                       deltaY /= dwSrcHeight;
                   }

                   if ((deltaY < 0x100000) && (deltaY & 0xFFFFF)) {
                       deltaY = (dwDstHeight << 20) + 0x100000;
                       deltaY /= dwSrcHeight;
                   }

                   wSrcExt.wh16.w = (unsigned short)((dwSrcWidth + 1) & ~1);
                   wSrcExt.wh16.h = (unsigned short)dwSrcHeight;

                   n = (short)dwSrcHeight;

                   if (wSrcXY.xy16.y + n > src->wHeight)
                       n = src->wHeight - wSrcXY.xy16.y;

                   nxtSrcScan = srcScanLength;

                   if (doMirrorUpDown) {
                       wSrcXY.xy16.y += (n - 1);
                       nxtSrcScan = -nxtSrcScan;
                       skipSrcBytes = -skipSrcBytes;
                   }

                   if ((dwSrcCaps & DDSCAPS_VIDEOMEMORY) &&
                       ((dwSrcCaps & DDSCAPS_TEXTURE) == 0) &&
                       ((src->fpVidMem >= pDriverData->BaseAddress) || isOverlappingVmem)) {
                       srcInVideoMemory = 1;
                   } else {
                       pSaveSrcBits = (unsigned char *)(pSrcInitBits +
                                      (wSrcXY.xy16.y * srcScanLength));
                       pSaveSrcBits += (wSrcXY.xy16.x << 1);
                       pSrcCurScan = pSaveSrcBits;
                   }

                   if (srcInVideoMemory) {
                       pDmaBufferNotifier = (NvNotification *)pDriverData->NvDmaBufferNotifierFlat;
                       pDmaBufferNotifier++;
                       pScanlineBuffer = (unsigned char *)pDriverData->NvScanlineBufferFlat;

                       wSrcExt.wh16.w = (unsigned short)((dwSrcWidth + 1) & ~1);
                       wSrcExt.wh16.h = m;

                       srcStrtX = wSrcXY.xy16.x;

                       while (freeCount < 2)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
                       freeCount -= 2;

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) | 0x40000;
                       dmaPusherPutAddress[1] = NV_DD_VIDEO_MEMORY_TO_SYSTEM_MEMORY_FORMAT;

                       dmaPusherPutAddress += 2;

                       // wait for any pending notification operation to finish
                       while ((volatile)pDmaBufferNotifier->status == NV_IN_PROGRESS);

                       pDmaBufferNotifier->status = NV_IN_PROGRESS;

                       while (freeCount < 9)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 9, dmaPusherPutAddress);
                       freeCount -= 9;

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                           MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000;

                       dmaPusherPutAddress[1] = dwSrcOffset +
                           ((dwSrcPitch + skipSrcBytes) * (unsigned long)wSrcXY.xy16.y) +
                           ((unsigned long)wSrcXY.xy16.x << 1);

                       dmaPusherPutAddress[2] = NV_DD_NOTIFIER_BLOCK_SIZE + (srcStrtX << 1);

                       dmaPusherPutAddress[3] = (dwSrcPitch + skipSrcBytes);

                       dmaPusherPutAddress[4] = dwSrcPitch;

                       dmaPusherPutAddress[5] = (unsigned long)(wSrcExt.wh16.w << 1);

                       dmaPusherPutAddress[6] = m;

                       dmaPusherPutAddress[7] = (1 << 8) | 1;

                       dmaPusherPutAddress[8] = 0;

                       dmaPusherPutAddress += 9;

                       /* Force write combine buffer to flush */
                       pDriverData->NvDmaPusherBufferEnd[0] = 0;
                       /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                       _outp (0x3d0,0);

                       pDriverData->dwDmaPusherFreeCount = freeCount;

                       npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                       // wait for Dma operation to finish
                       while ((volatile)pDmaBufferNotifier->status == NV_IN_PROGRESS);

                       if (doMirrorUpDown)
                           wSrcXY.xy16.y -= (m + skipV);
                       else
                           wSrcXY.xy16.y += (m + skipV);
                   }

                   /* Convert to 12.4 format */
                   wDstPoint.xy16.x = (wDestXY.xy16.x << 4);
                   wDstPoint.xy16.y = (wDestXY.xy16.y << 4);

                   /* convert to 16.16 */
                   lastDstY = (long)(wDestXY.xy16.y + wXYext.wh16.h) << 16;

                   /* convert to 16.16 */
                   curDstY = (long)(wDestXY.xy16.y << 16);

                   while (freeCount < 7)
                       NvGetDmaBufferFreeCount(npDev, freeCount, 7, dmaPusherPutAddress);
                   freeCount -= 7;

                   dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                       STRETCHED_IMAGE_SIZE_IN_OFFSET | 0x180000;
                   dmaPusherPutAddress[1] = wSrcExt.wh;
                   dmaPusherPutAddress[2] = deltaX;
                   dmaPusherPutAddress[3] = deltaY;
                   dmaPusherPutAddress[4] = wDestXY.xy;
                   dmaPusherPutAddress[5] = wXYext.wh;
                   dmaPusherPutAddress[6] = wDstPoint.xy;

                   dmaPusherPutAddress += 7;

                   while ((n > 0) && (curDstY < lastDstY)) {
                       FAST unsigned long *pSrcBits;
                       FAST unsigned long tmpPxls0, tmpPxls1, tmpPxls2;

                       if (srcInVideoMemory) {
                           if (bufState == 0)
                               pSrcBits = (unsigned long *)(pScanlineBuffer +
                                   (srcStrtX << 1));
                           else
                               pSrcBits = (unsigned long *)(pScanlineBuffer +
                                   (NV_DD_COMMON_DMA_BUFFER_SIZE >> 1) +
                                   (srcStrtX << 1));

                           pSrcCurScan = (unsigned char *)pSrcBits;

                           if (m > 0) {
                               pDmaBufferNotifier->status = NV_IN_PROGRESS;

                               while (freeCount < 9)
                                   NvGetDmaBufferFreeCount(npDev, freeCount, 9, dmaPusherPutAddress);
                               freeCount -= 9;

                               dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                                   MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000;

                               dmaPusherPutAddress[1] = dwSrcOffset +
                                   ((dwSrcPitch + skipSrcBytes) * (unsigned long)wSrcXY.xy16.y) +
                                   ((unsigned long)wSrcXY.xy16.x << 1);

                               if (bufState == 0)
                                   dmaPusherPutAddress[2] =
                                       NV_DD_NOTIFIER_BLOCK_SIZE +
                                       (NV_DD_COMMON_DMA_BUFFER_SIZE >> 1) +
                                       (srcStrtX << 1);
                               else
                                   dmaPusherPutAddress[2] =
                                       NV_DD_NOTIFIER_BLOCK_SIZE +
                                       (srcStrtX << 1);

                               dmaPusherPutAddress[3] = (dwSrcPitch + skipSrcBytes);

                               dmaPusherPutAddress[4] = dwSrcPitch;

                               dmaPusherPutAddress[5] = (unsigned long)(wSrcExt.wh16.w << 1);

                               dmaPusherPutAddress[6] = m;

                               dmaPusherPutAddress[7] = (1 << 8) | 1;

                               dmaPusherPutAddress[8] = 0;

                               dmaPusherPutAddress += 9;

                               /* Force write combine buffer to flush */
                               pDriverData->NvDmaPusherBufferEnd[0] = 0;
                               /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                               _outp (0x3d0,0);

                               pDriverData->dwDmaPusherFreeCount = freeCount;

                               npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                               bufState ^= 1;

                               if (doMirrorUpDown)
                                   wSrcXY.xy16.y -= (m + skipV);
                               else
                                   wSrcXY.xy16.y += (m + skipV);

                               while (freeCount < 7)
                                   NvGetDmaBufferFreeCount(npDev, freeCount, 7, dmaPusherPutAddress);
                               freeCount -= 7;

                               dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                                   STRETCHED_IMAGE_SIZE_IN_OFFSET | 0x180000;

                               dmaPusherPutAddress[1] = wSrcExt.wh;

                               dmaPusherPutAddress[2] = deltaX;

                               dmaPusherPutAddress[3] = deltaY;

                               dmaPusherPutAddress[4] = wDestXY.xy;

                               dmaPusherPutAddress[5] = wXYext.wh;

                               dmaPusherPutAddress[6] = wDstPoint.xy;

                               dmaPusherPutAddress += 7;

                               /* Force write combine buffer to flush */
                               pDriverData->NvDmaPusherBufferEnd[0] = 0;
                               /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                               _outp (0x3d0,0);

                               pDriverData->dwDmaPusherFreeCount = freeCount;

                               npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;
                           }
                       } else { // source in system memory
                           pSrcBits = (unsigned long *)pSrcCurScan;
                           pSrcCurScan += (nxtSrcScan + skipSrcBytes);
                           n--;
                       }

doNxtSrcScan:          pxlCount = (short)((dwSrcWidth + 1) & ~1);

                       if (pxlCount < (1792 << 1)) {

                           // Get enough room for this scanline
                           while (freeCount < (1 + (pxlCount >> 1)))
                               NvGetDmaBufferFreeCount(npDev, freeCount, (1 + (pxlCount >> 1)), dmaPusherPutAddress);
                           freeCount -= (1 + (pxlCount >> 1));

                           dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                               STRETCHED_IMAGE_COLOR_OFFSET | (pxlCount << 17);

                           dmaPusherPutAddress += 1;

                           while (pxlCount >= 32) {

                               pxlCount -= 32;

                               tmpPxls0 = pSrcBits[0];
                               tmpPxls1 = pSrcBits[1];
                               dmaPusherPutAddress[0] = tmpPxls0;
                               tmpPxls2 = pSrcBits[2];
                               dmaPusherPutAddress[1] = tmpPxls1;
                               tmpPxls0 = pSrcBits[3];
                               tmpPxls1 = pSrcBits[4];
                               dmaPusherPutAddress[2] = tmpPxls2;
                               dmaPusherPutAddress[3] = tmpPxls0;
                               tmpPxls2 = pSrcBits[5];
                               tmpPxls0 = pSrcBits[6];
                               dmaPusherPutAddress[4] = tmpPxls1;
                               dmaPusherPutAddress[5] = tmpPxls2;
                               tmpPxls1 = pSrcBits[7];
                               tmpPxls2 = pSrcBits[8];
                               dmaPusherPutAddress[6] = tmpPxls0;
                               dmaPusherPutAddress[7] = tmpPxls1;
                               tmpPxls0 = pSrcBits[9];
                               tmpPxls1 = pSrcBits[10];
                               dmaPusherPutAddress[8] = tmpPxls2;
                               dmaPusherPutAddress[9] = tmpPxls0;
                               tmpPxls2 = pSrcBits[11];
                               tmpPxls0 = pSrcBits[12];
                               dmaPusherPutAddress[10] = tmpPxls1;
                               dmaPusherPutAddress[11] = tmpPxls2;
                               tmpPxls1 = pSrcBits[13];
                               tmpPxls2 = pSrcBits[14];
                               dmaPusherPutAddress[12] = tmpPxls0;
                               dmaPusherPutAddress[13] = tmpPxls1;
                               tmpPxls0 = pSrcBits[15];
                               dmaPusherPutAddress[14] = tmpPxls2;
                               pSrcBits += 16;
                               dmaPusherPutAddress[15] = tmpPxls0;

                               dmaPusherPutAddress += 16;
                           }

                           while (pxlCount >= 16) {

                               pxlCount -= 16;

                               tmpPxls0 = pSrcBits[0];
                               tmpPxls1 = pSrcBits[1];
                               dmaPusherPutAddress[0] = tmpPxls0;
                               tmpPxls2 = pSrcBits[2];
                               dmaPusherPutAddress[1] = tmpPxls1;
                               tmpPxls0 = pSrcBits[3];
                               tmpPxls1 = pSrcBits[4];
                               dmaPusherPutAddress[2] = tmpPxls2;
                               dmaPusherPutAddress[3] = tmpPxls0;
                               tmpPxls2 = pSrcBits[5];
                               tmpPxls0 = pSrcBits[6];
                               dmaPusherPutAddress[4] = tmpPxls1;
                               dmaPusherPutAddress[5] = tmpPxls2;
                               tmpPxls1 = pSrcBits[7];
                               pSrcBits += 8;
                               dmaPusherPutAddress[6] = tmpPxls0;
                               dmaPusherPutAddress[7] = tmpPxls1;

                               dmaPusherPutAddress += 8;
                           }

                           while (pxlCount >= 2) {
                               pxlCount -= 2;
                               tmpPxls0 = pSrcBits[0];
                               pSrcBits += 1;
                               dmaPusherPutAddress[0] = tmpPxls0;

                               dmaPusherPutAddress += 1;
                           }

                       } else { /* more than 1792 dwords per scanline */

                           while (pxlCount >= 32) {

                               pxlCount -= 32;

                               while (freeCount < (1 + (32 >> 1)))
                                   NvGetDmaBufferFreeCount(npDev, freeCount, (1 + (32 >> 1)), dmaPusherPutAddress);
                               freeCount -= (1 + (32 >> 1));

                               dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                                   STRETCHED_IMAGE_COLOR_OFFSET | (32 << 17);

                               dmaPusherPutAddress += 1;

                               tmpPxls0 = pSrcBits[0];
                               tmpPxls1 = pSrcBits[1];
                               dmaPusherPutAddress[0] = tmpPxls0;
                               tmpPxls2 = pSrcBits[2];
                               dmaPusherPutAddress[1] = tmpPxls1;
                               tmpPxls0 = pSrcBits[3];
                               tmpPxls1 = pSrcBits[4];
                               dmaPusherPutAddress[2] = tmpPxls2;
                               dmaPusherPutAddress[3] = tmpPxls0;
                               tmpPxls2 = pSrcBits[5];
                               tmpPxls0 = pSrcBits[6];
                               dmaPusherPutAddress[4] = tmpPxls1;
                               dmaPusherPutAddress[5] = tmpPxls2;
                               tmpPxls1 = pSrcBits[7];
                               tmpPxls2 = pSrcBits[8];
                               dmaPusherPutAddress[6] = tmpPxls0;
                               dmaPusherPutAddress[7] = tmpPxls1;
                               tmpPxls0 = pSrcBits[9];
                               tmpPxls1 = pSrcBits[10];
                               dmaPusherPutAddress[8] = tmpPxls2;
                               dmaPusherPutAddress[9] = tmpPxls0;
                               tmpPxls2 = pSrcBits[11];
                               tmpPxls0 = pSrcBits[12];
                               dmaPusherPutAddress[10] = tmpPxls1;
                               dmaPusherPutAddress[11] = tmpPxls2;
                               tmpPxls1 = pSrcBits[13];
                               tmpPxls2 = pSrcBits[14];
                               dmaPusherPutAddress[12] = tmpPxls0;
                               dmaPusherPutAddress[13] = tmpPxls1;
                               tmpPxls0 = pSrcBits[15];
                               dmaPusherPutAddress[14] = tmpPxls2;
                               pSrcBits += 16;
                               dmaPusherPutAddress[15] = tmpPxls0;

                               dmaPusherPutAddress += 16;
                           }

                           while (pxlCount >= 16) {

                               pxlCount -= 16;

                               while (freeCount < (1 + (16 >> 1)))
                                   NvGetDmaBufferFreeCount(npDev, freeCount, (1 + (16 >> 1)), dmaPusherPutAddress);
                               freeCount -= (1 + (16 >> 1));

                               dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                                   STRETCHED_IMAGE_COLOR_OFFSET | (16 << 17);

                               dmaPusherPutAddress += 1;

                               tmpPxls0 = pSrcBits[0];
                               tmpPxls1 = pSrcBits[1];
                               dmaPusherPutAddress[0] = tmpPxls0;
                               tmpPxls2 = pSrcBits[2];
                               dmaPusherPutAddress[1] = tmpPxls1;
                               tmpPxls0 = pSrcBits[3];
                               tmpPxls1 = pSrcBits[4];
                               dmaPusherPutAddress[2] = tmpPxls2;
                               dmaPusherPutAddress[3] = tmpPxls0;
                               tmpPxls2 = pSrcBits[5];
                               tmpPxls0 = pSrcBits[6];
                               dmaPusherPutAddress[4] = tmpPxls1;
                               dmaPusherPutAddress[5] = tmpPxls2;
                               tmpPxls1 = pSrcBits[7];
                               pSrcBits += 8;
                               dmaPusherPutAddress[6] = tmpPxls0;
                               dmaPusherPutAddress[7] = tmpPxls1;

                               dmaPusherPutAddress += 8;
                           }

                           if (pxlCount >= 2) {
                               while (freeCount < (1 + (pxlCount >> 1)))
                                   NvGetDmaBufferFreeCount(npDev, freeCount, (1 + (pxlCount >> 1)), dmaPusherPutAddress);
                               freeCount -= (1 + (pxlCount >> 1));

                               dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                                   STRETCHED_IMAGE_COLOR_OFFSET | (pxlCount << 17);

                               dmaPusherPutAddress++;
                           }

                           while (pxlCount >= 2) {
                               pxlCount -= 2;
                               tmpPxls0 = pSrcBits[0];
                               pSrcBits += 1;
                               dmaPusherPutAddress[0] = tmpPxls0;

                               dmaPusherPutAddress++;
                           }
                       }

                       /* Force write combine buffer to flush */
                       pDriverData->NvDmaPusherBufferEnd[0] = 0;
                       /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                       _outp (0x3d0,0);

                       pDriverData->dwDmaPusherFreeCount = freeCount;

                       npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                       if (srcInVideoMemory) {
                           if (--m > 0) {
                               pSrcCurScan += dwSrcPitch;

                               pSrcBits = (unsigned long *)pSrcCurScan;

                               goto doNxtSrcScan;
                           } else {
                               if (dwSrcPitch <= 800) {
                                   m = 16;
                                   curDstY += deltaY;
                               } else if (dwSrcPitch <= 1600) {
                                   m = 8;
                                   curDstY += (deltaY >> 1);
                               } else {
                                   m = 4;
                                   curDstY += (deltaY >> 2);
                               }
                                                   /* convert 16.16 to 12.4 */
                               wDstPoint.xy16.y = (short)(curDstY >> 12);

                               // wait for DMA operation to finish
                               while ((volatile)pDmaBufferNotifier->status == NV_IN_PROGRESS);
                           }
                       }
                   }

                   if (srcInVideoMemory) {

                       while (freeCount < 2)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
                       freeCount -= 2;

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) | 0x40000;
                       dmaPusherPutAddress[1] = NV_DD_IMAGE_FROM_CPU;

                       dmaPusherPutAddress += 2;
                   }

                   /* restore default object */
                   while (freeCount < 2)
                       NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
                   freeCount -= 2;

                   dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000;
                   dmaPusherPutAddress[1] = NV_DD_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY;

                   dmaPusherPutAddress += 2;

               } else { // OK to use SCALED IMAGE
                   NvNotification *pDmaDmaFromMemNotifier;
                   unsigned char *pScanlineBuffer;
                   unsigned char *npPixelBuf;
                   long srcScanLength;
                   long nxtSrcScan;
                   unsigned long n;
                   unsigned char *pSrcInitBits;
                   unsigned char *pSaveSrcInitBits;
                   unsigned short *pSaveSrcBits;
                   unsigned short *pSrcCurScan;
                   long srcDeltaX;
                   long srcDeltaY;
                   long skipDeltaY = 0;
                   unsigned long dstDeltaScans;
                   unsigned long dstDeltaX;
                   long dstDeltaY;
                   long srcInitFract;
                   long srcStartFract;
                   long srcStartY;
                   long srcCurFract;
                   long srcCurY;
                   long srcDeltaYPerBand;
                   long srcDeltaScans;
                   long srcCurDeltaScans;
                   long xStretch;
                   long yStretch;
                   long srcBufferPitch;
                   long skipSrcBytes = 0;
                   long dstStartY;
                   long dstCurY;
                   long curV;
                   long skipV = 0;
                   long m;
                   NVCOORD wSrcPoint;
                   NVCOORD wSrcExt;
                   NVCOORD wDstPoint;
                   NVCOORD wDstExt;
                   BYTE srcInVideoMemory = 0;
                   BYTE srcTooWide = 0;
                   short curBuffer;
//// These are for working around NV4 scaled image bug
                   DWORD scaledImageObjectID = NV_DD_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY;
                   DWORD curClipPoint;
                   DWORD curClipExtent;
                   DWORD curDUDX;
                   DWORD curDVDY;
//// End of NV4 workaround variables

//                   pSrcInitBits = (unsigned char *)src->fpVidMem;
//                   srcScanLength = src->lPitch;
                   pSrcInitBits = (unsigned char *)(dwSrcOffset + pDriverData->BaseAddress);
                   srcScanLength = dwSrcPitch;

                   while (freeCount < 6)
                       NvGetDmaBufferFreeCount(npDev, freeCount, 6, dmaPusherPutAddress);
                   freeCount -= 6;

                   dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
                       SET_ROP_OFFSET | 0x40000;
                   dmaPusherPutAddress[1] = dwRop;

                   dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                       SURFACES_2D_DEST_OFFSET | 0x40000;
                   dmaPusherPutAddress[3] = dwDstOffset;
                   dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                       SURFACES_2D_PITCH_OFFSET | 0x40000;
                   dmaPusherPutAddress[5] = (dwDstPitch << 16) | dwDstPitch;

                   dmaPusherPutAddress += 6;

                   pDriverData->dwDmaPusherFreeCount = freeCount;

                   /* Just in case we return unexpectedly */
                   pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

                   srcBufferPitch = ((dwSrcWidth << 1) + 3) & ~3L;

                   srcDeltaScans = (NV_DD_COMMON_DMA_BUFFER_SIZE >> 1) -   /* allow for 2 extra src scanlines */
                            NV_DD_NOTIFIER_BLOCK_SIZE - (srcBufferPitch << 1); /* buffer contains several separate notifiers */

                   srcDeltaScans /= srcBufferPitch;

                   /* Limiting source scans per DMA increases parallelism */
                   if (srcDeltaScans > 32)
                       srcDeltaScans = 32;
                   else if (srcDeltaScans > 16)
                       srcDeltaScans = 16;
                   else if (srcDeltaScans > 8)
                       srcDeltaScans = 8;
                   else if (srcDeltaScans > 4)
                       srcDeltaScans = 4;
                   else
                       srcDeltaScans = 2;

                   /* Check for divide by 0 */
                   if ((dwDstWidth < 1) || (dwDstHeight < 1)) {
                       pbd->ddRVal = DDERR_INVALIDRECT;
                       return DDHAL_DRIVER_HANDLED;
                   }

                   /* Check if within NV hardware supported range */
                   if ((dwDstWidth > 2047) || (dwDstHeight > 2047)) {
                       return DDHAL_DRIVER_NOTHANDLED;
                   }

                   srcDeltaX = dwSrcWidth << 20;
                   srcDeltaX /= dwDstWidth;

                   /*
                    * This fudge factor prevents us from running out of source pixels
                    * when the source starting position is fractional resulting in
                    * a true final width of dwSrcWidth - fraction. Unfortunately
                    * this fudge factor also causes problems when it is important
                    * to end on exactly the right source pixel.  The uglier of the 2 cases
                    * is to run out of source pixels so I opted to leave the fudge
                    * factor in. It works by enlarging the destination by a factor
                    * equivalent to 1 source pixel resulting in slightly enlarging
                    * the stretch factor on each source pixel.
                    */

                   if (srcDeltaX < 0x100000) {
                       xStretch = 0x40000000 / (srcDeltaX >> 10);
                       xStretch >>= 20;
                       srcDeltaX = dwSrcWidth << 20;
                       srcDeltaX /= (dwDstWidth + xStretch);
                   }

                   srcDeltaY = dwSrcHeight << 20;
                   srcDeltaY /= dwDstHeight;

                   /* Algorithm can't handle a scale factor that is too large */
                   if (srcDeltaY > 0x40000000) {
                       pbd->ddRVal = DDERR_INVALIDRECT;
                       return DDHAL_DRIVER_HANDLED;
                   }

                   /* If shrinking in vertical direction then adjust to skip src scanlines */
                   if (srcDeltaY >= (srcDeltaScans << 20)) { /* limit Y delta range to acceptable range */
                       skipDeltaY = srcDeltaY;
                       skipSrcBytes = srcScanLength;
                       skipV = 1;
                       while (srcDeltaY >= (srcDeltaScans << 20)) {
                           srcDeltaY >>= 1;
                           skipSrcBytes <<= 1;
                           skipV <<= 1;
                           skipDeltaY <<= 1;
                       }
                       skipSrcBytes -= srcScanLength;
                       skipV -= 1;
                       skipDeltaY -= srcDeltaY;
                   }

                   /* Algorithm can't handle scale factor that is too small */
                   if ((srcDeltaY & 0xFFFFFC00) == 0) {
                       pbd->ddRVal = DDERR_INVALIDRECT;
                       return DDHAL_DRIVER_HANDLED;
                   }

                   yStretch = 0x40000000 / ((srcDeltaY + 0x00000200) >> 10);

                   dstDeltaY = srcDeltaScans * yStretch;  // how many dst scanlines will srcDeltaScans scanlines generate

                   dstDeltaScans = dstDeltaY >> 20;

                   if (dstDeltaScans == 0) { /* if shrinking too much then can't handle */
                       return DDHAL_DRIVER_NOTHANDLED;
                   }

                   if (wSrcXY.xy16.y + dwSrcHeight > src->wHeight)
                       dwSrcHeight = src->wHeight - wSrcXY.xy16.y;

                   nxtSrcScan = (srcScanLength >> 1);

                   srcDeltaYPerBand = dstDeltaScans * (srcDeltaY + skipDeltaY);

                   if (doMirrorUpDown) {
                       wSrcXY.xy16.y += (short)(dwSrcHeight - 1);
                       srcDeltaY =- srcDeltaY;
                       srcDeltaYPerBand = -srcDeltaYPerBand;
                       skipDeltaY = -skipDeltaY;
                       nxtSrcScan = -nxtSrcScan;
                       skipSrcBytes = -skipSrcBytes;
                   }

                   pDmaDmaFromMemNotifier = (NvNotification *)pDriverData->NvDmaDmaFromMemNotifierFlat;
                   pScanlineBuffer = (unsigned char *)pDriverData->NvScanlineBufferFlat;

                   if (srcDeltaY > 0)
                       srcCurY = 0;
                   else
                       srcCurY = ((long)dwSrcHeight << 20);

                   wSrcPoint.xy = 0;

                   /* Calculate initial source fractional X */
                   if ((srcDeltaX > 0x40000000) || ((srcDeltaX & 0xFFFFFC00) == 0)) {
                       pbd->ddRVal = DDERR_INVALIDRECT;
                       return DDHAL_DRIVER_HANDLED;
                   }

                   /* Do this math in 16.16 precision to avoid 12. overflow */
                   dstDeltaX = ((long)wSrcXY.xy16.x << 16) / (srcDeltaX >> 4);

                   /* Do this math in 16.16 precision to avoid 12. overflow */
                   srcInitFract = dstDeltaX * (srcDeltaX >> 4);

                   /* Do this math in 16.16 precision to avoid 12. overflow */
                   while (srcInitFract >> 16 < wSrcXY.xy16.x)
                       srcInitFract += (srcDeltaX >> 4);

                   /* Convert to 12.4 format */
                   wSrcPoint.xy16.x = (short)((srcInitFract & 0xFFFF) >> 12);

                        // DMAable ?
                   if ((isVideo > 3) || ((dwSrcCaps & DDSCAPS_VIDEOMEMORY) &&
                       ((dwSrcCaps & DDSCAPS_TEXTURE) == 0) &&
                       ((src->fpVidMem >= pDriverData->BaseAddress) || isOverlappingVmem))) {

                       srcInitFract = 0;

                       if (srcDeltaY > 0) {
                           /* Calculate initial source fractional Y */
                           /* Do this math in 16.16 precision to avoid 12. overflow */
                           dstDeltaY = ((long)wSrcXY.xy16.y << 16) / (srcDeltaY  >> 4);

                           /* Do this math in 16.16 precision to avoid 12. overflow */
                           srcInitFract = dstDeltaY * (srcDeltaY >> 4);

                           /* Do this math in 16.16 precision to avoid 12. overflow */
                           while (srcInitFract >> 16 < wSrcXY.xy16.y)
                               srcInitFract += (srcDeltaY >> 4);

                           /* Convert result back to 12.20 precision */
                           srcInitFract <<= 4;

                           srcInitFract &= 0xFFFFF;
                       }

                       srcCurY += srcInitFract;

                       srcCurFract = srcInitFract;

                       if (isVideo < 4) {
                           srcInVideoMemory = 1;

                           if (doMirrorUpDown) {
                               pSaveSrcBits = (unsigned short *)
                                  (pSrcInitBits - pDriverData->BaseAddress);
                               wSrcPoint.xy16.y += ((short)(dwSrcHeight - 1) << 4);
                           } else {
                               wSrcPoint.xy16.y += (short)(srcCurFract >> 16);

                               pSaveSrcBits = (unsigned short *)
                                  ((pSrcInitBits - pDriverData->BaseAddress) +
                                   (wSrcXY.xy16.y * srcScanLength));
                           }

                       } else { // source is in DMAable system memory

                           if (doMirrorUpDown) {
                               pSaveSrcBits = 0;
                               wSrcPoint.xy16.y += ((short)(dwSrcHeight - 1) << 4);
                           } else {
                               wSrcPoint.xy16.y += (short)(srcCurFract >> 16);

                               pSaveSrcBits = (unsigned short *)
                                  (wSrcXY.xy16.y * srcScanLength);
                           }
                       }

                       pSaveSrcBits += wSrcXY.xy16.x;

                       while (freeCount < 2)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
                       freeCount -= 2;

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000;

                       if (isVideo < 2)
                           scaledImageObjectID = NV_DD_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY;
                       else if (isVideo == 2)
                           scaledImageObjectID = NV_DD_SCALED_UYVY_IMAGE_FROM_VIDEO_MEMORY;
                       else if (isVideo == 3)
                           scaledImageObjectID = NV_DD_SCALED_YUYV_IMAGE_FROM_VIDEO_MEMORY;
                       else if (isVideo == 4)
                           scaledImageObjectID = NV_DD_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
                       else if (isVideo == 5)
                           scaledImageObjectID = NV_DD_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
                       else if (isVideo == 6)
                           scaledImageObjectID = NV_DD_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
                       else if (isVideo == 7)
                           scaledImageObjectID = NV_DD_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;

                       dmaPusherPutAddress[1] = scaledImageObjectID;

                       dmaPusherPutAddress += 2;

                   } else {
                       pSaveSrcBits = (unsigned short *)(pSrcInitBits +
                           (wSrcXY.xy16.y * srcScanLength));
                       pSaveSrcBits += wSrcXY.xy16.x;
                       pSrcCurScan = pSaveSrcBits;

                       while (freeCount < 2)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
                       freeCount -= 2;

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000;

                       if (isVideo == 2)
                           scaledImageObjectID = NV_DD_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
                       else if (isVideo == 3)
                           scaledImageObjectID = NV_DD_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;

                       /* NOTE: This may load the default scaledImageObjectID */
                       dmaPusherPutAddress[1] = scaledImageObjectID;

                       dmaPusherPutAddress += 2;
                   }

                   pSaveSrcInitBits = (unsigned char *)pSaveSrcBits;

                   curClipPoint = wDestXY.xy;
                   curClipExtent = wXYext.wh;
                   curDUDX = srcDeltaX;
                   if (srcDeltaY > 0)
                       curDVDY = srcDeltaY;
                   else
                       curDVDY = -srcDeltaY;

                   while (freeCount < 6)
                       NvGetDmaBufferFreeCount(npDev, freeCount, 6, dmaPusherPutAddress);
                   freeCount -= 6;

                   dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                       SCALED_IMAGE_CLIPPOINT_OFFSET | 0x80000;
                   dmaPusherPutAddress[1] = curClipPoint;
                   dmaPusherPutAddress[2] = curClipExtent;
                   dmaPusherPutAddress[3] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                       SCALED_IMAGE_DELTADUDX_OFFSET | 0x80000;
                   dmaPusherPutAddress[4] = curDUDX;
                   dmaPusherPutAddress[5] = curDVDY;

                   dmaPusherPutAddress += 6;

                   wDstExt.wh = wXYext.wh;

                   /* NV4 Scaled Image class requires source width to be even */
                   dwSrcWidth = (dwSrcWidth + 1) & ~1;

                   /* NV3 hardware can only handle a maximum source width of 1024 */
                   if (dwSrcWidth > 1024) {
                       srcTooWide = 1;
                       xStretch = 0x40000000 / (srcDeltaX >> 10);
                       dstDeltaX = (xStretch * 1024) >> 20;
                       wDstExt.wh16.w = (unsigned short)dstDeltaX;
                       srcBufferPitch = 2048;
                   }

                   // Let the world know we are doing DMA operations
//                   pDriverData->NvDmaFromMemSurfaceMem = src->fpVidMem;
                   pDriverData->NvDmaFromMemSurfaceMem = dwSrcOffset + pDriverData->BaseAddress;

oneMorePass:       n = dwDstHeight;

                   srcCurY &= 0xFFF00000;

                   srcInitFract = 0;

                   if (srcDeltaY > 0) {
                       /* Calculate initial source fractional Y */
                       /* Do this math in 16.16 precision to avoid 12. overflow */
                       dstDeltaY = ((long)wSrcXY.xy16.y << 16) / (srcDeltaY  >> 4);

                       /* Do this math in 16.16 precision to avoid 12. overflow */
                       srcInitFract = dstDeltaY * (srcDeltaY >> 4);

                       /* Do this math in 16.16 precision to avoid 12. overflow */
                       while (srcInitFract >> 16 < wSrcXY.xy16.y)
                           srcInitFract += (srcDeltaY >> 4);

                       /* Convert result back to 12.20 precision */
                       srcInitFract <<= 4;

                       srcInitFract &= 0xFFFFF;
                   }

                   srcCurY += srcInitFract;

                   srcCurFract = srcInitFract;

                   curV = srcCurY >> 20;

                   wDstPoint.xy = wDestXY.xy;

                   dstStartY = dstCurY = wDestXY.xy16.y;

                   curBuffer = 0;

                   if ((srcInVideoMemory) || (isVideo > 3)) { // DMAable ?

                       // wait for any pending notification operation to finish
// should not be necessary   while ((volatile)pDmaDmaFromMemNotifier->status == NV_IN_PROGRESS);

                       pDmaDmaFromMemNotifier->status = NV_IN_PROGRESS;

                       while (freeCount < 11)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
                       freeCount -= 11;

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_IMAGE_OUT_POINT_OFFSET | 0x80000;
                       dmaPusherPutAddress[1] = wDstPoint.xy;
                       dmaPusherPutAddress[2] = wDstExt.wh;
                       dmaPusherPutAddress[3] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_IMAGE_IN_SIZE_OFFSET | 0xC0000;

                       if ((dwSrcWidth < 16) && (isVideo < 4)) { // workaround for NV3 Rev B hardware bug (only happens if source is in video memory)
                           dmaPusherPutAddress[4] =
                               asmMergeCoords(dwSrcPitch, dwSrcHeight);
                       } else {
                           dmaPusherPutAddress[4] =
                               asmMergeCoords(dwSrcWidth, dwSrcHeight);
                       }

                       dmaPusherPutAddress[5] =
                           (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24) |
                           (NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16) |
                           dwSrcPitch;

                       dmaPusherPutAddress[6] = (unsigned long)pSaveSrcBits;

                       dmaPusherPutAddress[7] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_NOTIFY_OFFSET | 0x40000;
                       dmaPusherPutAddress[8] = 0;
                       dmaPusherPutAddress[9] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_IMAGE_IN_POINT_OFFSET | 0x40000;
                       dmaPusherPutAddress[10] = wSrcPoint.xy;

                       dmaPusherPutAddress += 11;

                       /* Force write combine buffer to flush */
                       pDriverData->NvDmaPusherBufferEnd[0] = 0;
                       /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                       _outp (0x3d0,0);

                       pDriverData->dwDmaPusherFreeCount = freeCount;

                       npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                       n = 0;
                   } else {
                       // wait for any pending notification operation to finish
                       while ((volatile)pDmaDmaFromMemNotifier->status == NV_IN_PROGRESS);
                   }

                   while (n >= dstDeltaScans) {
                       FAST unsigned long *pSrcBits;

                       n -= dstDeltaScans;
                       srcStartY = srcCurY;
                       srcStartFract = srcCurFract;
                       srcCurY += srcDeltaYPerBand;

                       if (doMirrorUpDown) {
                           if (((srcCurY - 0x100000) >> 20) < 0)
                               srcCurY = 0x100000;
                       } else {
                           if (((srcCurY + 0x100000) >> 20) >  ((long)dwSrcHeight - 1))
                               srcCurY = ((long)dwSrcHeight - 2) << 20;
                       }

                       srcCurFract = srcCurY & 0xFFFFF;

                       if (curBuffer == 0)
                           npPixelBuf = (unsigned char *)pScanlineBuffer;
                       else
                           npPixelBuf = (unsigned char *)(pScanlineBuffer +
                               (NV_DD_COMMON_DMA_BUFFER_SIZE >> 1));

                       /* Must recalculate on each pass since src scanlines may be used more than once */
                       pSrcBits = (unsigned long *)(pSaveSrcInitBits +
                                  (curV * (nxtSrcScan << 1)));
                       pSrcCurScan = (unsigned short *)pSrcBits;

                       if (doMirrorUpDown)
                           m = (srcStartY >> 20) - ((srcCurY - 0x100000) >> 20);
                       else
                           m = ((srcCurY + 0x100000) >> 20) - (srcStartY >> 20);

                       srcCurDeltaScans = 0;

                       /* Copy and convert a block of source pixels to transfer buffer */
                       while (--m >= 0) {

                           if (pSrcBits >= (unsigned long *)pSrcInitBits) {
  //                           asmCopyScan(pSrcBits, npPixelBuf, srcBufferPitch);
                               _asm
                               {
#ifdef P6
                                   mov ecx, dword ptr srcBufferPitch
                                   mov esi, dword ptr pSrcBits
                                   shr ecx, 5
                    nxtCacheLine2: mov eax, [esi]
                                   add esi, 32
                                   dec ecx
                                   jg nxtCacheLine2
#endif /* P6 */
                                   mov ecx, dword ptr srcBufferPitch
                                   mov esi, dword ptr pSrcBits
                                   shr ecx, 2
                                   mov edi, dword ptr npPixelBuf
                                   test ecx, 1
                                   jz doQwords2
                                   mov eax, [esi]
                                   add esi, 4
                                   mov [edi], eax
                                   add edi, 4
                        doQwords2: shr ecx, 1
                                   jz copyDone2
#ifdef MMX
                        nxtQword2: movq mm1, qword ptr [esi]
                                   add esi, 8
                                   movq qword ptr [edi], mm1
                                   add edi, 8
                                   dec ecx
#else /* MMX */
                        nxtQword2: mov eax, [esi]
                                   mov edx, [esi+4]
                                   add edi, 8
                                   add esi, 8
                                   dec ecx
                                   mov [edi-8], eax
                                   mov [edi-4], edx
#endif /* MMX */
                        copyDone2: jg nxtQword2
                               }
                           }
                           npPixelBuf += srcBufferPitch;
                           pSrcCurScan += (nxtSrcScan + skipSrcBytes);
                           pSrcBits = (unsigned long *)pSrcCurScan;
                           srcCurDeltaScans++;
                           m -= skipV;
                       }

                       /* wait for Dma operation to finish */
                       while (pDmaDmaFromMemNotifier->status == NV_IN_PROGRESS);

                       pDmaDmaFromMemNotifier->status = NV_IN_PROGRESS;

                       wDstPoint.xy16.y = (short)dstCurY;
                       wDstExt.wh16.h = (unsigned short)dstDeltaScans;
                       wSrcPoint.xy16.y = (short)(srcStartFract >> 16); /* convert V to 12.4 */
                       wSrcExt.wh = srcCurDeltaScans;
                       wSrcExt.wh <<= 16;    /* shift V extent into place */
                       wSrcExt.wh |= dwSrcWidth;

//// BEGIN WORKAROUND FOR NV4 SCALED IMAGE HARDWARE BUG

                       while (freeCount < 8)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 8, dmaPusherPutAddress);
                       freeCount -= 8;

                       /* Reload object */
                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000;
                       dmaPusherPutAddress[1] = scaledImageObjectID;
                       /* Reinitialize volatile methods */
                       dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_CLIPPOINT_OFFSET | 0x80000;
                       dmaPusherPutAddress[3] = curClipPoint;
                       dmaPusherPutAddress[4] = curClipExtent;
                       dmaPusherPutAddress[5] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_DELTADUDX_OFFSET | 0x80000;
                       dmaPusherPutAddress[6] = curDUDX;
                       dmaPusherPutAddress[7] = curDVDY;

                       dmaPusherPutAddress += 8;

//// END WORKAROUND FOR NV4 SCALED IMAGE HARDWARE BUG

                       while (freeCount < 11)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
                       freeCount -= 11;

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_IMAGE_OUT_POINT_OFFSET | 0x80000;
                       dmaPusherPutAddress[1] = wDstPoint.xy;
                       dmaPusherPutAddress[2] = wDstExt.wh;
                       dmaPusherPutAddress[3] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_IMAGE_IN_SIZE_OFFSET | 0xC0000;
                       dmaPusherPutAddress[4] = wSrcExt.wh;
                       dmaPusherPutAddress[5] =
                           (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24) |
                           (NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16) |
                           srcBufferPitch;

                       if (curBuffer == 0)
                           dmaPusherPutAddress[6] =
                               NV_DD_NOTIFIER_BLOCK_SIZE;  /* There are several notifiers in the buffer */
                       else
                           dmaPusherPutAddress[6] =
                               NV_DD_NOTIFIER_BLOCK_SIZE + (NV_DD_COMMON_DMA_BUFFER_SIZE >> 1);

                       dmaPusherPutAddress[7] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_NOTIFY_OFFSET | 0x40000;
                       dmaPusherPutAddress[8] = 0;
                       dmaPusherPutAddress[9] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_IMAGE_IN_POINT_OFFSET | 0x40000;
                       dmaPusherPutAddress[10] = wSrcPoint.xy;

                       dmaPusherPutAddress += 11;

                       /* Force write combine buffer to flush */
                       pDriverData->NvDmaPusherBufferEnd[0] = 0;
                       /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                       _outp (0x3d0,0);

                       pDriverData->dwDmaPusherFreeCount = freeCount;

                       npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                       curBuffer ^= 1;

                       dstCurY += dstDeltaScans;

                       curV = srcCurY >> 20;
                   }

                   if (n > 0) {
                       FAST unsigned long *pSrcBits;

                       srcStartY = srcCurY;
                       srcStartFract = srcCurFract;
                       srcCurY += srcDeltaYPerBand;

                       if (doMirrorUpDown) {
                           if (((srcCurY - 0x100000) >> 20) < 0)
                               srcCurY = 0x100000;
                       } else {
                           if (((srcCurY + 0x100000) >> 20) > ((long)dwSrcHeight - 1))
                               srcCurY = ((long)dwSrcHeight - 2) << 20;
                       }

                       srcCurFract = srcCurY & 0xFFFFF;

                       if (curBuffer == 0)
                           npPixelBuf = (unsigned char *)pScanlineBuffer;
                       else
                           npPixelBuf = (unsigned char *)(pScanlineBuffer +
                               (NV_DD_COMMON_DMA_BUFFER_SIZE >> 1));

                       /* Must recalculate since src scanlines may be used more than once */
                       pSrcBits = (unsigned long *)(pSaveSrcInitBits +
                                  (curV * (nxtSrcScan << 1)));
                       pSrcCurScan = (unsigned short *)pSrcBits;

                       if (doMirrorUpDown)
                           m = (srcStartY >> 20) - ((srcCurY - 0x100000) >> 20);
                       else
                           m = ((srcCurY + 0x100000) >> 20) - (srcStartY >> 20);

                       srcCurDeltaScans = 0;

                       /* Copy and convert a block of source pixels to transfer buffer */
                       while (--m >= 0) {
                           if (pSrcBits >= (unsigned long *)pSrcInitBits) {
  //                           asmCopyScan(pSrcBits, npPixelBuf, srcBufferPitch);
                               _asm
                               {
#ifdef P6
                                   mov ecx, dword ptr srcBufferPitch
                                   mov esi, dword ptr pSrcBits
                                   shr ecx, 5
                     nxtCacheLine: mov eax, [esi]
                                   add esi, 32
                                   dec ecx
                                   jg nxtCacheLine
#endif /* P6 */
                                   mov ecx, dword ptr srcBufferPitch
                                   mov esi, dword ptr pSrcBits
                                   shr ecx, 2
                                   mov edi, dword ptr npPixelBuf
                                   test ecx, 1
                                   jz doQwords
                                   mov eax, [esi]
                                   add esi, 4
                                   mov [edi], eax
                                   add edi, 4
                         doQwords: shr ecx, 1
                                   jz copyDone
#ifdef MMX
                         nxtQword: movq mm1, qword ptr [esi]
                                   add esi, 8
                                   movq qword ptr [edi], mm1
                                   add edi, 8
                                   dec ecx
#else /* MMX */
                         nxtQword: mov eax, [esi]
                                   mov edx, [esi+4]
                                   add edi, 8
                                   add esi, 8
                                   dec ecx
                                   mov [edi-8], eax
                                   mov [edi-4], edx
#endif /* MMX */
                         copyDone: jg nxtQword
                               }
                           }
                           npPixelBuf += srcBufferPitch;
                           pSrcCurScan += (nxtSrcScan + skipSrcBytes);
                           pSrcBits = (unsigned long *)pSrcCurScan;
                           srcCurDeltaScans++;
                           m -= skipV;
                       }

                       /* wait for Dma operation to finish */
                       while (pDmaDmaFromMemNotifier->status == NV_IN_PROGRESS);

                       pDmaDmaFromMemNotifier->status = NV_IN_PROGRESS;

                       wDstPoint.xy16.y = (short)dstCurY;
                       wDstExt.wh16.h = (unsigned short)n;
                       wSrcPoint.xy16.y = (short)(srcStartFract >> 16); /* convert V to 12.4 */
                       wSrcExt.wh = srcCurDeltaScans;
                       wSrcExt.wh <<= 16;    /* shift V extent into place */
                       wSrcExt.wh |= dwSrcWidth;

//// BEGIN WORKAROUND FOR NV4 SCALED IMAGE HARDWARE BUG

                       while (freeCount < 8)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 8, dmaPusherPutAddress);
                       freeCount -= 8;

                       /* Reload object */
                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000;
                       dmaPusherPutAddress[1] = scaledImageObjectID;
                       /* Reinitialize volatile methods */
                       dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_CLIPPOINT_OFFSET | 0x80000;
                       dmaPusherPutAddress[3] = curClipPoint;
                       dmaPusherPutAddress[4] = curClipExtent;
                       dmaPusherPutAddress[5] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_DELTADUDX_OFFSET | 0x80000;
                       dmaPusherPutAddress[6] = curDUDX;
                       dmaPusherPutAddress[7] = curDVDY;

                       dmaPusherPutAddress += 8;

//// END WORKAROUND FOR NV4 SCALED IMAGE HARDWARE BUG

                       while (freeCount < 11)
                           NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
                       freeCount -= 11;

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_IMAGE_OUT_POINT_OFFSET | 0x80000;
                       dmaPusherPutAddress[1] = wDstPoint.xy;
                       dmaPusherPutAddress[2] = wDstExt.wh;
                       dmaPusherPutAddress[3] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_IMAGE_IN_SIZE_OFFSET | 0xC0000;
                       dmaPusherPutAddress[4] = wSrcExt.wh;
                       dmaPusherPutAddress[5] =
                           (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24) |
                           (NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16) |
                           srcBufferPitch;

                       if (curBuffer == 0)
                           dmaPusherPutAddress[6] =
                               NV_DD_NOTIFIER_BLOCK_SIZE;  /* There are several notifiers in the buffer */
                       else
                           dmaPusherPutAddress[6] =
                               NV_DD_NOTIFIER_BLOCK_SIZE + (NV_DD_COMMON_DMA_BUFFER_SIZE >> 1);

                       dmaPusherPutAddress[7] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_NOTIFY_OFFSET | 0x40000;
                       dmaPusherPutAddress[8] = 0;
                       dmaPusherPutAddress[9] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           SCALED_IMAGE_IMAGE_IN_POINT_OFFSET | 0x40000;
                       dmaPusherPutAddress[10] = wSrcPoint.xy;

                       dmaPusherPutAddress += 11;

                       /* Force write combine buffer to flush */
                       pDriverData->NvDmaPusherBufferEnd[0] = 0;
                       /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                       _outp (0x3d0,0);

                       pDriverData->dwDmaPusherFreeCount = freeCount;

                       npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;
                   }

                   if (srcTooWide) {
                       srcTooWide = 0;
                       wDestXY.xy16.x += (short)dstDeltaX;
                       wDstExt.wh16.w = wXYext.wh16.w - wDstExt.wh16.w;
                       if ((srcInVideoMemory) || (isVideo > 3))
                           wSrcPoint.xy16.x += (1024 << 4);
                       srcBufferPitch = ((dwSrcWidth << 1) + 3) & ~3L;
                       srcBufferPitch -= 2048;
                       pSaveSrcInitBits += 2048;
                       pSaveSrcBits = (unsigned short *)pSaveSrcInitBits;
                       pSrcCurScan = pSaveSrcBits;
                       goto oneMorePass;
                   }
#ifdef  MMX
                   if (curV != 0) {
                      _asm emms;
                   }
#endif /* MMX */
                }   // stretch

                if (isOverlappingVmem && lpSurfTemp) {
                    // FIXME: wait for blt to complete
                    NVHEAP_FREE(lpSurfTemp);
                }
            }

            if (dwFlags & DDBLT_KEYSRCOVERRIDE) {
                // disable chroma key
                while (freeCount < 2)
                    NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
                freeCount -= 2;

                dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_TRANSCOLOR) +
                    SET_TRANSCOLOR_OFFSET | 0x40000;
                dmaPusherPutAddress[1] = 0;

                dmaPusherPutAddress += 2;
            }

        } else {
            DPF("BLT     blt not handled by driver");
            return DDHAL_DRIVER_NOTHANDLED;
        }

        // restore pixel depth for z blts
        if (isZBlt) {
            while (freeCount < 2)
                NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
            freeCount -= 2;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x40000;
            dmaPusherPutAddress[1] = NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8;

            dmaPusherPutAddress += 2;
        }

    } else if (dwFlags & DDBLT_COLORFILL) {
        dwFillColor = pbd->bltFX.dwFillColor & pDriverData->physicalColorMask;

        while (freeCount < 10)
            NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);
        freeCount -= 10;

        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
            SET_ROP_OFFSET | 0x40000;
        dmaPusherPutAddress[1] = SRCCOPYINDEX;

        dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
            SURFACES_2D_DEST_OFFSET | 0x40000;
        dmaPusherPutAddress[3] = dwDstOffset;
        dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SURFACES) +
            SURFACES_2D_PITCH_OFFSET | 0x40000;
        dmaPusherPutAddress[5] = (dwDstPitch << 16) | dwDstPitch;

        dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
            RECT_AND_TEXT_COLOR1A_OFFSET | 0xC0000;
        dmaPusherPutAddress[7] = dwFillColor;
        dmaPusherPutAddress[8] = asmMergeCoords(wDestXY.xy16.y, wDestXY.xy16.x);
        dmaPusherPutAddress[9] = asmMergeCoords(wXYext.wh16.h, wXYext.wh16.w);

        dmaPusherPutAddress += 10;

    } else if (dwFlags & DDBLT_DEPTHFILL) {

        if (!(dwDstCaps & DDSCAPS_ZBUFFER)) {
            pbd->ddRVal = DDERR_INVALIDSURFACETYPE;
            return DDHAL_DRIVER_HANDLED;
        }

        pDriverData->dwDmaPusherFreeCount = freeCount;
        (unsigned long *)pDriverData->NvDmaPusherPutAddress = dmaPusherPutAddress;
        nvD3DClearZBuffer(dstx, pbd->bltFX.dwFillDepth);
        dmaPusherPutAddress = (unsigned long *)pDriverData->NvDmaPusherPutAddress;
#ifdef  CACHE_FREECOUNT
        freeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
        NvCheckCachedFreeCount(freeCount, dmaPusherPutAddress);
#endif  /* DEBUG */
#else   /* CACHE_FREECOUNT */
        freeCount = 0;
#endif  /* CACHE_FREECOUNT */

    } else {
        /* We don't handle any other type of BLT operation */
        return DDHAL_DRIVER_NOTHANDLED;
    }

    pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

    /* Force write combine buffer to flush */
    pDriverData->NvDmaPusherBufferEnd[0] = 0;
    /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
    _outp (0x3d0,0);

    pDriverData->dwDmaPusherFreeCount = freeCount;

    npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

    pbd->ddRVal = DD_OK;

    return DDHAL_DRIVER_HANDLED;

} /* Blt16bpp32 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\blt832.c ===
/*==========================================================================;
 *
 *  Copyright (C) 1995, 1998 NVidia Corporation.  All Rights Reserved.
 *
 *  File:       blt832.c
 *  Content:    Windows95 DirectDraw 32 bit driver
 *
 ***************************************************************************/

#include "windows.h"
#include <conio.h>
#include "nvd3ddrv.h"
#include "nv32.h"
#include "nvddobj.h"
#include "ddrvmem.h"
#include "d3dinc.h"
#include "nvheap.h"

extern DWORD ResetNV();

/*
 * Blt8bpp32
 *
 * 32-bit Blt function for 8bpp surfaces.
 */
DWORD __stdcall Blt8bpp32( LPDDHAL_BLTDATA pbd )
{
    FAST Nv10ControlDma *npDev;
    DWORD               dwFlags;
#ifdef  DX7
    DWORD               dwAFlags;
#endif  // DX7
    DWORD               dwDDFX = 0;
    DWORD               dwDstCaps;
    DWORD               dwSrcCaps;
    DWORD               dwRop;
    NVCOORD             wXYext;
    NVCOORD             wDestXY;
    NVCOORD             wSrcXY;
    BYTE                wStretch = 0;
    BYTE                doMirrorUpDown = 0;
    BYTE                isVideo = 0;
    BYTE                isZBlt = 0;

    DWORD               dwFillColor;
    DWORD               dwColorKey;

    DWORD               dwDstOffset;
    DWORD               dwDstPitch;
    DWORD               dwDstWidth;
    DWORD               dwDstHeight;

    DWORD               dwSrcOffset;
    DWORD               dwSrcPitch;
    DWORD               dwSrcWidth;
    DWORD               dwSrcHeight;

    LPDDRAWI_DDRAWSURFACE_LCL  srcx;
    LPDDRAWI_DDRAWSURFACE_LCL  dstx;
    LPDDRAWI_DDRAWSURFACE_GBL  src;
    LPDDRAWI_DDRAWSURFACE_GBL  dst;

    unsigned long       *dmaPusherPutAddress =
                            (unsigned long *)pDriverData->NvDmaPusherPutAddress;
    unsigned long       *dmaPusherBufferBase =
                            (unsigned long *)pDriverData->NvDmaPusherBufferBase;
    long                freeCount;

    dstx = pbd->lpDDDestSurface;
    dst = dstx->lpGbl;

    /*
     * NOTES:
     *
     * Everything you need is in pdb->bltFX .
     * Look at pdb->dwFlags to determine what kind of blt you are doing,
     * DDBLT_xxxx are the flags.
     *
     * Z BUFFER NOTES:
     *
     * ZBuffer ALWAYS comes in BLTFX.   You don't need to go looking for
     * the attached surface. If DDBLT_ZBUFFER is specified, then either a
     * constant z or z buffer surface has been specified for the source and
     * destination. Just look for the DDBLT_ZBUFFERDESTOVERRIDE,
     * DDBLT_ZBUFFERSRCOVERRIDE, DDBLT_ZBUFFERCONSTANTDESTOVERRIDE, or
     * DDBLT_ZBUFFERCONSTANTSRCOVERRIDE.
     *
     * COLORKEY NOTES:
     *
     * ColorKey ALWAYS comes in BLTFX.   You don't have to look it up in
     * the surface.
     */

    dwFlags   = pbd->dwFlags;
    dwDstCaps = dstx->ddsCaps.dwCaps;

    if (dwFlags & DDBLT_DDFX)
        dwDDFX = pbd->bltFX.dwDDFX;
#ifdef  DX7
    dwAFlags  = pbd->dwAFlags;

    if ((dwFlags & DDBLT_AFLAGS) && (dwAFlags & DDABLT_SRCOVERDEST)) {
        DPF("ALPHA ON 8BPP SURFACE FAILED");
        pbd->ddRVal = DDERR_NOALPHAHW;
        return DDHAL_DRIVER_HANDLED;
    }
#endif  /* DX7 */

    // check for z buffer blit
    // assume that DD runtime has enough sense to make alpha blits mutually exclusive
    if ((dwDstCaps & DDSCAPS_ZBUFFER) && (dstx->dwFlags & DDRAWISURF_HASPIXELFORMAT)) {
        if (dst->ddpfSurface.dwZBufferBitDepth == 32)
            isZBlt = NV042_SET_COLOR_FORMAT_LE_Y32;
        else if (dst->ddpfSurface.dwZBufferBitDepth == 16)
            isZBlt = NV042_SET_COLOR_FORMAT_LE_Y16;
    }

    if (dwFlags & (DDBLT_KEYDEST | DDBLT_KEYDESTOVERRIDE)) {
        DPF("DEST COLOR KEY FAILED");
        pbd->ddRVal = DDERR_NOCOLORKEYHW;
        return DDHAL_DRIVER_HANDLED;
    }

    /*
     * get offset, width, and height for destination
     */
    dwDstOffset = dst->fpVidMem     - pDriverData->BaseAddress;
    dwDstPitch  = dst->lPitch;
    dwDstWidth  = pbd->rDest.right  - pbd->rDest.left;
    dwDstHeight = pbd->rDest.bottom - pbd->rDest.top;
    wXYext.wh16.w = (unsigned short)dwDstWidth;
    wXYext.wh16.h = (unsigned short)dwDstHeight;

    wDestXY.xy16.x = (short)pbd->rDest.left;
    wDestXY.xy16.y = (short)pbd->rDest.top;

    if (dwDstCaps & (DDSCAPS_SYSTEMMEMORY | DDSCAPS_TEXTURE | DDSCAPS_NONLOCALVIDMEM))
        return DDHAL_DRIVER_NOTHANDLED;

    npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;

    if (npDev == NULL) {
        if (!ResetNV()) {
            pbd->ddRVal = DDERR_GENERIC;
            return DDHAL_DRIVER_HANDLED;
        }
        pDriverData->fReset = FALSE;
        npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;

        if (npDev == NULL) {
            pbd->ddRVal = DDERR_SURFACELOST;
            return DDHAL_DRIVER_HANDLED;
        }
    }

    dmaPusherPutAddress = (unsigned long *)pDriverData->NvDmaPusherPutAddress;

#ifdef  CACHE_FREECOUNT
    freeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
    NvCheckCachedFreeCount(freeCount, dmaPusherPutAddress);
#endif  /* DEBUG */
#else   /* CACHE_FREECOUNT */
    freeCount = 0;
#endif  /* CACHE_FREECOUNT */

    /*
     * If async, then only work if bltter isn't busy
     * This should probably be a little more specific to each call, but
     * waiting for 32 is pretty close
     */
    if (dwFlags & DDBLT_ASYNC ) {

        NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);

        pDriverData->dwDmaPusherFreeCount = freeCount;

        /* Must save pointer in case it was changed by above macro */
        pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

        if (freeCount < 10) {
            DPF("ASYNC FAILED");
            pbd->ddRVal = DDERR_WASSTILLDRAWING;
            return DDHAL_DRIVER_HANDLED;
        }
    }

    if (dwFlags & DDBLT_ROP) {
        dwRop = pbd->bltFX.dwROP >> 16;

        // set pixel depth for z buffer blit
        if (isZBlt) {
            while (freeCount < 2)
                NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
            freeCount -= 2;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x40000;
            dmaPusherPutAddress[1] = isZBlt;

            dmaPusherPutAddress += 2;
        }
        if ((dwRop == BLACKNESSINDEX) || (dwRop == WHITENESSINDEX)) {

            while (freeCount < 10)
                NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);
            freeCount -= 10;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
                SET_ROP_OFFSET | 0x40000;
            dmaPusherPutAddress[1] = dwRop;

            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                SURFACES_2D_DEST_OFFSET | 0x40000;
            dmaPusherPutAddress[3] = dwDstOffset;
            dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                SURFACES_2D_PITCH_OFFSET | 0x40000;
            dmaPusherPutAddress[5] = (dwDstPitch << 16) | dwDstPitch;

            dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                RECT_AND_TEXT_COLOR1A_OFFSET | 0xC0000;
            dmaPusherPutAddress[7] = 0;
            dmaPusherPutAddress[8] = asmMergeCoords(wDestXY.xy16.y, wDestXY.xy16.x);
            dmaPusherPutAddress[9] = asmMergeCoords(wXYext.wh16.h, wXYext.wh16.w);

            dmaPusherPutAddress += 10;

        } else if ((dwRop == PATCOPYINDEX) || (dwRop == PATINVERTINDEX)) {

            dwFillColor = pbd->bltFX.dwFillColor & pDriverData->physicalColorMask;

            if (dwRop == PATCOPYINDEX)
                dwRop = SRCCOPYINDEX;
            else if (dwRop == PATINVERTINDEX)
                dwRop = SRCINVERTINDEX;

            while (freeCount < 10)
                NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);
            freeCount -= 10;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
                SET_ROP_OFFSET | 0x40000;
            dmaPusherPutAddress[1] = dwRop;

            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                SURFACES_2D_DEST_OFFSET | 0x40000;
            dmaPusherPutAddress[3] = dwDstOffset;
            dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                SURFACES_2D_PITCH_OFFSET | 0x40000;
            dmaPusherPutAddress[5] = (dwDstPitch << 16) | dwDstPitch;

            dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                RECT_AND_TEXT_COLOR1A_OFFSET | 0xC0000;
            dmaPusherPutAddress[7] = dwFillColor;
            dmaPusherPutAddress[8] = asmMergeCoords(wDestXY.xy16.y, wDestXY.xy16.x);
            dmaPusherPutAddress[9] = asmMergeCoords(wXYext.wh16.h, wXYext.wh16.w);

            dmaPusherPutAddress += 10;

        } else if ((dwRop == SRCCOPYINDEX) || (dwRop == SRCPAINTINDEX) ||
                   (dwRop == SRCANDINDEX) || (dwRop == NOTSRCCOPYINDEX) ||
                   (dwRop == SRCINVERTINDEX) || (dwRop == MERGEPAINTINDEX) ||
                   (dwRop == SRCERASEINDEX) || (dwRop == NOTSRCERASEINDEX)) {

            srcx = pbd->lpDDSrcSurface;
            src = srcx->lpGbl;

            dwSrcCaps = srcx->ddsCaps.dwCaps;

            /* We must treat AGP source memory as system memory */
            if (dwSrcCaps & DDSCAPS_NONLOCALVIDMEM) {
                dwSrcCaps &= ~(DDSCAPS_VIDEOMEMORY | DDSCAPS_NONLOCALVIDMEM);
            }

            dwSrcOffset = src->fpVidMem    - pDriverData->BaseAddress;
            dwSrcPitch  = src->lPitch;
            dwSrcWidth  = pbd->rSrc.right  - pbd->rSrc.left;
            dwSrcHeight = pbd->rSrc.bottom - pbd->rSrc.top;
            dwColorKey  = pbd->bltFX.ddckSrcColorkey.dwColorSpaceLowValue;

            wSrcXY.xy16.x = (short)pbd->rSrc.left;
            wSrcXY.xy16.y = (short)pbd->rSrc.top;

            /* We don't handle FOURCC_RGB0 format in 8bpp mode */
            if ((srcx->dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
                (src->ddpfSurface.dwFlags & DDPF_FOURCC)) {

               if (src->ddpfSurface.dwFourCC == FOURCC_RGB0) {
                   if ((src->ddpfSurface.dwRBitMask == 0) &&
                       (src->ddpfSurface.dwGBitMask == 0) &&
                       (src->ddpfSurface.dwBBitMask == 0)) {
                       if (dwSrcCaps & DDSCAPS_SYSTEMMEMORY)
                           isVideo = 1;
                       goto srcRGB;
                   } else {
                       pbd->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                       return DDHAL_DRIVER_HANDLED;
                   }
               }
               pbd->ddRVal = DDERR_UNSUPPORTEDFORMAT;
               return DDHAL_DRIVER_HANDLED;
            }

srcRGB:     if (dwDDFX & DDBLTFX_MIRRORUPDOWN)
                doMirrorUpDown = 1;

            if ((dwSrcWidth != dwDstWidth) || (dwSrcHeight != dwDstHeight)) {
                wStretch = 1;
            }

            if (dwFlags & DDBLT_KEYSRCOVERRIDE) {

                dwColorKey = pbd->bltFX.ddckSrcColorkey.dwColorSpaceLowValue;

                /* Let D3D know that we changed the object in subchannel 6 */
                pDriverData->dDrawSpareSubchannel6Object = NV_DD_CONTEXT_COLOR_KEY;

                while (freeCount < 4)
                    NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
                freeCount -= 4;

                // load and enable chroma key
                dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_TRANSCOLOR) | 0x40000;
                dmaPusherPutAddress[1] = NV_DD_CONTEXT_COLOR_KEY;
                dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_TRANSCOLOR) +
                    SET_TRANSCOLOR_OFFSET | 0x40000;
                dmaPusherPutAddress[3] =
                    (dwColorKey & pDriverData->physicalColorMask) | NV_ALPHA_1_008;

                dmaPusherPutAddress += 4;

                pDriverData->dwDmaPusherFreeCount = freeCount;

                /* Just in case we return unexpectedly */
                pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;
            }

            // screen to screen bitblt
            if (wStretch == 0) {

                if ((dwDstCaps & DDSCAPS_VIDEOMEMORY) &&
                    (dwSrcCaps & DDSCAPS_VIDEOMEMORY) &&
                    ((dwSrcCaps & DDSCAPS_TEXTURE) == 0) &&
                    (doMirrorUpDown == 0) &&
                    (isVideo == 0)) {

                    if (pDriverData->dwSharedClipChangeCount != pDriverData->dwDDMostRecentClipChangeCount) {

                        while (freeCount < 7)
                            NvGetDmaBufferFreeCount(npDev, freeCount, 7, dmaPusherPutAddress);
                        freeCount -= 7;

                        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000;
                        dmaPusherPutAddress[1] = NV_DD_IMAGE_BLACK_RECTANGLE;
                        dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                            IMAGE_BLACK_RECTANGLE_POINT_OFFSET | 0x80000;
                        dmaPusherPutAddress[3] = 0;
                        dmaPusherPutAddress[4] = asmMergeCoords(NV_MAX_X_CLIP, NV_MAX_Y_CLIP);
                        dmaPusherPutAddress[5] = dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000;
                        dmaPusherPutAddress[6] = NV_DD_SURFACES_2D;

                        dmaPusherPutAddress += 7;

                        pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

                        /* Force write combine buffer to flush */
                        pDriverData->NvDmaPusherBufferEnd[0] = 0;
                        /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                        _outp (0x3d0,0);

                        pDriverData->dwDmaPusherFreeCount = freeCount;

                        npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                        pDriverData->dwSharedClipChangeCount++;

                        pDriverData->dwDDMostRecentClipChangeCount = pDriverData->dwSharedClipChangeCount;
                    }

                    while (freeCount < 10)
                        NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);
                    freeCount -= 10;

                    dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
                        SET_ROP_OFFSET | 0x40000;
                    dmaPusherPutAddress[1] = dwRop;

                    dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                        SURFACES_2D_PITCH_OFFSET | 0xC0000;
                    dmaPusherPutAddress[3] = (dwDstPitch << 16) | dwSrcPitch;
                    dmaPusherPutAddress[4] = dwSrcOffset;
                    dmaPusherPutAddress[5] = dwDstOffset;

                    dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_BLIT) +
                        BLIT_POINT_IN_OFFSET | 0xC0000;
                    dmaPusherPutAddress[7] = wSrcXY.xy;
                    dmaPusherPutAddress[8] = wDestXY.xy;
                    dmaPusherPutAddress[9] = wXYext.wh;

                    dmaPusherPutAddress += 10;

               } else {
                   // memory to screen blt (src may be in system memory or in video memory)
                   unsigned long temp;
                   long srcScanLength;
                   long nxtSrcScan;
                   short n = wXYext.wh16.h;
                   FAST short pxlCount;
                   unsigned short srcOffset;
                   unsigned char *pSrcInitBits;

                   pSrcInitBits = (unsigned char *)src->fpVidMem;

                   srcScanLength = src->lPitch;

                   if (doMirrorUpDown)
                       wSrcXY.xy16.y += (n - 1);

                   pSrcInitBits += (wSrcXY.xy16.y * srcScanLength);

                   srcOffset = wSrcXY.xy16.x & 3;

                   temp = ((wXYext.wh16.w + srcOffset + 3) & 0xFFFC);

                   nxtSrcScan = srcScanLength - temp;

                   if (doMirrorUpDown)
                       nxtSrcScan = -srcScanLength - temp;

                   pSrcInitBits += (wSrcXY.xy16.x & 0xFFFC);

                   while (freeCount < 15)
                       NvGetDmaBufferFreeCount(npDev, freeCount, 15, dmaPusherPutAddress);
                   freeCount -= 15;

                   if (pDriverData->dDrawSpareSubchannelObject !=
                       NV_DD_IMAGE_BLACK_RECTANGLE) {

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                       dmaPusherPutAddress[1] = NV_DD_IMAGE_BLACK_RECTANGLE;

                       dmaPusherPutAddress += 2;

                       pDriverData->dDrawSpareSubchannelObject =
                       NV_DD_IMAGE_BLACK_RECTANGLE;
                   }

                   /* Let others know that we changed the clip */
                   pDriverData->dwSharedClipChangeCount++;

                   // changing canvas clip avoids manually aligning 8-bit source
                   dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) +
                       IMAGE_BLACK_RECTANGLE_POINT_OFFSET | 0x80000;
                   dmaPusherPutAddress[1] = wDestXY.xy;
                   dmaPusherPutAddress[2] = wXYext.wh;

                   dmaPusherPutAddress[3] = dDrawSubchannelOffset(NV_DD_ROP) +
                       SET_ROP_OFFSET | 0x40000;
                   dmaPusherPutAddress[4] = dwRop;

                   dmaPusherPutAddress[5] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                       SURFACES_2D_DEST_OFFSET | 0x40000;
                   dmaPusherPutAddress[6] = dwDstOffset;
                   dmaPusherPutAddress[7] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                       SURFACES_2D_PITCH_OFFSET | 0x40000;
                   dmaPusherPutAddress[8] = (dwDstPitch << 16) | dwDstPitch;

                   /* compiler screws up this expression when it goes negative in following macro */
                   temp = wDestXY.xy16.x - srcOffset;

                   dmaPusherPutAddress[9] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                       IMAGE_FROM_CPU_POINT_OFFSET | 0xC0000;
                   dmaPusherPutAddress[10] =
                       asmMergeCoords(temp, wDestXY.xy16.y);
                   dmaPusherPutAddress[11] =
                       asmMergeCoords(wXYext.wh16.w + srcOffset, wXYext.wh16.h);

                   temp = ((wXYext.wh16.w + srcOffset + 3) & 0xFFFC);

                   dmaPusherPutAddress[12] =
                       asmMergeCoords(temp, wXYext.wh16.h);

                   dmaPusherPutAddress += 13;

                   {
                       FAST unsigned char *pSrcBits = pSrcInitBits;
                       FAST unsigned long tmpPxls0, tmpPxls1, tmpPxls2;

                       if (temp < (1792 << 2)) {
                           while (--n >= 0) {
                               pxlCount = (short)temp;

                               // Get enough buffer space for this scanline
                               while (freeCount < (long)(1 + (temp >> 2)))
                                   NvGetDmaBufferFreeCount(npDev, freeCount, (long)(1 + (temp >> 2)), dmaPusherPutAddress);
                               freeCount -= (long)(1 + (temp >> 2));

                               dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                                   IMAGE_FROM_CPU_COLOR_OFFSET | (temp << 16);
                               dmaPusherPutAddress += 1;

                               while (pxlCount >= 32) {
                                   pxlCount -= 32;

                                   tmpPxls0 = *(unsigned long *)&pSrcBits[0];
                                   tmpPxls1 = *(unsigned long *)&pSrcBits[4];
                                   dmaPusherPutAddress[0] = tmpPxls0;
                                   tmpPxls2 = *(unsigned long *)&pSrcBits[8];
                                   dmaPusherPutAddress[1] = tmpPxls1;
                                   tmpPxls0 = *(unsigned long *)&pSrcBits[12];
                                   tmpPxls1 = *(unsigned long *)&pSrcBits[16];
                                   dmaPusherPutAddress[2] = tmpPxls2;
                                   dmaPusherPutAddress[3] = tmpPxls0;
                                   tmpPxls2 = *(unsigned long *)&pSrcBits[20];
                                   tmpPxls0 = *(unsigned long *)&pSrcBits[24];
                                   dmaPusherPutAddress[4] = tmpPxls1;
                                   dmaPusherPutAddress[5] = tmpPxls2;
                                   tmpPxls1 = *(unsigned long *)&pSrcBits[28];
                                   dmaPusherPutAddress[6] = tmpPxls0;
                                   pSrcBits += 32;
                                   dmaPusherPutAddress[7] = tmpPxls1;

                                   dmaPusherPutAddress += 8;
                               }

                               if (pxlCount > 0) {

                                   while (pxlCount >= 8) {
                                       pxlCount -= 8;
                                       tmpPxls0 = *(unsigned long *)&pSrcBits[0];
                                       tmpPxls1 = *(unsigned long *)&pSrcBits[4];
                                       pSrcBits += 8;
                                       dmaPusherPutAddress[0] = tmpPxls0;
                                       dmaPusherPutAddress[1] = tmpPxls1;

                                       dmaPusherPutAddress += 2;
                                   }

                                   if (pxlCount > 0) {
                                       pxlCount -= 4;
                                       tmpPxls0 = *(unsigned long *)&pSrcBits[0];
                                       pSrcBits += 4;
                                       dmaPusherPutAddress[0] = tmpPxls0;

                                       dmaPusherPutAddress++;

                                       if (pxlCount > 0) {
                                           tmpPxls1 = *(unsigned long *)&pSrcBits[0];
                                           pSrcBits += 4;
                                           dmaPusherPutAddress[0] = tmpPxls1;

                                           dmaPusherPutAddress++;
                                       }
                                   }
                               }
                               pSrcBits += nxtSrcScan;

                               /* Force write combine buffer to flush */
                               pDriverData->NvDmaPusherBufferEnd[0] = 0;
                               /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                               _outp (0x3d0,0);

                               pDriverData->dwDmaPusherFreeCount = freeCount;

                               npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;
                            }
                        } else { /* more than 1792 dwords per scanline */

                           while (--n >= 0) {
                               pxlCount = (short)temp;

                               while (pxlCount >= 32) {
                                   pxlCount -= 32;

                                   while (freeCount < (1 + (32 >> 2)))
                                       NvGetDmaBufferFreeCount(npDev, freeCount, (1 + (32 >> 2)), dmaPusherPutAddress);
                                   freeCount -= (1 + (32 >> 2));

                                   dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                                       IMAGE_FROM_CPU_COLOR_OFFSET | (32 << 16);

                                   tmpPxls0 = *(unsigned long *)&pSrcBits[0];
                                   tmpPxls1 = *(unsigned long *)&pSrcBits[4];
                                   dmaPusherPutAddress[1] = tmpPxls0;
                                   tmpPxls2 = *(unsigned long *)&pSrcBits[8];
                                   dmaPusherPutAddress[2] = tmpPxls1;
                                   tmpPxls0 = *(unsigned long *)&pSrcBits[12];
                                   tmpPxls1 = *(unsigned long *)&pSrcBits[16];
                                   dmaPusherPutAddress[3] = tmpPxls2;
                                   dmaPusherPutAddress[4] = tmpPxls0;
                                   tmpPxls2 = *(unsigned long *)&pSrcBits[20];
                                   tmpPxls0 = *(unsigned long *)&pSrcBits[24];
                                   dmaPusherPutAddress[5] = tmpPxls1;
                                   dmaPusherPutAddress[6] = tmpPxls2;
                                   tmpPxls1 = *(unsigned long *)&pSrcBits[28];
                                   dmaPusherPutAddress[7] = tmpPxls0;
                                   pSrcBits += 32;
                                   dmaPusherPutAddress[8] = tmpPxls1;

                                   dmaPusherPutAddress += 9;
                               }

                               if (pxlCount > 0) {

                                   while (freeCount < (1 + (pxlCount >> 2)))
                                       NvGetDmaBufferFreeCount(npDev, freeCount, (1 + (pxlCount >> 2)), dmaPusherPutAddress);
                                   freeCount -= (1 + (pxlCount >> 2));

                                   dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                                       IMAGE_FROM_CPU_COLOR_OFFSET | (pxlCount << 16);
                                   dmaPusherPutAddress += 1;

                                   while (pxlCount >= 8) {
                                       pxlCount -= 8;
                                       tmpPxls0 = *(unsigned long *)&pSrcBits[0];
                                       tmpPxls1 = *(unsigned long *)&pSrcBits[4];
                                       pSrcBits += 8;
                                       dmaPusherPutAddress[0] = tmpPxls0;
                                       dmaPusherPutAddress[1] = tmpPxls1;

                                       dmaPusherPutAddress += 2;
                                   }

                                   if (pxlCount > 0) {
                                       pxlCount -= 4;
                                       tmpPxls0 = *(unsigned long *)&pSrcBits[0];
                                       pSrcBits += 4;
                                       dmaPusherPutAddress[0] = tmpPxls0;

                                       dmaPusherPutAddress++;

                                       if (pxlCount > 0) {
                                           tmpPxls1 = *(unsigned long *)&pSrcBits[0];
                                           pSrcBits += 4;
                                           dmaPusherPutAddress[0] = tmpPxls1;

                                           dmaPusherPutAddress++;
                                       }
                                   }
                               }
                               pSrcBits += nxtSrcScan;

                               /* Force write combine buffer to flush */
                               pDriverData->NvDmaPusherBufferEnd[0] = 0;
                               /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                               _outp (0x3d0,0);

                               pDriverData->dwDmaPusherFreeCount = freeCount;

                               npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;
                            }
                        }
                    }

                    pDriverData->dwSharedClipChangeCount++;

                    pDriverData->dwDDMostRecentClipChangeCount = pDriverData->dwSharedClipChangeCount;

                    while (freeCount < 3)
                        NvGetDmaBufferFreeCount(npDev, freeCount, 3, dmaPusherPutAddress);
                    freeCount -= 3;

                    // restore canvas clip
                    dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) +
                        IMAGE_BLACK_RECTANGLE_POINT_OFFSET | 0x80000;
                    dmaPusherPutAddress[1] = 0;
                    dmaPusherPutAddress[2] = asmMergeCoords(NV_MAX_X_CLIP, NV_MAX_Y_CLIP);

                    dmaPusherPutAddress += 3;
                }
            } else { // stretch
               NvNotification *pDmaBufferNotifier;
               unsigned char *pScanlineBuffer;
               long srcScanLength;
               long nxtSrcScan;
               long n;
               short m;
               FAST short pxlCount;
               unsigned char *pSrcInitBits;
               unsigned char *pSaveSrcBits;
               unsigned char *pSrcCurScan;
               long deltaX;
               long deltaY;
               long curDstY;
               long lastDstY;
               long skipSrcBytes = 0;
               NVCOORD wSrcExt;
               NVCOORD wDstPoint;
               unsigned long srcStrtX;
               BYTE srcInVideoMemory = 0;
               BYTE bufState = 0;
               short skipV = 0;

               RECT rDummy;
               BOOL isOverlappingVmem = FALSE;
               FLATPTR lpSurfTemp = 0;
               DWORD dwSrcBitsPP = 8;
               // if the source and destination overlap, then we must do this in 2 passes, first copy the source
               // image somewhere else, and then so the stretch from there.
               if ((dwSrcCaps & DDSCAPS_VIDEOMEMORY) && dwSrcOffset == dwDstOffset && IntersectRect(&rDummy, (LPRECT)(&pbd->rSrc), (LPRECT)(&pbd->rDest))) {
                    NVHEAP_ALLOC(lpSurfTemp, dwSrcHeight * ((dwSrcWidth * dwSrcBitsPP / 8 + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad), TYPE_IMAGE);
                    if (lpSurfTemp) {
                        isOverlappingVmem = TRUE;
                        if (pDriverData->dwSharedClipChangeCount != pDriverData->dwDDMostRecentClipChangeCount) {

                            while (freeCount < 7)
                                NvGetDmaBufferFreeCount(npDev, freeCount, 7, dmaPusherPutAddress);
                            freeCount -= 7;

                            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000;
                            dmaPusherPutAddress[1] = NV_DD_IMAGE_BLACK_RECTANGLE;
                            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                                IMAGE_BLACK_RECTANGLE_POINT_OFFSET | 0x80000;
                            dmaPusherPutAddress[3] = 0;
                            dmaPusherPutAddress[4] = asmMergeCoords(NV_MAX_X_CLIP, NV_MAX_Y_CLIP);
                            dmaPusherPutAddress[5] = dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000;
                            dmaPusherPutAddress[6] = NV_DD_SURFACES_2D;

                            dmaPusherPutAddress += 7;

                            pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

                            /* Force write combine buffer to flush */
                            pDriverData->NvDmaPusherBufferEnd[0] = 0;
                            /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                            _outp (0x3d0,0);

                            pDriverData->dwDmaPusherFreeCount = freeCount;

                            npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                            pDriverData->dwSharedClipChangeCount++;

                            pDriverData->dwDDMostRecentClipChangeCount = pDriverData->dwSharedClipChangeCount;
                        }

                        while (freeCount < 10)
                            NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);
                        freeCount -= 10;

                        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
                            SET_ROP_OFFSET | 0x40000;
                        dmaPusherPutAddress[1] = dwRop;

                        dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                            SURFACES_2D_PITCH_OFFSET | 0xC0000;
                        dmaPusherPutAddress[3] = ((((dwSrcWidth * dwSrcBitsPP / 8 + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad)) << 16) | dwSrcPitch;
                        dmaPusherPutAddress[4] = dwSrcOffset;
                        dmaPusherPutAddress[5] = lpSurfTemp - pDriverData->BaseAddress;

                        dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_BLIT) +
                            BLIT_POINT_IN_OFFSET | 0xC0000;
                        dmaPusherPutAddress[7] = wSrcXY.xy;
                        dmaPusherPutAddress[8] = 0;
                        dmaPusherPutAddress[9] = wXYext.wh;

                        dmaPusherPutAddress += 10;

                        dwSrcOffset = lpSurfTemp - pDriverData->BaseAddress;
                        dwSrcPitch = ((dwSrcWidth * dwSrcBitsPP / 8 + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad);
                        wSrcXY.xy = 0;
                        wSrcXY.xy16.x = 0;
                        wSrcXY.xy16.y = 0;
                    } else {
                        // FIXME: vmem heap alloc failed, must do system mem alloc and copy there
                    }
               }
               // WARNING: carefully consider each use of src->fpVidMem and src->lPitch beyond this point
               //          it could screw up overlapping stretchblits

//               pSrcInitBits = (unsigned char *)src->fpVidMem;
//               srcScanLength = src->lPitch;
               pSrcInitBits = (unsigned char *)(dwSrcOffset + pDriverData->BaseAddress);
               srcScanLength = dwSrcPitch;

               if (dwSrcPitch <= 800)
                   m = 16;
               else
                   m = 8;

               while (freeCount < 6)
                   NvGetDmaBufferFreeCount(npDev, freeCount, 6, dmaPusherPutAddress);
               freeCount -= 6;

               dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
                   SET_ROP_OFFSET | 0x40000;
               dmaPusherPutAddress[1] = dwRop;

               dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                   SURFACES_2D_DEST_OFFSET | 0x40000;
               dmaPusherPutAddress[3] = dwDstOffset;
               dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                   SURFACES_2D_PITCH_OFFSET | 0x40000;
               dmaPusherPutAddress[5] = (dwDstPitch << 16) | dwDstPitch;

               dmaPusherPutAddress += 6;

               /* calculate deltas in 12.20 format */
               deltaX = dwDstWidth << 20;
               deltaX /= dwSrcWidth;

               if ((deltaX > 0x100000) && (deltaX & 0xFFFFF)) {
                   long xStretch = deltaX & 0xFFF00000;
                   deltaX = (dwDstWidth << 20) + xStretch;
                   deltaX /= dwSrcWidth;
               }

               if ((deltaX < 0x100000) && (deltaX & 0xFFFFF)) {
                   deltaX = (dwDstWidth << 20) + 0x100000;
                   deltaX /= dwSrcWidth;
               }

               deltaY = dwDstHeight << 20;
               deltaY /= dwSrcHeight;

               if ((deltaY > 0x100000) && (deltaY & 0xFFFFF)) {
                   long yStretch = deltaY & 0xFFF00000;
                   deltaY = (dwDstHeight << 20) + yStretch;
                   deltaY /= dwSrcHeight;
               }

               if ((deltaY < 0x100000) && (deltaY & 0xFFFFF)) {
                   deltaY = (dwDstHeight << 20) + 0x100000;
                   deltaY /= dwSrcHeight;
               }

               wSrcExt.wh16.w = (unsigned short)((dwSrcWidth + 3) & ~3L);
               wSrcExt.wh16.h = (unsigned short)dwSrcHeight;

               n = (short)dwSrcHeight;

               if (wSrcXY.xy16.y + n > src->wHeight)
                   n = src->wHeight - wSrcXY.xy16.y;

               nxtSrcScan = srcScanLength;

               if (doMirrorUpDown) {
                   wSrcXY.xy16.y += (n - 1);
                   nxtSrcScan = -nxtSrcScan;
                   skipSrcBytes = -skipSrcBytes;
               }

               if ((dwSrcCaps & DDSCAPS_VIDEOMEMORY) &&
                   ((dwSrcCaps & DDSCAPS_TEXTURE) == 0) &&
                   ((src->fpVidMem >= pDriverData->BaseAddress) || isOverlappingVmem)) {
                   srcInVideoMemory = 1;
               } else {
                   pSaveSrcBits = (unsigned char *)(pSrcInitBits +
                                  (wSrcXY.xy16.y * srcScanLength));
                   pSaveSrcBits += wSrcXY.xy16.x;
                   pSrcCurScan = pSaveSrcBits;
               }

               if (srcInVideoMemory) {
                   pDmaBufferNotifier = (NvNotification *)pDriverData->NvDmaBufferNotifierFlat;
                   pDmaBufferNotifier++;
                   pScanlineBuffer = (unsigned char *)pDriverData->NvScanlineBufferFlat;

                   wSrcExt.wh16.w = (unsigned short)((dwSrcWidth + 3) & ~3);
                   wSrcExt.wh16.h = m;

                   srcStrtX = wSrcXY.xy16.x;

                   while (freeCount < 2)
                       NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
                   freeCount -= 2;

                   dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) | 0x40000;
                   dmaPusherPutAddress[1] = NV_DD_VIDEO_MEMORY_TO_SYSTEM_MEMORY_FORMAT;

                   dmaPusherPutAddress += 2;

                   // wait for any pending notification operation to finish
                   while ((volatile)pDmaBufferNotifier->status == NV_IN_PROGRESS);

                   pDmaBufferNotifier->status = NV_IN_PROGRESS;

                   while (freeCount < 9)
                       NvGetDmaBufferFreeCount(npDev, freeCount, 9, dmaPusherPutAddress);
                   freeCount -= 9;

                   dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                       MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000;

                   dmaPusherPutAddress[1] = dwSrcOffset +
                       ((dwSrcPitch + skipSrcBytes) * (unsigned long)wSrcXY.xy16.y) +
                       ((unsigned long)wSrcXY.xy16.x);

                   dmaPusherPutAddress[2] = NV_DD_NOTIFIER_BLOCK_SIZE + srcStrtX;

                   dmaPusherPutAddress[3] = (dwSrcPitch + skipSrcBytes);

                   dmaPusherPutAddress[4] = dwSrcPitch;

                   dmaPusherPutAddress[5] = (unsigned long)wSrcExt.wh16.w;

                   dmaPusherPutAddress[6] = m;

                   dmaPusherPutAddress[7] = (1 << 8) | 1;

                   dmaPusherPutAddress[8] = 0;

                   dmaPusherPutAddress += 9;

                   /* Force write combine buffer to flush */
                   pDriverData->NvDmaPusherBufferEnd[0] = 0;
                   /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                   _outp (0x3d0,0);

                   pDriverData->dwDmaPusherFreeCount = freeCount;

                   npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                   // wait for Dma operation to finish
                   while ((volatile)pDmaBufferNotifier->status == NV_IN_PROGRESS);

                   if (doMirrorUpDown)
                       wSrcXY.xy16.y -= (m + skipV);
                   else
                       wSrcXY.xy16.y += (m + skipV);
               }

               /* Convert to 12.4 format */
               wDstPoint.xy16.x = (wDestXY.xy16.x << 4);
               wDstPoint.xy16.y = (wDestXY.xy16.y << 4);

               /* convert to 16.16 */
               lastDstY = (long)(wDestXY.xy16.y + wXYext.wh16.h) << 16;

               /* convert to 16.16 */
               curDstY = ((long)wDestXY.xy16.y << 16);

               while (freeCount < 7)
                   NvGetDmaBufferFreeCount(npDev, freeCount, 7, dmaPusherPutAddress);
               freeCount -= 7;

               dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                   STRETCHED_IMAGE_SIZE_IN_OFFSET | 0x180000;
               dmaPusherPutAddress[1] = wSrcExt.wh;
               dmaPusherPutAddress[2] = deltaX;
               dmaPusherPutAddress[3] = deltaY;
               dmaPusherPutAddress[4] = wDestXY.xy;
               dmaPusherPutAddress[5] = wXYext.wh;
               dmaPusherPutAddress[6] = wDstPoint.xy;

               dmaPusherPutAddress += 7;

               while ((n > 0) && (curDstY < lastDstY)) {
                   FAST unsigned long *pSrcBits;
                   FAST unsigned long tmpPxls0, tmpPxls1, tmpPxls2;

                   if (srcInVideoMemory) {
                       if (bufState == 0)
                           pSrcBits = (unsigned long *)(pScanlineBuffer + srcStrtX);
                       else
                           pSrcBits = (unsigned long *)(pScanlineBuffer +
                               (NV_DD_COMMON_DMA_BUFFER_SIZE >> 1) + srcStrtX);

                       pSrcCurScan = (unsigned char *)pSrcBits;

                       if (m > 0) {
                           pDmaBufferNotifier->status = NV_IN_PROGRESS;

                           while (freeCount < 9)
                               NvGetDmaBufferFreeCount(npDev, freeCount, 9, dmaPusherPutAddress);
                           freeCount -= 9;

                           dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) +
                               MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000;

                           dmaPusherPutAddress[1] = dwSrcOffset +
                               ((dwSrcPitch + skipSrcBytes) * (unsigned long)wSrcXY.xy16.y) +
                               ((unsigned long)wSrcXY.xy16.x);

                           if (bufState == 0)
                               dmaPusherPutAddress[2] =
                                   NV_DD_NOTIFIER_BLOCK_SIZE +
                                   (NV_DD_COMMON_DMA_BUFFER_SIZE >> 1) +
                                   srcStrtX;
                           else
                               dmaPusherPutAddress[2] =
                                   NV_DD_NOTIFIER_BLOCK_SIZE +
                                   srcStrtX;

                           dmaPusherPutAddress[3] = (dwSrcPitch + skipSrcBytes);

                           dmaPusherPutAddress[4] = dwSrcPitch;

                           dmaPusherPutAddress[5] = (unsigned long)wSrcExt.wh16.w;

                           dmaPusherPutAddress[6] = m;

                           dmaPusherPutAddress[7] = (1 << 8) | 1;

                           dmaPusherPutAddress[8] = 0;

                           dmaPusherPutAddress += 9;

                           /* Force write combine buffer to flush */
                           pDriverData->NvDmaPusherBufferEnd[0] = 0;
                           /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                           _outp (0x3d0,0);

                           pDriverData->dwDmaPusherFreeCount = freeCount;

                           npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                           bufState ^= 1;

                           if (doMirrorUpDown)
                               wSrcXY.xy16.y -= (m + skipV);
                           else
                               wSrcXY.xy16.y += (m + skipV);

                           while (freeCount < 7)
                               NvGetDmaBufferFreeCount(npDev, freeCount, 7, dmaPusherPutAddress);
                           freeCount -= 7;

                           dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                               STRETCHED_IMAGE_SIZE_IN_OFFSET | 0x180000;

                           dmaPusherPutAddress[1] = wSrcExt.wh;

                           dmaPusherPutAddress[2] = deltaX;

                           dmaPusherPutAddress[3] = deltaY;

                           dmaPusherPutAddress[4] = wDestXY.xy;

                           dmaPusherPutAddress[5] = wXYext.wh;

                           dmaPusherPutAddress[6] = wDstPoint.xy;

                           dmaPusherPutAddress += 7;

                           /* Force write combine buffer to flush */
                           pDriverData->NvDmaPusherBufferEnd[0] = 0;
                           /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                           _outp (0x3d0,0);

                           pDriverData->dwDmaPusherFreeCount = freeCount;

                           npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;
                       }
                   } else { // source in system memory
                       pSrcBits = (unsigned long *)pSrcCurScan;
                       pSrcCurScan += (nxtSrcScan + skipSrcBytes);
                       n--;
                   }

doNxtSrcScan:      pxlCount = (short)((dwSrcWidth + 3) & ~3);

                   if (pxlCount < (1792 << 2)) {

                       // Get enough room for this scanline
                       while (freeCount < (1 + (pxlCount >> 2)))
                           NvGetDmaBufferFreeCount(npDev, freeCount, (1 + (pxlCount >> 2)), dmaPusherPutAddress);
                       freeCount -= (1 + (pxlCount >> 2));

                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                           STRETCHED_IMAGE_COLOR_OFFSET | (pxlCount << 16);

                       dmaPusherPutAddress += 1;

                       while (pxlCount >= 64) {

                           pxlCount -= 64;

                           tmpPxls0 = pSrcBits[0];
                           tmpPxls1 = pSrcBits[1];
                           dmaPusherPutAddress[0] = tmpPxls0;
                           tmpPxls2 = pSrcBits[2];
                           dmaPusherPutAddress[1] = tmpPxls1;
                           tmpPxls0 = pSrcBits[3];
                           tmpPxls1 = pSrcBits[4];
                           dmaPusherPutAddress[2] = tmpPxls2;
                           dmaPusherPutAddress[3] = tmpPxls0;
                           tmpPxls2 = pSrcBits[5];
                           tmpPxls0 = pSrcBits[6];
                           dmaPusherPutAddress[4] = tmpPxls1;
                           dmaPusherPutAddress[5] = tmpPxls2;
                           tmpPxls1 = pSrcBits[7];
                           tmpPxls2 = pSrcBits[8];
                           dmaPusherPutAddress[6] = tmpPxls0;
                           dmaPusherPutAddress[7] = tmpPxls1;
                           tmpPxls0 = pSrcBits[9];
                           tmpPxls1 = pSrcBits[10];
                           dmaPusherPutAddress[8] = tmpPxls2;
                           dmaPusherPutAddress[9] = tmpPxls0;
                           tmpPxls2 = pSrcBits[11];
                           tmpPxls0 = pSrcBits[12];
                           dmaPusherPutAddress[10] = tmpPxls1;
                           dmaPusherPutAddress[11] = tmpPxls2;
                           tmpPxls1 = pSrcBits[13];
                           tmpPxls2 = pSrcBits[14];
                           dmaPusherPutAddress[12] = tmpPxls0;
                           dmaPusherPutAddress[13] = tmpPxls1;
                           tmpPxls0 = pSrcBits[15];
                           dmaPusherPutAddress[14] = tmpPxls2;
                           pSrcBits += 16;
                           dmaPusherPutAddress[15] = tmpPxls0;

                           dmaPusherPutAddress += 16;
                       }

                       while (pxlCount >= 32) {

                           pxlCount -= 32;

                           tmpPxls0 = pSrcBits[0];
                           tmpPxls1 = pSrcBits[1];
                           dmaPusherPutAddress[0] = tmpPxls0;
                           tmpPxls2 = pSrcBits[2];
                           dmaPusherPutAddress[1] = tmpPxls1;
                           tmpPxls0 = pSrcBits[3];
                           tmpPxls1 = pSrcBits[4];
                           dmaPusherPutAddress[2] = tmpPxls2;
                           dmaPusherPutAddress[3] = tmpPxls0;
                           tmpPxls2 = pSrcBits[5];
                           tmpPxls0 = pSrcBits[6];
                           dmaPusherPutAddress[4] = tmpPxls1;
                           dmaPusherPutAddress[5] = tmpPxls2;
                           tmpPxls1 = pSrcBits[7];
                           pSrcBits += 8;
                           dmaPusherPutAddress[6] = tmpPxls0;
                           dmaPusherPutAddress[7] = tmpPxls1;

                           dmaPusherPutAddress += 8;
                       }

                       while (pxlCount >= 4) {
                           pxlCount -= 4;
                           tmpPxls0 = pSrcBits[0];
                           pSrcBits += 1;
                           dmaPusherPutAddress[0] = tmpPxls0;

                           dmaPusherPutAddress += 1;
                       }

                   } else { /* more than 1792 dwords per scanline */

                       while (pxlCount >= 64) {

                           pxlCount -= 64;

                           while (freeCount < (1 + (64 >> 2)))
                               NvGetDmaBufferFreeCount(npDev, freeCount, (1 + (64 >> 2)), dmaPusherPutAddress);
                           freeCount -= (1 + (64 >> 2));

                           dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                               STRETCHED_IMAGE_COLOR_OFFSET | (64 << 16);

                           dmaPusherPutAddress += 1;

                           tmpPxls0 = pSrcBits[0];
                           tmpPxls1 = pSrcBits[1];
                           dmaPusherPutAddress[0] = tmpPxls0;
                           tmpPxls2 = pSrcBits[2];
                           dmaPusherPutAddress[1] = tmpPxls1;
                           tmpPxls0 = pSrcBits[3];
                           tmpPxls1 = pSrcBits[4];
                           dmaPusherPutAddress[2] = tmpPxls2;
                           dmaPusherPutAddress[3] = tmpPxls0;
                           tmpPxls2 = pSrcBits[5];
                           tmpPxls0 = pSrcBits[6];
                           dmaPusherPutAddress[4] = tmpPxls1;
                           dmaPusherPutAddress[5] = tmpPxls2;
                           tmpPxls1 = pSrcBits[7];
                           tmpPxls2 = pSrcBits[8];
                           dmaPusherPutAddress[6] = tmpPxls0;
                           dmaPusherPutAddress[7] = tmpPxls1;
                           tmpPxls0 = pSrcBits[9];
                           tmpPxls1 = pSrcBits[10];
                           dmaPusherPutAddress[8] = tmpPxls2;
                           dmaPusherPutAddress[9] = tmpPxls0;
                           tmpPxls2 = pSrcBits[11];
                           tmpPxls0 = pSrcBits[12];
                           dmaPusherPutAddress[10] = tmpPxls1;
                           dmaPusherPutAddress[11] = tmpPxls2;
                           tmpPxls1 = pSrcBits[13];
                           tmpPxls2 = pSrcBits[14];
                           dmaPusherPutAddress[12] = tmpPxls0;
                           dmaPusherPutAddress[13] = tmpPxls1;
                           tmpPxls0 = pSrcBits[15];
                           dmaPusherPutAddress[14] = tmpPxls2;
                           pSrcBits += 16;
                           dmaPusherPutAddress[15] = tmpPxls0;

                           dmaPusherPutAddress += 16;
                       }

                       while (pxlCount >= 32) {

                           pxlCount -= 32;

                           while (freeCount < (1 + (32 >> 2)))
                               NvGetDmaBufferFreeCount(npDev, freeCount, (1 + (32 >> 2)), dmaPusherPutAddress);
                           freeCount -= (1 + (32 >> 2));

                           dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                               STRETCHED_IMAGE_COLOR_OFFSET | (32 << 16);

                           dmaPusherPutAddress += 1;

                           tmpPxls0 = pSrcBits[0];
                           tmpPxls1 = pSrcBits[1];
                           dmaPusherPutAddress[0] = tmpPxls0;
                           tmpPxls2 = pSrcBits[2];
                           dmaPusherPutAddress[1] = tmpPxls1;
                           tmpPxls0 = pSrcBits[3];
                           tmpPxls1 = pSrcBits[4];
                           dmaPusherPutAddress[2] = tmpPxls2;
                           dmaPusherPutAddress[3] = tmpPxls0;
                           tmpPxls2 = pSrcBits[5];
                           tmpPxls0 = pSrcBits[6];
                           dmaPusherPutAddress[4] = tmpPxls1;
                           dmaPusherPutAddress[5] = tmpPxls2;
                           tmpPxls1 = pSrcBits[7];
                           pSrcBits += 8;
                           dmaPusherPutAddress[6] = tmpPxls0;
                           dmaPusherPutAddress[7] = tmpPxls1;

                           dmaPusherPutAddress += 8;
                       }

                       if (pxlCount >= 4) {
                           while (freeCount < (1 + (pxlCount >> 2)))
                               NvGetDmaBufferFreeCount(npDev, freeCount, (1 + (pxlCount >> 2)), dmaPusherPutAddress);
                           freeCount -= (1 + (pxlCount >> 2));

                           dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                               STRETCHED_IMAGE_COLOR_OFFSET | (pxlCount << 16);

                           dmaPusherPutAddress++;
                       }

                       while (pxlCount >= 4) {
                           pxlCount -= 4;
                           tmpPxls0 = pSrcBits[0];
                           pSrcBits += 1;
                           dmaPusherPutAddress[0] = tmpPxls0;

                           dmaPusherPutAddress += 1;
                       }
                   }

                   /* Force write combine buffer to flush */
                   pDriverData->NvDmaPusherBufferEnd[0] = 0;
                   /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                   _outp (0x3d0,0);

                   pDriverData->dwDmaPusherFreeCount = freeCount;

                   npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                   if (srcInVideoMemory) {
                       if (--m > 0) {
                           pSrcCurScan += dwSrcPitch;

                           pSrcBits = (unsigned long *)pSrcCurScan;

                           goto doNxtSrcScan;
                       } else {
                           if (dwSrcPitch <= 800) {
                               m = 16;
                               curDstY += deltaY;
                           } else {
                               m = 8;
                               curDstY += (deltaY >> 1);
                           }
                                               /* convert 16.16 to 12.4 */
                           wDstPoint.xy16.y = (short)(curDstY >> 12);

                           // wait for DMA operation to finish
                           while ((volatile)pDmaBufferNotifier->status == NV_IN_PROGRESS);
                       }
                   }    // stretch
                   if (isOverlappingVmem && lpSurfTemp) {
                       // FIXME: wait for blt to complete
                       NVHEAP_FREE(lpSurfTemp);
                   }
               }

               if (srcInVideoMemory) {

                   while (freeCount < 2)
                       NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
                   freeCount -= 2;

                   dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_IMAGE) | 0x40000;
                   dmaPusherPutAddress[1] = NV_DD_IMAGE_FROM_CPU;

                   dmaPusherPutAddress += 2;
               }
            }

            if (dwFlags & DDBLT_KEYSRCOVERRIDE) {
                // disable chroma key
                while (freeCount < 2)
                    NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
                freeCount -= 2;

                dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_TRANSCOLOR) +
                    SET_TRANSCOLOR_OFFSET | 0x40000;
                dmaPusherPutAddress[1] = 0;

                dmaPusherPutAddress += 2;
            }

        } else {
            DPF("BLT     blt not handled by driver");
            return DDHAL_DRIVER_NOTHANDLED;
        }

        // restore pixel depth for z blts
        if (isZBlt) {
            while (freeCount < 2)
                NvGetDmaBufferFreeCount(npDev, freeCount, 2, dmaPusherPutAddress);
            freeCount -= 2;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x40000;
            dmaPusherPutAddress[1] = NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8;

            dmaPusherPutAddress += 2;
        }

    } else if (dwFlags & DDBLT_COLORFILL) {
        dwFillColor = pbd->bltFX.dwFillColor & pDriverData->physicalColorMask;

        while (freeCount < 10)
            NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);
        freeCount -= 10;

        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
            SET_ROP_OFFSET | 0x40000;
        dmaPusherPutAddress[1] = SRCCOPYINDEX;

        dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
            SURFACES_2D_DEST_OFFSET | 0x40000;
        dmaPusherPutAddress[3] = dwDstOffset;
        dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SURFACES) +
            SURFACES_2D_PITCH_OFFSET | 0x40000;
        dmaPusherPutAddress[5] = (dwDstPitch << 16) | dwDstPitch;

        dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
            RECT_AND_TEXT_COLOR1A_OFFSET | 0xC0000;
        dmaPusherPutAddress[7] = dwFillColor;
        dmaPusherPutAddress[8] = asmMergeCoords(wDestXY.xy16.y, wDestXY.xy16.x);
        dmaPusherPutAddress[9] = asmMergeCoords(wXYext.wh16.h, wXYext.wh16.w);

        dmaPusherPutAddress += 10;

    } else if (dwFlags & DDBLT_ZBUFFER) {
        /* Hardware Z buffer fills not currently supported when in 8bpp mode */
        DPF("HARDWARE Z BUFFER BLT FAILED");
        return DDHAL_DRIVER_NOTHANDLED;
    } else {
        DPF("BLT     blt not handled by driver");
        /* We don't handle any other type of BLT operation */
        return DDHAL_DRIVER_NOTHANDLED;
    }

    pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

    /* Force write combine buffer to flush */
    pDriverData->NvDmaPusherBufferEnd[0] = 0;
    /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
    _outp (0x3d0,0);

    pDriverData->dwDmaPusherFreeCount = freeCount;

    npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

    pbd->ddRVal = DD_OK;

    return DDHAL_DRIVER_HANDLED;

} /* Blt8bpp32 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\d3ddebug.c ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: D3DDBG.C                                                          *
*   Debug build stuff for D3D.                                              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       11/18/97 - re-wrote and cleaned up.     *
*                                                                           *
\***************************************************************************/
#include <math.h>
#include <windows.h>
#include "nvd3ddrv.h"

#include "ddrvmem.h"
#include "nv32.h"
#include "nvddobj.h"
#include "d3dinc.h"
#include "nv3ddbg.h"

/*
 * Define global data valid only when DEBUG is defined.
 */
#ifdef  DEBUG
BOOL    dbgShowState    = 0;
BOOL    dbgFlush        = 0x00000000;   // Flush Nothing
DWORD   dbgLevel        = 0x00000000;   // No Debug output.
#endif  // DEBUG

/*
 * Define global data valid only when DBGFRONTRENDER is defined.
 */
#ifdef  DBGFRONTRENDER
BOOL    dbgFrontRender      = 0;
DWORD   dbgFrontRenderPitch = 1024 * 2;
#endif  // DBGFRONTRENDER

/*
 * Define global data valid only when DBGPREVIEWTEX is defined.
 */
#ifdef  DBGPREVIEWTEX
BOOL    dbgPreviewTextureUseBase = 0;
BOOL    dbgPreviewTexture        = 0;
BOOL    dbgPreviewLinearTexture  = 0;
BOOL    dbgMaskAlpha0            = 0;
DWORD   dbgPreviewTexturePitch   = 1024 * 2;
DWORD   dbgSurfaceDepth          = 16;
BOOL    dbgPreviewTextureClearFirst = TRUE;
DWORD   dbgPreviewTextureMagX = 1;
DWORD   dbgPreviewTextureMagY = 1;
#endif  // DBGPREVIEWTEX

/*
 * Define global data valid only when DMAVALIDATE is defined.
 */
#ifdef  DMAVALIDATE
BOOL    dbgValidatePushBuffer       = 0;
DWORD   dbgLastValidatedPushBuffer  = 0;
#endif  // DMAVALIDATE

#ifdef  DEBUG
/*
 *
 */
char szD3DBoolean[][32] =
{
    "FALSE",
    "TRUE",
};
char szD3DShadeMode[][32] =
{
    "NULL",
    "D3DSHADE_FLAT",
    "D3DSHADE_GOURAUD",
    "D3DSHADE_PHONG"
};
char szD3DFillMode[][32] =
{
    "NULL",
    "D3DFILL_POINT",
    "D3DFILL_WIREFRAME",
    "D3DFILL_SOLID"
};
char szD3DTextureFilter[][32] =
{
    "NULL",
    "D3DFILTER_NEAREST",
    "D3DFILTER_LINEAR",
    "D3DFILTER_MIPNEAREST",
    "D3DFILTER_MIPLINEAR",
    "D3DFILTER_LINEARMIPNEAREST",
    "D3DFILTER_LINEARMIPLINEAR"
};
char szD3DBlend[][32] =
{
    "NULL",
    "D3DBLEND_ZERO",
    "D3DBLEND_ONE",
    "D3DBLEND_SRCCOLOR",
    "D3DBLEND_INVSRCCOLOR",
    "D3DBLEND_SRCALPHA",
    "D3DBLEND_INVSRCALPHA",
    "D3DBLEND_DESTALPHA",
    "D3DBLEND_INVDESTALPHA",
    "D3DBLEND_DESTCOLOR",
    "D3DBLEND_INVDESTCOLOR",
    "D3DBLEND_SRCALPHASAT",
    "D3DBLEND_BOTHSRCALPHA",
    "D3DBLEND_BOTHINVSRCALPHA"
};
char szD3DTextureBlend[][32] =
{
    "NULL",
    "D3DTBLEND_DECAL",
    "D3DTBLEND_MODULATE",
    "D3DTBLEND_DECALALPHA",
    "D3DTBLEND_MODULATEALPHA",
    "D3DTBLEND_DECALMASK",
    "D3DTBLEND_MODULATEMASK",
    "D3DTBLEND_COPY",
    "D3DTBLEND_ADD"
};
char szD3DTextureAddress[][32] =
{
    "NULL",
    "D3DTADDRESS_WRAP",
    "D3DTADDRESS_MIRROR",
    "D3DTADDRESS_CLAMP",
    "D3DTADDRESS_BORDER"
};
char szD3DCull[][32] =
{
    "NULL",
    "D3DCULL_NONE",
    "D3DCULL_CW",
    "D3DCULL_CCW"
};
char szD3DCmpFunc[][32] =
{
    "NULL",
    "D3DCMP_NEVER",
    "D3DCMP_LESS",
    "D3DCMP_EQUAL",
    "D3DCMP_LESSEQUAL",
    "D3DCMP_GREATER",
    "D3DCMP_NOTEQUAL",
    "D3DCMP_GREATEREQUAL",
    "D3DCMP_ALWAYS"
};
char szD3DStencilOp[][32] =
{
    "NULL",
    "D3DSTENCILOP_KEEP",
    "D3DSTENCILOP_ZERO",
    "D3DSTENCILOP_REPLACE",
    "D3DSTENCILOP_INCRSAT",
    "D3DSTENCILOP_DECRSAT",
    "D3DSTENCILOP_INVERT",
    "D3DSTENCILOP_INCR",
    "D3DSTENCILOP_DECR"
};
char szD3DFogMode[][32] =
{
    "NULL",
    "D3DFOG_NONE",
    "D3DFOG_EXP",
    "D3DFOG_EXP2",
    "D3DFOG_LINEAR"
};
char szD3DZBufferType[][32] =
{
    "NULL",
    "D3DZB_FALSE",
    "D3DZB_TRUE",
    "D3DZB_USEW"
};
char szD3DAntiAliasMode[][32] =
{
    "NULL",
    "D3DANTIALIAS_NONE",
    "D3DANTIALIAS_SORTDEPENDENT",
    "D3DANTIALIAS_SORTINDEPENDENT"
};
char szD3DTextureOp[][36] =
{
    "NULL",
    "D3DTOP_DISABLE",
    "D3DTOP_SELECTARG1",
    "D3DTOP_SELECTARG2",
    "D3DTOP_MODULATE",
    "D3DTOP_MODULATE2X",
    "D3DTOP_MODULATE4X",
    "D3DTOP_ADD",
    "D3DTOP_ADDSIGNED",
    "D3DTOP_ADDSIGNED2X",
    "D3DTOP_SUBTRACT",
    "D3DTOP_ADDSMOOTH",
    "D3DTOP_BLENDDIFFUSEALPHA",
    "D3DTOP_BLENDTEXTUREALPHA",
    "D3DTOP_BLENDFACTORALPHA",
    "D3DTOP_BLENDTEXTUREALPHAPM",
    "D3DTOP_BLENDCURRENTALPHA",
    "D3DTOP_PREMODULATE",
    "D3DTOP_MODULATEALPHA_ADDCOLOR",
    "D3DTOP_MODULATECOLOR_ADDALPHA",
    "D3DTOP_MODULATEINVALPHA_ADDCOLOR",
    "D3DTOP_MODULATEINVCOLOR_ADDALPHA",
    "D3DTOP_BUMPENVMAP",
    "D3DTOP_BUMPENVMAPLUMINANCE",
    "D3DTOP_DOTPRODUCT3"
};
char szD3DArg[][64] =
{
    "D3DTA_DIFFUSE",
    "D3DTA_CURRENT",
    "D3DTA_TEXTURE",
    "D3DTA_TFACTOR",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "D3DTA_DIFFUSE | D3DTA_COMPLEMENT",
    "D3DTA_CURRENT | D3DTA_COMPLEMENT",
    "D3DTA_TEXTURE | D3DTA_COMPLEMENT",
    "D3DTA_TFACTOR | D3DTA_COMPLEMENT",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "D3DTA_DIFFUSE | D3DTA_ALPHAREPLICATE",
    "D3DTA_CURRENT | D3DTA_ALPHAREPLICATE",
    "D3DTA_TEXTURE | D3DTA_ALPHAREPLICATE",
    "D3DTA_TFACTOR | D3DTA_ALPHAREPLICATE",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "D3DTA_DIFFUSE | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE",
    "D3DTA_CURRENT | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE",
    "D3DTA_TEXTURE | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE",
    "D3DTA_TFACTOR | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID"
};
char szD3DArgModifier[][32] =
{
    "D3DTA_NORMAL",
    "D3DTA_COMPLEMENT",
    "D3DTA_ALPHAREPLICATE"
};
char szD3DTextureMagFilter[][32] =
{
    "NULL",
    "D3DTFG_POINT",
    "D3DTFG_LINEAR",
    "D3DTFG_FLATCUBIC",
    "D3DTFG_GAUSSIANCUBIC",
    "D3DTFG_ANISOTROPIC"
};
char szD3DTextureMinFilter[][32] =
{
    "NULL",
    "D3DTFN_POINT",
    "D3DTFN_LINEAR",
    "D3DTFN_ANISOTROPIC"
};
char szD3DTextureMipFilter[][32] =
{
    "NULL",
    "D3DTFP_POINT",
    "D3DTFP_LINEAR"
};
#endif  // DEBUG


#ifdef  DEBUG
#define START_STR       "NVD3D: "
#define END_STR         "\r\n"
#ifndef WINNT
void __cdecl DPF_LEVEL(DWORD dwLevel, LPSTR szFormat, ...)
{
    char str[256];

    if (dbgLevel & dwLevel)
    {
        lstrcpy(str, START_STR);
        wvsprintf(str+lstrlen(str), szFormat, (LPVOID)(&szFormat+1));
        lstrcat(str, END_STR);
        OutputDebugString(str);
    }
}
#else
void __cdecl DPF_LEVEL(DWORD dwLevel, LPSTR szFormat, ...)
{
    va_list ap;

    if (dbgLevel & dwLevel)
    {
        va_start(ap, szFormat);
        EngDebugPrint(START_STR, szFormat, ap);
        EngDebugPrint("", "\n", ap);
        va_end(ap);
    }
}
#endif // #ifdef WINNT

#endif  // DEBUG


/*
 * Debug routines that are valid only when DEBUG is defined.
 */
#ifdef  DEBUG
void dbgD3DError
(
    void
)
{
    DPF("NV D3D ERROR!!!");
    return;
}

void dbgDisplayContextState
(
    DWORD           dwFlags,
    PNVD3DCONTEXT   pContext
)
{
    if (!dbgShowState)
        return;

    if ((dbgShowState & NVDBG_SHOW_RENDER_STATE)
     && (dwFlags & NVDBG_SHOW_RENDER_STATE))
    {
        DPF("D3D:Context Render State:");
        DPF("    TextureHandle      = %08lx", pContext->dwRenderState[D3DRENDERSTATE_TEXTUREHANDLE]);
        DPF("    AntiAlias          = %s",    szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_ANTIALIAS]]);
        DPF("    TextureAddress     = %s",    szD3DTextureAddress[pContext->dwRenderState[D3DRENDERSTATE_TEXTUREADDRESS]]);
        DPF("    TexturePerspective = %s",    szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE]]);
        DPF("    WrapU              = %s",    szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_WRAPU]]);
        DPF("    WrapV              = %s",    szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_WRAPV]]);
        DPF("    ZEnable            = %s",    szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_ZENABLE]]);
        DPF("    FillMode           = %s",    szD3DFillMode[pContext->dwRenderState[D3DRENDERSTATE_FILLMODE]]);
        DPF("    ShadeMode          = %s",    szD3DShadeMode[pContext->dwRenderState[D3DRENDERSTATE_SHADEMODE]]);
        DPF("    LinePattern        = %08lx", pContext->dwRenderState[D3DRENDERSTATE_LINEPATTERN]);
        DPF("    MonoEnable         = %08lx", pContext->dwRenderState[D3DRENDERSTATE_MONOENABLE]);
        DPF("    Rop2               = %08lx", pContext->dwRenderState[D3DRENDERSTATE_ROP2]);
        DPF("    PlaneMask          = %08lx", pContext->dwRenderState[D3DRENDERSTATE_PLANEMASK]);
        DPF("    ZWriteEnable       = %s",    szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_ZWRITEENABLE]]);
        DPF("    AlphaTestEnable    = %s",    szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_ALPHATESTENABLE]]);
        DPF("    LastPixelEnable    = %s",    szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_LASTPIXEL]]);
        DPF("    TextureMag         = %s",    szD3DTextureFilter[pContext->dwRenderState[D3DRENDERSTATE_TEXTUREMAG]]);
        DPF("    TextureMin         = %s",    szD3DTextureFilter[pContext->dwRenderState[D3DRENDERSTATE_TEXTUREMIN]]);
        DPF("    SrcBlend           = %s",    szD3DBlend[pContext->dwRenderState[D3DRENDERSTATE_SRCBLEND]]);
        DPF("    DstBlend           = %s",    szD3DBlend[pContext->dwRenderState[D3DRENDERSTATE_DESTBLEND]]);
        DPF("    TextureMapBlend    = %s",    szD3DTextureBlend[pContext->dwRenderState[D3DRENDERSTATE_TEXTUREMAPBLEND]]);
        DPF("    CullMode           = %s",    szD3DCull[pContext->dwRenderState[D3DRENDERSTATE_CULLMODE]]);
        DPF("    ZFunc              = %s",    szD3DCmpFunc[pContext->dwRenderState[D3DRENDERSTATE_ZFUNC]]);
        DPF("    AlphaRef           = %08lx", pContext->dwRenderState[D3DRENDERSTATE_ALPHAREF]);
        DPF("    AlphaFunc          = %s",    szD3DCmpFunc[pContext->dwRenderState[D3DRENDERSTATE_ALPHAFUNC]]);
        DPF("    DitherEnable       = %s",    szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_DITHERENABLE]]);
        DPF("    AlphaBlendEnable   = %s",    szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE]]);
        DPF("    FogEnable          = %s",    szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_FOGENABLE]]);
        DPF("    SpecularEnable     = %s",    szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_SPECULARENABLE]]);
        DPF("    ZVisible           = %08lx", pContext->dwRenderState[D3DRENDERSTATE_ZVISIBLE]);
        DPF("    SubPixel           = %08lx", pContext->dwRenderState[D3DRENDERSTATE_SUBPIXEL]);
        DPF("    SubPixelX          = %08lx", pContext->dwRenderState[D3DRENDERSTATE_SUBPIXELX]);
        DPF("    StippledAlpha      = %08lx", pContext->dwRenderState[D3DRENDERSTATE_STIPPLEDALPHA]);
        DPF("    FogColor           = %08lx", pContext->dwRenderState[D3DRENDERSTATE_FOGCOLOR]);
        DPF("    FogTableMode       = %s",    szD3DFogMode[pContext->dwRenderState[D3DRENDERSTATE_FOGTABLEMODE]]);
        DPF("    FogTableStart      = %08lx", pContext->dwRenderState[D3DRENDERSTATE_FOGTABLESTART]);
        DPF("    FogTableEnd        = %08lx", pContext->dwRenderState[D3DRENDERSTATE_FOGTABLEEND]);
        DPF("    FogTableDensity    = %08lx", pContext->dwRenderState[D3DRENDERSTATE_FOGTABLEDENSITY]);
        DPF("    StippledEnable     = %s",    szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_STIPPLEENABLE]]);
        DPF("    EdgeAntiAlias      = %s",    szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_EDGEANTIALIAS]]);
        DPF("    ColorKeyEnable     = %s",    szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_COLORKEYENABLE]]);
        DPF("    BorderColor        = %08lx", pContext->dwRenderState[D3DRENDERSTATE_BORDERCOLOR]);
        DPF("    TextureAddressU    = %s",    szD3DTextureAddress[pContext->dwRenderState[D3DRENDERSTATE_TEXTUREADDRESSU]]);
        DPF("    TextureAddressV    = %s",    szD3DTextureAddress[pContext->dwRenderState[D3DRENDERSTATE_TEXTUREADDRESSV]]);
        DPF("    MipMapLODBias      = %08lx", pContext->dwRenderState[D3DRENDERSTATE_MIPMAPLODBIAS]);
        DPF("    ZBias              = %08lx", pContext->dwRenderState[D3DRENDERSTATE_ZBIAS]);
        DPF("    RangeFogEnable     = %s",    szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_RANGEFOGENABLE]]);
        DPF("    Anisotropy         = %08lx", pContext->dwRenderState[D3DRENDERSTATE_ANISOTROPY]);
        DPF("    FlushBatch         = %08lx", pContext->dwRenderState[D3DRENDERSTATE_FLUSHBATCH]);
#ifdef  NVD3D_DX6
        DPF("    TranslucentSortInd = %08lx", pContext->dwRenderState[D3DRENDERSTATE_TRANSLUCENTSORTINDEPENDENT]);
        DPF("    StencilEnable      = %s",    szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_STENCILENABLE]]);
        DPF("    StencilFail        = %s",    szD3DStencilOp[pContext->dwRenderState[D3DRENDERSTATE_STENCILFAIL]]);
        DPF("    StencilZFail       = %s",    szD3DStencilOp[pContext->dwRenderState[D3DRENDERSTATE_STENCILZFAIL]]);
        DPF("    StencilPass        = %s",    szD3DStencilOp[pContext->dwRenderState[D3DRENDERSTATE_STENCILPASS]]);
        DPF("    StencilFunc        = %s",    szD3DCmpFunc[pContext->dwRenderState[D3DRENDERSTATE_STENCILFUNC]]);
        DPF("    StencilRef         = %08lx", pContext->dwRenderState[D3DRENDERSTATE_STENCILREF]);
        DPF("    StencilMask        = %08lx", pContext->dwRenderState[D3DRENDERSTATE_STENCILMASK]);
        DPF("    StencilWriteMask   = %08lx", pContext->dwRenderState[D3DRENDERSTATE_STENCILWRITEMASK]);
        DPF("    TextureFactor      = %08lx", pContext->dwRenderState[D3DRENDERSTATE_TEXTUREFACTOR]);
        DPF("    Wrap0              = %08lx", pContext->dwRenderState[D3DRENDERSTATE_WRAP0]);
        DPF("    Wrap1              = %08lx", pContext->dwRenderState[D3DRENDERSTATE_WRAP1]);
        DPF("    Wrap2              = %08lx", pContext->dwRenderState[D3DRENDERSTATE_WRAP2]);
        DPF("    Wrap3              = %08lx", pContext->dwRenderState[D3DRENDERSTATE_WRAP3]);
        DPF("    Wrap4              = %08lx", pContext->dwRenderState[D3DRENDERSTATE_WRAP4]);
        DPF("    Wrap5              = %08lx", pContext->dwRenderState[D3DRENDERSTATE_WRAP5]);
        DPF("    Wrap6              = %08lx", pContext->dwRenderState[D3DRENDERSTATE_WRAP6]);
        DPF("    Wrap7              = %08lx", pContext->dwRenderState[D3DRENDERSTATE_WRAP7]);
#endif  // NVD3D_DX6
        DPF("\r\n");
    }
#ifdef  NVD3D_DX6
    if ((dbgShowState & NVDBG_SHOW_MTS_STATE)
     && (dwFlags & NVDBG_SHOW_MTS_STATE))
    {
        DWORD   dwNumStages;
        DWORD   dwStage;

        dwNumStages = (dbgShowState & NVDBG_SHOW_MTS_STATE) >> NVDBG_SHOW_MTS_STATE_SHIFT;
        dwNumStages = (dwNumStages <= NVDBG_SHOW_MTS_STATE_MAX) ? dwNumStages : NVDBG_SHOW_MTS_STATE_MAX;
        for (dwStage = 0; dwStage < dwNumStages; dwStage++)
        {
            DPF("D3D:Texture Stage %d State:", dwStage);
            DPF("    TextureMap     = %08lx", pContext->tssState[dwStage].dwTextureMap);
            DPF("    AddressU       = %s",    szD3DTextureAddress[pContext->tssState[dwStage].dwAddressU]);
            DPF("    AddressV       = %s",    szD3DTextureAddress[pContext->tssState[dwStage].dwAddressV]);
            DPF("    MagFilter      = %s",    szD3DTextureMagFilter[pContext->tssState[dwStage].dwMagFilter]);
            DPF("    MinFilter      = %s",    szD3DTextureMinFilter[pContext->tssState[dwStage].dwMinFilter]);
            DPF("    MipFilter      = %s",    szD3DTextureMipFilter[pContext->tssState[dwStage].dwMipFilter]);
            DPF("    ColorOp        = %s",    szD3DTextureOp[pContext->tssState[dwStage].dwColorOp]);
            DPF("    ColorArg1      = %s",    szD3DArg[pContext->tssState[dwStage].dwColorArg1]);
            DPF("    ColorArg2      = %s",    szD3DArg[pContext->tssState[dwStage].dwColorArg2]);
            DPF("    AlphaOp        = %s",    szD3DTextureOp[pContext->tssState[dwStage].dwAlphaOp]);
            DPF("    AlphaArg1      = %s",    szD3DArg[pContext->tssState[dwStage].dwAlphaArg1]);
            DPF("    AlphaArg2      = %s",    szD3DArg[pContext->tssState[dwStage].dwAlphaArg2]);
            DPF("    BumpEnvMat00   = %08lx", pContext->tssState[dwStage].dwBumpEnvMat00);
            DPF("    BumpEnvMat01   = %08lx", pContext->tssState[dwStage].dwBumpEnvMat01);
            DPF("    BumpEnvMat10   = %08lx", pContext->tssState[dwStage].dwBumpEnvMat10);
            DPF("    BumpEnvMat11   = %08lx", pContext->tssState[dwStage].dwBumpEnvMat11);
            DPF("    TexCoordIndex  = %08lx", pContext->tssState[dwStage].dwTexCoordIndex);
            DPF("    BorderColor    = %08lx", pContext->tssState[dwStage].dwBorderColor);
            DPF("    MipMapLODBias  = %08lx", pContext->tssState[dwStage].dwMipMapLODBias);
            DPF("    MaxMipMapLevel = %08lx", pContext->tssState[dwStage].dwMaxMipLevel);
            DPF("    MaxAnisotropy  = %08lx", pContext->tssState[dwStage].dwMaxAnisotropy);
            DPF("    BumpEnvlScale  = %08lx", pContext->tssState[dwStage].dwBumpEnvlScale);
            DPF("    BumpEnvlOffset = %08lx", pContext->tssState[dwStage].dwBumpEnvlOffset);
            DPF("\r\n");
        }
    }
#endif  // NVD3D_DX6
    if ((dbgShowState & NVDBG_SHOW_DX5_CLASS_STATE)
     && (dwFlags & NVDBG_SHOW_DX5_CLASS_STATE))
    {
        DPF("D3D:NV4 DX5 Class Context State:");
        DPF("    ColorKey           = %08lx", pContext->ctxInnerLoop.dwColorKey);
        DPF("    TextureOffset      = %08lx", pContext->ctxInnerLoop.dwTextureOffset);
        DPF("    Format             = %08lx", pContext->ctxInnerLoop.dwFormat);
        DPF("    Filter             = %08lx", pContext->ctxInnerLoop.dwFilter);
        DPF("    Blend              = %08lx", pContext->ctxInnerLoop.dwBlend);
        DPF("    Control            = %08lx", pContext->ctxInnerLoop.dwControl);
        DPF("    FogColor           = %08lx", pContext->ctxInnerLoop.dwFogColor);
        DPF("\r\n");
    }
#ifdef  NVD3D_DX6
    if ((dbgShowState & NVDBG_SHOW_DX6_CLASS_STATE)
     && (dwFlags & NVDBG_SHOW_DX6_CLASS_STATE))
    {
        DPF("D3D:NV4 DX6 Class Context State:");
        DPF("    TextureOffset[0]   = %08lx", pContext->mtsState.dwTextureOffset[0]);
        DPF("    TextureOffset[1]   = %08lx", pContext->mtsState.dwTextureOffset[1]);
        DPF("    TextureFormat[0]   = %08lx", pContext->mtsState.dwTextureFormat[0]);
        DPF("    TextureFormat[1]   = %08lx", pContext->mtsState.dwTextureFormat[1]);
        DPF("    TextureFilter[0]   = %08lx", pContext->mtsState.dwTextureFilter[0]);
        DPF("    TextureFilter[1]   = %08lx", pContext->mtsState.dwTextureFilter[1]);
        DPF("    Combine0Alpha      = %08lx", pContext->mtsState.dwCombine0Alpha);
        DPF("    Combine0Color      = %08lx", pContext->mtsState.dwCombine0Color);
        DPF("    Combine1Alpha      = %08lx", pContext->mtsState.dwCombine1Alpha);
        DPF("    Combine1Color      = %08lx", pContext->mtsState.dwCombine1Color);
        DPF("    CombineFactor      = %08lx", pContext->mtsState.dwCombineFactor);
        DPF("    Blend              = %08lx", pContext->mtsState.dwBlend);
        DPF("    Control0           = %08lx", pContext->mtsState.dwControl0);
        DPF("    Control1           = %08lx", pContext->mtsState.dwControl1);
        DPF("    Control2           = %08lx", pContext->mtsState.dwControl2);
        DPF("    FogColor           = %08lx", pContext->mtsState.dwFogColor);
        DPF("\r\n");
    }
#endif  // NVD3D_DX6
    if ((dbgShowState & NVDBG_SHOW_SURFACE_STATE)
     && (dwFlags & NVDBG_SHOW_SURFACE_STATE))
    {
        DPF("D3D:NV4 Surface State:");
        DPF("    ClipStart (x, y)   = %04ld, %04ld", pContext->surfaceViewport.clipHorizontal.wX, pContext->surfaceViewport.clipVertical.wY);
        DPF("    ClipSize (w, h)    = %04ld, %04ld", pContext->surfaceViewport.clipHorizontal.wWidth, pContext->surfaceViewport.clipVertical.wHeight);
        DPF("    SurfaceAddr        = %08lx", pContext->dwSurfaceAddr);
        DPF("    SurfaceOffset      = %08lx", pContext->dwSurfaceOffset);
        DPF("    SurfaceOffset      = %04lx", pContext->surfacePitch.wColorPitch);
        DPF("    SurfaceFormat      = %08lx", pContext->dwSurfaceFormat);
        DPF("    Z-BufferAddr       = %08lx", pContext->ZBufferAddr);
        DPF("    Z-BufferOffset     = %08lx", pContext->ZBufferOffset);
        DPF("    Z-BufferPitch      = %04lx", pContext->surfacePitch.wZetaPitch);
        DPF("\r\n");
    }
    return;
}

void dbgDisplayDrawPrimitives2Info
(
    BYTE bCommand,
    WORD wCommandCount
)
{
    if(!(dbgShowState & NVDBG_SHOW_DRAWPRIM2_INFO))
    {
        return;
    }

    switch(bCommand)
    {

    case D3DDP2OP_POINTS:
        DPF("D3D:D3DDP2OP_POINTS : %08lx", (DWORD)wCommandCount);
        break;
    case D3DDP2OP_INDEXEDLINELIST:
        DPF("D3DDP2OP_INDEXEDLINELIST : %08lx", (DWORD)wCommandCount);
        break;
    case D3DDP2OP_INDEXEDTRIANGLELIST:
        DPF("D3DDP2OP_INDEXEDTRIANGLELIST : %08lx", (DWORD)wCommandCount);
        break;
    case D3DDP2OP_RENDERSTATE:
        DPF("D3DDP2OP_RENDERSTATE : %08lx", (DWORD)wCommandCount);
        break;
    case D3DDP2OP_LINELIST:
        DPF("D3DDP2OP_LINELIST : %08lx", (DWORD)wCommandCount);
        break;
    case D3DDP2OP_LINESTRIP:
        DPF("D3DDP2OP_LINESTRIP : %08lx", (DWORD)wCommandCount);
        break;
    case D3DDP2OP_INDEXEDLINESTRIP:
        DPF("D3DDP2OP_INDEXEDLINESTRIP : %08lx", (DWORD)wCommandCount);
        break;
    case D3DDP2OP_TRIANGLELIST:
        DPF("D3DDP2OP_TRIANGLELIST : %08lx", (DWORD)wCommandCount);
        break;
    case D3DDP2OP_TRIANGLESTRIP:
        DPF("D3DDP2OP_TRIANGLESTRIP : %08lx", (DWORD)wCommandCount);
        break;
    case D3DDP2OP_INDEXEDTRIANGLESTRIP:
        DPF("D3DDP2OP_INDEXEDTRIANGLESTRIP : %08lx", (DWORD)wCommandCount);
        break;
    case D3DDP2OP_TRIANGLEFAN:
        DPF("D3DDP2OP_TRIANGLEFAN : %08lx", (DWORD)wCommandCount);
        break;
    case D3DDP2OP_INDEXEDTRIANGLEFAN:
        DPF("D3DDP2OP_INDEXEDTRIANGLEFAN : %08lx", (DWORD)wCommandCount);
        break;
    case D3DDP2OP_TRIANGLEFAN_IMM:
        DPF("D3DDP2OP_TRIANGLEFAN_IMM : %08lx", (DWORD)wCommandCount);
        break;
    case D3DDP2OP_LINELIST_IMM:
        DPF("D3DDP2OP_LINELIST_IMM : %08lx", (DWORD)wCommandCount);
        break;
    case D3DDP2OP_TEXTURESTAGESTATE:
        DPF("D3DDP2OP_TEXTURESTAGESTATE : %08lx", (DWORD)wCommandCount);
        break;
    case D3DDP2OP_INDEXEDTRIANGLELIST2:
        DPF("D3DDP2OP_INDEXEDTRIANGLELIST2 : %08lx", (DWORD)wCommandCount);
        break;
    case D3DDP2OP_INDEXEDLINELIST2:
        DPF("D3DDP2OP_INDEXEDLINELIST2 : %08lx", (DWORD)wCommandCount);
        break;
    case D3DDP2OP_VIEWPORTINFO:
        DPF("D3DDP2OP_VIEWPORTINFO : %08lx", (DWORD)wCommandCount);
        break;
    default:
        DPF("D3DDP2OP_UNKNOWN : Command = %08lx", (DWORD)bCommand);
        break;
    }

/*
    switch(bCommand)
    {
        BOOL didIPrintAnything = 0;

    case D3DDP2OP_POINTS:
    case D3DDP2OP_INDEXEDLINELIST:
    case D3DDP2OP_INDEXEDTRIANGLELIST:
    case D3DDP2OP_LINELIST:
    case D3DDP2OP_LINESTRIP:
    case D3DDP2OP_INDEXEDLINESTRIP:
    case D3DDP2OP_TRIANGLELIST:
    case D3DDP2OP_TRIANGLESTRIP:
    case D3DDP2OP_INDEXEDTRIANGLESTRIP:
    case D3DDP2OP_TRIANGLEFAN:
    case D3DDP2OP_INDEXEDTRIANGLEFAN:
    case D3DDP2OP_TRIANGLEFAN_IMM:
    case D3DDP2OP_LINELIST_IMM:
    case D3DDP2OP_INDEXEDTRIANGLELIST2:
    case D3DDP2OP_INDEXEDLINELIST2:

        // profiling -paul
        if(pCurrentContext->dwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE] == 1 &&
           pCurrentContext->dwRenderState[D3DRENDERSTATE_FOGENABLE] == 1)
        {
            DPF("*** ALPHA FOG ***");
            didIPrintAnything = 1;
        }
        if(pCurrentContext->dwRenderState[D3DRENDERSTATE_SPECULARENABLE] == 1)
        {
            DPF("*** SPECULAR ***");
            didIPrintAnything = 1;
        }
        if(pCurrentContext->tssState[0].dwMipFilter == D3DTFP_LINEAR)
        {
            DPF("*** TRILINEAR MIPMAPPING ***");
            didIPrintAnything = 1;
        }
        if(pCurrentContext->tssState[1].dwColorOp != D3DTOP_DISABLE ||
           pCurrentContext->tssState[1].dwAlphaOp != D3DTOP_DISABLE)
        {

        }
        if(didIPrintAnything)
        {
            DPF(" "); DPF(" ");
        }

        break;
    default:
        break;
    }
*/
}

void dbgDisplayVertexData
(
    DWORD   sx,
    DWORD   sy,
    DWORD   sz,
    DWORD   rhw,
    DWORD   color,
    DWORD   specular,
    DWORD   tu,
    DWORD   tv
)
{
    if (dbgShowState & NVDBG_SHOW_VERTICES)
    {
        float f;
        int i, frac;
        DPF("D3D:NV4 Vertex Data:");
        f = *(float *)&sx;    i = (int)f;      frac = (int)(100.0*(f-i));
        DPF("    X        = %08lx ~= %d.%02d", sx, i, frac);
        f = *(float *)&sy;    i = (int)f;      frac = (int)(100.0*(f-i));
        DPF("    Y        = %08lx ~= %d.%02d", sy, i, frac);
        f = *(float *)&sz;    i = (int)f;      frac = (int)(100.0*(f-i));
        DPF("    Z        = %08lx ~= %d.%02d", sz, i, frac);
        f = *(float *)&rhw;   i = (int)f;      frac = (int)(100.0*(f-i));
        DPF("    RHW      = %08lx ~= %d.%02d", rhw, i, frac);
        DPF("    Color    = %08lx", color);
        DPF("    Specular = %08lx", specular);
        f = *(float *)&tu;    i = (int)f;      frac = (int)(100.0*(f-i));
        DPF("    U        = %08lx ~= %d.%02d", tu, i, frac);
        f = *(float *)&tv;    i = (int)f;      frac = (int)(100.0*(f-i));
        DPF("    V        = %08lx ~= %d.%02d", tv, i, frac);
        DPF("\r\n");
    }
    return;
}

/*
 * Routine to test the push buffers ability to function.
 */
BOOL dbgTestPushBuffer
(
    PNVD3DCONTEXT   pContext
)
{
    return (TRUE);
}
BOOL dbgValidateControlRegisters
(
    PNVD3DCONTEXT   pContext
)
{
    DWORD   drfValue;
    /*
     * Validate the Format register.
     */
    drfValue = DRF_VAL(054, _FORMAT, _CONTEXT_DMA, pContext->ctxInnerLoop.dwFormat);
    if ((drfValue != NV054_FORMAT_CONTEXT_DMA_A)
     && (drfValue != NV054_FORMAT_CONTEXT_DMA_B))
    {
        DPF("dbgValidateControlRegisters: NV054_FORMAT_CONTEXT_DMA field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FORMAT, _COLORKEYENABLE, pContext->ctxInnerLoop.dwFormat);
    if ((drfValue != NV054_FORMAT_COLORKEYENABLE_FALSE)
     && (drfValue != NV054_FORMAT_COLORKEYENABLE_TRUE))
    {
        DPF("dbgValidateControlRegisters: NV054_FORMAT_COLORKEYENABLE field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FORMAT, _ORIGIN_ZOH, pContext->ctxInnerLoop.dwFormat);
    if ((drfValue != NV054_FORMAT_ORIGIN_ZOH_CENTER)
     && (drfValue != NV054_FORMAT_ORIGIN_ZOH_CORNER))
    {
        DPF("dbgValidateControlRegisters: NV054_FORMAT__ORIGIN_ZOH field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FORMAT, _ORIGIN_FOH, pContext->ctxInnerLoop.dwFormat);
    if ((drfValue != NV054_FORMAT_ORIGIN_FOH_CENTER)
     && (drfValue != NV054_FORMAT_ORIGIN_FOH_CORNER))
    {
        DPF("dbgValidateControlRegisters: NV054_FORMAT__ORIGIN_FOH field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FORMAT, _COLOR, pContext->ctxInnerLoop.dwFormat);
    if ((drfValue != NV054_FORMAT_COLOR_LE_Y8)
     && (drfValue != NV054_FORMAT_COLOR_LE_A1R5G5B5)
     && (drfValue != NV054_FORMAT_COLOR_LE_X1R5G5B5)
     && (drfValue != NV054_FORMAT_COLOR_LE_A4R4G4B4)
     && (drfValue != NV054_FORMAT_COLOR_LE_R5G6B5)
     && (drfValue != NV054_FORMAT_COLOR_LE_A8R8G8B8)
     && (drfValue != NV054_FORMAT_COLOR_LE_X8R8G8B8))
    {
        DPF("dbgValidateControlRegisters: NV054_FORMAT_COLOR field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
//    drfValue = DRF_VAL(054, _FORMAT, _MIPMAP_LEVELS, pContext->ctxInnerLoop.dwFormat);
//    if (drfValue )
//    {
//        DPF("dbgValidateControlRegisters: NV054_FORMAT_MIPMAP_LEVELS field invalid 0x%08lx", drfValue);
//        dbgD3DError();
//    }
    drfValue = DRF_VAL(054, _FORMAT, _BASE_SIZE_U, pContext->ctxInnerLoop.dwFormat);
    if ((drfValue != NV054_FORMAT_BASE_SIZE_U_1)
     && (drfValue != NV054_FORMAT_BASE_SIZE_U_2)
     && (drfValue != NV054_FORMAT_BASE_SIZE_U_4)
     && (drfValue != NV054_FORMAT_BASE_SIZE_U_8)
     && (drfValue != NV054_FORMAT_BASE_SIZE_U_16)
     && (drfValue != NV054_FORMAT_BASE_SIZE_U_32)
     && (drfValue != NV054_FORMAT_BASE_SIZE_U_64)
     && (drfValue != NV054_FORMAT_BASE_SIZE_U_128)
     && (drfValue != NV054_FORMAT_BASE_SIZE_U_256)
     && (drfValue != NV054_FORMAT_BASE_SIZE_U_512)
     && (drfValue != NV054_FORMAT_BASE_SIZE_U_1024)
     && (drfValue != NV054_FORMAT_BASE_SIZE_U_2048))
    {
        DPF("dbgValidateControlRegisters: NV054_FORMAT_BASE_SIZE_U field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FORMAT, _BASE_SIZE_V, pContext->ctxInnerLoop.dwFormat);
    if ((drfValue != NV054_FORMAT_BASE_SIZE_V_1)
     && (drfValue != NV054_FORMAT_BASE_SIZE_V_2)
     && (drfValue != NV054_FORMAT_BASE_SIZE_V_4)
     && (drfValue != NV054_FORMAT_BASE_SIZE_V_8)
     && (drfValue != NV054_FORMAT_BASE_SIZE_V_16)
     && (drfValue != NV054_FORMAT_BASE_SIZE_V_32)
     && (drfValue != NV054_FORMAT_BASE_SIZE_V_64)
     && (drfValue != NV054_FORMAT_BASE_SIZE_V_128)
     && (drfValue != NV054_FORMAT_BASE_SIZE_V_256)
     && (drfValue != NV054_FORMAT_BASE_SIZE_V_512)
     && (drfValue != NV054_FORMAT_BASE_SIZE_V_1024)
     && (drfValue != NV054_FORMAT_BASE_SIZE_V_2048))
    {
        DPF("dbgValidateControlRegisters: NV054_FORMAT_BASE_SIZE_V field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FORMAT, _TEXTUREADDRESSU, pContext->ctxInnerLoop.dwFormat);
    if ((drfValue != NV054_FORMAT_TEXTUREADDRESSU_WRAP)
     && (drfValue != NV054_FORMAT_TEXTUREADDRESSU_MIRROR)
     && (drfValue != NV054_FORMAT_TEXTUREADDRESSU_CLAMP)
     && (drfValue != NV054_FORMAT_TEXTUREADDRESSU_BORDER))
    {
        DPF("dbgValidateControlRegisters: NV054_FORMAT_TEXTUREADDRESSU field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FORMAT, _WRAPU, pContext->ctxInnerLoop.dwFormat);
    if ((drfValue != NV054_FORMAT_WRAPU_FALSE)
     && (drfValue != NV054_FORMAT_WRAPU_TRUE))
    {
        DPF("dbgValidateControlRegisters: NV054_FORMAT_WRAPU field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FORMAT, _TEXTUREADDRESSV, pContext->ctxInnerLoop.dwFormat);
    if ((drfValue != NV054_FORMAT_TEXTUREADDRESSV_WRAP)
     && (drfValue != NV054_FORMAT_TEXTUREADDRESSV_MIRROR)
     && (drfValue != NV054_FORMAT_TEXTUREADDRESSV_CLAMP)
     && (drfValue != NV054_FORMAT_TEXTUREADDRESSV_BORDER))
    {
        DPF("dbgValidateControlRegisters: NV054_FORMAT_TEXTUREADDRESSV field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FORMAT, _WRAPV, pContext->ctxInnerLoop.dwFormat);
    if ((drfValue != NV054_FORMAT_WRAPV_FALSE)
     && (drfValue != NV054_FORMAT_WRAPV_TRUE))
    {
        DPF("dbgValidateControlRegisters: NV054_FORMAT_WRAPV field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }

    /*
     * Validate the Filter register.
     */
    drfValue = DRF_VAL(054, _FILTER, _MIPMAP_DITHER_ENABLE, pContext->ctxInnerLoop.dwFilter);
    if ((drfValue != NV054_FILTER_MIPMAP_DITHER_ENABLE_FALSE)
     && (drfValue != NV054_FILTER_MIPMAP_DITHER_ENABLE_TRUE))
    {
        DPF("dbgValidateControlRegisters: NV054_FILTER_MIPMAP_DITHER_ENABLE field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FILTER, _TEXTUREMIN, pContext->ctxInnerLoop.dwFilter);
    if ((drfValue != NV054_FILTER_TEXTUREMIN_NEAREST)
     && (drfValue != NV054_FILTER_TEXTUREMIN_LINEAR)
     && (drfValue != NV054_FILTER_TEXTUREMIN_MIPNEAREST)
     && (drfValue != NV054_FILTER_TEXTUREMIN_MIPLINEAR)
     && (drfValue != NV054_FILTER_TEXTUREMIN_LINEARMIPNEAREST)
     && (drfValue != NV054_FILTER_TEXTUREMIN_LINEARMIPLINEAR))
    {
        DPF("dbgValidateControlRegisters: NV054_FILTER_TEXTUREMIN field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FILTER, _ANISOTROPIC_MINIFY_ENABLE, pContext->ctxInnerLoop.dwFilter);
    if ((drfValue != NV054_FILTER_ANISOTROPIC_MINIFY_ENABLE_FALSE)
     && (drfValue != NV054_FILTER_ANISOTROPIC_MINIFY_ENABLE_TRUE))
    {
        DPF("dbgValidateControlRegisters: NV054_FILTER_ANISOTROPIC_MINIFY_ENABLE field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FILTER, _TEXTUREMAG, pContext->ctxInnerLoop.dwFilter);
    if ((drfValue != NV054_FILTER_TEXTUREMAG_NEAREST)
     && (drfValue != NV054_FILTER_TEXTUREMAG_LINEAR)
     && (drfValue != NV054_FILTER_TEXTUREMAG_MIPNEAREST)
     && (drfValue != NV054_FILTER_TEXTUREMAG_MIPLINEAR)
     && (drfValue != NV054_FILTER_TEXTUREMAG_LINEARMIPNEAREST)
     && (drfValue != NV054_FILTER_TEXTUREMAG_LINEARMIPLINEAR))
    {
        DPF("dbgValidateControlRegisters: NV054_FILTER_TEXTUREMAG field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FILTER, _ANISOTROPIC_MAGNIFY_ENABLE, pContext->ctxInnerLoop.dwFilter);
    if ((drfValue != NV054_FILTER_ANISOTROPIC_MAGNIFY_ENABLE_FALSE)
     && (drfValue != NV054_FILTER_ANISOTROPIC_MAGNIFY_ENABLE_TRUE))
    {
        DPF("dbgValidateControlRegisters: NV054_FILTER_ANISOTROPIC_MAGNIFY_ENABLE field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }

    /*
     * Validate the Blend register.
     */
    drfValue = DRF_VAL(054, _BLEND, _TEXTUREMAPBLEND, pContext->ctxInnerLoop.dwBlend);
    if ((drfValue != NV054_BLEND_TEXTUREMAPBLEND_DECAL)
     && (drfValue != NV054_BLEND_TEXTUREMAPBLEND_MODULATE)
     && (drfValue != NV054_BLEND_TEXTUREMAPBLEND_DECALALPHA)
     && (drfValue != NV054_BLEND_TEXTUREMAPBLEND_MODULATEALPHA)
     && (drfValue != NV054_BLEND_TEXTUREMAPBLEND_DECALMASK)
     && (drfValue != NV054_BLEND_TEXTUREMAPBLEND_MODULATEMASK)
     && (drfValue != NV054_BLEND_TEXTUREMAPBLEND_COPY)
     && (drfValue != NV054_BLEND_TEXTUREMAPBLEND_ADD))
    {
        DPF("dbgValidateControlRegisters: NV054_BLEND_TEXTUREMAPBLEND field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _BLEND, _MASK_BIT, pContext->ctxInnerLoop.dwBlend);
    if ((drfValue != NV054_BLEND_MASK_BIT_LSB)
     && (drfValue != NV054_BLEND_MASK_BIT_MSB))
    {
        DPF("dbgValidateControlRegisters: NV054_BLEND_MASK_BIT field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _BLEND, _SHADEMODE, pContext->ctxInnerLoop.dwBlend);
    if ((drfValue != NV054_BLEND_SHADEMODE_FLAT)
     && (drfValue != NV054_BLEND_SHADEMODE_GOURAUD)
     && (drfValue != NV054_BLEND_SHADEMODE_PHONG))
    {
        DPF("dbgValidateControlRegisters: NV054_BLEND_SHADEMODE field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _BLEND, _TEXTUREPERSPECTIVE, pContext->ctxInnerLoop.dwBlend);
    if ((drfValue != NV054_BLEND_TEXTUREPERSPECTIVE_FALSE)
     && (drfValue != NV054_BLEND_TEXTUREPERSPECTIVE_TRUE))
    {
        DPF("dbgValidateControlRegisters: NV054_BLEND_TEXTUREPERSPECTIVE field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _BLEND, _SPECULARENABLE, pContext->ctxInnerLoop.dwBlend);
    if ((drfValue != NV054_BLEND_SPECULARENABLE_FALSE)
     && (drfValue != NV054_BLEND_SPECULARENABLE_TRUE))
    {
        DPF("dbgValidateControlRegisters: NV054_BLEND_SPECULARENABLE field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _BLEND, _FOGENABLE, pContext->ctxInnerLoop.dwBlend);
    if ((drfValue != NV054_BLEND_FOGENABLE_FALSE)
     && (drfValue != NV054_BLEND_FOGENABLE_TRUE))
    {
        DPF("dbgValidateControlRegisters: NV054_BLEND_FOGENABLE field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _BLEND, _ALPHABLENDENABLE, pContext->ctxInnerLoop.dwBlend);
    if ((drfValue != NV054_BLEND_ALPHABLENDENABLE_FALSE)
     && (drfValue != NV054_BLEND_ALPHABLENDENABLE_TRUE))
    {
        DPF("dbgValidateControlRegisters: NV054_BLEND_ALPHABLENDENABLE field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _BLEND, _SRCBLEND, pContext->ctxInnerLoop.dwBlend);
    if ((drfValue != NV054_BLEND_SRCBLEND_ZERO)
     && (drfValue != NV054_BLEND_SRCBLEND_ONE)
     && (drfValue != NV054_BLEND_SRCBLEND_SRCCOLOR)
     && (drfValue != NV054_BLEND_SRCBLEND_INVSRCCOLOR)
     && (drfValue != NV054_BLEND_SRCBLEND_SRCALPHA)
     && (drfValue != NV054_BLEND_SRCBLEND_INVSRCALPHA)
     && (drfValue != NV054_BLEND_SRCBLEND_DESTALPHA)
     && (drfValue != NV054_BLEND_SRCBLEND_INVDESTALPHA)
     && (drfValue != NV054_BLEND_SRCBLEND_DESTCOLOR)
     && (drfValue != NV054_BLEND_SRCBLEND_INVDESTCOLOR)
     && (drfValue != NV054_BLEND_SRCBLEND_SRCALPHASAT))
    {
        DPF("dbgValidateControlRegisters: NV054_BLEND_SRCBLEND field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _BLEND, _DESTBLEND, pContext->ctxInnerLoop.dwBlend);
    if ((drfValue != NV054_BLEND_DESTBLEND_ZERO)
     && (drfValue != NV054_BLEND_DESTBLEND_ONE)
     && (drfValue != NV054_BLEND_DESTBLEND_SRCCOLOR)
     && (drfValue != NV054_BLEND_DESTBLEND_INVSRCCOLOR)
     && (drfValue != NV054_BLEND_DESTBLEND_SRCALPHA)
     && (drfValue != NV054_BLEND_DESTBLEND_INVSRCALPHA)
     && (drfValue != NV054_BLEND_DESTBLEND_DESTALPHA)
     && (drfValue != NV054_BLEND_DESTBLEND_INVDESTALPHA)
     && (drfValue != NV054_BLEND_DESTBLEND_DESTCOLOR)
     && (drfValue != NV054_BLEND_DESTBLEND_INVDESTCOLOR)
     && (drfValue != NV054_BLEND_DESTBLEND_SRCALPHASAT))
    {
        DPF("dbgValidateControlRegisters: NV054_BLEND_DESTBLEND field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }

    /*
     * Validate the Control register.
     */
    drfValue = DRF_VAL(054, _CONTROL, _ALPHAFUNC, pContext->ctxInnerLoop.dwControl);
    if ((drfValue != NV054_CONTROL_ALPHAFUNC_NEVER)
     && (drfValue != NV054_CONTROL_ALPHAFUNC_LESS)
     && (drfValue != NV054_CONTROL_ALPHAFUNC_EQUAL)
     && (drfValue != NV054_CONTROL_ALPHAFUNC_LESSEQUAL)
     && (drfValue != NV054_CONTROL_ALPHAFUNC_GREATER)
     && (drfValue != NV054_CONTROL_ALPHAFUNC_NOTEQUAL)
     && (drfValue != NV054_CONTROL_ALPHAFUNC_GREATEREQUAL)
     && (drfValue != NV054_CONTROL_ALPHAFUNC_ALWAYS))
    {
        DPF("dbgValidateControlRegisters: NV054_CONTROL_ALPHAFUNC field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _CONTROL, _ALPHATESTENABLE, pContext->ctxInnerLoop.dwControl);
    if ((drfValue != NV054_CONTROL_ALPHATESTENABLE_FALSE)
     && (drfValue != NV054_CONTROL_ALPHATESTENABLE_TRUE))
    {
        DPF("dbgValidateControlRegisters: NV054_CONTROL_ALPHATESTENABLE field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _CONTROL, _ZENABLE, pContext->ctxInnerLoop.dwControl);
    if ((drfValue != NV054_CONTROL_ZENABLE_FALSE)
     && (drfValue != NV054_CONTROL_ZENABLE_TRUE))
    {
        DPF("dbgValidateControlRegisters: NV054_CONTROL_ZENABLE field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _CONTROL, _ZFUNC, pContext->ctxInnerLoop.dwControl);
    if ((drfValue != NV054_CONTROL_ZFUNC_NEVER)
     && (drfValue != NV054_CONTROL_ZFUNC_LESS)
     && (drfValue != NV054_CONTROL_ZFUNC_EQUAL)
     && (drfValue != NV054_CONTROL_ZFUNC_LESSEQUAL)
     && (drfValue != NV054_CONTROL_ZFUNC_GREATER)
     && (drfValue != NV054_CONTROL_ZFUNC_NOTEQUAL)
     && (drfValue != NV054_CONTROL_ZFUNC_GREATEREQUAL)
     && (drfValue != NV054_CONTROL_ZFUNC_ALWAYS))
    {
        DPF("dbgValidateControlRegisters: NV054_CONTROL_ZFUNC field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _CONTROL, _CULLMODE, pContext->ctxInnerLoop.dwControl);
    if ((drfValue != NV054_CONTROL_CULLMODE_NONE)
     && (drfValue != NV054_CONTROL_CULLMODE_CW)
     && (drfValue != NV054_CONTROL_CULLMODE_CCW))
    {
        DPF("dbgValidateControlRegisters: NV054_CONTROL_CULLMODE field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _CONTROL, _DITHERENABLE, pContext->ctxInnerLoop.dwControl);
    if ((drfValue != NV054_CONTROL_DITHERENABLE_FALSE)
     && (drfValue != NV054_CONTROL_DITHERENABLE_TRUE))
    {
        DPF("dbgValidateControlRegisters: NV054_CONTROL_DITHERENABLE field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _CONTROL, _Z_PERSPECTIVE_ENABLE, pContext->ctxInnerLoop.dwControl);
    if ((drfValue != NV054_CONTROL_Z_PERSPECTIVE_ENABLE_FALSE)
     && (drfValue != NV054_CONTROL_Z_PERSPECTIVE_ENABLE_TRUE))
    {
        DPF("dbgValidateControlRegisters: NV054_CONTROL_Z_PERSPECTIVE_ENABLE field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _CONTROL, _ZWRITEENABLE, pContext->ctxInnerLoop.dwControl);
    if ((drfValue != NV054_CONTROL_ZWRITEENABLE_FALSE)
     && (drfValue != NV054_CONTROL_ZWRITEENABLE_TRUE))
    {
        DPF("dbgValidateControlRegisters: NV054_CONTROL_ZWRITEENABLE field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _CONTROL, _Z_FORMAT, pContext->ctxInnerLoop.dwControl);
    if ((drfValue != NV054_CONTROL_Z_FORMAT_FIXED)
     && (drfValue != NV054_CONTROL_Z_FORMAT_FLOAT))
    {
        DPF("dbgValidateControlRegisters: NV054_CONTROL_Z_FORMAT field invalid 0x%08lx", drfValue);
        dbgD3DError();
    }
    return (TRUE);
}
#endif  // DEBUG

#ifdef  DBGPREVIEWTEX
void dbgDisplayTexture
(
    PNVD3DCONTEXT   pContext,
    PNVD3DTEXTURE   pTexture
)
{
    // txtodo - support this
    if (dbgPreviewTexture && pTexture)
    {
        LPDDRAWI_DDRAWSURFACE_LCL   lclDDS   = pTexture->lpLcl;
        LPDDRAWI_DDRAWSURFACE_GBL   gblDDS   = pTexture->lpLcl->lpGbl;
        long                        u, v, u0, v0, uu, vv;
        long                        texWidth  = gblDDS->wWidth;
        long                        texHeight = gblDDS->wHeight;
        long                        texPitch  = gblDDS->lPitch;
        long                        fbPitch;
        long                        magX, magY;
        DWORD                       dwNonZeroAlphaCount = 0;

        if (pContext)
        {
            switch (pContext->dwSurfaceFormat & 0x0000000F)
            {
                case NV053_SET_FORMAT_COLOR_LE_X1R5G5B5_Z1R5G5B5:
                case NV053_SET_FORMAT_COLOR_LE_X1R5G5B5_O1R5G5B5:
                case NV053_SET_FORMAT_COLOR_LE_R5G6B5:
                    dbgSurfaceDepth = 16;
                    break;
                case NV053_SET_FORMAT_COLOR_LE_X8R8G8B8_Z8R8G8B8:
                case NV053_SET_FORMAT_COLOR_LE_X8R8G8B8_O8R8G8B8:
                case NV053_SET_FORMAT_COLOR_LE_X1A7R8G8B8_Z1A7R8G8B8:
                case NV053_SET_FORMAT_COLOR_LE_X1A7R8G8B8_O1A7R8G8B8:
                case NV053_SET_FORMAT_COLOR_LE_A8R8G8B8:
                    dbgSurfaceDepth = 32;
                    break;
            }
        }

        NV_D3D_GLOBAL_SAVE();
        nvFlushDmaBuffers();
        NV_D3D_GLOBAL_SETUP();
        if (dbgSurfaceDepth == 16)
        {
            short                       texelSwizzle;
            unsigned short             *texMapSwizzle;
            unsigned short             *fb, *fb0;

#ifdef NV_TEX2
            if (pTexture->dwTextureFlags & NV4_TEXFLAG_USER_MIP_LEVEL)
                texMapSwizzle = (unsigned short *)TEX_SWIZZLE_ADDR(pTexture,pTexture->dwTextureFlags);
#else
            if (pTexture->dwTextureFlags & NV3_TEXTURE_USER_MIP_LEVEL)
                texMapSwizzle = (unsigned short *)pTexture->dwTexturePointer;
#endif
            else
            {
#ifdef NV_TEX2
                texMapSwizzle = (unsigned short *)TEX_SWIZZLE_ADDR(pTexture,pTexture->dwTextureFlags);
#else // !NV_TEX2
                if (pTexture->dwTextureFlags & NV3_TEXTURE_VIDEO_MEMORY)
                    texMapSwizzle = (unsigned short *)(VIDMEM_ADDR(pDriverData->BaseAddress + pTexture->dwTextureOffset));
                else
                {
                    if (pDriverData->GARTLinearBase > 0)
                        texMapSwizzle = (unsigned short *)pTexture->dwTexturePointer;
                    else
                        texMapSwizzle = (unsigned short *)GetPointerTextureHeap(pTexture->dwTextureOffset);
                }
#endif // !NV_TEX2
            }
            fb = fb0 = (dbgPreviewTextureUseBase) ? (unsigned short *)VIDMEM_ADDR(pDriverData->BaseAddress)
                                                  : (unsigned short *)VIDMEM_ADDR(pDriverData->CurrentVisibleSurfaceAddress);
            fbPitch = dbgPreviewTexturePitch;

            // if we can fit it in half the screen width or less,
            // then magnify as requested. otherwise don't
            magX = magY = 1;
            if ((int)(dbgPreviewTextureMagX * texWidth) < (fbPitch >> 2))
                magX = dbgPreviewTextureMagX;
            if ((int)(dbgPreviewTextureMagY * texHeight) < (fbPitch >> 2))
                magY = dbgPreviewTextureMagY;
            if ((magX > 1) || (magY > 1))
                DPF("D3D: DbgDisplayTexture: Texture Preview magnified by %d,%d (x,y)", magX, magY);

            if (dbgPreviewTextureClearFirst)
            {
                short clrColor;
                clrColor = (short)(0xffff * ((double)rand() / RAND_MAX));
                for (v = 0; v < texHeight*magY + 32; v++)
                {
                    for (u = 0; u < texWidth*magX + 32; u++) fb[u] = clrColor;
                    fb += (fbPitch >> 1);
                }
                fb = fb0;
            }

            for (v = 0; v < texHeight; v++)
            {
                V_INTERLEAVE(v0, v, texWidth, texHeight);

                for (vv = 0; vv < magY; vv++)
                {
                    for (u = 0; u < texWidth; u++)
                    {
                        U_INTERLEAVE(u0, u, texWidth, texHeight);
                        texelSwizzle = texMapSwizzle[u0|v0];

                        switch (pTexture->dwTextureColorFormat)
                        {

                        case NV054_FORMAT_COLOR_LE_A1R5G5B5:
                        {
                            if (texelSwizzle & 0x8000)
                                dwNonZeroAlphaCount++;
                            if ((!dbgMaskAlpha0)
                             || (texelSwizzle & 0x8000))
                            {
                                short r, g;
                                r = (texelSwizzle & 0x7C00) << 1;
                                g = (texelSwizzle & 0x03E0) << 1;
                                texelSwizzle = r | g | (texelSwizzle & 0x001F);
                                for (uu=0; uu<magX; uu++) fb[magX*u+uu] = texelSwizzle;
                            }
                            break;
                        }

                        case NV054_FORMAT_COLOR_LE_X1R5G5B5:
                        {
                            short r, g;
                            r = (texelSwizzle & 0x7C00) << 1;
                            g = (texelSwizzle & 0x03E0) << 1;
                            texelSwizzle = r | g | (texelSwizzle & 0x001F);
                            for (uu=0; uu<magX; uu++) fb[magX*u+uu] = texelSwizzle;
                            break;
                        }

                        case NV054_FORMAT_COLOR_LE_A4R4G4B4:
                        {
                            short a, r, g;
                            if (a = texelSwizzle & 0xF000)
                                dwNonZeroAlphaCount++;

                            r = (texelSwizzle & 0x0F00) << 3;
                            g = (texelSwizzle & 0x00F0) << 2;
                            texelSwizzle = ((texelSwizzle & 0x000F) << 1) | r | g;

                            if ((!dbgMaskAlpha0) || (a))
                            {
                                for (uu=0; uu<magX; uu++) fb[magX*u+uu] = texelSwizzle;
                            }
                            break;
                        }

                        case NV054_FORMAT_COLOR_LE_R5G6B5:
                        {
                            for (uu=0; uu<magX; uu++) fb[magX*u+uu] = texelSwizzle;
                            break;
                        }

                        case NV054_FORMAT_COLOR_LE_A8R8G8B8:
                        {
                            DWORD   dwTexel;
                            DWORD   a;
                            SHORT   r, g, b;
                            dwTexel = ((DWORD *)texMapSwizzle)[u0|v0];
                            if (a = (dwTexel & 0xFF000000))
                                dwNonZeroAlphaCount++;

                            r = (SHORT)((dwTexel & 0x00FF0000) >> 8) & 0xF800;
                            g = (SHORT)((dwTexel & 0x0000FF00) >> 5) & 0x07E0;
                            b = (SHORT)((dwTexel & 0x000000FF) >> 3) & 0x001F;
                            texelSwizzle = r | g | b;
                            if ((!dbgMaskAlpha0) || (a))
                            {
                                for (uu=0; uu<magX; uu++) fb[magX*u+uu] = texelSwizzle;
                            }
                            break;
                        }

                        case NV054_FORMAT_COLOR_LE_X8R8G8B8:
                        {
                            DWORD   dwTexel;
                            SHORT   r, g, b;
                            dwTexel = ((DWORD *)texMapSwizzle)[u0|v0];
                            r = (SHORT)((dwTexel & 0x00FF0000) >> 8) & 0xF800;
                            g = (SHORT)((dwTexel & 0x0000FF00) >> 5) & 0x07E0;
                            b = (SHORT)((dwTexel & 0x000000FF) >> 3) & 0x001F;
                            texelSwizzle = r | g | b;
                            for (uu=0; uu<magX; uu++) fb[magX*u+uu] = texelSwizzle;
                            break;
                        }

                        default:
                        {
                            for (uu=0; uu<magX; uu++) fb[magX*u+uu] = texelSwizzle;
                            break;
                        }

                        }  // switch

                    }  // loop on u

                    fb += (fbPitch >> 1);

                }  // loop on vv
            }  // loop on v
        }
        else
        {
            DWORD   texelSwizzle;
            DWORD  *texMapSwizzle;
            DWORD  *fb, *fb0;

#ifdef NV_TEX2
            if (pTexture->dwTextureFlags & NV4_TEXFLAG_USER_MIP_LEVEL)
                texMapSwizzle = (unsigned long *)TEX_SWIZZLE_ADDR(pTexture,pTexture->dwTextureFlags);
#else
            if (pTexture->dwTextureFlags & NV3_TEXTURE_USER_MIP_LEVEL)
                texMapSwizzle = (unsigned long *)pTexture->dwTexturePointer;
#endif
            else
            {
#ifdef NV_TEX2
                texMapSwizzle = (unsigned long *)TEX_SWIZZLE_ADDR(pTexture,pTexture->dwTextureFlags);
#else // !NV_TEX2
                if (pTexture->dwTextureFlags & NV3_TEXTURE_VIDEO_MEMORY)
                    texMapSwizzle = (unsigned long *)(VIDMEM_ADDR(pDriverData->BaseAddress + pTexture->dwTextureOffset));
                else
                {
                    if (pDriverData->GARTLinearBase > 0)
                        texMapSwizzle = (unsigned long *)pTexture->dwTexturePointer;
                    else
                        texMapSwizzle = (unsigned long *)GetPointerTextureHeap(pTexture->dwTextureOffset);
                }
#endif // !NV_TEX2
            }
            fb = fb0 = (dbgPreviewTextureUseBase) ? (DWORD *)VIDMEM_ADDR(pDriverData->BaseAddress)
                                                  : (DWORD *)VIDMEM_ADDR(pDriverData->CurrentVisibleSurfaceAddress);
            fbPitch = dbgPreviewTexturePitch;

            // if we can fit it in half the screen width or less,
            // then magnify as requested. otherwise don't
            magX = magY = 1;
            if ((int)(dbgPreviewTextureMagX * texWidth) < (fbPitch >> 3))
                magX = dbgPreviewTextureMagX;
            if ((int)(dbgPreviewTextureMagY * texHeight) < (fbPitch >> 3))
                magY = dbgPreviewTextureMagY;
            if ((magX > 1) || (magY > 1))
                DPF("D3D: DbgDisplayTexture: Texture Preview magnified by %d,%d (x,y)", magX, magY);

            if (dbgPreviewTextureClearFirst)
            {
                DWORD clrColor;
                clrColor = (DWORD)(0xffffffff * ((float)rand() / RAND_MAX));
                for (v = 0; v < texHeight*magY + 32; v++)
                {
                    for (u = 0; u < texWidth*magX + 32; u++) fb[u] = clrColor;
                    fb += (fbPitch >> 2);
                }
                fb = fb0;
            }

            for (v = 0; v < texHeight; v++)
            {
                V_INTERLEAVE(v0, v, texWidth, texHeight);

                for (vv = 0; vv < magY; vv++)
                {

                    for (u = 0; u < texWidth; u++)
                    {

                        U_INTERLEAVE(u0, u, texWidth, texHeight);

                        switch (pTexture->dwTextureColorFormat)
                        {

                        case NV054_FORMAT_COLOR_LE_A1R5G5B5:
                        {
                            WORD    wTexel;
                            wTexel = ((WORD *)texMapSwizzle)[u0|v0];

                            if (wTexel & 0x8000)
                                dwNonZeroAlphaCount++;
                            if ((!dbgMaskAlpha0)
                             || (wTexel & 0x8000))
                            {
                                texelSwizzle = ((wTexel & 0x7C00) << 9)
                                             | ((wTexel & 0x03E0) << 6)
                                             | ((wTexel & 0x001F) << 3);
                                for (uu=0; uu<magX; uu++) fb[magX*u+uu] = texelSwizzle;
                            }
                            break;
                        }

                        case NV054_FORMAT_COLOR_LE_X1R5G5B5:
                        {
                            WORD    wTexel;
                            wTexel = ((WORD *)texMapSwizzle)[u0|v0];
                            texelSwizzle = ((wTexel & 0x7C00) << 9)
                                         | ((wTexel & 0x03E0) << 6)
                                         | ((wTexel & 0x001F) << 3);
                            for (uu=0; uu<magX; uu++) fb[magX*u+uu] = texelSwizzle;
                            break;
                        }

                        case NV054_FORMAT_COLOR_LE_A4R4G4B4:
                        {
                            short a;
                            WORD    wTexel;
                            wTexel = ((WORD *)texMapSwizzle)[u0|v0];

                            if (a = wTexel & 0xF000)
                                dwNonZeroAlphaCount++;

                            if ((!dbgMaskAlpha0)
                             || (a))
                            {
                                texelSwizzle = ((wTexel & 0x0F00) << 12)
                                             | ((wTexel & 0x00F0) << 8)
                                             | ((wTexel & 0x000F) << 4);
                                for (uu=0; uu<magX; uu++) fb[magX*u+uu] = texelSwizzle;
                            }
                            break;
                        }

                        case NV054_FORMAT_COLOR_LE_R5G6B5:
                        {
                            WORD    wTexel;
                            wTexel = ((WORD *)texMapSwizzle)[u0|v0];

                            texelSwizzle = ((wTexel & 0xF800) << 8)
                                         | ((wTexel & 0x07E0) << 5)
                                         | ((wTexel & 0x001F) << 3);
                            for (uu=0; uu<magX; uu++) fb[magX*u+uu] = texelSwizzle;
                            break;
                        }

                        case NV054_FORMAT_COLOR_LE_A8R8G8B8:
                        {
                            DWORD   a;
                            texelSwizzle = texMapSwizzle[u0|v0];
                            if (a = (texelSwizzle & 0xFF000000))
                                dwNonZeroAlphaCount++;

                            if ((!dbgMaskAlpha0)
                             || (a))
                            {
                                for (uu=0; uu<magX; uu++) fb[magX*u+uu] = texelSwizzle;
                            }
                            break;
                        }

                        case NV054_FORMAT_COLOR_LE_X8R8G8B8:
                        {
                            texelSwizzle = texMapSwizzle[u0|v0];
                            for (uu=0; uu<magX; uu++) fb[magX*u+uu] = texelSwizzle;
                            break;
                        }

                        }  // switch

                    }  // loop on u

                    fb += (fbPitch >> 2);

                }  // loop on vv
            }  // loop on v

        }  // else (32-bit)

        if ((pTexture->dwTextureColorFormat == NV054_FORMAT_COLOR_LE_A1R5G5B5)
         || (pTexture->dwTextureColorFormat == NV054_FORMAT_COLOR_LE_A4R4G4B4)
         || (pTexture->dwTextureColorFormat == NV054_FORMAT_COLOR_LE_A8R8G8B8))
        {
            if (dwNonZeroAlphaCount)
                DPF("D3D:dbgDisplayTexture - Non Zero Alpha Count = %08lx", dwNonZeroAlphaCount);
            else
                DPF("D3D:dbgDisplayTexture - ALPHA TEXTURE HAS NO ALPHA!!!!");
        }
    }

    return;
}

void dbgDisplayLinearTexture
(
    LPDDRAWI_DDRAWSURFACE_LCL   lpLcl,
    LPDDRAWI_DDRAWSURFACE_LCL   lpLclDst,
    DWORD                       dwTextureFormat
)
{
    if (dbgPreviewLinearTexture && lpLcl)
    {
        LPDDRAWI_DDRAWSURFACE_GBL   lpGbl = lpLcl->lpGbl;
        short                       texelLinear;
        unsigned short             *texMapLinear;
        unsigned short             *fb;
        long                        u, v;
        long                        texWidth  = lpGbl->wWidth;
        long                        texHeight = lpGbl->wHeight;
        long                        texPitch  = lpGbl->lPitch;
        long                        fbPitch;
        DWORD                       dwNonZeroAlphaCount = 0;
        DWORD                       dwSrcBitCount;

        texMapLinear = (unsigned short *)lpGbl->fpVidMem;
        fb           = (dbgPreviewTextureUseBase) ? (unsigned short *)VIDMEM_ADDR(pDriverData->BaseAddress) : (unsigned short *)VIDMEM_ADDR(pDriverData->CurrentVisibleSurfaceAddress);
        fbPitch      = dbgPreviewTexturePitch;
        if (lpGbl->ddpfSurface.dwFlags & DDPF_RGB)
            dwSrcBitCount = lpGbl->ddpfSurface.dwRGBBitCount;
        else
            dwSrcBitCount = pDriverData->bi.biBitCount;
#ifndef WINNT // BUGBUG NT5 doesn't appear to support palettized textures
        if (dwSrcBitCount == 8)
        {
            BYTE            bIndex;
            WORD            wColor;
            LPPALETTEENTRY  pPalette;
            unsigned char  *srcTexture;
            if ((!lpLclDst->lpDDPalette)
             || (!lpLclDst->lpDDPalette->lpLcl)
             || (!lpLclDst->lpDDPalette->lpLcl->lpGbl)
             || (!lpLclDst->lpDDPalette->lpLcl->lpGbl->lpColorTable))
            {
                return;
            }
            pPalette = lpLclDst->lpDDPalette->lpLcl->lpGbl->lpColorTable;
            srcTexture = (unsigned char *)texMapLinear;
            for (v = 0; v < texHeight; v++)
            {
                for (u = 0; u < texWidth; u++)
                {
                    bIndex = srcTexture[u];
                    wColor = ((WORD)(pPalette[bIndex].peRed & 0xF8) << 8)
                           | ((WORD)(pPalette[bIndex].peGreen & 0xFC) << 3)
                           | ((WORD)(pPalette[bIndex].peBlue & 0xF8) >> 3);
                    fb[u+264] = wColor;
                }
                srcTexture += texPitch;
                fb         += (fbPitch >> 1);
            }
            return;
        }
#endif // BUGBUG #ifndef WINNT

        for (v = 0; v < texHeight; v++)
        {
            for (u = 0; u < texWidth; u++)
            {
                texelLinear = texMapLinear[u];
                switch (dwTextureFormat)
                {
                    case NV054_FORMAT_COLOR_LE_A1R5G5B5:
                    {
                        if (texelLinear & 0x8000)
                            dwNonZeroAlphaCount++;
                        if ((!dbgMaskAlpha0)
                         || (texelLinear & 0x8000))
                        {
                            short r, g;
                            r = (texelLinear & 0x7C00) << 1;
                            g = (texelLinear & 0x03D0) << 1;
                            texelLinear = r | g | (texelLinear & 0x001F);
                            fb[u+264] = texelLinear;
                        }
                        break;
                    }
                    case NV054_FORMAT_COLOR_LE_X1R5G5B5:
                    {
                        short r, g;
                        r = (texelLinear & 0x7C00) << 1;
                        g = (texelLinear & 0x03D0) << 1;
                        texelLinear = r | g | (texelLinear & 0x001F);
                        fb[u+264] = texelLinear;
                        break;
                    }
                    case NV054_FORMAT_COLOR_LE_A4R4G4B4:
                    {
                        short a, r, g;
                        if (a = texelLinear & 0xF000)
                            dwNonZeroAlphaCount++;

                        r = (texelLinear & 0x0F00) << 3;
                        g = (texelLinear & 0x00F0) << 2;
                        texelLinear = ((texelLinear & 0x000F) << 1) | r | g;

                        if ((!dbgMaskAlpha0)
                         || (a))
                        {
                            fb[u+264] = texelLinear;
                        }
                        break;
                    }
                    case NV054_FORMAT_COLOR_LE_R5G6B5:
                    {
                        fb[u+264] = texelLinear;
                        break;
                    }
                    case NV054_FORMAT_COLOR_LE_A8R8G8B8:
                    {
                        DWORD   dwTexel;
                        DWORD   a;
                        SHORT   r, g, b;
                        dwTexel = ((DWORD *)texMapLinear)[u];
                        if (a = (dwTexel & 0xFF000000))
                            dwNonZeroAlphaCount++;

                        r = (SHORT)((dwTexel & 0x00FF0000) >> 8) & 0xF800;
                        g = (SHORT)((dwTexel & 0x0000FF00) >> 5) & 0x07E0;
                        b = (SHORT)((dwTexel & 0x000000FF) >> 3) & 0x001F;
                        texelLinear = r | g | b;
                        if ((!dbgMaskAlpha0)
                         || (a))
                        {
                            fb[u+264] = texelLinear;
                        }
                        break;
                    }
                    case NV054_FORMAT_COLOR_LE_X8R8G8B8:
                    {
                        DWORD   dwTexel;
                        SHORT   r, g, b;
                        dwTexel = ((DWORD *)texMapLinear)[u];
                        r = (SHORT)((dwTexel & 0x00FF0000) >> 8) & 0xF800;
                        g = (SHORT)((dwTexel & 0x0000FF00) >> 5) & 0x07E0;
                        b = (SHORT)((dwTexel & 0x000000FF) >> 3) & 0x001F;
                        texelLinear = r | g | b;
                        fb[u+264] = texelLinear;
                        break;
                    }
                    default:
                        fb[u+264] = texelLinear;
                        break;

                }
            }
            texMapLinear += (texPitch >> 1);
            fb           += (fbPitch >> 1);
        }
        if ((dwTextureFormat == NV054_FORMAT_COLOR_LE_A1R5G5B5)
         || (dwTextureFormat == NV054_FORMAT_COLOR_LE_A4R4G4B4)
         || (dwTextureFormat == NV054_FORMAT_COLOR_LE_A8R8G8B8))
        {
            if (dwNonZeroAlphaCount)
                DPF("D3D:dbgDisplayTexture - Non Zero Alpha Count = %08lx", dwNonZeroAlphaCount);
            else
                DPF("D3D:dbgDisplayTexture - ALPHA TEXTURE HAS NO ALPHA!!!!");
        }
    }
    return;
}
#endif  // DBGPREVIEWTEX

/*
 * Routines that are valid when DMAVALIDATE is defined.
 */
#ifdef  DMAVALIDATE
void dbgValidatePushBufferError
(
    void
)
{
    DPF("D3D:dbgValidatePushBufferError - Push Buffer Validation Error!!!");
    return;
}
void dbgValidatePushBufferData
(
    void
)
{
    return;
}
#endif  // DMAVALIDATE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\D3dmini.c ===
/*
 * Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: D3DMINI.C                                                         *
*   The direct 3d HAL driver routines are implemented in this module.       *
*   This file is a hardware independant file.                               *
*   DO NOT PUT HARDWARE SPECIFIC CODE IN THIS FILE                          *
*   Hardware specific code can be found in:                                 *
*   nv3mini.c, nv4mini.c, ...                                               *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/02/97 - re-wrote and cleaned up.     *
*       Charles Inman               01/31/98 - Ported for NV4               *
*                                                                           *
\***************************************************************************/
#include <windows.h>
#include "nvd3ddrv.h"
#include "ddrvmem.h"
#include "nv32.h"
#include "d3dinc.h"
#include "nvd3dcap.h"
#include "nvtexfmt.h"
#include "nv3ddbg.h"

/*
 * Miscellaneous Driver Data.
 */
static D3DHAL_GLOBALDRIVERDATA  NvGlobal;

/*
 * Direct3D HAL Callback Table.
 */
static D3DHAL_CALLBACKS NvD3DHALCallbacks =
{
    sizeof(D3DHAL_CALLBACKS),
    /*
     * Device context
     */
    nvContextCreate,            /* Required. */
    nvContextDestroy,           /* Required. */
    nvContextDestroyAll,        /* Required. */
    /*
     * Scene capture
     */
    nvSceneCapture,             /* Optional. */
    /*
     * Execution
     */
    0,                          /* Optional. Not needed if only rasterization */
    0,
#ifndef WINNT
    nvRenderState,              /* Required if no Execute */
    nvRenderPrimitive,          /* Required if no Execute */
#else
    0,
    0,
#endif // #else
    0L,                         /* Reserved, must be zero */
    /*
     * Textures
     */
    nvTextureCreate,            /* If any of these calls are supported, */
    nvTextureDestroy,           /* they must all be. */
    nvTextureSwap,              /* ditto - but can always fail. */
    nvTextureGetSurf,           /* ditto - but can always fail. */
    /*
     * Transform - must be supported if lighting is supported.
     */
    0,                          /* If any of these calls are supported, */
    0,                          /* they must all be. */
    0,                          /* ditto */
    0,                          /* ditto */
    0,                          /* ditto */
    /*
     * Lighting
     */
    0,                          /* If any of these calls are supported, */
    0,                          /* they must all be. */
    0,                          /* ditto */
    0,                          /* ditto */
    0,                          /* ditto */
    /*
     * Pipeline state
     */
#ifndef WINNT
    nvGetState,                 /* Required if implementing Execute. */
#else
    0,
#endif // #else
    /*
     * Reserved
     */
    0L,                         /* Reserved, must be zero */
    0L,                         /* Reserved, must be zero */
    0L,                         /* Reserved, must be zero */
    0L,                         /* Reserved, must be zero */
    0L,                         /* Reserved, must be zero */
    0L,                         /* Reserved, must be zero */
    0L,                         /* Reserved, must be zero */
    0L,                         /* Reserved, must be zero */
    0L,                         /* Reserved, must be zero */
    0L,                         /* Reserved, must be zero */
};

/*
 * Define the NV3 device capabilities structure.
 */
D3DDEVICEDESC_V1 NvCaps =
{
    sizeof(D3DDEVICEDESC_V1),
    NV_DEVDESC_FLAGS,
    NV_COLORMODEL,
    NV_DEVCAPS_FLAGS,
    NV_TRANSFORMCAPS,
    NV_3DCLIPPINGCAPS,
    NV_LIGHTINGCAPS,
    NV_LINECAPS,
    NV_TRICAPS,
    NV_RENDERBITDEPTHCAPS,
    NV_ZBUFFERBITDEPTHCAPS,
    NV_MAXBUFFERSIZE,
    NV_MAXVERTEXCOUNT
};

/*
 * Define supported texture formats.
 */
static DDSURFACEDESC    NvTextureFormats[] =
{
    NV_TEXTURE_FORMATS      /* Texture formats defined in NVTEXFMTS.H */
};

/*
 * Developer Identification String
 * Before sending a pre-release driver to a developer, this data can be modified in the binary to identify
 * the developer it is being sent to.  This will give us an identification mechanism if the driver mysteriously
 * finds it's way on the the net.
 */
BYTE bDeveloperID[32 + 32] =
{
    0x0F, 0xAD, 0xCA, 0xFE, 0xDE, 0xAF, 0xFE, 0xED,
    0xDE, 0xAF, 0xBA, 0xBE, 0xDE, 0xAD, 0xF0, 0x0D,
    0x0B, 0xAD, 0xCA, 0xFE, 0x0D, 0xEA, 0xDF, 0xED,
    0xDE, 0xAD, 0xBA, 0xBE, 0x0B, 0xAD, 0xF0, 0x0D,

    0x61, 0x34, 0x42, 0x34, 0xf6, 0xf4, 0x82, 0xe1,
    0xb7, 0xec, 0x5c, 0x23, 0x82, 0x00, 0x60, 0x84,
    0x67, 0x8c, 0x45, 0x2c, 0x47, 0x31, 0x85, 0x32,
    0x30, 0x05, 0x06, 0x20, 0x93, 0x10, 0x40, 0x92,
};

/*
 * --------------------------------------------------------------------------
 *  Direct 3D HAL driver creation routines.
 *  Functions used to instantiate the 3D portion of the DirectDraw HAL
 *  Will be called (for example) from invokeCreateDriver() from ddsamp.
 *
 *  D3DHALCreateDriver
 *
 *  LPD3DHAL_GLOBALDRIVERDATA* lplpGlobal
 *      - A pointer to a structure containing alot of global information about
 *        our driver.
 *
 *  LPD3DHAL_CALLBACKS* lplpHALCallbacks
 *      - A pointer to a structure we fill in with the callbacks that this
 *        driver supports.
 * --------------------------------------------------------------------------
 */
BOOL __stdcall D3DHALCreateDriver
(
    LPD3DHAL_GLOBALDRIVERDATA  *lplpGlobal,
    LPD3DHAL_CALLBACKS         *lplpHALCallbacks
)
{
    if (!pDriverData->hContexts_gbl)
        if (!CreateItemArrays())
        {
            DPF_LEVEL (NVDBG_LEVEL_ERROR, "Failed to initialize arrays");
            return FALSE;
        }

    /*
     * check if driver is valid
     */
    {
        DWORD i,c;

        for (i = 32,c = 0; i < 64; i++)
        {
            if ((i & 7) == 7)
            {
                c ^= 0x42;
                if ((c ^ bDeveloperID[i]) & 0xfe)
                {
                    DPF_LEVEL (NVDBG_LEVEL_ERROR, "Invalid Driver ID");
                    return FALSE;
                }
                c = 0;
            }
            else
            {
                c ^= bDeveloperID[i];
            }
        }
    }

    /*
     * Get the current registry settings from the hardware specific routine.
     */
    D3DReadRegistry();

    /*
     * Here we fill in the supplied structures.
     */
    memset(&NvGlobal, 0, sizeof(D3DHAL_GLOBALDRIVERDATA));
    NvGlobal.dwSize              = sizeof(D3DHAL_GLOBALDRIVERDATA);
    NvGlobal.hwCaps              = NvCaps;
    NvGlobal.dwNumVertices       = 0;
    NvGlobal.dwNumClipVertices   = 0;
    NvGlobal.dwNumTextureFormats = sizeof(NvTextureFormats)
                                 / sizeof(DDSURFACEDESC);
    NvGlobal.lpTextureFormats    = &NvTextureFormats[0];

    /*
     * Modify the capabilities as neccessary for the registry settings.
     */
    D3DModifyCapabilities(&NvGlobal);

    /*
     * Return the HAL table.
     */
    *lplpGlobal       = &NvGlobal;
    *lplpHALCallbacks = &NvD3DHALCallbacks;
    return (TRUE);
}

/*
 * --------------------------------------------------------------------------
 * Initialization routines.
 * --------------------------------------------------------------------------
 */

/*
 * This routine creates the various dynamic item arrays used by the Direct3D
 * driver for managing contexts and textures. This routine should be called
 * at DLL_PROCESS_ATTACH time from DllMain.
 */
BOOL CreateItemArrays
(
    void
)
{
#ifndef OLDSTUFF
#else
    /*
     * Initialize memory system.
     */
    if (!DDrvItemArrayInit())
    {
        DPF_LEVEL (NVDBG_LEVEL_ERROR, "CreateItemArrays - Failed to initialize memory subsystem");
        return (FALSE);
    }
#endif

    /*
     * Create the D3D context heap.
     */
    if (!nvCreateContextListHeap())
        return (FALSE);

    /*
     * Create the D3D texture heap.
     */
    if (!nvCreateTextureListHeap())
    {
        /*
         * Could not allocate the Texture heap! Cleanup.
         */
        nvDestroyContextListHeap();
#ifndef OLDSTUFF
#else
        DDrvItemArrayFini();
#endif
        return (FALSE);
    }
    return (TRUE);
}

/*
 * --------------------------------------------------------------------------
 * Termination routines.
 * --------------------------------------------------------------------------
 */

/*
 * This routine destroys the various dynamic item arrays used by the
 * Direct3D driver for managing contexts and textures. This routine should
 * be called at DLL_PROCESS_DETACH time from DllMain.
 */
BOOL DestroyItemArrays
(
    void
)
{
    /*
     * Cleanup texture array.
     */
    nvDestroyTextureListHeap();

    /*
     * Cleanup the D3D context heap.
     */
    nvDestroyContextListHeap();

    /*
     * Set all the heap handles back to null.
     */
    pDriverData->hContexts_gbl  = 0;
    pDriverData->hTextures_gbl  = 0;
    pDriverData->hAGPList_gbl   = 0;

#ifndef OLDSTUFF
    return (TRUE);
#else
    /*
     * Cleanup memory.
     */
    return (DDrvItemArrayFini());
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\D3drendr.c ===
/*
 * Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 * (C) Copyright NVIDIA Corporation Inc., 1996,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: D3DRENDR.C                                                        *
*   The Direct 3d Rendereing routines.                                      *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/02/97 - re-wrote and cleaned up.     *
*       Ben de Waal (bdw)           11/06/97 - Linear MipMap xxx            *
*                                                                           *
\***************************************************************************/
#include <math.h>
#include <windows.h>
#include "nvd3ddrv.h"
#include "ddrvmem.h"
#include "nv32.h"
#include "d3dinc.h"
#include "nv3ddbg.h"

/*
 * Dma Pushing loop stats.
 */
DWORD   statDmaSyncLoop      = 0;
DWORD   statDmaSyncOverflow  = 0;
DWORD   statDmaBusyLoop      = 0;
DWORD   statDmaBusyOverflow  = 0;
DWORD   statDmaFlushLoop     = 0;
DWORD   statDmaFlushOverflow = 0;
#ifndef WINNT
/*
 * --------------------------------------------------------------------------
 * nvRenderState
 *
 * LPD3DHAL_RENDERSTATEDATA
 * - Points to the instruction in the execute buffer.
 *
 * We get the count of states to set and then walk the execute buffer
 * handling each one at a time.
 * --------------------------------------------------------------------------
 */
DWORD __stdcall nvRenderState
(
    LPD3DHAL_RENDERSTATEDATA    prd
)
{
    DWORD           i;
    LPBYTE          lpData;
    LPD3DSTATE      lpState;

    /*
     * NOTES:
     * This callback is invoked when a set of render states are changed.
     *
     * Get the pointer to the context this texture is associated with.
     */
    DPF_LEVEL (NVDBG_LEVEL_DDI_ENTRY, "nvRenderState - hContext = %08lx", prd->dwhContext);
    SET_CURRENT_CONTEXT(prd);

    /*
     * Get pointer to global driver. data structure.
     */
    NvSetDriverDataPtrFromContext(pCurrentContext);
    NV_D3D_GLOBAL_SETUP();

    /*
     *
     */
    lpData = (LPBYTE)(((LPDDRAWI_DDRAWSURFACE_INT)prd->lpExeBuf)->lpLcl->lpGbl->fpVidMem);
    for (i = 0, lpState = (LPD3DSTATE)(lpData + prd->dwOffset);
         i < prd->dwCount; i++, lpState++)
    {
        DWORD type = (DWORD) lpState->drstRenderStateType;

        if (IS_OVERRIDE(type))
        {
            DWORD override = GET_OVERRIDE(type);
            if (lpState->dwArg[0])
            {
                DPF_LEVEL (NVDBG_LEVEL_INFO, "nvRenderState - setting override for state %08lx", override);
                STATESET_SET(pCurrentContext->overrides, override);
            }
            else
            {
                DPF_LEVEL (NVDBG_LEVEL_INFO, "nvRenderState, clearing override for state %08lx", override);
                STATESET_CLEAR(pCurrentContext->overrides, override);
            }
            continue;
        }
        if (STATESET_ISSET(pCurrentContext->overrides, type))
        {
            DPF_LEVEL (NVDBG_LEVEL_INFO, "nvRenderState, state %08lx is overridden, ignoring", type);
            continue;
        }
        nvSetContextState(lpState->drstRenderStateType, lpState->dwArg[0], &prd->ddrval);
        if (prd->ddrval != DD_OK)
        {
            NV_D3D_GLOBAL_SAVE();
            return (DDHAL_DRIVER_HANDLED);
        }

    }
    NV_D3D_GLOBAL_SAVE();
    prd->ddrval = DD_OK;
    return (DDHAL_DRIVER_HANDLED);
}
#endif // #ifndef WINNT
DWORD __stdcall nvSetRenderTarget
(
    LPD3DHAL_SETRENDERTARGETDATA    psrtd
)
{
    LPDDRAWI_DDRAWSURFACE_LCL   lpLcl    = 0;
    LPDDRAWI_DDRAWSURFACE_LCL   lpLclZ   = 0;

    /*
     * Get the pointer to the context this texture is associated with.
     */
    DPF_LEVEL (NVDBG_LEVEL_DDI_ENTRY, "nvSetRenderTarget - hContext = %08lx", psrtd->dwhContext);
    SET_CURRENT_CONTEXT(psrtd);

    /*
     * Get pointer to global driver. data structure.
     */
    NvSetDriverDataPtrFromContext(pCurrentContext);

    /*
     * Set the new rendering surface into the D3D context.
     */
    if (!psrtd->lpDDS)
    {
        dbgD3DError();
        psrtd->ddrval = DDERR_CURRENTLYNOTAVAIL;
        return (DDHAL_DRIVER_HANDLED);
    }
    if (!(lpLcl = DDS_LCL(psrtd->lpDDS)))
    {
        dbgD3DError();
        psrtd->ddrval = DDERR_CURRENTLYNOTAVAIL;
        return (DDHAL_DRIVER_HANDLED);
    }
    if (psrtd->lpDDSZ)
        lpLclZ = DDS_LCL(psrtd->lpDDSZ);

    /*
     * Check for an invalid rendering and ZETA sufaces
     * (i.e. system memory surface)
     */
    if (lpLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
    {
        dbgD3DError();
        psrtd->ddrval = DDERR_CURRENTLYNOTAVAIL;
        return (DDHAL_DRIVER_HANDLED);
    }
    if (lpLclZ
     && (lpLclZ->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY))
    {
        dbgD3DError();
        psrtd->ddrval = DDERR_CURRENTLYNOTAVAIL;
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Set the Rendering and Zeta surfaces into the D3D context.
     */
    pCurrentContext->lpLcl  = lpLcl;
    pCurrentContext->lpLclZ = lpLclZ;

    /*
     * Call the hardware specific context surface setup.
     */
    if (!nvSetContextSurface(pCurrentContext))
    {
        /*
         * Generally the only way this fails if if a stencil buffer is
         * being used with a 16 bit rendering target.
         */
        dbgD3DError();
        psrtd->ddrval = DDERR_INVALIDPIXELFORMAT;
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Return invalid pixel format if the z-buffer depth does not match the render target depth.
     */
    if (pCurrentContext->dwContextFlags & NV_CONTEXT_ZETA_BUFFER_MISMATCH)
    {
        dbgD3DError();
        psrtd->ddrval = DDERR_INVALIDPIXELFORMAT;
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Return successfully.
     */
    psrtd->ddrval = DD_OK;
    return DDHAL_DRIVER_HANDLED;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\D3dstate.c ===
/*
 * Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: D3DRENDR.C                                                        *
*   The Direct 3d Rendereing routines.                                      *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/02/97 - re-wrote and cleaned up.     *
*                                                                           *
\***************************************************************************/
#include <windows.h>
#include "ddrawi.h"
#include "d3dhal.h"

DWORD __stdcall nvGetState
(
    LPD3DHAL_GETSTATEDATA   pgsd
)
{
    /*
     * NOTES:
     *
     * This callback is called when Direct3D requires information about
     * the state of a particular stage in the pipeline. If you only handle
     * rasterisation then you only need to respond to D3DHALSTATE_GET_RENDER
     * calls.
     * The state wanted is in pgsd->ddState.drstRenderStateType.
     * Return the answer in pgsd->ddState.dwArg[0].
     */
    if (!pgsd->dwhContext)
    {
        pgsd->ddrval = D3DHAL_CONTEXT_BAD;
        return (DDHAL_DRIVER_HANDLED);
    }
    if (pgsd->dwWhich != D3DHALSTATE_GET_RENDER)
    {
        pgsd->ddrval = DD_OK;
        return (DDHAL_DRIVER_HANDLED);
    }
    pgsd->ddState.dwArg[0] = 1;
    pgsd->ddrval           = DD_OK;
    return (DDHAL_DRIVER_HANDLED);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\D3dTex.c ===
/*
 * Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 * (C) Copyright NVIDIA Corporation Inc., 1996,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: D3DTEX.C                                                          *
*   The Direct 3d texture routines.                                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/02/97 - re-wrote and cleaned up.     *
*       Ben de Waal (bdw)           08/28/97 - enabled locked tex status    *
*                                   09/19/97 - optimize mipmap creation     *
*                                                                           *
\***************************************************************************/

#include <windows.h>
#include "nvd3ddrv.h"
#include "ddrvmem.h"
#include "nv32.h"
#include "nvddobj.h"
#include "d3dinc.h"
#include "nv3ddbg.h"

#ifndef WINNT
FLATPTR EXTERN_DDAPI DDHAL32_VidMemAlloc (LPDDRAWI_DIRECTDRAW_GBL pdrv, int heap, DWORD dwXDim, DWORD dwYDim);
void EXTERN_DDAPI DDHAL32_VidMemFree (LPDDRAWI_DIRECTDRAW_GBL pdrv, int heap, FLATPTR ptr);
#endif // #ifndef WINNT

/*
 * Some statistical data.
 */

// omnitemporal texture counts
DWORD   statTextureOmniCountTotal      = 0;
DWORD   statTextureOmniCountPalette    = 0;

// omnitemporal texture sizes
DWORD   statTextureOmniSizeTotal       = 0;
DWORD   statTextureOmniSizePalette     = 0;

// extant texture counts
DWORD   statTextureCountTotal          = 0;
DWORD   statTextureCountVideo          = 0;
DWORD   statTextureCountAgpHeap        = 0;
DWORD   statTextureCountPciHeap        = 0;
DWORD   statTextureCountCache          = 0;

// extant texture sizes
DWORD   statTextureSizeTotal           = 0;
DWORD   statTextureSizeVideo           = 0;
DWORD   statTextureSizeAgpHeap         = 0;
DWORD   statTextureSizePciHeap         = 0;
DWORD   statTextureSizeCache           = 0;

// texture dimensions
DWORD   statTextureDimensionMinVideo   = 2048;
DWORD   statTextureDimensionMinAgpHeap = 2048;
DWORD   statTextureDimensionMinPciHeap = 2048;
DWORD   statTextureDimensionMinCache   = 2048;
DWORD   statTextureDimensionMaxVideo   = 0;
DWORD   statTextureDimensionMaxAgpHeap = 0;
DWORD   statTextureDimensionMaxPciHeap = 0;
DWORD   statTextureDimensionMaxCache   = 0;

/*
 * --------------------------------------------------------------------------
 * Miscellaneous D3D texture related routines.
 * --------------------------------------------------------------------------
 */
BOOL nvCreateTextureListHeap
(
    void
)
{
    /*
     * Create a global heap to allocate internal D3D Texture data structures out of.
     * The number of D3D Textures available can be adjusted by a setting in the registry.
     * It is set reasonably large by default, so hopefully the registry override will never
     * be needed....but just in case.
     */
#ifndef OLDSTUFF
    pDriverData->hTextures_gbl = (DWORD)HEAPCREATE((pDriverData->regD3DTextureMax * sizeof(NVD3DTEXTURE)));
#else
    pDriverData->hTextures_gbl = (DWORD)HeapCreate(HEAP_SHARED,
                                                   (pDriverData->regD3DTextureMax * sizeof(NVD3DTEXTURE)),
                                                   0);
#endif
    if (!pDriverData->hTextures_gbl)
    {
        dbgD3DError();
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvCreateTextureListHeap - Could not create texture list heap!");
        return (FALSE);
    }
    return (TRUE);
}
BOOL nvDestroyTextureListHeap
(
    void
)
{
    PNVD3DTEXTURE               pTexture;
    PNVD3DTEXTURE               pTextureNext;

    /*
     * If there's no heap currently allocated, then there is no heap to destroy.
     */
    if (!pDriverData->hTextures_gbl)
        return (TRUE);

    /*
     * Free any textures that are still allocated.
     * This will hopefully never happen, because it gets quite complicated if the texture
     * surface that this texture structure is associated with has not been destroyed yet.
     */
    pTexture = (PNVD3DTEXTURE)pDriverData->dwTextureListHead;

    while (pTexture)
    {
        /*
         * Get the pointer to the next texture in the list before actually freeing the
         * memory for this structure.
         */
        pTextureNext = pTexture->pTextureNext;

        /*
         * Before freeing the memory for this texture structure, we will need to get the
         * pointer to the texture surface so that we can zero out the reserved field
         * containing the handle for this structure.  That is, if the texture surface field
         * is still valid.
         */


        /*
         * If the surface is no longer allocated, but the user texture memory is, then
         * free up the memory now.
         */
#ifdef NV_TEX2
        if (pTexture->dwLinearAddr)
        {
            nvTextureFreeLinearSurface (pTexture);
        }
#else // !NV_TEX2
        if ((!(pTexture->dwTextureFlags & NV3_TEXTURE_SURFACE_ALLOCATED))
         && (pTexture->dwTextureFlags & NV3_TEXTURE_USER_ALLOCATED))
        {
            GlobalUnlock(pTexture->hUserTexture);
            GlobalFree(pTexture->hUserTexture);
            pTexture->hUserTexture    = (HANDLE)NULL;
            pTexture->fpUserTexture   = (FLATPTR)NULL;
            pTexture->dwTextureFlags &= ~NV3_TEXTURE_USER_ALLOCATED;
        }
#endif // NV_TEX2

        /*
         * No matter what, if the internal texture memory is still allocated, then
         * free it now.
         */
#ifdef NV_TEX2
        if (TEX_SWIZZLE_ADDR(pTexture,pTexture->dwTextureFlags))
        {
            nvTextureFreeSwizzleSurface (pTexture);
        }
#else // !NV_TEX2
        if (pTexture->dwTextureFlags & NV3_TEXTURE_INTERNAL_ALLOCATED)
        {
            PNVD3DCONTEXT   pContext;

            /*
             * Free the internal texture memory.
             */
            pContext = (PNVD3DCONTEXT)pTexture->hContext;
            nvDestroyInternalTexture(pContext, pTexture);
        }
#endif // NV_TEX2

        /*
         * Zero out the handle field in the texture surface structure if there is still
         * a valid pointer to the surface (which there should only be if the surface
         * wasn't destroyed yet.
         */
        NV_LOCK_TEXTURE_SURFACE(pTexture);
        if ((pTexture->lpLcl)
#ifndef NV_TEX2
         && (pTexture->dwTextureFlags & NV3_TEXTURE_SURFACE_ALLOCATED)
#endif
         ) pTexture->lpLcl->dwReserved1 = (DWORD)NULL;
        NV_UNLOCK_TEXTURE_SURFACE(pTexture);

        /*
         * Zero out the memory so that there's no question about the contents.
         */
        memset(pTexture, 0, sizeof(PNVD3DTEXTURE));

        /*
         * Alrighty, go ahead and free the memory for this texture structure.
         */
#ifndef OLDSTUFF
        HEAPFREE(pDriverData->hTextures_gbl, pTexture);
#else
        HeapFree((HANDLE)pDriverData->hTextures_gbl, 0, pTexture);
#endif
        pDriverData->dwD3DTextureCount--;
        pTexture = pTextureNext;
    }

    /*
     * Destroy the heap.
     */
#ifndef OLDSTUFF
    HEAPDESTROY(pDriverData->hTextures_gbl);
#else
    HeapDestroy((HANDLE)pDriverData->hTextures_gbl);
#endif
    pDriverData->hTextures_gbl = (DWORD)NULL;
    return (TRUE);
}
BOOL nvDestroyTextureStructure
(
    PNVD3DTEXTURE   pTexture
)
{
    /*
     * NOTE: This routine assumes only valid (non-null) texture pointers will be
     *       passed in!!
     * Is there still a surface allocated?
     * This can vary.  It is possible that a structure has been destroyed already
     * (i.e. this is common in the case of full screen applications being minimized
     * and restored)
     */
#ifdef NV_TEX2
    if (!TEX_SWIZZLE_ADDR(pTexture,pTexture->dwTextureFlags) && !pTexture->dwLinearAddr)
#else
#ifdef WINNT
    /*
     * Under WINNT, free up user copy of texture since we are now running
     * in the context of the process which created it (we hope).
     */
    if (pTexture->dwTextureFlags & NV3_TEXTURE_USER_ALLOCATED)
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvDestroyTextureSurface - Free User Texture = %08lx", pTexture->fpUserTexture);
        pTexture->dwTextureFlags &= ~NV3_TEXTURE_USER_ALLOCATED;
        GlobalUnlock(pTexture->hUserTexture);
        GlobalFree(pTexture->hUserTexture);
    }
#endif // #ifdef WINNT
    if (!(pTexture->dwTextureFlags & NV3_TEXTURE_SURFACE_ALLOCATED))
#endif
    {
        /*
         * Perform all neccessary context cleanup.
         */
        pTexture->pid             = 0L;
        pTexture->hContext        = 0L;

        /*
         * The internal data structure has been destroyed, make sure to clear the driver
         * reserved field out so that we don't try and access an invalid internal texture
         * structure.
         * REMOVING THIS LINE IS BAD FOR BENCHMARK TEST 10 AND 19.
         */
        NV_LOCK_TEXTURE_SURFACE(pTexture);
        if (pTexture->lpLcl)
            pTexture->lpLcl->dwReserved1 = 0;
        NV_UNLOCK_TEXTURE_SURFACE(pTexture);

        /*
         * Free the context from the array.
         */
        if (pTexture->pTexturePrev)
            pTexture->pTexturePrev->pTextureNext = pTexture->pTextureNext;
        if (pTexture->pTextureNext)
            pTexture->pTextureNext->pTexturePrev = pTexture->pTexturePrev;
        if (pDriverData->dwTextureListHead == (DWORD)pTexture)
            pDriverData->dwTextureListHead = (DWORD)pTexture->pTextureNext;
#ifndef OLDSTUFF
        HEAPFREE(pDriverData->hTextures_gbl, pTexture);
#else
        HeapFree((HANDLE)pDriverData->hTextures_gbl, 0, (PVOID)pTexture);
#endif
        pDriverData->dwD3DTextureCount--;
    }
    else
    {
        /*
         * Return FALSE if the texture structure was not deallocated.
         */
        return (FALSE);
    }

    /*
     * Return TRUE if the texture structure was actually destroyed.
     */
    return (TRUE);
}
BOOL nvDestroyTextureProcess
(
    DWORD   pid
)
{
    PNVD3DTEXTURE   pTexture;
    PNVD3DTEXTURE   pTextureNext;

    /*
     * Start at the head of the texture list.
     */
    pTexture = (PNVD3DTEXTURE)pDriverData->dwTextureListHead;

    /*
     * Search for all textures belonging to this process.
     */
    while (pTexture)
    {
        /*
         * Get the pointer to the next texture in the list before possibly
         * destroying this texture structure.
         */
        pTextureNext = pTexture->pTextureNext;

        /*
         * Destroy this texture if it belongs to this process.
         */
        if (pTexture->pid == pid)
        {
            /*
             * Mark the texture handle as being deallocated.
             */
#ifdef NV_TEX2
            pTexture->dwTextureFlags &= ~NV4_TEXFLAG_HANDLE_ALLOCATED;
            if (!TEX_SWIZZLE_ADDR(pTexture,pTexture->dwTextureFlags))
#else
            pTexture->dwTextureFlags &= ~NV3_TEXTURE_HANDLE_ALLOCATED;
            if (!(pTexture->dwTextureFlags & NV3_TEXTURE_SURFACE_ALLOCATED))
#endif
                pTexture->lpLcl = 0;

            nvDestroyTextureStructure(pTexture);
        }

        /*
         * Set the current texture to the next texture in the list.
         */
        pTexture = pTextureNext;
    }
    return (TRUE);
}
BOOL nvDestroyTextureContext
(
    DWORD   hContext
)
{
    PNVD3DTEXTURE   pTexture;
    PNVD3DTEXTURE   pTextureNext;

    /*
     * Start at the head of the texture list.
     */
    pTexture = (PNVD3DTEXTURE)pDriverData->dwTextureListHead;

    /*
     * Search for all textures belonging to this context.
     */
    while (pTexture)
    {
        /*
         * Get the pointer to the next texture in the list before possibly
         * destroying this texture structure.
         */
        pTextureNext = pTexture->pTextureNext;

        /*
         * Destroy this texture if it belongs to this process.
         */
        if (pTexture->hContext == hContext)
        {
#ifndef WINNT
            /*
             * Mark the texture handle as being deallocated.
             */
#ifdef NV_TEX2
            pTexture->dwTextureFlags &= ~NV4_TEXFLAG_HANDLE_ALLOCATED;
#else
            pTexture->dwTextureFlags &= ~NV3_TEXTURE_HANDLE_ALLOCATED;
#endif
            nvDestroyTextureStructure(pTexture);
#else
            /*
             * We might not be running in the proper context to
             * free the user mode copy of the texture. Defer
             * destruction of the surface til the texture is
             * explicitly destroyed via DestroySurface. Get rid
             * of the context ptr as the context is about to
             * be destroyed.
             */
            pTexture->hContext = 0;
#endif // #ifndef WINNT
        }

        /*
         * Set the current texture to the next texture in the list.
         */
        pTexture = pTextureNext;
    }
    return (TRUE);
}

/*
 * --------------------------------------------------------------------------
 * D3D HAL texture callback routines
 * --------------------------------------------------------------------------
 */
DWORD __stdcall nvTextureCreate
(
    LPD3DHAL_TEXTURECREATEDATA  ptcd
)
{
    HDDRVITEM                   hTexture;
    PNVD3DTEXTURE               pTexture = 0;
    LPDDRAWI_DDRAWSURFACE_LCL   lpLcl;

    /*
     * NOTES:
     *
     * This callback is invoked when a texture is to be created from a
     * DirectDrawSurface.
     * We must pass back the created handle.
     *
     * Get the pointer to the context this texture is associated with.
     */
    DPF_LEVEL (NVDBG_LEVEL_DDI_ENTRY, "nvTextureCreate - hContext = %08lx", ptcd->dwhContext);
    pCurrentContext = (PNVD3DCONTEXT)ptcd->dwhContext;
    if (!pCurrentContext)
    {
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvTextureCreate - Bad Context");
        dbgD3DError();
        ptcd->ddrval = D3DHAL_CONTEXT_BAD;
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Validate the parameters of the texture being created.
     */
#ifndef WINNT
    lpLcl = ((LPDDRAWI_DDRAWSURFACE_INT)ptcd->lpDDS)->lpLcl;
#else
     lpLcl = EngLockDirectDrawSurface(ptcd->hDDS);
#endif // #ifndef WINNT

    if (!lpLcl)
    {
        DPF_LEVEL(NVDBG_LEVEL_ERROR, ":nvTextureCreate - Texture Create Failed");
        dbgD3DError();
        ptcd->ddrval = D3DERR_TEXTURE_CREATE_FAILED;
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Get pointer to global driver. data structure.
     */
    NvSetDriverDataPtrFromContext(pCurrentContext);

    /*
     * Setup frequently accessed globals.
     */
    NV_D3D_GLOBAL_SETUP();

    /*
     * Try and get a texture pointer based on the value stored in the local surface structure
     * driver reserved field.
     *
     * DUMB APPLICATION ALERT!!!!!
     * This code is going to look really strange, but there is a reason.  Believe it or not,
     * an application actually exists (Nightmare Creatures by Kalisto) that does not work if
     * the handle returned has bit 31 set.  Because of where the memory for our texture structures
     * is located, the high bit is always set, but I don't want to just blindly assume that this
     * is always going to be the case.  So, what I'm going to do is mask off the high bit of the
     * texture structure and return the remaining 31 bits as the handle, then in places where the
     * application passes in a texture handle, I will take the pointer to the head of the texture
     * list, mask off all but the high bit and OR it in with the handle to get the pointer to the
     * texture structure.  This should be safe since the texture structures are all allocated from
     * a linearly contiguous heap.
     *
     * bdw: except if this heap straddles the 2GB point where the texture will live with bit 31 set
     *      and the heap base with bit 31 not set. Windows architecture will of course not do such a
     *      thing since the 2GB point splits app and shared memory.
     */
    hTexture = lpLcl->dwReserved1 & 0x7FFFFFFF;
    pTexture = (PNVD3DTEXTURE)lpLcl->dwReserved1;

    /*
     * Is the internal texture data structure already allocated for this texture?
     */
    if (!pTexture)
    {
        /*
         * The internal texture data structure has not been allocated yet. This can
         * happen if the application allocates it's texture handles before it creates the
         * texture surfaces.  (Ziff Davis 3D Winbench)
         * So we have to handle both cases.  If the data structure has not been allocated
         * yet, allocate it here.
         */
#ifndef OLDSTUFF
        hTexture = (HDDRVITEM)HEAPALLOC(pDriverData->hTextures_gbl, sizeof(NVD3DTEXTURE));
#else
        hTexture = (HDDRVITEM)HeapAlloc((HANDLE)pDriverData->hTextures_gbl,
                                        HEAP_ZERO_MEMORY,
                                        sizeof(NVD3DTEXTURE));
#endif
        pTexture = (PNVD3DTEXTURE)hTexture;
        if (!pTexture)
        {
            /*
             * Bad news.  Could not allocate the internal data structure.  No choice but to
             * return an error.
             */
            dbgD3DError();
            DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvTextureCreate - Bad Texture");
            ptcd->ddrval = D3DERR_TEXTURE_CREATE_FAILED;
            return (DDHAL_DRIVER_HANDLED);
        }
        pDriverData->dwD3DTextureCount++;

        /*
         * Store the handle of the internal texture structure in the local surface structure
         * driver reserved field.
         */
        lpLcl->dwReserved1 = hTexture;

        /*
         * Make sure a few key fields are intialized to zero.
         */
/* allocated with HEAP_ZERO_MEMORY - waste of time
        pTexture->hMipBaseTexture  = 0;
        pTexture->dwTextureFlags   = 0;
        pTexture->dwTexturePointer = 0;
        pTexture->dwTextureOffset  = 0;
        pTexture->fpTexture        = 0;
        pTexture->hUserTexture     = 0;
        pTexture->fpUserTexture    = 0;
*/
        pTexture->dwDriverData     = (DWORD)pDriverData;

        /*
         * Update the texture list.
         */
        pTexture->pTexturePrev = (PNVD3DTEXTURE)NULL;
        pTexture->pTextureNext = (PNVD3DTEXTURE)pDriverData->dwTextureListHead;
        if (pTexture->pTextureNext)
            pTexture->pTextureNext->pTexturePrev = pTexture;
        pDriverData->dwTextureListHead = (DWORD)pTexture;
    }

    /*
     * Return the new texture handle.
     */
    DPF_LEVEL(NVDBG_LEVEL_INFO, "nvTextureCreate - New texture handle = %08lx", hTexture);
    ptcd->dwHandle = hTexture;

    /*
     * Initialize the new texture header.
     */
    pTexture->pid      = pCurrentContext->pid;
    pTexture->hContext = ptcd->dwhContext;
    pTexture->lpLcl    = lpLcl;
#ifndef WINNT
    pTexture->lpDDS    = ptcd->lpDDS;
#else
    pTexture->hDDS = ptcd->hDDS;
#endif  // #ifndef WINNT

    /*
     * A handle is only ever allocated for the top most level of the mipmap chain.
     * run down the chain and updated the mipmap base texture for each mipmap.
     */
    if ((lpLcl->ddsCaps.dwCaps & DDSCAPS_MIPMAP)
     && (!lpLcl->lpAttachListFrom)
     && (lpLcl->lpAttachList))
    {
        LPDDRAWI_DDRAWSURFACE_LCL   lclMip;
        lclMip = lpLcl->lpAttachList->lpAttached;
        while (lclMip)
        {
            PNVD3DTEXTURE   pMipMap;

            pMipMap = (PNVD3DTEXTURE)lclMip->dwReserved1;
            if (pMipMap)
            {
                pMipMap->hMipBaseTexture = (DWORD)pTexture;
#ifdef NV_TEX2
                pMipMap->dwTextureFlags |= NV4_TEXFLAG_USER_MIP_LEVEL;
#else
                pMipMap->dwTextureFlags |= NV3_TEXTURE_USER_MIP_LEVEL;
#endif
            }
            if (lclMip->lpAttachList)
                lclMip = lclMip->lpAttachList->lpAttached;
            else
                lclMip = 0;
        }
    }

    /*
     * If this is not a user mipmap level then see if the internal texture
     * memory needs to be re-allocated.  For user mip maps, only the base
     * level
     */
#ifdef NV_TEX2
    if (!(pTexture->dwTextureFlags & NV4_TEXFLAG_USER_MIP_LEVEL))
#else
    if (!(pTexture->dwTextureFlags & NV3_TEXTURE_USER_MIP_LEVEL))
#endif
    {
        /*
         * We don't normally want to allocate the internal texture memory here, but there are
         * situations where we need to try.
         * First, if the surface is already allocated but there is no internal memory allocated
         * for it.  Then try and allocate it.
         */
#ifdef NV_TEX2
        if (!TEX_SWIZZLE_ADDR(pTexture,pTexture->dwTextureFlags)
          && pTexture->dwMipMapSizeBytes)
#else
        if ((pTexture->dwTextureFlags & NV3_TEXTURE_SURFACE_ALLOCATED)
         && (!(pTexture->dwTextureFlags & NV3_TEXTURE_INTERNAL_ALLOCATED)))
#endif
        {
#ifdef NV_TEX2
            nvAllocateInternalTexture(pTexture);
            /* txtodo - remove this comment
            nvTextureAllocSwizzleSurface (pTexture,
                                          pTexture->dwMipMapSizeBytes,
                                          pDriverData->GARTLinearBase ? (NV4_TEXLOC_VID | NV4_TEXLOC_AGP)
                                                                      : (NV4_TEXLOC_VID | NV4_TEXLOC_PCI),
                                          pTexture->dwTextureFlags >> NV4_TEXMASK_SWIZZLE_SHIFT);
            pTexture->dwTextureFlags &= ~NV4_TEXFLAG_SWIZZLE_VALID;
            */
#else
            pTexture->dwTexturePointer = 0;
            pTexture->dwTextureOffset  = 0;
            nvAllocateInternalTexture(pTexture);
            pTexture->dwTextureFlags |= NV3_TEXTURE_MODIFIED;
#endif // NV_TEX2
        }

        /*
         * If the texture flags show that the internal texture surface has been allocated and
         * the internal texture is in the PCI system memory texture heap, validate the texture
         * pointer.  If it is invalid, then it must be reallocated.
         */
#ifdef NV_TEX2
        if (TEX_SWIZZLE_FLAGS(pTexture,pTexture->dwTextureFlags) & NV4_TEXLOC_PCI)
#else
        if ((pTexture->dwTextureFlags & NV3_TEXTURE_INTERNAL_ALLOCATED)
         && !(pTexture->dwTextureFlags & NV3_TEXTURE_VIDEO_MEMORY)
         && (pDriverData->GARTLinearBase == 0))
#endif
        {
            /*
             * Validate the PCI system memory texture pointer.
             */
#ifdef NV_TEX2
            if (!GetPointerTextureHeap(TEX_SWIZZLE_OFFSET(pTexture,pTexture->dwTextureFlags)))
#else
            if (!GetPointerTextureHeap(pTexture->dwTextureOffset))
#endif
            {
#ifdef NV_TEX2
                nvTextureAllocSwizzleSurface (pTexture,
                                              pTexture->dwMipMapSizeBytes,
                                              pDriverData->GARTLinearBase ? (NV4_TEXLOC_VID | NV4_TEXLOC_AGP)
                                                                          : (NV4_TEXLOC_VID | NV4_TEXLOC_PCI),
                                              TEX_SWIZZLE_FLAGS(pTexture,pTexture->dwTextureFlags) & NV4_TEXMASK_LOCATION);
                TEX_SWIZZLE_FLAGS(pTexture,pTexture->dwTextureFlags) &= ~NV4_TEXFLAG_VALID;
#else
                pTexture->dwTexturePointer = 0;
                pTexture->dwTextureOffset  = 0;
                nvAllocateInternalTexture(pTexture);
                pTexture->dwTextureFlags |= NV3_TEXTURE_MODIFIED;
#endif // NV_TEX2
            }
        }
    }

    /*
     * Show that the texture has not been loaded yet and that it is not locked.
     */
#ifdef NV_TEX2
    pTexture->dwTextureFlags |= NV4_TEXFLAG_HANDLE_ALLOCATED;
#else
    pTexture->dwTextureFlags |= NV3_TEXTURE_HANDLE_ALLOCATED;
    pTexture->dwTextureFlags &= ~(NV3_TEXTURE_IS_LOCKED | NV3_TEXTURE_MUST_RELOAD);
#endif

    /*
     * Load convert the texture immediately so that hopefully real game speed does not
     * get impacted during actual game play.  This has no effect on the benchmarks, but
     * it can sometimes help out games (like moto racer with the polygon patch).
     */
#ifdef NV_TEX2
    if (!(TEX_SWIZZLE_FLAGS(pTexture,pTexture->dwTextureFlags) & NV4_TEXFLAG_VALID)
      && (pTexture->dwTextureFlags & NV4_TEXFLAG_LINEAR_VALID))
        nvUpdateSwizzleSurface(pTexture);
#else
    if ((pTexture->dwTextureFlags & NV3_TEXTURE_MODIFIED)
     && (pTexture->dwTextureFlags & NV3_TEXTURE_USER_ALLOCATED))
        nvLoadTexture(pTexture);
#endif

    /*
     * Texture creation successful.
     */
    NV_D3D_GLOBAL_SAVE();
    ptcd->ddrval = DD_OK;
    return (DDHAL_DRIVER_HANDLED);
}
DWORD __stdcall nvTextureDestroy
(
    LPD3DHAL_TEXTUREDESTROYDATA ptcd
)
{
    HDDRVITEM       hTexture;
    PNVD3DTEXTURE   pTexture = 0;

    /*
     * DUMB APPLICATION ALERT!!!!!
     * This code is going to look really strange, but there is a reason.  Believe it or not,
     * an application actually exists (Nightmare Creatures by Kalisto) that does not work if
     * the handle returned has bit 31 set.  Because of where the memory for our texture structures
     * is located, the high bit is always set, but I don't want to just blindly assume that this
     * is always going to be the case.  So, what I'm going to do is mask off the high bit of the
     * texture structure and return the remaining 31 bits as the handle, then in places where the
     * application passes in a texture handle, I will take the pointer to the head of the texture
     * list, mask off all but the high bit and OR it in with the handle to get the pointer to the
     * texture structure.  This should be safe since the texture structures are all allocated from
     * a linearly contiguous heap.
     */

    DPF_LEVEL(NVDBG_LEVEL_DDI_ENTRY, "nvTextureDestroy - Destroy texture handle = %08lx", ptcd->dwHandle);

    /*
     * This is a little ugly.  I know however that the handle is supposed to have bit 31
     * set all the time in order to reference it as a pointer.  And I need the pointer to the
     * texture so that I can get the pointer to the global driver data structure out of the
     * surface structure before I can access pDriverData which I would normally use to construct
     * the texture structure pointer.
     */
    hTexture = ptcd->dwHandle | 0x80000000;
    pTexture = (PNVD3DTEXTURE)hTexture;

    /*
     * The order in which the texture handle is allocated/deallocated and the texture
     * surface is created/destroyed can vary based on the application (and also a problem
     * between D3D and DDRAW). Check to see if the internal data structure is still allcocated
     * and destroy it if it still is AND the texture surface has already been destroyed.
     * If the texture surface has not been destroyed yet, then we don't want to destroy the
     * internal texture structure yet.
     */
//    hTexture = ptcd->dwHandle | (pDriverData->dwTextureListHead & 0x80000000);
//    pTexture = (PNVD3DTEXTURE)hTexture;

    /*
     * Perform all the neccessary steps for destroying this texture handle.
     * Destruction of the actual texture data structure is actually
     * dependent on the current state of the texture surface structure.
     */
    if (pTexture)
    {
        /*
         * Get pointer to global driver. data structure.
         */
        pDriverData = (GLOBALDATA *)pTexture->dwDriverData;

        /*
         * Mark the texture handle as being deallocated.
         */
#ifdef NV_TEX2
        pTexture->dwTextureFlags &= ~NV4_TEXFLAG_HANDLE_ALLOCATED;
#else
        pTexture->dwTextureFlags &= ~NV3_TEXTURE_HANDLE_ALLOCATED;
#endif

        /*
         * Destroy the internal texture data structure.
         */
        nvDestroyTextureStructure(pTexture);
    }

    /*
     * Texture destroyed successfully.
     */
    ptcd->ddrval = DD_OK;
    return (DDHAL_DRIVER_HANDLED);
}
DWORD __stdcall nvTextureSwap
(
    LPD3DHAL_TEXTURESWAPDATA    ptsd
)
{
    PNVD3DCONTEXT   pContext  = 0;
    PNVD3DTEXTURE   pTexture1 = 0;
    PNVD3DTEXTURE   pTexture2 = 0;
    NVD3DTEXTURE    texTemp;

    /*
     * DUMB APPLICATION ALERT!!!!!
     * This code is going to look really strange, but there is a reason.  Believe it or not,
     * an application actually exists (Nightmare Creatures by Kalisto) that does not work if
     * the handle returned has bit 31 set.  Because of where the memory for our texture structures
     * is located, the high bit is always set, but I don't want to just blindly assume that this
     * is always going to be the case.  So, what I'm going to do is mask off the high bit of the
     * texture structure and return the remaining 31 bits as the handle, then in places where the
     * application passes in a texture handle, I will take the pointer to the head of the texture
     * list, mask off all but the high bit and OR it in with the handle to get the pointer to the
     * texture structure.  This should be safe since the texture structures are all allocated from
     * a linearly contiguous heap.
     */

    DPF_LEVEL(NVDBG_LEVEL_DDI_ENTRY, "nvTextureSwap - hContext = %08lx", ptsd->dwhContext);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "Swap texture handle 1 = %08lx", ptsd->dwHandle1);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "nvTextureSwap - Swap texture handle 2 = %08lx", ptsd->dwHandle2);

    /*
     * NOTES:
     *
     * This callback is invoked when two texture handles are to be swapped.
     * I.e. the data refered to by the two handles is to be swapped.
     *
     * Get the pointer to the specified context.
     */
    pContext = (PNVD3DCONTEXT)ptsd->dwhContext;
    if (!pContext)
    {
        dbgD3DError();
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvTextureSwap - Bad Context");
        ptsd->ddrval = D3DHAL_CONTEXT_BAD;
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Get pointer to global driver. data structure.
     */
    NvSetDriverDataPtrFromContext(pContext);

    /*
     * Get pointer to first texture.
     */
    pTexture1 = (PNVD3DTEXTURE)(ptsd->dwHandle1 | (pDriverData->dwTextureListHead & 0x80000000));
    if (!pTexture1)
    {
        dbgD3DError();
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvTextureSwap - Bad Texture 1");
        ptsd->ddrval = DDERR_INVALIDPARAMS;
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Get pointer to second texture.
     */
    pTexture2 = (PNVD3DTEXTURE)(ptsd->dwHandle2 | (pDriverData->dwTextureListHead & 0x80000000));
    if (!pTexture2)
    {
        dbgD3DError();
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvTextureSwap - Bad Texture 2");
        ptsd->ddrval = DDERR_INVALIDPARAMS;
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Swap the contents of the internal texture data structures.
     */
    texTemp    = *pTexture1;
    *pTexture1 = *pTexture2;
    *pTexture2 = texTemp;

    /*
     * Restore the original structure list pointers.
     * Even though the contents of the texture structure have been swapped,
     * the positions of the structures in the texture list does not change.
     */
    pTexture2->pTexturePrev = pTexture1->pTexturePrev;
    pTexture2->pTextureNext = pTexture1->pTextureNext;
    pTexture1->pTexturePrev = texTemp.pTexturePrev;
    pTexture1->pTextureNext = texTemp.pTextureNext;
    NV_LOCK_TEXTURE_SURFACE(pTexture1);
#ifdef NV_TEX2
    if ((TEX_SWIZZLE_ADDR(pTexture1,pTexture1->dwTextureFlags))
#else
    if ((pTexture1->dwTextureFlags & NV3_TEXTURE_SURFACE_ALLOCATED)
#endif
     && (pTexture1->lpLcl))
    {
        /*
         * Make sure the handle in the local surface structure is correct
         * after the swap.
         */
        pTexture1->lpLcl->dwReserved1 = ptsd->dwHandle1 | (pDriverData->dwTextureListHead & 0x80000000);

        /*
         * If the texture being swapped is the base of a user mipmap chain,
         * then it is neccessary to traverse the chain and update the mipmap base texture
         * field for each mipmap in the chain.
         */
        if ((pTexture1->lpLcl->ddsCaps.dwCaps & DDSCAPS_MIPMAP)
         && (pTexture1->lpLcl->lpAttachList))
        {
            LPDDRAWI_DDRAWSURFACE_LCL   lclMip;

            lclMip = pTexture1->lpLcl->lpAttachList->lpAttached;
            while (lclMip)
            {
                PNVD3DTEXTURE   pMipMap;

                pMipMap = (PNVD3DTEXTURE)lclMip->dwReserved1;
                if (pMipMap)
                    pMipMap->hMipBaseTexture = (DWORD)pTexture1;
                if (lclMip->lpAttachList)
                    lclMip = lclMip->lpAttachList->lpAttached;
                else
                    lclMip = 0;
            }
        }
    }
    NV_LOCK_TEXTURE_SURFACE(pTexture2);
#ifdef NV_TEX2
    if ((TEX_SWIZZLE_ADDR(pTexture2,pTexture2->dwTextureFlags))
#else
    if ((pTexture2->dwTextureFlags & NV3_TEXTURE_SURFACE_ALLOCATED)
#endif
     && (pTexture2->lpLcl))
    {
        /*
         * Make sure the handle in the local surface structure is correct
         * after the swap.
         */
        pTexture2->lpLcl->dwReserved1 = ptsd->dwHandle2 | (pDriverData->dwTextureListHead & 0x80000000);

        /*
         * If the texture being swapped is the base of a user mipmap chain,
         * then it is neccessary to traverse the chain and update the mipmap base texture
         * field for each mipmap in the chain.
         */
        if ((pTexture2->lpLcl->ddsCaps.dwCaps & DDSCAPS_MIPMAP)
         && (pTexture2->lpLcl->lpAttachList))
        {
            LPDDRAWI_DDRAWSURFACE_LCL   lclMip;

            lclMip = pTexture2->lpLcl->lpAttachList->lpAttached;
            while (lclMip)
            {
                PNVD3DTEXTURE   pMipMap;

                pMipMap = (PNVD3DTEXTURE)lclMip->dwReserved1;
                if (pMipMap)
                    pMipMap->hMipBaseTexture = (DWORD)pTexture2;
                if (lclMip->lpAttachList)
                    lclMip = lclMip->lpAttachList->lpAttached;
                else
                    lclMip = 0;
            }
        }
    }

    /*
     * Texture swap was successful.
     */
    ptsd->ddrval = DD_OK;
    NV_UNLOCK_TEXTURE_SURFACE(pTexture1);
    NV_UNLOCK_TEXTURE_SURFACE(pTexture2);

    return (DDHAL_DRIVER_HANDLED);
}
DWORD __stdcall nvTextureGetSurf
(
    LPD3DHAL_TEXTUREGETSURFDATA ptgd
)
{
    PNVD3DCONTEXT   pContext = 0;
    PNVD3DTEXTURE   pTexture = 0;

    /*
     * DUMB APPLICATION ALERT!!!!!
     * This code is going to look really strange, but there is a reason.  Believe it or not,
     * an application actually exists (Nightmare Creatures by Kalisto) that does not work if
     * the handle returned has bit 31 set.  Because of where the memory for our texture structures
     * is located, the high bit is always set, but I don't want to just blindly assume that this
     * is always going to be the case.  So, what I'm going to do is mask off the high bit of the
     * texture structure and return the remaining 31 bits as the handle, then in places where the
     * application passes in a texture handle, I will take the pointer to the head of the texture
     * list, mask off all but the high bit and OR it in with the handle to get the pointer to the
     * texture structure.  This should be safe since the texture structures are all allocated from
     * a linearly contiguous heap.
     */

    DPF_LEVEL(NVDBG_LEVEL_DDI_ENTRY, "nvTextureGetSurf - Get texture surface handle = %08lx", ptgd->dwHandle);

    /*
     * NOTES:
     *
     * This callback is invoked when the d3d needs to obtain the surface
     * refered to by a handle.
     *
     * Get the pointer to the specified context.
     */
    pContext = (PNVD3DCONTEXT)ptgd->dwhContext;
    if (!pContext)
    {
        dbgD3DError();
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvTextureGetSurf - Bad Context");
        ptgd->ddrval = D3DHAL_CONTEXT_BAD;
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Get pointer to global driver data structure.
     */
    NvSetDriverDataPtrFromContext(pContext);

    /*
     * Get pointer to the texture.
     */
    pTexture = (PNVD3DTEXTURE)(ptgd->dwHandle | (pDriverData->dwTextureListHead & 0x80000000));

    if (!pTexture)
    {
        dbgD3DError();
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvTextureGetSurf - Bad Texture");
        ptgd->ddrval = DDERR_INVALIDPARAMS;
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Return the pointer to the texture surface.
     */
#ifndef WINNT
    ptgd->lpDDS = (DWORD)pTexture->lpDDS;
#else
    ptgd->hDDS = pTexture->hDDS;
#endif // #ifndef WINNT


    /*
     * Texture surface was gotten successfully.
     */
    ptgd->ddrval = DD_OK;
    return (DDHAL_DRIVER_HANDLED);
}

/*
 * --------------------------------------------------------------------------
 * Texture heap management routines.
 * --------------------------------------------------------------------------
 */
BOOL CreateTextureHeap
(
    void
)
{
    DWORD   status;
    DWORD   dwBlockStartOffset;

    /*
     * Something is very wrong if we don't have a pointer to NV at this point.
     */
    if ((!pDriverData->NvDevFlatDma) || (!pDriverData->NvBaseFlat))
        return (FALSE);

    /*
     * Only need to create the heap once.
     */
    if (pDriverData->hTextureHeap)
        return (TRUE);

    /*
     * The texture heap always starts out empty.
     */
    pDriverData->dwAllocSize = 0;

    /*
     * On AGP don't allocate a heap just use the GART address.
     */
    if (pDriverData->GARTLinearBase > 0)
    {
        /*
         * Make sure we don't do this more than neccessary.
         */
        CreateAGPListArray();
        pDriverData->hTextureHeap = 1;
        return (TRUE);
    }

    /*
     * Get the maximum size of the texture heap.
     */
    if (!(pDriverData->dwTextureHeapSizeMax = pDriverData->regTexHeap))
        return (TRUE);

    do
    {
        /*
         * Create the texture heap.
         */
#ifndef OLDSTUFF
        pDriverData->hTextureHeap = (DWORD)HEAPCREATE(pDriverData->dwTextureHeapSizeMax);
#else
        pDriverData->hTextureHeap = (DWORD)HeapCreate(HEAP_SHARED, pDriverData->dwTextureHeapSizeMax, 0);
#endif // #ifdef OLDSTUFF
        if (!pDriverData->hTextureHeap)
            return (FALSE);

        /*
         * Allocate the entire heap up front for management.
         */
#ifndef OLDSTUFF
        (PTEXHEAPHEADER)pDriverData->pRealHeapBase = (PTEXHEAPHEADER)HEAPALLOC((HANDLE)pDriverData->hTextureHeap, pDriverData->dwTextureHeapSizeMax);
#else
        (PTEXHEAPHEADER)pDriverData->pRealHeapBase = (PTEXHEAPHEADER)HeapAlloc((HANDLE)pDriverData->hTextureHeap, HEAP_ZERO_MEMORY, pDriverData->dwTextureHeapSizeMax);
#endif
        if (!pDriverData->pRealHeapBase)
        {
#ifndef OLDSTUFF
            HEAPDESTROY((HANDLE)pDriverData->hTextureHeap);
#else
            HeapDestroy((HANDLE)pDriverData->hTextureHeap);
#endif // #ifdef OLDSTUFF
            pDriverData->hTextureHeap = (DWORD)NULL;
            return (FALSE);
        }

        /*
         * Get the size of the allocated heap and set the maximum heap limit.
         * The size shouldn't be different than what we asked for, but do
         * the check anyway, just for fun.
         */
#ifndef OLDSTUFF
#ifndef WINNT
        pDriverData->dwTextureHeapSizeMax  = (DWORD)HEAPSIZE((HANDLE)pDriverData->hTextureHeap, (PTEXHEAPHEADER)pDriverData->pRealHeapBase);
#endif // #ifndef WINNT
#else
        pDriverData->dwTextureHeapSizeMax  = (DWORD)HeapSize((HANDLE)pDriverData->hTextureHeap, 0, (PTEXHEAPHEADER)pDriverData->pRealHeapBase);
#endif // #ifdef OLDSTUFF
        pDriverData->dwTextureHeapLimitMax = pDriverData->dwTextureHeapSizeMax - 1;

        /*
         * Align the heap properly.
         */
        pDriverData->pTextureHeapBase       = ((pDriverData->pRealHeapBase + NV_TEXTURE_OFFSET_ALIGN) & ~NV_TEXTURE_OFFSET_ALIGN);
        pDriverData->dwTextureHeapSizeMax  -= (pDriverData->pTextureHeapBase - pDriverData->pRealHeapBase);
        pDriverData->dwTextureHeapSizeMax  &= 0xFFFFFF00;
        pDriverData->dwTextureHeapLimitMax  = pDriverData->dwTextureHeapSizeMax - 1;
        pDriverData->dwFreeSize             = pDriverData->dwTextureHeapSizeMax - NV_TEXTURE_PAD;
        pDriverData->dwTextureHeapSize      = pDriverData->dwTextureHeapSizeMax;
        pDriverData->dwTextureHeapLimit     = pDriverData->dwTextureHeapSize - 1;

        /*
         * Try and lock down the entire heap.
         */
#ifdef  CACHE_FREECOUNT
        nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
        NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#endif  // CACHE_FREECOUNT
        UnplugSystemMemoryTextureContext();
        status = AdjustTextureLimit(D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY, pDriverData->pTextureHeapBase, pDriverData->dwTextureHeapLimit, 0);
        UpdateTriangleContexts();
        if (status)
        {
            /*
             * Map the context to the frame buffer because the RM/Hardware doesn't
             * like having limts of 0.
             */
            UnplugSystemMemoryTextureContext();
#ifndef WINNT
            AdjustTextureLimit(D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY, pDriverData->BaseAddress, 0xFF, 0xFF);
#else
            AdjustTextureLimit(D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY, pDriverData->ppdev->pjScreen, 0xFF, 0xFF);
#endif // #ifdef WINNT
            UpdateTriangleContexts();
#ifndef OLDSTUFF
            HEAPFREE(pDriverData->hTextureHeap, (PTEXHEAPHEADER)pDriverData->pRealHeapBase);
            HEAPDESTROY((HANDLE)pDriverData->hTextureHeap);
#else
            HeapFree((HANDLE)pDriverData->hTextureHeap, 0, (PTEXHEAPHEADER)pDriverData->pRealHeapBase);
            HeapDestroy((HANDLE)pDriverData->hTextureHeap);
#endif
            pDriverData->hTextureHeap  = (DWORD)NULL;
            (PTEXHEAPHEADER)pDriverData->pRealHeapBase = (PTEXHEAPHEADER)NULL;
            if (status)
            {
                pDriverData->dwTextureHeapSizeMax -= min(pDriverData->dwTextureHeapSizeMax, HEAP_SIZE_ADJUST);
                if (!pDriverData->dwTextureHeapSizeMax)
                {
                    /*
                     * Can't lock down even a minimal heap.  Disable system memory textures.
                     */
                    pDriverData->regTexHeap             = 0;
                    pDriverData->dwTextureHeapSizeMax  = 0;
                    pDriverData->dwTextureHeapLimitMax = 0;
#ifdef  CACHE_FREECOUNT
                    pDriverData->dwDmaPusherFreeCount = nvFreeCount;
#ifdef  DEBUG
                    NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#endif  // CACHE_FREECOUNT
                    return (FALSE);
                }
            }
            else
            {
                /*
                 * Something more severe occured.  Disable system memory textures.
                 */
                pDriverData->regTexHeap            = 0;
                pDriverData->dwTextureHeapSizeMax  = 0;
                pDriverData->dwTextureHeapLimitMax = 0;
#ifdef  CACHE_FREECOUNT
                pDriverData->dwDmaPusherFreeCount = nvFreeCount;
#ifdef  DEBUG
                NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#endif  // CACHE_FREECOUNT
                return (FALSE);
            }
        }
#ifdef  CACHE_FREECOUNT
        pDriverData->dwDmaPusherFreeCount = nvFreeCount;
#ifdef  DEBUG
        NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#endif  // CACHE_FREECOUNT
    } while (!pDriverData->hTextureHeap);

    /*
     * Align the start of the texture.
     * 1) Original way was aligning the texture heap base address then aligning each
     *    individual texture start offset off of the texture heap base address.
     */
//    dwBlockStartOffset                       = (sizeof(TEXHEAPHEADER) + NV_TEXTURE_OFFSET_ALIGN) & ~NV_TEXTURE_OFFSET_ALIGN;
    /*
     * 2) New way is to align the texture heap address and align the start address of each
     *    texture.
     */
    dwBlockStartOffset = (((pDriverData->pTextureHeapBase + sizeof(TEXHEAPHEADER) + NV_TEXTURE_OFFSET_ALIGN) & ~NV_TEXTURE_OFFSET_ALIGN) - pDriverData->pTextureHeapBase);

    /*
     * Fill in the initial block structure.
     */
    ((PTEXHEAPHEADER)pDriverData->pTextureHeapFreeHead)                     = (PTEXHEAPHEADER)(pDriverData->pTextureHeapBase + dwBlockStartOffset - sizeof(TEXHEAPHEADER));
    ((PTEXHEAPHEADER)pDriverData->pTextureHeapFreeTail)                     = (PTEXHEAPHEADER)pDriverData->pTextureHeapFreeHead;
    ((PTEXHEAPHEADER)pDriverData->pTextureHeapFreeHead)->dwTag              = HEAP_TAG_FREE;
    ((PTEXHEAPHEADER)pDriverData->pTextureHeapFreeHead)->dwBlockSize        = pDriverData->dwTextureHeapSizeMax - dwBlockStartOffset;
    ((PTEXHEAPHEADER)pDriverData->pTextureHeapFreeHead)->dwBlockStartOffset = dwBlockStartOffset;
    ((PTEXHEAPHEADER)pDriverData->pTextureHeapFreeHead)->pNextFreeBlock     = (PTEXHEAPHEADER)NULL;
    ((PTEXHEAPHEADER)pDriverData->pTextureHeapFreeHead)->pPrevFreeBlock     = (PTEXHEAPHEADER)NULL;
    ((PTEXHEAPHEADER)pDriverData->pTextureHeapFreeHead)->pNextAllocBlock    = (PTEXHEAPHEADER)NULL;
    ((PTEXHEAPHEADER)pDriverData->pTextureHeapFreeHead)->pPrevAllocBlock    = (PTEXHEAPHEADER)NULL;

    /*
     * Dump some information about the texture heap.
     */
    DPF_LEVEL(NVDBG_LEVEL_INFO, "CreateTextureHeap - pTextureHeapBase      = %08lx", pDriverData->pTextureHeapBase);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "CreateTextureHeap - dwTextureHeapSizeMax  = %08lx", pDriverData->dwTextureHeapSizeMax);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "CreateTextureHeap - dwTextureHeapLimitMax = %08lx", pDriverData->dwTextureHeapLimitMax);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "CreateTextureHeap - dwTextureHeapSize     = %08lx", pDriverData->dwTextureHeapSize);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "CreateTextureHeap - dwTextureHeapLimit    = %08lx", pDriverData->dwTextureHeapLimit);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "CreateTextureHeap - dwFreeSize            = %08lx", pDriverData->dwFreeSize);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "CreateTextureHeap - dwAllocSize           = %08lx", pDriverData->dwAllocSize);

    /*
     * Return successfully.
     */
    return (TRUE);
}
BOOL DestroyTextureHeap
(
    void
)
{
    /*
     * Can't destroy a heap if there isn't one.
     */
    if (!pDriverData->hTextureHeap)
        return (TRUE);

    /*
     * Tear down the Texture DMA context.
     * Note: Need to be careful here, because there are some instances that
     * the channel may already be closed at this point.
     */
    /*
     * Something is very wrong if we don't have a pointer to NV at this point.
     */
    if ((pDriverData->NvDevFlatDma) && (pDriverData->NvBaseFlat))
    {
        /*
         * Map the context to the frame buffer because the RM/Hardware doesn't
         * like having limts of 0.
         */
#ifdef  CACHE_FREECOUNT
        nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
        NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#endif  // CACHE_FREECOUNT
        UnplugSystemMemoryTextureContext();
#ifndef WINNT
        AdjustTextureLimit(D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY, pDriverData->BaseAddress, 0xFF, 0xFF);
#else
        AdjustTextureLimit(D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY, pDriverData->ppdev->pjScreen, 0xFF, 0xFF);
#endif // #ifdef WINNT

        UpdateTriangleContexts();
#ifdef  CACHE_FREECOUNT
        pDriverData->dwDmaPusherFreeCount = nvFreeCount;
#ifdef  DEBUG
        NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#endif  // CACHE_FREECOUNT
    }

    /*
     * Free and destroy the texture heap.
     */
    if (pDriverData->GARTLinearBase == 0)
    {
        /*
         * Only need to free the heap if it was allocated.  (it won't be
         * allocated on an AGP system)
         */
#ifndef OLDSTUFF
        HEAPFREE(pDriverData->hTextureHeap, (PTEXHEAPHEADER)pDriverData->pRealHeapBase);
        HEAPDESTROY(pDriverData->hTextureHeap);
#else
        HeapFree((HANDLE)pDriverData->hTextureHeap, 0, (PTEXHEAPHEADER)pDriverData->pRealHeapBase);
        HeapDestroy((HANDLE)pDriverData->hTextureHeap);
#endif
    }
    else
        DestroyAGPListArray();

    /*
     * Clean up a little bit.
     */
    pDriverData->hTextureHeap                           = (DWORD)NULL;
    (PTEXHEAPHEADER)pDriverData->pRealHeapBase         = (PTEXHEAPHEADER)NULL;
    (PTEXHEAPHEADER)pDriverData->pTextureHeapBase      = (PTEXHEAPHEADER)NULL;
    (PTEXHEAPHEADER)pDriverData->pTextureHeapAllocHead = (PTEXHEAPHEADER)NULL;
    (PTEXHEAPHEADER)pDriverData->pTextureHeapAllocTail = (PTEXHEAPHEADER)NULL;
    (PTEXHEAPHEADER)pDriverData->pTextureHeapFreeHead  = (PTEXHEAPHEADER)NULL;
    (PTEXHEAPHEADER)pDriverData->pTextureHeapFreeTail  = (PTEXHEAPHEADER)NULL;
    pDriverData->dwTextureHeapSize                     = 0;
    pDriverData->dwTextureHeapSizeMax                  = 0;
    pDriverData->dwTextureHeapLimit                    = 0;
    pDriverData->dwTextureHeapLimitMax                 = 0;
    pDriverData->dwAllocSize                           = 0;
    pDriverData->dwFreeSize                            = 0;
    return (TRUE);
}
DWORD AllocTextureHeap
(
    DWORD   dwSizeRequest
)
{
    DWORD           dwAllocBlockSize;
    DWORD           dwNewFreeBlockSize;
    DWORD           dwNewFreeBlockOffset;
    DWORD           dwNewFreeBlockStartOffset;
    DWORD           dwAllocLimit;
    PTEXHEAPHEADER  pAllocBlock;
    PTEXHEAPHEADER  pList;
    PTEXHEAPHEADER  pNextFree;
    PTEXHEAPHEADER  pPrevFree;
    PTEXHEAPHEADER  pNewFree;

    DPF_LEVEL(NVDBG_LEVEL_FUNCTION_CALL, "AllocTextureHeap - dwSizeRequest = %08lx", dwSizeRequest);

    /*
     * Create the texture heap if it doesn't exist yet.
     */
    if (!pDriverData->hTextureHeap)
        CreateTextureHeap();

    /*
     * If the free list is null, then there's no memory to be allocated.
     */
    if ((!pDriverData->pTextureHeapFreeHead)
     || (pDriverData->dwFreeSize < dwSizeRequest))
    {
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "AllocTextureHeap - Not enough free memory to fill request!");
        return (0);
    }

    /*
     * Search the free block list for a block large enough to fill this
     * request.
     */
    pAllocBlock      = (PTEXHEAPHEADER)NULL;
    dwAllocBlockSize = 0;
    pList            = (PTEXHEAPHEADER)pDriverData->pTextureHeapFreeHead;

    /*
     * The search will end when a block has been found that exactly matches
     * the requested size or the end of the free list has been reached. In the
     * event that an exact size match is not found, then the first block that is
     * closest to the requested size will be used.
     *
     * CHASNOTE: Potential problem with this method is that a larger block might
     * be passed up for a smaller block later in the heap and this could mean that
     * the context limit will fail shrink when it may have otherwise if the larger
     * block was used.
     */
    while ((pList)
        && (dwAllocBlockSize != dwSizeRequest))
    {
        if (pList->dwBlockSize >= dwSizeRequest)
        {
            if ((!dwAllocBlockSize)
             || (pList->dwBlockSize < dwAllocBlockSize))
            {
                pAllocBlock      = pList;
                dwAllocBlockSize = pList->dwBlockSize;
            }
        }
        pList = pList->pNextFreeBlock;
    }

    /*
     * If there was no block large enough to fill the request, return unsuccessful.
     */
    if (!pAllocBlock)
        return (0);

    /*
     * Get a few pointers.
     */
    pPrevFree                   = pAllocBlock->pPrevFreeBlock;
    pNextFree                   = pAllocBlock->pNextFreeBlock;
    pAllocBlock->pPrevFreeBlock = (PTEXHEAPHEADER)NULL;
    pAllocBlock->pNextFreeBlock = (PTEXHEAPHEADER)NULL;

    /*
     * Initialize the newly allocated block header and create
     * the new free block as neccessary.
     */
    pAllocBlock->dwTag       = HEAP_TAG_ALLOC;
    pAllocBlock->dwBlockSize = dwSizeRequest;

    /*
     * Allocate any new free block if the block being used for the allocation
     * is larger than the requested block size.
     */
    dwNewFreeBlockSize = dwAllocBlockSize - dwSizeRequest;

    /*
     * Adjust alignment so the next free block starts on the correct boundry for an NV3
     * texture.
     */
    if (dwNewFreeBlockSize >= (sizeof(TEXHEAPHEADER) + NV_MIN_TEXTURE_SIZE))
    {
        DWORD dwNextBlockOffset;
        DWORD dwExcess;

        dwNextBlockOffset         = pAllocBlock->dwBlockStartOffset + dwSizeRequest;
        /*
         * Align the start of the texture.
         * 1) Original way was aligning the texture heap base address then aligning each
         *    individual texture start offset off of the texture heap base address.
         */
//        dwNewFreeBlockStartOffset = (dwNextBlockOffset + sizeof(TEXHEAPHEADER) + NV_TEXTURE_OFFSET_ALIGN) & ~NV_TEXTURE_OFFSET_ALIGN;
        /*
         * 2) New way is to align the texture heap address and align the start address of each
         *    texture.
         */
        dwNewFreeBlockStartOffset = ((((pDriverData->pTextureHeapBase + dwNextBlockOffset + sizeof(TEXHEAPHEADER)) + NV_TEXTURE_OFFSET_ALIGN) & ~NV_TEXTURE_OFFSET_ALIGN) - pDriverData->pTextureHeapBase);
        dwNewFreeBlockOffset      = dwNewFreeBlockStartOffset - sizeof(TEXHEAPHEADER);
        dwExcess                  = dwNewFreeBlockOffset - dwNextBlockOffset;
        dwNewFreeBlockSize       -= dwExcess;
        pAllocBlock->dwBlockSize += dwExcess;
    }

    /*
     * Now that the block has been aligned on the correct boundry, check again to make sure
     * that there's still enough room for a minimum sized texture.
     */
    if (dwNewFreeBlockSize >= (sizeof(TEXHEAPHEADER) + NV_MIN_TEXTURE_SIZE))
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "AllocTextureHeap - Create new free block at end of allocation block.");

        /*
         * Create the new free block.
         */
        pNewFree                     = (PTEXHEAPHEADER)(pDriverData->pTextureHeapBase + dwNewFreeBlockOffset);
        pNewFree->dwTag              = HEAP_TAG_FREE;
        pNewFree->dwBlockStartOffset = dwNewFreeBlockStartOffset;
        pNewFree->dwBlockSize        = dwNewFreeBlockSize - sizeof(TEXHEAPHEADER);
        pNewFree->pNextFreeBlock     = pNextFree;
        pNewFree->pPrevFreeBlock     = pPrevFree;
        pNewFree->pNextAllocBlock    = (PTEXHEAPHEADER)NULL;
        pNewFree->pPrevAllocBlock    = (PTEXHEAPHEADER)NULL;

        /*
         * Insert the new free block into the free block list.
         */
        if (pPrevFree)
            pPrevFree->pNextFreeBlock = pNewFree;
        else
            (PTEXHEAPHEADER)pDriverData->pTextureHeapFreeHead = pNewFree;
        if (pNextFree)
            pNextFree->pPrevFreeBlock = pNewFree;
        else
            (PTEXHEAPHEADER)pDriverData->pTextureHeapFreeTail = pNewFree;
    }
    else
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "AllocTextureHeap - Tack excess free memory  onto end of allocation block.");

        /*
         * Tack the excess memory on to the end of the block.
         */
        pAllocBlock->dwBlockSize += dwNewFreeBlockSize;

        /*
         * Remove the block from the free block list.
         */
        if (pPrevFree)
            pPrevFree->pNextFreeBlock = pNextFree;
        else
            (PTEXHEAPHEADER)pDriverData->pTextureHeapFreeHead = pNextFree;

        if (pNextFree)
            pNextFree->pPrevFreeBlock = pPrevFree;
        else
            (PTEXHEAPHEADER)pDriverData->pTextureHeapFreeTail = pPrevFree;
    }

    /*
     * Update the allocation sizes.
     */
    pDriverData->dwAllocSize += pAllocBlock->dwBlockSize;
    pDriverData->dwFreeSize  -= pAllocBlock->dwBlockSize;

    /*
     * Insert the newly allocated block into the allocation list.
     * First handle the best case scenarios, the block is either the first block
     * to be allocated, the block comes before the current head of the allocation
     * list, or the block comes after the current tail of the allocation list.
     * In these cases, its simply a case of updating a few pointers.
     */
    if (!pDriverData->pTextureHeapAllocHead)
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "AllocTextureHeap - Insert new allocation block at head of allocation list. First time.");
        pAllocBlock->pPrevAllocBlock                        = (PTEXHEAPHEADER)NULL;
        pAllocBlock->pNextAllocBlock                        = (PTEXHEAPHEADER)NULL;
        (PTEXHEAPHEADER)pDriverData->pTextureHeapAllocHead = pAllocBlock;
        (PTEXHEAPHEADER)pDriverData->pTextureHeapAllocTail = pAllocBlock;

        /*
         * The tail of allocation list has changed. Check to see if the texture context
         * needs to be udpated to reflect the change.
         */
        if (pDriverData->pTextureHeapAllocTail)
            dwAllocLimit = ((PTEXHEAPHEADER)pDriverData->pTextureHeapAllocTail)->dwBlockStartOffset + ((PTEXHEAPHEADER)pDriverData->pTextureHeapAllocTail)->dwBlockSize - 1;
        else
            dwAllocLimit = 0;
    }
    else if (pAllocBlock < (PTEXHEAPHEADER)pDriverData->pTextureHeapAllocHead)
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "AllocTextureHeap - Insert new allocation block at head of allocation list.");
        ((PTEXHEAPHEADER)pDriverData->pTextureHeapAllocHead)->pPrevAllocBlock = pAllocBlock;
        pAllocBlock->pPrevAllocBlock                                           = (PTEXHEAPHEADER)NULL;
        pAllocBlock->pNextAllocBlock                                           = (PTEXHEAPHEADER)pDriverData->pTextureHeapAllocHead;
        (PTEXHEAPHEADER)pDriverData->pTextureHeapAllocHead                    = pAllocBlock;
    }
    else if (pAllocBlock > (PTEXHEAPHEADER)pDriverData->pTextureHeapAllocTail)
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "AllocTextureHeap - Insert new allocation block at tail of allocation list.");
        ((PTEXHEAPHEADER)pDriverData->pTextureHeapAllocTail)->pNextAllocBlock = pAllocBlock;
        pAllocBlock->pPrevAllocBlock                                           = (PTEXHEAPHEADER)pDriverData->pTextureHeapAllocTail;
        pAllocBlock->pNextAllocBlock                                           = (PTEXHEAPHEADER)NULL;
        (PTEXHEAPHEADER)pDriverData->pTextureHeapAllocTail                    = pAllocBlock;

        /*
         * The tail of allocation list has changed. Check to see if the texture context
         * needs to be udpated to reflect the change.
         */
        if (pDriverData->pTextureHeapAllocTail)
            dwAllocLimit = ((PTEXHEAPHEADER)pDriverData->pTextureHeapAllocTail)->dwBlockStartOffset + ((PTEXHEAPHEADER)pDriverData->pTextureHeapAllocTail)->dwBlockSize - 1;
        else
            dwAllocLimit = 0;
    }
    else
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "AllocTextureHeap - Insert new allocation block in middle of allocation list.");

        /* WORST CASE
         * The newly allocated block falls between the head and tail of the allocation
         * list. Search all memory blocks following the new allocation block to find the
         * next allocated block, then just update the pointers.
         */
        pList = (PTEXHEAPHEADER)((DWORD)pAllocBlock + sizeof(TEXHEAPHEADER) + pAllocBlock->dwBlockSize);
        while ((pList)
            && (pList->dwTag != HEAP_TAG_ALLOC))
        {
            pList = (PTEXHEAPHEADER)((DWORD)pList + sizeof(TEXHEAPHEADER) + pList->dwBlockSize);
        }
        /*
         * This should never happen, if it does, then we've got problems.
         */
        if (!pList)
        {
            DPF_LEVEL(NVDBG_LEVEL_ERROR, "AllocTextureHeap - Error inserting new allocation block!!");
            return (pAllocBlock->dwBlockStartOffset);
        }

        /*
         * Update the pointers.
         */
        pAllocBlock->pPrevAllocBlock                  = pList->pPrevAllocBlock;
        pAllocBlock->pNextAllocBlock                  = pList;
        pList->pPrevAllocBlock                        = pAllocBlock;
        pAllocBlock->pPrevAllocBlock->pNextAllocBlock = pAllocBlock;
    }

    /*
     * Dump some information about the texture heap allocation.
     */
    DPF_LEVEL(NVDBG_LEVEL_INFO, "AllocTextureHeap - pAllocBlock->dwBlockStartOffset = %08lx", (DWORD)pAllocBlock->dwBlockStartOffset);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "AllocTextureHeap - dwTextureHeapSize               = %08lx", pDriverData->dwTextureHeapSize);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "AllocTextureHeap - dwTextureHeapLimit              = %08lx", pDriverData->dwTextureHeapLimit);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "AllocTextureHeap - dwFreeSize                      = %08lx", pDriverData->dwFreeSize);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "AllocTextureHeap - dwAllocSize                     = %08lx", pDriverData->dwAllocSize);

    /*
     * Return the offset to the allocated block.
     */
    return (pAllocBlock->dwBlockStartOffset);
}
BOOL FreeTextureHeap
(
    DWORD   dwFreeBlockOffset
)
{
    DWORD           dwAllocLimit;
    PTEXHEAPHEADER  pList;
    PTEXHEAPHEADER  pFreeBlock;
    PTEXHEAPHEADER  pPrevFree;
    PTEXHEAPHEADER  pNextFree;
    PTEXHEAPHEADER  pPrevAlloc;
    PTEXHEAPHEADER  pNextAlloc;

    DPF_LEVEL(NVDBG_LEVEL_FUNCTION_CALL, "FreeTextureHeap - dwFreeBlockOffset       = %08lx", dwFreeBlockOffset);

    /*
     * Make sure there is a valid texture heap to free the memory from.
     */
    if (!pDriverData->pTextureHeapBase)
        return (TRUE);

    /*
     * Make sure there is actually a valid texture block to free.
     */
    if (!dwFreeBlockOffset)
        return (FALSE);

    /*
     * Calculate the pointer to the header of the block being freed.
     */
    pFreeBlock = (PTEXHEAPHEADER)(pDriverData->pTextureHeapBase + (dwFreeBlockOffset - sizeof(TEXHEAPHEADER)));
    DPF_LEVEL(NVDBG_LEVEL_INFO, "FreeTextureHeap - pFreeBlock->dwBlockSize = %08lx", pFreeBlock->dwBlockSize);

    /*
     * Make sure we are pointer to an actual allocated block header.
     */
    if (pFreeBlock->dwTag != HEAP_TAG_ALLOC)
        return (FALSE);

    /*
     * Get a few pointers.
     */
    pPrevAlloc                  = pFreeBlock->pPrevAllocBlock;
    pNextAlloc                  = pFreeBlock->pNextAllocBlock;
    pFreeBlock->pPrevAllocBlock = (PTEXHEAPHEADER)NULL;
    pFreeBlock->pNextAllocBlock = (PTEXHEAPHEADER)NULL;

    /*
     * Remove the block from the allocation list.
     */
    if (pPrevAlloc)
        pPrevAlloc->pNextAllocBlock = pNextAlloc;
    else
        (PTEXHEAPHEADER)pDriverData->pTextureHeapAllocHead = pNextAlloc;
    if (pNextAlloc)
        pNextAlloc->pPrevAllocBlock = pPrevAlloc;
    else
    {
        (PTEXHEAPHEADER)pDriverData->pTextureHeapAllocTail = pPrevAlloc;

        /*
         * The tail of allocation list has changed. Check to see if the texture context
         * needs to be udpated to reflect the change.
         */
        if (pDriverData->pTextureHeapAllocTail)
            dwAllocLimit = ((PTEXHEAPHEADER)pDriverData->pTextureHeapAllocTail)->dwBlockStartOffset + ((PTEXHEAPHEADER)pDriverData->pTextureHeapAllocTail)->dwBlockSize - 1;
        else
            dwAllocLimit = 0;
    }

    /*
     * Mark the block as freed and get the size of the block.
     */
    pFreeBlock->dwTag = HEAP_TAG_FREE;

    /*
     * Update the allocation sizes.
     */
    pDriverData->dwAllocSize -= pFreeBlock->dwBlockSize;
    pDriverData->dwFreeSize  += pFreeBlock->dwBlockSize;

    /*
     * Insert the newly freed block into the free list.
     */
    if (!pDriverData->pTextureHeapFreeHead)
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "FreeTextureHeap - Insert new free block at head of free list. First time.");
        pFreeBlock->pPrevFreeBlock                         = (PTEXHEAPHEADER)NULL;
        pFreeBlock->pNextFreeBlock                         = (PTEXHEAPHEADER)NULL;
        (PTEXHEAPHEADER)pDriverData->pTextureHeapFreeHead = pFreeBlock;
        (PTEXHEAPHEADER)pDriverData->pTextureHeapFreeTail = pFreeBlock;
    }
    else if (pFreeBlock < (PTEXHEAPHEADER)pDriverData->pTextureHeapFreeHead)
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "FreeTextureHeap - Insert new free block at head of free list.");
        ((PTEXHEAPHEADER)pDriverData->pTextureHeapFreeHead)->pPrevFreeBlock = pFreeBlock;
        pFreeBlock->pPrevFreeBlock                                           = (PTEXHEAPHEADER)NULL;
        pFreeBlock->pNextFreeBlock                                           = (PTEXHEAPHEADER)pDriverData->pTextureHeapFreeHead;
        (PTEXHEAPHEADER)pDriverData->pTextureHeapFreeHead                   = pFreeBlock;
    }
    else if (pFreeBlock > (PTEXHEAPHEADER)pDriverData->pTextureHeapFreeTail)
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "FreeTextureHeap - Insert new free block at tail of free list.");
        ((PTEXHEAPHEADER)pDriverData->pTextureHeapFreeTail)->pNextFreeBlock = pFreeBlock;
        pFreeBlock->pPrevFreeBlock                                           = (PTEXHEAPHEADER)pDriverData->pTextureHeapFreeTail;
        pFreeBlock->pNextFreeBlock                                           = (PTEXHEAPHEADER)NULL;
        (PTEXHEAPHEADER)pDriverData->pTextureHeapFreeTail                   = pFreeBlock;
    }
    else
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "FreeTextureHeap - Insert new free block in middle of free list.");

        /* WORST CASE
         * The newly freed block falls between the head and tail of the free
         * list. Search all memory blocks following the new freed block to find the
         * next free block, then just update the pointers.
         */
        pList = (PTEXHEAPHEADER)((DWORD)pFreeBlock + sizeof(TEXHEAPHEADER) + pFreeBlock->dwBlockSize);
        while ((pList)
            && (pList->dwTag != HEAP_TAG_FREE))
        {
            pList = (PTEXHEAPHEADER)((DWORD)pList + sizeof(TEXHEAPHEADER) + pList->dwBlockSize);
        }
        /*
         * This should never happen, if it does, then we've got problems.
         */
        if (!pList)
        {
            DPF_LEVEL(NVDBG_LEVEL_ERROR, "FreeTextureHeap - Error inserting newly freed block!!");
            return (TRUE);
        }

        /*
         * Update the pointers.
         */
        pFreeBlock->pPrevFreeBlock                 = pList->pPrevFreeBlock;
        pFreeBlock->pNextFreeBlock                 = pList;
        pList->pPrevFreeBlock                      = pFreeBlock;
        pFreeBlock->pPrevFreeBlock->pNextFreeBlock = pFreeBlock;
    }

    /*
     * Do some basic garbage collection to try and consolidate contiguous free
     * blocks.
     */
    pPrevFree = pFreeBlock->pPrevFreeBlock;
    pNextFree = pFreeBlock->pNextFreeBlock;
    if ((pPrevFree)
     && (((DWORD)pPrevFree + sizeof(TEXHEAPHEADER) + pPrevFree->dwBlockSize) == (DWORD)pFreeBlock))
    {
        /*
         * Merge the previous free block with the new free block.
         */
        pPrevFree->dwBlockSize += sizeof(TEXHEAPHEADER) + pFreeBlock->dwBlockSize;
        if (pPrevFree->pNextFreeBlock = pNextFree)
            pNextFree->pPrevFreeBlock = pPrevFree;
        else
            (PTEXHEAPHEADER)pDriverData->pTextureHeapFreeTail = pPrevFree;

        /*
         * Clean out the old free block header.
         */
        pFreeBlock->dwTag              = 0;
        pFreeBlock->dwBlockSize        = 0;
        pFreeBlock->dwBlockStartOffset = 0;
        pFreeBlock->pPrevFreeBlock     = (PTEXHEAPHEADER)NULL;
        pFreeBlock->pNextFreeBlock     = (PTEXHEAPHEADER)NULL;
        pFreeBlock->pPrevAllocBlock    = (PTEXHEAPHEADER)NULL;
        pFreeBlock->pNextAllocBlock    = (PTEXHEAPHEADER)NULL;

        /*
         * Update the free block pointer to point to the new consolidated block.
         */
        pFreeBlock = pPrevFree;
    }
    if ((pNextFree)
     && (((DWORD)pFreeBlock + sizeof(TEXHEAPHEADER) + pFreeBlock->dwBlockSize) == (DWORD)pNextFree))
    {
        /*
         * Merge the new free block with the next free block.
         */
        pFreeBlock->dwBlockSize += sizeof(TEXHEAPHEADER) + pNextFree->dwBlockSize;
        if (pFreeBlock->pNextFreeBlock = pNextFree->pNextFreeBlock)
            pNextFree->pNextFreeBlock->pPrevFreeBlock = pFreeBlock;
        else
            (PTEXHEAPHEADER)pDriverData->pTextureHeapFreeTail = pFreeBlock;

        /*
         * Clean out the old free block header.
         */
        pNextFree->dwTag              = 0;
        pNextFree->dwBlockSize        = 0;
        pNextFree->dwBlockStartOffset = 0;
        pNextFree->pPrevFreeBlock     = (PTEXHEAPHEADER)NULL;
        pNextFree->pNextFreeBlock     = (PTEXHEAPHEADER)NULL;
        pNextFree->pPrevAllocBlock    = (PTEXHEAPHEADER)NULL;
        pNextFree->pNextAllocBlock    = (PTEXHEAPHEADER)NULL;
    }

    /*
     * Dump some information about the texture heap allocation.
     */
    DPF_LEVEL(NVDBG_LEVEL_INFO, "FreeTextureHeap - dwTextureHeapSize  = %08lx", pDriverData->dwTextureHeapSize);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "FreeTextureHeap - dwTextureHeapLimit = %08lx", pDriverData->dwTextureHeapLimit);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "FreeTextureHeap - dwFreeSize         = %08lx", pDriverData->dwFreeSize);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "FreeTextureHeap - dwAllocSize        = %08lx", pDriverData->dwAllocSize);

    /*
     * Destroy the texture heap if there's nothing left allocated in it.
     */
    if (!pDriverData->pTextureHeapAllocHead)
        DestroyTextureHeap();

    /*
     * Return successfully.
     */
    return (TRUE);
}
DWORD GetPointerTextureHeap
(
    DWORD   dwBlockOffset
)
{
    DWORD           dwBlockPointer;
    PTEXHEAPHEADER  pBlockHeader;

    dwBlockPointer = pDriverData->pTextureHeapBase + dwBlockOffset;
    pBlockHeader   = (PTEXHEAPHEADER)(dwBlockPointer - sizeof(TEXHEAPHEADER));

    if ((!pBlockHeader)
     || (pBlockHeader->dwTag != HEAP_TAG_ALLOC))
        return (0);

    /*
     * Return the pointer to the start of the memory block.
     */
    return (dwBlockPointer);
}

typedef struct _def_agp_heap_list   AGPHEAPLIST, *PAGPHEAPLIST;
struct _def_agp_heap_list
{
    DWORD           hCurrent;
    DWORD           dwPointer;
    DWORD           dwAlignedPointer;
    DWORD           dwSize;
    DWORD           dwLimit;
    HDDRVITEM       hPrev;
    HDDRVITEM       hNext;
};
HDDRVITEM           hAGPHeapHead = (HDDRVITEM)0;
HDDRVITEM           hAGPHeapTail = (HDDRVITEM)0;
DWORD AllocAGPHeap
(
    LPDDRAWI_DIRECTDRAW_GBL pDrv,
    DWORD                   dwSize
)
{
    DWORD           dwOffset;
    DWORD           dwCurrentLimit;
    DWORD           dwNewBlockLimit;
    DWORD           pAGPMem;
    HDDRVITEM       hAGPListBlock;
    PAGPHEAPLIST    pAGPHeap;
    PAGPHEAPLIST    pAGPListBlock;
    PAGPHEAPLIST    pAGPHeapHead;
    PAGPHEAPLIST    pAGPHeapTail;
    PAGPHEAPLIST    pNext;

    /*
     * Something is very wrong if we don't have a pointer to NV at this point.
     */
    if ((!pDriverData->NvDevFlatDma) || (!pDriverData->NvBaseFlat))
        return (0);

    /*
     * Make sure this is AGP.
     */
    if (pDriverData->GARTLinearBase == 0)
        return (0);

    /*
     * Create the texture heap if it doesn't exist yet.
     */
    if (!pDriverData->hTextureHeap)
        CreateTextureHeap();

    /*
     * Allocate an entry in the texture item array for the new texture.
     */
#ifndef OLDSTUFF
    hAGPListBlock = (HDDRVITEM)HEAPALLOC(pDriverData->hAGPList_gbl, sizeof(AGPHEAPLIST));
    if (!hAGPListBlock)
        return (0);
    pAGPListBlock = (PAGPHEAPLIST)hAGPListBlock;
    pAGPHeapHead  = (PAGPHEAPLIST)hAGPHeapHead; // Needs to be in pDriverData
    pAGPHeapTail  = (PAGPHEAPLIST)hAGPHeapTail; // Needs to be in pDriverData
#else
    DDrvItemArrayAlloc(pDriverData->hAGPList_gbl, &hAGPListBlock);
    if (!hAGPListBlock)
        return (0);
    pAGPListBlock = (PAGPHEAPLIST)DDrvItemArrayGetPtr(pDriverData->hAGPList_gbl, hAGPListBlock);
    if (!pAGPListBlock)
    {
        DDrvItemArrayFree(pDriverData->hAGPList_gbl, hAGPListBlock);
        return (0);
    }
    pAGPHeapHead = (PAGPHEAPLIST)DDrvItemArrayGetPtr(pDriverData->hAGPList_gbl, hAGPHeapHead);
    pAGPHeapTail = (PAGPHEAPLIST)DDrvItemArrayGetPtr(pDriverData->hAGPList_gbl, hAGPHeapTail);
#endif

    /*
     * Allocate the memory from the AGP heap.
     * Add padding to prevent DMA limit errors.
     */
    dwSize += NV_TEXTURE_PAD;
    pAGPMem = (DWORD)DDHAL32_VidMemAlloc(pDrv, AGP_HEAP, dwSize, 1);
    if (pAGPMem)
    {
        dwNewBlockLimit = ((pAGPMem - pDriverData->GARTLinearBase) + dwSize & 0xFFFFFF00) - 1;
        dwCurrentLimit = (pAGPHeapTail) ? pAGPHeapTail->dwLimit : 0;
        if (dwNewBlockLimit > dwCurrentLimit)
        {
            /*
             * Adjust the limit on the AGP context.
             */

#ifdef  CACHE_FREECOUNT
            nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
            NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#endif  // CACHE_FREECOUNT
            UnplugSystemMemoryTextureContext();
            if (AdjustTextureLimit(D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY, pDriverData->GARTLinearBase, dwNewBlockLimit, dwCurrentLimit))
            {
                /*
                 * Free the memory since the new limit could not be set.
                 */
                DDHAL32_VidMemFree(pDrv, AGP_HEAP, pAGPMem);

#ifndef OLDSTUFF
                HEAPFREE(pDriverData->hAGPList_gbl, (HDDRVITEM)hAGPListBlock);
#else
                DDrvItemArrayFree(pDriverData->hAGPList_gbl, (HDDRVITEM)hAGPListBlock);
#endif

                /*
                 * Could not set the new limit.  Return an error.
                 */
                UpdateTriangleContexts();
#ifdef  CACHE_FREECOUNT
                pDriverData->dwDmaPusherFreeCount = nvFreeCount;
#ifdef  DEBUG
                NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#endif  // CACHE_FREECOUNT
                return (0);
            }
            UpdateTriangleContexts();
#ifdef  CACHE_FREECOUNT
            pDriverData->dwDmaPusherFreeCount = nvFreeCount;
#ifdef  DEBUG
            NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#endif  // CACHE_FREECOUNT
            pDriverData->dwAllocSize += dwSize;

            /*
             * Store the current texture heap limit.
             */
            pDriverData->dwTextureHeapLimit = dwNewBlockLimit;
        }

        /*
         * Insert the new allocation block into the heap allocation list.
         */
        pAGPListBlock->hCurrent  = hAGPListBlock;
        pAGPListBlock->dwPointer = pAGPMem;

        /*
         * Align the start of the texture.
         * 1) Original way was each individual texture start offset off of the
         *    texture heap base address.
         */
//        dwOffset = ((pAGPMem - pDriverData->GARTLinearBase) + NV_TEXTURE_OFFSET_ALIGN) & ~NV_TEXTURE_OFFSET_ALIGN;
        /*
         * 2) New way is to align the start address of each texture.
         */
        dwOffset = ((pAGPMem + NV_TEXTURE_OFFSET_ALIGN) & ~NV_TEXTURE_OFFSET_ALIGN) - pDriverData->GARTLinearBase;
        pAGPMem  = pDriverData->GARTLinearBase + dwOffset;
        pAGPListBlock->dwAlignedPointer = pAGPMem;
        pAGPListBlock->dwSize           = dwSize;
        pAGPListBlock->dwLimit          = dwNewBlockLimit;
        pAGPHeap = pAGPHeapTail;
#ifndef OLDSTUFF
        while ((pAGPHeap) && (dwNewBlockLimit < pAGPHeap->dwLimit))
            pAGPHeap = (PAGPHEAPLIST)pAGPHeap->hPrev;
#else
        while ((pAGPHeap) && (dwNewBlockLimit < pAGPHeap->dwLimit))
            pAGPHeap = (PAGPHEAPLIST)DDrvItemArrayGetPtr(pDriverData->hAGPList_gbl, pAGPHeap->hPrev);
#endif
        if (pAGPHeap)
        {
#ifndef OLDSTUFF
            pNext = (PAGPHEAPLIST)pAGPHeap->hNext;
#else
            pNext = (PAGPHEAPLIST)DDrvItemArrayGetPtr(pDriverData->hAGPList_gbl, pAGPHeap->hNext);
#endif
            pAGPListBlock->hPrev = pAGPHeap->hCurrent;
            pAGPListBlock->hNext = pAGPHeap->hNext;
            pAGPHeap->hNext      = hAGPListBlock;
            if (pNext)
                pNext->hPrev = hAGPListBlock;
            else
                hAGPHeapTail = hAGPListBlock;
        }
        else
        {
            if (hAGPHeapHead)
            {
                pAGPListBlock->hPrev = (HDDRVITEM)NULL;
                pAGPListBlock->hNext = hAGPHeapHead;
            }
            else
            {
                pAGPListBlock->hPrev = (HDDRVITEM)NULL;
                pAGPListBlock->hNext = (HDDRVITEM)NULL;
                hAGPHeapTail = hAGPListBlock;
            }
            hAGPHeapHead = hAGPListBlock;
        }
    }
    else
    {
#ifndef OLDSTUFF
        HEAPFREE(pDriverData->hAGPList_gbl, (HDDRVITEM)hAGPListBlock);
#else
        DDrvItemArrayFree(pDriverData->hAGPList_gbl, (HDDRVITEM)hAGPListBlock);
#endif
        return (0);
    }
    if ((pAGPListBlock->dwAlignedPointer & NV_TEXTURE_OFFSET_ALIGN)
     || (((pAGPListBlock->dwAlignedPointer - pDriverData->GARTLinearBase) & NV_TEXTURE_OFFSET_ALIGN)))
    {
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "AllocAGPHeap - Alignment Error - dwPointer        = %08lx", pAGPListBlock->dwPointer);
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "                                 dwAlignedPointer = %08lx", pAGPListBlock->dwAlignedPointer);
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "                                 dwOffset         = %08lx", (pAGPListBlock->dwAlignedPointer - pDriverData->GARTLinearBase));
    }
    return (pAGPMem);
}
BOOL FreeAGPHeap
(
    LPDDRAWI_DIRECTDRAW_GBL pDrv,
    DWORD                   pMem
)
{
    DWORD           dwBlockLimit;
    DWORD           dwNewLimit;
    HDDRVITEM       hAGPListBlock;
    HDDRVITEM       hAGPHeap;
    PAGPHEAPLIST    pAGPHeap;
    PAGPHEAPLIST    pAGPHeapHead;
    PAGPHEAPLIST    pAGPHeapTail;
    PAGPHEAPLIST    pPrev;
    PAGPHEAPLIST    pNext;

    /*
     * Make sure this is AGP.
     */
    if (pDriverData->GARTLinearBase == 0)
        return (FALSE);

    /*
     * Find the allocation list block for this address.
     */
#ifndef OLDSTUFF
    pAGPHeapHead = (PAGPHEAPLIST)hAGPHeapHead;
    pAGPHeapTail = (PAGPHEAPLIST)hAGPHeapTail;
#else
    pAGPHeapHead = (PAGPHEAPLIST)DDrvItemArrayGetPtr(pDriverData->hAGPList_gbl, hAGPHeapHead);
    pAGPHeapTail = (PAGPHEAPLIST)DDrvItemArrayGetPtr(pDriverData->hAGPList_gbl, hAGPHeapTail);
#endif
    pAGPHeap     = pAGPHeapHead;
    hAGPHeap     = hAGPHeapHead;
    while ((pAGPHeap) && (pMem != pAGPHeap->dwAlignedPointer))
    {
        /*
         * Watch out for infinite looping.
         */
        if ((pAGPHeap->hNext) && (pAGPHeap->hNext != hAGPHeap))
        {
            hAGPHeap = pAGPHeap->hNext;
#ifndef OLDSTUFF
            pAGPHeap = (PAGPHEAPLIST)hAGPHeap;
#else
            pAGPHeap = (PAGPHEAPLIST)DDrvItemArrayGetPtr(pDriverData->hAGPList_gbl, hAGPHeap);
#endif
        }
        else
        {
            /*
             * Something is messed up because this block is pointing to itself.
             */
            pAGPHeap->hNext = (HDDRVITEM)NULL;
            hAGPHeapTail    = hAGPHeap;
            pAGPHeap        = (PAGPHEAPLIST)NULL;
            hAGPHeap        = (HDDRVITEM)NULL;
        }
    }

    if (pAGPHeap)
    {
        /*
         * Need to free the orignal pointer that was allocated.
         */
        pMem = pAGPHeap->dwPointer;

        /*
         * Remove the allocation block from the list.
         */
#ifndef OLDSTUFF
        pPrev = (PAGPHEAPLIST)pAGPHeap->hPrev;
        pNext = (PAGPHEAPLIST)pAGPHeap->hNext;
#else
        pPrev = (PAGPHEAPLIST)DDrvItemArrayGetPtr(pDriverData->hAGPList_gbl, pAGPHeap->hPrev);
        pNext = (PAGPHEAPLIST)DDrvItemArrayGetPtr(pDriverData->hAGPList_gbl, pAGPHeap->hNext);
#endif
        if (pPrev)
        {
            if (!(pPrev->hNext = pAGPHeap->hNext))
                hAGPHeapTail = pAGPHeap->hPrev;
        }
        else
        {
            hAGPHeapHead = pAGPHeap->hNext;
            pAGPHeapHead = pNext;
        }
        if (pNext)
        {
            if (!(pNext->hPrev = pAGPHeap->hPrev))
                hAGPHeapHead = pAGPHeap->hNext;
        }
        else
        {
            hAGPHeapTail = pAGPHeap->hPrev;
            pAGPHeapTail = pPrev;
        }
        dwNewLimit                 = (pAGPHeapTail) ? pAGPHeapTail->dwLimit : 0;
        dwBlockLimit               = pAGPHeap->dwLimit;
        pDriverData->dwAllocSize -= pAGPHeap->dwSize;

        /*
         * Free the allocation block memory.
         */
        hAGPListBlock = pAGPHeap->hCurrent;
#ifndef OLDSTUFF
        HEAPFREE(pDriverData->hAGPList_gbl, (HDDRVITEM)hAGPListBlock);
#else
        DDrvItemArrayFree(pDriverData->hAGPList_gbl, (HDDRVITEM)hAGPListBlock);
#endif

        /*
         * Check if reduction of AGP context limit is neccessary.
         */
        if ((pDriverData->NvDevFlatDma) && (pDriverData->NvBaseFlat))
        {
            if (dwBlockLimit > dwNewLimit)
            {
                /*
                 * Shrink the AGP limit in the context DMA.
                 * Setting old limit to new limit will make sure that this
                 * operation happens.  There's no reason it shouldn't since
                 * the limit is getting smaller.
                 * If the limit is 0, then map the context to the frame buffer
                 * because the RM/Hardware doesn't like having limts of 0.
                 */
#ifdef  CACHE_FREECOUNT
                nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
                NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#endif  // CACHE_FREECOUNT
                UnplugSystemMemoryTextureContext();
                if (dwNewLimit != 0)
                    AdjustTextureLimit(D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY, pDriverData->GARTLinearBase, dwNewLimit, dwNewLimit);
                else
#ifndef WINNT
                    AdjustTextureLimit(D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY, pDriverData->BaseAddress, 0xFF, 0xFF);
#else
                    AdjustTextureLimit(D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY, pDriverData->ppdev->pjScreen, 0xFF, 0xFF);
#endif // #ifdef WINNT

                UpdateTriangleContexts();

#ifdef  CACHE_FREECOUNT
                pDriverData->dwDmaPusherFreeCount = nvFreeCount;
#ifdef  DEBUG
                NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#endif  // CACHE_FREECOUNT
                /*
                 * Store the current texture heap limit.
                 */
                pDriverData->dwTextureHeapLimit = dwNewLimit;
            }
        }
    }

    /*
     * Destroy the texture heap if there's nothing left allocated in it.
     */
    if (pDriverData->dwAllocSize == 0)
        DestroyTextureHeap();

    /*
     * Free the AGP memory.
     */
    DDHAL32_VidMemFree(pDrv, AGP_HEAP, pMem);
    return (TRUE);
}
BOOL CreateAGPListArray
(
    void
)
{
#ifndef OLDSTUFF
    pDriverData->hAGPList_gbl = (HDDRVITEM)HEAPCREATE(AGPLIST_ARRAY_SIZE * sizeof(AGPHEAPLIST));
#else
    if (!DDrvItemArrayCreate(AGPLIST_ARRAY_SIZE,
                             sizeof(AGPHEAPLIST),
                             AGPLIST_ARRAY_DELTA,
                             &pDriverData->hAGPList_gbl))
    {
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "CreateAGPListArray - AGP List array creation failed!");
        return (FALSE);
    }
#endif
    return (TRUE);
}
BOOL ResetAGPHeap
(
    void
)
{
    /*
     * Make sure this is AGP.
     */
    if ((pDriverData->dwD3DContextCount > 0)
     && (pDriverData->GARTLinearBase > 0))
        DestroyTextureHeap();
    return (TRUE);
}
BOOL DestroyAGPListArray
(
    void
)
{
    if (!pDriverData->hAGPList_gbl)
    {
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "DestroyAGPListArray - No current AGP List array to destroy");
        return (TRUE);
    }
#ifndef OLDSTUFF
    HEAPDESTROY(pDriverData->hAGPList_gbl);
#else
    DDrvItemArrayApplyValid(pDriverData->hAGPList_gbl, DestroyAGPListCallback, 0L);
    DDrvItemArrayDestroy(pDriverData->hAGPList_gbl);
#endif

    /*
     * Once the list is destroyed, there can't be a head or a tail.
     */
    hAGPHeapHead = 0;
    hAGPHeapTail = 0;
    return (TRUE);
}
DWORD DestroyAGPListCallback
(
    LPVOID      lpData,
    HDDRVITEM   hItem,
    DWORD       dwExtra
)
{

    /*
     * No context was actually destroyed on this call, so return an
     * error so that the success count does not get updated for anyone
     * keeping track of these things.
     */
    return (DDRV_ERROR_CONTINUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\DDDRV32.C ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *  Portions Copyright (C) 1995, 1998 NVidia Corporation.  All Rights Reserved.
 *  Portions Copyright (C) 1997 SGS-THOMSON Microelectronics  All Rights Reserved.
 *
 *  File:       dddrv32.c
 *  Content:    sample Windows95 display driver
 *              32 bit DirectDraw part.
 *
 ***************************************************************************/
#ifndef WINNT
#define INITGUID
#endif // #ifndef WINNT
#include "nvd3ddrv.h"
#include "nvcm.h"
#include "nvtypes.h"
#include "nv32.h"
#include "nvddobj.h"
#include "wingdi.h"
#include "dmemmgr.h"

#include "ddrvmem.h"
#include "d3dinc.h"
#include "global.h"
#include "nv4dreg.h"
#include "nv3ddbg.h"
#include "nvheap.h"

#ifdef  MULTI_MON
#include "nvrmapi.h"
#include "nvrmarch.inc"
#endif  /* MULTI_MON */

#define ddHALInfo            pDriverData->HALInfo
//#define OVLCCTL

#define  ST_MAX_VIDEOPORTS   1

GLOBALDATA              *pDriverData;
static HINSTANCE        hInstance;
#ifdef WINNT
SURFACEALIGNMENT    AgpHeapAlignment;
LONG                AgpDummyPitch;
#endif // #ifdef WINNT

/*
 * list of ROPs we support
 *
 * SRCCOPY is the key one to support
 */
static DWORD ropList[] = {
    BLACKNESSBIT | NOTSRCERASEBIT,               // 0x00 - 0x1F
    NOTSRCCOPYBIT,                               // 0x20 - 0x3F
    SRCERASEBIT,                                 // 0x40 - 0x5F
    SRCINVERTBIT,                                // 0x60 - 0x7F
    SRCANDBIT,                                   // 0x80 - 0x9F
    MERGEPAINTBIT,                               // 0xA0 - 0xBF
    SRCCOPYBIT,                                  // 0xC0 - 0xDF
    SRCPAINTBIT | WHITENESSBIT                   // 0xE0 - 0xFF
};


/*
 * IN_VBLANK should be replaced by a test to see if the hardware is currently
 * in the vertical blank
 */
static BOOL     bInVBlank;
static BOOL     bInDisplay;
#define IN_VBLANK               (bInVBlank= !bInVBlank)
#define IN_DISPLAY              (bInDisplay= !bInDisplay)

/*
 * DRAW_ENGINE_BUSY should be replaced by a test to see the bltter is still
 * busy drawing
 */
#define DRAW_ENGINE_BUSY        FALSE

/*
 * ENOUGH_FIFO_FOR_BLT should be replaced with a test to see if there is enough
 * room in the hardware fifo for a blt
 */
#define ENOUGH_FIFO_FOR_BLT     TRUE

/*
 * CURRENT_VLINE should be replaced by a macro to retrieve the current
 * scanline
 */
#define CURRENT_VLINE   0

#ifndef WINNT
FLATPTR EXTERN_DDAPI DDHAL32_VidMemAlloc (LPDDRAWI_DIRECTDRAW_GBL pdrv, int heap, DWORD dwXDim, DWORD dwYDim);
void EXTERN_DDAPI DDHAL32_VidMemFree (LPDDRAWI_DIRECTDRAW_GBL pdrv, int heap, FLATPTR ptr);
#endif

extern Nv10ControlDma * __stdcall NvSysOpenDma(char *, int, int, int);
extern DWORD __stdcall NvSysOpen(DWORD);
extern void  __stdcall NvSysClose(DWORD);
extern DWORD __stdcall Blt8bpp32( LPDDHAL_BLTDATA pbd );
extern DWORD __stdcall Blt16bpp32( LPDDHAL_BLTDATA pbd );
extern DWORD __stdcall Blt32bpp32( LPDDHAL_BLTDATA pbd );
extern DWORD NvDDEnable32();
extern DWORD NvDDDisable32();


extern DWORD __stdcall ConvertOverlay32 ( LPDDRAWI_DDRAWSURFACE_LCL, BOOL waitForCompletion);
extern DWORD __stdcall PreScaleOverlay32 ( LPDDRAWI_DDRAWSURFACE_LCL );
extern DWORD __stdcall DestroyFloating422Context32 ( LPDDRAWI_DDRAWSURFACE_LCL );
extern DWORD __stdcall CreateFloating422Context32 ( LPDDRAWI_DDRAWSURFACE_LCL, DWORD dwBlockSize );
extern DWORD __stdcall UpdateOverlay32( LPDDHAL_UPDATEOVERLAYDATA );
extern DWORD __stdcall SetOverlayPosition32( LPDDHAL_SETOVERLAYPOSITIONDATA );

#ifndef WINNT
extern BOOL  __stdcall GetVideoScalerBandwidthStatus32( DWORD );
#endif

extern DWORD __stdcall CanCreateVideoPort32 ( LPDDHAL_CANCREATEVPORTDATA );
extern DWORD __stdcall CreateVideoPort32 ( LPDDHAL_CREATEVPORTDATA );
extern DWORD __stdcall FlipVideoPort32 ( LPDDHAL_FLIPVPORTDATA );
extern DWORD __stdcall GetVideoPortBandwidth32 ( LPDDHAL_GETVPORTBANDWIDTHDATA );
extern DWORD __stdcall GetVideoPortInputFormat32 ( LPDDHAL_GETVPORTINPUTFORMATDATA );
extern DWORD __stdcall GetVideoPortOutputFormat32 ( LPDDHAL_GETVPORTOUTPUTFORMATDATA );
extern DWORD __stdcall GetVideoPortField32 ( LPDDHAL_GETVPORTFIELDDATA );
extern DWORD __stdcall GetVideoPortLine32 ( LPDDHAL_GETVPORTLINEDATA );
extern DWORD __stdcall GetVideoPortConnectInfo ( LPDDHAL_GETVPORTCONNECTDATA );
extern DWORD __stdcall DestroyVideoPort32 ( LPDDHAL_DESTROYVPORTDATA );
extern DWORD __stdcall GetVideoPortFlipStatus32 ( LPDDHAL_GETVPORTFLIPSTATUSDATA );
extern DWORD __stdcall UpdateVideoPort32 ( LPDDHAL_UPDATEVPORTDATA );
extern DWORD __stdcall WaitForVideoPortSync32 ( LPDDHAL_WAITFORVPORTSYNCDATA );
extern DWORD __stdcall GetVideoSignalStatus32 ( LPDDHAL_GETVPORTSIGNALDATA );
extern DWORD HookUpVxdStorage();


#ifdef NVD3D
/*
 * D3D Hal Fcts
 */
extern BOOL __stdcall D3DHALCreateDriver(LPD3DHAL_GLOBALDRIVERDATA *lplpGlobal,
                                  LPD3DHAL_CALLBACKS* lplpHALCallbacks);
extern BOOL __stdcall D3DGetDriverInfo(LPDDHAL_GETDRIVERINFODATA lpData);

extern BOOL DestroyItemArrays(void);
#endif


#ifndef DEBUG
    #define DPF         1 ? (void)0 : (void)
#else
/*
 * Msg
 * Defined in ddsamp.c
 */
extern void __cdecl DPF( LPSTR szFormat, ... );


void __stdcall NvCachedFreeCountError(long freeCount, long correctFreeCount, DWORD *currentBufferAddress)
{
    DPF( "NvCachedFreeCountError: currentFreeCount=%08lx, correctFreeCount=%08lx, currentPutAddress=%08lx", freeCount, correctFreeCount, currentBufferAddress );
}

#endif


/*
 * ResetNV
 *
 * Reset NV after a mode change
 */
DWORD ResetNV()
{

    /* If currently in full screen DOS, don't allow channel to be enabled */
    if (pDriverData->fFullScreenDosOccurred == 2)
        return;

    if (pDriverData->fDDrawFullScreenDosOccurred == 2)
        return;

    if (pDriverData->NvAGPDmaPusherBufferBase != 0) {
        pDriverData->NvDmaPusherBufferBase = pDriverData->NvAGPDmaPusherBufferBase;
    } else if (pDriverData->NvDmaPusherBufferHandle == 0) {
        pDriverData->NvDmaPusherBufferHandle = (DWORD)
            HEAPCREATE(pDriverData->NvDmaPusherBufferSize);
        pDriverData->NvDmaPusherBufferBase = (DWORD)
            HEAPALLOC(pDriverData->NvDmaPusherBufferHandle, pDriverData->NvDmaPusherBufferSize);
    }

    /*
     * This obviously doesn't handle the case where the AGP push buffer gets moved.
     * That case is handled in UpdateNonlocalVidMem32().
     */

    if (pDriverData->dwDmaPusherCtxDmaSize == 0) {
        if (NvRmAllocContextDma(pDriverData->dwRootHandle,
                           NV_DD_DMA_PUSHER_CONTEXT_DMA_FROM_MEMORY,
                           NV01_CONTEXT_DMA,
                           (ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY |
                           ALLOC_CTX_DMA_FLAGS_LOCKED_CACHED),
                           (PVOID)pDriverData->NvDmaPusherBufferBase,
                           (pDriverData->NvDmaPusherBufferSize - 1)) != NVOS07_STATUS_SUCCESS)
                                return(FALSE);

        pDriverData->dwDmaPusherCtxDmaSize = pDriverData->NvDmaPusherBufferSize;
    }

    if (pDriverData->NvDevFlatDma == 0) {
        if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
            if (NvRmAllocChannelDma(pDriverData->dwRootHandle, NV_WIN_DEVICE,
                                NV_DD_DEV_DMA, NV10_CHANNEL_DMA, 0,
                                NV_DD_DMA_PUSHER_CONTEXT_DMA_FROM_MEMORY, 0,
                                (PVOID)&pDriverData->NvDevFlatDma) != NVOS07_STATUS_SUCCESS)
                                    return(FALSE);
        } else {
            if (NvRmAllocChannelDma(pDriverData->dwRootHandle, NV_WIN_DEVICE,
                                NV_DD_DEV_DMA, NV4_CHANNEL_DMA, 0,
                                NV_DD_DMA_PUSHER_CONTEXT_DMA_FROM_MEMORY, 0,
                                (PVOID)&pDriverData->NvDevFlatDma) != NVOS07_STATUS_SUCCESS)
                                    return(FALSE);
        }

        pDriverData->NvDmaPusherPutAddress = pDriverData->NvDmaPusherBufferBase;
        pDriverData->NvDmaPusherBufferEnd = (long *)
            pDriverData->NvDmaPusherBufferBase + ((pDriverData->NvDmaPusherBufferSize - 4) >> 2);
    }

    if (pDriverData->NvDevVideoFlatPio == 0) {
        if (NvRmAllocChannelPio(pDriverData->dwRootHandle, NV_WIN_DEVICE,
                            NV_DD_DEV_VIDEO, NV3_CHANNEL_PIO, 0,
                            (PVOID)&pDriverData->NvDevVideoFlatPio,
                            ALLOC_CHL_PIO_FLAGS_FIFO_IGNORE_RUNOUT) != NVOS04_STATUS_SUCCESS)
                                return(FALSE);
    }

    pDriverData->wDDrawActive = (WORD)TRUE; // let everyone know DDraw is active

    if (!NvDDEnable32())
        return(FALSE);

    DPF( "    Successfully enabled NV" );

    /* Let D3D code know that we have touched NV */
    pDriverData->TwoDRenderingOccurred = 1;

    pDriverData->DDrawVideoSurfaceCount = 0;

    pDriverData->ddClipUpdate = TRUE;

    // All active floating DMA contexts have been reset
    pDriverData->fNvActiveFloatingContexts = 0;

    // reset overlay source offset
    pDriverData->OverlaySrcX = 0;
    pDriverData->OverlaySrcY = 0;
    pDriverData->OverlayFormat = 0;
    pDriverData->OverlaySrcPitch = 0;
    pDriverData->OverlaySrcSize = 0;

    pDriverData->OverlayBufferIndex = 1;

    /* Make sure overlay owner checking is enabled */
    pDriverData->OverlayRelaxOwnerCheck = 0;

    pDriverData->NvPrevDepth = (BYTE)pDriverData->bi.biBitCount;
    pDriverData->NvFirstCall = 0;

    // Initialize primary surface pointer
    pDriverData->CurrentVisibleSurfaceAddress = pDriverData->BaseAddress;

    // No DMA push blit synchronizations currently in progress
    pDriverData->syncDmaRecord.bSyncFlag = FALSE;

    return(TRUE);
}

#ifndef WINNT
/*
 * SetMode32
 */
DWORD __stdcall SetMode32(
        LPDDHAL_SETMODEDATA lpSetModeData )
{
    HDC hdc = GetDC(0);

    NvSetDriverDataPtr(lpSetModeData->lpDD);

    pDriverData->dwModeIndex = lpSetModeData->dwModeIndex;
    pDriverData->dwUseRefreshRate = lpSetModeData->useRefreshRate;

    // Call back to 16 bit direct draw code to set mode
    ExtEscape(hdc, NVSETDDRAWMODE, 0, 0, 0, 0);

    lpSetModeData->ddRVal = DD_OK;

    return DDHAL_DRIVER_HANDLED;
}
#endif


/*
 * updateFlipStatus
 *
 * checks and sees if the most recent flip has occurred
 */
static __inline HRESULT updateFlipStatus( FLATPTR fpVidMem )
{
    int index;

    /*
     * see if a flip has happened recently
     */
    if (pDriverData->flipPrimaryRecord.bFlipFlag &&
        ((fpVidMem == 0) || (fpVidMem == pDriverData->flipPrimaryRecord.fpFlipFrom)) ) {
        NvNotification *pDmaFlipPrimaryNotifier =
            (NvNotification *)pDriverData->NvDmaFlipPrimaryNotifierFlat;

        if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
            if ((pDmaFlipPrimaryNotifier[1].status == NV_IN_PROGRESS) ||
                (pDmaFlipPrimaryNotifier[2].status == NV_IN_PROGRESS))
                return DDERR_WASSTILLDRAWING;
            else {
                pDriverData->CurrentVisibleSurfaceAddress = pDriverData->flipPrimaryRecord.fpFlipTo;
                pDriverData->flipPrimaryRecord.bFlipFlag = FALSE;
                return DD_OK;
            }
        } else {
            NvNotification *pDmaSyncNotifier =
                (NvNotification *)pDriverData->NvDmaSyncNotifierFlat;
            /* pDmaSyncNotifier is used for NOVSYNC flips for devices < NV10 */
            if ((pDmaFlipPrimaryNotifier[1].status == NV_IN_PROGRESS) ||
                 ((pDmaSyncNotifier->status == NV_IN_PROGRESS) &&
                  (pDriverData->fIsBltStyleFlip)))
                return DDERR_WASSTILLDRAWING;
            else {
                pDriverData->CurrentVisibleSurfaceAddress = pDriverData->flipPrimaryRecord.fpFlipTo;
                pDriverData->flipPrimaryRecord.bFlipFlag = FALSE;
                return DD_OK;
            }
        }
    }

    if (pDriverData->flipOverlayRecord.bFlipFlag &&
        ((fpVidMem == 0) || (fpVidMem == pDriverData->flipOverlayRecord.fpFlipFrom)) ) {
        NvNotification *pPioFlipOverlayNotifier =
            (NvNotification *)pDriverData->NvPioFlipOverlayNotifierFlat;

        index = (pDriverData->OverlayBufferIndex ^ 1) + 1;

        if (pPioFlipOverlayNotifier[index].status == NV_IN_PROGRESS)
            return DDERR_WASSTILLDRAWING;
        else {
            pDriverData->flipOverlayRecord.bFlipFlag = FALSE;
            return DD_OK;
        }
    }

    return DD_OK;

} /* updateFlipStatus */


#ifndef WINNT
/*
 * getDisplayDuration
 *
 * get the length (in ticks) of a refresh cycle
 */
static void getDisplayDuration( void )
{
    int         i;
    __int64     start, end;
    DWORD       oldclass;
    HANDLE      hprocess;

    memset( &pDriverData->flipPrimaryRecord, 0, sizeof( pDriverData->flipPrimaryRecord ) );
    memset( &pDriverData->flipOverlayRecord, 0, sizeof( pDriverData->flipOverlayRecord ) );

    hprocess = GetCurrentProcess();
    oldclass = GetPriorityClass( hprocess );
//    SetPriorityClass( hprocess, REALTIME_PRIORITY_CLASS ); Can't do this due to Electronic Arts bug in Triple Play 97
    SetPriorityClass( hprocess, HIGH_PRIORITY_CLASS );

    NvConfigSet(NV_CFG_VBLANK_TOGGLE, 1, pDriverData->dwDeviceIDNum);
    while (NvConfigGet(NV_CFG_VBLANK_TOGGLE, pDriverData->dwDeviceIDNum)); // wait for next vertical blank to happen
    QueryPerformanceCounter((LARGE_INTEGER*)&start);
    #define LOOP_CNT    20
    for( i=0;i<LOOP_CNT;i++ ) {
        NvConfigSet(NV_CFG_VBLANK_TOGGLE, 1, pDriverData->dwDeviceIDNum);
        while (NvConfigGet(NV_CFG_VBLANK_TOGGLE, pDriverData->dwDeviceIDNum)); // wait for next vertical blank to happen
    }
    QueryPerformanceCounter((LARGE_INTEGER*)&end);

    SetPriorityClass( hprocess, oldclass );
    pDriverData->flipPrimaryRecord.dwFlipDuration = ((DWORD)(end-start) + LOOP_CNT/2)/LOOP_CNT;
    pDriverData->HALInfo.dwMonitorFrequency = (DWORD)start / pDriverData->flipPrimaryRecord.dwFlipDuration;

#ifdef DEBUG
    QueryPerformanceFrequency((LARGE_INTEGER*)&start);

    DPF( "Duration = %d ticks, %dms, %dHz",
        pDriverData->flipPrimaryRecord.dwFlipDuration,
        pDriverData->flipPrimaryRecord.dwFlipDuration * 1000 / (DWORD)start,
        (DWORD)start / pDriverData->flipPrimaryRecord.dwFlipDuration);
#endif
} /* getDisplayDuration */
#endif  // #ifndef WINNT



/*
 * GetBltStatus32
 */
DWORD __stdcall GetBltStatus32(LPDDHAL_GETBLTSTATUSDATA lpGetBltStatus )
{
    FAST Nv10ControlDma *npDev;
    NvNotification      *pDmaSyncNotifier;
    unsigned long       *dmaPusherPutAddress;
    unsigned long       *dmaPusherBufferBase;
    long                freeCount = 0;

    NvSetDriverDataPtr(lpGetBltStatus->lpDD);

    pDmaSyncNotifier = (NvNotification *)pDriverData->NvDmaSyncNotifierFlat;
    dmaPusherPutAddress = (unsigned long *)pDriverData->NvDmaPusherPutAddress;
    dmaPusherBufferBase = (unsigned long *)pDriverData->NvDmaPusherBufferBase;

    /*
     * CANBLT: can we add a blt?
     */
    if( lpGetBltStatus->dwFlags == DDGBS_CANBLT ) {
        /*
         * make sure that we've flipped away from the destination surface
         */
        lpGetBltStatus->ddRVal = updateFlipStatus(
                        lpGetBltStatus->lpDDSurface->lpGbl->fpVidMem );

        if( lpGetBltStatus->ddRVal == DD_OK ) {

            npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;

            if (npDev == NULL) {
                if (!ResetNV()) {
                    lpGetBltStatus->ddRVal = DDERR_GENERIC;
                    return DDHAL_DRIVER_HANDLED;
                }

                dmaPusherPutAddress = (unsigned long *)pDriverData->NvDmaPusherPutAddress;
                        pDriverData->fReset = FALSE;
                npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;

                if (npDev == NULL) {
                    lpGetBltStatus->ddRVal = DDERR_SURFACELOST;
                    return DDHAL_DRIVER_HANDLED;
                }
            }

            /*
             * so there was no flip going on, is there room in the fifo
             * to add a blt?
             */

            NV_DD_DMA_PUSHER_SYNC();

            NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);

            /* Must save pointer in case it was changed by above macro */
            pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

            pDriverData->dwDmaPusherFreeCount = freeCount;

            if(freeCount < 10) {
                lpGetBltStatus->ddRVal = DDERR_WASSTILLDRAWING;
                return DDHAL_DRIVER_HANDLED;
            } else {
                lpGetBltStatus->ddRVal = DD_OK;
            }
        }
    } else {

    /*
     * DONEBLT: is a blt in progress?
     */

        /* Some apps call GetBltStatus many times after calling Blit even after they were told that it was done */
        if (pDriverData->blitCalled == FALSE) {
            lpGetBltStatus->ddRVal = DD_OK;
            return DDHAL_DRIVER_HANDLED;
        }

        npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;

        if (npDev == NULL) {
            if (!ResetNV()) {
                lpGetBltStatus->ddRVal = DDERR_GENERIC;
                return DDHAL_DRIVER_HANDLED;
            }

            dmaPusherPutAddress = (unsigned long *)pDriverData->NvDmaPusherPutAddress;
                pDriverData->fReset = FALSE;
            npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;

            if (npDev == NULL) {
                lpGetBltStatus->ddRVal = DDERR_SURFACELOST;
                return DDHAL_DRIVER_HANDLED;
            }
        }

        /* If a texture surface then just wait for notifier */
        if (lpGetBltStatus->lpDDSurface->ddsCaps.dwCaps & DDSCAPS_TEXTURE) {

            NV_DD_DMA_PUSHER_SYNC();

            /* Let D3D code know that we have touched NV */
            pDriverData->TwoDRenderingOccurred = 1;

#ifdef  CACHE_FREECOUNT
            freeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
            NvCheckCachedFreeCount(freeCount, dmaPusherPutAddress);
#endif  /* DEBUG */
#else   /* CACHE_FREECOUNT */
            freeCount = 0;
#endif  /* CACHE_FREECOUNT */

            while (freeCount < 4)
                NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
            freeCount -= 4;

            pDmaSyncNotifier->status = NV_IN_PROGRESS;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                RECT_AND_TEXT_NOTIFY_OFFSET | 0x40000;
            dmaPusherPutAddress[1] = 0;
            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                RECT_AND_TEXT_NO_OPERATION_OFFSET | 0x40000;
            dmaPusherPutAddress[3] = 0;

            dmaPusherPutAddress += 4;

            pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

            /* Force write combine buffer to flush */
            pDriverData->NvDmaPusherBufferEnd[0] = 0;
            /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
            _outp (0x3d0,0);

            pDriverData->dwDmaPusherFreeCount = freeCount;

            npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

            lpGetBltStatus->ddRVal = DD_OK;

            return DDHAL_DRIVER_HANDLED;
        }


        /* Is there a DMA push blit synchronization in progress ? */
        if (pDriverData->syncDmaRecord.bSyncFlag) { /* if so then check status */
            if (pDmaSyncNotifier->status == NV_IN_PROGRESS)
                lpGetBltStatus->ddRVal = DDERR_WASSTILLDRAWING;
            else {
                lpGetBltStatus->ddRVal = DD_OK;
                pDriverData->syncDmaRecord.bSyncFlag = FALSE;
                pDriverData->blitCalled = FALSE;
            }
        } else { /* start a blit synchronization sequence */
            pDriverData->syncDmaRecord.bSyncFlag = TRUE;

            NV_DD_DMA_PUSHER_SYNC();

            /* Let D3D code know that we have touched NV */
            pDriverData->TwoDRenderingOccurred = 1;

#ifdef  CACHE_FREECOUNT
            freeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
            NvCheckCachedFreeCount(freeCount, dmaPusherPutAddress);
#endif  /* DEBUG */
#else   /* CACHE_FREECOUNT */
            freeCount = 0;
#endif  /* CACHE_FREECOUNT */

            while (freeCount < 4)
                NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
            freeCount -= 4;

            pDmaSyncNotifier->status = NV_IN_PROGRESS;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                RECT_AND_TEXT_NOTIFY_OFFSET | 0x40000;
            dmaPusherPutAddress[1] = 0;
            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                RECT_AND_TEXT_NO_OPERATION_OFFSET | 0x40000;
            dmaPusherPutAddress[3] = 0;

            dmaPusherPutAddress += 4;

            pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

            /* Force write combine buffer to flush */
            pDriverData->NvDmaPusherBufferEnd[0] = 0;
            /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
            _outp (0x3d0,0);

            pDriverData->dwDmaPusherFreeCount = freeCount;

            npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

            if (pDmaSyncNotifier->status == NV_IN_PROGRESS)
                lpGetBltStatus->ddRVal = DDERR_WASSTILLDRAWING;
            else {
                lpGetBltStatus->ddRVal = DD_OK;
                pDriverData->syncDmaRecord.bSyncFlag = FALSE;
                pDriverData->blitCalled = FALSE;
            }
        }
    }

    return DDHAL_DRIVER_HANDLED;

} /* GetBltStatus32 */



/*
 * Blit32
 *
 * 32-bit Blt function for all surfaces.
 *
 * Stupid callback table is built before mode is changed so we never know
 * which function to call until after mode is changed.
 */
DWORD __stdcall Blit32( LPDDHAL_BLTDATA pbd )
{
    FAST Nv10ControlDma *npDev;
    HRESULT     ddrval;

    NvSetDriverDataPtr(pbd->lpDD);

    /*
     * This needs to be here for cases where the channel has closed due to
     * a mode switch or some other reason when there is a pending notification
     * which gets lost due to the channel closure.   ResetNV will deal
     * with clearing the pending notifier.
     */

    npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;

    if (npDev == NULL) {
        if (!ResetNV()) {
            pbd->ddRVal = DDERR_GENERIC;
            return DDHAL_DRIVER_HANDLED;
        }

        pDriverData->fReset = FALSE;
        npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;

        if (npDev == NULL) {
            pbd->ddRVal = DDERR_SURFACELOST;
            return DDHAL_DRIVER_HANDLED;
        }
    }

#ifdef NV_TEX2
    /*
     * texture manager wants full control before all the sync points below
     * it will check for these in time to not break
     */
    if (pbd->lpDDDestSurface->ddsCaps.dwCaps & DDSCAPS_TEXTURE)
    {
        return nvTextureBlt(pbd);
    }
#endif // NV_TEX2

    /*
     * is a flip in progress?
     */
#ifndef DX7
    // DX7 requires that Blit() NEVER return DDERR_WASSTILLDRAWING
    ddrval = updateFlipStatus(pbd->lpDDDestSurface->lpGbl->fpVidMem);
    if( ddrval != DD_OK ) {
        if (pbd->dwFlags & DDBLT_WAIT) {
           while (ddrval != DD_OK) {
               NV_SLEEPFLIP;
               ddrval = updateFlipStatus(pbd->lpDDDestSurface->lpGbl->fpVidMem);
           }
        } else {
           pbd->ddRVal = ddrval;
           return DDHAL_DRIVER_HANDLED;
        }
    }
#endif  // DX7

    pDriverData->blitCalled = TRUE;

    /*
     * Make sure push buffer idle.
     */
    NV_DD_DMA_PUSHER_SYNC();


    /*
     * yet another d3d aa semntics hack
     */
    {
        //pCurrentContext = (PNVD3DCONTEXT)pbd->dwhContext;
        // we depend on pCurrentContext to point to the last used context
        // this may fail if pCurrentContext is not valid
        if ((pCurrentContext)
         && (pCurrentContext->dwAntiAliasFlags & AA_ENABLED_MASK)
         && (pCurrentContext->dwAntiAliasFlags & AA_IN_SCENE))
        {
            NV_D3D_GLOBAL_SETUP();
#ifdef  CACHE_FREECOUNT
            nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
            NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#else   // CACHE_FREECOUNT
            nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSetRenderTargetContexts + sizeSetRenderTarget));
#endif  // CACHE_FREECOUNT
            nvAARenderPrimitive();
            pCurrentContext->dwAntiAliasFlags |= AA_COPY_SCREEN;
            NV_D3D_GLOBAL_SAVE();
        }
    }

    if (pDriverData->bi.biBitCount == 8) {
        return(Blt8bpp32(pbd));
    } else if (pDriverData->bi.biBitCount == 16) {
        return(Blt16bpp32(pbd));
    } else {
        return(Blt32bpp32(pbd));
    }

} /* Blit32 */


/*
 * GetFlipStatus32
 *
 */
DWORD __stdcall GetFlipStatus32(LPDDHAL_GETFLIPSTATUSDATA lpGetFlipStatus )
{
    Nv10ControlDma *npDev;
    DWORD fpVidMem;

    NvSetDriverDataPtr(lpGetFlipStatus->lpDD);

    fpVidMem = lpGetFlipStatus->lpDDSurface->lpGbl->fpVidMem;

    lpGetFlipStatus->ddRVal = updateFlipStatus(fpVidMem);

    npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;

    if (npDev == NULL) {
        lpGetFlipStatus->ddRVal = DDERR_SURFACELOST;
    } else {
        if (lpGetFlipStatus->dwFlags & (DDGFS_CANFLIP | DDGFS_ISFLIPDONE)) {
            NvNotification *pDmaFlipPrimaryNotifier =
                (NvNotification *)pDriverData->NvDmaFlipPrimaryNotifierFlat;

            if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
                if (((pDmaFlipPrimaryNotifier[1].status == NV_IN_PROGRESS) ||
                     (pDmaFlipPrimaryNotifier[2].status == NV_IN_PROGRESS)) &&
                     ((fpVidMem == pDriverData->flipPrimaryRecord.fpFlipFrom) ||
                      (fpVidMem == pDriverData->flipPrimaryRecord.fpFlipTo)))
                        lpGetFlipStatus->ddRVal = DDERR_WASSTILLDRAWING;
            } else {
                NvNotification *pDmaSyncNotifier =
                    (NvNotification *)pDriverData->NvDmaSyncNotifierFlat;
                /* pDmaSyncNotifier is used for NOVSYNC flips for devices < NV10 */
                if (((fpVidMem == pDriverData->flipPrimaryRecord.fpFlipFrom) ||
                     (fpVidMem == pDriverData->flipPrimaryRecord.fpFlipTo)) &&
                     ((pDmaFlipPrimaryNotifier[1].status == NV_IN_PROGRESS) ||
                     ((pDriverData->fIsBltStyleFlip) &&
                      (pDmaSyncNotifier->status == NV_IN_PROGRESS))))
                        lpGetFlipStatus->ddRVal = DDERR_WASSTILLDRAWING;
            }
        }

        /*
         * Check if the push buffer is busy if someone wants to know if they can flip
         */

        if (lpGetFlipStatus->dwFlags & DDGFS_CANFLIP) {

            if (lpGetFlipStatus->ddRVal == DD_OK) {
                unsigned long *dmaPusherPutAddress =
                    (unsigned long *)pDriverData->NvDmaPusherPutAddress;
                unsigned long *dmaPusherBufferBase =
                    (unsigned long *)pDriverData->NvDmaPusherBufferBase;

                NV_DD_DMA_PUSHER_SYNC();

                /* Give the application a chance to do something else if push buffer isn't empty yet */
                if (npDev->Get != (unsigned long)(dmaPusherPutAddress - dmaPusherBufferBase) << 2) {
                    /* Force write combine buffer to flush */
                    pDriverData->NvDmaPusherBufferEnd[0] = 0;
                    /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                    _outp (0x3d0,0);
                    npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;
                    lpGetFlipStatus->ddRVal = DDERR_WASSTILLDRAWING;
                }
            }
        }
    }

    return DDHAL_DRIVER_HANDLED;

} /* GetFlipStatus32 */


// ------------------------------------------------------------------------------------------
// YUV422ColourControl
//      Simulates colour controls on YUV422 surfaces.  So far only supports contrast.
//      Returns TRUE if success
#ifndef OVLCCTL
#define YUV422ColourControl(a,b)
#else
BOOL __stdcall YUV422ColourControl(LPDDRAWI_DDRAWSURFACE_GBL lpGbl, LPDDCOLORCONTROL lpDDCC)
{
//FAST Nv10ControlDma *npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;
//unsigned long *dmaPusherPutAddress = (unsigned long *)pDriverData->NvDmaPusherPutAddress;
//unsigned long *dmaPusherBufferBase = (unsigned long *)pDriverData->NvDmaPusherBufferBase;
//long freeCount = 0;
DDPIXELFORMAT *lpPixelFormat = &lpGbl->ddpfSurface;
DWORD overlayFourCC = 0;
DWORD dwContrast;
DWORD  dwOffset = (DWORD)lpGbl->fpVidMem - (DWORD)pDriverData->BaseAddress;
FAST Nv3ChannelPio *npDevVideo = (Nv3ChannelPio *)pDriverData->NvDevVideoFlatPio;
FAST long videoFreeCount = NvGetFreeCount(npDevVideo, NV_DD_SPARE);

    if (lpPixelFormat->dwSize == sizeof(DDPIXELFORMAT) && (lpPixelFormat->dwFlags & DDPF_FOURCC))
        overlayFourCC = lpPixelFormat->dwFourCC;
    if (overlayFourCC == MAKEFOURCC('Y','U','Y','2'))
        dwContrast = lpDDCC->lContrast | (lpDDCC->lContrast << 16) | 0xFF00FF00;
    else if (overlayFourCC == MAKEFOURCC('U','Y','V','Y'))
        dwContrast = (lpDDCC->lContrast << 8) | (lpDDCC->lContrast << 24) | 0x00FF00FF;
    else dwContrast = 0xFFFFFFFF;

    if (dwContrast == 0xFFFFFFFF) return FALSE;

    while (videoFreeCount < 48)
        videoFreeCount = NvGetFreeCount(npDevVideo, NV_DD_SPARE);
    videoFreeCount -= 48;

    /* Trash spare subchannel */
    npDevVideo->dDrawSpare.SetObject = NV_DD_CONTEXT_BETA4;
    npDevVideo->dDrawSpare.nv4ContextBeta.SetBetaFactor = dwContrast;
    npDevVideo->dDrawSpare.SetObject = NV_DD_SURFACES_2D_A8R8G8B8;
    npDevVideo->dDrawSpare.nv4ContextSurfaces2D.SetPitch = (lpGbl->lPitch << 16) | lpGbl->lPitch;
    npDevVideo->dDrawSpare.nv4ContextSurfaces2D.SetOffsetSource = dwOffset;
    npDevVideo->dDrawSpare.nv4ContextSurfaces2D.SetOffsetDestin = dwOffset;
    npDevVideo->dDrawSpare.SetObject = NV_DD_SRCCOPY_PREMULT_A8R8G8B8_IMAGE_BLIT;
    npDevVideo->dDrawSpare.nv4ImageBlit.ControlPointIn = 0;
    npDevVideo->dDrawSpare.nv4ImageBlit.ControlPointOut = 0;
    npDevVideo->dDrawSpare.nv4ImageBlit.Size = (lpGbl->wHeight << 16) | (lpGbl->wWidth >> 1);

    pDriverData->dDrawSpareSubchannelObject = 0;

    /* Force fifo to stall until blit operation finishes */
    npDevVideo->dDrawSpare.nv4ImageBlit.Notify = 0;
    npDevVideo->dDrawSpare.nv4ImageBlit.NoOperation = 0;

    return TRUE;
}
#endif

/*
 * Flip32
 *
 * Flip RGB or overlay surfaces.
 *
 * NOTES:
 *
 * When flipping overlay surfaces NOT associated with a video port
 * the surface will be flipped according to the following criteria.
 * DDOVER_INTERLEAVED and DDOVER_BOB values used are those set on most
 * recent UpdateOverlay32 call referencing this overlay surface.
 *
 *  DDOVER_INTERLEAVED  DDOVER_BOB  DDFLIP_EVEN DDFLIP_ODD  DISPLAYED
 *
 *          1               1            1          0       Even field
 *          1               1            X          1       Odd field with BOB
 *          1               1            0          0       Full interleaved surface
 *          1               0            1          0       Even field
 *          1               0            X          1       Odd field
 *          1               0            0          0       Full interleaved surface
 *          0               1            X          X       Full non-interleaved surface
 *          0               0            X          X       Full non-interleaved surface
 *
 */

DWORD __stdcall Flip32(  LPDDHAL_FLIPDATA pfd )
{
    FAST Nv10ControlDma         *npDev;
    NvNotification              *pDmaFlipPrimaryNotifier;
    NvNotification              *pPioFlipOverlayNotifier;
    NvNotification              *pDmaSyncNotifier;
    NvNotification              *pDmaDmaFromMemNotifier;
    HRESULT                     ddrval;
    LPDDRAWI_DDRAWSURFACE_GBL   pSurfTarg_gbl;
    BOOL                        bIsD3D;
    BOOL                        waitForVsync = TRUE;

    NvSetDriverDataPtr(pfd->lpDD);

    npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;
    pDmaFlipPrimaryNotifier = (NvNotification *)pDriverData->NvDmaFlipPrimaryNotifierFlat;
    pPioFlipOverlayNotifier = (NvNotification *)pDriverData->NvPioFlipOverlayNotifierFlat;
    pDmaSyncNotifier = (NvNotification *)pDriverData->NvDmaSyncNotifierFlat;
    pDmaDmaFromMemNotifier = (NvNotification *)pDriverData->NvDmaDmaFromMemNotifierFlat;

    /*
     * NOTES:
     *
     * This callback is invoked whenever we are about to flip to from
     * one surface to another.   pfd->lpSurfCurr is the surface we were at,
     * pfd->lpSurfTarg is the one we are flipping to.
     *
     * You should point the hardware registers at the new surface, and
     * also keep track of the surface that was flipped away from, so
     * that if the user tries to lock it, you can be sure that it is done
     * being displayed
     */

    DPF_LEVEL(NVDBG_LEVEL_FLIP,"Flip32: curr=%08lx, targ=%08lx", pfd->lpSurfCurr, pfd->lpSurfTarg );
    DPF_LEVEL(NVDBG_LEVEL_FLIP,"        vidmem ptrs change: %08lx->%08lx",
                                        pfd->lpSurfCurr->lpGbl->fpVidMem,
                                        pfd->lpSurfTarg->lpGbl->fpVidMem );

    /*
     * D3D: no VSync will insert a Blt and exit
     */
    bIsD3D = (pfd->lpSurfTarg->ddsCaps.dwCaps & DDSCAPS_3DDEVICE)
          && (pfd->lpSurfCurr->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE)
          && (pfd->lpSurfCurr->ddsCaps.dwCaps & DDSCAPS_3DDEVICE);

    if ((((pDriverData->regD3DEnableBits1 & REG_BIT1_NO_WAIT_4_VSYNC) && bIsD3D)) ||
          (pfd->dwFlags & DDFLIP_NOVSYNC)) {

        /* DDFLIP_NOVSYNC flips must be restricted to normal frame depth count */
        if ((pfd->dwFlags & DDFLIP_NOVSYNC) &&
            (pDriverData->NvDeviceVersion < NV_DEVICE_VERSION_10)) {

            ddrval = updateFlipStatus(0);

            if (ddrval != DD_OK) {
                if (pfd->dwFlags & DDFLIP_WAIT) {
                    while (ddrval != DD_OK) {
                                        NV_SLEEPFLIP;
                        ddrval = updateFlipStatus(0);
                    }
                } else {
                    pfd->ddRVal = ddrval;
                    return DDHAL_DRIVER_HANDLED;
                }
            }
        }

        /*
         * Check how many frames we are ahead
         *  we want to limit this since we have serious lag effect on fast CPUs
         */
        // free count for d3d stuff must be accurate
#ifndef NV_NULL_HW_DRIVER
        {
            NV_D3D_GLOBAL_SETUP();
#ifdef  CACHE_FREECOUNT
            nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
            NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#else   /* CACHE_FREECOUNT */
            nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, 1);
#endif  /* CACHE_FREECOUNT */

            if ((int)(pDriverData->dwCurrentFrame - pDriverData->dwRenderedFrame) > pDriverData->regPreRenderLimit)
            {
                nvStartDmaBuffer (FALSE);
                /*
                 * if we do not have to wait here - don't
                 */
                /* it does not seem to work - some apps just fail to call Flip again
                if (!(pfd->dwFlags & DDFLIP_WAIT))
                {
                    pfd->ddRVal = DDERR_WASSTILLDRAWING;
                    return DDHAL_DRIVER_HANDLED;
                }
                */
                /*
                 * wait for HW to catch up
                 */
#ifdef NV_PROFILE
                NVP_START(NVP_T_FLIP);
#endif

                do
                {
                    NV_DELAY;
#ifndef WINNT
                  pDriverData->dwRenderedFrame = *(DWORD*)(pDriverData->dwTMPseudoNotifierOffset + NV_PN_SPOOFED_FLIP_COUNT + pDriverData->BaseAddress);
#else
                  pDriverData->dwRenderedFrame = *(DWORD*)(pDriverData->dwTMPseudoNotifierOffset + NV_PN_SPOOFED_FLIP_COUNT + (ULONG) pDriverData->ppdev->pjScreen);
#endif // #ifdef WINNT

                } while ((int)(pDriverData->dwCurrentFrame - pDriverData->dwRenderedFrame) > pDriverData->regPreRenderLimit);

#ifdef NV_PROFILE
                NVP_STOP(NVP_T_FLIP);
                nvpLogTime(NVP_T_FLIP,nvpTime[NVP_T_FLIP]);
#endif
            }
            /*
             * Update frame counters
             */
            pDriverData->dwCurrentFrame++;
            if (!pDriverData->dwCurrentFrame) { pDriverData->dwCurrentFrame = pDriverData->dwRenderedFrame = 0; } // wrap around case
            nvPlacePsuedoNotifier (NV_PN_SPOOFED_FLIP_COUNT,pDriverData->dwCurrentFrame);
            NV_D3D_GLOBAL_SAVE();
#ifdef  CACHE_FREECOUNT
            pDriverData->dwDmaPusherFreeCount = nvFreeCount;
#ifdef  DEBUG
            NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#endif  /* CACHE_FREECOUNT */
        }
#endif  //!NV_NULL_HW_DRIVER


        if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
            waitForVsync = FALSE;
        } else {
            /*
             * Do the Blt
             */
            DWORD  dwSrcOffset =  (DWORD)VIDMEM_OFFSET(pfd->lpSurfTarg->lpGbl->fpVidMem);
            DWORD  dwDstOffset =  (DWORD)VIDMEM_OFFSET(pfd->lpSurfCurr->lpGbl->fpVidMem);
            DWORD  dwPitch     = (pfd->lpSurfTarg->lpGbl->lPitch  << 16) | pfd->lpSurfCurr->lpGbl->lPitch;
            DWORD  dwDims      = (pfd->lpSurfCurr->lpGbl->wHeight << 16) | pfd->lpSurfCurr->lpGbl->wWidth;
            unsigned long *dmaPusherPutAddress =
                (unsigned long *)pDriverData->NvDmaPusherPutAddress;
            unsigned long *dmaPusherBufferBase =
                (unsigned long *)pDriverData->NvDmaPusherBufferBase;
#ifdef  CACHE_FREECOUNT
            long freeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
            NvCheckCachedFreeCount(freeCount, dmaPusherPutAddress);
#endif  /* DEBUG */
#else   /* CACHE_FREECOUNT */
            long freeCount = 0;
#endif  /* CACHE_FREECOUNT */

            if (pDriverData->dwSharedClipChangeCount != pDriverData->dwDDMostRecentClipChangeCount) {

                while (freeCount < 7)
                    NvGetDmaBufferFreeCount(npDev, freeCount, 7, dmaPusherPutAddress);
                freeCount -= 7;

                dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000;
                dmaPusherPutAddress[1] = NV_DD_IMAGE_BLACK_RECTANGLE;
                dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                    IMAGE_BLACK_RECTANGLE_POINT_OFFSET | 0x80000;
                dmaPusherPutAddress[3] = 0;
                dmaPusherPutAddress[4] = asmMergeCoords(NV_MAX_X_CLIP, NV_MAX_Y_CLIP);
                dmaPusherPutAddress[5] = dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000;
                dmaPusherPutAddress[6] = NV_DD_SURFACES_2D;

                dmaPusherPutAddress += 7;

                pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

                /* Force write combine buffer to flush */
                pDriverData->NvDmaPusherBufferEnd[0] = 0;
                /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                _outp (0x3d0,0);

                pDriverData->dwDmaPusherFreeCount = freeCount;

                npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                pDriverData->dwSharedClipChangeCount++;

                pDriverData->dwDDMostRecentClipChangeCount = pDriverData->dwSharedClipChangeCount;
            }

            while (freeCount < 10)
                NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);
            freeCount -= 10;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
                SET_ROP_OFFSET | 0x40000;
            dmaPusherPutAddress[1] = SRCCOPYINDEX;

            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                SURFACES_2D_PITCH_OFFSET | 0xC0000;
            dmaPusherPutAddress[3] = dwPitch;
            dmaPusherPutAddress[4] = dwSrcOffset;
            dmaPusherPutAddress[5] = dwDstOffset;

            dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_BLIT) +
                BLIT_POINT_IN_OFFSET | 0xC0000;
            dmaPusherPutAddress[7] = 0;
            dmaPusherPutAddress[8] = 0;
            dmaPusherPutAddress[9] = dwDims;

            dmaPusherPutAddress += 10;

            if (pfd->dwFlags & DDFLIP_NOVSYNC) {

                pDriverData->flipPrimaryRecord.fpFlipFrom = pfd->lpSurfCurr->lpGbl->fpVidMem;
                pDriverData->flipPrimaryRecord.fpFlipTo = pfd->lpSurfTarg->lpGbl->fpVidMem;

                pDriverData->flipPrimaryRecord.bFlipFlag = TRUE;

                pDriverData->fIsBltStyleFlip = TRUE;

                pDmaSyncNotifier->status = NV_IN_PROGRESS;

                while (freeCount < 4)
                    NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
                freeCount -= 4;

                dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                    RECT_AND_TEXT_NOTIFY_OFFSET | 0x40000;
                dmaPusherPutAddress[1] = 0;
                dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                    RECT_AND_TEXT_NO_OPERATION_OFFSET | 0x40000;
                dmaPusherPutAddress[3] = 0;

                dmaPusherPutAddress += 4;
            }

            pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

            /* Force write combine buffer to flush */
            pDriverData->NvDmaPusherBufferEnd[0] = 0;
            /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
            _outp (0x3d0,0);

            pDriverData->dwDmaPusherFreeCount = freeCount;

            npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

            /*
             * flip the vidmem pointers (so ddraw can flip them back)
             */
            pfd->lpSurfCurr->lpGbl->fpVidMem = dwSrcOffset + (DWORD)pDriverData->BaseAddress;
            pfd->lpSurfTarg->lpGbl->fpVidMem = dwDstOffset + (DWORD)pDriverData->BaseAddress;

            /*
             * done
             */
            pfd->ddRVal = DD_OK;
            return DDHAL_DRIVER_HANDLED;
        }
    }

    /*
     * everything is OK, do the flip here
     */

    pDriverData->fIsBltStyleFlip = FALSE;

    pSurfTarg_gbl = pfd->lpSurfTarg->lpGbl;

    pDriverData->flipPrimaryRecord.bIsD3DSurface = FALSE;

    /* Is this an overlay surface ? */
    if (!(pfd->lpSurfTarg->ddsCaps.dwCaps & (DDSCAPS_OVERLAY | DDSCAPS_VIDEOPORT))) {
        /* No - assume it is the primary surface */
        unsigned long *dmaPusherPutAddress =
            (unsigned long *)pDriverData->NvDmaPusherPutAddress;
        unsigned long *dmaPusherBufferBase =
            (unsigned long *)pDriverData->NvDmaPusherBufferBase;
#ifdef  CACHE_FREECOUNT
        long freeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
        NvCheckCachedFreeCount(freeCount, dmaPusherPutAddress);
#endif  /* DEBUG */
#else   /* CACHE_FREECOUNT */
        long freeCount = 0;
#endif  /* CACHE_FREECOUNT */

#ifdef NV_PROFILE
        NVP_START(NVP_T_FLIP);
#endif

#ifdef FORCED_TRIPLE_BUFFER
        if (pDriverData->bNeedToAttachBuffer) {
            HRESULT result;
            IDirectDrawSurface *lpSurfPrimary_int = (IDirectDrawSurface *) pfd->lpDD->lpExclusiveOwner->lpPrimary;
            if (lpSurfPrimary_int) {
                result = IDirectDrawSurface_AddAttachedSurface(lpSurfPrimary_int, pDriverData->lpBuffer3);
                if (result != DD_OK) {
                    IDirectDrawSurface_Release(pDriverData->lpBuffer3);
                    pDriverData->lpBuffer3 = NULL;
                }
            }
            pDriverData->bNeedToAttachBuffer = FALSE;
        }
#endif // FORCED_TRIPLE_BUFFER

        ddrval = updateFlipStatus(0);

        if (ddrval != DD_OK) {
            /* Flush DMA push buffer on first Flip call regardless of current flip status */
            if (!(pDriverData->fDmaPushBufferHasBeenFlushed)) {

                /*
                 * is NV busy right now?
                 */
                NV_DD_DMA_PUSHER_SYNC();

                /* Optimize flip waits for D3D rendered surfaces. */
                pDriverData->flipPrimaryRecord.bIsD3DSurface = bIsD3D;

                if (npDev == NULL) {
                    pfd->ddRVal = DDERR_SURFACELOST;
                    return DDHAL_DRIVER_HANDLED;
                }

                while (freeCount < 4)
                    NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
                freeCount -= 4;

                /* Let D3D code know that we have touched NV */
                pDriverData->TwoDRenderingOccurred = 1;

                pDmaSyncNotifier->status = NV_IN_PROGRESS;

                dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                    RECT_AND_TEXT_NOTIFY_OFFSET | 0x40000;
                dmaPusherPutAddress[1] = 0;
                dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                    RECT_AND_TEXT_NO_OPERATION_OFFSET | 0x40000;
                dmaPusherPutAddress[3] = 0;

                dmaPusherPutAddress += 4;

                pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

                /* Force write combine buffer to flush */
                pDriverData->NvDmaPusherBufferEnd[0] = 0;
                /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                _outp (0x3d0,0);

                pDriverData->dwDmaPusherFreeCount = freeCount;

                npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                pDriverData->fDmaPushBufferHasBeenFlushed = TRUE;
            }

            if (pfd->dwFlags & DDFLIP_WAIT) {
                while (ddrval != DD_OK) {
                    NV_SLEEPFLIP;
                    ddrval = updateFlipStatus(0);
                }
            } else {
                pfd->ddRVal = ddrval;
                return DDHAL_DRIVER_HANDLED;
            }
        }

        /*
         * is NV busy right now?
         */
        NV_DD_DMA_PUSHER_SYNC();

#ifdef NV_PROFILE
        NVP_STOP(NVP_T_FLIP);
        nvpLogTime(NVP_T_FLIP,nvpTime[NVP_T_FLIP]);
#endif

        /* Optimize flip waits for D3D rendered surfaces. */
        /*
        if (pSurfTarg_gbl->fpVidMem == pDriverData->lpLast3DSurfaceRendered)
            pDriverData->flipPrimaryRecord.bIsD3DSurface = TRUE;
        */
        pDriverData->flipPrimaryRecord.bIsD3DSurface = bIsD3D;

        if (npDev == NULL) {
            pfd->ddRVal = DDERR_SURFACELOST;
            return DDHAL_DRIVER_HANDLED;
        }

        while (freeCount < 4)
            NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
        freeCount -= 4;

        /* Let D3D code know that we have touched NV */
        pDriverData->TwoDRenderingOccurred = 1;

        pDmaSyncNotifier->status = NV_IN_PROGRESS;

        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
            RECT_AND_TEXT_NOTIFY_OFFSET | 0x40000;
        dmaPusherPutAddress[1] = 0;
        dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
            RECT_AND_TEXT_NO_OPERATION_OFFSET | 0x40000;
        dmaPusherPutAddress[3] = 0;

        dmaPusherPutAddress += 4;

        pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

        pDriverData->flipPrimaryRecord.fpFlipFrom = pfd->lpSurfCurr->lpGbl->fpVidMem;
        pDriverData->flipPrimaryRecord.fpFlipTo = pSurfTarg_gbl->fpVidMem;

        pDriverData->flipPrimaryRecord.bFlipFlag = TRUE;

        pDriverData->primaryBufferIndex ^= 1;

        if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {

            pDmaFlipPrimaryNotifier[pDriverData->primaryBufferIndex + 1].status = NV_IN_PROGRESS;

            /* Temporarily load VIDEO_LUT_CURSOR_DAC object */
            while (freeCount < 7)
                NvGetDmaBufferFreeCount(npDev, freeCount, 7, dmaPusherPutAddress);
            freeCount -= 7;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000;
            dmaPusherPutAddress[1] = NV_DD_VIDEO_LUT_CURSOR_DAC;
            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                NV067_SET_IMAGE_OFFSET(pDriverData->primaryBufferIndex) | 0x80000;
            dmaPusherPutAddress[3] = pSurfTarg_gbl->fpVidMem - pDriverData->BaseAddress;
            if (waitForVsync)
                dmaPusherPutAddress[4] = (NV067_SET_IMAGE_FORMAT_NOTIFY_WRITE_ONLY << 31) ||
                                         (NV067_SET_IMAGE_FORMAT_WHEN_NOT_WITHIN_BUFFER << 20) ||
                                         pSurfTarg_gbl->lPitch;
            else
                dmaPusherPutAddress[4] = (NV067_SET_IMAGE_FORMAT_NOTIFY_WRITE_ONLY << 31) ||
                                         (NV067_SET_IMAGE_FORMAT_WHEN_IMMEDIATELY << 20) ||
                                         pSurfTarg_gbl->lPitch;
            dmaPusherPutAddress[5] = dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000;
            dmaPusherPutAddress[6] = NV_DD_SURFACES_2D;

            dmaPusherPutAddress += 7;

        } else {

            pDmaFlipPrimaryNotifier[1].status = NV_IN_PROGRESS;

            /* Temporarily load VIDEO_FROM_MEMORY object */
            while (freeCount < 10)
                NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);
            freeCount -= 10;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000;
            dmaPusherPutAddress[1] = NV_DD_PRIMARY_VIDEO_FROM_MEMORY;
            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                VIDEO_FROM_MEM_OFFSET_OFFSET | 0x140000;
            dmaPusherPutAddress[3] = pSurfTarg_gbl->fpVidMem - pDriverData->BaseAddress;
            dmaPusherPutAddress[4] = pSurfTarg_gbl->lPitch;
            dmaPusherPutAddress[5] = asmMergeCoords(pSurfTarg_gbl->wWidth, pSurfTarg_gbl->wHeight);
            if (pDriverData->bi.biBitCount == 8)
                dmaPusherPutAddress[6] = NV_VFM_FORMAT_COLOR_LE_Y8_P4;
            else if (pDriverData->bi.biBitCount == 16)
                dmaPusherPutAddress[6] = NV_VFM_FORMAT_COLOR_LE_X1R5G5B5_P2;
            else
                dmaPusherPutAddress[6] = NV_VFM_FORMAT_COLOR_LE_X8R8G8B8;
            dmaPusherPutAddress[7] = 0;
            dmaPusherPutAddress[8] = dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000;
            dmaPusherPutAddress[9] = NV_DD_SURFACES_2D;

            dmaPusherPutAddress += 10;
        }

        pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

        /* Force write combine buffer to flush */
        pDriverData->NvDmaPusherBufferEnd[0] = 0;
        /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
        _outp (0x3d0,0);

        pDriverData->dwDmaPusherFreeCount = freeCount;

        npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

        pDriverData->fDmaPushBufferHasBeenFlushed = FALSE;

        DPF( "Flip32: RGB Flip request completed successfully");

    } else if (pfd->lpSurfTarg->ddsCaps.dwCaps & DDSCAPS_OVERLAY) { /* flip overlay */
        FAST Nv3ChannelPio *npDevVideo = (Nv3ChannelPio *)pDriverData->NvDevVideoFlatPio;
        FAST long videoFreeCount;
        DWORD dwOffset;
        DWORD dwPitch;
        DWORD dwHeight;
        DWORD index;
        DWORD doBob = 0;
        DWORD dwFieldFlags = 0;
        DWORD dwOverlayDeltaY = pDriverData->dwOverlayDeltaY;
        DWORD preScaleOverlay = 0;
        DWORD srcPreShrinkDeltaX;
        DWORD srcPreShrinkDeltaY;
        BOOL  surfaceIs422 = FALSE;

        if (npDevVideo == NULL) {
            pfd->ddRVal = DDERR_SURFACELOST;
            return DDHAL_DRIVER_HANDLED;
        }

        if (pDriverData->fDDrawFullScreenDosOccurred) {
            pDriverData->OverlayRelaxOwnerCheck = 1;        /* relax owner check when we come back from DOS mode */
            if (pDriverData->fDDrawFullScreenDosOccurred == 2) {  /* still in DOS mode ? */
                pPioFlipOverlayNotifier[1].status = 0;      /* clear notifiers */
                pPioFlipOverlayNotifier[2].status = 0;
                pfd->ddRVal = DDERR_SURFACEBUSY;
                return DDHAL_DRIVER_HANDLED;
            } else {                                        /* back to hires mode */
                pPioFlipOverlayNotifier[1].status = 0;      /* clear notifiers */
                pPioFlipOverlayNotifier[2].status = 0;
                pDriverData->fDDrawFullScreenDosOccurred = 0;    /* reset flag */
            }
        }

        /* Limit flips to 1 at a time to work around NV4 RM limitation */
        ddrval = updateFlipStatus(pSurfTarg_gbl->fpVidMem);

        /* Only reject flip requests when flipping frames (but allow fields to proceed) */
        if (pfd->dwFlags & (DDFLIP_ODD | DDFLIP_EVEN) == 0) {
            if (ddrval != DD_OK) {
                if (pfd->dwFlags & DDFLIP_WAIT) {
                    // do contrast blt (only supports YUV422 style formats)
                    YUV422ColourControl(pfd->lpSurfTarg->lpGbl, &pDriverData->OverlayColourControl);

                    while (ddrval != DD_OK) {
                        NV_SLEEPFLIP;
                        ddrval = updateFlipStatus(pSurfTarg_gbl->fpVidMem);
                    }
                } else {
                    pfd->ddRVal = ddrval;
                    return DDHAL_DRIVER_HANDLED;
                }
            } else {
                // do contrast blt (only supports YUV422 style formats)
                YUV422ColourControl(pfd->lpSurfTarg->lpGbl, &pDriverData->OverlayColourControl);
            }
        } else {
            // do contrast blt (only supports YUV422 style formats)
            YUV422ColourControl(pfd->lpSurfTarg->lpGbl, &pDriverData->OverlayColourControl);
        }

        /*
         * is NV busy right now?
         */
        NV_DD_DMA_PUSHER_SYNC();

        if (pDriverData->dwOverlaySurfaces > 2)
            ConvertOverlay32(pfd->lpSurfTarg, TRUE);

        videoFreeCount = NvGetFreeCount(npDevVideo, NV_DD_SPARE);

        pDriverData->flipOverlayRecord.fpFlipFrom = pfd->lpSurfCurr->lpGbl->fpVidMem;
        pDriverData->flipOverlayRecord.fpFlipTo = pSurfTarg_gbl->fpVidMem;

        pDriverData->flipOverlayRecord.bFlipFlag = TRUE;

        /* Make sure we flip to the correct starting offset in new overlay surface */
        dwOffset = pSurfTarg_gbl->fpVidMem - pDriverData->BaseAddress;

        if ((pSurfTarg_gbl->ddpfSurface.dwFourCC == FOURCC_IF09) ||
            (pSurfTarg_gbl->ddpfSurface.dwFourCC == FOURCC_YVU9) ||
            (pSurfTarg_gbl->ddpfSurface.dwFourCC == FOURCC_IV32) ||
            (pSurfTarg_gbl->ddpfSurface.dwFourCC == FOURCC_IV31)) {
            /* Skip over Indeo portion of surface */
            dwPitch = (DWORD)pSurfTarg_gbl->wWidth;
            dwOffset += ((dwPitch * ((DWORD)pSurfTarg_gbl->wHeight * 10L)) >> 3);
            /* Force block to be properly aligned */
            dwOffset = (dwOffset + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
            dwPitch = ((pSurfTarg_gbl->wWidth + 1) & 0xFFFE) << 1;
            dwPitch = (dwPitch + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
        } else if ((pSurfTarg_gbl->ddpfSurface.dwFourCC == FOURCC_YV12) ||
                   (pSurfTarg_gbl->ddpfSurface.dwFourCC == FOURCC_420i)) {
            /* Assumes a separate overlay YUY2 surface in video memory */
            if (pSurfTarg_gbl->fpVidMem == pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0])
                dwOffset = pDriverData->NvYUY2Surface0Mem -
                               pDriverData->BaseAddress;
            else if (pSurfTarg_gbl->fpVidMem == pDriverData->NvFloatingMem2MemFormatSurfaceAddress[1])
                dwOffset = pDriverData->NvYUY2Surface1Mem -
                               pDriverData->BaseAddress;
            else if (pSurfTarg_gbl->fpVidMem == pDriverData->NvFloatingMem2MemFormatSurfaceAddress[2])
                dwOffset = pDriverData->NvYUY2Surface2Mem -
                               pDriverData->BaseAddress;
            else
                dwOffset = pDriverData->NvYUY2Surface3Mem -
                               pDriverData->BaseAddress;

            dwPitch = ((pSurfTarg_gbl->wWidth + 1) & 0xFFFE) << 1;
            dwPitch = (dwPitch + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
        } else {
            dwPitch = (DWORD)pSurfTarg_gbl->lPitch;
            surfaceIs422 = TRUE;
        }

        /* Assume full surface height */
        dwHeight = (DWORD)pSurfTarg_gbl->wHeight;

        if ( !(pfd->lpSurfTarg->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT)  ) {
            if (pfd->dwFlags & (DDFLIP_ODD | DDFLIP_EVEN)) {
                if (pfd->lpSurfTarg->lpSurfMore) {
                    if (pfd->lpSurfTarg->lpSurfMore->dwOverlayFlags & DDOVER_INTERLEAVED) {
                        dwPitch <<= 1;
                        dwFieldFlags = pfd->dwFlags;
                        if ((pfd->dwFlags & DDFLIP_ODD) &&
                            (pfd->lpSurfTarg->lpSurfMore->dwOverlayFlags & DDOVER_BOB))
                            doBob = 2; /* Tell RM to BOB this field */
                    } else {
                        if ((pfd->dwFlags & DDFLIP_ODD) &&
                            (pfd->lpSurfTarg->lpSurfMore->dwOverlayFlags & DDOVER_BOB))
                            doBob = 2; /* Tell RM to BOB this field */
                    }
                }
                /* If flipping interleaved fields then halve the surface height */
                if (dwFieldFlags & (DDFLIP_ODD | DDFLIP_EVEN)) {
                    dwHeight >>= 1;
#ifdef  NOPRESTRETCH
                    dwOverlayDeltaY >>= 1;
#endif  // NOPRESTRETCH
                }
            } else {
                /* Sometimes we get calls with DDOVER_INTERLEAVED set but with neither DDFLIP_ODD nor DDFLIP_EVEN flags set. */
                /* This happens mostly during transitions when dynamic bob and weave are occurring. */
                if (pfd->lpSurfTarg->lpSurfMore) {
                    if (pfd->lpSurfTarg->lpSurfMore->dwOverlayFlags & DDOVER_INTERLEAVED) {
                        if (pfd->lpSurfTarg->lpSurfMore->dwOverlayFlags & DDOVER_BOB) {
#ifdef  NOPRESTRETCH
                            dwOverlayDeltaY >>= 1;
#endif  // NOPRESTRETCH
                            dwHeight >>= 1;
                            dwPitch <<= 1;
                            doBob = 2;
                            dwFieldFlags = DDFLIP_ODD;
                        }
                    }
                }
            }
        }

        srcPreShrinkDeltaX = 0x100000;
        srcPreShrinkDeltaY = 0x100000;

        if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {

            if ((((pDriverData->dwOverlaySrcWidth + 7) >> 3) >
                   pDriverData->dwOverlayDstWidth) && (pDriverData->dwOverlayDstWidth > 0)) {
                preScaleOverlay |= NV_PRESCALE_OVERLAY_X;
                srcPreShrinkDeltaX =
                    (pDriverData->dwOverlaySrcWidth << 20) / pDriverData->dwOverlayDstWidth;
            }

            if ((((pDriverData->dwOverlaySrcHeight + 7) >> 3) >
                   pDriverData->dwOverlayDstHeight) && (pDriverData->dwOverlayDstHeight > 0)) {
                preScaleOverlay |= NV_PRESCALE_OVERLAY_Y;
                srcPreShrinkDeltaY =
                    (pDriverData->dwOverlaySrcHeight << 20) / pDriverData->dwOverlayDstHeight;
                dwOverlayDeltaY = pDriverData->dwOverlayDeltaY;
            }
        } else {

            if ((pDriverData->dwOverlaySrcWidth >
                   pDriverData->dwOverlayDstWidth) && (pDriverData->dwOverlayDstWidth > 0)) {
                preScaleOverlay |= NV_PRESCALE_OVERLAY_X;
                srcPreShrinkDeltaX =
                    (pDriverData->dwOverlaySrcWidth << 20) / pDriverData->dwOverlayDstWidth;
            }

            if ((pDriverData->dwOverlaySrcHeight >
                   pDriverData->dwOverlayDstHeight) && (pDriverData->dwOverlayDstHeight > 0)) {
                preScaleOverlay |= NV_PRESCALE_OVERLAY_Y;
                srcPreShrinkDeltaY =
                    (pDriverData->dwOverlaySrcHeight << 20) / pDriverData->dwOverlayDstHeight;
                dwOverlayDeltaY = pDriverData->dwOverlayDeltaY;
            }
        }

#ifndef NOPRESTRETCH
        if (dwFieldFlags & (DDFLIP_ODD | DDFLIP_EVEN)) {
            preScaleOverlay |= NV_PRESCALE_OVERLAY_FIELD;
            srcPreShrinkDeltaY >>= 1;
        }
#endif  // NOPRESTRETCH

        /* Alternate buffer indexes to keep the hardware happy */
        pDriverData->OverlayBufferIndex ^= 1;

        index = pDriverData->OverlayBufferIndex;

        /* Preshrink overlay surface if necessary */
        if ((pDriverData->TotalVRAM >> 20 > 4) && (preScaleOverlay) &&
            (!(pfd->lpSurfTarg->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT))) {

            while (videoFreeCount < 76)
                videoFreeCount = NvGetFreeCount(npDevVideo, NV_DD_SPARE);
            videoFreeCount -= 76;

            /* Trash spare subchannel */
            npDevVideo->dDrawSpare.SetObject = NV_DD_DVD_SUBPICTURE;

            npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutPoint = 0;

            /* Widths below are increased by 2 instead of 1 to remain hardware compatible */
            if (preScaleOverlay == NV_PRESCALE_OVERLAY_X) {
                npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutSize =
                    asmMergeCoords(((pDriverData->dwOverlayDstWidth + 2) & ~1),
                                   pSurfTarg_gbl->wHeight);
            } else if (preScaleOverlay == NV_PRESCALE_OVERLAY_Y) {
                if (dwFieldFlags & (DDFLIP_ODD | DDFLIP_EVEN)) {
                    npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutSize =
                        asmMergeCoords(((pSurfTarg_gbl->wWidth + 2) & ~1),
                                       (pDriverData->dwOverlayDstHeight >> 1));
                } else {
                    npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutSize =
                        asmMergeCoords(((pSurfTarg_gbl->wWidth + 2) & ~1),
                                       pDriverData->dwOverlayDstHeight);
                }
            } else if (preScaleOverlay == (NV_PRESCALE_OVERLAY_X + NV_PRESCALE_OVERLAY_Y)) {
                if (dwFieldFlags & (DDFLIP_ODD | DDFLIP_EVEN)) {
                    npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutSize =
                        asmMergeCoords(((pDriverData->dwOverlayDstWidth + 2) & ~1),
                                       (pDriverData->dwOverlayDstHeight >> 1));
                } else {
                    npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutSize =
                        asmMergeCoords(((pDriverData->dwOverlayDstWidth + 2) & ~1),
                                       pDriverData->dwOverlayDstHeight);
                }
            } else if (preScaleOverlay == NV_PRESCALE_OVERLAY_FIELD) {
                npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutSize =
                    asmMergeCoords(((pDriverData->dwOverlaySrcWidth + 2) & ~1),
                                   pDriverData->dwOverlaySrcHeight);
            } else if (preScaleOverlay == (NV_PRESCALE_OVERLAY_X + NV_PRESCALE_OVERLAY_FIELD)) {
                npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutSize =
                    asmMergeCoords(((pDriverData->dwOverlayDstWidth + 2) & ~1),
                                   pDriverData->dwOverlaySrcHeight);
            } else if (preScaleOverlay == (NV_PRESCALE_OVERLAY_Y + NV_PRESCALE_OVERLAY_FIELD)) {
                npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutSize =
                    asmMergeCoords(((pSurfTarg_gbl->wWidth + 2) & ~1),
                                   pDriverData->dwOverlayDstHeight);
            } else { // NV_PRESCALE_OVERLAY_X + NV_PRESCALE_OVERLAY_Y + NV_PRESCALE_OVERLAY_FIELD
                npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutSize =
                    asmMergeCoords(((pDriverData->dwOverlayDstWidth + 2) & ~1),
                                   pDriverData->dwOverlayDstHeight);
            }

            if (preScaleOverlay & NV_PRESCALE_OVERLAY_FIELD) {
                if (pSurfTarg_gbl->ddpfSurface.dwFourCC == FOURCC_UYVY)
                    npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutFormat =
                        (NV038_IMAGE_OUT_FORMAT_COLOR_LE_YB8V8YA8U8 << 16) | (dwPitch >> 1);
                else
                    npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutFormat =
                        (NV038_IMAGE_OUT_FORMAT_COLOR_LE_V8YB8U8YA8 << 16) | (dwPitch >> 1);


            } else {
                if (pSurfTarg_gbl->ddpfSurface.dwFourCC == FOURCC_UYVY)
                    npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutFormat =
                        (NV038_IMAGE_OUT_FORMAT_COLOR_LE_YB8V8YA8U8 << 16) | dwPitch;
                else
                    npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutFormat =
                        (NV038_IMAGE_OUT_FORMAT_COLOR_LE_V8YB8U8YA8 << 16) | dwPitch;
            }

            /* Output to extra overlay surface memory area */
            if ((surfaceIs422) && (pDriverData->extra422OverlayOffset[index] != 0)) {
                npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutOffset =
                    pDriverData->extra422OverlayOffset[index];
            } else {
                if (dwFieldFlags & DDFLIP_ODD)
                    npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutOffset =
                        (dwOffset + (dwPitch >> 1) + pSurfTarg_gbl->dwReserved1);
                else
                    npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutOffset =
                        (dwOffset + pSurfTarg_gbl->dwReserved1);
            }

            npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageInDeltaDuDx = srcPreShrinkDeltaX;
            npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageInDeltaDvDy = srcPreShrinkDeltaY;

            npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageInSize =
                asmMergeCoords(((pDriverData->dwOverlaySrcWidth + 1) & ~1), dwHeight);

            if (pSurfTarg_gbl->ddpfSurface.dwFourCC == FOURCC_UYVY)
                npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageInFormat =
                    (NV038_IMAGE_IN_FORMAT_COLOR_LE_YB8V8YA8U8 << 16) | dwPitch;
            else
                npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageInFormat =
                    (NV038_IMAGE_IN_FORMAT_COLOR_LE_V8YB8U8YA8 << 16) | dwPitch;

            /* Temporarily offset to the beginning of the visible portion of source surface */
            dwOffset += (pDriverData->OverlaySrcY * dwPitch);
            dwOffset += ((pDriverData->OverlaySrcX & ~1) << 1);

            if (dwFieldFlags & DDFLIP_ODD)
                npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageInOffset =
                    (dwOffset + (dwPitch >> 1));
            else
                npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageInOffset =
                    dwOffset;

            npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageInPoint = 0;

            npDevVideo->dDrawSpare.nv4DvdSubpicture.OverlayDeltaDuDx = srcPreShrinkDeltaX;
            npDevVideo->dDrawSpare.nv4DvdSubpicture.OverlayDeltaDvDy = srcPreShrinkDeltaY;

            npDevVideo->dDrawSpare.nv4DvdSubpicture.OverlaySize =
                asmMergeCoords(((pDriverData->dwOverlaySrcWidth + 1) & ~1), dwHeight);

            npDevVideo->dDrawSpare.nv4DvdSubpicture.OverlayFormat =
                (NV038_OVERLAY_FORMAT_COLOR_LE_TRANSPARENT << 16) | dwPitch;

            if (dwFieldFlags & DDFLIP_ODD)
                npDevVideo->dDrawSpare.nv4DvdSubpicture.OverlayOffset =
                    (dwOffset + (dwPitch >> 1));
            else
                npDevVideo->dDrawSpare.nv4DvdSubpicture.OverlayOffset =
                    dwOffset;

            /* Restore offset */
            dwOffset -= (pDriverData->OverlaySrcY * dwPitch);
            dwOffset -= ((pDriverData->OverlaySrcX & ~1) << 1);

            npDevVideo->dDrawSpare.nv4DvdSubpicture.OverlayPoint = 0;

            pDriverData->dDrawSpareSubchannelObject = 0;

            /* Change offset to point to shrunken overlay surface memory */
            if ((surfaceIs422) && (pDriverData->extra422OverlayOffset[index] != 0))
                dwOffset = pDriverData->extra422OverlayOffset[index];
            else
                dwOffset += pSurfTarg_gbl->dwReserved1;

            /* Restore overlay source pitch and height to normal since we prescaled it */
            if (preScaleOverlay & NV_PRESCALE_OVERLAY_FIELD) {
                dwPitch >>= 1;
                dwHeight <<= 1;
            }

            /* Force fifo to stall until shrink operation finishes */
            npDevVideo->dDrawSpare.nv4DvdSubpicture.Notify = 0;
            npDevVideo->dDrawSpare.nv4DvdSubpicture.NoOperation = 0;
        } else {
            /* Offset to visible portion of source surface */
            if (pDriverData->NvDeviceVersion < NV_DEVICE_VERSION_10) {
                dwOffset += (pDriverData->OverlaySrcY * dwPitch);
                dwOffset += ((pDriverData->OverlaySrcX & ~1) << 1);
            }
        }

        /* This actually refers to the video channel in this case */
        pDriverData->dDrawSpareSubchannelObject = 0;

        /* This should never wait unless there is a hardware glitch */
        while ((volatile)pPioFlipOverlayNotifier[index + 1].status == NV_IN_PROGRESS);

        pPioFlipOverlayNotifier[index + 1].status = NV_IN_PROGRESS;

        if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
            DWORD dwPointIn;
            DWORD dwOverlayFormat;

            while (videoFreeCount < 40) {
                videoFreeCount = NvGetFreeCount(npDevVideo, NV_DD_SPARE);
                if (videoFreeCount < 40)
                    NV_SLEEP;
            }

            /* Trash spare subchannel */
            npDevVideo->subchannel[NV_DD_SPARE].SetObject = NV_VIDEO_OVERLAY;

            npDevVideo->dDrawSpare.Nv10VideoOverlay.SetOverlay[index].colorKey =
                pDriverData->OverlayColorKey;

            if ((!(surfaceIs422)) && (dwFieldFlags & DDFLIP_ODD))
                dwOffset += dwPitch >> 1;

            /* Remember this in case we get a SetOverlayPosition call */
            pDriverData->OverlaySrcOffset = dwOffset;

            npDevVideo->dDrawSpare.Nv10VideoOverlay.SetOverlay[index].offset =
                dwOffset;

            npDevVideo->dDrawSpare.Nv10VideoOverlay.SetOverlay[index].sizeIn =
                (pDriverData->OverlaySrcSize & ~0x00010001);

            if (preScaleOverlay == 0) {
                dwPointIn = asmMergeCoords((pDriverData->OverlaySrcX << 4), (pDriverData->OverlaySrcY << 4));
            } else
                dwPointIn = 0;

            /* Offset source starting Y by -0.5 when bobing */
            if (doBob)
                dwPointIn += 0xFFF80000;

            npDevVideo->dDrawSpare.Nv10VideoOverlay.SetOverlay[index].pointIn = dwPointIn;

            if ( !(pfd->lpSurfTarg->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT) ) {
                npDevVideo->dDrawSpare.Nv10VideoOverlay.SetOverlay[index].duDx =
                    pDriverData->dwOverlayDeltaX;
                npDevVideo->dDrawSpare.Nv10VideoOverlay.SetOverlay[index].dvDy =
                    dwOverlayDeltaY;
            }

            npDevVideo->dDrawSpare.Nv10VideoOverlay.SetOverlay[index].pointOut =
                asmMergeCoords(pDriverData->OverlayDstX, pDriverData->OverlayDstY);

            if (preScaleOverlay) {
                npDevVideo->dDrawSpare.Nv10VideoOverlay.SetOverlay[index].sizeOut =
                    asmMergeCoords(pDriverData->dwOverlayDstWidth, pDriverData->dwOverlayDstHeight);
            } else {
                npDevVideo->dDrawSpare.Nv10VideoOverlay.SetOverlay[index].sizeOut =
                    asmMergeCoords(pSurfTarg_gbl->wWidth, dwHeight);
            }

            dwOverlayFormat = pDriverData->OverlayFormat;

            /* replace old surface pitch value with current pitch value */
            dwOverlayFormat &= 0xFFFF0000;

            dwOverlayFormat |= dwPitch;

            npDevVideo->dDrawSpare.Nv10VideoOverlay.SetOverlay[index].format = dwOverlayFormat;

        } else { // pre NV10

            while (videoFreeCount < 32) {
                videoFreeCount = NvGetFreeCount(npDevVideo, NV_DD_SPARE);
                if (videoFreeCount < 32)
                    NV_SLEEP;
            }

            /* Trash spare subchannel */
            npDevVideo->subchannel[NV_DD_SPARE].SetObject = NV_DD_VIDEO_SCALER;

            if ( !(pfd->lpSurfTarg->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT) )
                    npDevVideo->subchannel[NV_DD_SPARE].videoScaler.SetDeltaDvDy = dwOverlayDeltaY;

            /* Temporarily load VIDEO_FROM_MEMORY object */
            npDevVideo->subchannel[NV_DD_SPARE].SetObject =
                NV_DD_YUV422_VIDEO_FROM_MEMORY;

            if ((!(surfaceIs422)) && (dwFieldFlags & DDFLIP_ODD))
                dwOffset += dwPitch >> 1;

            /* Remember this in case we get a SetOverlayPosition call */
            pDriverData->OverlaySrcOffset = dwOffset;

            npDevVideo->subchannel[NV_DD_SPARE].videoFromMemory.ImageScan[index].offset =
                dwOffset;

            npDevVideo->subchannel[NV_DD_SPARE].videoFromMemory.ImageScan[index].pitch =
                (dwPitch | doBob);

                if (preScaleOverlay) {
                npDevVideo->subchannel[NV_DD_SPARE].videoFromMemory.ImageScan[index].size =
                    asmMergeCoords(pDriverData->dwOverlayDstWidth,
                                   pDriverData->dwOverlayDstHeight);
                } else {
                npDevVideo->subchannel[NV_DD_SPARE].videoFromMemory.ImageScan[index].size =
                    asmMergeCoords(pSurfTarg_gbl->wWidth, dwHeight);
                }

            if (pSurfTarg_gbl->ddpfSurface.dwFourCC == FOURCC_UYVY)
                npDevVideo->subchannel[NV_DD_SPARE].videoFromMemory.ImageScan[index].format =
                    NV_VFM_FORMAT_COLOR_LE_Y8V8Y8U8;
            else
                npDevVideo->subchannel[NV_DD_SPARE].videoFromMemory.ImageScan[index].format =
                    NV_VFM_FORMAT_COLOR_LE_V8Y8U8Y8;

            npDevVideo->subchannel[NV_DD_SPARE].videoFromMemory.ImageScan[index].notify =
                0;
        }

        pDriverData->NvVideoFreeCount = (short)NvGetFreeCount(npDevVideo, NV_DD_SPARE);

    } else { /* Video port flips handled by FlipVideoPort32 */
        pfd->ddRVal = DDERR_INVALIDSURFACETYPE;
        return DDHAL_DRIVER_HANDLED;
    }

    /*
     * D3D will not wait for flip to complete - so much for ddraw semantics
     */
    if (!bIsD3D && !(pfd->lpSurfTarg->ddsCaps.dwCaps & DDSCAPS_OVERLAY)) {
        if (pfd->dwFlags & DDFLIP_WAIT) {
            ddrval = updateFlipStatus(0);

            while (ddrval != DD_OK) {
                NV_SLEEPFLIP;
                ddrval = updateFlipStatus(0);
            }
        }
    }

    pfd->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;

} /* Flip32 */



/*
 * Lock32
 */
DWORD __stdcall Lock32( LPDDHAL_LOCKDATA lpLockData )
{
    HRESULT                                     ddrval;
    FAST Nv10ControlDma         *npDev;
    NvNotification                              *pDmaFlipPrimaryNotifier;
    NvNotification                              *pPioFlipOverlayNotifier;
    NvNotification                              *pDmaSyncNotifier;
    NvNotification                              *pDmaDmaFromMemNotifier;
    DWORD                                       dwOffset;
        DWORD                                           caps;
    LPDDRAWI_DDRAWSURFACE_GBL   psurf_gbl;
    unsigned long               *dmaPusherPutAddress;
    unsigned long               *dmaPusherBufferBase;
    long                        freeCount;

    NvSetDriverDataPtr(lpLockData->lpDD);
    npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;

    /*
     * NOTES:
     *
     * This callback is invoked whenever a surface is about to be directly
     * accessed by the user.   This is where you need to make sure that
     * a surface can be safely accessed by the user.
     *
     * If your memory cannot be accessed while in accelerator mode, you
     * should either take the card out of accelerator mode or else
     * return DDERR_SURFACEBUSY
     *
     * If someone is accessing a surface that was just flipped away from,
     * make sure that the old surface (what was the primary) has finished
     * being displayed.
     */

    caps = lpLockData->lpDDSurface->ddsCaps.dwCaps;

    /*
     * Reset NV and get the monitor frequency after a mode reset
     */
    if( pDriverData->fReset ) {
        NV_DD_DMA_PUSHER_SYNC();
        getDisplayDuration();
        if (!ResetNV()) {
            lpLockData->ddRVal = DDERR_GENERIC;
            return(DDHAL_DRIVER_HANDLED);
        }
        pDriverData->fReset = FALSE;
    }

    pDmaFlipPrimaryNotifier = (NvNotification *)pDriverData->NvDmaFlipPrimaryNotifierFlat;
    pPioFlipOverlayNotifier = (NvNotification *)pDriverData->NvPioFlipOverlayNotifierFlat;
    pDmaSyncNotifier = (NvNotification *)pDriverData->NvDmaSyncNotifierFlat;
    pDmaDmaFromMemNotifier = (NvNotification *)pDriverData->NvDmaDmaFromMemNotifierFlat;
    dmaPusherPutAddress = (unsigned long *)pDriverData->NvDmaPusherPutAddress;
    dmaPusherBufferBase = (unsigned long *)pDriverData->NvDmaPusherBufferBase;

    if ((npDev == NULL) && (caps & DDSCAPS_VIDEOMEMORY)) {  /* Mode switches might occur without warning */
        lpLockData->ddRVal = DDERR_SURFACELOST;
        return DDHAL_DRIVER_HANDLED;
    }

    psurf_gbl = lpLockData->lpDDSurface->lpGbl;

    /*
     * check to see if any pending physical flip has occurred
     */


    if ((caps & DDSCAPS_OVERLAY) == 0) { /* Only wait for RGB surfaces */
        ddrval = updateFlipStatus(psurf_gbl->fpVidMem);
        if( ddrval != DD_OK ) {
            if (lpLockData->dwFlags & DDLOCK_WAIT) {
                while (ddrval != DD_OK) {
                    long countDown = 1000;  // sometimes we can loose a Flip notification
                    // do not sleep on non-overlay locks cuz OpenGL does alot of locks
                    // NV_SLEEPFLIP;
                    ddrval = updateFlipStatus(psurf_gbl->fpVidMem);
                    if (--countDown <= 0) {
                        pDmaFlipPrimaryNotifier[1].status = 0;
                        pDmaFlipPrimaryNotifier[2].status = 0;
                    }
                }
            } else {
                lpLockData->ddRVal = DDERR_WASSTILLDRAWING;
                return DDHAL_DRIVER_HANDLED;
            }
        }
    }

    /*
     * don't allow a lock if a blt is in progress (only do this if your
     * hardware requires it)
     */

//    if(DRAW_ENGINE_BUSY)
//    {
//        lpLockData->ddRVal = DDERR_WASSTILLDRAWING;
//        return DDHAL_DRIVER_HANDLED;
//    }

    if ((pDmaDmaFromMemNotifier->status == NV_IN_PROGRESS) &&
        (pDriverData->NvDmaFromMemSurfaceMem == psurf_gbl->fpVidMem)) {
        lpLockData->ddRVal = DDERR_WASSTILLDRAWING;
        return DDHAL_DRIVER_HANDLED;
    }

    if ((caps & DDSCAPS_VIDEOMEMORY) && ((caps & DDSCAPS_TEXTURE) == 0)) {

        // No need to lock textures even though they may currently be in use because
        //     their surface memory is not used directly when rendering
        // Every other surface type with DDSCAPS_VIDMEMORY set does need locked however


        if ((lpLockData->dwFlags & DDLOCK_WAIT) || // workaround for Telurian Defence bug
            ((lpLockData->dwFlags & DDLOCK_READONLY) == 0)) {

            NV_DD_DMA_PUSHER_SYNC();

            // Give the application a chance to do something else if push buffer isn't empty yet
            if (npDev->Get != (unsigned long)(dmaPusherPutAddress - dmaPusherBufferBase) << 2) {
                /* Force write combine buffer to flush */
                pDriverData->NvDmaPusherBufferEnd[0] = 0;
                /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                _outp (0x3d0,0);
                npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;
                lpLockData->ddRVal = DDERR_WASSTILLDRAWING;
                return DDHAL_DRIVER_HANDLED;
            }

            freeCount = 0; /* Force a hardware read */

            /* Let D3D code know that we have touched NV */
            pDriverData->TwoDRenderingOccurred = 1;

            // MUST wait for any pending notification to prevent possible loss of notification serialization
            while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS);

            while (freeCount < 4)
                NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
            freeCount -= 4;

            pDmaSyncNotifier->status = NV_IN_PROGRESS;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                RECT_AND_TEXT_NOTIFY_OFFSET | 0x40000;
            dmaPusherPutAddress[1] = 0;
            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                RECT_AND_TEXT_NO_OPERATION_OFFSET | 0x40000;
            dmaPusherPutAddress[3] = 0;

            dmaPusherPutAddress += 4;

            pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

            /* Force write combine buffer to flush */
            pDriverData->NvDmaPusherBufferEnd[0] = 0;
            /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
            _outp (0x3d0,0);

            pDriverData->dwDmaPusherFreeCount = freeCount;

            npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

            while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS);

            if (caps & DDSCAPS_VISIBLE) {
                pDriverData->fVidMemLocked = TRUE;
            }
        }
    }

    /*
     * Signal that the texture surface has been locked.  This means that the
     * texture has possibly been modified which means it needs to be retranslated.
     * This needs to be done no matter where the texture was allocated.
     */
    if (caps & DDSCAPS_TEXTURE) {
        PNVD3DTEXTURE   pTexture;
#ifdef NV_TEX2
        /*
         * user wants to lock a texture - process elsewhere
         */
        if (pTexture = (PNVD3DTEXTURE)lpLockData->lpDDSurface->dwReserved1)
        {
#ifdef WINNT
            DWORD retval;
            pTexture->lpLcl = lpLockData->lpDDSurface;
            retval = nvTextureLock(pTexture,lpLockData);
            pTexture->lpLcl = NULL;
            return(retval);
#else
            return(nvTextureLock(pTexture,lpLockData));
#endif // #ifndef WINNT
        }
#else // NV_TEX2
       if (pTexture = (PNVD3DTEXTURE)lpLockData->lpDDSurface->dwReserved1)
        {
            /*
             * When the application is locking and touching the texture directly, it's
             * neccessary to allocate a seperate block of system memory for it to use
             * since the texture memory used by the hardware stores the texture in a
             * different format than what the application understands.
             */
#ifdef WINNT
            pTexture->lpLcl = lpLockData->lpDDSurface;
            nvAllocateUserTexture(pTexture);
            pTexture->dwTextureFlags |= (NV3_TEXTURE_MODIFIED | NV3_TEXTURE_IS_LOCKED);
            lpLockData->lpSurfData = pTexture->lpLcl->lpGbl->fpVidMem;
            pTexture->lpLcl = NULL;
            lpLockData->ddRVal = DD_OK;
            return(DDHAL_DRIVER_HANDLED);
#else
            nvAllocateUserTexture(pTexture);
#endif // #ifdef WINNT
        }
#endif // NV_TEX2
    }

    /* Currently works only for pDriverData->bi.biBitCount pixel depth surfaces */
    if (lpLockData->bHasRect) {
        dwOffset = lpLockData->rArea.top * psurf_gbl->lPitch;
        dwOffset += (lpLockData->rArea.left * (pDriverData->bi.biBitCount >> 3));
        lpLockData->lpSurfData = (VOID *)((DWORD)psurf_gbl->fpVidMem + dwOffset);
    }

    return DDHAL_DRIVER_NOTHANDLED;

} /* Lock32 */


/*
 * Unlock32
 */
DWORD __stdcall Unlock32( LPDDHAL_UNLOCKDATA lpUnlockData )
{
    Nv10ControlDma              *npDev;
    LPDDRAWI_DDRAWSURFACE_GBL   pSurf_gbl;
    DWORD                       caps;

    NvSetDriverDataPtr(lpUnlockData->lpDD);

    npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;

    caps = lpUnlockData->lpDDSurface->ddsCaps.dwCaps;

    if ((npDev == NULL) && (caps & DDSCAPS_VIDEOMEMORY)) {  /* Mode switches might occur without warning */
        lpUnlockData->ddRVal = DDERR_SURFACELOST;
        return DDHAL_DRIVER_HANDLED;
    }

    pSurf_gbl = lpUnlockData->lpDDSurface->lpGbl;

    if ((caps & DDSCAPS_OVERLAY) && ((caps & DDSCAPS_VISIBLE) ||
        (pDriverData->dwOverlaySurfaces < 3))) {
        ConvertOverlay32(lpUnlockData->lpDDSurface, FALSE);
        if ((caps & DDSCAPS_VISIBLE) && ((caps & DDSCAPS_VIDEOPORT) == 0)) {
            if ((pDriverData->dwOverlaySurfaces == 1) && (pSurf_gbl->wHeight >= 480)) { // Quadrant MCI DVD decoder fix
                if (pDriverData->lockCount > 2)
                    PreScaleOverlay32(lpUnlockData->lpDDSurface);
            } else if (((pDriverData->dwOverlaySrcWidth > pDriverData->dwOverlayDstWidth) ||
                (pDriverData->dwOverlaySrcHeight > pDriverData->dwOverlayDstHeight))) {
                PreScaleOverlay32(lpUnlockData->lpDDSurface);
            }
        }
        pDriverData->lockCount++;
    }

    /*
     * Signal that the texture surface has been unlocked.  This means that the
     * texture has possibly been modified which means it needs to be retranslated.
     * This needs to be done no matter where the texture was allocated.
     */
    if (caps & DDSCAPS_TEXTURE) {
        PNVD3DTEXTURE   pTexture;
#ifdef NV_TEX2
        /*
         * user wants to unlock a texture - process elsewhere
         */
        if (pTexture = (PNVD3DTEXTURE)lpUnlockData->lpDDSurface->dwReserved1)
        {
#ifdef WINNT
            DWORD retval;
            pTexture->lpLcl = lpUnlockData->lpDDSurface;
            pDriverData->fVidMemLocked = FALSE;
            retval = nvTextureUnlock(pTexture,lpUnlockData);
            pTexture->lpLcl = NULL;
            return(retval);
#else
            pDriverData->fVidMemLocked = FALSE;
            return(nvTextureUnlock(pTexture,lpUnlockData));
#endif // #ifndef WINNT
        }
#else // NV_TEX2
        pTexture = (PNVD3DTEXTURE)lpUnlockData->lpDDSurface->dwReserved1;
        if (pTexture) {
            pTexture->dwTextureFlags |= NV3_TEXTURE_MODIFIED;
            pTexture->dwTextureFlags &= ~NV3_TEXTURE_IS_LOCKED;

            /*
             * Swizzle the texture now.
             */
#ifdef WINNT
            pTexture->lpLcl = lpUnlockData->lpDDSurface;
            nvLoadTexture(pTexture);
            pTexture->lpLcl = NULL;
#else
            nvLoadTexture(pTexture);
#endif // #ifndef WINNT

        }
#endif // NV_TEX2
    }

    pDriverData->fVidMemLocked = FALSE;

    lpUnlockData->ddRVal = DD_OK;

    return DDHAL_DRIVER_HANDLED;

} /* Unlock32 */




/*
 * WaitForVerticalBlank32
 */
DWORD __stdcall WaitForVerticalBlank32(
        LPDDHAL_WAITFORVERTICALBLANKDATA lpWaitForVerticalBlank )
{
    NvSetDriverDataPtr(lpWaitForVerticalBlank->lpDD);

    switch( lpWaitForVerticalBlank->dwFlags ) {

    case DDWAITVB_I_TESTVB:
        /*
         * if testvb is just a request for the current vertical blank status
         */
        lpWaitForVerticalBlank->ddRVal = DD_OK;
#ifndef WINNT
        if (NvConfigGet(NV_CFG_VBLANK_STATUS, pDriverData->dwDeviceIDNum))
#else
        if (pDriverData->ppdev->pfnVBlankIsActive(pDriverData->ppdev))
#endif // #ifdef WINNT
           lpWaitForVerticalBlank->bIsInVB = TRUE;
        else
           lpWaitForVerticalBlank->bIsInVB = FALSE;

        return DDHAL_DRIVER_HANDLED;

    case DDWAITVB_BLOCKBEGIN:
        /*
         * if blockbegin is requested we wait until the vertical blank
         * is over, and then wait for the display period to end.
         */
#ifndef WINNT
        while(NvConfigGet(NV_CFG_VBLANK_STATUS, pDriverData->dwDeviceIDNum) != 0);
        while(NvConfigGet(NV_CFG_VBLANK_STATUS, pDriverData->dwDeviceIDNum) == 0);
#else
        pDriverData->ppdev->pfnWaitWhileVBlankActive(pDriverData->ppdev);
        pDriverData->ppdev->pfnWaitWhileDisplayActive(pDriverData->ppdev);
#endif // #ifdef WINNT
        lpWaitForVerticalBlank->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;

    case DDWAITVB_BLOCKEND:
        /*
         * if blockend is requested we wait for the vblank interval to end.
         */
#ifndef WINNT
        if (NvConfigGet(NV_CFG_VBLANK_STATUS, pDriverData->dwDeviceIDNum)) {
            while(NvConfigGet(NV_CFG_VBLANK_STATUS, pDriverData->dwDeviceIDNum) != 0);
        } else {
            while(NvConfigGet(NV_CFG_VBLANK_STATUS, pDriverData->dwDeviceIDNum) == 0);
            while(NvConfigGet(NV_CFG_VBLANK_STATUS, pDriverData->dwDeviceIDNum) != 0);
        }
#else
        if (pDriverData->ppdev->pfnVBlankIsActive(pDriverData->ppdev)) {
            pDriverData->ppdev->pfnWaitWhileVBlankActive(pDriverData->ppdev);
        } else {
            pDriverData->ppdev->pfnWaitWhileDisplayActive(pDriverData->ppdev);
            pDriverData->ppdev->pfnWaitWhileVBlankActive(pDriverData->ppdev);
        }
#endif // #ifdef WINNT
        lpWaitForVerticalBlank->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;
    }

    return DDHAL_DRIVER_NOTHANDLED;

} /* WaitForVerticalBlank32 */



/*
 * GetScanLine32
 */
DWORD __stdcall GetScanLine32( LPDDHAL_GETSCANLINEDATA lpGetScanLine )
{
    NvSetDriverDataPtr(lpGetScanLine->lpDD);

    /*
     * If a vertical blank is in progress the scan line is in
     * indeterminant. If the scan line is indeterminant we return
     * the error code DDERR_VERTICALBLANKINPROGRESS.
     * Otherwise we return the scan line and a success code
     */
#ifndef WINNT
    lpGetScanLine->dwScanLine = NvConfigGet(NV_CFG_CURRENT_SCANLINE, pDriverData->dwDeviceIDNum);
#else
    lpGetScanLine->dwScanLine = pDriverData->ppdev->pfnGetScanline(pDriverData->ppdev);
#endif // #ifdef WINNT

    if (lpGetScanLine->dwScanLine >= (DWORD)pDriverData->bi.biHeight)
        lpGetScanLine->ddRVal = DDERR_VERTICALBLANKINPROGRESS;
    else
        lpGetScanLine->ddRVal = DD_OK;

    return DDHAL_DRIVER_HANDLED;

} /* GetScanLine32 */



/*
 * SetSurfaceColorKey32
 */
DWORD __stdcall SetSurfaceColorKey32(LPDDHAL_SETCOLORKEYDATA lpSetColorKey)
{
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;
    LPDDRAWI_DDRAWSURFACE_LCL   psurf;

    NvSetDriverDataPtr(lpSetColorKey->lpDD);

    pdrv = lpSetColorKey->lpDD;
    psurf = lpSetColorKey->lpDDSurface;

    DPF( "in SetSurfaceColorKey, lpSetColorKey->lpDD=%08lx, lpSetColorKey->lpDDSurface = %08lx",
                pdrv, lpSetColorKey->lpDDSurface );

    if (lpSetColorKey->dwFlags == DDCKEY_SRCBLT) {
        psurf->ddckCKSrcBlt.dwColorSpaceLowValue =
            lpSetColorKey->ckNew.dwColorSpaceLowValue & pDriverData->physicalColorMask;
        /* Use no mask on this one on NV3 so that our D3D driver can get all the bits when surface is 565 */
        psurf->ddckCKSrcBlt.dwColorSpaceHighValue =
            lpSetColorKey->ckNew.dwColorSpaceHighValue;
    } else if (lpSetColorKey->dwFlags == DDCKEY_DESTOVERLAY) {
        psurf->ddckCKDestOverlay.dwColorSpaceLowValue =
            lpSetColorKey->ckNew.dwColorSpaceLowValue & pDriverData->physicalColorMask;
        psurf->ddckCKDestOverlay.dwColorSpaceHighValue =
            lpSetColorKey->ckNew.dwColorSpaceHighValue & pDriverData->physicalColorMask;
    } else {
        lpSetColorKey->ddRVal = DDERR_UNSUPPORTED;
        return DDHAL_DRIVER_HANDLED;
    }


    lpSetColorKey->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
}


/*
 * DestroySurface32
 */
DWORD __stdcall DestroySurface32( LPDDHAL_DESTROYSURFACEDATA lpDestroySurface )
{
    FAST Nv10ControlDma          *npDev;
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;
    LPDDRAWI_DDRAWSURFACE_LCL   psurf;
    LPDDRAWI_DDRAWSURFACE_GBL   psurf_gbl;
    HGLOBAL                     hMem;
    DWORD                       index = 0;

    NvSetDriverDataPtr(lpDestroySurface->lpDD);

    npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;

    pdrv = lpDestroySurface->lpDD;
    DPF( "in DestroySurface, lpDestroySurface->lpDD=%08lx, lpDestroySurface->lpDDSurface = %08lx",
                pdrv, lpDestroySurface->lpDDSurface );

    psurf = lpDestroySurface->lpDDSurface;
    psurf_gbl = psurf->lpGbl;

    if (psurf_gbl->fpVidMem == pDriverData->BaseAddress) {
        lpDestroySurface->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;
    }

    /*
       Should check if YUV surface is an active VPE surface and make sure
       to stop VPE hardware before destroying VPE surface somewhere in YUV
       surface code in this function.
    */

    if ((psurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) &&
        (psurf->ddsCaps.dwCaps & (DDSCAPS_VISIBLE | DDSCAPS_FRONTBUFFER))) {
        FAST Nv3ChannelPio *npDevVideo = (Nv3ChannelPio *)pDriverData->NvDevVideoFlatPio;
        FAST long          videoFreeCount = pDriverData->NvVideoFreeCount;
        NvNotification     *pPioFlipOverlayNotifier =
                            (NvNotification *)pDriverData->NvPioFlipOverlayNotifierFlat;

        pDriverData->HALInfo.ddCaps.dwCurrVisibleOverlays = 0;

        NV_DD_DMA_PUSHER_SYNC();

        if (npDevVideo == NULL) {  /* Mode switches might occur without warning */
            if (!ResetNV()) {
                lpDestroySurface->ddRVal = DDERR_GENERIC;
                return DDHAL_DRIVER_HANDLED;
            }
            pDriverData->fReset = FALSE;
            npDevVideo = (Nv3ChannelPio *)pDriverData->NvDevVideoFlatPio;
            videoFreeCount = pDriverData->NvVideoFreeCount;
            npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;
            if ((npDevVideo == NULL) || (npDev == NULL))  {
                pDriverData->dwOverlaySurfaces = 0;
                pDriverData->dwOverlayOwner = 0;
                lpDestroySurface->ddRVal = DDERR_SURFACELOST;
                return DDHAL_DRIVER_HANDLED;
            }
        }

        pDriverData->dwRingZeroMutex = TRUE;

        if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {

            while (videoFreeCount < 12)
                videoFreeCount = NvGetFreeCount(npDevVideo, NV_DD_SPARE);
            videoFreeCount -= 12;

            npDevVideo->dDrawSpare.SetObject = NV_VIDEO_OVERLAY;

            npDevVideo->dDrawSpare.Nv10VideoOverlay.StopOverlay[0] =
                NV07A_STOP_OVERLAY_BETWEEN_BUFFERS;

            npDevVideo->dDrawSpare.Nv10VideoOverlay.StopOverlay[1] =
                NV07A_STOP_OVERLAY_BETWEEN_BUFFERS;

        } else {

            while (videoFreeCount < 20)
                videoFreeCount = NvGetFreeCount(npDevVideo, NV_DD_SPARE);
            videoFreeCount -= 20;

            /* Trash spare subchannel */
            npDevVideo->dDrawSpare.SetObject = NV_DD_VIDEO_COLOR_KEY;

            npDevVideo->dDrawSpare.videoColorKey.SetSize = 0; // hide overlay

            npDevVideo->dDrawSpare.SetObject = NV_DD_YUV422_VIDEO_FROM_MEMORY;

            npDevVideo->dDrawSpare.videoFromMemory.ImageScan[0].size = 0;

            npDevVideo->dDrawSpare.videoFromMemory.ImageScan[0].notify = 0;
        }

        pDriverData->dwRingZeroMutex = FALSE;
        pDriverData->dDrawSpareSubchannelObject = 0;

        pDriverData->NvVideoFreeCount = (short)videoFreeCount;

        /* Make sure we don't get confused later on */
        pPioFlipOverlayNotifier[1].status = 0;      /* clear notifiers */
        pPioFlipOverlayNotifier[2].status = 0;
        pDriverData->fDDrawFullScreenDosOccurred = 0;    /* reset flag */
    }

    if( (psurf->dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
         (psurf_gbl->ddpfSurface.dwFlags & DDPF_FOURCC) ) {
             DPF( "  FOURCC surface" );

        switch( psurf->lpGbl->ddpfSurface.dwFourCC ) {
            case FOURCC_RGB0:
            case FOURCC_RAW8:
               if (psurf->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) {
                   if (psurf_gbl->fpVidMem > 0) {
                       NVHEAP_FREE (psurf_gbl->fpVidMem);
                       //DDHAL32_VidMemFree(pdrv, 0, psurf_gbl->fpVidMem);
                       psurf_gbl->fpVidMem = 0;
                       if (pDriverData->DDrawVideoSurfaceCount > 0)
                           pDriverData->DDrawVideoSurfaceCount--;
                   }
               } else {
                   hMem = (HGLOBAL)psurf_gbl->dwReserved1;
                   GlobalUnlock(hMem);
                   GlobalFree(hMem);
                   psurf_gbl->dwReserved1 = 0;
               }
               lpDestroySurface->ddRVal = DD_OK;
               return DDHAL_DRIVER_HANDLED;
               break;

            case FOURCC_IF09:
            case FOURCC_YVU9:
            case FOURCC_IV32:
            case FOURCC_IV31:
            case FOURCC_YUY2:
            case FOURCC_YUNV:
            case FOURCC_UYVY:
            case FOURCC_UYNV:

               if (psurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) {
       