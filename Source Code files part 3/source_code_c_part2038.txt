as static strings, based upon values from previous properties, or set to a list of servers in the configuration at deployment time.
    ///The value set by the <property> element may be overridden as part of a publishComponent or aggregateComponent element.
    ///
    ///Properties are necessary for many Microsoft Windows Installer files, which forms the basis of their inclusion in the Octopus Deployment Framework. Developers are free to place all properties in the msi elements of components if that is simplest, but other more flexible manifests are possible. For example, a set of properties may be defined at the topology level which are then inherited by published components. Or, a component may override a static property value with a user-provided value by using passProperty when aggregating another component.
    ///The property 'value' attribute may refer to the value of another property as though it were a variable. This is done by placing the name of the referenced property between square brackets. For example, the value of property 'foo' may be set to "my name is [bar]". This will reference the value of the property named 'bar' and replace the string '[bar]' with that value. If the value of 'bar' were 'Susan', then the value of 'foo' would be "my name is Susan". 
    ///
    /// </para>
    /// <para>
    /// Regular expression: (serverList | userInput | any)?
    /// </para>
    /// </summary>
    public partial class PropertyType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static FSM validationStates;
        
         public static explicit operator PropertyType(XElement xe) { return XTypedServices.ToXTypedElement<PropertyType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static PropertyType() {
            BuildElementDictionary();
            InitFSM();
        }
        
        /// <summary>
        /// <para>
        /// A property definition.
        /// </para>
        /// <para>
        /// 
        ///The <property> element is used throughout a service manifest to obtain user input and reconcile that input with predefined values. The values of properties may be entered by users, set as static strings, based upon values from previous properties, or set to a list of servers in the configuration at deployment time.
        ///The value set by the <property> element may be overridden as part of a publishComponent or aggregateComponent element.
        ///
        ///Properties are necessary for many Microsoft Windows Installer files, which forms the basis of their inclusion in the Octopus Deployment Framework. Developers are free to place all properties in the msi elements of components if that is simplest, but other more flexible manifests are possible. For example, a set of properties may be defined at the topology level which are then inherited by published components. Or, a component may override a static property value with a user-provided value by using passProperty when aggregating another component.
        ///The property 'value' attribute may refer to the value of another property as though it were a variable. This is done by placing the name of the referenced property between square brackets. For example, the value of property 'foo' may be set to "my name is [bar]". This will reference the value of the property named 'bar' and replace the string '[bar]' with that value. If the value of 'bar' were 'Susan', then the value of 'foo' would be "my name is Susan". 
        ///
        /// </para>
        /// <para>
        /// Regular expression: (serverList | userInput | any)?
        /// </para>
        /// </summary>
        public PropertyType() {
        }
        
        public PropertyType(serverListLocalType serverList) {
            this.serverList = serverList;
        }
        
        public PropertyType(userInputLocalType userInput) {
            this.userInput = userInput;
        }
        
        /// <summary>
        /// <para>
        /// The property value is set to a list of servers meeting specified criteria.
        /// </para>
        /// <para>
        /// The <serverList> element sets the value of the parent property to a list of servers based on the roles and components assigned to servers at deployment time.The serverList element is useful to automatically determine the server name used for a particular component. For example, if a front end component needs to know the name of the database server, a property for the front end MSI file could be to a server list with type="component" and the name of the database component.
        /// </para>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Regular expression: (serverList | userInput | any)?
        /// </para>
        /// </summary>
        public serverListLocalType serverList {
            get {
                XElement x = this.GetElement(XName.Get("serverList", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                return ((serverListLocalType)(x));
            }
            set {
                this.SetElement(XName.Get("serverList", "http://schemas.microsoft.com/Octopus/2005/01/Service"), value);
            }
        }
        
        /// <summary>
        /// <para>
        /// The property value can be entered by the user at deployment time.
        /// </para>
        /// <para>
        /// The <userInput> element instructs the Octopus Console to solicit user input for the value of the parent property.
        ///The userInput element is useful at many levels in the service manifest. It can be used anywhere a property is allowed. At the upper levels of the service manifest (service or topology), userInput is used for property values that are shared by multiple components. At intermediate levels, userInput is useful for overriding properties lower down. A developer can solicit user input for a property at one level, and then use passProperty to override the default or static values of properties in an aggregated component at the next level down. At the component or MSI level, userInput allows the deployment operator to enter detailed configuration values for that individual component.
        /// </para>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Regular expression: (serverList | userInput | any)?
        /// </para>
        /// </summary>
        public userInputLocalType userInput {
            get {
                XElement x = this.GetElement(XName.Get("userInput", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                return ((userInputLocalType)(x));
            }
            set {
                this.SetElement(XName.Get("userInput", "http://schemas.microsoft.com/Octopus/2005/01/Service"), value);
            }
        }
        
        /// <summary>
        /// <para>
        /// Regular expression: (serverList | userInput | any)?
        /// </para>
        /// </summary>
        public IEnumerable<XElement> Any {
            get {
                return this.GetWildCards(WildCard.DefaultWildCard);
            }
        }
        
        /// <summary>
        /// <para>
        /// The name of this property. Property names must start and end with a letter or digit; and may include letters, digits, underscores, spaces, periods or dashes between the first and last character.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public string name {
            get {
                XAttribute x = this.Attribute(XName.Get("name", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("name", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// A static or variable-based value for this property.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public string value {
            get {
                XAttribute x = this.Attribute(XName.Get("value", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("value", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// A separator to use when merging values passed from multiple aggregating components.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public string mergeSeparator {
            get {
                XAttribute x = this.Attribute(XName.Get("mergeSeparator", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("mergeSeparator", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("PropertyType", "http://schemas.microsoft.com/Octopus/2005/01/Service");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<PropertyType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(XName.Get("serverList", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(serverListLocalType));
            localElementDictionary.Add(XName.Get("userInput", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(userInputLocalType));
        }
        
        FSM IXMetaData.GetValidationStates() {
            return validationStates;
        }
        
        private static void InitFSM() {
            Dictionary<int, Transitions> transitions = new Dictionary<int, Transitions>();
            transitions.Add(1, new Transitions(new SingleTransition(XName.Get("serverList", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 2), new SingleTransition(XName.Get("userInput", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 4), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 6)));
            validationStates = new FSM(1, new Set<int>(new int[] {
                            2,
                            4,
                            6,
                            1}), transitions);
        }
        
        public partial class serverListLocalType : XTypedElement, IXMetaData {
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private static string separatorDefaultValue = ",";
            
         public static explicit operator serverListLocalType(XElement xe) { return XTypedServices.ToXTypedElement<serverListLocalType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
            
            public serverListLocalType() {
            }
            
            /// <summary>
            /// <para>
            /// The type of server list to generate.
            /// </para>
            /// <para>
            /// The type attribute may take one of the following values:componentThe list will include all servers which include the component specified by the name attribute.publishInterfaceThe list will include all servers which include a component that publishes the interface specified by the name attribute.requireInterfaceThe list will include all servers which include a component that requires the interface specified by the name attribute.
            /// </para>
            /// <para>
            /// Occurrence: required
            /// </para>
            /// </summary>
            public string type {
                get {
                    XAttribute x = this.Attribute(XName.Get("type", ""));
                    return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
                set {
                    this.SetAttribute(XName.Get("type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
            }
            
            /// <summary>
            /// <para>
            /// The name of the component, publishInterface or requireInterface from which to construct the list of servers.
            /// </para>
            /// <para>
            /// Occurrence: required
            /// </para>
            /// </summary>
            public string name {
                get {
                    XAttribute x = this.Attribute(XName.Get("name", ""));
                    return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
                set {
                    this.SetAttribute(XName.Get("name", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
            }
            
            /// <summary>
            /// <para>
            /// The string with which to separate the server names in the list.
            /// </para>
            /// <para>
            /// Occurrence: optional
            /// </para>
            /// </summary>
            public string separator {
                get {
                    XAttribute x = this.Attribute(XName.Get("separator", ""));
                    return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, separatorDefaultValue);
                }
                set {
                    this.SetAttribute(XName.Get("separator", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            XName IXMetaData.SchemaName {
                get {
                    return XName.Get("serverList", "http://schemas.microsoft.com/Octopus/2005/01/Service");
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            SchemaOrigin IXMetaData.TypeOrigin {
                get {
                    return SchemaOrigin.Fragment;
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            ILinqToXsdTypeManager IXMetaData.TypeManager {
                get {
                    return LinqToXsdTypeManager.Instance;
                }
            }
            
            public override XTypedElement Clone() {
                return XTypedServices.CloneXTypedElement<serverListLocalType>(this);
            }
            
            ContentModelEntity IXMetaData.GetContentModel() {
                return ContentModelEntity.Default;
            }
        }
        
        /// <summary>
        /// <para>
        /// Regular expression: (checkbox | select | textbox | password)?
        /// </para>
        /// </summary>
        public partial class userInputLocalType : XTypedElement, IXMetaData {
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private static bool requiredDefaultValue = System.Xml.XmlConvert.ToBoolean("true");
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private static bool persistentDefaultValue = System.Xml.XmlConvert.ToBoolean("true");
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private static ContentModelEntity contentModel;
            
         public static explicit operator userInputLocalType(XElement xe) { return XTypedServices.ToXTypedElement<userInputLocalType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
            
            static userInputLocalType() {
                BuildElementDictionary();
                contentModel = new ChoiceContentModelEntity(new NamedContentModelEntity(XName.Get("checkbox", "http://schemas.microsoft.com/Octopus/2005/01/Service")), new NamedContentModelEntity(XName.Get("select", "http://schemas.microsoft.com/Octopus/2005/01/Service")), new NamedContentModelEntity(XName.Get("textbox", "http://schemas.microsoft.com/Octopus/2005/01/Service")), new NamedContentModelEntity(XName.Get("password", "http://schemas.microsoft.com/Octopus/2005/01/Service")));
            }
            
            /// <summary>
            /// <para>
            /// Regular expression: (checkbox | select | textbox | password)?
            /// </para>
            /// </summary>
            public userInputLocalType() {
            }
            
            public userInputLocalType(checkboxLocalType checkbox) {
                this.checkbox = checkbox;
            }
            
            public userInputLocalType(selectLocalType select) {
                this.select = select;
            }
            
            public userInputLocalType(textboxLocalType textbox) {
                this.textbox = textbox;
            }
            
            public userInputLocalType(passwordLocalType password) {
                this.password = password;
            }
            
            /// <summary>
            /// <para>
            /// The UI displays a check box.
            /// </para>
            /// <para>
            /// The <checkbox> user input element indicates that the UI should display a check box for the specified property. The property can be assigned one of two values, for example 0 or 1, true or false, etc.
            /// </para>
            /// <para>
            /// Occurrence: required, choice
            /// </para>
            /// <para>
            /// Regular expression: (checkbox | select | textbox | password)?
            /// </para>
            /// </summary>
            public checkboxLocalType checkbox {
                get {
                    XElement x = this.GetElement(XName.Get("checkbox", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                    return ((checkboxLocalType)(x));
                }
                set {
                    this.SetElement(XName.Get("checkbox", "http://schemas.microsoft.com/Octopus/2005/01/Service"), value);
                }
            }
            
            /// <summary>
            /// <para>
            /// The UI displays a predetermined list of values from which the user can select.
            /// </para>
            /// <para>
            /// The select element is a simple collection of option elements.The select element works in the same way as an HTML select tag. Once the developer has declared the select element, it must be populated by one or more option elements to be useful. The Octopus Console will depict the select element as a list box containing the values specified by the child option elements.
            ///
            /// </para>
            /// <para>
            /// Occurrence: required, choice
            /// </para>
            /// <para>
            /// Regular expression: (checkbox | select | textbox | password)?
            /// </para>
            /// </summary>
            public selectLocalType select {
                get {
                    XElement x = this.GetElement(XName.Get("select", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                    return ((selectLocalType)(x));
                }
                set {
                    this.SetElement(XName.Get("select", "http://schemas.microsoft.com/Octopus/2005/01/Service"), value);
                }
            }
            
            /// <summary>
            /// <para>
            /// The UI displays a text box into which the user can enter any value.
            /// </para>
            /// <para>
            /// The <textbox> element informs the Octopus Console that it should depict a userInput property as a text input field.The textbox element is used to solicit inputs from the user that take the form of a string. It is most useful in cases where the value entered by the user cannot be known in advance, such as details specific to a given network.
            /// </para>
            /// <para>
            /// Occurrence: required, choice
            /// </para>
            /// <para>
            /// Regular expression: (checkbox | select | textbox | password)?
            /// </para>
            /// </summary>
            public textboxLocalType textbox {
                get {
                    XElement x = this.GetElement(XName.Get("textbox", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                    return ((textboxLocalType)(x));
                }
                set {
                    this.SetElement(XName.Get("textbox", "http://schemas.microsoft.com/Octopus/2005/01/Service"), value);
                }
            }
            
            /// <summary>
            /// <para>
            /// The UI displays a text box in which the value entered is masked.
            /// </para>
            /// <para>
            /// The password element instructs the Octopus Console to represent this userInput property as a password field.When a user types text into a password element, the Octopus Console will render that text as a series of bullets. Properties defined as passwords will not be written to any log files by the Octopus Deployment Framework.MSI authors are encouraged to use the MsiHiddenProperties property within the MSI file to prevent password properties from being written to the MSI log file.
            /// </para>
            /// <para>
            /// Occurrence: required, choice
            /// </para>
            /// <para>
            /// Regular expression: (checkbox | select | textbox | password)?
            /// </para>
            /// </summary>
            public passwordLocalType password {
                get {
                    XElement x = this.GetElement(XName.Get("password", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                    return ((passwordLocalType)(x));
                }
                set {
                    this.SetElement(XName.Get("password", "http://schemas.microsoft.com/Octopus/2005/01/Service"), value);
                }
            }
            
            /// <summary>
            /// <para>
            /// A friendly string for the Octopus Console to display as the prompt for the property value.
            /// </para>
            /// <para>
            /// Occurrence: required
            /// </para>
            /// </summary>
            public string prompt {
                get {
                    XAttribute x = this.Attribute(XName.Get("prompt", ""));
                    return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
                set {
                    this.SetAttribute(XName.Get("prompt", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
            }
            
            /// <summary>
            /// <para>
            /// A friendly help text explaining the purpose of the user input in more detail.
            /// </para>
            /// <para>
            /// Occurrence: optional
            /// </para>
            /// </summary>
            public string help {
                get {
                    XAttribute x = this.Attribute(XName.Get("help", ""));
                    return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
                set {
                    this.SetAttribute(XName.Get("help", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
            }
            
            /// <summary>
            /// <para>
            /// A boolean ("true" or "false") stating whether the user must provide this input.
            /// </para>
            /// <para>
            /// Occurrence: optional
            /// </para>
            /// </summary>
            public bool required {
                get {
                    XAttribute x = this.Attribute(XName.Get("required", ""));
                    return XTypedServices.ParseValue<bool>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean).Datatype, requiredDefaultValue);
                }
                set {
                    this.SetAttribute(XName.Get("required", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean).Datatype);
                }
            }
            
            /// <summary>
            /// <para>
            /// A default value for this property that will be pre-selected by the Octopus Console.
            /// </para>
            /// <para>
            /// Occurrence: optional
            /// </para>
            /// </summary>
            public string @default {
                get {
                    XAttribute x = this.Attribute(XName.Get("default", ""));
                    return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
                set {
                    this.SetAttribute(XName.Get("default", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
            }
            
            /// <summary>
            /// <para>
            /// This property will never be persisted to the configuration file, so it will revert to its default value after each deployment session.
            /// </para>
            /// <para>
            /// Occurrence: optional
            /// </para>
            /// </summary>
            public bool persistent {
                get {
                    XAttribute x = this.Attribute(XName.Get("persistent", ""));
                    return XTypedServices.ParseValue<bool>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean).Datatype, persistentDefaultValue);
                }
                set {
                    this.SetAttribute(XName.Get("persistent", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean).Datatype);
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
                get {
                    return localElementDictionary;
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            XName IXMetaData.SchemaName {
                get {
                    return XName.Get("userInput", "http://schemas.microsoft.com/Octopus/2005/01/Service");
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            SchemaOrigin IXMetaData.TypeOrigin {
                get {
                    return SchemaOrigin.Fragment;
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            ILinqToXsdTypeManager IXMetaData.TypeManager {
                get {
                    return LinqToXsdTypeManager.Instance;
                }
            }
            
            public override XTypedElement Clone() {
                return XTypedServices.CloneXTypedElement<userInputLocalType>(this);
            }
            
            private static void BuildElementDictionary() {
                localElementDictionary.Add(XName.Get("checkbox", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(checkboxLocalType));
                localElementDictionary.Add(XName.Get("select", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(selectLocalType));
                localElementDictionary.Add(XName.Get("textbox", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(textboxLocalType));
                localElementDictionary.Add(XName.Get("password", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(passwordLocalType));
            }
            
            ContentModelEntity IXMetaData.GetContentModel() {
                return contentModel;
            }
            
            public partial class checkboxLocalType : XTypedElement, IXMetaData {
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                private static string checkedValueDefaultValue = "0";
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                private static string uncheckedValueDefaultValue = "1";
                
         public static explicit operator checkboxLocalType(XElement xe) { return XTypedServices.ToXTypedElement<checkboxLocalType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
                
                public checkboxLocalType() {
                }
                
                /// <summary>
                /// <para>
                /// The value to be passed for the property when the check box is checked.
                /// </para>
                /// <para>
                /// Occurrence: optional
                /// </para>
                /// </summary>
                public string checkedValue {
                    get {
                        XAttribute x = this.Attribute(XName.Get("checkedValue", ""));
                        return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, checkedValueDefaultValue);
                    }
                    set {
                        this.SetAttribute(XName.Get("checkedValue", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                    }
                }
                
                /// <summary>
                /// <para>
                /// The value to be passed for the property when the check box is not checked.
                /// </para>
                /// <para>
                /// Occurrence: optional
                /// </para>
                /// </summary>
                public string uncheckedValue {
                    get {
                        XAttribute x = this.Attribute(XName.Get("uncheckedValue", ""));
                        return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, uncheckedValueDefaultValue);
                    }
                    set {
                        this.SetAttribute(XName.Get("uncheckedValue", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                    }
                }
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                XName IXMetaData.SchemaName {
                    get {
                        return XName.Get("checkbox", "http://schemas.microsoft.com/Octopus/2005/01/Service");
                    }
                }
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                SchemaOrigin IXMetaData.TypeOrigin {
                    get {
                        return SchemaOrigin.Fragment;
                    }
                }
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                ILinqToXsdTypeManager IXMetaData.TypeManager {
                    get {
                        return LinqToXsdTypeManager.Instance;
                    }
                }
                
                public override XTypedElement Clone() {
                    return XTypedServices.CloneXTypedElement<checkboxLocalType>(this);
                }
                
                ContentModelEntity IXMetaData.GetContentModel() {
                    return ContentModelEntity.Default;
                }
            }
            
            /// <summary>
            /// <para>
            /// Regular expression: (option+)+
            /// </para>
            /// </summary>
            public partial class selectLocalType : XTypedElement, IXMetaData {
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                private XTypedList<optionLocalType> optionField;
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
                
         public static explicit operator selectLocalType(XElement xe) { return XTypedServices.ToXTypedElement<selectLocalType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
                
                static selectLocalType() {
                    BuildElementDictionary();
                }
                
                /// <summary>
                /// <para>
                /// Regular expression: (option+)+
                /// </para>
                /// </summary>
                public selectLocalType() {
                }
                
                /// <summary>
                /// <para>
                /// Defines a single value in the list from which the user can select.
                /// </para>
                /// <para>
                /// The <option> element defines a single value in a list of possible values from which the user can select.
                /// </para>
                /// <para>
                /// Occurrence: required, repeating, choice
                /// </para>
                /// <para>
                /// Regular expression: (option+)+
                /// </para>
                /// </summary>
                public IList<schemas.microsoft.com.Octopus.Item2005.Item01.Service.PropertyType.userInputLocalType.selectLocalType.optionLocalType> option {
                    get {
                        if ((this.optionField == null)) {
                            this.optionField = new XTypedList<optionLocalType>(this, LinqToXsdTypeManager.Instance, XName.Get("option", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                        }
                        return this.optionField;
                    }
                    set {
                        if ((value == null)) {
                            this.optionField = null;
                        }
                        else {
                            if ((this.optionField == null)) {
                                this.optionField = XTypedList<optionLocalType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("option", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                            }
                            else {
                                XTypedServices.SetList<optionLocalType>(this.optionField, value);
                            }
                        }
                    }
                }
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
                    get {
                        return localElementDictionary;
                    }
                }
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                XName IXMetaData.SchemaName {
                    get {
                        return XName.Get("select", "http://schemas.microsoft.com/Octopus/2005/01/Service");
                    }
                }
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                SchemaOrigin IXMetaData.TypeOrigin {
                    get {
                        return SchemaOrigin.Fragment;
                    }
                }
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                ILinqToXsdTypeManager IXMetaData.TypeManager {
                    get {
                        return LinqToXsdTypeManager.Instance;
                    }
                }
                
                public override XTypedElement Clone() {
                    return XTypedServices.CloneXTypedElement<selectLocalType>(this);
                }
                
                private static void BuildElementDictionary() {
                    localElementDictionary.Add(XName.Get("option", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(optionLocalType));
                }
                
                ContentModelEntity IXMetaData.GetContentModel() {
                    return ContentModelEntity.Default;
                }
                
                public partial class optionLocalType : XTypedElement, IXMetaData {
                    
         public static explicit operator optionLocalType(XElement xe) { return XTypedServices.ToXTypedElement<optionLocalType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
                    
                    public optionLocalType() {
                    }
                    
                    /// <summary>
                    /// <para>
                    /// The value to be passed for the property when this option is selected.
                    /// </para>
                    /// <para>
                    /// Occurrence: required
                    /// </para>
                    /// </summary>
                    public string value {
                        get {
                            XAttribute x = this.Attribute(XName.Get("value", ""));
                            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                        }
                        set {
                            this.SetAttribute(XName.Get("value", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                        }
                    }
                    
                    /// <summary>
                    /// <para>
                    /// The value to be displayed in the UI for this option. If the displayValue attribute is not specified, the value attribute is used both for the UI and for the actual value passed as the property value.
                    /// </para>
                    /// <para>
                    /// Occurrence: optional
                    /// </para>
                    /// </summary>
                    public string displayValue {
                        get {
                            XAttribute x = this.Attribute(XName.Get("displayValue", ""));
                            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                        }
                        set {
                            this.SetAttribute(XName.Get("displayValue", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                        }
                    }
                    
                    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                    XName IXMetaData.SchemaName {
                        get {
                            return XName.Get("option", "http://schemas.microsoft.com/Octopus/2005/01/Service");
                        }
                    }
                    
                    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                    SchemaOrigin IXMetaData.TypeOrigin {
                        get {
                            return SchemaOrigin.Fragment;
                        }
                    }
                    
                    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                    ILinqToXsdTypeManager IXMetaData.TypeManager {
                        get {
                            return LinqToXsdTypeManager.Instance;
                        }
                    }
                    
                    public override XTypedElement Clone() {
                        return XTypedServices.CloneXTypedElement<optionLocalType>(this);
                    }
                    
                    ContentModelEntity IXMetaData.GetContentModel() {
                        return ContentModelEntity.Default;
                    }
                }
            }
            
            public partial class textboxLocalType : XTypedElement, IXMetaData {
                
         public static explicit operator textboxLocalType(XElement xe) { return XTypedServices.ToXTypedElement<textboxLocalType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
                
                public textboxLocalType() {
                }
                
                /// <summary>
                /// <para>
                /// The maximum length imposed upon the text typed in this field.
                /// </para>
                /// <para>
                /// Occurrence: optional
                /// </para>
                /// </summary>
                public System.Nullable<decimal> length {
                    get {
                        XAttribute x = this.Attribute(XName.Get("length", ""));
                        if ((x == null)) {
                            return null;
                        }
                        return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
                    }
                    set {
                        this.SetAttribute(XName.Get("length", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
                    }
                }
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                XName IXMetaData.SchemaName {
                    get {
                        return XName.Get("textbox", "http://schemas.microsoft.com/Octopus/2005/01/Service");
                    }
                }
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                SchemaOrigin IXMetaData.TypeOrigin {
                    get {
                        return SchemaOrigin.Fragment;
                    }
                }
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                ILinqToXsdTypeManager IXMetaData.TypeManager {
                    get {
                        return LinqToXsdTypeManager.Instance;
                    }
                }
                
                public override XTypedElement Clone() {
                    return XTypedServices.CloneXTypedElement<textboxLocalType>(this);
                }
                
                ContentModelEntity IXMetaData.GetContentModel() {
                    return ContentModelEntity.Default;
                }
            }
            
            public partial class passwordLocalType : XTypedElement, IXMetaData {
                
         public static explicit operator passwordLocalType(XElement xe) { return XTypedServices.ToXTypedElement<passwordLocalType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
                
                public passwordLocalType() {
                }
                
                /// <summary>
                /// <para>
                /// The maximum length imposed upon the password entry field by the Octopus Console.
                /// </para>
                /// <para>
                /// Occurrence: optional
                /// </para>
                /// </summary>
                public System.Nullable<decimal> length {
                    get {
                        XAttribute x = this.Attribute(XName.Get("length", ""));
                        if ((x == null)) {
                            return null;
                        }
                        return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
                    }
                    set {
                        this.SetAttribute(XName.Get("length", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
                    }
                }
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                XName IXMetaData.SchemaName {
                    get {
                        return XName.Get("password", "http://schemas.microsoft.com/Octopus/2005/01/Service");
                    }
                }
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                SchemaOrigin IXMetaData.TypeOrigin {
                    get {
                        return SchemaOrigin.Fragment;
                    }
                }
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                ILinqToXsdTypeManager IXMetaData.TypeManager {
                    get {
                        return LinqToXsdTypeManager.Instance;
                    }
                }
                
                public override XTypedElement Clone() {
                    return XTypedServices.CloneXTypedElement<passwordLocalType>(this);
                }
                
                ContentModelEntity IXMetaData.GetContentModel() {
                    return ContentModelEntity.Default;
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// An aggregation of one component within another.
    /// </para>
    /// <para>
    /// 
    ///The <aggregateComponent> element names another
    ///component
    ///whose elements will be aggregated into the current component.
    ///Aggregation creates a copy of the elements and properties of the aggregated
    ///component and places them in the current component.
    ///
    ///The aggregateComponent element is commonly used to build
    ///published components from smaller foundational components.
    ///This is useful for convenience when defining multiple topologies for a service.
    ///For example, a one-box development topology could publish a single component.
    ///That component could aggregate several other components that ordinarily would be
    ///published independently in a larger topology.
    ///
    ///The passProperty element is used in these situations to override static values
    ///in aggregated components.
    ///
    /// </para>
    /// <para>
    /// Regular expression: (passProperty*)*
    /// </para>
    /// </summary>
    public partial class AggregateComponentType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<PassPropertyType> passPropertyField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
        
         public static explicit operator AggregateComponentType(XElement xe) { return XTypedServices.ToXTypedElement<AggregateComponentType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static AggregateComponentType() {
            BuildElementDictionary();
        }
        
        /// <summary>
        /// <para>
        /// An aggregation of one component within another.
        /// </para>
        /// <para>
        /// 
        ///The <aggregateComponent> element names another
        ///component
        ///whose elements will be aggregated into the current component.
        ///Aggregation creates a copy of the elements and properties of the aggregated
        ///component and places them in the current component.
        ///
        ///The aggregateComponent element is commonly used to build
        ///published components from smaller foundational components.
        ///This is useful for convenience when defining multiple topologies for a service.
        ///For example, a one-box development topology could publish a single component.
        ///That component could aggregate several other components that ordinarily would be
        ///published independently in a larger topology.
        ///
        ///The passProperty element is used in these situations to override static values
        ///in aggregated components.
        ///
        /// </para>
        /// <para>
        /// Regular expression: (passProperty*)*
        /// </para>
        /// </summary>
        public AggregateComponentType() {
        }
        
        /// <summary>
        /// <para>
        /// Specifies a value that overrides the value of an aggregated property.
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (passProperty*)*
        /// </para>
        /// </summary>
        public IList<PassPropertyType> passProperty {
            get {
                if ((this.passPropertyField == null)) {
                    this.passPropertyField = new XTypedList<PassPropertyType>(this, LinqToXsdTypeManager.Instance, XName.Get("passProperty", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                }
                return this.passPropertyField;
            }
            set {
                if ((value == null)) {
                    this.passPropertyField = null;
                }
                else {
                    if ((this.passPropertyField == null)) {
                        this.passPropertyField = XTypedList<PassPropertyType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("passProperty", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                    }
                    else {
                        XTypedServices.SetList<PassPropertyType>(this.passPropertyField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// The name of the component to aggregate.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public string name {
            get {
                XAttribute x = this.Attribute(XName.Get("name", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("name", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("AggregateComponentType", "http://schemas.microsoft.com/Octopus/2005/01/Service");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<AggregateComponentType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(XName.Get("passProperty", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(PassPropertyType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    /// <summary>
    /// <para>
    /// The <checkUser> element names a user in the global catalog that will be checked for existence. Optionally the user's password may also be checked.In many Operations environments, accounts are created by hand in order to maintain restrictions upon the way the Active Directory is manipulated. In these situations, it is important to verify that user names and passwords specified for service accounts are correct before starting deployment. By stating a username and password, the Octopus Engine will attempt a logon against that user and verify success.Passwords should never be hard-coded in the service.xml file. Instead specify the password attribute as the value of a user-input property to be entered by the Operator through the Octopus Console. The is done with the syntax: password="[Property]".
    /// </para>
    /// </summary>
    public partial class CheckUser : global::schemas.microsoft.com.Octopus.Item2005.Item01.Service.Check, IXMetaData {
        
         public static explicit operator CheckUser(XElement xe) { return XTypedServices.ToXTypedElement<CheckUser>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        /// <summary>
        /// <para>
        /// The <checkUser> element names a user in the global catalog that will be checked for existence. Optionally the user's password may also be checked.In many Operations environments, accounts are created by hand in order to maintain restrictions upon the way the Active Directory is manipulated. In these situations, it is important to verify that user names and passwords specified for service accounts are correct before starting deployment. By stating a username and password, the Octopus Engine will attempt a logon against that user and verify success.Passwords should never be hard-coded in the service.xml file. Instead specify the password attribute as the value of a user-input property to be entered by the Operator through the Octopus Console. The is done with the syntax: password="[Property]".
        /// </para>
        /// </summary>
        public CheckUser() {
        }
        
        /// <summary>
        /// <para>
        /// The name of the user to check.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public string userName {
            get {
                XAttribute x = this.Attribute(XName.Get("userName", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("userName", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The password to be verified for the specified user.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public string password {
            get {
                XAttribute x = this.Attribute(XName.Get("password", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("password", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("CheckUser", "http://schemas.microsoft.com/Octopus/2005/01/Service");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<CheckUser>(this);
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    /// <summary>
    /// <para>
    /// The <checkGroup> element names a group in the global catalog that will be checked for existence.The checkGroup element will not find local groups on a particular server. However, it will find domain groups located anywhere in the active directory forest global catalog. This includes domain local and domain universal groups.
    /// </para>
    /// </summary>
    public partial class CheckGroup : global::schemas.microsoft.com.Octopus.Item2005.Item01.Service.Check, IXMetaData {
        
         public static explicit operator CheckGroup(XElement xe) { return XTypedServices.ToXTypedElement<CheckGroup>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        /// <summary>
        /// <para>
        /// The <checkGroup> element names a group in the global catalog that will be checked for existence.The checkGroup element will not find local groups on a particular server. However, it will find domain groups located anywhere in the active directory forest global catalog. This includes domain local and domain universal groups.
        /// </para>
        /// </summary>
        public CheckGroup() {
        }
        
        /// <summary>
        /// <para>
        /// The group to check for existence.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public string groupName {
            get {
                XAttribute x = this.Attribute(XName.Get("groupName", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("groupName", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("CheckGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<CheckGroup>(this);
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    /// <summary>
    /// <para>
    /// The <checkGroupMembership> checks that a specified user or group is a member of another group.The checkGroupMembership element will not work with local groups, but it can verify that a domain user is a member of a domain local or domain universal security group. This element only works for security groups, and not mail distribution groups.
    /// </para>
    /// </summary>
    public partial class CheckGroupMembership : global::schemas.microsoft.com.Octopus.Item2005.Item01.Service.Check, IXMetaData {
        
         public static explicit operator CheckGroupMembership(XElement xe) { return XTypedServices.ToXTypedElement<CheckGroupMembership>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        /// <summary>
        /// <para>
        /// The <checkGroupMembership> checks that a specified user or group is a member of another group.The checkGroupMembership element will not work with local groups, but it can verify that a domain user is a member of a domain local or domain universal security group. This element only works for security groups, and not mail distribution groups.
        /// </para>
        /// </summary>
        public CheckGroupMembership() {
        }
        
        /// <summary>
        /// <para>
        /// The name of the group to check.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public string groupName {
            get {
                XAttribute x = this.Attribute(XName.Get("groupName", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("groupName", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The name of the group member to verify. This can be either a user or another group.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public string memberName {
            get {
                XAttribute x = this.Attribute(XName.Get("memberName", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("memberName", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("CheckGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<CheckGroupMembership>(this);
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    /// <summary>
    /// <para>
    /// A list of status codes returned by a command action.
    /// </para>
    /// <para>
    /// Regular expression: (statusCode+)+
    /// </para>
    /// </summary>
    public partial class StatusCodeList : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<statusCodeLocalType> statusCodeField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
        
         public static explicit operator StatusCodeList(XElement xe) { return XTypedServices.ToXTypedElement<StatusCodeList>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static StatusCodeList() {
            BuildElementDictionary();
        }
        
        /// <summary>
        /// <para>
        /// A list of status codes returned by a command action.
        /// </para>
        /// <para>
        /// Regular expression: (statusCode+)+
        /// </para>
        /// </summary>
        public StatusCodeList() {
        }
        
        /// <summary>
        /// <para>
        /// Describes a numeric exit code that might be returned by the command.
        /// </para>
        /// <para>
        /// 
        ///A <statusCode> element specifies a numeric exit code that might be returned by a command, the success or failure status of the exit code, and a text message explaining the meaning of the exit code.
        /// </para>
        /// <para>
        /// Occurrence: required, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (statusCode+)+
        /// </para>
        /// </summary>
        public IList<schemas.microsoft.com.Octopus.Item2005.Item01.Service.StatusCodeList.statusCodeLocalType> statusCode {
            get {
                if ((this.statusCodeField == null)) {
                    this.statusCodeField = new XTypedList<statusCodeLocalType>(this, LinqToXsdTypeManager.Instance, XName.Get("statusCode", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                }
                return this.statusCodeField;
            }
            set {
                if ((value == null)) {
                    this.statusCodeField = null;
                }
                else {
                    if ((this.statusCodeField == null)) {
                        this.statusCodeField = XTypedList<statusCodeLocalType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("statusCode", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                    }
                    else {
                        XTypedServices.SetList<statusCodeLocalType>(this.statusCodeField, value);
                    }
                }
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("StatusCodeList", "http://schemas.microsoft.com/Octopus/2005/01/Service");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<StatusCodeList>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(XName.Get("statusCode", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(statusCodeLocalType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        public partial class statusCodeLocalType : XTypedElement, IXMetaData {
            
         public static explicit operator statusCodeLocalType(XElement xe) { return XTypedServices.ToXTypedElement<statusCodeLocalType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
            
            public statusCodeLocalType() {
            }
            
            /// <summary>
            /// <para>
            /// The numeric exit code to which this statusCode element applies.
            /// </para>
            /// <para>
            /// Occurrence: required
            /// </para>
            /// </summary>
            public int value {
                get {
                    XAttribute x = this.Attribute(XName.Get("value", ""));
                    return XTypedServices.ParseValue<int>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Int).Datatype);
                }
                set {
                    this.SetAttribute(XName.Get("value", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Int).Datatype);
                }
            }
            
            /// <summary>
            /// <para>
            /// One of the values "success", "success_reboot", "reboot_rerun", "warning" or "failure". Success and failure indicate that the command completed successfully or failed, respectively. The meaning of warning depends on the 'Treat Warning As Errors' flag. Success_reboot indicates that the command completed successfully, but the server must be rebooted before the changes take effect. reboot_rerun indicates the command did not complete, it requires a reboot now and needs to be invoked again.
            /// </para>
            /// <para>
            /// Occurrence: required
            /// </para>
            /// </summary>
            public string type {
                get {
                    XAttribute x = this.Attribute(XName.Get("type", ""));
                    return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
                set {
                    this.SetAttribute(XName.Get("type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
            }
            
            /// <summary>
            /// <para>
            /// The message to be displayed to the user describing the meaning of this status code.
            /// </para>
            /// <para>
            /// Occurrence: required
            /// </para>
            /// </summary>
            public string message {
                get {
                    XAttribute x = this.Attribute(XName.Get("message", ""));
                    return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
                set {
                    this.SetAttribute(XName.Get("message", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            XName IXMetaData.SchemaName {
                get {
                    return XName.Get("statusCode", "http://schemas.microsoft.com/Octopus/2005/01/Service");
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            SchemaOrigin IXMetaData.TypeOrigin {
                get {
                    return SchemaOrigin.Fragment;
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            ILinqToXsdTypeManager IXMetaData.TypeManager {
                get {
                    return LinqToXsdTypeManager.Instance;
                }
            }
            
            public override XTypedElement Clone() {
                return XTypedServices.CloneXTypedElement<statusCodeLocalType>(this);
            }
            
            ContentModelEntity IXMetaData.GetContentModel() {
                return ContentModelEntity.Default;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Specification of a command to run for install, uninstall or check.
    /// </para>
    /// <para>
    /// Regular expression: (statusCodes? | inputFiles? | outputFiles?)*
    /// </para>
    /// </summary>
    public partial class CommandType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<StatusCodeList> statusCodesField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<FileListType> inputFilesField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<FileListType> outputFilesField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
        
         public static explicit operator CommandType(XElement xe) { return XTypedServices.ToXTypedElement<CommandType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static CommandType() {
            BuildElementDictionary();
        }
        
        /// <summary>
        /// <para>
        /// Specification of a command to run for install, uninstall or check.
        /// </para>
        /// <para>
        /// Regular expression: (statusCodes? | inputFiles? | outputFiles?)*
        /// </para>
        /// </summary>
        public CommandType() {
        }
        
        /// <summary>
        /// <para>
        /// A collection of statusCode elements that control how Octopus handles the status returned by the command.
        /// </para>
        /// <para>
        /// 
        ///The <statusCode> element is a collection of statusCode elements that control how Octopus handles the status returned by a command.
        /// </para>
        /// <para>
        /// Occurrence: optional, choice
        /// </para>
        /// <para>
        /// Regular expression: (statusCodes? | inputFiles? | outputFiles?)*
        /// </para>
        /// </summary>
        public IList<StatusCodeList> statusCodes {
            get {
                if ((this.statusCodesField == null)) {
                    this.statusCodesField = new XTypedList<StatusCodeList>(this, LinqToXsdTypeManager.Instance, XName.Get("statusCodes", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                }
                return this.statusCodesField;
            }
            set {
                if ((value == null)) {
                    this.statusCodesField = null;
                }
                else {
                    if ((this.statusCodesField == null)) {
                        this.statusCodesField = XTypedList<StatusCodeList>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("statusCodes", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                    }
                    else {
                        XTypedServices.SetList<StatusCodeList>(this.statusCodesField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// A list of files to be copied from the build location to the target server before command execution.
        /// </para>
        /// <para>
        /// The <inputFiles> element contains a list of files to be copied from the build location to the target server before command execution.
        /// </para>
        /// <para>
        /// Occurrence: optional, choice
        /// </para>
        /// <para>
        /// Regular expression: (statusCodes? | inputFiles? | outputFiles?)*
        /// </para>
        /// </summary>
        public IList<FileListType> inputFiles {
            get {
                if ((this.inputFilesField == null)) {
                    this.inputFilesField = new XTypedList<FileListType>(this, LinqToXsdTypeManager.Instance, XName.Get("inputFiles", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                }
                return this.inputFilesField;
            }
            set {
                if ((value == null)) {
                    this.inputFilesField = null;
                }
                else {
                    if ((this.inputFilesField == null)) {
                        this.inputFilesField = XTypedList<FileListType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("inputFiles", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                    }
                    else {
                        XTypedServices.SetList<FileListType>(this.inputFilesField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// A list of files to copy back from the target server to the log share after command execution.
        /// </para>
        /// <para>
        /// The <outputFiles> element contains a list of files to copy back from the target server to the log share after command execution.
        /// </para>
        /// <para>
        /// Occurrence: optional, choice
        /// </para>
        /// <para>
        /// Regular expression: (statusCodes? | inputFiles? | outputFiles?)*
        /// </para>
        /// </summary>
        public IList<FileListType> outputFiles {
            get {
                if ((this.outputFilesField == null)) {
                    this.outputFilesField = new XTypedList<FileListType>(this, LinqToXsdTypeManager.Instance, XName.Get("outputFiles", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                }
                return this.outputFilesField;
            }
            set {
                if ((value == null)) {
                    this.outputFilesField = null;
                }
                else {
                    if ((this.outputFilesField == null)) {
                        this.outputFilesField = XTypedList<FileListType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("outputFiles", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                    }
                    else {
                        XTypedServices.SetList<FileListType>(this.outputFilesField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// An arbitrary name that you assign to this command. This name is used in the file and directory names for log files. It must be unique among all installCommand, uninstallCommand and commandCheck elements in a given service manifest. Command names must start and end with a letter or digit; and may include letters, digits, underscores, spaces, periods or dashes between the first and last character.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public string name {
            get {
                XAttribute x = this.Attribute(XName.Get("name", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("name", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The command to execute. This may include references to component properties by enclosing the property name in square brackets. After expansion of properties, the command is interpreted by cmd.exe on the target machine, so it may refer to environment variables using a name enclosed in percent signs. The Octopus agent defines a set of environment variables prior to executing the command.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public string cmd {
            get {
                XAttribute x = this.Attribute(XName.Get("cmd", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("cmd", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("CommandType", "http://schemas.microsoft.com/Octopus/2005/01/Service");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<CommandType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(XName.Get("statusCodes", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(StatusCodeList));
            localElementDictionary.Add(XName.Get("inputFiles", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(FileListType));
            localElementDictionary.Add(XName.Get("outputFiles", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(FileListType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    /// <summary>
    /// <para>
    /// A list of files to copy to or from a target server for a command action.
    /// </para>
    /// <para>
    /// Regular expression: (file+)+
    /// </para>
    /// </summary>
    public partial class FileListType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<FileType> fileField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
        
         public static explicit operator FileListType(XElement xe) { return XTypedServices.ToXTypedElement<FileListType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static FileListType() {
            BuildElementDictionary();
        }
        
        /// <summary>
        /// <para>
        /// A list of files to copy to or from a target server for a command action.
        /// </para>
        /// <para>
        /// Regular expression: (file+)+
        /// </para>
        /// </summary>
        public FileListType() {
        }
        
        /// <summary>
        /// <para>
        /// A single file to be copied.
        /// </para>
        /// <para>
        /// Occurrence: required, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (file+)+
        /// </para>
        /// </summary>
        public IList<FileType> file {
            get {
                if ((this.fileField == null)) {
                    this.fileField = new XTypedList<FileType>(this, LinqToXsdTypeManager.Instance, XName.Get("file", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                }
                return this.fileField;
            }
            set {
                if ((value == null)) {
                    this.fileField = null;
                }
                else {
                    if ((this.fileField == null)) {
                        this.fileField = XTypedList<FileType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("file", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                    }
                    else {
                        XTypedServices.SetList<FileType>(this.fileField, value);
                    }
                }
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("FileListType", "http://schemas.microsoft.com/Octopus/2005/01/Service");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<FileListType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(XName.Get("file", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(FileType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    /// <summary>
    /// <para>
    /// The <file> element specifies a file to be created or copied to the target server before execution of a command (an input file), or to be copied from the target server to the log folder after executing the command (an output file).
    ///                    When an absolute path is used for the sourcePath attribute of an output file,
    ///                    a relative path must be specified for the destinationPath attribute.
    ///                    Otherwise, since the default destination path is the same as the source path,
    ///                    the absolute source path will be appended to the Octopus log directory,
    ///                    resulting in an invalid file path.
    ///                    
    ///                    For example, to copy the file setup.log from %SystemRoot%\System32 on the target server to
    ///                    the Octopus log directory, use the following:
    ///                    <file sourcePath="%SystemRoot%\System32\setup.log" destinationPath="setup.log" />
    /// </para>
    /// </summary>
    public partial class FileType : XTypedElement, IXMetaData {
        
         public static explicit operator FileType(XElement xe) { return XTypedServices.ToXTypedElement<FileType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        /// <summary>
        /// <para>
        /// The <file> element specifies a file to be created or copied to the target server before execution of a command (an input file), or to be copied from the target server to the log folder after executing the command (an output file).
        ///                    When an absolute path is used for the sourcePath attribute of an output file,
        ///                    a relative path must be specified for the destinationPath attribute.
        ///                    Otherwise, since the default destination path is the same as the source path,
        ///                    the absolute source path will be appended to the Octopus log directory,
        ///                    resulting in an invalid file path.
        ///                    
        ///                    For example, to copy the file setup.log from %SystemRoot%\System32 on the target server to
        ///                    the Octopus log directory, use the following:
        ///                    <file sourcePath="%SystemRoot%\System32\setup.log" destinationPath="setup.log" />
        /// </para>
        /// </summary>
        public FileType() {
        }
        
        /// <summary>
        /// <para>
        /// The source path for the file to be copied. When used for input files, this file path is relative to the build directory, or may be omitted, and the text inside the <file> element will be used as the content of the file. When used for output files, this path is relative to the temporary directory on the target server, or may be an absolute path on the target server.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public string sourcePath {
            get {
                XAttribute x = this.Attribute(XName.Get("sourcePath", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("sourcePath", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// An optional destination path for the file to be copied. If not specified, the destination path is the same as the source path. When used with input files, the destination path is relative to the temporary directory on the target server. When used with output files, the destination path is relative to the Octopus log directory for the command being executed.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public string destinationPath {
            get {
                XAttribute x = this.Attribute(XName.Get("destinationPath", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("destinationPath", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("FileType", "http://schemas.microsoft.com/Octopus/2005/01/Service");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<FileType>(this);
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    /// <summary>
    /// <para>
    /// A collection of checks.
    /// </para>
    /// <para>
    /// Regular expression: (checkUser* | checkGroup* | checkGroupMembership* | checkDrive* | checkFile* | checkFolder* | checkValue* | checkRegistry* | checkService* | checkWebSite* | commandCheck* | not* | or* | and* | @true* | @false* | any)+
    /// </para>
    /// </summary>
    public partial class ChecksType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<CheckUser> checkUserField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<CheckGroup> checkGroupField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<CheckGroupMembership> checkGroupMembershipField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<CheckDrive> checkDriveField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<CheckFile> checkFileField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<CheckFolder> checkFolderField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<CheckValue> checkValueField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<CheckRegistry> checkRegistryField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<CheckService> checkServiceField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<CheckWebSite> checkWebSiteField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<CommandCheck> commandCheckField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<LogicalCheck> notField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<LogicalCheck> orField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<LogicalCheck> andField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<XTypedElement> @trueField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<XTypedElement> @falseField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static FSM validationStates;
        
         public static explicit operator ChecksType(XElement xe) { return XTypedServices.ToXTypedElement<ChecksType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static ChecksType() {
            BuildElementDictionary();
            InitFSM();
        }
        
        /// <summary>
        /// <para>
        /// A collection of checks.
        /// </para>
        /// <para>
        /// Regular expression: (checkUser* | checkGroup* | checkGroupMembership* | checkDrive* | checkFile* | checkFolder* | checkValue* | checkRegistry* | checkService* | checkWebSite* | commandCheck* | not* | or* | and* | @true* | @false* | any)+
        /// </para>
        /// </summary>
        public ChecksType() {
        }
        
        /// <summary>
        /// <para>
        /// Check for the existence of a domain user and optionally check the user's password. NOTE: Only valid within domain checks.
        /// </para>
        /// <para>
        /// conditionChecksinstalledChecksprerequisiteChecks
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (checkUser* | checkGroup* | checkGroupMembership* | checkDrive* | checkFile* | checkFolder* | checkValue* | checkRegistry* | checkService* | checkWebSite* | commandCheck* | not* | or* | and* | @true* | @false* | any)+
        /// </para>
        /// </summary>
        public IList<CheckUser> checkUser {
            get {
                if ((this.checkUserField == null)) {
                    this.checkUserField = new XTypedList<CheckUser>(this, LinqToXsdTypeManager.Instance, XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                }
                return this.checkUserField;
            }
            set {
                if ((value == null)) {
                    this.checkUserField = null;
                }
                else {
                    if ((this.checkUserField == null)) {
                        this.checkUserField = XTypedList<CheckUser>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                    }
                    else {
                        XTypedServices.SetList<CheckUser>(this.checkUserField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Check for the existence of a domain group. NOTE: Only valid within domain checks.
        /// </para>
        /// <para>
        /// conditionChecksinstalledChecksprerequisiteChecks
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (checkUser* | checkGroup* | checkGroupMembership* | checkDrive* | checkFile* | checkFolder* | checkValue* | checkRegistry* | checkService* | checkWebSite* | commandCheck* | not* | or* | and* | @true* | @false* | any)+
        /// </para>
        /// </summary>
        public IList<CheckGroup> checkGroup {
            get {
                if ((this.checkGroupField == null)) {
                    this.checkGroupField = new XTypedList<CheckGroup>(this, LinqToXsdTypeManager.Instance, XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                }
                return this.checkGroupField;
            }
            set {
                if ((value == null)) {
                    this.checkGroupField = null;
                }
                else {
                    if ((this.checkGroupField == null)) {
                        this.checkGroupField = XTypedList<CheckGroup>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                    }
                    else {
                        XTypedServices.SetList<CheckGroup>(this.checkGroupField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Check for membership in a domain group. NOTE: Only valid within domain checks.
        /// </para>
        /// <para>
        /// conditionChecksinstalledChecksprerequisiteChecks
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (checkUser* | checkGroup* | checkGroupMembership* | checkDrive* | checkFile* | checkFolder* | checkValue* | checkRegistry* | checkService* | checkWebSite* | commandCheck* | not* | or* | and* | @true* | @false* | any)+
        /// </para>
        /// </summary>
        public IList<CheckGroupMembership> checkGroupMembership {
            get {
                if ((this.checkGroupMembershipField == null)) {
                    this.checkGroupMembershipField = new XTypedList<CheckGroupMembership>(this, LinqToXsdTypeManager.Instance, XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                }
                return this.checkGroupMembershipField;
            }
            set {
                if ((value == null)) {
                    this.checkGroupMembershipField = null;
                }
                else {
                    if ((this.checkGroupMembershipField == null)) {
                        this.checkGroupMembershipField = XTypedList<CheckGroupMembership>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                    }
                    else {
                        XTypedServices.SetList<CheckGroupMembership>(this.checkGroupMembershipField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Check for the existence of a logical drive letter. NOTE: Only valid within component checks.
        /// </para>
        /// <para>
        /// domainChecks
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (checkUser* | checkGroup* | checkGroupMembership* | checkDrive* | checkFile* | checkFolder* | checkValue* | checkRegistry* | checkService* | checkWebSite* | commandCheck* | not* | or* | and* | @true* | @false* | any)+
        /// </para>
        /// </summary>
        public IList<CheckDrive> checkDrive {
            get {
                if ((this.checkDriveField == null)) {
                    this.checkDriveField = new XTypedList<CheckDrive>(this, LinqToXsdTypeManager.Instance, XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                }
                return this.checkDriveField;
            }
            set {
                if ((value == null)) {
                    this.checkDriveField = null;
                }
                else {
                    if ((this.checkDriveField == null)) {
                        this.checkDriveField = XTypedList<CheckDrive>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                    }
                    else {
                        XTypedServices.SetList<CheckDrive>(this.checkDriveField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Check for the existence and/or version of a file. NOTE: Only valid within component checks.
        /// </para>
        /// <para>
        /// domainChecks
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (checkUser* | checkGroup* | checkGroupMembership* | checkDrive* | checkFile* | checkFolder* | checkValue* | checkRegistry* | checkService* | checkWebSite* | commandCheck* | not* | or* | and* | @true* | @false* | any)+
        /// </para>
        /// </summary>
        public IList<CheckFile> checkFile {
            get {
                if ((this.checkFileField == null)) {
                    this.checkFileField = new XTypedList<CheckFile>(this, LinqToXsdTypeManager.Instance, XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                }
                return this.checkFileField;
            }
            set {
                if ((value == null)) {
                    this.checkFileField = null;
                }
                else {
                    if ((this.checkFileField == null)) {
                        this.checkFileField = XTypedList<CheckFile>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                    }
                    else {
                        XTypedServices.SetList<CheckFile>(this.checkFileField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Check for the existence of a folder. NOTE: Only valid within component checks.
        /// </para>
        /// <para>
        /// domainChecks
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (checkUser* | checkGroup* | checkGroupMembership* | checkDrive* | checkFile* | checkFolder* | checkValue* | checkRegistry* | checkService* | checkWebSite* | commandCheck* | not* | or* | and* | @true* | @false* | any)+
        /// </para>
        /// </summary>
        public IList<CheckFolder> checkFolder {
            get {
                if ((this.checkFolderField == null)) {
                    this.checkFolderField = new XTypedList<CheckFolder>(this, LinqToXsdTypeManager.Instance, XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                }
                return this.checkFolderField;
            }
            set {
                if ((value == null)) {
                    this.checkFolderField = null;
                }
                else {
                    if ((this.checkFolderField == null)) {
                        this.checkFolderField = XTypedList<CheckFolder>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                    }
                    else {
                        XTypedServices.SetList<CheckFolder>(this.checkFolderField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Check/compare value(s).
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (checkUser* | checkGroup* | checkGroupMembership* | checkDrive* | checkFile* | checkFolder* | checkValue* | checkRegistry* | checkService* | checkWebSite* | commandCheck* | not* | or* | and* | @true* | @false* | any)+
        /// </para>
        /// </summary>
        public IList<CheckValue> checkValue {
            get {
                if ((this.checkValueField == null)) {
                    this.checkValueField = new XTypedList<CheckValue>(this, LinqToXsdTypeManager.Instance, XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                }
                return this.checkValueField;
            }
            set {
                if ((value == null)) {
                    this.checkValueField = null;
                }
                else {
                    if ((this.checkValueField == null)) {
                        this.checkValueField = XTypedList<CheckValue>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                    }
                    else {
                        XTypedServices.SetList<CheckValue>(this.checkValueField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Check a registry key value. NOTE: Only valid within component checks.
        /// </para>
        /// <para>
        /// domainChecks
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (checkUser* | checkGroup* | checkGroupMembership* | checkDrive* | checkFile* | checkFolder* | checkValue* | checkRegistry* | checkService* | checkWebSite* | commandCheck* | not* | or* | and* | @true* | @false* | any)+
        /// </para>
        /// </summary>
        public IList<CheckRegistry> checkRegistry {
            get {
                if ((this.checkRegistryField == null)) {
                    this.checkRegistryField = new XTypedList<CheckRegistry>(this, LinqToXsdTypeManager.Instance, XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                }
                return this.checkRegistryField;
            }
            set {
                if ((value == null)) {
                    this.checkRegistryField = null;
                }
                else {
                    if ((this.checkRegistryField == null)) {
                        this.checkRegistryField = XTypedList<CheckRegistry>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                    }
                    else {
                        XTypedServices.SetList<CheckRegistry>(this.checkRegistryField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Check the status of a service. NOTE: Only valid within component checks.
        /// </para>
        /// <para>
        /// domainChecks
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (checkUser* | checkGroup* | checkGroupMembership* | checkDrive* | checkFile* | checkFolder* | checkValue* | checkRegistry* | checkService* | checkWebSite* | commandCheck* | not* | or* | and* | @true* | @false* | any)+
        /// </para>
        /// </summary>
        public IList<CheckService> checkService {
            get {
                if ((this.checkServiceField == null)) {
                    this.checkServiceField = new XTypedList<CheckService>(this, LinqToXsdTypeManager.Instance, XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                }
                return this.checkServiceField;
            }
            set {
                if ((value == null)) {
                    this.checkServiceField = null;
                }
                else {
                    if ((this.checkServiceField == null)) {
                        this.checkServiceField = XTypedList<CheckService>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                    }
                    else {
                        XTypedServices.SetList<CheckService>(this.checkServiceField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Check for the existence of an IIS Web Site. NOTE: Only valid within component checks.
        /// </para>
        /// <para>
        /// domainChecks
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (checkUser* | checkGroup* | checkGroupMembership* | checkDrive* | checkFile* | checkFolder* | checkValue* | checkRegistry* | checkService* | checkWebSite* | commandCheck* | not* | or* | and* | @true* | @false* | any)+
        /// </para>
        /// </summary>
        public IList<CheckWebSite> checkWebSite {
            get {
                if ((this.checkWebSiteField == null)) {
                    this.checkWebSiteField = new XTypedList<CheckWebSite>(this, LinqToXsdTypeManager.Instance, XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                }
                return this.checkWebSiteField;
            }
            set {
                if ((value == null)) {
                    this.checkWebSiteField = null;
                }
                else {
                    if ((this.checkWebSiteField == null)) {
                        this.checkWebSiteField = XTypedList<CheckWebSite>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                    }
                    else {
                        XTypedServices.SetList<CheckWebSite>(this.checkWebSiteField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Run a custom check defined by an arbitrary command. NOTE: Only valid within component checks.
        /// </para>
        /// <para>
        /// domainChecks
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (checkUser* | checkGroup* | checkGroupMembership* | checkDrive* | checkFile* | checkFolder* | checkValue* | checkRegistry* | checkService* | checkWebSite* | commandCheck* | not* | or* | and* | @true* | @false* | any)+
        /// </para>
        /// </summary>
        public IList<CommandCheck> commandCheck {
            get {
                if ((this.commandCheckField == null)) {
                    this.commandCheckField = new XTypedList<CommandCheck>(this, LinqToXsdTypeManager.Instance, XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                }
                return this.commandCheckField;
            }
            set {
                if ((value == null)) {
                    this.commandCheckField = null;
                }
                else {
                    if ((this.commandCheckField == null)) {
                        this.commandCheckField = XTypedList<CommandCheck>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                    }
                    else {
                        XTypedServices.SetList<CommandCheck>(this.commandCheckField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// The negation of the result of a check.
        /// </para>
        /// <para>
        /// 
        ///The <not> element must enclose exactly one check or logical operation, chosen from the list of possible child elements.
        ///The result of the <not> is the opposite of the result of the enclosed element.
        ///
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (checkUser* | checkGroup* | checkGroupMembership* | checkDrive* | checkFile* | checkFolder* | checkValue* | checkRegistry* | checkService* | checkWebSite* | commandCheck* | not* | or* | and* | @true* | @false* | any)+
        /// </para>
        /// </summary>
        public IList<LogicalCheck> not {
            get {
                if ((this.notField == null)) {
                    this.notField = new XTypedList<LogicalCheck>(this, LinqToXsdTypeManager.Instance, XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                }
                return this.notField;
            }
            set {
                if ((value == null)) {
                    this.notField = null;
                }
                else {
                    if ((this.notField == null)) {
                        this.notField = XTypedList<LogicalCheck>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                    }
                    else {
                        XTypedServices.SetList<LogicalCheck>(this.notField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// A group of checks whose result is true if any of the individual checks returns true.
        /// </para>
        /// <para>
        /// 
        ///The <or> element creates a group of checks whose results are combined using a boolean "or" operation.
        ///That is, the result is true if any of the contained checks return true.
        ///
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (checkUser* | checkGroup* | checkGroupMembership* | checkDrive* | checkFile* | checkFolder* | checkValue* | checkRegistry* | checkService* | checkWebSite* | commandCheck* | not* | or* | and* | @true* | @false* | any)+
        /// </para>
        /// </summary>
        public IList<LogicalCheck> or {
            get {
                if ((this.orField == null)) {
                    this.orField = new XTypedList<LogicalCheck>(this, LinqToXsdTypeManager.Instance, XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                }
                return this.orField;
            }
            set {
                if ((value == null)) {
                    this.orField = null;
                }
                else {
                    if ((this.orField == null)) {
                        this.orField = XTypedList<LogicalCheck>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                    }
                    else {
                        XTypedServices.SetList<LogicalCheck>(this.orField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// A group of checks in which all checks must return true for the result to be true.
        /// </para>
        /// <para>
        /// 
        ///The <and> element creates a group of checks whose results are combined using a boolean "and" operation.
        ///That is, the result is true if and only if all of the contained checks return true.
        ///
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (checkUser* | checkGroup* | checkGroupMembership* | checkDrive* | checkFile* | checkFolder* | checkValue* | checkRegistry* | checkService* | checkWebSite* | commandCheck* | not* | or* | and* | @true* | @false* | any)+
        /// </para>
        /// </summary>
        public IList<LogicalCheck> and {
            get {
                if ((this.andField == null)) {
                    this.andField = new XTypedList<LogicalCheck>(this, LinqToXsdTypeManager.Instance, XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                }
                return this.andField;
            }
            set {
                if ((value == null)) {
                    this.andField = null;
                }
                else {
                    if ((this.andField == null)) {
                        this.andField = XTypedList<LogicalCheck>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                    }
                    else {
                        XTypedServices.SetList<LogicalCheck>(this.andField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// A check which always evaluates to true.
        /// </para>
        /// <para>
        /// 
        ///A check which always evaluates to true.
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (checkUser* | checkGroup* | checkGroupMembership* | checkDrive* | checkFile* | checkFolder* | checkValue* | checkRegistry* | checkService* | checkWebSite* | commandCheck* | not* | or* | and* | @true* | @false* | any)+
        /// </para>
        /// </summary>
        public IList<XTypedElement> @true {
            get {
                if ((this.@trueField == null)) {
                    this.@trueField = new XTypedList<XTypedElement>(this, LinqToXsdTypeManager.Instance, XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                }
                return this.@trueField;
            }
            set {
                if ((value == null)) {
                    this.@trueField = null;
                }
                else {
                    if ((this.@trueField == null)) {
                        this.@trueField = XTypedList<XTypedElement>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                    }
                    else {
                        XTypedServices.SetList<XTypedElement>(this.@trueField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// A check that always evaluates to false.
        /// </para>
        /// <para>
        /// 
        ///A check that always evaluates to false.
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (checkUser* | checkGroup* | checkGroupMembership* | checkDrive* | checkFile* | checkFolder* | checkValue* | checkRegistry* | checkService* | checkWebSite* | commandCheck* | not* | or* | and* | @true* | @false* | any)+
        /// </para>
        /// </summary>
        public IList<XTypedElement> @false {
            get {
                if ((this.@falseField == null)) {
                    this.@falseField = new XTypedList<XTypedElement>(this, LinqToXsdTypeManager.Instance, XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                }
                return this.@falseField;
            }
            set {
                if ((value == null)) {
                    this.@falseField = null;
                }
                else {
                    if ((this.@falseField == null)) {
                        this.@falseField = XTypedList<XTypedElement>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                    }
                    else {
                        XTypedServices.SetList<XTypedElement>(this.@falseField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Regular expression: (checkUser* | checkGroup* | checkGroupMembership* | checkDrive* | checkFile* | checkFolder* | checkValue* | checkRegistry* | checkService* | checkWebSite* | commandCheck* | not* | or* | and* | @true* | @false* | any)+
        /// </para>
        /// </summary>
        public IEnumerable<XElement> Any {
            get {
                return this.GetWildCards(WildCard.DefaultWildCard);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("ChecksType", "http://schemas.microsoft.com/Octopus/2005/01/Service");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<ChecksType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(CheckUser));
            localElementDictionary.Add(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(CheckGroup));
            localElementDictionary.Add(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(CheckGroupMembership));
            localElementDictionary.Add(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(CheckDrive));
            localElementDictionary.Add(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(CheckFile));
            localElementDictionary.Add(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(CheckFolder));
            localElementDictionary.Add(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(CheckValue));
            localElementDictionary.Add(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(CheckRegistry));
            localElementDictionary.Add(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(CheckService));
            localElementDictionary.Add(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(CheckWebSite));
            localElementDictionary.Add(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(CommandCheck));
            localElementDictionary.Add(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(LogicalCheck));
            localElementDictionary.Add(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(LogicalCheck));
            localElementDictionary.Add(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(LogicalCheck));
            localElementDictionary.Add(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(XTypedElement));
            localElementDictionary.Add(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(XTypedElement));
        }
        
        FSM IXMetaData.GetValidationStates() {
            return validationStates;
        }
        
        private static void InitFSM() {
            Dictionary<int, Transitions> transitions = new Dictionary<int, Transitions>();
            transitions.Add(1, new Transitions(new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            transitions.Add(3, new Transitions(new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            transitions.Add(5, new Transitions(new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            transitions.Add(7, new Transitions(new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            transitions.Add(9, new Transitions(new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            transitions.Add(11, new Transitions(new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            transitions.Add(13, new Transitions(new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            transitions.Add(15, new Transitions(new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            transitions.Add(17, new Transitions(new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            transitions.Add(19, new Transitions(new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            transitions.Add(21, new Transitions(new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            transitions.Add(23, new Transitions(new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            transitions.Add(25, new Transitions(new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            transitions.Add(27, new Transitions(new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            transitions.Add(29, new Transitions(new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            transitions.Add(31, new Transitions(new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            transitions.Add(33, new Transitions(new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            validationStates = new FSM(1, new Set<int>(new int[] {
                            1,
                            3,
                            5,
                            7,
                            9,
                            11,
                            13,
                            15,
                            17,
                            19,
                            21,
                            23,
                            25,
                            27,
                            29,
                            31,
                            33}), transitions);
        }
    }
    
    /// <summary>
    /// <para>
    /// The base type for checks.
    /// </para>
    /// </summary>
    public partial class Check : XTypedElement, IXMetaData {
        
         public static explicit operator Check(XElement xe) { return XTypedServices.ToXTypedElement<Check>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        /// <summary>
        /// <para>
        /// The base type for checks.
        /// </para>
        /// </summary>
        public Check() {
        }
        
        /// <summary>
        /// <para>
        /// A help string to be displayed in the log files if the check fails.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public string help {
            get {
                XAttribute x = this.Attribute(XName.Get("help", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("help", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("Check", "http://schemas.microsoft.com/Octopus/2005/01/Service");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<Check>(this);
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    /// <summary>
    /// <para>
    /// Check for the existence of a drive letter on the target server.
    /// </para>
    /// <para>
    /// The <checkDrive> element names a logical drive letter that should be checked for existence on the target server. The check will return true only if the drive letter exists.The checkDrive check is useful for ensuring that a drive exists prior to assigning it to an application for use. For example, when configuring SQL server, checkDrive can verify that a drive is present before informing SQL to use it for logs.
    /// </para>
    /// </summary>
    public partial class CheckDrive : global::schemas.microsoft.com.Octopus.Item2005.Item01.Service.Check, IXMetaData {
        
         public static explicit operator CheckDrive(XElement xe) { return XTypedServices.ToXTypedElement<CheckDrive>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        /// <summary>
        /// <para>
        /// Check for the existence of a drive letter on the target server.
        /// </para>
        /// <para>
        /// The <checkDrive> element names a logical drive letter that should be checked for existence on the target server. The check will return true only if the drive letter exists.The checkDrive check is useful for ensuring that a drive exists prior to assigning it to an application for use. For example, when configuring SQL server, checkDrive can verify that a drive is present before informing SQL to use it for logs.
        /// </para>
        /// </summary>
        public CheckDrive() {
        }
        
        /// <summary>
        /// <para>
        /// The drive letter, followed by a colon, for example "C:", or a full path. If a full path is given, only the first two characters will be used.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public string path {
            get {
                XAttribute x = this.Attribute(XName.Get("path", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("path", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("CheckDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<CheckDrive>(this);
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    /// <summary>
    /// <para>
    /// Check for file existence and version on the target server.
    /// </para>
    /// <para>
    /// The <checkFile> element names a file that will be checked for existence on the target server. The check also supports validating the version of the file once it is located.In addition to checking a file for existence or non-existence, the various version number checks give an author considerable flexibility. For example, the checkFile element with a 'ge' version number check can be used to ensure that security or bug patches are applied before a service is deployed.
    /// </para>
    /// </summary>
    public partial class CheckFile : global::schemas.microsoft.com.Octopus.Item2005.Item01.Service.Check, IXMetaData {
        
         public static explicit operator CheckFile(XElement xe) { return XTypedServices.ToXTypedElement<CheckFile>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        /// <summary>
        /// <para>
        /// Check for file existence and version on the target server.
        /// </para>
        /// <para>
        /// The <checkFile> element names a file that will be checked for existence on the target server. The check also supports validating the version of the file once it is located.In addition to checking a file for existence or non-existence, the various version number checks give an author considerable flexibility. For example, the checkFile element with a 'ge' version number check can be used to ensure that security or bug patches are applied before a service is deployed.
        /// </para>
        /// </summary>
        public CheckFile() {
        }
        
        /// <summary>
        /// <para>
        /// The full path name of the file to check.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public string path {
            get {
                XAttribute x = this.Attribute(XName.Get("path", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("path", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// A version number against which to compare the version of the file.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public string version {
            get {
                XAttribute x = this.Attribute(XName.Get("version", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("version", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The type of check to perform.
        /// </para>
        /// <para>
        /// The method attribute may take any of the following values:eqThe version number of the file equals the specified version.exThe file exists, regardless of version.geThe version number of the file is greater than or equal to the specified version.gtThe version number of the file is greater than the specified version.leThe version number of the file is less than or equal to the specified version.ltThe version number of the file is less than the specified version.neqThe version number of the file is not equal to the specified version.nexThe file does not exist, regardless of version.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public string method {
            get {
                XAttribute x = this.Attribute(XName.Get("method", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("method", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("CheckFile", "http://schemas.microsoft.com/Octopus/2005/01/Service");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<CheckFile>(this);
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    /// <summary>
    /// <para>
    /// Check for the existence of a folder on the target server.
    /// </para>
    /// <para>
    /// The <checkFolder> element names a folder that will be checked for existence on the target server.
    /// </para>
    /// </summary>
    public partial class CheckFolder : global::schemas.microsoft.com.Octopus.Item2005.Item01.Service.Check, IXMetaData {
        
         public static explicit operator CheckFolder(XElement xe) { return XTypedServices.ToXTypedElement<CheckFolder>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        /// <summary>
        /// <para>
        /// Check for the existence of a folder on the target server.
        /// </para>
        /// <para>
        /// The <checkFolder> element names a folder that will be checked for existence on the target server.
        /// </para>
        /// </summary>
        public CheckFolder() {
        }
        
        /// <summary>
        /// <para>
        /// The full path of the folder to check for existence.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public string path {
            get {
                XAttribute x = this.Attribute(XName.Get("path", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("path", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("CheckFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<CheckFolder>(this);
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    /// <summary>
    /// <para>
    /// Check a property value.
    /// </para>
    /// <para>
    /// The <checkValue> element compares two values.Note that value1 and value2 may contain references to property values enclosed in square brackets.
    /// </para>
    /// </summary>
    public partial class CheckValue : global::schemas.microsoft.com.Octopus.Item2005.Item01.Service.Check, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static string typeDefaultValue = "string";
        
         public static explicit operator CheckValue(XElement xe) { return XTypedServices.ToXTypedElement<CheckValue>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        /// <summary>
        /// <para>
        /// Check a property value.
        /// </para>
        /// <para>
        /// The <checkValue> element compares two values.Note that value1 and value2 may contain references to property values enclosed in square brackets.
        /// </para>
        /// </summary>
        public CheckValue() {
        }
        
        /// <summary>
        /// <para>
        /// The first value.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public string value1 {
            get {
                XAttribute x = this.Attribute(XName.Get("value1", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("value1", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The second value to compare to the first value.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public string value2 {
            get {
                XAttribute x = this.Attribute(XName.Get("value2", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("value2", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The type with which to interpret the compared values. This must be 'integer', 'string' or 'version'. This governs the results of comparisons with numeric values. For example with type="string", the value "10" would be less than "2". With type="integer" or type="version", "10" would be greater than "2". Furthermore, with type="version", the string "2.10" would be greater than "2.2".
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public string type {
            get {
                XAttribute x = this.Attribute(XName.Get("type", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, typeDefaultValue);
            }
            set {
                this.SetAttribute(XName.Get("type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The type of check to perform.
        /// </para>
        /// <para>
        /// The method attribute may take any of the following values:eqBoth values are the same.geValue1 is greater than or equal to value2.gtValue1 is greater than value2.leValue1 is less than or equal to value2.ltValue1 is less than value2.neqValue1 is not equal to value2.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public string method {
            get {
                XAttribute x = this.Attribute(XName.Get("method", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("method", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("CheckValue", "http://schemas.microsoft.com/Octopus/2005/01/Service");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<CheckValue>(this);
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    /// <summary>
    /// <para>
    /// Check a registry key on the target server.
    /// </para>
    /// <para>
    /// The <checkRegistry> element names a registry key that will be checked for existence or value on the target server.
    /// </para>
    /// </summary>
    public partial class CheckRegistry : global::schemas.microsoft.com.Octopus.Item2005.Item01.Service.Check, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static string typeDefaultValue = "string";
        
         public static explicit operator CheckRegistry(XElement xe) { return XTypedServices.ToXTypedElement<CheckRegistry>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        /// <summary>
        /// <para>
        /// Check a registry key on the target server.
        /// </para>
        /// <para>
        /// The <checkRegistry> element names a registry key that will be checked for existence or value on the target server.
        /// </para>
        /// </summary>
        public CheckRegistry() {
        }
        
        /// <summary>
        /// <para>
        /// The path to the registry entry. For example "HKLM\Software\Microsoft\Windows NT\CurrentVersion".
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public string path {
            get {
                XAttribute x = this.Attribute(XName.Get("path", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("path", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The registry key to evaluate. For example "CSDVersion".
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public string key {
            get {
                XAttribute x = this.Attribute(XName.Get("key", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("key", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The value with which to compare the registry key. For example "Service Pack 1".
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public string value {
            get {
                XAttribute x = this.Attribute(XName.Get("value", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("value", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The expected type of the registry key. This must be 'dword', 'string' or 'version'. This governs the results of comparisons with numeric values. For example with type="string", the value "10" would be less than "2". With type="dword" or type="version", "10" would be greater than "2". Furthermore, with type="version", the string "2.10" would be greater than "2.2".
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public string type {
            get {
                XAttribute x = this.Attribute(XName.Get("type", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, typeDefaultValue);
            }
            set {
                this.SetAttribute(XName.Get("type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The type of check to perform.
        /// </para>
        /// <para>
        /// The method attribute may take any of the following values:eqThe value of the key equals the specified value.exThe key or path exists, regardless of the value.geThe value of the key is greater than or equal to the specified value.gtThe value of the key is greater than the specified value.leThe value of the key is less than or equal to the specified value.ltThe value of the key is less than the specified value.neqThe value of the key is not equal to the specified value.nexThe key or path does not exist, regardless of the value.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public string method {
            get {
                XAttribute x = this.Attribute(XName.Get("method", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("method", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("CheckRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<CheckRegistry>(this);
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    /// <summary>
    /// <para>
    /// Check the status of a service on the target server.
    /// </para>
    /// <para>
    /// The <checkService> element determines whether a service exists, and also its current status and startup setting.When referring to a service, specify the short service name as opposed to the friendly name. For example, the actual name of the 'ASP.NET State Service' is 'aspnet_state'.Ordinarily it is sufficient to check whether a service exists. Authors who depend upon a service to be started or stopped in advance may also specify the status attribute. Checking the startup type of the service is useful to ensure that the server is properly configured. For example, for security reasons a component might check whether the SMTP service was disabled on a Web server.
    /// </para>
    /// </summary>
    public partial class CheckService : global::schemas.microsoft.com.Octopus.Item2005.Item01.Service.Check, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static string startupDefaultValue = "enabled";
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static string statusDefaultValue = "started";
        
         public static explicit operator CheckService(XElement xe) { return XTypedServices.ToXTypedElement<CheckService>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        /// <summary>
        /// <para>
        /// Check the status of a service on the target server.
        /// </para>
        /// <para>
        /// The <checkService> element determines whether a service exists, and also its current status and startup setting.When referring to a service, specify the short service name as opposed to the friendly name. For example, the actual name of the 'ASP.NET State Service' is 'aspnet_state'.Ordinarily it is sufficient to check whether a service exists. Authors who depend upon a service to be started or stopped in advance may also specify the status attribute. Checking the startup type of the service is useful to ensure that the server is properly configured. For example, for security reasons a component might check whether the SMTP service was disabled on a Web server.
        /// </para>
        /// </summary>
        public CheckService() {
        }
        
        /// <summary>
        /// <para>
        /// The name of the service to inspect.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public string name {
            get {
                XAttribute x = this.Attribute(XName.Get("name", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("name", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The startup type of the service.
        /// </para>
        /// <para>
        /// This must be one of the following:automaticThe service starts automatically at boot time.disabledThe service should never start.enabledThe service is either set to 'automatic' or 'manual'.manualThe service should start when requested by a user or process.ignoreOctopus should not check the startup type.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public string startup {
            get {
                XAttribute x = this.Attribute(XName.Get("startup", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, startupDefaultValue);
            }
            set {
                this.SetAttribute(XName.Get("startup", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The current status of the service.
        /// </para>
        /// <para>
        /// This must be one of the following:absentThe service is not installed.startedThe service is running.stoppedThe service is not running.ignoreOctopus should not check the service status.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public string status {
            get {
                XAttribute x = this.Attribute(XName.Get("status", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, statusDefaultValue);
            }
            set {
                this.SetAttribute(XName.Get("status", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("CheckService", "http://schemas.microsoft.com/Octopus/2005/01/Service");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<CheckService>(this);
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    /// <summary>
    /// <para>
    /// Check for the existence of a web site.
    /// </para>
    /// <para>
    /// The <checkWebSite> element names an IIS web site to be checked for existence on the target server.This check can be used in situations where the web site is created manually by Operations in advance of deployment. The webSiteName attribute can be a hard-coded web site name, or it can refer to the value of a user-input property by enclosing the property name in square brackets.You must have the IIS Common Files Windows Component installed on the Octopus controller machine to run checkWebsite.
    /// </para>
    /// </summary>
    public partial class CheckWebSite : global::schemas.microsoft.com.Octopus.Item2005.Item01.Service.Check, IXMetaData {
        
         public static explicit operator CheckWebSite(XElement xe) { return XTypedServices.ToXTypedElement<CheckWebSite>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        /// <summary>
        /// <para>
        /// Check for the existence of a web site.
        /// </para>
        /// <para>
        /// The <checkWebSite> element names an IIS web site to be checked for existence on the target server.This check can be used in situations where the web site is created manually by Operations in advance of deployment. The webSiteName attribute can be a hard-coded web site name, or it can refer to the value of a user-input property by enclosing the property name in square brackets.You must have the IIS Common Files Windows Component installed on the Octopus controller machine to run checkWebsite.
        /// </para>
        /// </summary>
        public CheckWebSite() {
        }
        
        /// <summary>
        /// <para>
        /// The name of the IIS web site to check for existence.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public string webSiteName {
            get {
                XAttribute x = this.Attribute(XName.Get("webSiteName", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("webSiteName", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("CheckWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<CheckWebSite>(this);
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    /// <summary>
    /// <para>
    /// The <commandCheck> element specifies a custom check implemented as an arbitrary command. Optional child elements specify status codes, input files, and output files for the command.
    /// </para>
    /// <para>
    /// Regular expression: (statusCodes? | inputFiles? | outputFiles?)*
    /// </para>
    /// </summary>
    public partial class CommandCheck : global::schemas.microsoft.com.Octopus.Item2005.Item01.Service.CommandType, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
        
         public static explicit operator CommandCheck(XElement xe) { return XTypedServices.ToXTypedElement<CommandCheck>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static CommandCheck() {
            BuildElementDictionary();
        }
        
        /// <summary>
        /// <para>
        /// The <commandCheck> element specifies a custom check implemented as an arbitrary command. Optional child elements specify status codes, input files, and output files for the command.
        /// </para>
        /// <para>
        /// Regular expression: (statusCodes? | inputFiles? | outputFiles?)*
        /// </para>
        /// </summary>
        public CommandCheck() {
        }
        
        /// <summary>
        /// <para>
        /// A help string to be displayed if the check fails.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public string help {
            get {
                XAttribute x = this.Attribute(XName.Get("help", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("help", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("CommandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<CommandCheck>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(XName.Get("statusCodes", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(StatusCodeList));
            localElementDictionary.Add(XName.Get("inputFiles", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(FileListType));
            localElementDictionary.Add(XName.Get("outputFiles", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(FileListType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    /// <summary>
    /// <para>
    /// Base type for a logical operation on a group of checks.
    /// </para>
    /// <para>
    /// Regular expression: (checkUser* | checkGroup* | checkGroupMembership* | checkDrive* | checkFile* | checkFolder* | checkValue* | checkRegistry* | checkService* | checkWebSite* | commandCheck* | not* | or* | and* | @true* | @false* | any)+
    /// </para>
    /// </summary>
    public partial class LogicalCheck : global::schemas.microsoft.com.Octopus.Item2005.Item01.Service.ChecksType, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static FSM validationStates;
        
         public static explicit operator LogicalCheck(XElement xe) { return XTypedServices.ToXTypedElement<LogicalCheck>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static LogicalCheck() {
            BuildElementDictionary();
            InitFSM();
        }
        
        /// <summary>
        /// <para>
        /// Base type for a logical operation on a group of checks.
        /// </para>
        /// <para>
        /// Regular expression: (checkUser* | checkGroup* | checkGroupMembership* | checkDrive* | checkFile* | checkFolder* | checkValue* | checkRegistry* | checkService* | checkWebSite* | commandCheck* | not* | or* | and* | @true* | @false* | any)+
        /// </para>
        /// </summary>
        public LogicalCheck() {
        }
        
        /// <summary>
        /// <para>
        /// A unique name used to identify this group of checks in the log files.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public string name {
            get {
                XAttribute x = this.Attribute(XName.Get("name", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("name", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// A help message displayed in the log files if this check fails.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public string help {
            get {
                XAttribute x = this.Attribute(XName.Get("help", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("help", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("LogicalCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<LogicalCheck>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(CheckUser));
            localElementDictionary.Add(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(CheckGroup));
            localElementDictionary.Add(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(CheckGroupMembership));
            localElementDictionary.Add(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(CheckDrive));
            localElementDictionary.Add(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(CheckFile));
            localElementDictionary.Add(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(CheckFolder));
            localElementDictionary.Add(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(CheckValue));
            localElementDictionary.Add(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(CheckRegistry));
            localElementDictionary.Add(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(CheckService));
            localElementDictionary.Add(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(CheckWebSite));
            localElementDictionary.Add(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(CommandCheck));
            localElementDictionary.Add(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(LogicalCheck));
            localElementDictionary.Add(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(LogicalCheck));
            localElementDictionary.Add(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(LogicalCheck));
            localElementDictionary.Add(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(XTypedElement));
            localElementDictionary.Add(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(XTypedElement));
        }
        
        FSM IXMetaData.GetValidationStates() {
            return validationStates;
        }
        
        private static void InitFSM() {
            Dictionary<int, Transitions> transitions = new Dictionary<int, Transitions>();
            transitions.Add(1, new Transitions(new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            transitions.Add(3, new Transitions(new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            transitions.Add(5, new Transitions(new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            transitions.Add(7, new Transitions(new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            transitions.Add(9, new Transitions(new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            transitions.Add(11, new Transitions(new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            transitions.Add(13, new Transitions(new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            transitions.Add(15, new Transitions(new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            transitions.Add(17, new Transitions(new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            transitions.Add(19, new Transitions(new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            transitions.Add(21, new Transitions(new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            transitions.Add(23, new Transitions(new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            transitions.Add(25, new Transitions(new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            transitions.Add(27, new Transitions(new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            transitions.Add(29, new Transitions(new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            transitions.Add(31, new Transitions(new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            transitions.Add(33, new Transitions(new SingleTransition(XName.Get("checkUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 1), new SingleTransition(XName.Get("checkGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 5), new SingleTransition(XName.Get("checkDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 7), new SingleTransition(XName.Get("checkFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 9), new SingleTransition(XName.Get("checkFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 11), new SingleTransition(XName.Get("checkValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 13), new SingleTransition(XName.Get("checkRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 15), new SingleTransition(XName.Get("checkService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 17), new SingleTransition(XName.Get("checkWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 19), new SingleTransition(XName.Get("commandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 21), new SingleTransition(XName.Get("not", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 23), new SingleTransition(XName.Get("or", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 25), new SingleTransition(XName.Get("and", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 27), new SingleTransition(XName.Get("true", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 29), new SingleTransition(XName.Get("false", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 31), new SingleTransition(new WildCard("##other", "http://schemas.microsoft.com/Octopus/2005/01/Service"), 33)));
            validationStates = new FSM(1, new Set<int>(new int[] {
                            1,
                            3,
                            5,
                            7,
                            9,
                            11,
                            13,
                            15,
                            17,
                            19,
                            21,
                            23,
                            25,
                            27,
                            29,
                            31,
                            33}), transitions);
        }
    }
    
    /// <summary>
    /// <para>
    /// Valid characters for property names.
    /// </para>
    /// </summary>
    public sealed class PropertyName {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(8)), null, 0, 0, null, null, 0, null, null, 0, new string[] {
                        "[A-Za-z0-9]([A-Za-z0-9_ .\\-]*[A-Za-z0-9])?"}, 0, XmlSchemaWhiteSpace.Preserve));
        
        private PropertyName() {
        }
    }
    
    /// <summary>
    /// <para>
    /// Valid characters for command names.
    /// </para>
    /// </summary>
    public sealed class CommandName {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(8)), null, 0, 0, null, null, 0, null, null, 0, new string[] {
                        "[A-Za-z0-9]([A-Za-z0-9_ .\\-]*[A-Za-z0-9])?"}, 0, XmlSchemaWhiteSpace.Preserve));
        
        private CommandName() {
        }
    }
    
    /// <summary>
    /// <para>
    /// Valid characters for release names.
    /// </para>
    /// </summary>
    public sealed class ReleaseName {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(8)), null, 0, 0, null, null, 0, null, null, 0, new string[] {
                        "[A-Za-z0-9]([A-Za-z0-9_ .\\-]*[A-Za-z0-9])?"}, 0, XmlSchemaWhiteSpace.Preserve));
        
        private ReleaseName() {
        }
    }
    
    /// <summary>
    /// <para>
    /// Regular expression: (passProperty*)*
    /// </para>
    /// </summary>
    public partial class RoleType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<PassPropertyType> passPropertyField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static string serversDefaultValue = "select";
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
        
         public static explicit operator RoleType(XElement xe) { return XTypedServices.ToXTypedElement<RoleType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static RoleType() {
            BuildElementDictionary();
        }
        
        /// <summary>
        /// <para>
        /// Regular expression: (passProperty*)*
        /// </para>
        /// </summary>
        public RoleType() {
        }
        
        /// <summary>
        /// <para>
        /// A property value to override a property defined in the referenced component.
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (passProperty*)*
        /// </para>
        /// </summary>
        public IList<PassPropertyType> passProperty {
            get {
                if ((this.passPropertyField == null)) {
                    this.passPropertyField = new XTypedList<PassPropertyType>(this, LinqToXsdTypeManager.Instance, XName.Get("passProperty", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                }
                return this.passPropertyField;
            }
            set {
                if ((value == null)) {
                    this.passPropertyField = null;
                }
                else {
                    if ((this.passPropertyField == null)) {
                        this.passPropertyField = XTypedList<PassPropertyType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("passProperty", "http://schemas.microsoft.com/Octopus/2005/01/Service"));
                    }
                    else {
                        XTypedServices.SetList<PassPropertyType>(this.passPropertyField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// The name of the component to expose as a role. There must be a corresponding <component> element with this name.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public string name {
            get {
                XAttribute x = this.Attribute(XName.Get("name", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("name", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// Indicates whether or not the role must be assigned to at least one server.
        /// </para>
        /// <para>
        /// 
        ///                        As of Octopus 4.0, the required attribute is deprecated.
        ///                        It has been superceded by the minServers attribute.
        ///                        Rather than required="false", it is now preferable to use minServers="0".
        ///                        You cannot use both 'required' and 'minServers' or 'maxServers'.
        ///                        
        ///                        Since the default for minServers is 1, the default is that the role is required.
        ///                        
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public System.Nullable<bool> required {
            get {
                XAttribute x = this.Attribute(XName.Get("required", ""));
                if ((x == null)) {
                    return null;
                }
                return XTypedServices.ParseValue<bool>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("required", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// A statement of the way this role is assigned to servers.
        /// </para>
        /// <para>
        /// The servers attribute may take any of the following values:allThe role will automatically be assigned to all servers in the topology.selectThe deployment operator must explicitly associate the role with one or more servers.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public string servers {
            get {
                XAttribute x = this.Attribute(XName.Get("servers", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, serversDefaultValue);
            }
            set {
                this.SetAttribute(XName.Get("servers", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The minimum number of servers that must be assigned this role. The default is 1.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public System.Nullable<decimal> minServers {
            get {
                XAttribute x = this.Attribute(XName.Get("minServers", ""));
                if ((x == null)) {
                    return null;
                }
                return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Integer).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("minServers", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Integer).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The maximum number of servers that may be assigned this role. The default is no maximum.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public System.Nullable<decimal> maxServers {
            get {
                XAttribute x = this.Attribute(XName.Get("maxServers", ""));
                if ((x == null)) {
                    return null;
                }
                return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Integer).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("maxServers", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Integer).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("RoleType", "http://schemas.microsoft.com/Octopus/2005/01/Service");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<RoleType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(XName.Get("passProperty", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(PassPropertyType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    public class LinqToXsdTypeManager : ILinqToXsdTypeManager {
        
        static Dictionary<XName, System.Type> typeDictionary = new Dictionary<XName, System.Type>();
        
        static Dictionary<XName, System.Type> elementDictionary = new Dictionary<XName, System.Type>();
        
        private static XmlSchemaSet schemaSet;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        static LinqToXsdTypeManager typeManagerSingleton = new LinqToXsdTypeManager();
        
        static LinqToXsdTypeManager() {
            BuildTypeDictionary();
            BuildElementDictionary();
        }
        
        XmlSchemaSet ILinqToXsdTypeManager.Schemas {
            get {
                if ((schemaSet == null)) {
                    XmlSchemaSet tempSet = new XmlSchemaSet();
                    System.Threading.Interlocked.CompareExchange(ref schemaSet, tempSet, null);
                }
                return schemaSet;
            }
            set {
                schemaSet = value;
            }
        }
        
        Dictionary<XName, System.Type> ILinqToXsdTypeManager.GlobalTypeDictionary {
            get {
                return typeDictionary;
            }
        }
        
        Dictionary<XName, System.Type> ILinqToXsdTypeManager.GlobalElementDictionary {
            get {
                return elementDictionary;
            }
        }
        
        Dictionary<System.Type, System.Type> ILinqToXsdTypeManager.RootContentTypeMapping {
            get {
                return XTypedServices.EmptyTypeMappingDictionary;
            }
        }
        
        public static LinqToXsdTypeManager Instance {
            get {
                return typeManagerSingleton;
            }
        }
        
        private static void BuildTypeDictionary() {
            typeDictionary.Add(XName.Get("DomainChecksType", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(global::schemas.microsoft.com.Octopus.Item2005.Item01.Service.DomainChecksType));
            typeDictionary.Add(XName.Get("PassPropertyType", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(global::schemas.microsoft.com.Octopus.Item2005.Item01.Service.PassPropertyType));
            typeDictionary.Add(XName.Get("PropertyType", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(global::schemas.microsoft.com.Octopus.Item2005.Item01.Service.PropertyType));
            typeDictionary.Add(XName.Get("AggregateComponentType", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(global::schemas.microsoft.com.Octopus.Item2005.Item01.Service.AggregateComponentType));
            typeDictionary.Add(XName.Get("CheckUser", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(global::schemas.microsoft.com.Octopus.Item2005.Item01.Service.CheckUser));
            typeDictionary.Add(XName.Get("CheckGroup", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(global::schemas.microsoft.com.Octopus.Item2005.Item01.Service.CheckGroup));
            typeDictionary.Add(XName.Get("CheckGroupMembership", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(global::schemas.microsoft.com.Octopus.Item2005.Item01.Service.CheckGroupMembership));
            typeDictionary.Add(XName.Get("StatusCodeList", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(global::schemas.microsoft.com.Octopus.Item2005.Item01.Service.StatusCodeList));
            typeDictionary.Add(XName.Get("CommandType", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(global::schemas.microsoft.com.Octopus.Item2005.Item01.Service.CommandType));
            typeDictionary.Add(XName.Get("FileListType", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(global::schemas.microsoft.com.Octopus.Item2005.Item01.Service.FileListType));
            typeDictionary.Add(XName.Get("FileType", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(global::schemas.microsoft.com.Octopus.Item2005.Item01.Service.FileType));
            typeDictionary.Add(XName.Get("ChecksType", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(global::schemas.microsoft.com.Octopus.Item2005.Item01.Service.ChecksType));
            typeDictionary.Add(XName.Get("Check", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(global::schemas.microsoft.com.Octopus.Item2005.Item01.Service.Check));
            typeDictionary.Add(XName.Get("CheckDrive", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(global::schemas.microsoft.com.Octopus.Item2005.Item01.Service.CheckDrive));
            typeDictionary.Add(XName.Get("CheckFile", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(global::schemas.microsoft.com.Octopus.Item2005.Item01.Service.CheckFile));
            typeDictionary.Add(XName.Get("CheckFolder", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(global::schemas.microsoft.com.Octopus.Item2005.Item01.Service.CheckFolder));
            typeDictionary.Add(XName.Get("CheckValue", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(global::schemas.microsoft.com.Octopus.Item2005.Item01.Service.CheckValue));
            typeDictionary.Add(XName.Get("CheckRegistry", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(global::schemas.microsoft.com.Octopus.Item2005.Item01.Service.CheckRegistry));
            typeDictionary.Add(XName.Get("CheckService", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(global::schemas.microsoft.com.Octopus.Item2005.Item01.Service.CheckService));
            typeDictionary.Add(XName.Get("CheckWebSite", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(global::schemas.microsoft.com.Octopus.Item2005.Item01.Service.CheckWebSite));
            typeDictionary.Add(XName.Get("CommandCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(global::schemas.microsoft.com.Octopus.Item2005.Item01.Service.CommandCheck));
            typeDictionary.Add(XName.Get("LogicalCheck", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(global::schemas.microsoft.com.Octopus.Item2005.Item01.Service.LogicalCheck));
            typeDictionary.Add(XName.Get("RoleType", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(global::schemas.microsoft.com.Octopus.Item2005.Item01.Service.RoleType));
        }
        
        private static void BuildElementDictionary() {
            elementDictionary.Add(XName.Get("service", "http://schemas.microsoft.com/Octopus/2005/01/Service"), typeof(global::schemas.microsoft.com.Octopus.Item2005.Item01.Service.service));
        }
        
        protected internal static void AddSchemas(XmlSchemaSet schemas) {
            schemas.Add(schemaSet);
        }
        
        public static System.Type GetRootType() {
            return elementDictionary[XName.Get("service", "http://schemas.microsoft.com/Octopus/2005/01/Service")];
        }
    }
    
    public partial class XRootNamespace {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XDocument doc;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedElement rootObject;
        

    public service service {  get {return rootObject as service; } }
        
        private XRootNamespace() {
        }
        
        public XRootNamespace(service root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        
        public XDocument XDocument {
            get {
                return doc;
            }
        }
        
        public static XRootNamespace Load(string xmlFile) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Load(xmlFile);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Load(string xmlFile, LoadOptions options) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Load(xmlFile, options);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Load(TextReader textReader) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Load(textReader);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Load(TextReader textReader, LoadOptions options) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Load(textReader, options);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Load(XmlReader xmlReader) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Load(xmlReader);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Parse(string text) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Parse(text);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Parse(string text, LoadOptions options) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Parse(text, options);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public virtual void Save(string fileName) {
            doc.Save(fileName);
        }
        
        public virtual void Save(TextWriter textWriter) {
            doc.Save(textWriter);
        }
        
        public virtual void Save(XmlWriter writer) {
            doc.Save(writer);
        }
        
        public virtual void Save(TextWriter textWriter, SaveOptions options) {
            doc.Save(textWriter, options);
        }
        
        public virtual void Save(string fileName, SaveOptions options) {
            doc.Save(fileName, options);
        }
    }
    
    public partial class XRoot {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XDocument doc;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedElement rootObject;
        

    public global::schemas.microsoft.com.Octopus.Item2005.Item01.Service.service service {  get {return rootObject as global::schemas.microsoft.com.Octopus.Item2005.Item01.Service.service; } }
        
        private XRoot() {
        }
        
        public XRoot(global::schemas.microsoft.com.Octopus.Item2005.Item01.Service.service root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        
        public XDocument XDocument {
            get {
                return doc;
            }
        }
        
        public static XRoot Load(string xmlFile) {
            XRoot root = new XRoot();
            root.doc = XDocument.Load(xmlFile);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRoot Load(string xmlFile, LoadOptions options) {
            XRoot root = new XRoot();
            root.doc = XDocument.Load(xmlFile, options);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRoot Load(TextReader textReader) {
            XRoot root = new XRoot();
            root.doc = XDocument.Load(textReader);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRoot Load(TextReader textReader, LoadOptions options) {
            XRoot root = new XRoot();
            root.doc = XDocument.Load(textReader, options);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRoot Load(XmlReader xmlReader) {
            XRoot root = new XRoot();
            root.doc = XDocument.Load(xmlReader);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRoot Parse(string text) {
            XRoot root = new XRoot();
            root.doc = XDocument.Parse(text);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRoot Parse(string text, LoadOptions options) {
            XRoot root = new XRoot();
            root.doc = XDocument.Parse(text, options);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public virtual void Save(string fileName) {
            doc.Save(fileName);
        }
        
        public virtual void Save(TextWriter textWriter) {
            doc.Save(textWriter);
        }
        
        public virtual void Save(XmlWriter writer) {
            doc.Save(writer);
        }
        
        public virtual void Save(TextWriter textWriter, SaveOptions options) {
            doc.Save(textWriter, options);
        }
        
        public virtual void Save(string fileName, SaveOptions options) {
            doc.Save(fileName, options);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\EndToEndTests\Octopus\CommandInfo.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using schemas.microsoft.com.Octopus.Item2005.Item01.Service;

namespace DeploymentLanguageTests.Octopus
{
    public class CommandInfo
    {

        CommandType _commandType;

        public CommandInfo(CommandType runCommand)
        {
            _commandType = runCommand;
        }


        public string Command
        {
            get
            {
                return _commandType.cmd;
            }
        }

        public Dictionary<string, string> InputFiles
        {
            get
            {
                return _commandType.inputFiles.SelectMany(x => x.file).ToDictionary( y => y.sourcePath, x => x.destinationPath);
            }
        }

        public Dictionary<string, string> OutputFiles
        {
            get
            {
                return _commandType.outputFiles.SelectMany(x => x.file).ToDictionary(y => y.sourcePath, x => x.destinationPath);
            }
        }

        public IEnumerable<StatusCodeList.statusCodeLocalType> StatusCodes
        {
            get
            {
                return _commandType.statusCodes.SelectMany(x => x.statusCode).ToList();
            }
        }

        public override bool Equals(object obj)
        {
            if (obj.GetType() != this.GetType())
            {
                return false;
            }
            CommandInfo info = obj as CommandInfo;

            return Command == info.Command && InputFiles == info.InputFiles &&
                OutputFiles == info.OutputFiles &&
                StatusCodes == info.StatusCodes;
        }

        public override int GetHashCode()
        {
            return Command.GetHashCode();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\EndToEndTests\Octopus\Lookup.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;

using System.Text.RegularExpressions;

using schemas.microsoft.com.Octopus.Item2005.Item01.Service;

namespace DeploymentLanguageTests.Octopus
{
    public class Lookup
    {

        private XRoot _document;

        public Lookup(XRoot document)
        {
            _document = document;

            foreach (var property in document.service.property)
            {
                AddGlobalProperty(property);
            }
            foreach (var xmlComponent in document.service.components.SelectMany(wrapper => wrapper.component))
            {
                Add(new Component(xmlComponent));
            }

            foreach (var xmlRole in document.service.topologies.SelectMany(t => t.topology[0].role))
            {
                Add(new Role(this, xmlRole));
            }

            foreach (Component component in GetComponents())
            {
                // make sure that the components can see global properties.
                component.Lookup = this;

                foreach (string @interface in component.RequiredInterfaces)
                {
                    foreach (Component dependency in GetComponentByInterface(@interface))
                    {
                        component.AddDependency(dependency);
                    }
                }
                foreach (string aggregatedComponentName in component.AggregatedComponentNames)
                {
                    component.AddChild(GetComponent(aggregatedComponentName));
                }

                if (GetRole(component.Name) != null)
                {
                    component.Role = GetRole(component.Name);
                }
            }
        }
        
        private Dictionary<string, Component> _componentNameLookup = new Dictionary<string,Component>();
        private Dictionary<string, HashSet<Component>> _componentInterfaceLookup = new Dictionary<string, HashSet<Component>>();
        private Dictionary<string, Role> _roleNameLookup = new Dictionary<string, Role>();
        private Dictionary<string, string> _globalProperties = new Dictionary<string, string>();

        public Dictionary<string, string> GlobalProperties
        {
            get
            {
                return new Dictionary<string, string>(_globalProperties);
            }
        }

        public Dictionary<string, string> NormalizedGlobalProperties
        {
            get
            {
                Dictionary<string, string> newValues = new Dictionary<string, string>(_globalProperties);
                foreach (var pair in _globalProperties)
                {
                    newValues.Replace(pair.Key, GetNormalizedPropertyValue(pair.Value, newValues, 0));
                }

                return newValues;
            }
        }

        public string ReleaseName
        {
            get
            {
                return _document.service.release;
            }
        }

        public void Add(Component component)
        {
            if (_componentNameLookup.ContainsKey(component.Name))
            {
                throw new InvalidOperationException(String.Format("Component {0} appears multiple times", component.Name));
            }

            _componentNameLookup.Add(component.Name, component);
            if (component.PublishedInterface != null)
            {
                if (_componentInterfaceLookup.ContainsKey(component.PublishedInterface))
                {
                    _componentInterfaceLookup[component.PublishedInterface].Add(component);
                }
                else
                {
                    _componentInterfaceLookup.Add(component.PublishedInterface, new HashSet<Component>( new Component[] { component }));
                }
            }
        }

        public void Add(Role role)
        {
            if (_roleNameLookup.ContainsKey(role.Name))
            {
                throw new InvalidOperationException(String.Format("Role {0} appears multiple times", role.Name));
            }

            _roleNameLookup.Add(role.Name, role);
        }

        public void AddGlobalProperty(PropertyType type)
        {
            if (type.userInput != null)
            {
                AddGlobalProperty(type.name, "|" + type.name + "|");
            }
            else
            {
                AddGlobalProperty(type.name, type.value);
            }
        }

        public void AddGlobalProperty(string name, string value)
        {
            value = value ?? "";
            _globalProperties.Add(name, value);
        }

        public Role GetRole(string name)
        {
            Role returnVal;
            _roleNameLookup.TryGetValue(name, out returnVal);
            return returnVal;
        }

        public IEnumerable<Role> GetRoles()
        {
            return _roleNameLookup.Values;
        }

        public IEnumerable<Component> GetComponents()
        {
            return _componentNameLookup.Values;
        }

        public Component GetComponent(string name)
        {
            Component returnValue;
            _componentNameLookup.TryGetValue(name, out returnValue);
            return returnValue;
        }

        public IEnumerable<Component> GetComponentByInterface(string name)
        {
            HashSet<Component> returnValue;
            _componentInterfaceLookup.TryGetValue(name, out returnValue);
            if (returnValue == null)
            {
                returnValue = new HashSet<Component>();
            }
            return returnValue;
        }

        private string GetNormalizedPropertyValue(string valueString, Dictionary<string, string> properties, int recursionCount)
        {
            if (recursionCount > 20)
            {
                throw new ApplicationException(String.Format("Global Service has an infinite property evaluation loop involving: {0}",
                    valueString));
            }

            StringBuilder plainString = new StringBuilder();
            string[] pieces = Regex.Split(valueString, "\\[([^]]*)\\]");
            for (int index = 0; index < pieces.Length; index++)
            {
                if (index % 2 == 0)
                {
                    plainString.Append(pieces[index]);
                }
                else
                {
                    if (!properties.ContainsKey(pieces[index]))
                    {
                       throw new ApplicationException(String.Format("A property in global service referred to a non-existent property called {0}",
                            pieces[index]));
                    }
                    string value = null;

                    if (properties.ContainsKey(pieces[index]))
                    {
                        value = GetNormalizedPropertyValue(properties[pieces[index]], properties, recursionCount + 1);
                    }

                    if (value == null)
                    {
                        throw new ApplicationException(String.Format("Couldn't find property {0} in global service",
                        pieces[index]));
                    }

                    if (value.Contains('[') || value.Contains(']'))
                    {
                        throw new ApplicationException(String.Format("Property {0} from global service contains a [ or ] as normal character illegally",
                        pieces[index]));
                    }

                    plainString.Append(properties[pieces[index]]);
                }
            }

            return plainString.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\EndToEndTests\Octopus\Role.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using schemas.microsoft.com.Octopus.Item2005.Item01.Service;

namespace DeploymentLanguageTests.Octopus
{
    public class Role
    {
        public Role(Lookup lookup, RoleType role)
        {
            _role = role;
            Lookup = lookup;
        }

        public Lookup Lookup
        {
            get;
            private set;
        }

        public string Name
        {
            get 
            { 
                return _role.name;
            }
        }

        public decimal? MinServers
        {
            get
            {
                return _role.minServers;
            }
        }

        public decimal? MaxServers
        {
            get
            {
                return _role.maxServers;
            }
        }

        public bool AllServers
        {
            get
            {
                return _role.servers != null && _role.servers == "all";
            }
        }

        private RoleType _role;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\EndToEndTests\TestInfrastructure\TopLevelTestNode.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Reflection;
using System.IO;

using ServerTestFramework;

namespace DeploymentLanguageTests.TestInfrastructure
{
    [TestGroup]
    public class TopLevelTestNode : TestNode
    {
        public TopLevelTestNode()
        {
            Name = "Deployment Language";
            string testCasePath = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location),
                                               "Tests");
            TestNode node = new DynamicTestNode(new DirectoryInfo(testCasePath), x => new ValidatingTestNode(x));
            node.Name = "tests2";
            AddChild(node, true, false);
        }

        public class DynamicTestNode : TestNode
        {
            public DynamicTestNode(DirectoryInfo folderInfo, Func<DirectoryInfo, TestNode> creationDelegate)
            {
                Name = folderInfo.Name;
                foreach (DirectoryInfo subDirectoryInfo in folderInfo.GetDirectories().Where(x=>x.GetFiles().Length == 0 && x.GetDirectories().Length != 0))
                {
                    DynamicTestNode testNode = new DynamicTestNode(subDirectoryInfo, creationDelegate);
                    AddChild(testNode, true, false);
                }

                foreach (DirectoryInfo subDirectoryInfo in folderInfo.GetDirectories().Where(x => x.GetFiles().Length != 0))
                {
                    TestNode testNode = creationDelegate(subDirectoryInfo);
                    AddChild(testNode, true, false);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\EndToEndTests\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("DeploymentLanguageTests")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("DeploymentLanguageTests")]
[assembly: AssemblyCopyright("Copyright © Microsoft 2010")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("f1222fa9-abb9-4513-becb-d0afa9155d14")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\EndToEndTests\Octopus\Component.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;

using schemas.microsoft.com.Octopus.Item2005.Item01.Service;
using System.Diagnostics;

namespace DeploymentLanguageTests.Octopus
{
    public class Component
    {
        public Component(service.componentsLocalType.componentLocalType component)
        {
            _component = component;

            foreach (var property in _component.property)
            {
                AddProperty(property);
            }
        }

        public string Name
        {
            get { return _component.name; }
        }

        public service.componentsLocalType.componentLocalType Element
        {
            get { return _component; }
        }

        public string PublishedInterface
        {
            get { return _component.publishInterface.Select(x => x.name).FirstOrDefault(); }
        }

        public IEnumerable<string> RequiredInterfaces
        {
            get { return _component.requireInterface.Select(x => x.name).ToArray(); }
        }


        public IEnumerable<Component> Children
        {
            get
            {
                return _children.AsReadOnly();
            }
        }

        public IEnumerable<string> AggregatedComponentNames
        {
            get
            {
                return _component.aggregateComponent.Select(x => x.name).ToList();
            }
        }

        public IEnumerable<Component> Parents
        {
            get
            {
                return _parents.AsReadOnly();
            }
        }

        public IEnumerable<Component> Dependents
        {
            get
            {
                return _dependents.AsReadOnly();
            }
        }

        public IEnumerable<Component> Dependencies
        {
            get
            {
                return _dependencies.AsReadOnly();
            }
        }

        private IEnumerable<Component> CummulativeDependencies
        {
            get
            {
                return Parents.SelectMany(x => x.CummulativeDependencies).Union(Dependencies).ToList();
            }
        }

        public IEnumerable<Component> RealDependencies
        {
            get 
            {
                return CummulativeDependencies.Union(Children).ToList();
            }
        }

        public Role Role
        {
            get;
            set;
        }

        public Lookup Lookup
        {
            get;
            set;
        }

        public Dictionary<string, string> PassedPropertiesForChild(Component component)
        {
            return new Dictionary<string, string>(
                _component.aggregateComponent
                .Where(x => x.name == component.Name)
                .SelectMany(x => x.passProperty)
                .ToDictionary(x=>x.name, x=>x.value));
        }

        public Dictionary<string, string> Properties
        {
            get
            {
                return new Dictionary<string, string>(_properties);
            }
        }

        public IEnumerable<Component> Descendants
        {
            get
            {
                return Children.SelectMany(x=>x.Descendants).Union(Children).ToList();
            }
        }


        public Dictionary<string, string> NormalizedProperties
        {
            get
            {
                Dictionary<string, string> properties = Properties;
                if (Parents.Count() > 0) {
                    Component parent = Parents.First();
                    properties.Merge(parent.PassedPropertiesForChild(this).Replace((dict, key) => GetNormalizedPropertyValue(dict[key], parent.NormalizedProperties, 0)));
                }

                Dictionary<string, string> updatedProperties = new Dictionary<string,string>(properties);
                foreach (var pair in properties)
                {
                    updatedProperties.Replace(pair.Key, GetNormalizedPropertyValue(pair.Value, updatedProperties, 0));
                }
                return updatedProperties;
            }
        }

        public IEnumerable<Component> OrderedComponents
        {
            get
            {
                Dictionary<Component, int> distanceTable = new Dictionary<Component, int>();
                distanceTable.Add(this, 0);
                GetOrderedComponents(distanceTable, 1);
                return distanceTable.OrderByDescending(x => x.Value).Select(x => x.Key).ToList();
            }
        }

        public MsiInfo MsiInfo
        {
            get
            {
                MsiInfo info = null;
                if (_component.msi.Count > 0)
                {
                    info = new MsiInfo(_component.msi[0]);
                }
                return info;
            }
        }

        public CommandInfo InstallCommandInfo
        {
            get
            {
                CommandInfo info = null;
                if (_component.installCommand.Count > 0)
                {
                    info = new CommandInfo(_component.installCommand[0]);
                }
                return info;
            }
        }

        public CommandInfo UninstallCommandInfo
        {
            get
            {
                CommandInfo info = null;
                if (_component.uninstallCommand.Count > 0)
                {
                    info = new CommandInfo(_component.uninstallCommand[0]);
                }
                return info;
            }
        }

        public bool RebootsOnInstall
        {
            get
            {
                var rebootElement = _component.reboot.FirstOrDefault();
                return (rebootElement != null && rebootElement.onInstall);
            }
        }

        public bool RebootsOnUninstall
        {
            get
            {
                var rebootElement = _component.reboot.FirstOrDefault();
                return (rebootElement != null && rebootElement.onUninstall);
            }
        }

        private void GetOrderedComponents(Dictionary<Component, int> distanceTable, int distance)
        {
            if (distanceTable.ContainsKey(this))
            {
                if (distanceTable[this] < distance)
                {
                    distanceTable[this] = distance;
                }
            }
            else
            {
                distanceTable.Add(this, distance);
            }
            foreach (var child in Children)
            {
                child.GetOrderedComponents(distanceTable, distance + 1);
            }
        }

        private string GetNormalizedPropertyValue(string valueString, Dictionary<string, string> properties, int recursionCount)
        {
            if (recursionCount > 20)
            {
                throw new Exception(String.Format("Component {0} has an infinite property evaluation loop involving: {1}",
                    Name, valueString));
            }

            StringBuilder plainString = new StringBuilder();
            string[] pieces = Regex.Split(valueString, "\\[([^]]*)\\]");
            for (int index = 0; index < pieces.Length; index++)
            {
                if (index % 2 == 0)
                {
                    plainString.Append(pieces[index]);
                }
                else
                {
                    string value = null;
                    if (Lookup.NormalizedGlobalProperties.ContainsKey(pieces[index]))
                    {
                        value = Lookup.NormalizedGlobalProperties[pieces[index]];
                    }
                    else if (properties.ContainsKey(pieces[index]))
                    {
                        value = GetNormalizedPropertyValue(properties[pieces[index]], properties, recursionCount + 1);
                    }

                    //Debug.Assert(value != null, "Couldn't find property {0} in component {1}",
                    //    pieces[index], Name);
                    //Debug.Assert(!value.Contains('[') && !value.Contains(']'), "Property {0} from component {1} contains a [ or ] as normal character illegally",
                    //    pieces[index], Name);

                    plainString.Append(value);
                }
            }

            return plainString.ToString();
        }

        public IEnumerable<Role> TopLevelRoles
        {
            get
            {
                IEnumerable<Role> roles = Parents.SelectMany(x => x.TopLevelRoles);
                if (Role != null)
                {
                    roles = roles.Union( new Role[] { Role });
                }

                return roles;
            }
        }

        public void AddChild(Component component)
        {
            _children.Add(component);
            component._parents.Add(this);
        }

        public void AddDependency(Component dependency)
        {
            _dependencies.Add(dependency);
            dependency._dependents.Add(this);
        }

        public void AddProperty(PropertyType type)
        {
            if (type.userInput != null)
            {
                AddProperty(type.name, "|" + type.name + "|");
            }
            else
            {
                AddProperty(type.name, type.value);
            }
        }

        public void AddProperty(string name, string value)
        {
            value = value ?? "";
            _properties.Add(name, value);
        }
        public override string ToString()
        {
            return Name;
        }

        private List<Component> _children = new List<Component>();
        private List<Component> _parents = new List<Component>();
        private List<Component> _dependencies = new List<Component>();
        private List<Component> _dependents = new List<Component>();
        private Dictionary<string, string> _properties = new Dictionary<string, string>();

        private service.componentsLocalType.componentLocalType _component;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\EndToEndTests\Octopus\MsiInfo.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using schemas.microsoft.com.Octopus.Item2005.Item01.Service;

using MsiType = schemas.microsoft.com.Octopus.Item2005.Item01.Service.service.componentsLocalType.componentLocalType.msiLocalType;
namespace DeploymentLanguageTests.Octopus
{
    public class MsiInfo
    {
        MsiType _msiType;
        public MsiInfo(service.componentsLocalType.componentLocalType.msiLocalType msiNode)
        {
            _msiType = msiNode;
        }

        public bool PassesPropertiesOnUninstall
        {
            get 
            {
                return _msiType.passPropertiesOnUninstall ?? false;
            }
        }

        public string Path
        {
            get
            {
                return _msiType.path;
            }
        }

        public Dictionary<string, string> Properties
        {
            get
            {
                return _msiType.property.ToDictionary(x => x.name, x => x.value);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\EndToEndTests\deploymentlanguage.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace www.xboxlive.com.Deployment.Language.XMLSchema.xsd {
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.IO;
    using System.Diagnostics;
    using System.Xml;
    using System.Xml.Schema;
    using System.Xml.Linq;
    using Xml.Schema.Linq;
    
    
    /// <summary>
    /// <para>
    /// Regular expression: (release*)
    /// </para>
    /// </summary>
    public partial class releases : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<releaseLocalType> releaseField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
         public static explicit operator releases(XElement xe) { return XTypedServices.ToXTypedElement<releases>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static releases() {
            BuildElementDictionary();
            contentModel = new ChoiceContentModelEntity(new NamedContentModelEntity(XName.Get("release", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd")));
        }
        
        /// <summary>
        /// <para>
        /// Regular expression: (release*)
        /// </para>
        /// </summary>
        public releases() {
        }
        
        public releases(IEnumerable<releaseLocalType> release) {
            this.releaseField = XTypedList<releaseLocalType>.Initialize(this, LinqToXsdTypeManager.Instance, release, XName.Get("release", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (release*)
        /// </para>
        /// </summary>
        public IList<www.xboxlive.com.Deployment.Language.XMLSchema.xsd.releases.releaseLocalType> release {
            get {
                if ((this.releaseField == null)) {
                    this.releaseField = new XTypedList<releaseLocalType>(this, LinqToXsdTypeManager.Instance, XName.Get("release", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                }
                return this.releaseField;
            }
            set {
                if ((value == null)) {
                    this.releaseField = null;
                }
                else {
                    if ((this.releaseField == null)) {
                        this.releaseField = XTypedList<releaseLocalType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("release", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    else {
                        XTypedServices.SetList<releaseLocalType>(this.releaseField, value);
                    }
                }
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("releases", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public void Save(string xmlFile) {
            XTypedServices.Save(xmlFile, Untyped);
        }
        
        public void Save(System.IO.TextWriter tw) {
            XTypedServices.Save(tw, Untyped);
        }
        
        public void Save(System.Xml.XmlWriter xmlWriter) {
            XTypedServices.Save(xmlWriter, Untyped);
        }
        
        public static releases Load(string xmlFile) {
            return XTypedServices.Load<releases>(xmlFile);
        }
        
        public static releases Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<releases>(xmlFile);
        }
        
        public static releases Parse(string xml) {
            return XTypedServices.Parse<releases>(xml);
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<releases>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(XName.Get("release", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(releaseLocalType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
        
        /// <summary>
        /// <para>
        /// Regular expression: (componentRef+)
        /// </para>
        /// </summary>
        public partial class releaseLocalType : XTypedElement, IXMetaData {
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<ComponentRefType> componentRefField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private static ContentModelEntity contentModel;
            
         public static explicit operator releaseLocalType(XElement xe) { return XTypedServices.ToXTypedElement<releaseLocalType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
            
            static releaseLocalType() {
                BuildElementDictionary();
                contentModel = new ChoiceContentModelEntity(new NamedContentModelEntity(XName.Get("componentRef", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd")));
            }
            
            /// <summary>
            /// <para>
            /// Regular expression: (componentRef+)
            /// </para>
            /// </summary>
            public releaseLocalType() {
            }
            
            public releaseLocalType(IEnumerable<ComponentRefType> componentRef) {
                this.componentRefField = XTypedList<ComponentRefType>.Initialize(this, LinqToXsdTypeManager.Instance, componentRef, XName.Get("componentRef", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: required, repeating, choice
            /// </para>
            /// <para>
            /// Regular expression: (componentRef+)
            /// </para>
            /// </summary>
            public IList<ComponentRefType> componentRef {
                get {
                    if ((this.componentRefField == null)) {
                        this.componentRefField = new XTypedList<ComponentRefType>(this, LinqToXsdTypeManager.Instance, XName.Get("componentRef", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    return this.componentRefField;
                }
                set {
                    if ((value == null)) {
                        this.componentRefField = null;
                    }
                    else {
                        if ((this.componentRefField == null)) {
                            this.componentRefField = XTypedList<ComponentRefType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("componentRef", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                        }
                        else {
                            XTypedServices.SetList<ComponentRefType>(this.componentRefField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: required
            /// </para>
            /// </summary>
            public string name {
                get {
                    XAttribute x = this.Attribute(XName.Get("name", ""));
                    return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
                set {
                    this.SetAttribute(XName.Get("name", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
                get {
                    return localElementDictionary;
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            XName IXMetaData.SchemaName {
                get {
                    return XName.Get("release", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            SchemaOrigin IXMetaData.TypeOrigin {
                get {
                    return SchemaOrigin.Fragment;
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            ILinqToXsdTypeManager IXMetaData.TypeManager {
                get {
                    return LinqToXsdTypeManager.Instance;
                }
            }
            
            public override XTypedElement Clone() {
                return XTypedServices.CloneXTypedElement<releaseLocalType>(this);
            }
            
            private static void BuildElementDictionary() {
                localElementDictionary.Add(XName.Get("componentRef", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(ComponentRefType));
            }
            
            ContentModelEntity IXMetaData.GetContentModel() {
                return contentModel;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Regular expression: (property*)
    /// </para>
    /// </summary>
    public partial class properties : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<PropertyType> propertyField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
         public static explicit operator properties(XElement xe) { return XTypedServices.ToXTypedElement<properties>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static properties() {
            BuildElementDictionary();
            contentModel = new ChoiceContentModelEntity(new NamedContentModelEntity(XName.Get("property", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd")));
        }
        
        /// <summary>
        /// <para>
        /// Regular expression: (property*)
        /// </para>
        /// </summary>
        public properties() {
        }
        
        public properties(IEnumerable<PropertyType> property) {
            this.propertyField = XTypedList<PropertyType>.Initialize(this, LinqToXsdTypeManager.Instance, property, XName.Get("property", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
        }
        
        /// <summary>
        /// <para>
        /// A "global" property to which multiple topologies and components defined within the service may refer.
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (property*)
        /// </para>
        /// </summary>
        public IList<PropertyType> property {
            get {
                if ((this.propertyField == null)) {
                    this.propertyField = new XTypedList<PropertyType>(this, LinqToXsdTypeManager.Instance, XName.Get("property", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                }
                return this.propertyField;
            }
            set {
                if ((value == null)) {
                    this.propertyField = null;
                }
                else {
                    if ((this.propertyField == null)) {
                        this.propertyField = XTypedList<PropertyType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("property", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    else {
                        XTypedServices.SetList<PropertyType>(this.propertyField, value);
                    }
                }
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("properties", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public void Save(string xmlFile) {
            XTypedServices.Save(xmlFile, Untyped);
        }
        
        public void Save(System.IO.TextWriter tw) {
            XTypedServices.Save(tw, Untyped);
        }
        
        public void Save(System.Xml.XmlWriter xmlWriter) {
            XTypedServices.Save(xmlWriter, Untyped);
        }
        
        public static properties Load(string xmlFile) {
            return XTypedServices.Load<properties>(xmlFile);
        }
        
        public static properties Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<properties>(xmlFile);
        }
        
        public static properties Parse(string xml) {
            return XTypedServices.Parse<properties>(xml);
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<properties>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(XName.Get("property", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(PropertyType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// Regular expression: (component+)
    /// </para>
    /// </summary>
    public partial class components : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<componentLocalType> componentField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
         public static explicit operator components(XElement xe) { return XTypedServices.ToXTypedElement<components>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static components() {
            BuildElementDictionary();
            contentModel = new ChoiceContentModelEntity(new NamedContentModelEntity(XName.Get("component", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd")));
        }
        
        /// <summary>
        /// <para>
        /// Regular expression: (component+)
        /// </para>
        /// </summary>
        public components() {
        }
        
        public components(IEnumerable<componentLocalType> component) {
            this.componentField = XTypedList<componentLocalType>.Initialize(this, LinqToXsdTypeManager.Instance, component, XName.Get("component", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (component+)
        /// </para>
        /// </summary>
        public IList<www.xboxlive.com.Deployment.Language.XMLSchema.xsd.components.componentLocalType> component {
            get {
                if ((this.componentField == null)) {
                    this.componentField = new XTypedList<componentLocalType>(this, LinqToXsdTypeManager.Instance, XName.Get("component", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                }
                return this.componentField;
            }
            set {
                if ((value == null)) {
                    this.componentField = null;
                }
                else {
                    if ((this.componentField == null)) {
                        this.componentField = XTypedList<componentLocalType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("component", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    else {
                        XTypedServices.SetList<componentLocalType>(this.componentField, value);
                    }
                }
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("components", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public void Save(string xmlFile) {
            XTypedServices.Save(xmlFile, Untyped);
        }
        
        public void Save(System.IO.TextWriter tw) {
            XTypedServices.Save(tw, Untyped);
        }
        
        public void Save(System.Xml.XmlWriter xmlWriter) {
            XTypedServices.Save(xmlWriter, Untyped);
        }
        
        public static components Load(string xmlFile) {
            return XTypedServices.Load<components>(xmlFile);
        }
        
        public static components Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<components>(xmlFile);
        }
        
        public static components Parse(string xml) {
            return XTypedServices.Parse<components>(xml);
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<components>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(XName.Get("component", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(componentLocalType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
        
        /// <summary>
        /// <para>
        /// Regular expression: (property* | prerequisiteChecks? | postdeploymentChecks? | dependsOn* | install* | runCommand* | runMsi*)*
        /// </para>
        /// </summary>
        public partial class componentLocalType : XTypedElement, IXMetaData {
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<PropertyType> propertyField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<ChecksType> prerequisiteChecksField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<ChecksType> postdeploymentChecksField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<DependsOnType> dependsOnField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<InstallType> installField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<RunCommandType> runCommandField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<RunMsiType> runMsiField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
            
         public static explicit operator componentLocalType(XElement xe) { return XTypedServices.ToXTypedElement<componentLocalType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
            
            static componentLocalType() {
                BuildElementDictionary();
            }
            
            /// <summary>
            /// <para>
            /// Regular expression: (property* | prerequisiteChecks? | postdeploymentChecks? | dependsOn* | install* | runCommand* | runMsi*)*
            /// </para>
            /// </summary>
            public componentLocalType() {
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: optional, repeating, choice
            /// </para>
            /// <para>
            /// Regular expression: (property* | prerequisiteChecks? | postdeploymentChecks? | dependsOn* | install* | runCommand* | runMsi*)*
            /// </para>
            /// </summary>
            public IList<PropertyType> property {
                get {
                    if ((this.propertyField == null)) {
                        this.propertyField = new XTypedList<PropertyType>(this, LinqToXsdTypeManager.Instance, XName.Get("property", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    return this.propertyField;
                }
                set {
                    if ((value == null)) {
                        this.propertyField = null;
                    }
                    else {
                        if ((this.propertyField == null)) {
                            this.propertyField = XTypedList<PropertyType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("property", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                        }
                        else {
                            XTypedServices.SetList<PropertyType>(this.propertyField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: optional, choice
            /// </para>
            /// <para>
            /// Regular expression: (property* | prerequisiteChecks? | postdeploymentChecks? | dependsOn* | install* | runCommand* | runMsi*)*
            /// </para>
            /// </summary>
            public IList<ChecksType> prerequisiteChecks {
                get {
                    if ((this.prerequisiteChecksField == null)) {
                        this.prerequisiteChecksField = new XTypedList<ChecksType>(this, LinqToXsdTypeManager.Instance, XName.Get("prerequisiteChecks", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    return this.prerequisiteChecksField;
                }
                set {
                    if ((value == null)) {
                        this.prerequisiteChecksField = null;
                    }
                    else {
                        if ((this.prerequisiteChecksField == null)) {
                            this.prerequisiteChecksField = XTypedList<ChecksType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("prerequisiteChecks", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                        }
                        else {
                            XTypedServices.SetList<ChecksType>(this.prerequisiteChecksField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: optional, choice
            /// </para>
            /// <para>
            /// Regular expression: (property* | prerequisiteChecks? | postdeploymentChecks? | dependsOn* | install* | runCommand* | runMsi*)*
            /// </para>
            /// </summary>
            public IList<ChecksType> postdeploymentChecks {
                get {
                    if ((this.postdeploymentChecksField == null)) {
                        this.postdeploymentChecksField = new XTypedList<ChecksType>(this, LinqToXsdTypeManager.Instance, XName.Get("postdeploymentChecks", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    return this.postdeploymentChecksField;
                }
                set {
                    if ((value == null)) {
                        this.postdeploymentChecksField = null;
                    }
                    else {
                        if ((this.postdeploymentChecksField == null)) {
                            this.postdeploymentChecksField = XTypedList<ChecksType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("postdeploymentChecks", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                        }
                        else {
                            XTypedServices.SetList<ChecksType>(this.postdeploymentChecksField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: optional, repeating, choice
            /// </para>
            /// <para>
            /// Regular expression: (property* | prerequisiteChecks? | postdeploymentChecks? | dependsOn* | install* | runCommand* | runMsi*)*
            /// </para>
            /// </summary>
            public IList<DependsOnType> dependsOn {
                get {
                    if ((this.dependsOnField == null)) {
                        this.dependsOnField = new XTypedList<DependsOnType>(this, LinqToXsdTypeManager.Instance, XName.Get("dependsOn", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    return this.dependsOnField;
                }
                set {
                    if ((value == null)) {
                        this.dependsOnField = null;
                    }
                    else {
                        if ((this.dependsOnField == null)) {
                            this.dependsOnField = XTypedList<DependsOnType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("dependsOn", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                        }
                        else {
                            XTypedServices.SetList<DependsOnType>(this.dependsOnField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: optional, repeating, choice
            /// </para>
            /// <para>
            /// Regular expression: (property* | prerequisiteChecks? | postdeploymentChecks? | dependsOn* | install* | runCommand* | runMsi*)*
            /// </para>
            /// </summary>
            public IList<InstallType> install {
                get {
                    if ((this.installField == null)) {
                        this.installField = new XTypedList<InstallType>(this, LinqToXsdTypeManager.Instance, XName.Get("install", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    return this.installField;
                }
                set {
                    if ((value == null)) {
                        this.installField = null;
                    }
                    else {
                        if ((this.installField == null)) {
                            this.installField = XTypedList<InstallType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("install", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                        }
                        else {
                            XTypedServices.SetList<InstallType>(this.installField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: optional, repeating, choice
            /// </para>
            /// <para>
            /// Regular expression: (property* | prerequisiteChecks? | postdeploymentChecks? | dependsOn* | install* | runCommand* | runMsi*)*
            /// </para>
            /// </summary>
            public IList<RunCommandType> runCommand {
                get {
                    if ((this.runCommandField == null)) {
                        this.runCommandField = new XTypedList<RunCommandType>(this, LinqToXsdTypeManager.Instance, XName.Get("runCommand", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    return this.runCommandField;
                }
                set {
                    if ((value == null)) {
                        this.runCommandField = null;
                    }
                    else {
                        if ((this.runCommandField == null)) {
                            this.runCommandField = XTypedList<RunCommandType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("runCommand", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                        }
                        else {
                            XTypedServices.SetList<RunCommandType>(this.runCommandField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: optional, repeating, choice
            /// </para>
            /// <para>
            /// Regular expression: (property* | prerequisiteChecks? | postdeploymentChecks? | dependsOn* | install* | runCommand* | runMsi*)*
            /// </para>
            /// </summary>
            public IList<RunMsiType> runMsi {
                get {
                    if ((this.runMsiField == null)) {
                        this.runMsiField = new XTypedList<RunMsiType>(this, LinqToXsdTypeManager.Instance, XName.Get("runMsi", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    return this.runMsiField;
                }
                set {
                    if ((value == null)) {
                        this.runMsiField = null;
                    }
                    else {
                        if ((this.runMsiField == null)) {
                            this.runMsiField = XTypedList<RunMsiType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("runMsi", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                        }
                        else {
                            XTypedServices.SetList<RunMsiType>(this.runMsiField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: required
            /// </para>
            /// </summary>
            public string name {
                get {
                    XAttribute x = this.Attribute(XName.Get("name", ""));
                    return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
                set {
                    this.SetAttribute(XName.Get("name", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: optional
            /// </para>
            /// </summary>
            public System.Nullable<decimal> minServers {
                get {
                    XAttribute x = this.Attribute(XName.Get("minServers", ""));
                    if ((x == null)) {
                        return null;
                    }
                    return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
                }
                set {
                    this.SetAttribute(XName.Get("minServers", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: optional
            /// </para>
            /// </summary>
            public System.Nullable<decimal> maxServers {
                get {
                    XAttribute x = this.Attribute(XName.Get("maxServers", ""));
                    if ((x == null)) {
                        return null;
                    }
                    return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
                }
                set {
                    this.SetAttribute(XName.Get("maxServers", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: optional
            /// </para>
            /// </summary>
            public string servers {
                get {
                    XAttribute x = this.Attribute(XName.Get("servers", ""));
                    return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
                set {
                    this.SetAttribute(XName.Get("servers", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: optional
            /// </para>
            /// </summary>
            public string deploymentPhase {
                get {
                    XAttribute x = this.Attribute(XName.Get("deploymentPhase", ""));
                    return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
                set {
                    this.SetAttribute(XName.Get("deploymentPhase", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: optional
            /// </para>
            /// </summary>
            public System.Nullable<bool> dependedByAllComponents {
                get {
                    XAttribute x = this.Attribute(XName.Get("dependedByAllComponents", ""));
                    if ((x == null)) {
                        return null;
                    }
                    return XTypedServices.ParseValue<bool>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean).Datatype);
                }
                set {
                    this.SetAttribute(XName.Get("dependedByAllComponents", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean).Datatype);
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: optional
            /// </para>
            /// </summary>
            public System.Nullable<bool> dependsOnAllComponents {
                get {
                    XAttribute x = this.Attribute(XName.Get("dependsOnAllComponents", ""));
                    if ((x == null)) {
                        return null;
                    }
                    return XTypedServices.ParseValue<bool>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean).Datatype);
                }
                set {
                    this.SetAttribute(XName.Get("dependsOnAllComponents", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean).Datatype);
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
                get {
                    return localElementDictionary;
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            XName IXMetaData.SchemaName {
                get {
                    return XName.Get("component", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            SchemaOrigin IXMetaData.TypeOrigin {
                get {
                    return SchemaOrigin.Fragment;
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            ILinqToXsdTypeManager IXMetaData.TypeManager {
                get {
                    return LinqToXsdTypeManager.Instance;
                }
            }
            
            public override XTypedElement Clone() {
                return XTypedServices.CloneXTypedElement<componentLocalType>(this);
            }
            
            private static void BuildElementDictionary() {
                localElementDictionary.Add(XName.Get("property", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(PropertyType));
                localElementDictionary.Add(XName.Get("prerequisiteChecks", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(ChecksType));
                localElementDictionary.Add(XName.Get("postdeploymentChecks", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(ChecksType));
                localElementDictionary.Add(XName.Get("dependsOn", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(DependsOnType));
                localElementDictionary.Add(XName.Get("install", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(InstallType));
                localElementDictionary.Add(XName.Get("runCommand", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(RunCommandType));
                localElementDictionary.Add(XName.Get("runMsi", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(RunMsiType));
            }
            
            ContentModelEntity IXMetaData.GetContentModel() {
                return ContentModelEntity.Default;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Regular expression: (deploymentPhase+)
    /// </para>
    /// </summary>
    public partial class deploymentPhases : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<deploymentPhaseLocalType> deploymentPhaseField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
         public static explicit operator deploymentPhases(XElement xe) { return XTypedServices.ToXTypedElement<deploymentPhases>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static deploymentPhases() {
            BuildElementDictionary();
            contentModel = new ChoiceContentModelEntity(new NamedContentModelEntity(XName.Get("deploymentPhase", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd")));
        }
        
        /// <summary>
        /// <para>
        /// Regular expression: (deploymentPhase+)
        /// </para>
        /// </summary>
        public deploymentPhases() {
        }
        
        public deploymentPhases(IEnumerable<deploymentPhaseLocalType> deploymentPhase) {
            this.deploymentPhaseField = XTypedList<deploymentPhaseLocalType>.Initialize(this, LinqToXsdTypeManager.Instance, deploymentPhase, XName.Get("deploymentPhase", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (deploymentPhase+)
        /// </para>
        /// </summary>
        public IList<www.xboxlive.com.Deployment.Language.XMLSchema.xsd.deploymentPhases.deploymentPhaseLocalType> deploymentPhase {
            get {
                if ((this.deploymentPhaseField == null)) {
                    this.deploymentPhaseField = new XTypedList<deploymentPhaseLocalType>(this, LinqToXsdTypeManager.Instance, XName.Get("deploymentPhase", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                }
                return this.deploymentPhaseField;
            }
            set {
                if ((value == null)) {
                    this.deploymentPhaseField = null;
                }
                else {
                    if ((this.deploymentPhaseField == null)) {
                        this.deploymentPhaseField = XTypedList<deploymentPhaseLocalType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("deploymentPhase", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    else {
                        XTypedServices.SetList<deploymentPhaseLocalType>(this.deploymentPhaseField, value);
                    }
                }
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("deploymentPhases", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public void Save(string xmlFile) {
            XTypedServices.Save(xmlFile, Untyped);
        }
        
        public void Save(System.IO.TextWriter tw) {
            XTypedServices.Save(tw, Untyped);
        }
        
        public void Save(System.Xml.XmlWriter xmlWriter) {
            XTypedServices.Save(xmlWriter, Untyped);
        }
        
        public static deploymentPhases Load(string xmlFile) {
            return XTypedServices.Load<deploymentPhases>(xmlFile);
        }
        
        public static deploymentPhases Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<deploymentPhases>(xmlFile);
        }
        
        public static deploymentPhases Parse(string xml) {
            return XTypedServices.Parse<deploymentPhases>(xml);
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<deploymentPhases>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(XName.Get("deploymentPhase", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(deploymentPhaseLocalType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
        
        /// <summary>
        /// <para>
        /// Regular expression: (componentRef+ | property*)+
        /// </para>
        /// </summary>
        public partial class deploymentPhaseLocalType : XTypedElement, IXMetaData {
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<ComponentRefType> componentRefField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<PropertyType> propertyField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private static bool @defaultDefaultValue = System.Xml.XmlConvert.ToBoolean("false");
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
            
         public static explicit operator deploymentPhaseLocalType(XElement xe) { return XTypedServices.ToXTypedElement<deploymentPhaseLocalType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
            
            static deploymentPhaseLocalType() {
                BuildElementDictionary();
            }
            
            /// <summary>
            /// <para>
            /// Regular expression: (componentRef+ | property*)+
            /// </para>
            /// </summary>
            public deploymentPhaseLocalType() {
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: required, repeating, choice
            /// </para>
            /// <para>
            /// Regular expression: (componentRef+ | property*)+
            /// </para>
            /// </summary>
            public IList<ComponentRefType> componentRef {
                get {
                    if ((this.componentRefField == null)) {
                        this.componentRefField = new XTypedList<ComponentRefType>(this, LinqToXsdTypeManager.Instance, XName.Get("componentRef", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    return this.componentRefField;
                }
                set {
                    if ((value == null)) {
                        this.componentRefField = null;
                    }
                    else {
                        if ((this.componentRefField == null)) {
                            this.componentRefField = XTypedList<ComponentRefType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("componentRef", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                        }
                        else {
                            XTypedServices.SetList<ComponentRefType>(this.componentRefField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: optional, repeating, choice
            /// </para>
            /// <para>
            /// Regular expression: (componentRef+ | property*)+
            /// </para>
            /// </summary>
            public IList<PropertyType> property {
                get {
                    if ((this.propertyField == null)) {
                        this.propertyField = new XTypedList<PropertyType>(this, LinqToXsdTypeManager.Instance, XName.Get("property", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    return this.propertyField;
                }
                set {
                    if ((value == null)) {
                        this.propertyField = null;
                    }
                    else {
                        if ((this.propertyField == null)) {
                            this.propertyField = XTypedList<PropertyType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("property", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                        }
                        else {
                            XTypedServices.SetList<PropertyType>(this.propertyField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: required
            /// </para>
            /// </summary>
            public string name {
                get {
                    XAttribute x = this.Attribute(XName.Get("name", ""));
                    return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
                set {
                    this.SetAttribute(XName.Get("name", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: optional
            /// </para>
            /// </summary>
            public bool @default {
                get {
                    XAttribute x = this.Attribute(XName.Get("default", ""));
                    return XTypedServices.ParseValue<bool>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean).Datatype, @defaultDefaultValue);
                }
                set {
                    this.SetAttribute(XName.Get("default", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean).Datatype);
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
                get {
                    return localElementDictionary;
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            XName IXMetaData.SchemaName {
                get {
                    return XName.Get("deploymentPhase", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            SchemaOrigin IXMetaData.TypeOrigin {
                get {
                    return SchemaOrigin.Fragment;
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            ILinqToXsdTypeManager IXMetaData.TypeManager {
                get {
                    return LinqToXsdTypeManager.Instance;
                }
            }
            
            public override XTypedElement Clone() {
                return XTypedServices.CloneXTypedElement<deploymentPhaseLocalType>(this);
            }
            
            private static void BuildElementDictionary() {
                localElementDictionary.Add(XName.Get("componentRef", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(ComponentRefType));
                localElementDictionary.Add(XName.Get("property", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(PropertyType));
            }
            
            ContentModelEntity IXMetaData.GetContentModel() {
                return ContentModelEntity.Default;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Regular expression: (installStep+ | sharedStep+)
    /// </para>
    /// </summary>
    public partial class installSteps : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<installStepLocalType> installStepField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<sharedStepLocalType> sharedStepField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
         public static explicit operator installSteps(XElement xe) { return XTypedServices.ToXTypedElement<installSteps>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static installSteps() {
            BuildElementDictionary();
            contentModel = new ChoiceContentModelEntity(new NamedContentModelEntity(XName.Get("installStep", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd")), new NamedContentModelEntity(XName.Get("sharedStep", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd")));
        }
        
        /// <summary>
        /// <para>
        /// Regular expression: (installStep+ | sharedStep+)
        /// </para>
        /// </summary>
        public installSteps() {
        }
        
        public installSteps(IEnumerable<installStepLocalType> installStep) {
            this.installStepField = XTypedList<installStepLocalType>.Initialize(this, LinqToXsdTypeManager.Instance, installStep, XName.Get("installStep", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
        }
        
        public installSteps(IEnumerable<sharedStepLocalType> sharedStep) {
            this.sharedStepField = XTypedList<sharedStepLocalType>.Initialize(this, LinqToXsdTypeManager.Instance, sharedStep, XName.Get("sharedStep", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (installStep+ | sharedStep+)
        /// </para>
        /// </summary>
        public IList<www.xboxlive.com.Deployment.Language.XMLSchema.xsd.installSteps.installStepLocalType> installStep {
            get {
                if ((this.installStepField == null)) {
                    this.installStepField = new XTypedList<installStepLocalType>(this, LinqToXsdTypeManager.Instance, XName.Get("installStep", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                }
                return this.installStepField;
            }
            set {
                if ((value == null)) {
                    this.installStepField = null;
                }
                else {
                    if ((this.installStepField == null)) {
                        this.installStepField = XTypedList<installStepLocalType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("installStep", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    else {
                        XTypedServices.SetList<installStepLocalType>(this.installStepField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (installStep+ | sharedStep+)
        /// </para>
        /// </summary>
        public IList<www.xboxlive.com.Deployment.Language.XMLSchema.xsd.installSteps.sharedStepLocalType> sharedStep {
            get {
                if ((this.sharedStepField == null)) {
                    this.sharedStepField = new XTypedList<sharedStepLocalType>(this, LinqToXsdTypeManager.Instance, XName.Get("sharedStep", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                }
                return this.sharedStepField;
            }
            set {
                if ((value == null)) {
                    this.sharedStepField = null;
                }
                else {
                    if ((this.sharedStepField == null)) {
                        this.sharedStepField = XTypedList<sharedStepLocalType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("sharedStep", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    else {
                        XTypedServices.SetList<sharedStepLocalType>(this.sharedStepField, value);
                    }
                }
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("installSteps", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public void Save(string xmlFile) {
            XTypedServices.Save(xmlFile, Untyped);
        }
        
        public void Save(System.IO.TextWriter tw) {
            XTypedServices.Save(tw, Untyped);
        }
        
        public void Save(System.Xml.XmlWriter xmlWriter) {
            XTypedServices.Save(xmlWriter, Untyped);
        }
        
        public static installSteps Load(string xmlFile) {
            return XTypedServices.Load<installSteps>(xmlFile);
        }
        
        public static installSteps Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<installSteps>(xmlFile);
        }
        
        public static installSteps Parse(string xml) {
            return XTypedServices.Parse<installSteps>(xml);
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<installSteps>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(XName.Get("installStep", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(installStepLocalType));
            localElementDictionary.Add(XName.Get("sharedStep", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(sharedStepLocalType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
        
        /// <summary>
        /// <para>
        /// Regular expression: (property* | prerequisiteChecks? | postdeploymentChecks? | conditionChecks? | dependsOn* | install* | runCommand* | runMsi*)*
        /// </para>
        /// </summary>
        public partial class installStepLocalType : XTypedElement, IXMetaData {
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<PropertyType> propertyField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<ChecksType> prerequisiteChecksField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<ChecksType> postdeploymentChecksField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<ChecksType> conditionChecksField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<DependsOnType> dependsOnField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<InstallType> installField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<RunCommandType> runCommandField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<RunMsiType> runMsiField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
            
         public static explicit operator installStepLocalType(XElement xe) { return XTypedServices.ToXTypedElement<installStepLocalType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
            
            static installStepLocalType() {
                BuildElementDictionary();
            }
            
            /// <summary>
            /// <para>
            /// Regular expression: (property* | prerequisiteChecks? | postdeploymentChecks? | conditionChecks? | dependsOn* | install* | runCommand* | runMsi*)*
            /// </para>
            /// </summary>
            public installStepLocalType() {
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: optional, repeating, choice
            /// </para>
            /// <para>
            /// Regular expression: (property* | prerequisiteChecks? | postdeploymentChecks? | conditionChecks? | dependsOn* | install* | runCommand* | runMsi*)*
            /// </para>
            /// </summary>
            public IList<PropertyType> property {
                get {
                    if ((this.propertyField == null)) {
                        this.propertyField = new XTypedList<PropertyType>(this, LinqToXsdTypeManager.Instance, XName.Get("property", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    return this.propertyField;
                }
                set {
                    if ((value == null)) {
                        this.propertyField = null;
                    }
                    else {
                        if ((this.propertyField == null)) {
                            this.propertyField = XTypedList<PropertyType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("property", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                        }
                        else {
                            XTypedServices.SetList<PropertyType>(this.propertyField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: optional, choice
            /// </para>
            /// <para>
            /// Regular expression: (property* | prerequisiteChecks? | postdeploymentChecks? | conditionChecks? | dependsOn* | install* | runCommand* | runMsi*)*
            /// </para>
            /// </summary>
            public IList<ChecksType> prerequisiteChecks {
                get {
                    if ((this.prerequisiteChecksField == null)) {
                        this.prerequisiteChecksField = new XTypedList<ChecksType>(this, LinqToXsdTypeManager.Instance, XName.Get("prerequisiteChecks", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    return this.prerequisiteChecksField;
                }
                set {
                    if ((value == null)) {
                        this.prerequisiteChecksField = null;
                    }
                    else {
                        if ((this.prerequisiteChecksField == null)) {
                            this.prerequisiteChecksField = XTypedList<ChecksType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("prerequisiteChecks", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                        }
                        else {
                            XTypedServices.SetList<ChecksType>(this.prerequisiteChecksField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: optional, choice
            /// </para>
            /// <para>
            /// Regular expression: (property* | prerequisiteChecks? | postdeploymentChecks? | conditionChecks? | dependsOn* | install* | runCommand* | runMsi*)*
            /// </para>
            /// </summary>
            public IList<ChecksType> postdeploymentChecks {
                get {
                    if ((this.postdeploymentChecksField == null)) {
                        this.postdeploymentChecksField = new XTypedList<ChecksType>(this, LinqToXsdTypeManager.Instance, XName.Get("postdeploymentChecks", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    return this.postdeploymentChecksField;
                }
                set {
                    if ((value == null)) {
                        this.postdeploymentChecksField = null;
                    }
                    else {
                        if ((this.postdeploymentChecksField == null)) {
                            this.postdeploymentChecksField = XTypedList<ChecksType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("postdeploymentChecks", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                        }
                        else {
                            XTypedServices.SetList<ChecksType>(this.postdeploymentChecksField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: optional, choice
            /// </para>
            /// <para>
            /// Regular expression: (property* | prerequisiteChecks? | postdeploymentChecks? | conditionChecks? | dependsOn* | install* | runCommand* | runMsi*)*
            /// </para>
            /// </summary>
            public IList<ChecksType> conditionChecks {
                get {
                    if ((this.conditionChecksField == null)) {
                        this.conditionChecksField = new XTypedList<ChecksType>(this, LinqToXsdTypeManager.Instance, XName.Get("conditionChecks", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    return this.conditionChecksField;
                }
                set {
                    if ((value == null)) {
                        this.conditionChecksField = null;
                    }
                    else {
                        if ((this.conditionChecksField == null)) {
                            this.conditionChecksField = XTypedList<ChecksType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("conditionChecks", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                        }
                        else {
                            XTypedServices.SetList<ChecksType>(this.conditionChecksField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: optional, repeating, choice
            /// </para>
            /// <para>
            /// Regular expression: (property* | prerequisiteChecks? | postdeploymentChecks? | conditionChecks? | dependsOn* | install* | runCommand* | runMsi*)*
            /// </para>
            /// </summary>
            public IList<DependsOnType> dependsOn {
                get {
                    if ((this.dependsOnField == null)) {
                        this.dependsOnField = new XTypedList<DependsOnType>(this, LinqToXsdTypeManager.Instance, XName.Get("dependsOn", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    return this.dependsOnField;
                }
                set {
                    if ((value == null)) {
                        this.dependsOnField = null;
                    }
                    else {
                        if ((this.dependsOnField == null)) {
                            this.dependsOnField = XTypedList<DependsOnType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("dependsOn", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                        }
                        else {
                            XTypedServices.SetList<DependsOnType>(this.dependsOnField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: optional, repeating, choice
            /// </para>
            /// <para>
            /// Regular expression: (property* | prerequisiteChecks? | postdeploymentChecks? | conditionChecks? | dependsOn* | install* | runCommand* | runMsi*)*
            /// </para>
            /// </summary>
            public IList<InstallType> install {
                get {
                    if ((this.installField == null)) {
                        this.installField = new XTypedList<InstallType>(this, LinqToXsdTypeManager.Instance, XName.Get("install", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    return this.installField;
                }
                set {
                    if ((value == null)) {
                        this.installField = null;
                    }
                    else {
                        if ((this.installField == null)) {
                            this.installField = XTypedList<InstallType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("install", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                        }
                        else {
                            XTypedServices.SetList<InstallType>(this.installField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: optional, repeating, choice
            /// </para>
            /// <para>
            /// Regular expression: (property* | prerequisiteChecks? | postdeploymentChecks? | conditionChecks? | dependsOn* | install* | runCommand* | runMsi*)*
            /// </para>
            /// </summary>
            public IList<RunCommandType> runCommand {
                get {
                    if ((this.runCommandField == null)) {
                        this.runCommandField = new XTypedList<RunCommandType>(this, LinqToXsdTypeManager.Instance, XName.Get("runCommand", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    return this.runCommandField;
                }
                set {
                    if ((value == null)) {
                        this.runCommandField = null;
                    }
                    else {
                        if ((this.runCommandField == null)) {
                            this.runCommandField = XTypedList<RunCommandType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("runCommand", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                        }
                        else {
                            XTypedServices.SetList<RunCommandType>(this.runCommandField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: optional, repeating, choice
            /// </para>
            /// <para>
            /// Regular expression: (property* | prerequisiteChecks? | postdeploymentChecks? | conditionChecks? | dependsOn* | install* | runCommand* | runMsi*)*
            /// </para>
            /// </summary>
            public IList<RunMsiType> runMsi {
                get {
                    if ((this.runMsiField == null)) {
                        this.runMsiField = new XTypedList<RunMsiType>(this, LinqToXsdTypeManager.Instance, XName.Get("runMsi", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    return this.runMsiField;
                }
                set {
                    if ((value == null)) {
                        this.runMsiField = null;
                    }
                    else {
                        if ((this.runMsiField == null)) {
                            this.runMsiField = XTypedList<RunMsiType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("runMsi", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                        }
                        else {
                            XTypedServices.SetList<RunMsiType>(this.runMsiField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: required
            /// </para>
            /// </summary>
            public string name {
                get {
                    XAttribute x = this.Attribute(XName.Get("name", ""));
                    return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
                set {
                    this.SetAttribute(XName.Get("name", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
                get {
                    return localElementDictionary;
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            XName IXMetaData.SchemaName {
                get {
                    return XName.Get("installStep", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            SchemaOrigin IXMetaData.TypeOrigin {
                get {
                    return SchemaOrigin.Fragment;
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            ILinqToXsdTypeManager IXMetaData.TypeManager {
                get {
                    return LinqToXsdTypeManager.Instance;
                }
            }
            
            public override XTypedElement Clone() {
                return XTypedServices.CloneXTypedElement<installStepLocalType>(this);
            }
            
            private static void BuildElementDictionary() {
                localElementDictionary.Add(XName.Get("property", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(PropertyType));
                localElementDictionary.Add(XName.Get("prerequisiteChecks", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(ChecksType));
                localElementDictionary.Add(XName.Get("postdeploymentChecks", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(ChecksType));
                localElementDictionary.Add(XName.Get("conditionChecks", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(ChecksType));
                localElementDictionary.Add(XName.Get("dependsOn", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(DependsOnType));
                localElementDictionary.Add(XName.Get("install", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(InstallType));
                localElementDictionary.Add(XName.Get("runCommand", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(RunCommandType));
                localElementDictionary.Add(XName.Get("runMsi", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(RunMsiType));
            }
            
            ContentModelEntity IXMetaData.GetContentModel() {
                return ContentModelEntity.Default;
            }
        }
        
        /// <summary>
        /// <para>
        /// Regular expression: (property* | prerequisiteChecks? | postdeploymentChecks? | conditionChecks? | dependsOn* | install* | runCommand* | runMsi*)*
        /// </para>
        /// </summary>
        public partial class sharedStepLocalType : XTypedElement, IXMetaData {
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<SharedPropertyType> propertyField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<ChecksType> prerequisiteChecksField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<ChecksType> postdeploymentChecksField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<ChecksType> conditionChecksField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<DependsOnType> dependsOnField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<InstallType> installField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<RunCommandType> runCommandField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<RunMsiType> runMsiField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
            
         public static explicit operator sharedStepLocalType(XElement xe) { return XTypedServices.ToXTypedElement<sharedStepLocalType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
            
            static sharedStepLocalType() {
                BuildElementDictionary();
            }
            
            /// <summary>
            /// <para>
            /// Regular expression: (property* | prerequisiteChecks? | postdeploymentChecks? | conditionChecks? | dependsOn* | install* | runCommand* | runMsi*)*
            /// </para>
            /// </summary>
            public sharedStepLocalType() {
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: optional, repeating, choice
            /// </para>
            /// <para>
            /// Regular expression: (property* | prerequisiteChecks? | postdeploymentChecks? | conditionChecks? | dependsOn* | install* | runCommand* | runMsi*)*
            /// </para>
            /// </summary>
            public IList<SharedPropertyType> property {
                get {
                    if ((this.propertyField == null)) {
                        this.propertyField = new XTypedList<SharedPropertyType>(this, LinqToXsdTypeManager.Instance, XName.Get("property", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    return this.propertyField;
                }
                set {
                    if ((value == null)) {
                        this.propertyField = null;
                    }
                    else {
                        if ((this.propertyField == null)) {
                            this.propertyField = XTypedList<SharedPropertyType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("property", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                        }
                        else {
                            XTypedServices.SetList<SharedPropertyType>(this.propertyField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: optional, choice
            /// </para>
            /// <para>
            /// Regular expression: (property* | prerequisiteChecks? | postdeploymentChecks? | conditionChecks? | dependsOn* | install* | runCommand* | runMsi*)*
            /// </para>
            /// </summary>
            public IList<ChecksType> prerequisiteChecks {
                get {
                    if ((this.prerequisiteChecksField == null)) {
                        this.prerequisiteChecksField = new XTypedList<ChecksType>(this, LinqToXsdTypeManager.Instance, XName.Get("prerequisiteChecks", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    return this.prerequisiteChecksField;
                }
                set {
                    if ((value == null)) {
                        this.prerequisiteChecksField = null;
                    }
                    else {
                        if ((this.prerequisiteChecksField == null)) {
                            this.prerequisiteChecksField = XTypedList<ChecksType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("prerequisiteChecks", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                        }
                        else {
                            XTypedServices.SetList<ChecksType>(this.prerequisiteChecksField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: optional, choice
            /// </para>
            /// <para>
            /// Regular expression: (property* | prerequisiteChecks? | postdeploymentChecks? | conditionChecks? | dependsOn* | install* | runCommand* | runMsi*)*
            /// </para>
            /// </summary>
            public IList<ChecksType> postdeploymentChecks {
                get {
                    if ((this.postdeploymentChecksField == null)) {
                        this.postdeploymentChecksField = new XTypedList<ChecksType>(this, LinqToXsdTypeManager.Instance, XName.Get("postdeploymentChecks", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    return this.postdeploymentChecksField;
                }
                set {
                    if ((value == null)) {
                        this.postdeploymentChecksField = null;
                    }
                    else {
                        if ((this.postdeploymentChecksField == null)) {
                            this.postdeploymentChecksField = XTypedList<ChecksType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("postdeploymentChecks", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                        }
                        else {
                            XTypedServices.SetList<ChecksType>(this.postdeploymentChecksField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: optional, choice
            /// </para>
            /// <para>
            /// Regular expression: (property* | prerequisiteChecks? | postdeploymentChecks? | conditionChecks? | dependsOn* | install* | runCommand* | runMsi*)*
            /// </para>
            /// </summary>
            public IList<ChecksType> conditionChecks {
                get {
                    if ((this.conditionChecksField == null)) {
                        this.conditionChecksField = new XTypedList<ChecksType>(this, LinqToXsdTypeManager.Instance, XName.Get("conditionChecks", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    return this.conditionChecksField;
                }
                set {
                    if ((value == null)) {
                        this.conditionChecksField = null;
                    }
                    else {
                        if ((this.conditionChecksField == null)) {
                            this.conditionChecksField = XTypedList<ChecksType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("conditionChecks", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                        }
                        else {
                            XTypedServices.SetList<ChecksType>(this.conditionChecksField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: optional, repeating, choice
            /// </para>
            /// <para>
            /// Regular expression: (property* | prerequisiteChecks? | postdeploymentChecks? | conditionChecks? | dependsOn* | install* | runCommand* | runMsi*)*
            /// </para>
            /// </summary>
            public IList<DependsOnType> dependsOn {
                get {
                    if ((this.dependsOnField == null)) {
                        this.dependsOnField = new XTypedList<DependsOnType>(this, LinqToXsdTypeManager.Instance, XName.Get("dependsOn", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    return this.dependsOnField;
                }
                set {
                    if ((value == null)) {
                        this.dependsOnField = null;
                    }
                    else {
                        if ((this.dependsOnField == null)) {
                            this.dependsOnField = XTypedList<DependsOnType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("dependsOn", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                        }
                        else {
                            XTypedServices.SetList<DependsOnType>(this.dependsOnField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: optional, repeating, choice
            /// </para>
            /// <para>
            /// Regular expression: (property* | prerequisiteChecks? | postdeploymentChecks? | conditionChecks? | dependsOn* | install* | runCommand* | runMsi*)*
            /// </para>
            /// </summary>
            public IList<InstallType> install {
                get {
                    if ((this.installField == null)) {
                        this.installField = new XTypedList<InstallType>(this, LinqToXsdTypeManager.Instance, XName.Get("install", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    return this.installField;
                }
                set {
                    if ((value == null)) {
                        this.installField = null;
                    }
                    else {
                        if ((this.installField == null)) {
                            this.installField = XTypedList<InstallType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("install", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                        }
                        else {
                            XTypedServices.SetList<InstallType>(this.installField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: optional, repeating, choice
            /// </para>
            /// <para>
            /// Regular expression: (property* | prerequisiteChecks? | postdeploymentChecks? | conditionChecks? | dependsOn* | install* | runCommand* | runMsi*)*
            /// </para>
            /// </summary>
            public IList<RunCommandType> runCommand {
                get {
                    if ((this.runCommandField == null)) {
                        this.runCommandField = new XTypedList<RunCommandType>(this, LinqToXsdTypeManager.Instance, XName.Get("runCommand", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    return this.runCommandField;
                }
                set {
                    if ((value == null)) {
                        this.runCommandField = null;
                    }
                    else {
                        if ((this.runCommandField == null)) {
                            this.runCommandField = XTypedList<RunCommandType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("runCommand", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                        }
                        else {
                            XTypedServices.SetList<RunCommandType>(this.runCommandField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: optional, repeating, choice
            /// </para>
            /// <para>
            /// Regular expression: (property* | prerequisiteChecks? | postdeploymentChecks? | conditionChecks? | dependsOn* | install* | runCommand* | runMsi*)*
            /// </para>
            /// </summary>
            public IList<RunMsiType> runMsi {
                get {
                    if ((this.runMsiField == null)) {
                        this.runMsiField = new XTypedList<RunMsiType>(this, LinqToXsdTypeManager.Instance, XName.Get("runMsi", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    return this.runMsiField;
                }
                set {
                    if ((value == null)) {
                        this.runMsiField = null;
                    }
                    else {
                        if ((this.runMsiField == null)) {
                            this.runMsiField = XTypedList<RunMsiType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("runMsi", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                        }
                        else {
                            XTypedServices.SetList<RunMsiType>(this.runMsiField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: required
            /// </para>
            /// </summary>
            public string name {
                get {
                    XAttribute x = this.Attribute(XName.Get("name", ""));
                    return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
                set {
                    this.SetAttribute(XName.Get("name", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
                get {
                    return localElementDictionary;
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            XName IXMetaData.SchemaName {
                get {
                    return XName.Get("sharedStep", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            SchemaOrigin IXMetaData.TypeOrigin {
                get {
                    return SchemaOrigin.Fragment;
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            ILinqToXsdTypeManager IXMetaData.TypeManager {
                get {
                    return LinqToXsdTypeManager.Instance;
                }
            }
            
            public override XTypedElement Clone() {
                return XTypedServices.CloneXTypedElement<sharedStepLocalType>(this);
            }
            
            private static void BuildElementDictionary() {
                localElementDictionary.Add(XName.Get("property", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(SharedPropertyType));
                localElementDictionary.Add(XName.Get("prerequisiteChecks", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(ChecksType));
                localElementDictionary.Add(XName.Get("postdeploymentChecks", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(ChecksType));
                localElementDictionary.Add(XName.Get("conditionChecks", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(ChecksType));
                localElementDictionary.Add(XName.Get("dependsOn", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(DependsOnType));
                localElementDictionary.Add(XName.Get("install", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(InstallType));
                localElementDictionary.Add(XName.Get("runCommand", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(RunCommandType));
                localElementDictionary.Add(XName.Get("runMsi", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(RunMsiType));
            }
            
            ContentModelEntity IXMetaData.GetContentModel() {
                return ContentModelEntity.Default;
            }
        }
    }
    
    public sealed class ReleaseNameType {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(8)), null, 0, 0, null, null, 0, null, null, 0, new string[] {
                        "([a-zA-Z0-9 ])([a-zA-Z0-9 ])*"}, 0, XmlSchemaWhiteSpace.Preserve));
        
        private ReleaseNameType() {
        }
    }
    
    public sealed class ServersType {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                        "all"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
        
        private ServersType() {
        }
    }
    
    public partial class RebootType : XTypedElement, IXMetaData {
        
         public static explicit operator RebootType(XElement xe) { return XTypedServices.ToXTypedElement<RebootType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public RebootType() {
        }
        
        /// <summary>
        /// <para>
        /// Set this attribute to "true" to indicate that the server should be rebooted when the component is installed, or "false" to indicate that this component does not cause the server to be rebooted during install.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public bool onInstall {
            get {
                XAttribute x = this.Attribute(XName.Get("onInstall", ""));
                return XTypedServices.ParseValue<bool>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("onInstall", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// Set this attribute to "true" to indicate that the server should be rebooted when the component is uninstalled, or "false" to indicate that this component does not cause the server to be rebooted during uninstall.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public bool onUninstall {
            get {
                XAttribute x = this.Attribute(XName.Get("onUninstall", ""));
                return XTypedServices.ParseValue<bool>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("onUninstall", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("RebootType", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<RebootType>(this);
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    public partial class DependsOnType : XTypedElement, IXMetaData {
        
         public static explicit operator DependsOnType(XElement xe) { return XTypedServices.ToXTypedElement<DependsOnType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public DependsOnType() {
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public string componentName {
            get {
                XAttribute x = this.Attribute(XName.Get("componentName", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("componentName", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("DependsOnType", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<DependsOnType>(this);
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    /// <summary>
    /// <para>
    /// Regular expression: (passProperty*)
    /// </para>
    /// </summary>
    public partial class InstallType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<PassPropertyType> passPropertyField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
         public static explicit operator InstallType(XElement xe) { return XTypedServices.ToXTypedElement<InstallType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static InstallType() {
            BuildElementDictionary();
            contentModel = new ChoiceContentModelEntity(new NamedContentModelEntity(XName.Get("passProperty", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd")));
        }
        
        /// <summary>
        /// <para>
        /// Regular expression: (passProperty*)
        /// </para>
        /// </summary>
        public InstallType() {
        }
        
        public InstallType(IEnumerable<PassPropertyType> passProperty) {
            this.passPropertyField = XTypedList<PassPropertyType>.Initialize(this, LinqToXsdTypeManager.Instance, passProperty, XName.Get("passProperty", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (passProperty*)
        /// </para>
        /// </summary>
        public IList<PassPropertyType> passProperty {
            get {
                if ((this.passPropertyField == null)) {
                    this.passPropertyField = new XTypedList<PassPropertyType>(this, LinqToXsdTypeManager.Instance, XName.Get("passProperty", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                }
                return this.passPropertyField;
            }
            set {
                if ((value == null)) {
                    this.passPropertyField = null;
                }
                else {
                    if ((this.passPropertyField == null)) {
                        this.passPropertyField = XTypedList<PassPropertyType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("passProperty", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    else {
                        XTypedServices.SetList<PassPropertyType>(this.passPropertyField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public string step {
            get {
                XAttribute x = this.Attribute(XName.Get("step", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("step", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("InstallType", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<InstallType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(XName.Get("passProperty", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(PassPropertyType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// Regular expression: (property* | prerequisiteChecks? | postdeploymentChecks? | conditionChecks? | reboot? | installCommand? | uninstallCommand?)*
    /// </para>
    /// </summary>
    public partial class RunCommandType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<PropertyType> propertyField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<ChecksType> prerequisiteChecksField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<ChecksType> postdeploymentChecksField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<ChecksType> conditionChecksField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<RebootType> rebootField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<CommandType> installCommandField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<CommandType> uninstallCommandField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
        
         public static explicit operator RunCommandType(XElement xe) { return XTypedServices.ToXTypedElement<RunCommandType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static RunCommandType() {
            BuildElementDictionary();
        }
        
        /// <summary>
        /// <para>
        /// Regular expression: (property* | prerequisiteChecks? | postdeploymentChecks? | conditionChecks? | reboot? | installCommand? | uninstallCommand?)*
        /// </para>
        /// </summary>
        public RunCommandType() {
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (property* | prerequisiteChecks? | postdeploymentChecks? | conditionChecks? | reboot? | installCommand? | uninstallCommand?)*
        /// </para>
        /// </summary>
        public IList<PropertyType> property {
            get {
                if ((this.propertyField == null)) {
                    this.propertyField = new XTypedList<PropertyType>(this, LinqToXsdTypeManager.Instance, XName.Get("property", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                }
                return this.propertyField;
            }
            set {
                if ((value == null)) {
                    this.propertyField = null;
                }
                else {
                    if ((this.propertyField == null)) {
                        this.propertyField = XTypedList<PropertyType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("property", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    else {
                        XTypedServices.SetList<PropertyType>(this.propertyField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional, choice
        /// </para>
        /// <para>
        /// Regular expression: (property* | prerequisiteChecks? | postdeploymentChecks? | conditionChecks? | reboot? | installCommand? | uninstallCommand?)*
        /// </para>
        /// </summary>
        public IList<ChecksType> prerequisiteChecks {
            get {
                if ((this.prerequisiteChecksField == null)) {
                    this.prerequisiteChecksField = new XTypedList<ChecksType>(this, LinqToXsdTypeManager.Instance, XName.Get("prerequisiteChecks", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                }
                return this.prerequisiteChecksField;
            }
            set {
                if ((value == null)) {
                    this.prerequisiteChecksField = null;
                }
                else {
                    if ((this.prerequisiteChecksField == null)) {
                        this.prerequisiteChecksField = XTypedList<ChecksType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("prerequisiteChecks", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    else {
                        XTypedServices.SetList<ChecksType>(this.prerequisiteChecksField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional, choice
        /// </para>
        /// <para>
        /// Regular expression: (property* | prerequisiteChecks? | postdeploymentChecks? | conditionChecks? | reboot? | installCommand? | uninstallCommand?)*
        /// </para>
        /// </summary>
        public IList<ChecksType> postdeploymentChecks {
            get {
                if ((this.postdeploymentChecksField == null)) {
                    this.postdeploymentChecksField = new XTypedList<ChecksType>(this, LinqToXsdTypeManager.Instance, XName.Get("postdeploymentChecks", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                }
                return this.postdeploymentChecksField;
            }
            set {
                if ((value == null)) {
                    this.postdeploymentChecksField = null;
                }
                else {
                    if ((this.postdeploymentChecksField == null)) {
                        this.postdeploymentChecksField = XTypedList<ChecksType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("postdeploymentChecks", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    else {
                        XTypedServices.SetList<ChecksType>(this.postdeploymentChecksField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional, choice
        /// </para>
        /// <para>
        /// Regular expression: (property* | prerequisiteChecks? | postdeploymentChecks? | conditionChecks? | reboot? | installCommand? | uninstallCommand?)*
        /// </para>
        /// </summary>
        public IList<ChecksType> conditionChecks {
            get {
                if ((this.conditionChecksField == null)) {
                    this.conditionChecksField = new XTypedList<ChecksType>(this, LinqToXsdTypeManager.Instance, XName.Get("conditionChecks", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                }
                return this.conditionChecksField;
            }
            set {
                if ((value == null)) {
                    this.conditionChecksField = null;
                }
                else {
                    if ((this.conditionChecksField == null)) {
                        this.conditionChecksField = XTypedList<ChecksType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("conditionChecks", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    else {
                        XTypedServices.SetList<ChecksType>(this.conditionChecksField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional, choice
        /// </para>
        /// <para>
        /// Regular expression: (property* | prerequisiteChecks? | postdeploymentChecks? | conditionChecks? | reboot? | installCommand? | uninstallCommand?)*
        /// </para>
        /// </summary>
        public IList<RebootType> reboot {
            get {
                if ((this.rebootField == null)) {
                    this.rebootField = new XTypedList<RebootType>(this, LinqToXsdTypeManager.Instance, XName.Get("reboot", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                }
                return this.rebootField;
            }
            set {
                if ((value == null)) {
                    this.rebootField = null;
                }
                else {
                    if ((this.rebootField == null)) {
                        this.rebootField = XTypedList<RebootType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("reboot", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    else {
                        XTypedServices.SetList<RebootType>(this.rebootField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional, choice
        /// </para>
        /// <para>
        /// Regular expression: (property* | prerequisiteChecks? | postdeploymentChecks? | conditionChecks? | reboot? | installCommand? | uninstallCommand?)*
        /// </para>
        /// </summary>
        public IList<CommandType> installCommand {
            get {
                if ((this.installCommandField == null)) {
                    this.installCommandField = new XTypedList<CommandType>(this, LinqToXsdTypeManager.Instance, XName.Get("installCommand", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                }
                return this.installCommandField;
            }
            set {
                if ((value == null)) {
                    this.installCommandField = null;
                }
                else {
                    if ((this.installCommandField == null)) {
                        this.installCommandField = XTypedList<CommandType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("installCommand", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    else {
                        XTypedServices.SetList<CommandType>(this.installCommandField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional, choice
        /// </para>
        /// <para>
        /// Regular expression: (property* | prerequisiteChecks? | postdeploymentChecks? | conditionChecks? | reboot? | installCommand? | uninstallCommand?)*
        /// </para>
        /// </summary>
        public IList<CommandType> uninstallCommand {
            get {
                if ((this.uninstallCommandField == null)) {
                    this.uninstallCommandField = new XTypedList<CommandType>(this, LinqToXsdTypeManager.Instance, XName.Get("uninstallCommand", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                }
                return this.uninstallCommandField;
            }
            set {
                if ((value == null)) {
                    this.uninstallCommandField = null;
                }
                else {
                    if ((this.uninstallCommandField == null)) {
                        this.uninstallCommandField = XTypedList<CommandType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("uninstallCommand", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    else {
                        XTypedServices.SetList<CommandType>(this.uninstallCommandField, value);
                    }
                }
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("RunCommandType", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<RunCommandType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(XName.Get("property", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(PropertyType));
            localElementDictionary.Add(XName.Get("prerequisiteChecks", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(ChecksType));
            localElementDictionary.Add(XName.Get("postdeploymentChecks", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(ChecksType));
            localElementDictionary.Add(XName.Get("conditionChecks", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(ChecksType));
            localElementDictionary.Add(XName.Get("reboot", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(RebootType));
            localElementDictionary.Add(XName.Get("installCommand", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(CommandType));
            localElementDictionary.Add(XName.Get("uninstallCommand", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(CommandType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    /// <summary>
    /// <para>
    /// Regular expression: (property* | prerequisiteChecks? | postdeploymentChecks? | conditionChecks? | reboot? | msi)*
    /// </para>
    /// </summary>
    public partial class RunMsiType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<PropertyType> propertyField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<ChecksType> prerequisiteChecksField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<ChecksType> postdeploymentChecksField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<ChecksType> conditionChecksField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<RebootType> rebootField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<msiLocalType> msiField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
        
         public static explicit operator RunMsiType(XElement xe) { return XTypedServices.ToXTypedElement<RunMsiType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static RunMsiType() {
            BuildElementDictionary();
        }
        
        /// <summary>
        /// <para>
        /// Regular expression: (property* | prerequisiteChecks? | postdeploymentChecks? | conditionChecks? | reboot? | msi)*
        /// </para>
        /// </summary>
        public RunMsiType() {
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (property* | prerequisiteChecks? | postdeploymentChecks? | conditionChecks? | reboot? | msi)*
        /// </para>
        /// </summary>
        public IList<PropertyType> property {
            get {
                if ((this.propertyField == null)) {
                    this.propertyField = new XTypedList<PropertyType>(this, LinqToXsdTypeManager.Instance, XName.Get("property", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                }
                return this.propertyField;
            }
            set {
                if ((value == null)) {
                    this.propertyField = null;
                }
                else {
                    if ((this.propertyField == null)) {
                        this.propertyField = XTypedList<PropertyType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("property", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    else {
                        XTypedServices.SetList<PropertyType>(this.propertyField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional, choice
        /// </para>
        /// <para>
        /// Regular expression: (property* | prerequisiteChecks? | postdeploymentChecks? | conditionChecks? | reboot? | msi)*
        /// </para>
        /// </summary>
        public IList<ChecksType> prerequisiteChecks {
            get {
                if ((this.prerequisiteChecksField == null)) {
                    this.prerequisiteChecksField = new XTypedList<ChecksType>(this, LinqToXsdTypeManager.Instance, XName.Get("prerequisiteChecks", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                }
                return this.prerequisiteChecksField;
            }
            set {
                if ((value == null)) {
                    this.prerequisiteChecksField = null;
                }
                else {
                    if ((this.prerequisiteChecksField == null)) {
                        this.prerequisiteChecksField = XTypedList<ChecksType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("prerequisiteChecks", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    else {
                        XTypedServices.SetList<ChecksType>(this.prerequisiteChecksField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional, choice
        /// </para>
        /// <para>
        /// Regular expression: (property* | prerequisiteChecks? | postdeploymentChecks? | conditionChecks? | reboot? | msi)*
        /// </para>
        /// </summary>
        public IList<ChecksType> postdeploymentChecks {
            get {
                if ((this.postdeploymentChecksField == null)) {
                    this.postdeploymentChecksField = new XTypedList<ChecksType>(this, LinqToXsdTypeManager.Instance, XName.Get("postdeploymentChecks", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                }
                return this.postdeploymentChecksField;
            }
            set {
                if ((value == null)) {
                    this.postdeploymentChecksField = null;
                }
                else {
                    if ((this.postdeploymentChecksField == null)) {
                        this.postdeploymentChecksField = XTypedList<ChecksType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("postdeploymentChecks", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    else {
                        XTypedServices.SetList<ChecksType>(this.postdeploymentChecksField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional, choice
        /// </para>
        /// <para>
        /// Regular expression: (property* | prerequisiteChecks? | postdeploymentChecks? | conditionChecks? | reboot? | msi)*
        /// </para>
        /// </summary>
        public IList<ChecksType> conditionChecks {
            get {
                if ((this.conditionChecksField == null)) {
                    this.conditionChecksField = new XTypedList<ChecksType>(this, LinqToXsdTypeManager.Instance, XName.Get("conditionChecks", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                }
                return this.conditionChecksField;
            }
            set {
                if ((value == null)) {
                    this.conditionChecksField = null;
                }
                else {
                    if ((this.conditionChecksField == null)) {
                        this.conditionChecksField = XTypedList<ChecksType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("conditionChecks", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    else {
                        XTypedServices.SetList<ChecksType>(this.conditionChecksField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional, choice
        /// </para>
        /// <para>
        /// Regular expression: (property* | prerequisiteChecks? | postdeploymentChecks? | conditionChecks? | reboot? | msi)*
        /// </para>
        /// </summary>
        public IList<RebootType> reboot {
            get {
                if ((this.rebootField == null)) {
                    this.rebootField = new XTypedList<RebootType>(this, LinqToXsdTypeManager.Instance, XName.Get("reboot", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                }
                return this.rebootField;
            }
            set {
                if ((value == null)) {
                    this.rebootField = null;
                }
                else {
                    if ((this.rebootField == null)) {
                        this.rebootField = XTypedList<RebootType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("reboot", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    else {
                        XTypedServices.SetList<RebootType>(this.rebootField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// An MSI file to be executed.
        /// </para>
        /// <para>
        /// The <msi> element names a Microsoft Windows Installer file that should be executed by the Octopus Agent. The element optionally also specifies properties to pass to the MSI file.
        ///                All components ultimately reduce to a set of command actions or MSI files. MSI files are the standard Microsoft technology for installing, and uninstalling software on Microsoft Windows machines and documenting what is installed. Although a component may aggregate many msi elements by aggregating other components, only a single msi element may be declared in any given component.
        ///              The only MSI properties that can be changed on the command line are Public properties: those whose name contains no lowercase letters. Thus, the 'name' attribute of properties defined for the MSI should not contain lowercase letters.
        /// </para>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Regular expression: (property* | prerequisiteChecks? | postdeploymentChecks? | conditionChecks? | reboot? | msi)*
        /// </para>
        /// </summary>
        public IList<www.xboxlive.com.Deployment.Language.XMLSchema.xsd.RunMsiType.msiLocalType> msi {
            get {
                if ((this.msiField == null)) {
                    this.msiField = new XTypedList<msiLocalType>(this, LinqToXsdTypeManager.Instance, XName.Get("msi", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                }
                return this.msiField;
            }
            set {
                if ((value == null)) {
                    this.msiField = null;
                }
                else {
                    if ((this.msiField == null)) {
                        this.msiField = XTypedList<msiLocalType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("msi", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    else {
                        XTypedServices.SetList<msiLocalType>(this.msiField, value);
                    }
                }
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("RunMsiType", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<RunMsiType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(XName.Get("property", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(PropertyType));
            localElementDictionary.Add(XName.Get("prerequisiteChecks", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(ChecksType));
            localElementDictionary.Add(XName.Get("postdeploymentChecks", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(ChecksType));
            localElementDictionary.Add(XName.Get("conditionChecks", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(ChecksType));
            localElementDictionary.Add(XName.Get("reboot", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(RebootType));
            localElementDictionary.Add(XName.Get("msi", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(msiLocalType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        /// <summary>
        /// <para>
        /// Regular expression: (property*)*
        /// </para>
        /// </summary>
        public partial class msiLocalType : XTypedElement, IXMetaData {
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<PropertyType> propertyField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
            
         public static explicit operator msiLocalType(XElement xe) { return XTypedServices.ToXTypedElement<msiLocalType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
            
            static msiLocalType() {
                BuildElementDictionary();
            }
            
            /// <summary>
            /// <para>
            /// Regular expression: (property*)*
            /// </para>
            /// </summary>
            public msiLocalType() {
            }
            
            /// <summary>
            /// <para>
            /// A property to pass to the MSI file as a command-line parameter.
            /// </para>
            /// <para>
            /// Occurrence: optional, repeating, choice
            /// </para>
            /// <para>
            /// Regular expression: (property*)*
            /// </para>
            /// </summary>
            public IList<PropertyType> property {
                get {
                    if ((this.propertyField == null)) {
                        this.propertyField = new XTypedList<PropertyType>(this, LinqToXsdTypeManager.Instance, XName.Get("property", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    return this.propertyField;
                }
                set {
                    if ((value == null)) {
                        this.propertyField = null;
                    }
                    else {
                        if ((this.propertyField == null)) {
                            this.propertyField = XTypedList<PropertyType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("property", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                        }
                        else {
                            XTypedServices.SetList<PropertyType>(this.propertyField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// The file system path of the MSI file, relative to the directory containing the service.xml file. In most cases the MSI files are in the same directory as the service.xml file, so the MSI path is a simple file name, but it may be convenient in some cases to put MSI files in subdirectories.
            /// </para>
            /// <para>
            /// Occurrence: required
            /// </para>
            /// </summary>
            public string path {
                get {
                    XAttribute x = this.Attribute(XName.Get("path", ""));
                    return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
                set {
                    this.SetAttribute(XName.Get("path", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
            }
            
            /// <summary>
            /// <para>
            /// Normally properties are not passed to MSI files when uninstalling. Set this attribute to "true" to specify that this MSI file requires properties for uninstall. This option can also be set globally for all MSI files by setting the attribute on the <service> element.
            /// </para>
            /// <para>
            /// Occurrence: optional
            /// </para>
            /// </summary>
            public System.Nullable<bool> passPropertiesOnUninstall {
                get {
                    XAttribute x = this.Attribute(XName.Get("passPropertiesOnUninstall", ""));
                    if ((x == null)) {
                        return null;
                    }
                    return XTypedServices.ParseValue<bool>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean).Datatype);
                }
                set {
                    this.SetAttribute(XName.Get("passPropertiesOnUninstall", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean).Datatype);
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
                get {
                    return localElementDictionary;
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            XName IXMetaData.SchemaName {
                get {
                    return XName.Get("msi", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            SchemaOrigin IXMetaData.TypeOrigin {
                get {
                    return SchemaOrigin.Fragment;
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            ILinqToXsdTypeManager IXMetaData.TypeManager {
                get {
                    return LinqToXsdTypeManager.Instance;
                }
            }
            
            public override XTypedElement Clone() {
                return XTypedServices.CloneXTypedElement<msiLocalType>(this);
            }
            
            private static void BuildElementDictionary() {
                localElementDictionary.Add(XName.Get("property", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(PropertyType));
            }
            
            ContentModelEntity IXMetaData.GetContentModel() {
                return ContentModelEntity.Default;
            }
        }
    }
    
    public partial class ComponentRefType : XTypedElement, IXMetaData {
        
         public static explicit operator ComponentRefType(XElement xe) { return XTypedServices.ToXTypedElement<ComponentRefType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public ComponentRefType() {
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public string name {
            get {
                XAttribute x = this.Attribute(XName.Get("name", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("name", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("ComponentRefType", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<ComponentRefType>(this);
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    /// <summary>
    /// <para>
    /// A property definition.
    /// </para>
    /// <para>
    /// 
    ///            The <property> element is used throughout a service manifest to obtain user input and reconcile that input with predefined values. The values of properties may be entered by users, set as static strings, based upon values from previous properties, or set to a list of servers in the configuration at deployment time.
    ///            The value set by the <property> element may be overridden as part of a publishComponent or aggregateComponent element.
    ///          
    ///            Properties are necessary for many Microsoft Windows Installer files, which forms the basis of their inclusion in the Octopus Deployment Framework. Developers are free to place all properties in the msi elements of components if that is simplest, but other more flexible manifests are possible. For example, a set of properties may be defined at the topology level which are then inherited by published components. Or, a component may override a static property value with a user-provided value by using passProperty when aggregating another component.
    ///          
    ///            The property 'value' attribute may refer to the value of another property as though it were a variable. This is done by placing the name of the referenced property between square brackets. For example, the value of property 'foo' may be set to "my name is [bar]". This will reference the value of the property named 'bar' and replace the string '[bar]' with that value. If the value of 'bar' were 'Susan', then the value of 'foo' would be "my name is Susan".
    ///          
    /// </para>
    /// <para>
    /// Regular expression: (serverList | userInput | any)?
    /// </para>
    /// </summary>
    public partial class SharedPropertyType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static FSM validationStates;
        
         public static explicit operator SharedPropertyType(XElement xe) { return XTypedServices.ToXTypedElement<SharedPropertyType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static SharedPropertyType() {
            BuildElementDictionary();
            InitFSM();
        }
        
        /// <summary>
        /// <para>
        /// A property definition.
        /// </para>
        /// <para>
        /// 
        ///            The <property> element is used throughout a service manifest to obtain user input and reconcile that input with predefined values. The values of properties may be entered by users, set as static strings, based upon values from previous properties, or set to a list of servers in the configuration at deployment time.
        ///            The value set by the <property> element may be overridden as part of a publishComponent or aggregateComponent element.
        ///          
        ///            Properties are necessary for many Microsoft Windows Installer files, which forms the basis of their inclusion in the Octopus Deployment Framework. Developers are free to place all properties in the msi elements of components if that is simplest, but other more flexible manifests are possible. For example, a set of properties may be defined at the topology level which are then inherited by published components. Or, a component may override a static property value with a user-provided value by using passProperty when aggregating another component.
        ///          
        ///            The property 'value' attribute may refer to the value of another property as though it were a variable. This is done by placing the name of the referenced property between square brackets. For example, the value of property 'foo' may be set to "my name is [bar]". This will reference the value of the property named 'bar' and replace the string '[bar]' with that value. If the value of 'bar' were 'Susan', then the value of 'foo' would be "my name is Susan".
        ///          
        /// </para>
        /// <para>
        /// Regular expression: (serverList | userInput | any)?
        /// </para>
        /// </summary>
        public SharedPropertyType() {
        }
        
        public SharedPropertyType(serverListLocalType serverList) {
            this.serverList = serverList;
        }
        
        public SharedPropertyType(userInputLocalType userInput) {
            this.userInput = userInput;
        }
        
        /// <summary>
        /// <para>
        /// The property value is set to a list of servers meeting specified criteria.
        /// </para>
        /// <para>
        /// The <serverList> element sets the value of the parent property to a list of servers based on the roles and components assigned to servers at deployment time.The serverList element is useful to automatically determine the server name used for a particular component. For example, if a front end component needs to know the name of the database server, a property for the front end MSI file could be to a server list with type="component" and the name of the database component.
        /// </para>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Regular expression: (serverList | userInput | any)?
        /// </para>
        /// </summary>
        public serverListLocalType serverList {
            get {
                XElement x = this.GetElement(XName.Get("serverList", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                return ((serverListLocalType)(x));
            }
            set {
                this.SetElement(XName.Get("serverList", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), value);
            }
        }
        
        /// <summary>
        /// <para>
        /// The property value can be entered by the user at deployment time.
        /// </para>
        /// <para>
        /// 
        ///                The <userInput> element instructs the Octopus Console to solicit user input for the value of the parent property.
        ///              
        ///                The userInput element is useful at many levels in the service manifest. It can be used anywhere a property is allowed. At the upper levels of the service manifest (service or topology), userInput is used for property values that are shared by multiple components. At intermediate levels, userInput is useful for overriding properties lower down. A developer can solicit user input for a property at one level, and then use passProperty to override the default or static values of properties in an aggregated component at the next level down. At the component or MSI level, userInput allows the deployment operator to enter detailed configuration values for that individual component.
        ///              
        /// </para>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Regular expression: (serverList | userInput | any)?
        /// </para>
        /// </summary>
        public userInputLocalType userInput {
            get {
                XElement x = this.GetElement(XName.Get("userInput", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                return ((userInputLocalType)(x));
            }
            set {
                this.SetElement(XName.Get("userInput", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), value);
            }
        }
        
        /// <summary>
        /// <para>
        /// Regular expression: (serverList | userInput | any)?
        /// </para>
        /// </summary>
        public IEnumerable<XElement> Any {
            get {
                return this.GetWildCards(WildCard.DefaultWildCard);
            }
        }
        
        /// <summary>
        /// <para>
        /// The name of this property. Property names must start and end with a letter or digit; and may include letters, digits, underscores, spaces, periods or dashes between the first and last character.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public string name {
            get {
                XAttribute x = this.Attribute(XName.Get("name", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("name", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// A static or variable-based value for this property.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public string value {
            get {
                XAttribute x = this.Attribute(XName.Get("value", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("value", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// A separator to use when merging values passed from multiple aggregating components.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public string mergeSeparator {
            get {
                XAttribute x = this.Attribute(XName.Get("mergeSeparator", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("mergeSeparator", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("SharedPropertyType", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<SharedPropertyType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(XName.Get("serverList", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(serverListLocalType));
            localElementDictionary.Add(XName.Get("userInput", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(userInputLocalType));
        }
        
        FSM IXMetaData.GetValidationStates() {
            return validationStates;
        }
        
        private static void InitFSM() {
            Dictionary<int, Transitions> transitions = new Dictionary<int, Transitions>();
            transitions.Add(1, new Transitions(new SingleTransition(XName.Get("serverList", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 2), new SingleTransition(XName.Get("userInput", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 4), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 6)));
            validationStates = new FSM(1, new Set<int>(new int[] {
                            2,
                            4,
                            6,
                            1}), transitions);
        }
        
        public partial class serverListLocalType : XTypedElement, IXMetaData {
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private static string separatorDefaultValue = ",";
            
         public static explicit operator serverListLocalType(XElement xe) { return XTypedServices.ToXTypedElement<serverListLocalType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
            
            public serverListLocalType() {
            }
            
            /// <summary>
            /// <para>
            /// The type of server list to generate.
            /// </para>
            /// <para>
            /// The type attribute may take one of the following values:componentThe list will include all servers which include the component specified by the name attribute.publishInterfaceThe list will include all servers which include a component that publishes the interface specified by the name attribute.requireInterfaceThe list will include all servers which include a component that requires the interface specified by the name attribute.
            /// </para>
            /// <para>
            /// Occurrence: required
            /// </para>
            /// </summary>
            public string type {
                get {
                    XAttribute x = this.Attribute(XName.Get("type", ""));
                    return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
                set {
                    this.SetAttribute(XName.Get("type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
            }
            
            /// <summary>
            /// <para>
            /// The name of the component, publishInterface or requireInterface from which to construct the list of servers.
            /// </para>
            /// <para>
            /// Occurrence: required
            /// </para>
            /// </summary>
            public string name {
                get {
                    XAttribute x = this.Attribute(XName.Get("name", ""));
                    return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
                set {
                    this.SetAttribute(XName.Get("name", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
            }
            
            /// <summary>
            /// <para>
            /// The string with which to separate the server names in the list.
            /// </para>
            /// <para>
            /// Occurrence: optional
            /// </para>
            /// </summary>
            public string separator {
                get {
                    XAttribute x = this.Attribute(XName.Get("separator", ""));
                    return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, separatorDefaultValue);
                }
                set {
                    this.SetAttribute(XName.Get("separator", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            XName IXMetaData.SchemaName {
                get {
                    return XName.Get("serverList", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            SchemaOrigin IXMetaData.TypeOrigin {
                get {
                    return SchemaOrigin.Fragment;
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            ILinqToXsdTypeManager IXMetaData.TypeManager {
                get {
                    return LinqToXsdTypeManager.Instance;
                }
            }
            
            public override XTypedElement Clone() {
                return XTypedServices.CloneXTypedElement<serverListLocalType>(this);
            }
            
            ContentModelEntity IXMetaData.GetContentModel() {
                return ContentModelEntity.Default;
            }
        }
        
        /// <summary>
        /// <para>
        /// Regular expression: (checkbox | select | textbox | password)?
        /// </para>
        /// </summary>
        public partial class userInputLocalType : XTypedElement, IXMetaData {
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private static bool requiredDefaultValue = System.Xml.XmlConvert.ToBoolean("true");
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private static bool persistentDefaultValue = System.Xml.XmlConvert.ToBoolean("true");
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private static ContentModelEntity contentModel;
            
         public static explicit operator userInputLocalType(XElement xe) { return XTypedServices.ToXTypedElement<userInputLocalType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
            
            static userInputLocalType() {
                BuildElementDictionary();
                contentModel = new ChoiceContentModelEntity(new NamedContentModelEntity(XName.Get("checkbox", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd")), new NamedContentModelEntity(XName.Get("select", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd")), new NamedContentModelEntity(XName.Get("textbox", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd")), new NamedContentModelEntity(XName.Get("password", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd")));
            }
            
            /// <summary>
            /// <para>
            /// Regular expression: (checkbox | select | textbox | password)?
            /// </para>
            /// </summary>
            public userInputLocalType() {
            }
            
            public userInputLocalType(checkboxLocalType checkbox) {
                this.checkbox = checkbox;
            }
            
            public userInputLocalType(selectLocalType select) {
                this.select = select;
            }
            
            public userInputLocalType(textboxLocalType textbox) {
                this.textbox = textbox;
            }
            
            public userInputLocalType(passwordLocalType password) {
                this.password = password;
            }
            
            /// <summary>
            /// <para>
            /// The UI displays a check box.
            /// </para>
            /// <para>
            /// The <checkbox> user input element indicates that the UI should display a check box for the specified property. The property can be assigned one of two values, for example 0 or 1, true or false, etc.
            /// </para>
            /// <para>
            /// Occurrence: required, choice
            /// </para>
            /// <para>
            /// Regular expression: (checkbox | select | textbox | password)?
            /// </para>
            /// </summary>
            public checkboxLocalType checkbox {
                get {
                    XElement x = this.GetElement(XName.Get("checkbox", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    return ((checkboxLocalType)(x));
                }
                set {
                    this.SetElement(XName.Get("checkbox", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), value);
                }
            }
            
            /// <summary>
            /// <para>
            /// The UI displays a predetermined list of values from which the user can select.
            /// </para>
            /// <para>
            /// 
            ///                      The select element is a simple collection of option elements.
            ///                    
            ///                      The select element works in the same way as an HTML select tag. Once the developer has declared the select element, it must be populated by one or more option elements to be useful. The Octopus Console will depict the select element as a list box containing the values specified by the child option elements.
            ///                    
            /// </para>
            /// <para>
            /// Occurrence: required, choice
            /// </para>
            /// <para>
            /// Regular expression: (checkbox | select | textbox | password)?
            /// </para>
            /// </summary>
            public selectLocalType select {
                get {
                    XElement x = this.GetElement(XName.Get("select", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    return ((selectLocalType)(x));
                }
                set {
                    this.SetElement(XName.Get("select", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), value);
                }
            }
            
            /// <summary>
            /// <para>
            /// The UI displays a text box into which the user can enter any value.
            /// </para>
            /// <para>
            /// 
            ///                      The <textbox> element informs the Octopus Console that it should depict a userInput property as a text input field.
            ///                    The textbox element is used to solicit inputs from the user that take the form of a string. It is most useful in cases where the value entered by the user cannot be known in advance, such as details specific to a given network.
            /// </para>
            /// <para>
            /// Occurrence: required, choice
            /// </para>
            /// <para>
            /// Regular expression: (checkbox | select | textbox | password)?
            /// </para>
            /// </summary>
            public textboxLocalType textbox {
                get {
                    XElement x = this.GetElement(XName.Get("textbox", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    return ((textboxLocalType)(x));
                }
                set {
                    this.SetElement(XName.Get("textbox", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), value);
                }
            }
            
            /// <summary>
            /// <para>
            /// The UI displays a text box in which the value entered is masked.
            /// </para>
            /// <para>
            /// The password element instructs the Octopus Console to represent this userInput property as a password field.When a user types text into a password element, the Octopus Console will render that text as a series of bullets. Properties defined as passwords will not be written to any log files by the Octopus Deployment Framework.MSI authors are encouraged to use the MsiHiddenProperties property within the MSI file to prevent password properties from being written to the MSI log file.
            /// </para>
            /// <para>
            /// Occurrence: required, choice
            /// </para>
            /// <para>
            /// Regular expression: (checkbox | select | textbox | password)?
            /// </para>
            /// </summary>
            public passwordLocalType password {
                get {
                    XElement x = this.GetElement(XName.Get("password", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    return ((passwordLocalType)(x));
                }
                set {
                    this.SetElement(XName.Get("password", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), value);
                }
            }
            
            /// <summary>
            /// <para>
            /// A friendly string for the Octopus Console to display as the prompt for the property value.
            /// </para>
            /// <para>
            /// Occurrence: required
            /// </para>
            /// </summary>
            public string prompt {
                get {
                    XAttribute x = this.Attribute(XName.Get("prompt", ""));
                    return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
                set {
                    this.SetAttribute(XName.Get("prompt", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
            }
            
            /// <summary>
            /// <para>
            /// A friendly help text explaining the purpose of the user input in more detail.
            /// </para>
            /// <para>
            /// Occurrence: optional
            /// </para>
            /// </summary>
            public string help {
                get {
                    XAttribute x = this.Attribute(XName.Get("help", ""));
                    return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
                set {
                    this.SetAttribute(XName.Get("help", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
            }
            
            /// <summary>
            /// <para>
            /// A boolean ("true" or "false") stating whether the user must provide this input.
            /// </para>
            /// <para>
            /// Occurrence: optional
            /// </para>
            /// </summary>
            public bool required {
                get {
                    XAttribute x = this.Attribute(XName.Get("required", ""));
                    return XTypedServices.ParseValue<bool>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean).Datatype, requiredDefaultValue);
                }
                set {
                    this.SetAttribute(XName.Get("required", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean).Datatype);
                }
            }
            
            /// <summary>
            /// <para>
            /// A default value for this property that will be pre-selected by the Octopus Console.
            /// </para>
            /// <para>
            /// Occurrence: optional
            /// </para>
            /// </summary>
            public string @default {
                get {
                    XAttribute x = this.Attribute(XName.Get("default", ""));
                    return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
                set {
                    this.SetAttribute(XName.Get("default", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
            }
            
            /// <summary>
            /// <para>
            /// This property will never be persisted to the configuration file, so it will revert to its default value after each deployment session.
            /// </para>
            /// <para>
            /// Occurrence: optional
            /// </para>
            /// </summary>
            public bool persistent {
                get {
                    XAttribute x = this.Attribute(XName.Get("persistent", ""));
                    return XTypedServices.ParseValue<bool>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean).Datatype, persistentDefaultValue);
                }
                set {
                    this.SetAttribute(XName.Get("persistent", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean).Datatype);
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
                get {
                    return localElementDictionary;
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            XName IXMetaData.SchemaName {
                get {
                    return XName.Get("userInput", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            SchemaOrigin IXMetaData.TypeOrigin {
                get {
                    return SchemaOrigin.Fragment;
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            ILinqToXsdTypeManager IXMetaData.TypeManager {
                get {
                    return LinqToXsdTypeManager.Instance;
                }
            }
            
            public override XTypedElement Clone() {
                return XTypedServices.CloneXTypedElement<userInputLocalType>(this);
            }
            
            private static void BuildElementDictionary() {
                localElementDictionary.Add(XName.Get("checkbox", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(checkboxLocalType));
                localElementDictionary.Add(XName.Get("select", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(selectLocalType));
                localElementDictionary.Add(XName.Get("textbox", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(textboxLocalType));
                localElementDictionary.Add(XName.Get("password", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(passwordLocalType));
            }
            
            ContentModelEntity IXMetaData.GetContentModel() {
                return contentModel;
            }
            
            public partial class checkboxLocalType : XTypedElement, IXMetaData {
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                private static string checkedValueDefaultValue = "0";
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                private static string uncheckedValueDefaultValue = "1";
                
         public static explicit operator checkboxLocalType(XElement xe) { return XTypedServices.ToXTypedElement<checkboxLocalType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
                
                public checkboxLocalType() {
                }
                
                /// <summary>
                /// <para>
                /// The value to be passed for the property when the check box is checked.
                /// </para>
                /// <para>
                /// Occurrence: optional
                /// </para>
                /// </summary>
                public string checkedValue {
                    get {
                        XAttribute x = this.Attribute(XName.Get("checkedValue", ""));
                        return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, checkedValueDefaultValue);
                    }
                    set {
                        this.SetAttribute(XName.Get("checkedValue", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                    }
                }
                
                /// <summary>
                /// <para>
                /// The value to be passed for the property when the check box is not checked.
                /// </para>
                /// <para>
                /// Occurrence: optional
                /// </para>
                /// </summary>
                public string uncheckedValue {
                    get {
                        XAttribute x = this.Attribute(XName.Get("uncheckedValue", ""));
                        return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, uncheckedValueDefaultValue);
                    }
                    set {
                        this.SetAttribute(XName.Get("uncheckedValue", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                    }
                }
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                XName IXMetaData.SchemaName {
                    get {
                        return XName.Get("checkbox", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
                    }
                }
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                SchemaOrigin IXMetaData.TypeOrigin {
                    get {
                        return SchemaOrigin.Fragment;
                    }
                }
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                ILinqToXsdTypeManager IXMetaData.TypeManager {
                    get {
                        return LinqToXsdTypeManager.Instance;
                    }
                }
                
                public override XTypedElement Clone() {
                    return XTypedServices.CloneXTypedElement<checkboxLocalType>(this);
                }
                
                ContentModelEntity IXMetaData.GetContentModel() {
                    return ContentModelEntity.Default;
                }
            }
            
            /// <summary>
            /// <para>
            /// Regular expression: (option+)+
            /// </para>
            /// </summary>
            public partial class selectLocalType : XTypedElement, IXMetaData {
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                private XTypedList<optionLocalType> optionField;
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
                
         public static explicit operator selectLocalType(XElement xe) { return XTypedServices.ToXTypedElement<selectLocalType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
                
                static selectLocalType() {
                    BuildElementDictionary();
                }
                
                /// <summary>
                /// <para>
                /// Regular expression: (option+)+
                /// </para>
                /// </summary>
                public selectLocalType() {
                }
                
                /// <summary>
                /// <para>
                /// Defines a single value in the list from which the user can select.
                /// </para>
                /// <para>
                /// The <option> element defines a single value in a list of possible values from which the user can select.
                /// </para>
                /// <para>
                /// Occurrence: required, repeating, choice
                /// </para>
                /// <para>
                /// Regular expression: (option+)+
                /// </para>
                /// </summary>
                public IList<www.xboxlive.com.Deployment.Language.XMLSchema.xsd.SharedPropertyType.userInputLocalType.selectLocalType.optionLocalType> option {
                    get {
                        if ((this.optionField == null)) {
                            this.optionField = new XTypedList<optionLocalType>(this, LinqToXsdTypeManager.Instance, XName.Get("option", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                        }
                        return this.optionField;
                    }
                    set {
                        if ((value == null)) {
                            this.optionField = null;
                        }
                        else {
                            if ((this.optionField == null)) {
                                this.optionField = XTypedList<optionLocalType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("option", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                            }
                            else {
                                XTypedServices.SetList<optionLocalType>(this.optionField, value);
                            }
                        }
                    }
                }
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
                    get {
                        return localElementDictionary;
                    }
                }
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                XName IXMetaData.SchemaName {
                    get {
                        return XName.Get("select", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
                    }
                }
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                SchemaOrigin IXMetaData.TypeOrigin {
                    get {
                        return SchemaOrigin.Fragment;
                    }
                }
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                ILinqToXsdTypeManager IXMetaData.TypeManager {
                    get {
                        return LinqToXsdTypeManager.Instance;
                    }
                }
                
                public override XTypedElement Clone() {
                    return XTypedServices.CloneXTypedElement<selectLocalType>(this);
                }
                
                private static void BuildElementDictionary() {
                    localElementDictionary.Add(XName.Get("option", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(optionLocalType));
                }
                
                ContentModelEntity IXMetaData.GetContentModel() {
                    return ContentModelEntity.Default;
                }
                
                public partial class optionLocalType : XTypedElement, IXMetaData {
                    
         public static explicit operator optionLocalType(XElement xe) { return XTypedServices.ToXTypedElement<optionLocalType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
                    
                    public optionLocalType() {
                    }
                    
                    /// <summary>
                    /// <para>
                    /// The value to be passed for the property when this option is selected.
                    /// </para>
                    /// <para>
                    /// Occurrence: required
                    /// </para>
                    /// </summary>
                    public string value {
                        get {
                            XAttribute x = this.Attribute(XName.Get("value", ""));
                            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                        }
                        set {
                            this.SetAttribute(XName.Get("value", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                        }
                    }
                    
                    /// <summary>
                    /// <para>
                    /// The value to be displayed in the UI for this option. If the displayValue attribute is not specified, the value attribute is used both for the UI and for the actual value passed as the property value.
                    /// </para>
                    /// <para>
                    /// Occurrence: optional
                    /// </para>
                    /// </summary>
                    public string displayValue {
                        get {
                            XAttribute x = this.Attribute(XName.Get("displayValue", ""));
                            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                        }
                        set {
                            this.SetAttribute(XName.Get("displayValue", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                        }
                    }
                    
                    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                    XName IXMetaData.SchemaName {
                        get {
                            return XName.Get("option", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
                        }
                    }
                    
                    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                    SchemaOrigin IXMetaData.TypeOrigin {
                        get {
                            return SchemaOrigin.Fragment;
                        }
                    }
                    
                    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                    ILinqToXsdTypeManager IXMetaData.TypeManager {
                        get {
                            return LinqToXsdTypeManager.Instance;
                        }
                    }
                    
                    public override XTypedElement Clone() {
                        return XTypedServices.CloneXTypedElement<optionLocalType>(this);
                    }
                    
                    ContentModelEntity IXMetaData.GetContentModel() {
                        return ContentModelEntity.Default;
                    }
                }
            }
            
            public partial class textboxLocalType : XTypedElement, IXMetaData {
                
         public static explicit operator textboxLocalType(XElement xe) { return XTypedServices.ToXTypedElement<textboxLocalType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
                
                public textboxLocalType() {
                }
                
                /// <summary>
                /// <para>
                /// The maximum length imposed upon the text typed in this field.
                /// </para>
                /// <para>
                /// Occurrence: optional
                /// </para>
                /// </summary>
                public System.Nullable<decimal> length {
                    get {
                        XAttribute x = this.Attribute(XName.Get("length", ""));
                        if ((x == null)) {
                            return null;
                        }
                        return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
                    }
                    set {
                        this.SetAttribute(XName.Get("length", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
                    }
                }
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                XName IXMetaData.SchemaName {
                    get {
                        return XName.Get("textbox", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
                    }
                }
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                SchemaOrigin IXMetaData.TypeOrigin {
                    get {
                        return SchemaOrigin.Fragment;
                    }
                }
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                ILinqToXsdTypeManager IXMetaData.TypeManager {
                    get {
                        return LinqToXsdTypeManager.Instance;
                    }
                }
                
                public override XTypedElement Clone() {
                    return XTypedServices.CloneXTypedElement<textboxLocalType>(this);
                }
                
                ContentModelEntity IXMetaData.GetContentModel() {
                    return ContentModelEntity.Default;
                }
            }
            
            public partial class passwordLocalType : XTypedElement, IXMetaData {
                
         public static explicit operator passwordLocalType(XElement xe) { return XTypedServices.ToXTypedElement<passwordLocalType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
                
                public passwordLocalType() {
                }
                
                /// <summary>
                /// <para>
                /// The maximum length imposed upon the password entry field by the Octopus Console.
                /// </para>
                /// <para>
                /// Occurrence: optional
                /// </para>
                /// </summary>
                public System.Nullable<decimal> length {
                    get {
                        XAttribute x = this.Attribute(XName.Get("length", ""));
                        if ((x == null)) {
                            return null;
                        }
                        return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
                    }
                    set {
                        this.SetAttribute(XName.Get("length", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
                    }
                }
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                XName IXMetaData.SchemaName {
                    get {
                        return XName.Get("password", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
                    }
                }
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                SchemaOrigin IXMetaData.TypeOrigin {
                    get {
                        return SchemaOrigin.Fragment;
                    }
                }
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                ILinqToXsdTypeManager IXMetaData.TypeManager {
                    get {
                        return LinqToXsdTypeManager.Instance;
                    }
                }
                
                public override XTypedElement Clone() {
                    return XTypedServices.CloneXTypedElement<passwordLocalType>(this);
                }
                
                ContentModelEntity IXMetaData.GetContentModel() {
                    return ContentModelEntity.Default;
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Valid values for the servers attribute of publishComponent elements.
    /// </para>
    /// </summary>
    public sealed class PublishServersType {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                        "all",
                        "select"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
        
        private PublishServersType() {
        }
    }
    
    /// <summary>
    /// <para>
    /// Valid values for the method attribute of checkFile or checkRegistry elements.
    /// </para>
    /// </summary>
    public sealed class CompareMethodType {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                        "eq",
                        "ex",
                        "ge",
                        "gt",
                        "le",
                        "lt",
                        "neq",
                        "nex"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
        
        private CompareMethodType() {
        }
    }
    
    /// <summary>
    /// <para>
    /// Valid values for the type attribute of checkRegistry elements.
    /// </para>
    /// </summary>
    public sealed class RegistryValueType {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                        "dword",
                        "string",
                        "version"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
        
        private RegistryValueType() {
        }
    }
    
    /// <summary>
    /// <para>
    /// Valid values for the type attribute of checkValue elements.
    /// </para>
    /// </summary>
    public sealed class PropertyValueType {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                        "integer",
                        "string",
                        "version"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
        
        private PropertyValueType() {
        }
    }
    
    /// <summary>
    /// <para>
    /// Valid values for the wait attribute of requireInterface elements.
    /// </para>
    /// </summary>
    public sealed class InterfaceWaitType {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                        "all",
                        "any",
                        "same"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
        
        private InterfaceWaitType() {
        }
    }
    
    /// <summary>
    /// <para>
    /// Valid values for the type attribute of serverList elements.
    /// </para>
    /// </summary>
    public sealed class ServerListTypeType {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                        "component",
                        "publishInterface",
                        "requireInterface"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
        
        private ServerListTypeType() {
        }
    }
    
    /// <summary>
    /// <para>
    /// Valid values for the startup attribute of CheckService elements.
    /// </para>
    /// </summary>
    public sealed class ServiceStartupType {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                        "automatic",
                        "disabled",
                        "enabled",
                        "manual",
                        "ignore"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
        
        private ServiceStartupType() {
        }
    }
    
    /// <summary>
    /// <para>
    /// Valid values for the status attribute of CheckService elements.
    /// </para>
    /// </summary>
    public sealed class ServiceStatusType {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                        "absent",
                        "started",
                        "stopped",
                        "ignore"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
        
        private ServiceStatusType() {
        }
    }
    
    /// <summary>
    /// <para>
    /// Valid values for the type attribute of statusCode elements.
    /// </para>
    /// </summary>
    public sealed class StatusCodeTypeType {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                        "failure",
                        "warning",
                        "success",
                        "success_reboot",
                        "reboot_rerun"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
        
        private StatusCodeTypeType() {
        }
    }
    
    /// <summary>
    /// <para>
    /// A set of checks to be performed at the domain level before beginning deployment.
    /// </para>
    /// <para>
    /// 
    ///            The <domainChecks> element describes one or more atomic checks that will be performed before the Octopus Deployment Framework acts upon the surrounding service or topology element. All of the child elements of the check must return successfully for the domainChecks element to return success.
    ///          
    ///            This element lists check operations that are meaningful in the context of a Windows domain. This distinguishes domainChecks from the checks under a component element, which are meaningful in the context of an individual server.
    ///          
    ///            Domain checks are useful to detect flawed system setups before proceeding with a full deployment. In many Operatonal environments, access to the Active Directory is restricted, meaning that domain users and groups must be created manually in advance of automated deployment. If an account is mis-named, has the wrong password, or is not a member of the correct groups, installation might proceed despite the fact that the service will not run correctly. Developers can require domain checks before deploying to avoid this problem.
    ///          
    ///            The Octopus Deployment Framework and Console support a "check only" mode in which all checks are run against a set of servers, but no components are executed. Operators can run a "check only" test against their bed before committing time to a full deployment.
    ///          
    /// </para>
    /// <para>
    /// Regular expression: (checkUser* | checkGroup* | checkGroupMembership* | checkDrive* | checkFile* | checkFolder* | checkValue* | checkRegistry* | checkService* | checkWebSite* | commandCheck* | not* | or* | and* | @true* | @false* | any)+
    /// </para>
    /// </summary>
    public partial class DomainChecksType : global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.ChecksType, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static FSM validationStates;
        
         public static explicit operator DomainChecksType(XElement xe) { return XTypedServices.ToXTypedElement<DomainChecksType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static DomainChecksType() {
            BuildElementDictionary();
            InitFSM();
        }
        
        /// <summary>
        /// <para>
        /// A set of checks to be performed at the domain level before beginning deployment.
        /// </para>
        /// <para>
        /// 
        ///            The <domainChecks> element describes one or more atomic checks that will be performed before the Octopus Deployment Framework acts upon the surrounding service or topology element. All of the child elements of the check must return successfully for the domainChecks element to return success.
        ///          
        ///            This element lists check operations that are meaningful in the context of a Windows domain. This distinguishes domainChecks from the checks under a component element, which are meaningful in the context of an individual server.
        ///          
        ///            Domain checks are useful to detect flawed system setups before proceeding with a full deployment. In many Operatonal environments, access to the Active Directory is restricted, meaning that domain users and groups must be created manually in advance of automated deployment. If an account is mis-named, has the wrong password, or is not a member of the correct groups, installation might proceed despite the fact that the service will not run correctly. Developers can require domain checks before deploying to avoid this problem.
        ///          
        ///            The Octopus Deployment Framework and Console support a "check only" mode in which all checks are run against a set of servers, but no components are executed. Operators can run a "check only" test against their bed before committing time to a full deployment.
        ///          
        /// </para>
        /// <para>
        /// Regular expression: (checkUser* | checkGroup* | checkGroupMembership* | checkDrive* | checkFile* | checkFolder* | checkValue* | checkRegistry* | checkService* | checkWebSite* | commandCheck* | not* | or* | and* | @true* | @false* | any)+
        /// </para>
        /// </summary>
        public DomainChecksType() {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("DomainChecksType", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<DomainChecksType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(CheckUser));
            localElementDictionary.Add(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(CheckGroup));
            localElementDictionary.Add(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(CheckGroupMembership));
            localElementDictionary.Add(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(CheckDrive));
            localElementDictionary.Add(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(CheckFile));
            localElementDictionary.Add(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(CheckFolder));
            localElementDictionary.Add(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(CheckValue));
            localElementDictionary.Add(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(CheckRegistry));
            localElementDictionary.Add(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(CheckService));
            localElementDictionary.Add(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(CheckWebSite));
            localElementDictionary.Add(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(CommandCheck));
            localElementDictionary.Add(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(LogicalCheck));
            localElementDictionary.Add(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(LogicalCheck));
            localElementDictionary.Add(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(LogicalCheck));
            localElementDictionary.Add(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(XTypedElement));
            localElementDictionary.Add(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(XTypedElement));
        }
        
        FSM IXMetaData.GetValidationStates() {
            return validationStates;
        }
        
        private static void InitFSM() {
            Dictionary<int, Transitions> transitions = new Dictionary<int, Transitions>();
            transitions.Add(1, new Transitions(new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            transitions.Add(3, new Transitions(new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            transitions.Add(5, new Transitions(new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            transitions.Add(7, new Transitions(new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            transitions.Add(9, new Transitions(new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            transitions.Add(11, new Transitions(new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            transitions.Add(13, new Transitions(new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            transitions.Add(15, new Transitions(new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            transitions.Add(17, new Transitions(new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            transitions.Add(19, new Transitions(new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            transitions.Add(21, new Transitions(new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            transitions.Add(23, new Transitions(new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            transitions.Add(25, new Transitions(new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            transitions.Add(27, new Transitions(new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            transitions.Add(29, new Transitions(new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            transitions.Add(31, new Transitions(new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            transitions.Add(33, new Transitions(new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            validationStates = new FSM(1, new Set<int>(new int[] {
                            1,
                            3,
                            5,
                            7,
                            9,
                            11,
                            13,
                            15,
                            17,
                            19,
                            21,
                            23,
                            25,
                            27,
                            29,
                            31,
                            33}), transitions);
        }
    }
    
    /// <summary>
    /// <para>
    /// A property to be passed to a lower-level entity.
    /// </para>
    /// <para>
    /// The passProperty element is used to override the value of a property in a published or aggregated component with the value of a local property or static value.The passProperty 'value' attribute may refer to the value of another property - for example a local userInput property - as though it were a variable. This is done by placing the name of the referenced property between square brackets. For example, the value of property 'foo' may be set to "my name is [bar]". This will reference the value of the property named 'bar' and replace the string '[bar]' with that value. If the value of 'bar' were 'Susan', then the value of 'foo' would be "my name is Susan".Of course, the 'value' attribute of passProperty may also be a static value defined by the service manifest developer.
    /// </para>
    /// </summary>
    public partial class PassPropertyType : XTypedElement, IXMetaData {
        
         public static explicit operator PassPropertyType(XElement xe) { return XTypedServices.ToXTypedElement<PassPropertyType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        /// <summary>
        /// <para>
        /// A property to be passed to a lower-level entity.
        /// </para>
        /// <para>
        /// The passProperty element is used to override the value of a property in a published or aggregated component with the value of a local property or static value.The passProperty 'value' attribute may refer to the value of another property - for example a local userInput property - as though it were a variable. This is done by placing the name of the referenced property between square brackets. For example, the value of property 'foo' may be set to "my name is [bar]". This will reference the value of the property named 'bar' and replace the string '[bar]' with that value. If the value of 'bar' were 'Susan', then the value of 'foo' would be "my name is Susan".Of course, the 'value' attribute of passProperty may also be a static value defined by the service manifest developer.
        /// </para>
        /// </summary>
        public PassPropertyType() {
        }
        
        /// <summary>
        /// <para>
        /// The name of the property being overridden.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public string name {
            get {
                XAttribute x = this.Attribute(XName.Get("name", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("name", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The value to use for the property.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public string value {
            get {
                XAttribute x = this.Attribute(XName.Get("value", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("value", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("PassPropertyType", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<PassPropertyType>(this);
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    /// <summary>
    /// <para>
    /// A property definition.
    /// </para>
    /// <para>
    /// 
    ///            The <property> element is used throughout a service manifest to obtain user input and reconcile that input with predefined values. The values of properties may be entered by users, set as static strings, based upon values from previous properties, or set to a list of servers in the configuration at deployment time.
    ///            The value set by the <property> element may be overridden as part of a publishComponent or aggregateComponent element.
    ///          
    ///            Properties are necessary for many Microsoft Windows Installer files, which forms the basis of their inclusion in the Octopus Deployment Framework. Developers are free to place all properties in the msi elements of components if that is simplest, but other more flexible manifests are possible. For example, a set of properties may be defined at the topology level which are then inherited by published components. Or, a component may override a static property value with a user-provided value by using passProperty when aggregating another component.
    ///          
    ///            The property 'value' attribute may refer to the value of another property as though it were a variable. This is done by placing the name of the referenced property between square brackets. For example, the value of property 'foo' may be set to "my name is [bar]". This will reference the value of the property named 'bar' and replace the string '[bar]' with that value. If the value of 'bar' were 'Susan', then the value of 'foo' would be "my name is Susan".
    ///          
    /// </para>
    /// <para>
    /// Regular expression: (serverList | userInput | any)?
    /// </para>
    /// </summary>
    public partial class PropertyType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static FSM validationStates;
        
         public static explicit operator PropertyType(XElement xe) { return XTypedServices.ToXTypedElement<PropertyType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static PropertyType() {
            BuildElementDictionary();
            InitFSM();
        }
        
        /// <summary>
        /// <para>
        /// A property definition.
        /// </para>
        /// <para>
        /// 
        ///            The <property> element is used throughout a service manifest to obtain user input and reconcile that input with predefined values. The values of properties may be entered by users, set as static strings, based upon values from previous properties, or set to a list of servers in the configuration at deployment time.
        ///            The value set by the <property> element may be overridden as part of a publishComponent or aggregateComponent element.
        ///          
        ///            Properties are necessary for many Microsoft Windows Installer files, which forms the basis of their inclusion in the Octopus Deployment Framework. Developers are free to place all properties in the msi elements of components if that is simplest, but other more flexible manifests are possible. For example, a set of properties may be defined at the topology level which are then inherited by published components. Or, a component may override a static property value with a user-provided value by using passProperty when aggregating another component.
        ///          
        ///            The property 'value' attribute may refer to the value of another property as though it were a variable. This is done by placing the name of the referenced property between square brackets. For example, the value of property 'foo' may be set to "my name is [bar]". This will reference the value of the property named 'bar' and replace the string '[bar]' with that value. If the value of 'bar' were 'Susan', then the value of 'foo' would be "my name is Susan".
        ///          
        /// </para>
        /// <para>
        /// Regular expression: (serverList | userInput | any)?
        /// </para>
        /// </summary>
        public PropertyType() {
        }
        
        public PropertyType(serverListLocalType serverList) {
            this.serverList = serverList;
        }
        
        public PropertyType(userInputLocalType userInput) {
            this.userInput = userInput;
        }
        
        /// <summary>
        /// <para>
        /// The property value is set to a list of servers meeting specified criteria.
        /// </para>
        /// <para>
        /// The <serverList> element sets the value of the parent property to a list of servers based on the roles and components assigned to servers at deployment time.The serverList element is useful to automatically determine the server name used for a particular component. For example, if a front end component needs to know the name of the database server, a property for the front end MSI file could be to a server list with type="component" and the name of the database component.
        /// </para>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Regular expression: (serverList | userInput | any)?
        /// </para>
        /// </summary>
        public serverListLocalType serverList {
            get {
                XElement x = this.GetElement(XName.Get("serverList", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                return ((serverListLocalType)(x));
            }
            set {
                this.SetElement(XName.Get("serverList", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), value);
            }
        }
        
        /// <summary>
        /// <para>
        /// The property value can be entered by the user at deployment time.
        /// </para>
        /// <para>
        /// 
        ///                The <userInput> element instructs the Octopus Console to solicit user input for the value of the parent property.
        ///              
        ///                The userInput element is useful at many levels in the service manifest. It can be used anywhere a property is allowed. At the upper levels of the service manifest (service or topology), userInput is used for property values that are shared by multiple components. At intermediate levels, userInput is useful for overriding properties lower down. A developer can solicit user input for a property at one level, and then use passProperty to override the default or static values of properties in an aggregated component at the next level down. At the component or MSI level, userInput allows the deployment operator to enter detailed configuration values for that individual component.
        ///              
        /// </para>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Regular expression: (serverList | userInput | any)?
        /// </para>
        /// </summary>
        public userInputLocalType userInput {
            get {
                XElement x = this.GetElement(XName.Get("userInput", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                return ((userInputLocalType)(x));
            }
            set {
                this.SetElement(XName.Get("userInput", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), value);
            }
        }
        
        /// <summary>
        /// <para>
        /// Regular expression: (serverList | userInput | any)?
        /// </para>
        /// </summary>
        public IEnumerable<XElement> Any {
            get {
                return this.GetWildCards(WildCard.DefaultWildCard);
            }
        }
        
        /// <summary>
        /// <para>
        /// The name of this property. Property names must start and end with a letter or digit; and may include letters, digits, underscores, spaces, periods or dashes between the first and last character.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public string name {
            get {
                XAttribute x = this.Attribute(XName.Get("name", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("name", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// A static or variable-based value for this property.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public string value {
            get {
                XAttribute x = this.Attribute(XName.Get("value", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("value", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("PropertyType", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<PropertyType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(XName.Get("serverList", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(serverListLocalType));
            localElementDictionary.Add(XName.Get("userInput", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(userInputLocalType));
        }
        
        FSM IXMetaData.GetValidationStates() {
            return validationStates;
        }
        
        private static void InitFSM() {
            Dictionary<int, Transitions> transitions = new Dictionary<int, Transitions>();
            transitions.Add(1, new Transitions(new SingleTransition(XName.Get("serverList", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 2), new SingleTransition(XName.Get("userInput", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 4), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 6)));
            validationStates = new FSM(1, new Set<int>(new int[] {
                            2,
                            4,
                            6,
                            1}), transitions);
        }
        
        public partial class serverListLocalType : XTypedElement, IXMetaData {
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private static string separatorDefaultValue = ",";
            
         public static explicit operator serverListLocalType(XElement xe) { return XTypedServices.ToXTypedElement<serverListLocalType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
            
            public serverListLocalType() {
            }
            
            /// <summary>
            /// <para>
            /// The type of server list to generate.
            /// </para>
            /// <para>
            /// The type attribute may take one of the following values:componentThe list will include all servers which include the component specified by the name attribute.publishInterfaceThe list will include all servers which include a component that publishes the interface specified by the name attribute.requireInterfaceThe list will include all servers which include a component that requires the interface specified by the name attribute.
            /// </para>
            /// <para>
            /// Occurrence: required
            /// </para>
            /// </summary>
            public string type {
                get {
                    XAttribute x = this.Attribute(XName.Get("type", ""));
                    return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
                set {
                    this.SetAttribute(XName.Get("type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
            }
            
            /// <summary>
            /// <para>
            /// The name of the component, publishInterface or requireInterface from which to construct the list of servers.
            /// </para>
            /// <para>
            /// Occurrence: required
            /// </para>
            /// </summary>
            public string name {
                get {
                    XAttribute x = this.Attribute(XName.Get("name", ""));
                    return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
                set {
                    this.SetAttribute(XName.Get("name", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
            }
            
            /// <summary>
            /// <para>
            /// The string with which to separate the server names in the list.
            /// </para>
            /// <para>
            /// Occurrence: optional
            /// </para>
            /// </summary>
            public string separator {
                get {
                    XAttribute x = this.Attribute(XName.Get("separator", ""));
                    return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, separatorDefaultValue);
                }
                set {
                    this.SetAttribute(XName.Get("separator", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            XName IXMetaData.SchemaName {
                get {
                    return XName.Get("serverList", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            SchemaOrigin IXMetaData.TypeOrigin {
                get {
                    return SchemaOrigin.Fragment;
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            ILinqToXsdTypeManager IXMetaData.TypeManager {
                get {
                    return LinqToXsdTypeManager.Instance;
                }
            }
            
            public override XTypedElement Clone() {
                return XTypedServices.CloneXTypedElement<serverListLocalType>(this);
            }
            
            ContentModelEntity IXMetaData.GetContentModel() {
                return ContentModelEntity.Default;
            }
        }
        
        /// <summary>
        /// <para>
        /// Regular expression: (checkbox | select | textbox | password)?
        /// </para>
        /// </summary>
        public partial class userInputLocalType : XTypedElement, IXMetaData {
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private static bool requiredDefaultValue = System.Xml.XmlConvert.ToBoolean("true");
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private static bool persistentDefaultValue = System.Xml.XmlConvert.ToBoolean("true");
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private static ContentModelEntity contentModel;
            
         public static explicit operator userInputLocalType(XElement xe) { return XTypedServices.ToXTypedElement<userInputLocalType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
            
            static userInputLocalType() {
                BuildElementDictionary();
                contentModel = new ChoiceContentModelEntity(new NamedContentModelEntity(XName.Get("checkbox", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd")), new NamedContentModelEntity(XName.Get("select", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd")), new NamedContentModelEntity(XName.Get("textbox", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd")), new NamedContentModelEntity(XName.Get("password", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd")));
            }
            
            /// <summary>
            /// <para>
            /// Regular expression: (checkbox | select | textbox | password)?
            /// </para>
            /// </summary>
            public userInputLocalType() {
            }
            
            public userInputLocalType(checkboxLocalType checkbox) {
                this.checkbox = checkbox;
            }
            
            public userInputLocalType(selectLocalType select) {
                this.select = select;
            }
            
            public userInputLocalType(textboxLocalType textbox) {
                this.textbox = textbox;
            }
            
            public userInputLocalType(passwordLocalType password) {
                this.password = password;
            }
            
            /// <summary>
            /// <para>
            /// The UI displays a check box.
            /// </para>
            /// <para>
            /// The <checkbox> user input element indicates that the UI should display a check box for the specified property. The property can be assigned one of two values, for example 0 or 1, true or false, etc.
            /// </para>
            /// <para>
            /// Occurrence: required, choice
            /// </para>
            /// <para>
            /// Regular expression: (checkbox | select | textbox | password)?
            /// </para>
            /// </summary>
            public checkboxLocalType checkbox {
                get {
                    XElement x = this.GetElement(XName.Get("checkbox", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    return ((checkboxLocalType)(x));
                }
                set {
                    this.SetElement(XName.Get("checkbox", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), value);
                }
            }
            
            /// <summary>
            /// <para>
            /// The UI displays a predetermined list of values from which the user can select.
            /// </para>
            /// <para>
            /// 
            ///                      The select element is a simple collection of option elements.
            ///                    
            ///                      The select element works in the same way as an HTML select tag. Once the developer has declared the select element, it must be populated by one or more option elements to be useful. The Octopus Console will depict the select element as a list box containing the values specified by the child option elements.
            ///                    
            /// </para>
            /// <para>
            /// Occurrence: required, choice
            /// </para>
            /// <para>
            /// Regular expression: (checkbox | select | textbox | password)?
            /// </para>
            /// </summary>
            public selectLocalType select {
                get {
                    XElement x = this.GetElement(XName.Get("select", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    return ((selectLocalType)(x));
                }
                set {
                    this.SetElement(XName.Get("select", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), value);
                }
            }
            
            /// <summary>
            /// <para>
            /// The UI displays a text box into which the user can enter any value.
            /// </para>
            /// <para>
            /// 
            ///                      The <textbox> element informs the Octopus Console that it should depict a userInput property as a text input field.
            ///                    The textbox element is used to solicit inputs from the user that take the form of a string. It is most useful in cases where the value entered by the user cannot be known in advance, such as details specific to a given network.
            /// </para>
            /// <para>
            /// Occurrence: required, choice
            /// </para>
            /// <para>
            /// Regular expression: (checkbox | select | textbox | password)?
            /// </para>
            /// </summary>
            public textboxLocalType textbox {
                get {
                    XElement x = this.GetElement(XName.Get("textbox", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    return ((textboxLocalType)(x));
                }
                set {
                    this.SetElement(XName.Get("textbox", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), value);
                }
            }
            
            /// <summary>
            /// <para>
            /// The UI displays a text box in which the value entered is masked.
            /// </para>
            /// <para>
            /// The password element instructs the Octopus Console to represent this userInput property as a password field.When a user types text into a password element, the Octopus Console will render that text as a series of bullets. Properties defined as passwords will not be written to any log files by the Octopus Deployment Framework.MSI authors are encouraged to use the MsiHiddenProperties property within the MSI file to prevent password properties from being written to the MSI log file.
            /// </para>
            /// <para>
            /// Occurrence: required, choice
            /// </para>
            /// <para>
            /// Regular expression: (checkbox | select | textbox | password)?
            /// </para>
            /// </summary>
            public passwordLocalType password {
                get {
                    XElement x = this.GetElement(XName.Get("password", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    return ((passwordLocalType)(x));
                }
                set {
                    this.SetElement(XName.Get("password", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), value);
                }
            }
            
            /// <summary>
            /// <para>
            /// A friendly string for the Octopus Console to display as the prompt for the property value.
            /// </para>
            /// <para>
            /// Occurrence: required
            /// </para>
            /// </summary>
            public string prompt {
                get {
                    XAttribute x = this.Attribute(XName.Get("prompt", ""));
                    return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
                set {
                    this.SetAttribute(XName.Get("prompt", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
            }
            
            /// <summary>
            /// <para>
            /// A friendly help text explaining the purpose of the user input in more detail.
            /// </para>
            /// <para>
            /// Occurrence: optional
            /// </para>
            /// </summary>
            public string help {
                get {
                    XAttribute x = this.Attribute(XName.Get("help", ""));
                    return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
                set {
                    this.SetAttribute(XName.Get("help", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
            }
            
            /// <summary>
            /// <para>
            /// A boolean ("true" or "false") stating whether the user must provide this input.
            /// </para>
            /// <para>
            /// Occurrence: optional
            /// </para>
            /// </summary>
            public bool required {
                get {
                    XAttribute x = this.Attribute(XName.Get("required", ""));
                    return XTypedServices.ParseValue<bool>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean).Datatype, requiredDefaultValue);
                }
                set {
                    this.SetAttribute(XName.Get("required", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean).Datatype);
                }
            }
            
            /// <summary>
            /// <para>
            /// A default value for this property that will be pre-selected by the Octopus Console.
            /// </para>
            /// <para>
            /// Occurrence: optional
            /// </para>
            /// </summary>
            public string @default {
                get {
                    XAttribute x = this.Attribute(XName.Get("default", ""));
                    return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
                set {
                    this.SetAttribute(XName.Get("default", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
            }
            
            /// <summary>
            /// <para>
            /// This property will never be persisted to the configuration file, so it will revert to its default value after each deployment session.
            /// </para>
            /// <para>
            /// Occurrence: optional
            /// </para>
            /// </summary>
            public bool persistent {
                get {
                    XAttribute x = this.Attribute(XName.Get("persistent", ""));
                    return XTypedServices.ParseValue<bool>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean).Datatype, persistentDefaultValue);
                }
                set {
                    this.SetAttribute(XName.Get("persistent", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean).Datatype);
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
                get {
                    return localElementDictionary;
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            XName IXMetaData.SchemaName {
                get {
                    return XName.Get("userInput", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            SchemaOrigin IXMetaData.TypeOrigin {
                get {
                    return SchemaOrigin.Fragment;
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            ILinqToXsdTypeManager IXMetaData.TypeManager {
                get {
                    return LinqToXsdTypeManager.Instance;
                }
            }
            
            public override XTypedElement Clone() {
                return XTypedServices.CloneXTypedElement<userInputLocalType>(this);
            }
            
            private static void BuildElementDictionary() {
                localElementDictionary.Add(XName.Get("checkbox", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(checkboxLocalType));
                localElementDictionary.Add(XName.Get("select", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(selectLocalType));
                localElementDictionary.Add(XName.Get("textbox", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(textboxLocalType));
                localElementDictionary.Add(XName.Get("password", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(passwordLocalType));
            }
            
            ContentModelEntity IXMetaData.GetContentModel() {
                return contentModel;
            }
            
            public partial class checkboxLocalType : XTypedElement, IXMetaData {
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                private static string checkedValueDefaultValue = "0";
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                private static string uncheckedValueDefaultValue = "1";
                
         public static explicit operator checkboxLocalType(XElement xe) { return XTypedServices.ToXTypedElement<checkboxLocalType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
                
                public checkboxLocalType() {
                }
                
                /// <summary>
                /// <para>
                /// The value to be passed for the property when the check box is checked.
                /// </para>
                /// <para>
                /// Occurrence: optional
                /// </para>
                /// </summary>
                public string checkedValue {
                    get {
                        XAttribute x = this.Attribute(XName.Get("checkedValue", ""));
                        return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, checkedValueDefaultValue);
                    }
                    set {
                        this.SetAttribute(XName.Get("checkedValue", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                    }
                }
                
                /// <summary>
                /// <para>
                /// The value to be passed for the property when the check box is not checked.
                /// </para>
                /// <para>
                /// Occurrence: optional
                /// </para>
                /// </summary>
                public string uncheckedValue {
                    get {
                        XAttribute x = this.Attribute(XName.Get("uncheckedValue", ""));
                        return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, uncheckedValueDefaultValue);
                    }
                    set {
                        this.SetAttribute(XName.Get("uncheckedValue", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                    }
                }
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                XName IXMetaData.SchemaName {
                    get {
                        return XName.Get("checkbox", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
                    }
                }
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                SchemaOrigin IXMetaData.TypeOrigin {
                    get {
                        return SchemaOrigin.Fragment;
                    }
                }
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                ILinqToXsdTypeManager IXMetaData.TypeManager {
                    get {
                        return LinqToXsdTypeManager.Instance;
                    }
                }
                
                public override XTypedElement Clone() {
                    return XTypedServices.CloneXTypedElement<checkboxLocalType>(this);
                }
                
                ContentModelEntity IXMetaData.GetContentModel() {
                    return ContentModelEntity.Default;
                }
            }
            
            /// <summary>
            /// <para>
            /// Regular expression: (option+)+
            /// </para>
            /// </summary>
            public partial class selectLocalType : XTypedElement, IXMetaData {
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                private XTypedList<optionLocalType> optionField;
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
                
         public static explicit operator selectLocalType(XElement xe) { return XTypedServices.ToXTypedElement<selectLocalType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
                
                static selectLocalType() {
                    BuildElementDictionary();
                }
                
                /// <summary>
                /// <para>
                /// Regular expression: (option+)+
                /// </para>
                /// </summary>
                public selectLocalType() {
                }
                
                /// <summary>
                /// <para>
                /// Defines a single value in the list from which the user can select.
                /// </para>
                /// <para>
                /// The <option> element defines a single value in a list of possible values from which the user can select.
                /// </para>
                /// <para>
                /// Occurrence: required, repeating, choice
                /// </para>
                /// <para>
                /// Regular expression: (option+)+
                /// </para>
                /// </summary>
                public IList<www.xboxlive.com.Deployment.Language.XMLSchema.xsd.PropertyType.userInputLocalType.selectLocalType.optionLocalType> option {
                    get {
                        if ((this.optionField == null)) {
                            this.optionField = new XTypedList<optionLocalType>(this, LinqToXsdTypeManager.Instance, XName.Get("option", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                        }
                        return this.optionField;
                    }
                    set {
                        if ((value == null)) {
                            this.optionField = null;
                        }
                        else {
                            if ((this.optionField == null)) {
                                this.optionField = XTypedList<optionLocalType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("option", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                            }
                            else {
                                XTypedServices.SetList<optionLocalType>(this.optionField, value);
                            }
                        }
                    }
                }
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
                    get {
                        return localElementDictionary;
                    }
                }
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                XName IXMetaData.SchemaName {
                    get {
                        return XName.Get("select", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
                    }
                }
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                SchemaOrigin IXMetaData.TypeOrigin {
                    get {
                        return SchemaOrigin.Fragment;
                    }
                }
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                ILinqToXsdTypeManager IXMetaData.TypeManager {
                    get {
                        return LinqToXsdTypeManager.Instance;
                    }
                }
                
                public override XTypedElement Clone() {
                    return XTypedServices.CloneXTypedElement<selectLocalType>(this);
                }
                
                private static void BuildElementDictionary() {
                    localElementDictionary.Add(XName.Get("option", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(optionLocalType));
                }
                
                ContentModelEntity IXMetaData.GetContentModel() {
                    return ContentModelEntity.Default;
                }
                
                public partial class optionLocalType : XTypedElement, IXMetaData {
                    
         public static explicit operator optionLocalType(XElement xe) { return XTypedServices.ToXTypedElement<optionLocalType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
                    
                    public optionLocalType() {
                    }
                    
                    /// <summary>
                    /// <para>
                    /// The value to be passed for the property when this option is selected.
                    /// </para>
                    /// <para>
                    /// Occurrence: required
                    /// </para>
                    /// </summary>
                    public string value {
                        get {
                            XAttribute x = this.Attribute(XName.Get("value", ""));
                            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                        }
                        set {
                            this.SetAttribute(XName.Get("value", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                        }
                    }
                    
                    /// <summary>
                    /// <para>
                    /// The value to be displayed in the UI for this option. If the displayValue attribute is not specified, the value attribute is used both for the UI and for the actual value passed as the property value.
                    /// </para>
                    /// <para>
                    /// Occurrence: optional
                    /// </para>
                    /// </summary>
                    public string displayValue {
                        get {
                            XAttribute x = this.Attribute(XName.Get("displayValue", ""));
                            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                        }
                        set {
                            this.SetAttribute(XName.Get("displayValue", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                        }
                    }
                    
                    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                    XName IXMetaData.SchemaName {
                        get {
                            return XName.Get("option", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
                        }
                    }
                    
                    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                    SchemaOrigin IXMetaData.TypeOrigin {
                        get {
                            return SchemaOrigin.Fragment;
                        }
                    }
                    
                    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                    ILinqToXsdTypeManager IXMetaData.TypeManager {
                        get {
                            return LinqToXsdTypeManager.Instance;
                        }
                    }
                    
                    public override XTypedElement Clone() {
                        return XTypedServices.CloneXTypedElement<optionLocalType>(this);
                    }
                    
                    ContentModelEntity IXMetaData.GetContentModel() {
                        return ContentModelEntity.Default;
                    }
                }
            }
            
            public partial class textboxLocalType : XTypedElement, IXMetaData {
                
         public static explicit operator textboxLocalType(XElement xe) { return XTypedServices.ToXTypedElement<textboxLocalType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
                
                public textboxLocalType() {
                }
                
                /// <summary>
                /// <para>
                /// The maximum length imposed upon the text typed in this field.
                /// </para>
                /// <para>
                /// Occurrence: optional
                /// </para>
                /// </summary>
                public System.Nullable<decimal> length {
                    get {
                        XAttribute x = this.Attribute(XName.Get("length", ""));
                        if ((x == null)) {
                            return null;
                        }
                        return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
                    }
                    set {
                        this.SetAttribute(XName.Get("length", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
                    }
                }
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                XName IXMetaData.SchemaName {
                    get {
                        return XName.Get("textbox", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
                    }
                }
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                SchemaOrigin IXMetaData.TypeOrigin {
                    get {
                        return SchemaOrigin.Fragment;
                    }
                }
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                ILinqToXsdTypeManager IXMetaData.TypeManager {
                    get {
                        return LinqToXsdTypeManager.Instance;
                    }
                }
                
                public override XTypedElement Clone() {
                    return XTypedServices.CloneXTypedElement<textboxLocalType>(this);
                }
                
                ContentModelEntity IXMetaData.GetContentModel() {
                    return ContentModelEntity.Default;
                }
            }
            
            public partial class passwordLocalType : XTypedElement, IXMetaData {
                
         public static explicit operator passwordLocalType(XElement xe) { return XTypedServices.ToXTypedElement<passwordLocalType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
                
                public passwordLocalType() {
                }
                
                /// <summary>
                /// <para>
                /// The maximum length imposed upon the password entry field by the Octopus Console.
                /// </para>
                /// <para>
                /// Occurrence: optional
                /// </para>
                /// </summary>
                public System.Nullable<decimal> length {
                    get {
                        XAttribute x = this.Attribute(XName.Get("length", ""));
                        if ((x == null)) {
                            return null;
                        }
                        return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
                    }
                    set {
                        this.SetAttribute(XName.Get("length", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
                    }
                }
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                XName IXMetaData.SchemaName {
                    get {
                        return XName.Get("password", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
                    }
                }
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                SchemaOrigin IXMetaData.TypeOrigin {
                    get {
                        return SchemaOrigin.Fragment;
                    }
                }
                
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                ILinqToXsdTypeManager IXMetaData.TypeManager {
                    get {
                        return LinqToXsdTypeManager.Instance;
                    }
                }
                
                public override XTypedElement Clone() {
                    return XTypedServices.CloneXTypedElement<passwordLocalType>(this);
                }
                
                ContentModelEntity IXMetaData.GetContentModel() {
                    return ContentModelEntity.Default;
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// An aggregation of one component within another.
    /// </para>
    /// <para>
    /// 
    ///            The <aggregateComponent> element names another
    ///            component
    ///            whose elements will be aggregated into the current component.
    ///            Aggregation creates a copy of the elements and properties of the aggregated
    ///            component and places them in the current component.
    ///          
    ///            The aggregateComponent element is commonly used to build
    ///            published components from smaller foundational components.
    ///            This is useful for convenience when defining multiple topologies for a service.
    ///            For example, a one-box development topology could publish a single component.
    ///            That component could aggregate several other components that ordinarily would be
    ///            published independently in a larger topology.
    ///          
    ///            The passProperty element is used in these situations to override static values
    ///            in aggregated components.
    ///          
    /// </para>
    /// <para>
    /// Regular expression: (passProperty*)*
    /// </para>
    /// </summary>
    public partial class AggregateComponentType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<PassPropertyType> passPropertyField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
        
         public static explicit operator AggregateComponentType(XElement xe) { return XTypedServices.ToXTypedElement<AggregateComponentType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static AggregateComponentType() {
            BuildElementDictionary();
        }
        
        /// <summary>
        /// <para>
        /// An aggregation of one component within another.
        /// </para>
        /// <para>
        /// 
        ///            The <aggregateComponent> element names another
        ///            component
        ///            whose elements will be aggregated into the current component.
        ///            Aggregation creates a copy of the elements and properties of the aggregated
        ///            component and places them in the current component.
        ///          
        ///            The aggregateComponent element is commonly used to build
        ///            published components from smaller foundational components.
        ///            This is useful for convenience when defining multiple topologies for a service.
        ///            For example, a one-box development topology could publish a single component.
        ///            That component could aggregate several other components that ordinarily would be
        ///            published independently in a larger topology.
        ///          
        ///            The passProperty element is used in these situations to override static values
        ///            in aggregated components.
        ///          
        /// </para>
        /// <para>
        /// Regular expression: (passProperty*)*
        /// </para>
        /// </summary>
        public AggregateComponentType() {
        }
        
        /// <summary>
        /// <para>
        /// Specifies a value that overrides the value of an aggregated property.
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (passProperty*)*
        /// </para>
        /// </summary>
        public IList<PassPropertyType> passProperty {
            get {
                if ((this.passPropertyField == null)) {
                    this.passPropertyField = new XTypedList<PassPropertyType>(this, LinqToXsdTypeManager.Instance, XName.Get("passProperty", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                }
                return this.passPropertyField;
            }
            set {
                if ((value == null)) {
                    this.passPropertyField = null;
                }
                else {
                    if ((this.passPropertyField == null)) {
                        this.passPropertyField = XTypedList<PassPropertyType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("passProperty", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    else {
                        XTypedServices.SetList<PassPropertyType>(this.passPropertyField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// The name of the component to aggregate.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public string name {
            get {
                XAttribute x = this.Attribute(XName.Get("name", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("name", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("AggregateComponentType", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<AggregateComponentType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(XName.Get("passProperty", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(PassPropertyType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    /// <summary>
    /// <para>
    /// The <checkUser> element names a user in the global catalog that will be checked for existence. Optionally the user's password may also be checked.In many Operations environments, accounts are created by hand in order to maintain restrictions upon the way the Active Directory is manipulated. In these situations, it is important to verify that user names and passwords specified for service accounts are correct before starting deployment. By stating a username and password, the Octopus Engine will attempt a logon against that user and verify success.Passwords should never be hard-coded in the service.xml file. Instead specify the password attribute as the value of a user-input property to be entered by the Operator through the Octopus Console. The is done with the syntax: password="[Property]".
    /// </para>
    /// </summary>
    public partial class CheckUser : global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.Check, IXMetaData {
        
         public static explicit operator CheckUser(XElement xe) { return XTypedServices.ToXTypedElement<CheckUser>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        /// <summary>
        /// <para>
        /// The <checkUser> element names a user in the global catalog that will be checked for existence. Optionally the user's password may also be checked.In many Operations environments, accounts are created by hand in order to maintain restrictions upon the way the Active Directory is manipulated. In these situations, it is important to verify that user names and passwords specified for service accounts are correct before starting deployment. By stating a username and password, the Octopus Engine will attempt a logon against that user and verify success.Passwords should never be hard-coded in the service.xml file. Instead specify the password attribute as the value of a user-input property to be entered by the Operator through the Octopus Console. The is done with the syntax: password="[Property]".
        /// </para>
        /// </summary>
        public CheckUser() {
        }
        
        /// <summary>
        /// <para>
        /// The name of the user to check.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public string userName {
            get {
                XAttribute x = this.Attribute(XName.Get("userName", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("userName", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The password to be verified for the specified user.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public string password {
            get {
                XAttribute x = this.Attribute(XName.Get("password", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("password", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("CheckUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<CheckUser>(this);
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    /// <summary>
    /// <para>
    /// The <checkGroup> element names a group in the global catalog that will be checked for existence.The checkGroup element will not find local groups on a particular server. However, it will find domain groups located anywhere in the active directory forest global catalog. This includes domain local and domain universal groups.
    /// </para>
    /// </summary>
    public partial class CheckGroup : global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.Check, IXMetaData {
        
         public static explicit operator CheckGroup(XElement xe) { return XTypedServices.ToXTypedElement<CheckGroup>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        /// <summary>
        /// <para>
        /// The <checkGroup> element names a group in the global catalog that will be checked for existence.The checkGroup element will not find local groups on a particular server. However, it will find domain groups located anywhere in the active directory forest global catalog. This includes domain local and domain universal groups.
        /// </para>
        /// </summary>
        public CheckGroup() {
        }
        
        /// <summary>
        /// <para>
        /// The group to check for existence.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public string groupName {
            get {
                XAttribute x = this.Attribute(XName.Get("groupName", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("groupName", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("CheckGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<CheckGroup>(this);
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    /// <summary>
    /// <para>
    /// The <checkGroupMembership> checks that a specified user or group is a member of another group.The checkGroupMembership element will not work with local groups, but it can verify that a domain user is a member of a domain local or domain universal security group. This element only works for security groups, and not mail distribution groups.
    /// </para>
    /// </summary>
    public partial class CheckGroupMembership : global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.Check, IXMetaData {
        
         public static explicit operator CheckGroupMembership(XElement xe) { return XTypedServices.ToXTypedElement<CheckGroupMembership>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        /// <summary>
        /// <para>
        /// The <checkGroupMembership> checks that a specified user or group is a member of another group.The checkGroupMembership element will not work with local groups, but it can verify that a domain user is a member of a domain local or domain universal security group. This element only works for security groups, and not mail distribution groups.
        /// </para>
        /// </summary>
        public CheckGroupMembership() {
        }
        
        /// <summary>
        /// <para>
        /// The name of the group to check.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public string groupName {
            get {
                XAttribute x = this.Attribute(XName.Get("groupName", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("groupName", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The name of the group member to verify. This can be either a user or another group.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public string memberName {
            get {
                XAttribute x = this.Attribute(XName.Get("memberName", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("memberName", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("CheckGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<CheckGroupMembership>(this);
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    /// <summary>
    /// <para>
    /// A list of status codes returned by a command action.
    /// </para>
    /// <para>
    /// Regular expression: (statusCode+)+
    /// </para>
    /// </summary>
    public partial class StatusCodeList : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<statusCodeLocalType> statusCodeField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
        
         public static explicit operator StatusCodeList(XElement xe) { return XTypedServices.ToXTypedElement<StatusCodeList>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static StatusCodeList() {
            BuildElementDictionary();
        }
        
        /// <summary>
        /// <para>
        /// A list of status codes returned by a command action.
        /// </para>
        /// <para>
        /// Regular expression: (statusCode+)+
        /// </para>
        /// </summary>
        public StatusCodeList() {
        }
        
        /// <summary>
        /// <para>
        /// Describes a numeric exit code that might be returned by the command.
        /// </para>
        /// <para>
        /// 
        ///                A <statusCode> element specifies a numeric exit code that might be returned by a command, the success or failure status of the exit code, and a text message explaining the meaning of the exit code.
        ///              
        /// </para>
        /// <para>
        /// Occurrence: required, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (statusCode+)+
        /// </para>
        /// </summary>
        public IList<www.xboxlive.com.Deployment.Language.XMLSchema.xsd.StatusCodeList.statusCodeLocalType> statusCode {
            get {
                if ((this.statusCodeField == null)) {
                    this.statusCodeField = new XTypedList<statusCodeLocalType>(this, LinqToXsdTypeManager.Instance, XName.Get("statusCode", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                }
                return this.statusCodeField;
            }
            set {
                if ((value == null)) {
                    this.statusCodeField = null;
                }
                else {
                    if ((this.statusCodeField == null)) {
                        this.statusCodeField = XTypedList<statusCodeLocalType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("statusCode", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    else {
                        XTypedServices.SetList<statusCodeLocalType>(this.statusCodeField, value);
                    }
                }
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("StatusCodeList", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<StatusCodeList>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(XName.Get("statusCode", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(statusCodeLocalType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
        
        public partial class statusCodeLocalType : XTypedElement, IXMetaData {
            
         public static explicit operator statusCodeLocalType(XElement xe) { return XTypedServices.ToXTypedElement<statusCodeLocalType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
            
            public statusCodeLocalType() {
            }
            
            /// <summary>
            /// <para>
            /// The numeric exit code to which this statusCode element applies.
            /// </para>
            /// <para>
            /// Occurrence: required
            /// </para>
            /// </summary>
            public int value {
                get {
                    XAttribute x = this.Attribute(XName.Get("value", ""));
                    return XTypedServices.ParseValue<int>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Int).Datatype);
                }
                set {
                    this.SetAttribute(XName.Get("value", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Int).Datatype);
                }
            }
            
            /// <summary>
            /// <para>
            /// One of the values "success", "success_reboot", "reboot_rerun", "warning" or "failure". Success and failure indicate that the command completed successfully or failed, respectively. The meaning of warning depends on the 'Treat Warning As Errors' flag. Success_reboot indicates that the command completed successfully, but the server must be rebooted before the changes take effect. reboot_rerun indicates the command did not complete, it requires a reboot now and needs to be invoked again.
            /// </para>
            /// <para>
            /// Occurrence: required
            /// </para>
            /// </summary>
            public string type {
                get {
                    XAttribute x = this.Attribute(XName.Get("type", ""));
                    return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
                set {
                    this.SetAttribute(XName.Get("type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
            }
            
            /// <summary>
            /// <para>
            /// The message to be displayed to the user describing the meaning of this status code.
            /// </para>
            /// <para>
            /// Occurrence: required
            /// </para>
            /// </summary>
            public string message {
                get {
                    XAttribute x = this.Attribute(XName.Get("message", ""));
                    return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
                set {
                    this.SetAttribute(XName.Get("message", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            XName IXMetaData.SchemaName {
                get {
                    return XName.Get("statusCode", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            SchemaOrigin IXMetaData.TypeOrigin {
                get {
                    return SchemaOrigin.Fragment;
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            ILinqToXsdTypeManager IXMetaData.TypeManager {
                get {
                    return LinqToXsdTypeManager.Instance;
                }
            }
            
            public override XTypedElement Clone() {
                return XTypedServices.CloneXTypedElement<statusCodeLocalType>(this);
            }
            
            ContentModelEntity IXMetaData.GetContentModel() {
                return ContentModelEntity.Default;
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Specification of a command to run for install, uninstall or check.
    /// </para>
    /// <para>
    /// Regular expression: (statusCodes? | inputFiles? | outputFiles?)*
    /// </para>
    /// </summary>
    public partial class CommandType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<StatusCodeList> statusCodesField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<FileListType> inputFilesField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<FileListType> outputFilesField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
        
         public static explicit operator CommandType(XElement xe) { return XTypedServices.ToXTypedElement<CommandType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static CommandType() {
            BuildElementDictionary();
        }
        
        /// <summary>
        /// <para>
        /// Specification of a command to run for install, uninstall or check.
        /// </para>
        /// <para>
        /// Regular expression: (statusCodes? | inputFiles? | outputFiles?)*
        /// </para>
        /// </summary>
        public CommandType() {
        }
        
        /// <summary>
        /// <para>
        /// A collection of statusCode elements that control how Octopus handles the status returned by the command.
        /// </para>
        /// <para>
        /// 
        ///                The <statusCode> element is a collection of statusCode elements that control how Octopus handles the status returned by a command.
        ///              
        /// </para>
        /// <para>
        /// Occurrence: optional, choice
        /// </para>
        /// <para>
        /// Regular expression: (statusCodes? | inputFiles? | outputFiles?)*
        /// </para>
        /// </summary>
        public IList<StatusCodeList> statusCodes {
            get {
                if ((this.statusCodesField == null)) {
                    this.statusCodesField = new XTypedList<StatusCodeList>(this, LinqToXsdTypeManager.Instance, XName.Get("statusCodes", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                }
                return this.statusCodesField;
            }
            set {
                if ((value == null)) {
                    this.statusCodesField = null;
                }
                else {
                    if ((this.statusCodesField == null)) {
                        this.statusCodesField = XTypedList<StatusCodeList>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("statusCodes", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    else {
                        XTypedServices.SetList<StatusCodeList>(this.statusCodesField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// A list of files to be copied from the build location to the target server before command execution.
        /// </para>
        /// <para>
        /// The <inputFiles> element contains a list of files to be copied from the build location to the target server before command execution.
        /// </para>
        /// <para>
        /// Occurrence: optional, choice
        /// </para>
        /// <para>
        /// Regular expression: (statusCodes? | inputFiles? | outputFiles?)*
        /// </para>
        /// </summary>
        public IList<FileListType> inputFiles {
            get {
                if ((this.inputFilesField == null)) {
                    this.inputFilesField = new XTypedList<FileListType>(this, LinqToXsdTypeManager.Instance, XName.Get("inputFiles", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                }
                return this.inputFilesField;
            }
            set {
                if ((value == null)) {
                    this.inputFilesField = null;
                }
                else {
                    if ((this.inputFilesField == null)) {
                        this.inputFilesField = XTypedList<FileListType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("inputFiles", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    else {
                        XTypedServices.SetList<FileListType>(this.inputFilesField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// A list of files to copy back from the target server to the log share after command execution.
        /// </para>
        /// <para>
        /// The <outputFiles> element contains a list of files to copy back from the target server to the log share after command execution.
        /// </para>
        /// <para>
        /// Occurrence: optional, choice
        /// </para>
        /// <para>
        /// Regular expression: (statusCodes? | inputFiles? | outputFiles?)*
        /// </para>
        /// </summary>
        public IList<FileListType> outputFiles {
            get {
                if ((this.outputFilesField == null)) {
                    this.outputFilesField = new XTypedList<FileListType>(this, LinqToXsdTypeManager.Instance, XName.Get("outputFiles", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                }
                return this.outputFilesField;
            }
            set {
                if ((value == null)) {
                    this.outputFilesField = null;
                }
                else {
                    if ((this.outputFilesField == null)) {
                        this.outputFilesField = XTypedList<FileListType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("outputFiles", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    else {
                        XTypedServices.SetList<FileListType>(this.outputFilesField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// An arbitrary name that you assign to this command. This name is used in the file and directory names for log files. It must be unique among all installCommand, uninstallCommand and commandCheck elements in a given service manifest. Command names must start and end with a letter or digit; and may include letters, digits, underscores, spaces, periods or dashes between the first and last character.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public string name {
            get {
                XAttribute x = this.Attribute(XName.Get("name", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("name", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///          The command to execute. This may include references to component properties by enclosing the property name in square brackets. After expansion of properties, the command is interpreted by cmd.exe on the target machine, so it may refer to environment variables using a name enclosed in percent signs. The Octopus agent defines a set of environment variables prior to executing the command.
        ///        
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public string cmd {
            get {
                XAttribute x = this.Attribute(XName.Get("cmd", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("cmd", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("CommandType", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<CommandType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(XName.Get("statusCodes", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(StatusCodeList));
            localElementDictionary.Add(XName.Get("inputFiles", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(FileListType));
            localElementDictionary.Add(XName.Get("outputFiles", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(FileListType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    /// <summary>
    /// <para>
    /// A list of files to copy to or from a target server for a command action.
    /// </para>
    /// <para>
    /// Regular expression: (file+)+
    /// </para>
    /// </summary>
    public partial class FileListType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<FileType> fileField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
        
         public static explicit operator FileListType(XElement xe) { return XTypedServices.ToXTypedElement<FileListType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static FileListType() {
            BuildElementDictionary();
        }
        
        /// <summary>
        /// <para>
        /// A list of files to copy to or from a target server for a command action.
        /// </para>
        /// <para>
        /// Regular expression: (file+)+
        /// </para>
        /// </summary>
        public FileListType() {
        }
        
        /// <summary>
        /// <para>
        /// A single file to be copied.
        /// </para>
        /// <para>
        /// Occurrence: required, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (file+)+
        /// </para>
        /// </summary>
        public IList<FileType> file {
            get {
                if ((this.fileField == null)) {
                    this.fileField = new XTypedList<FileType>(this, LinqToXsdTypeManager.Instance, XName.Get("file", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                }
                return this.fileField;
            }
            set {
                if ((value == null)) {
                    this.fileField = null;
                }
                else {
                    if ((this.fileField == null)) {
                        this.fileField = XTypedList<FileType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("file", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    else {
                        XTypedServices.SetList<FileType>(this.fileField, value);
                    }
                }
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("FileListType", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<FileListType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(XName.Get("file", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(FileType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    /// <summary>
    /// <para>
    /// The <file> element specifies a file to be created or copied to the target server before execution of a command (an input file), or to be copied from the target server to the log folder after executing the command (an output file).
    ///            When an absolute path is used for the sourcePath attribute of an output file,
    ///            a relative path must be specified for the destinationPath attribute.
    ///            Otherwise, since the default destination path is the same as the source path,
    ///            the absolute source path will be appended to the Octopus log directory,
    ///            resulting in an invalid file path.
    ///          
    ///            For example, to copy the file setup.log from %SystemRoot%\System32 on the target server to
    ///            the Octopus log directory, use the following:
    ///            <file sourcePath="%SystemRoot%\System32\setup.log" destinationPath="setup.log" />
    /// </para>
    /// </summary>
    public partial class FileType : XTypedElement, IXMetaData {
        
         public static explicit operator FileType(XElement xe) { return XTypedServices.ToXTypedElement<FileType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        /// <summary>
        /// <para>
        /// The <file> element specifies a file to be created or copied to the target server before execution of a command (an input file), or to be copied from the target server to the log folder after executing the command (an output file).
        ///            When an absolute path is used for the sourcePath attribute of an output file,
        ///            a relative path must be specified for the destinationPath attribute.
        ///            Otherwise, since the default destination path is the same as the source path,
        ///            the absolute source path will be appended to the Octopus log directory,
        ///            resulting in an invalid file path.
        ///          
        ///            For example, to copy the file setup.log from %SystemRoot%\System32 on the target server to
        ///            the Octopus log directory, use the following:
        ///            <file sourcePath="%SystemRoot%\System32\setup.log" destinationPath="setup.log" />
        /// </para>
        /// </summary>
        public FileType() {
        }
        
        /// <summary>
        /// <para>
        /// The source path for the file to be copied. When used for input files, this file path is relative to the build directory, or may be omitted, and the text inside the <file> element will be used as the content of the file. When used for output files, this path is relative to the temporary directory on the target server, or may be an absolute path on the target server.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public string sourcePath {
            get {
                XAttribute x = this.Attribute(XName.Get("sourcePath", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("sourcePath", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// An optional destination path for the file to be copied. If not specified, the destination path is the same as the source path. When used with input files, the destination path is relative to the temporary directory on the target server. When used with output files, the destination path is relative to the Octopus log directory for the command being executed.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public string destinationPath {
            get {
                XAttribute x = this.Attribute(XName.Get("destinationPath", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("destinationPath", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("FileType", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<FileType>(this);
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    /// <summary>
    /// <para>
    /// A collection of checks.
    /// </para>
    /// <para>
    /// Regular expression: (checkUser* | checkGroup* | checkGroupMembership* | checkDrive* | checkFile* | checkFolder* | checkValue* | checkRegistry* | checkService* | checkWebSite* | commandCheck* | not* | or* | and* | @true* | @false* | any)+
    /// </para>
    /// </summary>
    public partial class ChecksType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<CheckUser> checkUserField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<CheckGroup> checkGroupField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<CheckGroupMembership> checkGroupMembershipField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<CheckDrive> checkDriveField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<CheckFile> checkFileField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<CheckFolder> checkFolderField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<CheckValue> checkValueField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<CheckRegistry> checkRegistryField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<CheckService> checkServiceField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<CheckWebSite> checkWebSiteField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<CommandCheck> commandCheckField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<LogicalCheck> notField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<LogicalCheck> orField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<LogicalCheck> andField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<XTypedElement> @trueField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<XTypedElement> @falseField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static FSM validationStates;
        
         public static explicit operator ChecksType(XElement xe) { return XTypedServices.ToXTypedElement<ChecksType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static ChecksType() {
            BuildElementDictionary();
            InitFSM();
        }
        
        /// <summary>
        /// <para>
        /// A collection of checks.
        /// </para>
        /// <para>
        /// Regular expression: (checkUser* | checkGroup* | checkGroupMembership* | checkDrive* | checkFile* | checkFolder* | checkValue* | checkRegistry* | checkService* | checkWebSite* | commandCheck* | not* | or* | and* | @true* | @false* | any)+
        /// </para>
        /// </summary>
        public ChecksType() {
        }
        
        /// <summary>
        /// <para>
        /// Check for the existence of a domain user and optionally check the user's password. NOTE: Only valid within domain checks.
        /// </para>
        /// <para>
        /// conditionChecksinstalledChecksprerequisiteChecks
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (checkUser* | checkGroup* | checkGroupMembership* | checkDrive* | checkFile* | checkFolder* | checkValue* | checkRegistry* | checkService* | checkWebSite* | commandCheck* | not* | or* | and* | @true* | @false* | any)+
        /// </para>
        /// </summary>
        public IList<CheckUser> checkUser {
            get {
                if ((this.checkUserField == null)) {
                    this.checkUserField = new XTypedList<CheckUser>(this, LinqToXsdTypeManager.Instance, XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                }
                return this.checkUserField;
            }
            set {
                if ((value == null)) {
                    this.checkUserField = null;
                }
                else {
                    if ((this.checkUserField == null)) {
                        this.checkUserField = XTypedList<CheckUser>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    else {
                        XTypedServices.SetList<CheckUser>(this.checkUserField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Check for the existence of a domain group. NOTE: Only valid within domain checks.
        /// </para>
        /// <para>
        /// conditionChecksinstalledChecksprerequisiteChecks
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (checkUser* | checkGroup* | checkGroupMembership* | checkDrive* | checkFile* | checkFolder* | checkValue* | checkRegistry* | checkService* | checkWebSite* | commandCheck* | not* | or* | and* | @true* | @false* | any)+
        /// </para>
        /// </summary>
        public IList<CheckGroup> checkGroup {
            get {
                if ((this.checkGroupField == null)) {
                    this.checkGroupField = new XTypedList<CheckGroup>(this, LinqToXsdTypeManager.Instance, XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                }
                return this.checkGroupField;
            }
            set {
                if ((value == null)) {
                    this.checkGroupField = null;
                }
                else {
                    if ((this.checkGroupField == null)) {
                        this.checkGroupField = XTypedList<CheckGroup>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    else {
                        XTypedServices.SetList<CheckGroup>(this.checkGroupField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Check for membership in a domain group. NOTE: Only valid within domain checks.
        /// </para>
        /// <para>
        /// conditionChecksinstalledChecksprerequisiteChecks
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (checkUser* | checkGroup* | checkGroupMembership* | checkDrive* | checkFile* | checkFolder* | checkValue* | checkRegistry* | checkService* | checkWebSite* | commandCheck* | not* | or* | and* | @true* | @false* | any)+
        /// </para>
        /// </summary>
        public IList<CheckGroupMembership> checkGroupMembership {
            get {
                if ((this.checkGroupMembershipField == null)) {
                    this.checkGroupMembershipField = new XTypedList<CheckGroupMembership>(this, LinqToXsdTypeManager.Instance, XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                }
                return this.checkGroupMembershipField;
            }
            set {
                if ((value == null)) {
                    this.checkGroupMembershipField = null;
                }
                else {
                    if ((this.checkGroupMembershipField == null)) {
                        this.checkGroupMembershipField = XTypedList<CheckGroupMembership>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    else {
                        XTypedServices.SetList<CheckGroupMembership>(this.checkGroupMembershipField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Check for the existence of a logical drive letter. NOTE: Only valid within component checks.
        /// </para>
        /// <para>
        /// domainChecks
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (checkUser* | checkGroup* | checkGroupMembership* | checkDrive* | checkFile* | checkFolder* | checkValue* | checkRegistry* | checkService* | checkWebSite* | commandCheck* | not* | or* | and* | @true* | @false* | any)+
        /// </para>
        /// </summary>
        public IList<CheckDrive> checkDrive {
            get {
                if ((this.checkDriveField == null)) {
                    this.checkDriveField = new XTypedList<CheckDrive>(this, LinqToXsdTypeManager.Instance, XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                }
                return this.checkDriveField;
            }
            set {
                if ((value == null)) {
                    this.checkDriveField = null;
                }
                else {
                    if ((this.checkDriveField == null)) {
                        this.checkDriveField = XTypedList<CheckDrive>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    else {
                        XTypedServices.SetList<CheckDrive>(this.checkDriveField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Check for the existence and/or version of a file. NOTE: Only valid within component checks.
        /// </para>
        /// <para>
        /// domainChecks
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (checkUser* | checkGroup* | checkGroupMembership* | checkDrive* | checkFile* | checkFolder* | checkValue* | checkRegistry* | checkService* | checkWebSite* | commandCheck* | not* | or* | and* | @true* | @false* | any)+
        /// </para>
        /// </summary>
        public IList<CheckFile> checkFile {
            get {
                if ((this.checkFileField == null)) {
                    this.checkFileField = new XTypedList<CheckFile>(this, LinqToXsdTypeManager.Instance, XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                }
                return this.checkFileField;
            }
            set {
                if ((value == null)) {
                    this.checkFileField = null;
                }
                else {
                    if ((this.checkFileField == null)) {
                        this.checkFileField = XTypedList<CheckFile>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    else {
                        XTypedServices.SetList<CheckFile>(this.checkFileField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Check for the existence of a folder. NOTE: Only valid within component checks.
        /// </para>
        /// <para>
        /// domainChecks
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (checkUser* | checkGroup* | checkGroupMembership* | checkDrive* | checkFile* | checkFolder* | checkValue* | checkRegistry* | checkService* | checkWebSite* | commandCheck* | not* | or* | and* | @true* | @false* | any)+
        /// </para>
        /// </summary>
        public IList<CheckFolder> checkFolder {
            get {
                if ((this.checkFolderField == null)) {
                    this.checkFolderField = new XTypedList<CheckFolder>(this, LinqToXsdTypeManager.Instance, XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                }
                return this.checkFolderField;
            }
            set {
                if ((value == null)) {
                    this.checkFolderField = null;
                }
                else {
                    if ((this.checkFolderField == null)) {
                        this.checkFolderField = XTypedList<CheckFolder>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    else {
                        XTypedServices.SetList<CheckFolder>(this.checkFolderField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Check/compare value(s).
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (checkUser* | checkGroup* | checkGroupMembership* | checkDrive* | checkFile* | checkFolder* | checkValue* | checkRegistry* | checkService* | checkWebSite* | commandCheck* | not* | or* | and* | @true* | @false* | any)+
        /// </para>
        /// </summary>
        public IList<CheckValue> checkValue {
            get {
                if ((this.checkValueField == null)) {
                    this.checkValueField = new XTypedList<CheckValue>(this, LinqToXsdTypeManager.Instance, XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                }
                return this.checkValueField;
            }
            set {
                if ((value == null)) {
                    this.checkValueField = null;
                }
                else {
                    if ((this.checkValueField == null)) {
                        this.checkValueField = XTypedList<CheckValue>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    else {
                        XTypedServices.SetList<CheckValue>(this.checkValueField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Check a registry key value. NOTE: Only valid within component checks.
        /// </para>
        /// <para>
        /// domainChecks
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (checkUser* | checkGroup* | checkGroupMembership* | checkDrive* | checkFile* | checkFolder* | checkValue* | checkRegistry* | checkService* | checkWebSite* | commandCheck* | not* | or* | and* | @true* | @false* | any)+
        /// </para>
        /// </summary>
        public IList<CheckRegistry> checkRegistry {
            get {
                if ((this.checkRegistryField == null)) {
                    this.checkRegistryField = new XTypedList<CheckRegistry>(this, LinqToXsdTypeManager.Instance, XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                }
                return this.checkRegistryField;
            }
            set {
                if ((value == null)) {
                    this.checkRegistryField = null;
                }
                else {
                    if ((this.checkRegistryField == null)) {
                        this.checkRegistryField = XTypedList<CheckRegistry>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    else {
                        XTypedServices.SetList<CheckRegistry>(this.checkRegistryField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Check the status of a service. NOTE: Only valid within component checks.
        /// </para>
        /// <para>
        /// domainChecks
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (checkUser* | checkGroup* | checkGroupMembership* | checkDrive* | checkFile* | checkFolder* | checkValue* | checkRegistry* | checkService* | checkWebSite* | commandCheck* | not* | or* | and* | @true* | @false* | any)+
        /// </para>
        /// </summary>
        public IList<CheckService> checkService {
            get {
                if ((this.checkServiceField == null)) {
                    this.checkServiceField = new XTypedList<CheckService>(this, LinqToXsdTypeManager.Instance, XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                }
                return this.checkServiceField;
            }
            set {
                if ((value == null)) {
                    this.checkServiceField = null;
                }
                else {
                    if ((this.checkServiceField == null)) {
                        this.checkServiceField = XTypedList<CheckService>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    else {
                        XTypedServices.SetList<CheckService>(this.checkServiceField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Check for the existence of an IIS Web Site. NOTE: Only valid within component checks.
        /// </para>
        /// <para>
        /// domainChecks
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (checkUser* | checkGroup* | checkGroupMembership* | checkDrive* | checkFile* | checkFolder* | checkValue* | checkRegistry* | checkService* | checkWebSite* | commandCheck* | not* | or* | and* | @true* | @false* | any)+
        /// </para>
        /// </summary>
        public IList<CheckWebSite> checkWebSite {
            get {
                if ((this.checkWebSiteField == null)) {
                    this.checkWebSiteField = new XTypedList<CheckWebSite>(this, LinqToXsdTypeManager.Instance, XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                }
                return this.checkWebSiteField;
            }
            set {
                if ((value == null)) {
                    this.checkWebSiteField = null;
                }
                else {
                    if ((this.checkWebSiteField == null)) {
                        this.checkWebSiteField = XTypedList<CheckWebSite>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    else {
                        XTypedServices.SetList<CheckWebSite>(this.checkWebSiteField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Run a custom check defined by an arbitrary command. NOTE: Only valid within component checks.
        /// </para>
        /// <para>
        /// domainChecks
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (checkUser* | checkGroup* | checkGroupMembership* | checkDrive* | checkFile* | checkFolder* | checkValue* | checkRegistry* | checkService* | checkWebSite* | commandCheck* | not* | or* | and* | @true* | @false* | any)+
        /// </para>
        /// </summary>
        public IList<CommandCheck> commandCheck {
            get {
                if ((this.commandCheckField == null)) {
                    this.commandCheckField = new XTypedList<CommandCheck>(this, LinqToXsdTypeManager.Instance, XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                }
                return this.commandCheckField;
            }
            set {
                if ((value == null)) {
                    this.commandCheckField = null;
                }
                else {
                    if ((this.commandCheckField == null)) {
                        this.commandCheckField = XTypedList<CommandCheck>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    else {
                        XTypedServices.SetList<CommandCheck>(this.commandCheckField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// The negation of the result of a check.
        /// </para>
        /// <para>
        /// 
        ///                The <not> element must enclose exactly one check or logical operation, chosen from the list of possible child elements.
        ///                The result of the <not> is the opposite of the result of the enclosed element.
        ///              
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (checkUser* | checkGroup* | checkGroupMembership* | checkDrive* | checkFile* | checkFolder* | checkValue* | checkRegistry* | checkService* | checkWebSite* | commandCheck* | not* | or* | and* | @true* | @false* | any)+
        /// </para>
        /// </summary>
        public IList<LogicalCheck> not {
            get {
                if ((this.notField == null)) {
                    this.notField = new XTypedList<LogicalCheck>(this, LinqToXsdTypeManager.Instance, XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                }
                return this.notField;
            }
            set {
                if ((value == null)) {
                    this.notField = null;
                }
                else {
                    if ((this.notField == null)) {
                        this.notField = XTypedList<LogicalCheck>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    else {
                        XTypedServices.SetList<LogicalCheck>(this.notField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// A group of checks whose result is true if any of the individual checks returns true.
        /// </para>
        /// <para>
        /// 
        ///                The <or> element creates a group of checks whose results are combined using a boolean "or" operation.
        ///                That is, the result is true if any of the contained checks return true.
        ///              
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (checkUser* | checkGroup* | checkGroupMembership* | checkDrive* | checkFile* | checkFolder* | checkValue* | checkRegistry* | checkService* | checkWebSite* | commandCheck* | not* | or* | and* | @true* | @false* | any)+
        /// </para>
        /// </summary>
        public IList<LogicalCheck> or {
            get {
                if ((this.orField == null)) {
                    this.orField = new XTypedList<LogicalCheck>(this, LinqToXsdTypeManager.Instance, XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                }
                return this.orField;
            }
            set {
                if ((value == null)) {
                    this.orField = null;
                }
                else {
                    if ((this.orField == null)) {
                        this.orField = XTypedList<LogicalCheck>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    else {
                        XTypedServices.SetList<LogicalCheck>(this.orField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// A group of checks in which all checks must return true for the result to be true.
        /// </para>
        /// <para>
        /// 
        ///                The <and> element creates a group of checks whose results are combined using a boolean "and" operation.
        ///                That is, the result is true if and only if all of the contained checks return true.
        ///              
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (checkUser* | checkGroup* | checkGroupMembership* | checkDrive* | checkFile* | checkFolder* | checkValue* | checkRegistry* | checkService* | checkWebSite* | commandCheck* | not* | or* | and* | @true* | @false* | any)+
        /// </para>
        /// </summary>
        public IList<LogicalCheck> and {
            get {
                if ((this.andField == null)) {
                    this.andField = new XTypedList<LogicalCheck>(this, LinqToXsdTypeManager.Instance, XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                }
                return this.andField;
            }
            set {
                if ((value == null)) {
                    this.andField = null;
                }
                else {
                    if ((this.andField == null)) {
                        this.andField = XTypedList<LogicalCheck>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    else {
                        XTypedServices.SetList<LogicalCheck>(this.andField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// A check which always evaluates to true.
        /// </para>
        /// <para>
        /// 
        ///                A check which always evaluates to true.
        ///              
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (checkUser* | checkGroup* | checkGroupMembership* | checkDrive* | checkFile* | checkFolder* | checkValue* | checkRegistry* | checkService* | checkWebSite* | commandCheck* | not* | or* | and* | @true* | @false* | any)+
        /// </para>
        /// </summary>
        public IList<XTypedElement> @true {
            get {
                if ((this.@trueField == null)) {
                    this.@trueField = new XTypedList<XTypedElement>(this, LinqToXsdTypeManager.Instance, XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                }
                return this.@trueField;
            }
            set {
                if ((value == null)) {
                    this.@trueField = null;
                }
                else {
                    if ((this.@trueField == null)) {
                        this.@trueField = XTypedList<XTypedElement>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    else {
                        XTypedServices.SetList<XTypedElement>(this.@trueField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// A check that always evaluates to false.
        /// </para>
        /// <para>
        /// 
        ///                A check that always evaluates to false.
        ///              
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (checkUser* | checkGroup* | checkGroupMembership* | checkDrive* | checkFile* | checkFolder* | checkValue* | checkRegistry* | checkService* | checkWebSite* | commandCheck* | not* | or* | and* | @true* | @false* | any)+
        /// </para>
        /// </summary>
        public IList<XTypedElement> @false {
            get {
                if ((this.@falseField == null)) {
                    this.@falseField = new XTypedList<XTypedElement>(this, LinqToXsdTypeManager.Instance, XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                }
                return this.@falseField;
            }
            set {
                if ((value == null)) {
                    this.@falseField = null;
                }
                else {
                    if ((this.@falseField == null)) {
                        this.@falseField = XTypedList<XTypedElement>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    else {
                        XTypedServices.SetList<XTypedElement>(this.@falseField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Regular expression: (checkUser* | checkGroup* | checkGroupMembership* | checkDrive* | checkFile* | checkFolder* | checkValue* | checkRegistry* | checkService* | checkWebSite* | commandCheck* | not* | or* | and* | @true* | @false* | any)+
        /// </para>
        /// </summary>
        public IEnumerable<XElement> Any {
            get {
                return this.GetWildCards(WildCard.DefaultWildCard);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("ChecksType", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<ChecksType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(CheckUser));
            localElementDictionary.Add(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(CheckGroup));
            localElementDictionary.Add(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(CheckGroupMembership));
            localElementDictionary.Add(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(CheckDrive));
            localElementDictionary.Add(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(CheckFile));
            localElementDictionary.Add(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(CheckFolder));
            localElementDictionary.Add(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(CheckValue));
            localElementDictionary.Add(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(CheckRegistry));
            localElementDictionary.Add(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(CheckService));
            localElementDictionary.Add(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(CheckWebSite));
            localElementDictionary.Add(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(CommandCheck));
            localElementDictionary.Add(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(LogicalCheck));
            localElementDictionary.Add(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(LogicalCheck));
            localElementDictionary.Add(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(LogicalCheck));
            localElementDictionary.Add(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(XTypedElement));
            localElementDictionary.Add(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(XTypedElement));
        }
        
        FSM IXMetaData.GetValidationStates() {
            return validationStates;
        }
        
        private static void InitFSM() {
            Dictionary<int, Transitions> transitions = new Dictionary<int, Transitions>();
            transitions.Add(1, new Transitions(new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            transitions.Add(3, new Transitions(new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            transitions.Add(5, new Transitions(new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            transitions.Add(7, new Transitions(new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            transitions.Add(9, new Transitions(new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            transitions.Add(11, new Transitions(new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            transitions.Add(13, new Transitions(new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            transitions.Add(15, new Transitions(new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            transitions.Add(17, new Transitions(new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            transitions.Add(19, new Transitions(new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            transitions.Add(21, new Transitions(new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            transitions.Add(23, new Transitions(new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            transitions.Add(25, new Transitions(new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            transitions.Add(27, new Transitions(new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            transitions.Add(29, new Transitions(new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            transitions.Add(31, new Transitions(new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            transitions.Add(33, new Transitions(new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            validationStates = new FSM(1, new Set<int>(new int[] {
                            1,
                            3,
                            5,
                            7,
                            9,
                            11,
                            13,
                            15,
                            17,
                            19,
                            21,
                            23,
                            25,
                            27,
                            29,
                            31,
                            33}), transitions);
        }
    }
    
    /// <summary>
    /// <para>
    /// The base type for checks.
    /// </para>
    /// </summary>
    public partial class Check : XTypedElement, IXMetaData {
        
         public static explicit operator Check(XElement xe) { return XTypedServices.ToXTypedElement<Check>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        /// <summary>
        /// <para>
        /// The base type for checks.
        /// </para>
        /// </summary>
        public Check() {
        }
        
        /// <summary>
        /// <para>
        /// A help string to be displayed in the log files if the check fails.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public string help {
            get {
                XAttribute x = this.Attribute(XName.Get("help", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("help", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("Check", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<Check>(this);
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    /// <summary>
    /// <para>
    /// Check for the existence of a drive letter on the target server.
    /// </para>
    /// <para>
    /// The <checkDrive> element names a logical drive letter that should be checked for existence on the target server. The check will return true only if the drive letter exists.The checkDrive check is useful for ensuring that a drive exists prior to assigning it to an application for use. For example, when configuring SQL server, checkDrive can verify that a drive is present before informing SQL to use it for logs.
    /// </para>
    /// </summary>
    public partial class CheckDrive : global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.Check, IXMetaData {
        
         public static explicit operator CheckDrive(XElement xe) { return XTypedServices.ToXTypedElement<CheckDrive>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        /// <summary>
        /// <para>
        /// Check for the existence of a drive letter on the target server.
        /// </para>
        /// <para>
        /// The <checkDrive> element names a logical drive letter that should be checked for existence on the target server. The check will return true only if the drive letter exists.The checkDrive check is useful for ensuring that a drive exists prior to assigning it to an application for use. For example, when configuring SQL server, checkDrive can verify that a drive is present before informing SQL to use it for logs.
        /// </para>
        /// </summary>
        public CheckDrive() {
        }
        
        /// <summary>
        /// <para>
        /// The drive letter, followed by a colon, for example "C:", or a full path. If a full path is given, only the first two characters will be used.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public string path {
            get {
                XAttribute x = this.Attribute(XName.Get("path", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("path", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("CheckDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<CheckDrive>(this);
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    /// <summary>
    /// <para>
    /// Check for file existence and version on the target server.
    /// </para>
    /// <para>
    /// The <checkFile> element names a file that will be checked for existence on the target server. The check also supports validating the version of the file once it is located.In addition to checking a file for existence or non-existence, the various version number checks give an author considerable flexibility. For example, the checkFile element with a 'ge' version number check can be used to ensure that security or bug patches are applied before a service is deployed.
    /// </para>
    /// </summary>
    public partial class CheckFile : global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.Check, IXMetaData {
        
         public static explicit operator CheckFile(XElement xe) { return XTypedServices.ToXTypedElement<CheckFile>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        /// <summary>
        /// <para>
        /// Check for file existence and version on the target server.
        /// </para>
        /// <para>
        /// The <checkFile> element names a file that will be checked for existence on the target server. The check also supports validating the version of the file once it is located.In addition to checking a file for existence or non-existence, the various version number checks give an author considerable flexibility. For example, the checkFile element with a 'ge' version number check can be used to ensure that security or bug patches are applied before a service is deployed.
        /// </para>
        /// </summary>
        public CheckFile() {
        }
        
        /// <summary>
        /// <para>
        /// The full path name of the file to check.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public string path {
            get {
                XAttribute x = this.Attribute(XName.Get("path", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("path", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// A version number against which to compare the version of the file.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public string version {
            get {
                XAttribute x = this.Attribute(XName.Get("version", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("version", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The type of check to perform.
        /// </para>
        /// <para>
        /// The method attribute may take any of the following values:eqThe version number of the file equals the specified version.exThe file exists, regardless of version.geThe version number of the file is greater than or equal to the specified version.gtThe version number of the file is greater than the specified version.leThe version number of the file is less than or equal to the specified version.ltThe version number of the file is less than the specified version.neqThe version number of the file is not equal to the specified version.nexThe file does not exist, regardless of version.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public string method {
            get {
                XAttribute x = this.Attribute(XName.Get("method", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("method", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("CheckFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<CheckFile>(this);
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    /// <summary>
    /// <para>
    /// Check for the existence of a folder on the target server.
    /// </para>
    /// <para>
    /// The <checkFolder> element names a folder that will be checked for existence on the target server.
    /// </para>
    /// </summary>
    public partial class CheckFolder : global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.Check, IXMetaData {
        
         public static explicit operator CheckFolder(XElement xe) { return XTypedServices.ToXTypedElement<CheckFolder>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        /// <summary>
        /// <para>
        /// Check for the existence of a folder on the target server.
        /// </para>
        /// <para>
        /// The <checkFolder> element names a folder that will be checked for existence on the target server.
        /// </para>
        /// </summary>
        public CheckFolder() {
        }
        
        /// <summary>
        /// <para>
        /// The full path of the folder to check for existence.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public string path {
            get {
                XAttribute x = this.Attribute(XName.Get("path", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("path", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("CheckFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<CheckFolder>(this);
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    /// <summary>
    /// <para>
    /// Check a property value.
    /// </para>
    /// <para>
    /// The <checkValue> element compares two values.
    ///            Note that value1 and value2 may contain references to property values enclosed in square brackets.
    ///          
    /// </para>
    /// </summary>
    public partial class CheckValue : global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.Check, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static string typeDefaultValue = "string";
        
         public static explicit operator CheckValue(XElement xe) { return XTypedServices.ToXTypedElement<CheckValue>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        /// <summary>
        /// <para>
        /// Check a property value.
        /// </para>
        /// <para>
        /// The <checkValue> element compares two values.
        ///            Note that value1 and value2 may contain references to property values enclosed in square brackets.
        ///          
        /// </para>
        /// </summary>
        public CheckValue() {
        }
        
        /// <summary>
        /// <para>
        /// The first value.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public string value1 {
            get {
                XAttribute x = this.Attribute(XName.Get("value1", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("value1", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The second value to compare to the first value.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public string value2 {
            get {
                XAttribute x = this.Attribute(XName.Get("value2", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("value2", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The type with which to interpret the compared values. This must be 'integer', 'string' or 'version'. This governs the results of comparisons with numeric values. For example with type="string", the value "10" would be less than "2". With type="integer" or type="version", "10" would be greater than "2". Furthermore, with type="version", the string "2.10" would be greater than "2.2".
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public string type {
            get {
                XAttribute x = this.Attribute(XName.Get("type", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, typeDefaultValue);
            }
            set {
                this.SetAttribute(XName.Get("type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The type of check to perform.
        /// </para>
        /// <para>
        /// The method attribute may take any of the following values:eqBoth values are the same.geValue1 is greater than or equal to value2.gtValue1 is greater than value2.leValue1 is less than or equal to value2.ltValue1 is less than value2.neqValue1 is not equal to value2.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public string method {
            get {
                XAttribute x = this.Attribute(XName.Get("method", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("method", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("CheckValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<CheckValue>(this);
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    /// <summary>
    /// <para>
    /// Check a registry key on the target server.
    /// </para>
    /// <para>
    /// The <checkRegistry> element names a registry key that will be checked for existence or value on the target server.
    /// </para>
    /// </summary>
    public partial class CheckRegistry : global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.Check, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static string typeDefaultValue = "string";
        
         public static explicit operator CheckRegistry(XElement xe) { return XTypedServices.ToXTypedElement<CheckRegistry>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        /// <summary>
        /// <para>
        /// Check a registry key on the target server.
        /// </para>
        /// <para>
        /// The <checkRegistry> element names a registry key that will be checked for existence or value on the target server.
        /// </para>
        /// </summary>
        public CheckRegistry() {
        }
        
        /// <summary>
        /// <para>
        /// The path to the registry entry. For example "HKLM\Software\Microsoft\Windows NT\CurrentVersion".
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public string path {
            get {
                XAttribute x = this.Attribute(XName.Get("path", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("path", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The registry key to evaluate. For example "CSDVersion".
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public string key {
            get {
                XAttribute x = this.Attribute(XName.Get("key", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("key", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The value with which to compare the registry key. For example "Service Pack 1".
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public string value {
            get {
                XAttribute x = this.Attribute(XName.Get("value", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("value", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The expected type of the registry key. This must be 'dword', 'string' or 'version'. This governs the results of comparisons with numeric values. For example with type="string", the value "10" would be less than "2". With type="dword" or type="version", "10" would be greater than "2". Furthermore, with type="version", the string "2.10" would be greater than "2.2".
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public string type {
            get {
                XAttribute x = this.Attribute(XName.Get("type", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, typeDefaultValue);
            }
            set {
                this.SetAttribute(XName.Get("type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The type of check to perform.
        /// </para>
        /// <para>
        /// The method attribute may take any of the following values:eqThe value of the key equals the specified value.exThe key or path exists, regardless of the value.geThe value of the key is greater than or equal to the specified value.gtThe value of the key is greater than the specified value.leThe value of the key is less than or equal to the specified value.ltThe value of the key is less than the specified value.neqThe value of the key is not equal to the specified value.nexThe key or path does not exist, regardless of the value.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public string method {
            get {
                XAttribute x = this.Attribute(XName.Get("method", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("method", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("CheckRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<CheckRegistry>(this);
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    /// <summary>
    /// <para>
    /// Check the status of a service on the target server.
    /// </para>
    /// <para>
    /// The <checkService> element determines whether a service exists, and also its current status and startup setting.When referring to a service, specify the short service name as opposed to the friendly name. For example, the actual name of the 'ASP.NET State Service' is 'aspnet_state'.Ordinarily it is sufficient to check whether a service exists. Authors who depend upon a service to be started or stopped in advance may also specify the status attribute. Checking the startup type of the service is useful to ensure that the server is properly configured. For example, for security reasons a component might check whether the SMTP service was disabled on a Web server.
    /// </para>
    /// </summary>
    public partial class CheckService : global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.Check, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static string startupDefaultValue = "enabled";
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static string statusDefaultValue = "started";
        
         public static explicit operator CheckService(XElement xe) { return XTypedServices.ToXTypedElement<CheckService>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        /// <summary>
        /// <para>
        /// Check the status of a service on the target server.
        /// </para>
        /// <para>
        /// The <checkService> element determines whether a service exists, and also its current status and startup setting.When referring to a service, specify the short service name as opposed to the friendly name. For example, the actual name of the 'ASP.NET State Service' is 'aspnet_state'.Ordinarily it is sufficient to check whether a service exists. Authors who depend upon a service to be started or stopped in advance may also specify the status attribute. Checking the startup type of the service is useful to ensure that the server is properly configured. For example, for security reasons a component might check whether the SMTP service was disabled on a Web server.
        /// </para>
        /// </summary>
        public CheckService() {
        }
        
        /// <summary>
        /// <para>
        /// The name of the service to inspect.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public string name {
            get {
                XAttribute x = this.Attribute(XName.Get("name", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("name", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The startup type of the service.
        /// </para>
        /// <para>
        /// This must be one of the following:automaticThe service starts automatically at boot time.disabledThe service should never start.enabledThe service is either set to 'automatic' or 'manual'.manualThe service should start when requested by a user or process.ignoreOctopus should not check the startup type.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public string startup {
            get {
                XAttribute x = this.Attribute(XName.Get("startup", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, startupDefaultValue);
            }
            set {
                this.SetAttribute(XName.Get("startup", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The current status of the service.
        /// </para>
        /// <para>
        /// This must be one of the following:absentThe service is not installed.startedThe service is running.stoppedThe service is not running.ignoreOctopus should not check the service status.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public string status {
            get {
                XAttribute x = this.Attribute(XName.Get("status", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, statusDefaultValue);
            }
            set {
                this.SetAttribute(XName.Get("status", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("CheckService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<CheckService>(this);
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    /// <summary>
    /// <para>
    /// Check for the existence of a web site.
    /// </para>
    /// <para>
    /// The <checkWebSite> element names an IIS web site to be checked for existence on the target server.
    ///            This check can be used in situations where the web site is created manually by Operations in advance of deployment. The webSiteName attribute can be a hard-coded web site name, or it can refer to the value of a user-input property by enclosing the property name in square brackets.
    ///          
    ///            You must have the IIS Common Files Windows Component installed on the Octopus controller machine to run checkWebsite.
    ///          
    /// </para>
    /// </summary>
    public partial class CheckWebSite : global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.Check, IXMetaData {
        
         public static explicit operator CheckWebSite(XElement xe) { return XTypedServices.ToXTypedElement<CheckWebSite>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        /// <summary>
        /// <para>
        /// Check for the existence of a web site.
        /// </para>
        /// <para>
        /// The <checkWebSite> element names an IIS web site to be checked for existence on the target server.
        ///            This check can be used in situations where the web site is created manually by Operations in advance of deployment. The webSiteName attribute can be a hard-coded web site name, or it can refer to the value of a user-input property by enclosing the property name in square brackets.
        ///          
        ///            You must have the IIS Common Files Windows Component installed on the Octopus controller machine to run checkWebsite.
        ///          
        /// </para>
        /// </summary>
        public CheckWebSite() {
        }
        
        /// <summary>
        /// <para>
        /// The name of the IIS web site to check for existence.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public string webSiteName {
            get {
                XAttribute x = this.Attribute(XName.Get("webSiteName", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("webSiteName", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("CheckWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<CheckWebSite>(this);
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    /// <summary>
    /// <para>
    /// The <commandCheck> element specifies a custom check implemented as an arbitrary command. Optional child elements specify status codes, input files, and output files for the command.
    /// </para>
    /// <para>
    /// Regular expression: (statusCodes? | inputFiles? | outputFiles?)*
    /// </para>
    /// </summary>
    public partial class CommandCheck : global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.CommandType, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
        
         public static explicit operator CommandCheck(XElement xe) { return XTypedServices.ToXTypedElement<CommandCheck>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static CommandCheck() {
            BuildElementDictionary();
        }
        
        /// <summary>
        /// <para>
        /// The <commandCheck> element specifies a custom check implemented as an arbitrary command. Optional child elements specify status codes, input files, and output files for the command.
        /// </para>
        /// <para>
        /// Regular expression: (statusCodes? | inputFiles? | outputFiles?)*
        /// </para>
        /// </summary>
        public CommandCheck() {
        }
        
        /// <summary>
        /// <para>
        /// A help string to be displayed if the check fails.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public string help {
            get {
                XAttribute x = this.Attribute(XName.Get("help", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("help", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("CommandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<CommandCheck>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(XName.Get("statusCodes", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(StatusCodeList));
            localElementDictionary.Add(XName.Get("inputFiles", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(FileListType));
            localElementDictionary.Add(XName.Get("outputFiles", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(FileListType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    /// <summary>
    /// <para>
    /// Base type for a logical operation on a group of checks.
    /// </para>
    /// <para>
    /// Regular expression: (checkUser* | checkGroup* | checkGroupMembership* | checkDrive* | checkFile* | checkFolder* | checkValue* | checkRegistry* | checkService* | checkWebSite* | commandCheck* | not* | or* | and* | @true* | @false* | any)+
    /// </para>
    /// </summary>
    public partial class LogicalCheck : global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.ChecksType, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static FSM validationStates;
        
         public static explicit operator LogicalCheck(XElement xe) { return XTypedServices.ToXTypedElement<LogicalCheck>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static LogicalCheck() {
            BuildElementDictionary();
            InitFSM();
        }
        
        /// <summary>
        /// <para>
        /// Base type for a logical operation on a group of checks.
        /// </para>
        /// <para>
        /// Regular expression: (checkUser* | checkGroup* | checkGroupMembership* | checkDrive* | checkFile* | checkFolder* | checkValue* | checkRegistry* | checkService* | checkWebSite* | commandCheck* | not* | or* | and* | @true* | @false* | any)+
        /// </para>
        /// </summary>
        public LogicalCheck() {
        }
        
        /// <summary>
        /// <para>
        /// A unique name used to identify this group of checks in the log files.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public string name {
            get {
                XAttribute x = this.Attribute(XName.Get("name", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("name", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// A help message displayed in the log files if this check fails.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public string help {
            get {
                XAttribute x = this.Attribute(XName.Get("help", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("help", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("LogicalCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<LogicalCheck>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(CheckUser));
            localElementDictionary.Add(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(CheckGroup));
            localElementDictionary.Add(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(CheckGroupMembership));
            localElementDictionary.Add(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(CheckDrive));
            localElementDictionary.Add(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(CheckFile));
            localElementDictionary.Add(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(CheckFolder));
            localElementDictionary.Add(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(CheckValue));
            localElementDictionary.Add(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(CheckRegistry));
            localElementDictionary.Add(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(CheckService));
            localElementDictionary.Add(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(CheckWebSite));
            localElementDictionary.Add(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(CommandCheck));
            localElementDictionary.Add(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(LogicalCheck));
            localElementDictionary.Add(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(LogicalCheck));
            localElementDictionary.Add(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(LogicalCheck));
            localElementDictionary.Add(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(XTypedElement));
            localElementDictionary.Add(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(XTypedElement));
        }
        
        FSM IXMetaData.GetValidationStates() {
            return validationStates;
        }
        
        private static void InitFSM() {
            Dictionary<int, Transitions> transitions = new Dictionary<int, Transitions>();
            transitions.Add(1, new Transitions(new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            transitions.Add(3, new Transitions(new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            transitions.Add(5, new Transitions(new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            transitions.Add(7, new Transitions(new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            transitions.Add(9, new Transitions(new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            transitions.Add(11, new Transitions(new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            transitions.Add(13, new Transitions(new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            transitions.Add(15, new Transitions(new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            transitions.Add(17, new Transitions(new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            transitions.Add(19, new Transitions(new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            transitions.Add(21, new Transitions(new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            transitions.Add(23, new Transitions(new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            transitions.Add(25, new Transitions(new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            transitions.Add(27, new Transitions(new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            transitions.Add(29, new Transitions(new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            transitions.Add(31, new Transitions(new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            transitions.Add(33, new Transitions(new SingleTransition(XName.Get("checkUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 1), new SingleTransition(XName.Get("checkGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 3), new SingleTransition(XName.Get("checkGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 5), new SingleTransition(XName.Get("checkDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 7), new SingleTransition(XName.Get("checkFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 9), new SingleTransition(XName.Get("checkFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 11), new SingleTransition(XName.Get("checkValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 13), new SingleTransition(XName.Get("checkRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 15), new SingleTransition(XName.Get("checkService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 17), new SingleTransition(XName.Get("checkWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 19), new SingleTransition(XName.Get("commandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 21), new SingleTransition(XName.Get("not", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 23), new SingleTransition(XName.Get("or", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 25), new SingleTransition(XName.Get("and", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 27), new SingleTransition(XName.Get("true", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 29), new SingleTransition(XName.Get("false", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 31), new SingleTransition(new WildCard("##other", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), 33)));
            validationStates = new FSM(1, new Set<int>(new int[] {
                            1,
                            3,
                            5,
                            7,
                            9,
                            11,
                            13,
                            15,
                            17,
                            19,
                            21,
                            23,
                            25,
                            27,
                            29,
                            31,
                            33}), transitions);
        }
    }
    
    /// <summary>
    /// <para>
    /// Valid characters for property names.
    /// </para>
    /// </summary>
    public sealed class PropertyName {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(8)), null, 0, 0, null, null, 0, null, null, 0, new string[] {
                        "[A-Za-z0-9]([A-Za-z0-9_ .\\-]*[A-Za-z0-9])?"}, 0, XmlSchemaWhiteSpace.Preserve));
        
        private PropertyName() {
        }
    }
    
    /// <summary>
    /// <para>
    /// Valid characters for command names.
    /// </para>
    /// </summary>
    public sealed class CommandName {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(8)), null, 0, 0, null, null, 0, null, null, 0, new string[] {
                        "[A-Za-z0-9]([A-Za-z0-9_ .\\-]*[A-Za-z0-9])?"}, 0, XmlSchemaWhiteSpace.Preserve));
        
        private CommandName() {
        }
    }
    
    /// <summary>
    /// <para>
    /// Valid characters for release names.
    /// </para>
    /// </summary>
    public sealed class ReleaseName {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(8)), null, 0, 0, null, null, 0, null, null, 0, new string[] {
                        "[A-Za-z0-9]([A-Za-z0-9_ .\\-]*[A-Za-z0-9])?"}, 0, XmlSchemaWhiteSpace.Preserve));
        
        private ReleaseName() {
        }
    }
    
    /// <summary>
    /// <para>
    /// Regular expression: (passProperty*)*
    /// </para>
    /// </summary>
    public partial class RoleType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<PassPropertyType> passPropertyField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static string serversDefaultValue = "select";
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
        
         public static explicit operator RoleType(XElement xe) { return XTypedServices.ToXTypedElement<RoleType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static RoleType() {
            BuildElementDictionary();
        }
        
        /// <summary>
        /// <para>
        /// Regular expression: (passProperty*)*
        /// </para>
        /// </summary>
        public RoleType() {
        }
        
        /// <summary>
        /// <para>
        /// A property value to override a property defined in the referenced component.
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (passProperty*)*
        /// </para>
        /// </summary>
        public IList<PassPropertyType> passProperty {
            get {
                if ((this.passPropertyField == null)) {
                    this.passPropertyField = new XTypedList<PassPropertyType>(this, LinqToXsdTypeManager.Instance, XName.Get("passProperty", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                }
                return this.passPropertyField;
            }
            set {
                if ((value == null)) {
                    this.passPropertyField = null;
                }
                else {
                    if ((this.passPropertyField == null)) {
                        this.passPropertyField = XTypedList<PassPropertyType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("passProperty", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"));
                    }
                    else {
                        XTypedServices.SetList<PassPropertyType>(this.passPropertyField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// The name of the component to expose as a role. There must be a corresponding <component> element with this name.
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public string name {
            get {
                XAttribute x = this.Attribute(XName.Get("name", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("name", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// Indicates whether or not the role must be assigned to at least one server.
        /// </para>
        /// <para>
        /// 
        ///              As of Octopus 4.0, the required attribute is deprecated.
        ///              It has been superceded by the minServers attribute.
        ///              Rather than required="false", it is now preferable to use minServers="0".
        ///              You cannot use both 'required' and 'minServers' or 'maxServers'.
        ///            
        ///              Since the default for minServers is 1, the default is that the role is required.
        ///            
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public System.Nullable<bool> required {
            get {
                XAttribute x = this.Attribute(XName.Get("required", ""));
                if ((x == null)) {
                    return null;
                }
                return XTypedServices.ParseValue<bool>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("required", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// A statement of the way this role is assigned to servers.
        /// </para>
        /// <para>
        /// The servers attribute may take any of the following values:allThe role will automatically be assigned to all servers in the topology.selectThe deployment operator must explicitly associate the role with one or more servers.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public string servers {
            get {
                XAttribute x = this.Attribute(XName.Get("servers", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, serversDefaultValue);
            }
            set {
                this.SetAttribute(XName.Get("servers", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The minimum number of servers that must be assigned this role. The default is 1.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public System.Nullable<decimal> minServers {
            get {
                XAttribute x = this.Attribute(XName.Get("minServers", ""));
                if ((x == null)) {
                    return null;
                }
                return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Integer).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("minServers", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Integer).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// The maximum number of servers that may be assigned this role. The default is no maximum.
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public System.Nullable<decimal> maxServers {
            get {
                XAttribute x = this.Attribute(XName.Get("maxServers", ""));
                if ((x == null)) {
                    return null;
                }
                return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Integer).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("maxServers", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Integer).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("RoleType", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<RoleType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(XName.Get("passProperty", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(PassPropertyType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    public class LinqToXsdTypeManager : ILinqToXsdTypeManager {
        
        static Dictionary<XName, System.Type> typeDictionary = new Dictionary<XName, System.Type>();
        
        static Dictionary<XName, System.Type> elementDictionary = new Dictionary<XName, System.Type>();
        
        private static XmlSchemaSet schemaSet;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        static LinqToXsdTypeManager typeManagerSingleton = new LinqToXsdTypeManager();
        
        static LinqToXsdTypeManager() {
            BuildTypeDictionary();
            BuildElementDictionary();
        }
        
        XmlSchemaSet ILinqToXsdTypeManager.Schemas {
            get {
                if ((schemaSet == null)) {
                    XmlSchemaSet tempSet = new XmlSchemaSet();
                    System.Threading.Interlocked.CompareExchange(ref schemaSet, tempSet, null);
                }
                return schemaSet;
            }
            set {
                schemaSet = value;
            }
        }
        
        Dictionary<XName, System.Type> ILinqToXsdTypeManager.GlobalTypeDictionary {
            get {
                return typeDictionary;
            }
        }
        
        Dictionary<XName, System.Type> ILinqToXsdTypeManager.GlobalElementDictionary {
            get {
                return elementDictionary;
            }
        }
        
        Dictionary<System.Type, System.Type> ILinqToXsdTypeManager.RootContentTypeMapping {
            get {
                return XTypedServices.EmptyTypeMappingDictionary;
            }
        }
        
        public static LinqToXsdTypeManager Instance {
            get {
                return typeManagerSingleton;
            }
        }
        
        private static void BuildTypeDictionary() {
            typeDictionary.Add(XName.Get("RebootType", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.RebootType));
            typeDictionary.Add(XName.Get("DependsOnType", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.DependsOnType));
            typeDictionary.Add(XName.Get("InstallType", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.InstallType));
            typeDictionary.Add(XName.Get("RunCommandType", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.RunCommandType));
            typeDictionary.Add(XName.Get("RunMsiType", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.RunMsiType));
            typeDictionary.Add(XName.Get("ComponentRefType", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.ComponentRefType));
            typeDictionary.Add(XName.Get("SharedPropertyType", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.SharedPropertyType));
            typeDictionary.Add(XName.Get("DomainChecksType", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.DomainChecksType));
            typeDictionary.Add(XName.Get("PassPropertyType", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.PassPropertyType));
            typeDictionary.Add(XName.Get("PropertyType", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.PropertyType));
            typeDictionary.Add(XName.Get("AggregateComponentType", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.AggregateComponentType));
            typeDictionary.Add(XName.Get("CheckUser", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.CheckUser));
            typeDictionary.Add(XName.Get("CheckGroup", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.CheckGroup));
            typeDictionary.Add(XName.Get("CheckGroupMembership", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.CheckGroupMembership));
            typeDictionary.Add(XName.Get("StatusCodeList", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.StatusCodeList));
            typeDictionary.Add(XName.Get("CommandType", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.CommandType));
            typeDictionary.Add(XName.Get("FileListType", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.FileListType));
            typeDictionary.Add(XName.Get("FileType", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.FileType));
            typeDictionary.Add(XName.Get("ChecksType", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.ChecksType));
            typeDictionary.Add(XName.Get("Check", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.Check));
            typeDictionary.Add(XName.Get("CheckDrive", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.CheckDrive));
            typeDictionary.Add(XName.Get("CheckFile", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.CheckFile));
            typeDictionary.Add(XName.Get("CheckFolder", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.CheckFolder));
            typeDictionary.Add(XName.Get("CheckValue", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.CheckValue));
            typeDictionary.Add(XName.Get("CheckRegistry", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.CheckRegistry));
            typeDictionary.Add(XName.Get("CheckService", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.CheckService));
            typeDictionary.Add(XName.Get("CheckWebSite", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.CheckWebSite));
            typeDictionary.Add(XName.Get("CommandCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.CommandCheck));
            typeDictionary.Add(XName.Get("LogicalCheck", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.LogicalCheck));
            typeDictionary.Add(XName.Get("RoleType", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.RoleType));
        }
        
        private static void BuildElementDictionary() {
            elementDictionary.Add(XName.Get("releases", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.releases));
            elementDictionary.Add(XName.Get("properties", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.properties));
            elementDictionary.Add(XName.Get("components", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.components));
            elementDictionary.Add(XName.Get("deploymentPhases", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.deploymentPhases));
            elementDictionary.Add(XName.Get("installSteps", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd"), typeof(global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.installSteps));
        }
        
        protected internal static void AddSchemas(XmlSchemaSet schemas) {
            schemas.Add(schemaSet);
        }
        
        public static System.Type GetRootType() {
            return elementDictionary[XName.Get("releases", "http://www.xboxlive.com/Deployment/Language/XMLSchema.xsd")];
        }
    }
    
    public partial class XRootNamespace {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XDocument doc;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedElement rootObject;
        

    public releases releases {  get {return rootObject as releases; } }

    public properties properties {  get {return rootObject as properties; } }

    public components components {  get {return rootObject as components; } }

    public deploymentPhases deploymentPhases {  get {return rootObject as deploymentPhases; } }

    public installSteps installSteps {  get {return rootObject as installSteps; } }
        
        private XRootNamespace() {
        }
        
        public XRootNamespace(releases root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        
        public XRootNamespace(properties root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        
        public XRootNamespace(components root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        
        public XRootNamespace(deploymentPhases root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        
        public XRootNamespace(installSteps root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        
        public XDocument XDocument {
            get {
                return doc;
            }
        }
        
        public static XRootNamespace Load(string xmlFile) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Load(xmlFile);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Load(string xmlFile, LoadOptions options) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Load(xmlFile, options);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Load(TextReader textReader) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Load(textReader);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Load(TextReader textReader, LoadOptions options) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Load(textReader, options);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Load(XmlReader xmlReader) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Load(xmlReader);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Parse(string text) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Parse(text);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Parse(string text, LoadOptions options) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Parse(text, options);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public virtual void Save(string fileName) {
            doc.Save(fileName);
        }
        
        public virtual void Save(TextWriter textWriter) {
            doc.Save(textWriter);
        }
        
        public virtual void Save(XmlWriter writer) {
            doc.Save(writer);
        }
        
        public virtual void Save(TextWriter textWriter, SaveOptions options) {
            doc.Save(textWriter, options);
        }
        
        public virtual void Save(string fileName, SaveOptions options) {
            doc.Save(fileName, options);
        }
    }
    
    public partial class XRoot {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XDocument doc;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedElement rootObject;
        

    public global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.releases releases {  get {return rootObject as global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.releases; } }

    public global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.properties properties {  get {return rootObject as global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.properties; } }

    public global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.components components {  get {return rootObject as global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.components; } }

    public global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.deploymentPhases deploymentPhases {  get {return rootObject as global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.deploymentPhases; } }

    public global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.installSteps installSteps {  get {return rootObject as global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.installSteps; } }
        
        private XRoot() {
        }
        
        public XRoot(global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.releases root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        
        public XRoot(global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.properties root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        
        public XRoot(global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.components root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        
        public XRoot(global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.deploymentPhases root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        
        public XRoot(global::www.xboxlive.com.Deployment.Language.XMLSchema.xsd.installSteps root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        
        public XDocument XDocument {
            get {
                return doc;
            }
        }
        
        public static XRoot Load(string xmlFile) {
            XRoot root = new XRoot();
            root.doc = XDocument.Load(xmlFile);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRoot Load(string xmlFile, LoadOptions options) {
            XRoot root = new XRoot();
            root.doc = XDocument.Load(xmlFile, options);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRoot Load(TextReader textReader) {
            XRoot root = new XRoot();
            root.doc = XDocument.Load(textReader);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRoot Load(TextReader textReader, LoadOptions options) {
            XRoot root = new XRoot();
            root.doc = XDocument.Load(textReader, options);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRoot Load(XmlReader xmlReader) {
            XRoot root = new XRoot();
            root.doc = XDocument.Load(xmlReader);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRoot Parse(string text) {
            XRoot root = new XRoot();
            root.doc = XDocument.Parse(text);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRoot Parse(string text, LoadOptions options) {
            XRoot root = new XRoot();
            root.doc = XDocument.Parse(text, options);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public virtual void Save(string fileName) {
            doc.Save(fileName);
        }
        
        public virtual void Save(TextWriter textWriter) {
            doc.Save(textWriter);
        }
        
        public virtual void Save(XmlWriter writer) {
            doc.Save(writer);
        }
        
        public virtual void Save(TextWriter textWriter, SaveOptions options) {
            doc.Save(textWriter, options);
        }
        
        public virtual void Save(string fileName, SaveOptions options) {
            doc.Save(fileName, options);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\EndToEndTests\TestInfrastructure\ValidatingTestNode.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Reflection;
using System.Xml.Linq;

using ServerTestFramework;
using System.Diagnostics;
using System.Linq.Expressions;
using Oct=schemas.microsoft.com.Octopus.Item2005.Item01.Service;
using DL = www.xboxlive.com.Deployment.Language.XMLSchema.xsd;
using DeploymentLanguageTests.Octopus;
using OctLookup = DeploymentLanguageTests.Octopus.Lookup;
using DeploymentLanguageTests.DeploymentLanguage;
using System.Text.RegularExpressions;

namespace DeploymentLanguageTests.TestInfrastructure
{
    public class ValidatingTestNode : TestNode
    {
        static readonly string MsiPathPrefix = @"..\..\";

        public ValidatingTestNode(DirectoryInfo info)
        {
            TestDirectoryInfo = info;
            Name = info.Name;
        }

        protected DirectoryInfo TestDirectoryInfo
        {
            get;
            private set;
        }

        static DirectoryInfo OutputInfo = new DirectoryInfo(Path.Combine(Path.GetTempPath(), Path.GetRandomFileName()));
        static string binaryPath = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "Binaries\\DeploymentLanguage.exe");

        public void Assert(Func<bool> expr)
        {
            if (!expr())
            {
                throw new ApplicationException(String.Format("The following assertion failed {0}", expr));
            }
        }

        public void Assert(string statement, Expression<Func<bool>> expr)
        {
            ThisChecks(statement);
            if (!expr.Compile()())
            {
                Fail();
            }

            Pass();
        }

        public void Assert(bool assertion)
        {
            if (!assertion)
            {
                throw new ApplicationException("Assertion Failed");
            }
        }

        public void ThisChecks(string criterium)
        {
            Console.Write("Validating that {0}...", criterium);
        }

        public void WriteLine(string writeLine, params object[] args)
        {
            if (args != null)
            {
                Console.WriteLine(" " + writeLine, args);
            } 
            else
            {
                Console.WriteLine(" " + writeLine);
            }
        }

        public void Fail()
        {
            Console.WriteLine("     FAIL");
            throw new ApplicationException();
        }

        public void Pass()
        {
            Console.WriteLine("     PASS");
        }

        public override void Run()
        {
            Console.WriteLine("Creating Directories Under {0}", OutputInfo.Name);
            OutputInfo.Create();

            DirectoryInfo input = OutputInfo.CreateSubdirectory("input");
            DirectoryInfo output = OutputInfo.CreateSubdirectory("output");

            foreach (var fileInfo in TestDirectoryInfo.GetFiles())
            {
                XDocument doc = XDocument.Load(fileInfo.FullName);
/*                foreach (var element in doc.Descendants())
                {
                    element.Name = element.Name.LocalName;
                }
                foreach (var attribute in doc.Descendants().SelectMany(x => x.Attributes()).Where(x => x.Name.LocalName == "xmlns"))
                {
                    attribute.Remove();
                }*/
                doc.Save(Path.Combine(input.FullName, fileInfo.Name));
            }
            

            try
            {
                Console.WriteLine("Running Language Compiler");
                ProcessStartInfo info = new ProcessStartInfo();
                info.FileName = binaryPath;
                info.UseShellExecute = false;
                info.RedirectStandardOutput = true;
                info.RedirectStandardError = true;
                info.CreateNoWindow = true;
                info.Arguments = String.Format("\"{0}\" \"{1}\"", input.FullName, output.FullName);

                
                Process p = Process.Start(info);
                Console.WriteLine(p.StandardOutput.ReadToEnd());
                p.WaitForExit();

                Assert("compiler returned zero exit code", () => p.ExitCode == 0);


                WriteLine("\nLoading Output Documents...\n");
                List<OctLookup> octLookups = output.GetFiles("service.xml", SearchOption.AllDirectories)
                    .Select(x => Oct.XRoot.Load(x.FullName))
                    .Select(x => new OctLookup(x)).ToList();

                WriteLine("\nLoading Input Documents...\n");
                DLLookup dlLookup = new DLLookup(input.GetFiles().Select(x=>DL.XRoot.Load(x.FullName)));

                WriteLine("\nPerforming Basic Sanity Checks...\n");
                foreach (var lookup in octLookups)
                {
                    var components = lookup.GetComponents();
                    Assert("every component is available via one or more roles",
                        () => components.Where(x => x.TopLevelRoles.Count() == 0).Count() == 0);
                    Assert("no components have dependency loops",
                        () => components.Where(x => DependencyLoopsFromComponent(x).Count() != 0).Count() == 0);
                    Assert("each component has a unique name",
                        () => components.Select(x => x.Name).GroupBy(x => x).Where(count => count.Count() > 1).Count() == 0);
                                  
                }
                var missingReleases =
                    from name in
                        from release in dlLookup.GetReleases()
                        from deploymentPhase in dlLookup.GetDeploymentPhases()
                        where deploymentPhase.Components.Select(x=>release.Components.Select(y=>y.Name).Contains(x.Name)).Count() != 0
                        select new { release, deploymentPhase }
                    where !octLookups.Select(x => x.ReleaseName).Contains(name.release + " " + name.deploymentPhase)
                    select name.release + " " + name.deploymentPhase;

                Assert("every release/deployment phase combo has a service xml", () => missingReleases.Count() == 0);

                var allRoleNames = octLookups.Where(x => x.ReleaseName.StartsWith("DefaultRelease")).SelectMany(x => x.GetRoles()).Select(x=>x.Name).ToList();

                Assert("every component has a corresponding role in the default release", () => dlLookup.GetComponents().Where(x => !allRoleNames.Contains(x.Name)).Count() == 0);

                Assert("every role has 'minServers' defined the same", ()=>octLookups
                    .SelectMany(x=>x.GetRoles())
                    .GroupBy(x=>x.Name)
                    .FindDifferent(x=>x.MinServers).Count() == 0);
                Assert("every role has 'maxServers' defined the same", () => octLookups
                    .SelectMany(x => x.GetRoles())
                    .GroupBy(x => x.Name)
                    .FindDifferent(x => x.MinServers).Count() == 0);
                Assert("every role has 'all servers' defined the same", () => octLookups
                    .SelectMany(x => x.GetRoles())
                    .GroupBy(x => x.Name)
                    .FindDifferent(x => x.AllServers).Count() == 0);

                Assert("every component uses minServer & maxServer or all servers, but not all three",
                  () => octLookups.SelectMany(x=>x.GetRoles()).Where(x => (x.MaxServers != null || x.MaxServers != null) ^ (x.AllServers)).Count() == 0);
              
 
                // there shouldn't be more than one component that has no dependencies that come from our set.
                foreach (var role in octLookups.SelectMany(x => x.GetRoles()))
                {
                    // Select the names of people who have at least one dependency 
                    var descendants = role.Lookup.GetComponent(role.Name).Descendants;
                    var componentsWithOneDependency = descendants.Explode(x=>x.RealDependencies, (x, y) => new { Parent = x, Child = y })
                        .Where(x=>descendants.Contains(x.Child)).Select(x=>x.Parent.Name);

                    Assert("{0} in {1} has only one child without any dependencies to peers".WithFormat(role.Name, role.Lookup.ReleaseName),
                       ()=>descendants.Select(x => x.Name).SetDifference(componentsWithOneDependency).Count() <= 1);  
                }

                foreach (var release in dlLookup.GetReleases())
                {
                    foreach (var phase in dlLookup.GetDeploymentPhases())
                    {
                        Lookup octLookup = octLookups.Where(x => x.ReleaseName == release.Name + " " + phase.Name).First();
                        foreach (var component in release.Components.Union(phase.Components))
                        {
                            WriteLine("Examining {0} in Release {1}, Phase {2}", component.Name, release.Name, phase.Name);

                            Assert(String.Format("A role exists for {0}", component.Name),
                                () => octLookup.GetRole(component.Name) != null);

                            
                            Queue<ShadowInstallStep> orderedSteps = new Queue<ShadowInstallStep>(component.OrderedSteps);
                            Queue<Octopus.Component> orderedComponents = new Queue<Octopus.Component>(octLookup.GetComponent(component.Name).OrderedComponents);

                            while (orderedSteps.Count != 0 && orderedComponents.Count != 0)
                            {
                                var shadow = orderedSteps.First();
                                var msiStep = orderedSteps.First().InstallStep as MsiInstallStep;
                                var commandStep = orderedSteps.First().InstallStep as CommandInstallStep;
                                var componentToBeExamined = orderedComponents.First();
                                if (!Compare(shadow, msiStep, componentToBeExamined))
                                {
                                    WriteLine("Skipping {0} because it doesn't match MSI contents of InstallStep {1}",
                                        componentToBeExamined.Name, shadow.Parent.InstallStep.Name);
                                    orderedComponents.Dequeue();
                                    continue;
                                }

                                if (!Compare(shadow, commandStep, componentToBeExamined))
                                {
                                    WriteLine("Skipping {0} because it doesn't match MSI contents of InstallStep {1}",
                                        componentToBeExamined.Name, shadow.Parent.InstallStep.Name);
                                    orderedComponents.Dequeue();
                                    continue;
                                }

                                //we matched both...
                                orderedComponents.Dequeue();
                                orderedSteps.Dequeue();
                            }

                            if (orderedSteps.Count != 0)
                            {
                                throw new ApplicationException(String.Format("Couldn't match last steps in component: {0}",
                                    String.Join(",", orderedSteps.Select(x => x.InstallStep.Name).ToArray())));
                            }
                        }
                    }
                }
            }
            finally
            {
                input.Delete(true);
                output.Delete(true);

            }
            return TEST_RESULTS.PASSED;
        }

        public bool Compare(ShadowInstallStep shadow, MsiInstallStep msiStep, Octopus.Component component)
        {
            MsiInfo msiInfo = component.MsiInfo;
            if (msiStep == null)
            {
                return component.MsiInfo == null;
            }

            if (component.MsiInfo == null)
            {
                return false;
            }

            if (component == null)
            {
                throw new ArgumentException("component");
            }

            Assert(String.Format("{0} has the right MSI path", component.Name),
            () => MsiPathPrefix + msiStep.Path ==  msiInfo.Path);

            Assert(String.Format("{0} passes properties only when it's supposed to.", component.Name),
                () => msiStep.PassPropertiesOnUninstall == msiInfo.PassesPropertiesOnUninstall);

            Assert(String.Format("{0} is correctly marked to (not) reboot on install / uninstall.", component.Name),
                () => msiStep.RebootOnInstall == component.RebootsOnInstall && msiStep.RebootOnUninstall == component.RebootsOnUninstall);

            Assert(String.Format("{0} has the right properties passed to it's MSI", component.Name),
                () => msiStep.PassedProperties.Keys.OrderBy(x => x).SequenceEqual(msiInfo.Properties.Keys.OrderBy(x => x)));

            Assert(String.Format("{0} has correct values for its properties", component.Name),
                ()=> msiStep.PassedProperties.OrderBy(x=>x.Key).Select(x=>shadow.NormalizedProperties[x.Key]).SequenceEqual(
                    msiInfo.Properties.OrderBy(x=>x.Key).Select(x=>component.NormalizedProperties[x.Key]).ToList()));
            return true;
        }


        public bool Compare(ShadowInstallStep shadow, CommandInstallStep command, Octopus.Component component)
        {

            if (command == null)
            {
                return component.InstallCommandInfo == null && component.UninstallCommandInfo == null;
            }

            if (component.InstallCommandInfo == null && component.UninstallCommandInfo == null)
            {
                return false;
            }

            if (component == null)
            {
                throw new ArgumentException("component");
            }

            CommandInfo installCommandInfo = component.InstallCommandInfo;
            CommandInfo uninstallCommandInfo = component.UninstallCommandInfo;

            Assert(String.Format("{0} has the right install command", component.Name),
                () => command.InstallCommand == null || 
                    NormalizeString(command.InstallCommand.cmd, shadow.NormalizedProperties) ==
                    NormalizeString(installCommandInfo.Command, component.NormalizedProperties));

            Assert(String.Format("{0} has the right uninstall command", component.Name),
                () => command.UninstallCommand == null ||
                    NormalizeString(command.UninstallCommand.cmd, shadow.NormalizedProperties) ==
                    NormalizeString(uninstallCommandInfo.Command, component.NormalizedProperties));

            return true;
        }

        public string NormalizeString(string aString, Dictionary<string, string> properties)
        {
            StringBuilder plainString = new StringBuilder();
            string[] pieces = Regex.Split(aString, "\\[([^]]*)\\]");
            for (int index = 0; index < pieces.Length; index++)
            {
                if (index % 2 == 0)
                {
                    plainString.Append(pieces[index]);
                }
                else
                {
                    plainString.Append(properties[pieces[index]]);
                }
            }

            return plainString.ToString();
        }

        public static IEnumerable<Octopus.Component> DependencyLoopsFromComponent(Octopus.Component component)
        {
            return DependencyLoopsFromComponent(component, new Stack<Octopus.Component>());
        }

        private static Stack<Octopus.Component> DependencyLoopsFromComponent(Octopus.Component component, Stack<Octopus.Component> visitedList)
        {
            if (visitedList.Contains(component))
            {
                visitedList.Push(component);
                return visitedList;
            }

            visitedList.Push(component);
            foreach (var dependency in component.RealDependencies)
            {
                Stack<Octopus.Component> stack = DependencyLoopsFromComponent(dependency, visitedList);
                if (stack.Count != 0)
                {
                    return stack;
                }
            }

            visitedList.Pop();
            return new Stack<Octopus.Component>();
        }
    }

    public static class ValidatingHelpers
    {
        public static IEnumerable<T> FindDifferent<T, U, V>(this IEnumerable<IGrouping<T, U>> list, Func<U,V> func)
        {
            return list.Where(x => x.GroupBy(func).Count() > 1).Select(x=>x.Key);
        }

        public static IEnumerable<V> CrossProduct<T, U, V>(this IEnumerable<T> firstList, IEnumerable<U> secondList, Func<T, U, V> resultSelector)
        {
            return firstList.Join(secondList, x => 0, x => 0, resultSelector);
        }

        public static IEnumerable<V> Explode<T, U, V>(this IEnumerable<T> firstList, Func<T, IEnumerable<U>> selector, Func<T, U, V> resultSelector)
        {
            foreach (var firstListObject in firstList)
            {
                foreach (var result in new T[] { firstListObject }.CrossProduct(selector(firstListObject), resultSelector))
                {
                    yield return result;
                }
            }
        }

        public static IEnumerable<T> SetDifference<T>(this IEnumerable<T> firstSet, IEnumerable<T> otherSet)
        {
            HashSet<T> returnValue = new HashSet<T>(firstSet);

            foreach (var value in otherSet)
            {
                returnValue.Remove(value);
            }
            return returnValue;
        }

        public static IEnumerable<T> SetIntersection<T>(this IEnumerable<T> firstSet, IEnumerable<T> otherSet)
        {
            foreach (var item in firstSet.Union(otherSet))
            {
                if (firstSet.Contains(item) && otherSet.Contains(item))
                {
                    yield return item;
                }
            }
        }

        public static string WithFormat(this string formatString, params object[] args)
        {
            return String.Format(formatString, args);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\src\ILanguageParser.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.tools.deploymentlanguage.Language;

namespace xonline.tools.deploymentlanguage
{
    public interface ILanguageParser
    {
        void ParseDirectory(string path, LanguageDefinition definition, LanguageErrors errorCollection);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\src\IOutputWriter.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace xonline.tools.deploymentlanguage
{
    public interface IOutputWriter
    {
        void WriteOutput(Definition definition, string outputPath);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\src\Definition.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.tools.deploymentlanguage.Octopus;
using xonline.tools.deploymentlanguage.Intermediate;
using xonline.tools.deploymentlanguage.Language;

namespace xonline.tools.deploymentlanguage
{
    public class Definition
    {
        private DeploymentPhase _currentDeploymentPhase;

        public DeploymentPhase DefaultDeploymentPhase { get; private set; }

        public Dictionary<string, ReleaseComponent> AllComponents { get; private set; }
        public Dictionary<string, InstallStepComponent> InstallStepComponents { get; private set; }
        public Dictionary<string, DeploymentPhase> DeploymentPhases { get; private set; }
        public Dictionary<string, Release> Releases { get; private set; }
        public Dictionary<string, OctopusProperty> GlobalProperties { get; private set; }

        /// <summary>
        /// Return the current deployment phase when going through different phases
        /// 
        /// If no current deployment phase set, it will take the default deployment phase
        /// </summary>
        public DeploymentPhase CurrentDeploymentPhase
        {
            get
            {
                if (_currentDeploymentPhase == null)
                {
                    _currentDeploymentPhase = DefaultDeploymentPhase;
                }

                return _currentDeploymentPhase;
            }
        }

        public Dictionary<string, ReleaseComponent> Components
        {
            get
            {
                return CurrentDeploymentPhase.Components;
            }
        }

        public Dictionary<string, ReleaseComponent> DependsOnAllComponents
        {
            get
            {
                return CurrentDeploymentPhase.DependsOnAllComponents;
            }
        }

        public Dictionary<string, ReleaseComponent> DependedByAllComponents
        {
            get
            {
                return CurrentDeploymentPhase.DependedByAllComponents;
            }
        }

        public Definition()
        {
            AllComponents = new Dictionary<string, ReleaseComponent>();
            InstallStepComponents = new Dictionary<string, InstallStepComponent>();
            DeploymentPhases = new Dictionary<string, DeploymentPhase>();
            Releases = new Dictionary<string, Release>();
            GlobalProperties = new Dictionary<string, OctopusProperty>();
        }

        #region Adding Components

        /// <summary>
        /// Add an install step component to the global install step list
        /// </summary>
        /// <param name="installStepComponent"></param>
        public void AddInstallStepComponent(InstallStepComponent installStepComponent)
        {
            InstallStepComponents.Add(installStepComponent.Name, installStepComponent);
        }

        #endregion

        /// <summary>
        /// Set the current active deployment phase for processing and output
        /// </summary>
        /// <param name="deploymentPhase"></param>
        public void SetCurrentDeploymentPhase(DeploymentPhase deploymentPhase)
        {
            _currentDeploymentPhase = deploymentPhase;
        }

        /// <summary>
        /// Set the default deployment phase to be used for components that did not define
        /// a deployment phase
        /// </summary>
        /// <param name="deploymentPhase"></param>
        public void SetDefaultDeploymentPhase(DeploymentPhase deploymentPhase)
        {
            DefaultDeploymentPhase = deploymentPhase;
        }

        /// <summary>
        /// Set global properties from the language
        /// </summary>
        /// <param name="propertyList"></param>
        public void SetGlobalProperties(IList<LanguageProperty> propertyList)
        {
            GlobalProperties = OctopusProperty.GetPropertyList(propertyList.ToArray<LanguageProperty>());
        }

        /// <summary>
        /// Add a used global property to the current deployment phase for tracking which
        /// global properties are used
        /// </summary>
        /// <param name="name"></param>
        public bool AddUsedGlobalProperty(string propertyName)
        {
            if (GlobalProperties.ContainsKey(propertyName))
            {
                return CurrentDeploymentPhase.UsedGlobalProperties.Add(GlobalProperties[propertyName]);
            }

            return false;
        }

        public void AddUsedGlobalProperty(IEnumerable<string> propertyNames)
        {
            foreach (var propertyName in propertyNames)
            {
                AddUsedGlobalProperty(propertyName);
            }
        }

        public void ClearInstallStepRelationships()
        {
            foreach (var installStep in InstallStepComponents.Values)
            {
                installStep.ClearRelationships();
                installStep.ClearDependencies();
            }
        }

        public void ClearAllComponentDependencyRelationships()
        {
            foreach (var component in DependedByAllComponents.Values)
            {
                component.ClearRelationships();
                component.ClearDependencies();
            }

            foreach (var component in DependsOnAllComponents.Values)
            {
                component.ClearRelationships();
                component.ClearDependencies();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\src\Engine.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;
using System.IO;

namespace xonline.tools.deploymentlanguage
{
    public class Engine
    {
        private ILanguageParser _parser;
        private IEnumerable<IProcessor> _preprocessors;
        private IEnumerable<IProcessor> _processors;
        private IOutputWriter _outputWriter;

        private LanguageDefinition _languageDefinition = new LanguageDefinition();
        private Definition _definition = new Definition();
        private LanguageErrors _errorCollection = new LanguageErrors();

        public Engine(ILanguageParser parser, IEnumerable<IProcessor> preprocessors, IEnumerable<IProcessor> processors, IOutputWriter outputWriter)
        {
            _parser = parser;
            _preprocessors = preprocessors;
            _processors = processors;
            _outputWriter = outputWriter;
        }

        public Engine()
        {
            _parser = DefaultParser;
            _preprocessors = DefaultPreprocessors;
            _processors = DefaultProcessors;
            _outputWriter = DefaultWriter;
        }

        public void ParseDirectory(string path)
        {
            if (_parser != null)
            {
                _parser.ParseDirectory(path, _languageDefinition, _errorCollection);
            }
        }

        public void Process(string outputPath)
        {
            if (_processors != null)
            {
                // Run preprocessors to validate and create object models
                foreach (var preprocessor in _preprocessors)
                {
                    if (_errorCollection.Count > 0)
                    {
                        return;
                    }

                    preprocessor.Process(_languageDefinition, _definition, _errorCollection);
                }

                // Run through all processors for all deployment phases
                foreach (var deploymentPhase in _definition.DeploymentPhases.Values)
                {
                    _definition.SetCurrentDeploymentPhase(deploymentPhase);
                    _definition.ClearInstallStepRelationships();
                    _definition.ClearAllComponentDependencyRelationships();

                    if (_definition.Components.Count > 0)
                    {
                        foreach (var processor in _processors)
                        {
                            if (_errorCollection.Count > 0)
                            {
                                return;
                            }

                            processor.Process(_languageDefinition, _definition, _errorCollection);
                        }

                        if (_errorCollection.Count > 0)
                        {
                            return;
                        }

                        if (_outputWriter != null)
                        {
                            _outputWriter.WriteOutput(_definition, outputPath);
                        }
                    }
                }
            }
        }

        private void DebugDefinition()
        {
            Console.WriteLine("Components: " + _languageDefinition.Components.Count);
            Console.WriteLine("Install Steps: " + _languageDefinition.InstallSteps.Count);
            Console.WriteLine("Releases: " + _languageDefinition.Releases.Count);
            Console.WriteLine("Deployment Phases: " + _languageDefinition.DeploymentPhases.Count);
        }

        public LanguageErrors ErrorCollection
        {
            get { return _errorCollection; }
        }

        public static ILanguageParser DefaultParser
        {
            get
            {
                return new LanguageParser();
            }
        }

        public static List<IProcessor> DefaultPreprocessors
        {
            get
            {
                List<IProcessor> processors = new List<IProcessor>();
                processors.Add(new ProcessValidation());
                processors.Add(new ProcessCollections());

                return processors;
            }
        }

        public static List<IProcessor> DefaultProcessors
        {
            get
            {
                List<IProcessor> processors = new List<IProcessor>();
                processors.Add(new ProcessResolveComponents());
                processors.Add(new ProcessDependsOn());
                processors.Add(new ProcessDependencyCheck());
                processors.Add(new ProcessDuplicateComponents());
                processors.Add(new ProcessProperties());
                processors.Add(new ProcessUniqueNames());

                return processors;
            }
        }

        public static IOutputWriter DefaultWriter
        {
            get
            {
                return new OutputOctopus();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\src\IProcessor.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace xonline.tools.deploymentlanguage
{
    public interface IProcessor
    {
        void Process(LanguageDefinition languageDefinition, Definition definition, LanguageErrors errorCollection);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\src\LanguageDefinition.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.tools.deploymentlanguage.Language;

namespace xonline.tools.deploymentlanguage
{
    public class LanguageDefinition
    {
        public LanguageDefinition()
        {
            Components = new List<LanguageComponent>();
            InstallSteps = new List<InstallStep>();
            Releases = new List<LanguageRelease>();
            DeploymentPhases = new List<LanguageDeploymentPhase>();
            Properties = new List<LanguageProperty>();
        }

        public IList<LanguageComponent> Components { get; set; }
        public IList<InstallStep> InstallSteps { get; set; }
        public IList<LanguageRelease> Releases { get; set; }
        public IList<LanguageDeploymentPhase> DeploymentPhases { get; set; }
        public IList<LanguageProperty> Properties { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\src\OctopusDependenciesSetter.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.tools.deploymentlanguage.Intermediate;
using xonline.tools.deploymentlanguage.Octopus;
using xonline.tools.deploymentlanguage.Language;

namespace xonline.tools.deploymentlanguage
{
    public class OctopusDependenciesSetter
    {
        public const string DefaultReleaseName = "DefaultRelease";

        public Release Release { get; private set; }

        public string ReleaseName { get; private set; }

        public HashSet<ReleaseComponent> ReleaseComponents { get; private set; }

        private Definition _definition;

        // Keep track of components referenced by server list properties for automatic generation
        private HashSet<ServerList> _serverListComponentNames;
        private HashSet<string> _allComponentNames;

        public OctopusDependenciesSetter(Definition definition)
        {
            _definition = definition;
        }

        public void SetRelease(Release release)
        {
            if (release != null)
            {
                Release = release;
                ReleaseName = release.Name;
                ReleaseComponents = release.ReleaseComponents;

                foreach (var component in _definition.DependedByAllComponents.Values)
                {
                    if (component.OriginalComponentLanguage.Servers == ComponentServersValue.All)
                    {
                        ReleaseComponents.Add(component);
                    }
                }

                foreach (var component in _definition.DependsOnAllComponents.Values)
                {
                    if (component.OriginalComponentLanguage.Servers == ComponentServersValue.All)
                    {
                        ReleaseComponents.Add(component);
                    }
                }
            }
            else
            {
                ReleaseName = DefaultReleaseName;
                ReleaseComponents = new HashSet<ReleaseComponent>(_definition.Components.Values.ToArray<ReleaseComponent>());
            }
        }

        public void Process()
        {
            _serverListComponentNames = new HashSet<ServerList>();
            _allComponentNames = new HashSet<string>();

            // Clear all aggregateComponents and requireInterfaces in Octopus components
            PrepareAllComponents();

            // Clear global properties used
            _definition.CurrentDeploymentPhase.UsedGlobalProperties.Clear();

            // Go through all components and gather any global properties used by them
            GatherUsedGlobalProperties(ReleaseComponents);

            // Check global properties to see if they reference other properties, if they do, add them as well
            // Do this recursively until no new properties are found
            var usedPropertiesAdded = 0;
            do
            {
                usedPropertiesAdded = GatherUsedGlobalProperties(_definition.CurrentDeploymentPhase.UsedGlobalProperties);
            } while (usedPropertiesAdded > 0);

            GatherServerListComponents(_definition.CurrentDeploymentPhase.UsedGlobalProperties);

            // Recursively go through all components and write out the aggregateComponents, require/publish interfaces
            foreach (var component in ReleaseComponents)
            {
                GatherServerListComponents(component);
                SetAggregates(component);
                SetDependencies(component);
            }

            AddComponentsIfNotExists();
        }

        private void GatherServerListComponents(ICollection<OctopusProperty> properties)
        {
            foreach (var property in properties)
            {
                if (property.ServerList != null)
                {
                    _serverListComponentNames.Add(property.ServerList);
                }
            }
        }

        private void GatherServerListComponents(Component component)
        {
            _allComponentNames.Add(component.Name);

            GatherServerListComponents(component.Octopus.PropertyList.Values);

            foreach (var installRelationship in component.InstallComponents)
            {
                GatherServerListComponents((Component)installRelationship.InstallComponent);
            }
        }

        private void AddComponentsIfNotExists()
        {
            foreach (var serverListComponent in _serverListComponentNames)
            {
                if (!_allComponentNames.Contains(serverListComponent.Name))
                {
                    if (serverListComponent.Type == ServerListType.RequireInterface)
                    {
                        // Should generate an error if the requireInterface references a component
                        // that doesn't exist.                        
                    }
                    else
                    {
                        var component = new ReleaseComponent(serverListComponent.Name);
                        component.Octopus.PublishInterface = component.Name;
                        ReleaseComponents.Add(component);
                    }
                }
            }
        }

        private void SetAggregates(Component component)
        {
            SetAggregates(component, new RequireInterfaceCollection());
        }

        private void SetAggregates(Component component, RequireInterfaceCollection requireInterfaces)
        {
            IInstallComponent previousComponent = null;

            if (component.InstallComponents.Count > 0)
            {
                foreach (var installRelationship in component.InstallComponents)
                {
                    if (!component.Octopus.AggregateComponents.ContainsKey(installRelationship.InstallComponent.Name))
                    {
                        // Create an aggregate component for all install components
                        var aggregateComponent = new AggregateComponent(installRelationship.InstallComponent.Name, installRelationship.PassProperties);
                        component.Octopus.AggregateComponents.Add(installRelationship.InstallComponent.Name, aggregateComponent);
                    }

                    // Create a list of dependencies on element order seen in installComponents list
                    if (previousComponent != null)
                    {
                        requireInterfaces.Add(previousComponent.Octopus.PublishInterface, DependsOnWaitValue.Same);
                    }

                    // Recursively set the aggregates for all install components
                    // If it's a runOnce install step, it should start a new list of requireInterfaces
                    if (installRelationship.InstallComponent is InstallStepComponent &&
                        ((InstallStepComponent)installRelationship.InstallComponent).RunOnce)
                    {
                        SetAggregates((Component)installRelationship.InstallComponent, new RequireInterfaceCollection());
                    }
                    else
                    {
                        SetAggregates((Component)installRelationship.InstallComponent, requireInterfaces);
                    }

                    previousComponent = installRelationship.InstallComponent;
                }
            }
            else
            {
                // When we reach the leaf node, we can put down all the dependencies
                foreach (var requireInterface in requireInterfaces.Values)
                {
                    component.Octopus.RequireInterfaces.Add(requireInterface);
                }

                requireInterfaces.Clear();
            }
        }

        private void SetDependencies(ReleaseComponent component)
        {
            SetDependencies(component, new HashSet<DependOnComponent>());
        }

        private void SetDependencies(ReleaseComponent component, bool notUsed)
        {
            var dependencyList = CollectDependencies(component);

            foreach (var dependency in dependencyList)
            {
                if (dependency is ReleaseComponent && ReleaseComponents.Contains((ReleaseComponent)dependency))
                {
                    component.Octopus.RequireInterfaces.Add(dependency.Name);
                }
            }
        }

        private HashSet<ReleaseComponent> CollectDependencies(Component component)
        {
            var dependencyList = new HashSet<ReleaseComponent>();

            // Gather all dependencies within the depended components
            foreach (var dependentComponent in component.DependsOnComponents)
            {
                dependencyList.Add((ReleaseComponent)dependentComponent.Component);

                var dependsOnList = CollectDependencies((Component)dependentComponent.Component);
                dependencyList.UnionWith(dependsOnList);
            }

            foreach (var installComponent in component.InstallComponents)
            {
                var installDependencyList = CollectDependencies((Component)installComponent.InstallComponent);
                dependencyList.UnionWith(installDependencyList);
            }

            return dependencyList;
        }

        private void SetDependencies(Component component, HashSet<DependOnComponent> dependOnComponents)
        {
            var currentComponentDependOnComponents = new HashSet<DependOnComponent>(dependOnComponents);

            foreach (var dependentComponent in component.DependsOnComponents)
            {
                currentComponentDependOnComponents.Add(dependentComponent);
            }

            bool canPushDownDependencies = false;

            if (component.InstallComponents.Count > 0)
            {
                foreach (var installRelationship in component.InstallComponents)
                {
                    if ((installRelationship.InstallComponent is InstallStepComponent) &&
                        ((InstallStepComponent)installRelationship.InstallComponent).RunOnce)
                    {
                        // If it is a runOnce install step, clear the dependency list before going through the install steps
                        SetDependencies((Component)installRelationship.InstallComponent, new HashSet<DependOnComponent>());
                    }
                    else
                    {
                        // Recursively go through the install components to push down dependencies
                        canPushDownDependencies = true;
                        SetDependencies((Component)installRelationship.InstallComponent, currentComponentDependOnComponents);
                    }
                }
            }
            
            if (!canPushDownDependencies)
            {
                foreach (var dependOnComponent in currentComponentDependOnComponents)
                {
                    if (ReleaseComponents.Contains(dependOnComponent.Component))
                    {
                        component.Octopus.RequireInterfaces.Add(dependOnComponent.Component.Name, dependOnComponent.WaitValue);
                    }
                }
            }
        }

        private void PrepareAllComponents()
        {
            foreach (var component in _definition.Components.Values)
            {
                PrepareComponent(component);
            }
        }

        private void PrepareComponent(Component component)
        {
            if (String.IsNullOrEmpty(component.Octopus.PublishInterface))
            {
                component.Octopus.PublishInterface = component.Name;
            }

            component.Octopus.RequireInterfaces = new RequireInterfaceCollection();
            component.Octopus.AggregateComponents = new Dictionary<string, AggregateComponent>();

            foreach (var installComponent in component.InstallComponents)
            {
                PrepareComponent((Component)installComponent.InstallComponent);
            }
        }


        private void GatherUsedGlobalProperties(IEnumerable<ReleaseComponent> components)
        {
            foreach (var component in components)
            {
                GatherUsedGlobalProperties(component);
            }
        }

        /// <summary>
        /// Find out which global properties are used and record it for the deployment phase
        /// </summary>
        /// <param name="component"></param>
        private void GatherUsedGlobalProperties(Component component)
        {
            GatherUsedGlobalProperties(component.Octopus.PropertyList.Values);

            if (component.Octopus.Msi != null)
            {
                GatherUsedGlobalProperties(component.Octopus.Msi.PropertyList.Values);
            }

            foreach (var installRelationship in component.InstallComponents)
            {
                GatherUsedGlobalProperties((Component)installRelationship.InstallComponent);
            }
        }

        /// <summary>
        /// Checks all property values to see if they reference other properties, if they do,
        /// add them to the used property list as well.
        /// </summary>
        /// <param name="properties">Properties to check their values for</param>
        /// <returns>Number of properties added to the used property list</returns>
        private int GatherUsedGlobalProperties(ICollection<OctopusProperty> properties)
        {
            var propertiesUsed = new HashSet<string>();

            foreach (var property in properties)
            {
                foreach (var propertyUsed in ProcessProperties.FindProperties(property.Value))
                {
                    if (_definition.GlobalProperties.ContainsKey(propertyUsed))
                    {
                        propertiesUsed.Add(propertyUsed);
                    }
                }
            }

            int usedPropertiesAdded = 0;

            foreach (var property in propertiesUsed)
            {
                if (_definition.AddUsedGlobalProperty(property))
                {
                    usedPropertiesAdded++;
                }
            }

            return usedPropertiesAdded;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\src\Timer.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;

namespace xonline.tools.deploymentlanguage
{
    public static class Timer
    {
        private static Dictionary<string, Stopwatch> _timers = new Dictionary<string, Stopwatch>();

        [Conditional("USETIMERS")]
        public static void Clear()
        {
            _timers = new Dictionary<string, Stopwatch>();
        }

        [Conditional("USETIMERS")]
        public static void StartTimer(string name)
        {
            Stopwatch timer = new Stopwatch();
            _timers.Add(name, timer);

            timer.Start();
        }

        [Conditional("USETIMERS")]
        public static void StopTimer(string name)
        {
            _timers[name].Stop();
        }

        [Conditional("USETIMERS")]
        public static void DebugTimers()
        {
            foreach (KeyValuePair<string, Stopwatch> kv in _timers)
            {
                Console.WriteLine("{0}: {1}", kv.Key, kv.Value.ElapsedMilliseconds);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\src\Util.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters.Binary;
using System.Xml;
using System.Xml.Serialization;
using System.Text.RegularExpressions;

namespace xonline.tools.deploymentlanguage
{
    public static class Util
    {
        public static T CloneObject<T>(T objectToClone)
        {
            using (Stream objectStream = new MemoryStream())
            {
                IFormatter formatter = new BinaryFormatter();
                formatter.Serialize(objectStream, objectToClone);
                objectStream.Seek(0, SeekOrigin.Begin);
                return (T)formatter.Deserialize(objectStream);
            }
        }

        public static string GetXmlEnumName(Type enumType, string enumName)
        {
            foreach (var attribute in enumType.GetField(enumName.ToString()).GetCustomAttributes(true))
            {
                if (attribute is XmlEnumAttribute)
                {
                    return ((XmlEnumAttribute)attribute).Name;
                }
            }

            return null;
        }

        public static bool IsValidFilename(string name)
        {
            var invalidChars = new Regex(String.Format("[{0}]", Regex.Escape(new string(Path.GetInvalidFileNameChars()))));

            return !invalidChars.IsMatch(name);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\src\Error\LanguageError.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace xonline.tools.deploymentlanguage
{
    /// <summary>
    /// Represents and error happened while parsing or processing the input definition
    /// </summary>
    public class LanguageError
    {
        public ErrorId ErrorId { get; private set; }
        public string Message { get; private set; }
        public int LineNumber { get; private set; }
        public int LinePosition { get; private set; }
        public string FileName { get; private set; }
        public Exception InnerException { get; private set; }

        public LanguageError(string filename, ErrorId errorId, params string[] args)
        {
            FileName = filename;
            ErrorId = errorId;
            Message = LanguageErrorMessages.GetMessage(errorId, args);
        }

        public LanguageError(string filename, ErrorId errorId, int lineNumber, int linePosition, params string[] args)
            : this(filename, errorId, args)
        {
            LineNumber = lineNumber;
            LinePosition = linePosition;
        }

        public LanguageError(string filename, Exception innerException)
            : this(filename, ErrorId.GenericException)
        {
            InnerException = innerException;
        }

        public override string ToString()
        {
            var sb = new StringBuilder();
            if (!String.IsNullOrEmpty(FileName))
            {
                sb.Append(FileName);

                if (LineNumber != 0)
                {
                    sb.Append("(" + LineNumber + ")");
                }

                sb.Append(": ");
            }

            sb.Append(Message);

            return sb.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\src\Program.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml.Serialization;
using System.IO;
using System.Xml;
using System.Diagnostics;
using xonline.tools.deploymentlanguage;
using xonline.tools.deploymentlanguage.Language;

namespace xonline.tools.deploymentlanguage.console
{
    public class Program
    {
        public static int Main(string[] args)
        {
            string path = null;
            string outputPath = null;

            if (args.Length > 0 && args[0].Equals("/?"))
            {
                Usage();
                return 0;
            }
            else if (args.Length != 2)
            {
                Usage();
                return 1;
            }
            else
            {
                path = args[0];
                outputPath = args[1];
            }

            if (String.IsNullOrEmpty(path) || String.IsNullOrEmpty(outputPath))
            {
                Usage();
                return 1;
            }

            try
            {
                WriteLine();
                WriteLine("Deployment Language Compiler");
                WriteLine();
                WriteLine("  Beginning processing {0}", path);

                // Setup engine and processing
                Engine engine = new Engine(Engine.DefaultParser, Engine.DefaultPreprocessors, Engine.DefaultProcessors, Engine.DefaultWriter);
                engine.ParseDirectory(path);
                engine.Process(outputPath);

                // Output timers if enabled
                Timer.DebugTimers();

                // Return error code 1 if any language error occured
                if (engine.ErrorCollection.Count == 0)
                {
                    WriteLine();
                    WriteLine(ConsoleColor.Green, "  service.xml(s) created with no errors at {0}", Path.Combine(outputPath, OutputOctopus.OctopusPathName));
                    WriteLine();

                    return 0;
                }
                else
                {
                    WriteLine();
                    WriteLine("  Unable to finish compiling deployment definitions, please correct the");
                    WriteLine("  following errors before proceeding:");
                    WriteLine();

                    // Output Errors
                    foreach (LanguageError error in engine.ErrorCollection)
                    {
                        WriteLine(ConsoleColor.Red, error.ToString());
                        WriteLine();
                    }

                    return 1;
                }
            }
            catch (Exception e)
            {
                WriteLine(e.ToString());

                return 1;
            }
        }

        private static void Usage()
        {
            Console.WriteLine("Deployment Language Compiler");
            Console.WriteLine("  Compiles definition into Octopus service.xml");
            Console.WriteLine();
            Console.WriteLine("  Usage:");
            Console.WriteLine("\t{0} <definitionPath> <outputPath>", typeof(Program).Assembly.ManifestModule.Name);
            Console.WriteLine();
            Console.WriteLine("\t<definitionPath> - Directory containing definition xmls");
            Console.WriteLine("\t<outputPath> - Directory for service.xml output");
            Console.WriteLine();
        }

        private static void WriteLine()
        {
            Console.WriteLine();
        }

        private static void WriteLine(string text, params string[] args)
        {
            Console.WriteLine(text, args);
        }

        private static void WriteLine(ConsoleColor color, string text, params string[] args)
        {
            ConsoleColor originalColor = Console.ForegroundColor;
            Console.ForegroundColor = color;
            Console.WriteLine(text, args);
            Console.ForegroundColor = originalColor;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\src\LanguageParser.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml.Serialization;
using System.IO;
using System.Xml.Linq;
using System.Xml;
using System.Xml.Schema;
using xonline.tools.deploymentlanguage.Language;
using System.Reflection;

namespace xonline.tools.deploymentlanguage
{
    public class LanguageParser : ILanguageParser
    {
        private Dictionary<string, XmlSerializer> _serializerMapping = new Dictionary<string, XmlSerializer>();
        private LanguageDefinition _definition;

        LanguageErrors _errorCollection;
        string _currentFile;

        private const string _timerPrefix = "[Parser] ";

        public LanguageParser()
        {
            Initialize();
        }

        private void Initialize()
        {
            Timer.StartTimer(_timerPrefix + "Initialize");

            AddNameClassMapping("components", typeof(LanguageComponents));
            AddNameClassMapping("installSteps", typeof(InstallSteps));
            AddNameClassMapping("releases", typeof(Releases));
            AddNameClassMapping("deploymentPhases", typeof(DeploymentPhases));
            AddNameClassMapping("properties", typeof(LanguageProperties));

            Timer.StopTimer(_timerPrefix + "Initialize");
        }

        private void AddNameClassMapping(string name, Type type)
        {
            var serializer = new XmlSerializer(type);
            serializer.UnknownAttribute += new XmlAttributeEventHandler(UnknownHandler);
            serializer.UnknownElement += new XmlElementEventHandler(UnknownHandler);

            _serializerMapping.Add(name, serializer);
        }

        private void UnknownHandler(object sender, EventArgs args)
        {
            if (args is XmlAttributeEventArgs)
            {
                var xmlAttributeEventArgs = (XmlAttributeEventArgs)args;

                if (xmlAttributeEventArgs.ExpectedAttributes.Contains(":" + xmlAttributeEventArgs.Attr.Name))
                {
                    _errorCollection.Add(_currentFile, ErrorId.ParserExtraAttribute, xmlAttributeEventArgs.Attr.Name);
                }
                //else
                //{
                //    _errorCollection.Add(
                //        _currentFile,
                //        ErrorId.ParserUnknownAttribute,
                //        xmlAttributeEventArgs.LineNumber,
                //        xmlAttributeEventArgs.LinePosition,
                //        xmlAttributeEventArgs.Attr.Name,
                //        xmlAttributeEventArgs.ExpectedAttributes
                //        );
                //}

            }
            else if (args is XmlElementEventArgs)
            {
                var xmlElementEventArgs = (XmlElementEventArgs)args;

                if (xmlElementEventArgs.ExpectedElements.Contains(":" + xmlElementEventArgs.Element.Name))
                {
                    _errorCollection.Add(_currentFile, ErrorId.ParserExtraElement, xmlElementEventArgs.Element.Name);
                }
                //else
                //{
                //    _errorCollection.Add(
                //        _currentFile,
                //        ErrorId.ParserUnknownElement,
                //        xmlElementEventArgs.LineNumber,
                //        xmlElementEventArgs.LinePosition,
                //        xmlElementEventArgs.Element.Name,
                //        xmlElementEventArgs.ExpectedElements
                //        );
                //}
            }
        }

        private void OnValidationError(object sender, ValidationEventArgs args)
        {
            var message = args.Message;

            if (message.EndsWith("is not declared.") && sender is XAttribute)
            {
                message = "The '" + ((XAttribute)sender).Name + "' attribute is not expected.";
            }

            if (sender is XObject)
            {
                var xObject = (XObject)sender;
                                
                if (xObject is XElement)
                {
                    message = "In '" + ((XElement)xObject).Name + "', " + message;
                }
                else if (xObject.Parent != null)
                {
                    message = "In '" + xObject.Parent.Name + "', " + message;
                }
            }
            _errorCollection.Add(_currentFile, ErrorId.ParserValidationError, args.Exception.LineNumber, args.Exception.LinePosition, message);
        }

        public void ParseDirectory(string path, LanguageDefinition definition, LanguageErrors errorCollection)
        {
            _errorCollection = errorCollection;
            _definition = definition;

            foreach (var file in Directory.GetFiles(path, "*.xml", SearchOption.AllDirectories))
            {
                Timer.StartTimer(_timerPrefix + file);

                DeserializeXmlToDefinition(file);

                Timer.StopTimer(_timerPrefix + file);
            }
        }

        private void DeserializeXmlToDefinition(string file)
        {
            string typeName = null;
            LanguageElement serializedObjects = null;

            _currentFile = file;

            Timer.StartTimer(_timerPrefix + file + " Serialize");

            try
            {
                var xDocument = XDocument.Load(file);

                RemoveNamespace(xDocument);
               
                // Find out what the root element of the xml is to get the correct serializer
                typeName = xDocument.Root.Name.LocalName;

                if (!String.IsNullOrEmpty(typeName) && _serializerMapping.ContainsKey(typeName))
                {
                    // Validate the xml using the xsd
                    xDocument.Validate(GetXmlSchemaSet(), OnValidationError);
                
                    // Deserialize xml to one of the objects
                    var serializer = _serializerMapping[typeName];
                    serializedObjects = (LanguageElement)serializer.Deserialize(xDocument.CreateReader());
                }
                else
                {
                    // if serializerMapping does not contain typeName, output an error
                    var message = String.Format("Unknown root tag: {0}", typeName);
                    _errorCollection.Add(file, ErrorId.ParserFailedToReadXml, message);

                    return;
                }
            }
            catch (InvalidOperationException e)
            {
                var message = new StringBuilder();
                Exception ex = e;

                do
                {
                    message.AppendLine(ex.Message);
                } while (null != (ex = ex.InnerException));

                _errorCollection.Add(file, ErrorId.ParserFailedToReadXml, message.ToString().Trim());
            }
            catch (XmlException e)
            {
                var message = new StringBuilder();
                Exception ex = e;

                do
                {
                    message.AppendLine(ex.Message);
                } while (null != (ex = ex.InnerException));

                _errorCollection.Add(file, ErrorId.ParserFailedToReadXml, e.LineNumber, e.LinePosition, message.ToString().Trim());
            }

            // Add the elements to the definition
            AddToDefinition(typeName, serializedObjects);

            Timer.StopTimer(_timerPrefix + file + " Serialize");
        }

        private void AddToDefinition(string typeName, LanguageElement serializedObjects)
        {
            if (serializedObjects != null)
            {
                serializedObjects.CreateEmptyListsOnNulls();

                switch (typeName)
                {
                    case "components":
                        PopulateDefinition<LanguageComponent>(((LanguageComponents)serializedObjects).ComponentList, _definition.Components);
                        break;
                    case "installSteps":
                        PopulateDefinition<InstallStep>(((InstallSteps)serializedObjects).InstallStepList, _definition.InstallSteps);
                        break;
                    case "releases":
                        PopulateDefinition<LanguageRelease>(((Releases)serializedObjects).ReleaseList, _definition.Releases);
                        break;
                    case "deploymentPhases":
                        PopulateDefinition<LanguageDeploymentPhase>(((DeploymentPhases)serializedObjects).DeploymentPhaseList, _definition.DeploymentPhases);
                        break;
                    case "properties":
                        PopulateDefinition<LanguageProperty>(((LanguageProperties)serializedObjects).PropertyList, _definition.Properties);
                        break;
                }
            }
        }

        private void RemoveNamespace(XDocument xDocument)
        {
            // Remove namespace
            foreach (var e in xDocument.Root.DescendantsAndSelf())
            {
                e.Name = e.Name.LocalName;
            }

            var attribute = xDocument.Root.Attribute("xmlns");
            if (attribute != null)
            {
                attribute.Remove();
            }
        }

        private XmlSchemaSet GetXmlSchemaSet()
        {
            var schemas = new XmlSchemaSet();
            schemas.Add("", XmlReader.Create(Assembly.GetExecutingAssembly().GetManifestResourceStream("xonline.tools.deploymentlanguage.Language.schema.xsd")));

            return schemas;
        }

        private XmlReaderSettings GetXmlReaderSettings()
        {
            var settings = new XmlReaderSettings();
            settings.ValidationType = ValidationType.Schema;
            settings.Schemas = GetXmlSchemaSet();
            settings.ValidationFlags =
                XmlSchemaValidationFlags.ProcessIdentityConstraints |
                XmlSchemaValidationFlags.ReportValidationWarnings;
            settings.ValidationEventHandler += OnValidationError;

            return settings;
        }

        private void PopulateDefinition<T>(T[] elementList, IList<T> definitionList) where T : ILanguageTopElement
        {
            foreach (var element in elementList)
            {
                element.FileName = _currentFile;
                definitionList.Add(element);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\src\Error\LanguageErrorMessages.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace xonline.tools.deploymentlanguage
{
    public enum ErrorId
    {
        GenericException,
        ParserExtraElement,
        ParserUnknownElement,
        ParserExtraAttribute,
        ParserUnknownAttribute,
        ParserFailedToReadXml,
        ParserValidationError,
        DuplicateReleaseComponentName,
        DuplicateInstallStepName,
        InstallComponentNotFound,
        InstallComponentNameEmpty,
        ReleaseComponentNotFound,
        ReleaseComponentNameEmpty,
        ReleaseComponentNotFoundInSameDeploymentPhase,
        ReleaseComponentPropertyNotFound,
        ReservedReleaseNameUsed,
        DuplicateReleaseName,
        InvalidReleaseNameCharacters,
        ReleaseNameEmpty,
        ReleaseEmpty,
        DeploymentPhaseNotFound,
        NoDefaultDeploymentPhaseDefined,
        MultipleDefaultDeploymentPhaseDefined,
        DuplicateDeploymentPhaseName,
        InvalidDeploymentPhaseNameCharacters,
        DeploymentPhaseNameEmpty,
        ValidationFailRequiredAttribute,
        InstallStepLoop,
        DependencyLoop,
        UnresolvedPropertyGlobalOrParent,
        UnresolvedPropertyGlobal,
        DependencyOnAllComponentsNeedAllServers,
    }

    public class LanguageErrorMessages
    {
        private static Dictionary<ErrorId, string> messages = new Dictionary<ErrorId, string>()
        {
            { ErrorId.GenericException, "General Exception" },
            { ErrorId.ParserExtraElement, "Extra element '{0}'" },
            { ErrorId.ParserUnknownElement, "Unknown element '{0}', expected elements: {1}" },
            { ErrorId.ParserExtraAttribute, "Extra attribute '{0}'" },
            { ErrorId.ParserUnknownAttribute, "Unknown attribute '{0}', expected attributes: {1}" },
            { ErrorId.ParserFailedToReadXml, "Failed reading xml. Error: {0}" },
            { ErrorId.ParserValidationError, "Failed to validate xml. Error: {0}" },
            { ErrorId.DuplicateReleaseComponentName, "Duplicate release component name '{0}'" },
            { ErrorId.DuplicateInstallStepName, "Duplicate install step name {0}" },
            { ErrorId.InstallComponentNotFound, "Install component '{0}' not found" },
            { ErrorId.InstallComponentNameEmpty, "Install step name is empty" },
            { ErrorId.ReleaseComponentNotFound, "Release component '{0}' not found" },
            { ErrorId.ReleaseComponentNameEmpty, "Release component name is empty" },
            { ErrorId.ReleaseComponentNotFoundInSameDeploymentPhase, "Component '{0}' cannot depend on component '{1}' since they are not in the same deployment phase '{2}'" },
            { ErrorId.ReleaseComponentPropertyNotFound, "Release component property '{0}' not defined in component '{1}'. Property must be defined in the high level component in order to pass in." },
            { ErrorId.ReservedReleaseNameUsed, "Reserved release name '{0}' used, please choose another name for the release" },
            { ErrorId.DuplicateReleaseName, "Duplicate release name '{0}'" },
            { ErrorId.InvalidReleaseNameCharacters, "Invalid characters used in release name '{0}'" },
            { ErrorId.ReleaseEmpty, "Release '{0}' must contain at least 1 componentRef." },
            { ErrorId.ReleaseNameEmpty, "Release name is empty" },
            { ErrorId.DeploymentPhaseNotFound, "Deployment phase '{0}' not found for component '{1}'" },
            { ErrorId.NoDefaultDeploymentPhaseDefined, "No default deployment phase defined. Ensure one of the deployment phases have 'default=\"true\"'" },
            { ErrorId.MultipleDefaultDeploymentPhaseDefined, "Multiple default deployment phase defined. Ensure only one of the deployment phases have 'default=\"true\"'" },
            { ErrorId.DuplicateDeploymentPhaseName, "Duplicate deployment phase name '{0}'" },
            { ErrorId.InvalidDeploymentPhaseNameCharacters, "Invalid characters used in deployment phase name '{0}'" },
            { ErrorId.DeploymentPhaseNameEmpty, "Deployment phase name is empty" },
            { ErrorId.ValidationFailRequiredAttribute, "Required attribute '{0}' can not be missing/empty for '{1}'" },
            { ErrorId.InstallStepLoop, "Install Step '{0}' contains infinite install loop on {1}" },
            { ErrorId.DependencyLoop, "Component '{0}' contains infinite dependency loop on {1}" },
            { ErrorId.UnresolvedPropertyGlobalOrParent, "Property '{0}' did not get resolved to a value from global properties or parent '{1}'" },
            { ErrorId.UnresolvedPropertyGlobal, "Property '{0}' did not get resolved to a value from global properties" },
            { ErrorId.DependencyOnAllComponentsNeedAllServers, "When dependedByAllComponents or dependsOnAllComponents is true, servers must be 'all'" }
        };

        public static string GetMessage(ErrorId errorId, params string[] args)
        {
            return String.Format(LanguageErrorMessages.messages[errorId], args);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\src\OutputOctopus.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.tools.deploymentlanguage.Octopus;
using System.Xml.Linq;
using System.IO;
using xonline.tools.deploymentlanguage.Intermediate;
using System.Xml.Serialization;
using System.Xml;
using xonline.tools.deploymentlanguage.Language;

namespace xonline.tools.deploymentlanguage
{
    public class OutputOctopus : IOutputWriter
    {
        // Octopus namespace to use on the output service.xml
        public static readonly XNamespace OctopusNameSpace = XNamespace.Get("http://schemas.microsoft.com/Octopus/2005/01/Service");

        // Directory to keep all octopus service.xml
        public static readonly string OctopusPathName = "octopus";

        // Keeps track of how many directories to go up from service.xml to the input files
        private string _fileAppendPath;

        /// <summary>
        /// Converts the Octopus object definition into xml and outputs service.xml structure to outputPath
        /// </summary>
        /// <param name="definition">Octopus object model definition</param>
        /// <param name="outputPath">Root path to output service.xml(s)</param>
        public void WriteOutput(Definition definition, string outputPath)
        {
            Output(definition, outputPath, null);

            foreach (var release in definition.Releases.Values)
            {
                if (release.ReleaseComponents.Count > 0)
                {
                    Output(definition, outputPath, release);
                }
            }
        }

        /// <summary>
        /// Generates and outputs a service.xml for a specific release or the default release with all components
        /// </summary>
        /// <param name="definition">Octopus object model definition</param>
        /// <param name="outputPath">Root path to output service.xml(s)</param>
        /// <param name="release">Release to create, null for default release with all components</param>
        public void Output(Definition definition, string outputPath, Release release)
        {
            // Reset the path appended to all msi/file references
            _fileAppendPath = "";

            // Setup all dependencies like aggregates and requireInterfaces
            var octopusDependenciesSetter = new OctopusDependenciesSetter(definition);
            octopusDependenciesSetter.SetRelease(release);
            octopusDependenciesSetter.Process();

            // Add a subdirectory for the release if it is not the DefaultRelease Main deployment
            if (release != null || definition.CurrentDeploymentPhase.Name != "Main")
            {
                outputPath = Path.Combine(outputPath, "_" + octopusDependenciesSetter.ReleaseName + " " + definition.CurrentDeploymentPhase.Name);
                _fileAppendPath = Path.Combine(_fileAppendPath, "..");
            }

            // Create the service.xml elements
            XElement serviceElement = CreateServiceElement(definition, octopusDependenciesSetter);

            // Write out service.xml
            Directory.CreateDirectory(outputPath);
            serviceElement.Save(Path.Combine(outputPath, "service.xml"));
        }

        private XElement CreateServiceElement(Definition definition, OctopusDependenciesSetter octopusDependenciesSetter)
        {
            XElement serviceElement = new XElement("service");
            serviceElement.AddAttribute("name", "Xbox Live Service");
            serviceElement.AddAttribute("release", octopusDependenciesSetter.ReleaseName + " " + definition.CurrentDeploymentPhase.Name);
            serviceElement.AddAttribute("passPropertiesOnUninstall", "true");

            // Populate contents
            serviceElement.Add(PopulateProperties(definition.CurrentDeploymentPhase.UsedGlobalProperties));
            serviceElement.Add(PopulateTopologies(octopusDependenciesSetter));
            serviceElement.Add(PopulateComponents(octopusDependenciesSetter.ReleaseComponents));

            // Fix up Octopus variable %Octopus.CurrentRelease.Source.Folder% to include the relative path
            foreach (var e in serviceElement.DescendantsAndSelf())
            {
                var attributes = e.Attributes();

                foreach (var attribute in attributes)
                {
                    if (attribute.Value.Contains("%Octopus.CurrentRelease.Source.Folder%"))
                    {
                        attribute.Value = attribute.Value.Replace("%Octopus.CurrentRelease.Source.Folder%", Path.Combine("%Octopus.CurrentRelease.Source.Folder%", _fileAppendPath));
                    }
                }
            }

            // Fix up namespace
            foreach (var e in serviceElement.DescendantsAndSelf())
            {
                e.Name = OctopusNameSpace + e.Name.LocalName;
            }

            return serviceElement;
        }

        private XElement[] PopulateProperties(IEnumerable<OctopusProperty> properties)
        {
            var propertiesElement = new List<XElement>();

            foreach (var property in properties)
            {
                var propertyElement = new XElement("property");

                propertyElement.AddAttribute("name", property.Name);
                propertyElement.AddAttribute("value", property.Value);
                propertyElement.ParseString(property.UserInput);
                propertyElement.Add(GetServerListXElement(property.ServerList));
                
                propertiesElement.Add(propertyElement);
            }

            return propertiesElement.ToArray();
        }

        private XElement GetServerListXElement(ServerList serverList)
        {
            if (serverList != null)
            {
                var serverListElement = new XElement("serverList");
                
                switch (serverList.Type)
                {
                    case ServerListType.Component:
                        serverListElement.AddAttribute("type", "component");
                        break;
                    case ServerListType.PublishInterface:
                        serverListElement.AddAttribute("type", "publishInterface");
                        break;
                    case ServerListType.RequireInterface:
                        serverListElement.AddAttribute("type", "requireInterface");
                        break;
                }

                serverListElement.AddAttribute("name", serverList.Name);
                serverListElement.AddAttribute("separator", serverList.Separator);

                return serverListElement;
            }
            else
            {
                return null;
            }
        }

        private XElement PopulateTopologies(OctopusDependenciesSetter octopusDependenciesSetter)            
        {
            var releaseComponents = octopusDependenciesSetter.ReleaseComponents;

            Dictionary<string, List<PassProperty>> roleProperties = null;

            if (octopusDependenciesSetter.Release != null)
            {
                roleProperties = GetRoleProperties(octopusDependenciesSetter.Release.OriginalReleaseElement.ComponentList);
            }

            var topologiesElement = new XElement("topologies");
            var topologyElement = new XElement("topology", new XAttribute("name", "Full"));
            topologiesElement.Add(topologyElement);

            foreach (var component in releaseComponents)
            {
                var roleElement = new XElement("role");
                roleElement.AddAttribute("name", component.Name);
                
                if (component.OriginalComponentLanguage.Servers == ComponentServersValue.All)
                {
                    roleElement.AddAttribute("servers", "all");
                }
                else
                {
                    roleElement.AddAttribute("minServers", component.OriginalComponentLanguage.MinServersValue);
                    roleElement.AddAttribute("maxServers", component.OriginalComponentLanguage.MaxServersValue);
                }

                if (roleProperties != null && roleProperties.ContainsKey(component.Name))
                {
                    foreach (var passProperty in roleProperties[component.Name])
                    {
                        if (passProperty.Value != null)
                        {
                            var propertyElement = new XElement("passProperty");
                            propertyElement.AddAttribute("name", passProperty.Name);
                            propertyElement.AddAttribute("value", passProperty.Value);

                            roleElement.Add(propertyElement);
                        }
                    }
                }

                topologyElement.Add(roleElement);
            }

            return topologiesElement;
        }

        private Dictionary<string, List<PassProperty>> GetRoleProperties(ComponentRef[] componentRefs)
        {
            var roleProperties = new Dictionary<string, List<PassProperty>>();

            foreach (var componentRef in componentRefs)
            {
                if (componentRef.PassProperty != null && componentRef.PassProperty.Length > 0)
                {
                    roleProperties.Add(componentRef.Name, new List<PassProperty>());

                    foreach (var passProperty in componentRef.PassProperty)
                    {
                        roleProperties[componentRef.Name].Add(passProperty);
                    }
                }
            }

            return roleProperties;
        }

        private XElement PopulateComponents(IEnumerable<ReleaseComponent> releaseComponents)
        {
            var componentsElement = new XElement("components");

            var componentList = new HashSet<OctopusComponent>();

            foreach (var component in releaseComponents)
            {
                CollectComponents(componentList, component);
            }

            foreach (var component in componentList)
            {
                componentsElement.Add(GetComponentXElement(component));
            }

            return componentsElement;
        }

        private void CollectComponents(HashSet<OctopusComponent> componentList, Component component)
        {
            componentList.Add(component.Octopus);

            foreach (var installComponent in component.InstallComponents)
            {
                CollectComponents(componentList, (Component)installComponent.InstallComponent);
            }
        }

        private XElement GetComponentXElement(OctopusComponent component)
        {
            XElement element = new XElement("component");

            element.Add(new XAttribute("name", component.Name));
            element.Add(GetPropertiesXElement(component.PropertyList));

            element.AddElement("publishInterface", "name", component.PublishInterface);
            element.Add(GetAggregateXElementList(component.AggregateComponents));
            element.Add(GetRequireInterfaceXElementList(component.RequireInterfaces));

            CorrectFilePaths(element.ParseString(component.PrerequisiteChecks));
            CorrectFilePaths(element.ParseString(component.PostDeploymentChecks));
            CorrectFilePaths(element.ParseString(component.ConditionChecks));
            element.ParseString(component.Reboot);
            
            element.Add(GetCommandXElement("installCommand", component.InstallCommand));
            element.Add(GetCommandXElement("uninstallCommand", component.UninstallCommand));
            element.Add(GetMsiXElement(component.Msi));

            return element;
        }

        private XElement[] GetXElementList(string elementName, string attributeName, ICollection<string> values)
        {
            if (values != null)
            {
                var elements = new List<XElement>(values.Count);

                foreach (var value in values)
                {
                    var element = new XElement(elementName);
                    element.AddAttribute(attributeName, value);

                    elements.Add(element);
                }

                return elements.ToArray();
            }
            else
            {
                return null;
            }
        }

        private XElement[] GetAggregateXElementList(Dictionary<string, AggregateComponent> aggregateComponents)
        {
            if (aggregateComponents != null)
            {
                var elements = new List<XElement>(aggregateComponents.Count);

                foreach (var aggregateComponent in aggregateComponents.Values)
                {
                    var aggregateElement = new XElement("aggregateComponent");
                    aggregateElement.AddAttribute("name", aggregateComponent.Name);
                    
                    foreach (var passProperty in aggregateComponent.PassProperties)
                    {
                        if (passProperty.Value != null)
                        {
                            var propertyElement = new XElement("passProperty");
                            propertyElement.AddAttribute("name", passProperty.Key);
                            propertyElement.AddAttribute("value", passProperty.Value);

                            aggregateElement.Add(propertyElement);
                        }
                    }

                    elements.Add(aggregateElement);
                }

                return elements.ToArray();
            }
            else
            {
                return null;
            }
        }

        private XElement[] GetRequireInterfaceXElementList(RequireInterfaceCollection requireInterfaces)
        {
            if (requireInterfaces != null)
            {
                var elements = new List<XElement>(requireInterfaces.Count);

                foreach (var requireInterface in requireInterfaces.Values)
                {
                    var interfaceElement = new XElement("requireInterface");
                    interfaceElement.AddAttribute("name", requireInterface.Name);
                    if (requireInterface.Wait != DependsOnWaitValue.All)
                    {
                        interfaceElement.AddAttribute("wait", Util.GetXmlEnumName(typeof(DependsOnWaitValue), requireInterface.Wait.ToString()));
                    }

                    elements.Add(interfaceElement);
                }

                return elements.ToArray();
            }
            else
            {
                return null;
            }
        }

        private XElement GetCommandXElement(string elementName, OctopusCommand octopusCommand)
        {
            if (octopusCommand == null)
            {
                return null;
            }
            else
            {
                var element = new XElement(elementName);
                element.AddAttribute("name", octopusCommand.Name);
                element.AddAttribute("cmd", octopusCommand.Command);
                element.ParseString(octopusCommand.StatusCodes);
                element.Add(GetInputFileXElement(octopusCommand.InputFiles));
                element.ParseString(octopusCommand.OutputFiles);

                return element;
            }
        }

        private XElement GetInputFileXElement(IEnumerable<OctopusInputFile> inputFiles)
        {
            if (inputFiles == null)
            {
                return null;
            }
            else
            {

                var inputFilesElement = new XElement("inputFiles");

                foreach (var inputFile in inputFiles)
                {
                    var fileElement = new XElement("file");

                    if (inputFile.SourcePath != null)
                    {
                        fileElement.AddAttribute("sourcePath", GetCorrectedFilePath(inputFile.SourcePath));
                    }
                    if (inputFile.DestinationPath != null)
                    {
                        fileElement.AddAttribute("destinationPath", inputFile.DestinationPath);
                    }

                    inputFilesElement.Add(fileElement);
                }

                return inputFilesElement;
            }
        }

        private XElement GetMsiXElement(OctopusMsi msi)
        {
            if (msi == null)
            {
                return null;
            }
            else
            {
                var element = new XElement("msi");
                element.AddAttribute("path", GetCorrectedFilePath(msi.Path));
                element.AddAttribute("passPropertiesOnUninstall", msi.PassPropertiesOnUninstall, false /* Don't add attribute if false */);
                element.Add(GetPropertiesXElement(msi.PropertyList));

                return element;
            }
        }

        private XElement[] GetPropertiesXElement(Dictionary<string, OctopusProperty> properties)
        {
            if (properties == null)
            {
                return null;
            }
            else
            {
                var elements = new List<XElement>(properties.Count);

                foreach (var property in properties.Values)
                {
                    var element = new XElement("property");
                    element.AddAttribute("name", property.Name);

                    element.AddAttribute("value", property.Value);
                    element.AddAttribute("mergeSeparator", property.MergeSeparator);

                    element.Add(GetServerListXElement(property.ServerList));
                    element.ParseString(property.UserInput);

                    elements.Add(element);
                }

                return elements.ToArray();
            }
        }

        private void CorrectFilePaths(XElement element)
        {
            if (element != null)
            {
                foreach (var fileElement in element.Descendants("file"))
                {
                    var sourcePathAttribute = fileElement.Attribute("sourcePath");

                    if (sourcePathAttribute != null)
                    {
                        sourcePathAttribute.Value = GetCorrectedFilePath(sourcePathAttribute.Value);
                    }
                }
            }
        }

        private string GetCorrectedFilePath(string path)
        {
            if (!Path.IsPathRooted(path))
            {
                path = Path.Combine(_fileAppendPath, path);
            }
            
            return path;
        }
    }

    public static class XElementExtension
    {
        public static void AddAttribute(this XElement parentElement, string name, string value)
        {
            if (value != null)
            {
                parentElement.Add(new XAttribute(name, value));
            }
        }

        public static void AddAttribute(this XElement parentElement, string name, int? value)
        {
            if (value != null)
            {
                parentElement.Add(new XAttribute(name, value));
            }
        }

        public static void AddAttribute(this XElement parentElement, string name, bool value, bool addEvenIfFalse)
        {
            if (value || addEvenIfFalse)
            {
                parentElement.Add(new XAttribute(name, value));
            }
        }

        public static void AddElement(this XElement parentElement, string elementName, string attributeName, string value)
        {
            if (value != null)
            {
                parentElement.Add(new XElement(elementName, new XAttribute(attributeName, value)));
            }
        }

        public static XElement ParseString(this XElement parentElement, string value)
        {
            if (!String.IsNullOrEmpty(value))
            {
                var element = XElement.Parse(value, LoadOptions.SetBaseUri);

                parentElement.Add(element);

                return element;
            }
            else
            {
                return null;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\src\Error\LanguageErrors.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace xonline.tools.deploymentlanguage
{
    public class LanguageErrors : List<LanguageError>
    {
        public void Add(string filename, ErrorId errorId, params string[] args)
        {
            Add(new LanguageError(filename, errorId, args));
        }

        public void Add(string filename, ErrorId errorId, int lineNumber, int linePosition, params string[] args)
        {
            Add(new LanguageError(filename, errorId, lineNumber, linePosition, args));
        }

        public void Add(string filename, Exception innerException)
        {
            Add(new LanguageError(filename, innerException));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\src\Intermediate\DependOnComponent.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.tools.deploymentlanguage.Language;

namespace xonline.tools.deploymentlanguage.Intermediate
{
    public class DependOnComponent
    {
        public ReleaseComponent Component { get; private set; }
        public DependsOnWaitValue WaitValue { get; private set; }

        public DependOnComponent(ReleaseComponent component, DependsOnWaitValue waitValue)
        {
            Component = component;
            WaitValue = waitValue;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\src\Intermediate\DeploymentPhase.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.tools.deploymentlanguage.Language;
using xonline.tools.deploymentlanguage.Octopus;

namespace xonline.tools.deploymentlanguage.Intermediate
{
    public class DeploymentPhase
    {
        public LanguageDeploymentPhase OriginalDeploymentPhaseElement { get; private set; }

        public Dictionary<string, ReleaseComponent> Components { get; private set; }
        public HashSet<OctopusProperty> UsedGlobalProperties { get; private set; }
        public Dictionary<string, ReleaseComponent> DependsOnAllComponents { get; private set; }
        public Dictionary<string, ReleaseComponent> DependedByAllComponents { get; private set; }

        public string Name { get; private set; }

        public bool Default
        {
            get
            {
                return OriginalDeploymentPhaseElement.Default;
            }
        }

        public DeploymentPhase(LanguageDeploymentPhase languageDeploymentPhase)
        {
            OriginalDeploymentPhaseElement = languageDeploymentPhase;

            Name = languageDeploymentPhase.Name;
            UsedGlobalProperties = new HashSet<OctopusProperty>();
            Components = new Dictionary<string, ReleaseComponent>();
            DependsOnAllComponents = new Dictionary<string, ReleaseComponent>();
            DependedByAllComponents = new Dictionary<string, ReleaseComponent>();
        }

        public override string ToString()
        {
            return Name;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\src\Language\DependsOn.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml.Serialization;

namespace xonline.tools.deploymentlanguage.Language
{
    public enum DependsOnWaitValue
    {
        [XmlEnum("all")]
        All,

        [XmlEnum("any")]
        Any,

        [XmlEnum("same")]
        Same
    }

    public class DependsOn : LanguageElement
    {
        [XmlAttribute("componentName")]
        public string ComponentName { get; set; }

        // Punted [XmlAttribute("wait")]
        [XmlIgnore()]
        public DependsOnWaitValue Wait { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\src\Intermediate\Release.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.tools.deploymentlanguage.Language;

namespace xonline.tools.deploymentlanguage.Intermediate
{
    public class Release
    {
        public string Name { get { return OriginalReleaseElement.Name; } }
        public HashSet<ReleaseComponent> ReleaseComponents { get; private set; }
        public LanguageRelease OriginalReleaseElement { get; private set; }
        
        public string OriginalElementFileName
        {
            get
            {
                return OriginalReleaseElement.FileName;
            }
        }

        public Release(LanguageRelease languageRelease)
        {
            OriginalReleaseElement = languageRelease;
            ReleaseComponents = new HashSet<ReleaseComponent>();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\src\Language\InstallStep.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml.Serialization;
using System.Xml;

namespace xonline.tools.deploymentlanguage.Language
{
    public class Install : InstallElement
    {
        [XmlAttribute("step")]
        public string StepName { get; set; }

        [XmlElement("passProperty")]
        public PassProperty[] PassProperty { get; set; }

        [XmlIgnore()]
        public override string Name { get { return StepName; } }
    }

    public class PassProperty : LanguageElement
    {
        [XmlAttribute("name")]
        public string Name { get; set; }

        [XmlAttribute("value")]
        public string Value { get; set; }

    }

    [XmlRoot("installSteps")]
    public class InstallSteps : LanguageElement
    {
        [XmlElement("installStep")]
        public InstallStep[] InstallStepList { get; set; }
    }

    public class InstallStep : LanguageElement, ILanguageTopElement
    {
        [XmlIgnore()]
        public string FileName { get; set; }

        [XmlAttribute("name")]
        public string Name { get; set; }

        [XmlAttribute("runOnce")]
        public bool RunOnce { get; set; }

        [XmlElement("property")]
        public LanguageProperty[] PropertyList { get; set; }

        [XmlAnyElement("prerequisiteChecks")]
        public XmlElement PrerequisiteChecks { get; set; }

        [XmlAnyElement("postDeploymentChecks")]
        public XmlElement PostDeploymentChecks { get; set; }

        [XmlElement("dependsOn")]
        public DependsOn[] DependsOnList { get; set; }

        [XmlElement("runCommand", typeof(RunCommand))]
        [XmlElement("runMsi", typeof(RunMsi))]
        [XmlElement("install", typeof(Install))]
        public InstallElement[] InstallElementList { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\src\Intermediate\Component.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.tools.deploymentlanguage.Octopus;
using xonline.tools.deploymentlanguage.Language;

namespace xonline.tools.deploymentlanguage.Intermediate
{
    /// <summary>
    /// Top Level Component as a release component
    /// </summary>
    public class ReleaseComponent : Component, IParentComponent
    {
        public ReleaseComponent(string name)
            : base(new LanguageComponent() { Name = name })
        {
        }

        public ReleaseComponent(LanguageComponent languageComponent)
            : base(languageComponent)
        {
            Octopus.PopulatePostDeploymentChecks(languageComponent.PostDeploymentChecks);
            Octopus.PopulatePrerequisiteChecks(languageComponent.PrerequisiteChecks);
            Octopus.PopulateProperties(languageComponent.PropertyList);
        }

        public LanguageComponent OriginalComponentLanguage
        {
            get
            {
                return (LanguageComponent)OriginalTopLanguageElement;
            }
        }
    }

    /// <summary>
    /// Install Step Component contains other install steps and consumed by top level components
    /// </summary>
    public class InstallStepComponent : Component, IParentComponent, IInstallComponent
    {
        public InstallStepComponent(InstallStep installStep)
            : base(installStep)
        {
            Octopus.PopulatePostDeploymentChecks(installStep.PostDeploymentChecks);
            Octopus.PopulatePrerequisiteChecks(installStep.PrerequisiteChecks);
            Octopus.PopulateProperties(installStep.PropertyList);
        }

        public InstallStep OriginalInstallStepLanguage
        {
            get
            {
                return (InstallStep)OriginalTopLanguageElement;
            }
        }

        /// <summary>
        /// Determines whether this component has properties that are not meant for merging. If there are, and multiple components are passing in properties,
        /// we'll need to duplicate the component since Octopus cannot handle different properties passing into the same component in a given deployment.
        /// </summary>
        /// <returns>True when this install step contains properties that does not have a mergeSeparator</returns>
        public bool HasUniqueProperties()
        {
            bool hasUniqueProperties = false;

            foreach (var property in Octopus.PropertyList.Values)
            {
                if (String.IsNullOrEmpty(property.MergeSeparator))
                {
                    hasUniqueProperties = true;
                }
            }

            return hasUniqueProperties;
        }

        public bool RunOnce
        {
            get { return OriginalInstallStepLanguage.RunOnce; }
        }
    }

    /// <summary>
    /// Action component for running a command.
    /// </summary>
    public class RunCommandComponent : Component, IActionComponent, IInstallComponent
    {
        public RunCommandComponent(ILanguageTopElement ownerElement, RunCommand runCommand)
            : base(ownerElement, runCommand)
        {
            Octopus.PopulatePostDeploymentChecks(runCommand.PostDeploymentChecks);
            Octopus.PopulatePrerequisiteChecks(runCommand.PrerequisiteChecks);
            Octopus.PopulateConditionChecks(runCommand.ConditionChecks);
            Octopus.PopulateProperties(runCommand.PropertyList);
            Octopus.PopulateReboot(runCommand.Reboot);
            Octopus.PopulateInstallCommand(runCommand.InstallCommand);
            Octopus.PopulateUninstallCommand(runCommand.UninstallCommand);
        }
    }

    /// <summary>
    /// Action component for running an Msi
    /// </summary>
    public class RunMsiComponent : Component, IActionComponent, IInstallComponent
    {
        public RunMsiComponent(ILanguageTopElement ownerElement, RunMsi runMsi)
            : base(ownerElement, runMsi)
        {
            Octopus.PopulatePostDeploymentChecks(runMsi.PostDeploymentChecks);
            Octopus.PopulatePrerequisiteChecks(runMsi.PrerequisiteChecks);
            Octopus.PopulateConditionChecks(runMsi.ConditionChecks);
            Octopus.PopulateProperties(runMsi.PropertyList);
            Octopus.PopulateReboot(runMsi.Reboot);
            Octopus.PopulateMsi(runMsi.Msi);
        }
    }

    public class InstallRelationship
    {
        public IInstallComponent InstallComponent { get; set; }
        public Dictionary<string, string> PassProperties { get; private set; }
        public IParentComponent ParentComponent { get; private set; }

        public InstallRelationship(IParentComponent parentComponent, IInstallComponent installComponents, Dictionary<string, string> passProperties)
        {            
            ParentComponent = parentComponent;
            InstallComponent = installComponents;
            SetPassProperties(passProperties);
        }

        public void SetPassProperties(Dictionary<string, string> passProperties)
        {
            PassProperties = passProperties;

            if (PassProperties == null)
            {
                PassProperties = new Dictionary<string, string>();
            }
        }
    }

    public abstract class Component : IInstallComponent, IActionComponent, IParentComponent
    {
        public OctopusComponent Octopus { get; protected set; }

        // Original xml element object for this component
        public ILanguageTopElement OriginalTopLanguageElement { get; private set; }

        // Original xml install element object for install/runMsi/runCommand
        public InstallElement OriginalInstallElement { get; private set; }

        // List of components this component should install
        public List<InstallRelationship> InstallComponents { get; private set; }

        // Reference to the component using this component
        public List<InstallRelationship> ParentComponents { get; protected set; }

        // List of components this component depends on
        public List<DependOnComponent> DependsOnComponents { get; private set; }

        // List of components depending on this component
        public List<IParentComponent> DependedByComponents { get; private set; }

        private Component ClonedFromComponent { get; set; }

        public bool HasUniqueName { get; private set; }

        public string Name
        {
            get { return Octopus.Name; }
        }

        public string OriginalName
        {
            get { return OriginalInstallElement != null ? OriginalInstallElement.Name : OriginalTopLanguageElement.Name; }
        }

        public string OriginalDefinitionFileName
        {
            get { return OriginalTopLanguageElement.FileName; }
        }

        public Component(ILanguageTopElement originalElement)
        {
            Octopus = new OctopusComponent() { Name = originalElement.Name };
            OriginalTopLanguageElement = originalElement;

            InstallComponents = new List<InstallRelationship>();
            ParentComponents = new List<InstallRelationship>();
            DependsOnComponents = new List<DependOnComponent>();
            DependedByComponents = new List<IParentComponent>();
        }

        public Component(ILanguageTopElement ownerElement, InstallElement originalInstallElement)
            : this(ownerElement)
        {
            Octopus = new OctopusComponent() { Name = originalInstallElement.Name };
            OriginalInstallElement = originalInstallElement;
        }

        public void AddInstallComponent(IInstallComponent installComponent, Dictionary<string, string> passProperties)
        {            
            var installRelationship = new InstallRelationship(this, installComponent, passProperties);
            
            InstallComponents.Add(installRelationship);
            ((Component)installComponent).ParentComponents.Add(installRelationship);
        }

        public void AddDependsOnComponent(DependOnComponent dependsOnComponent)
        {
            this.DependsOnComponents.Add(dependsOnComponent);
            dependsOnComponent.Component.DependedByComponents.Add(this);
        }

        public void AddDependsOnComponent(ReleaseComponent dependsOnComponent)
        {
            var dependOnComponent = new DependOnComponent(dependsOnComponent, DependsOnWaitValue.All);
            AddDependsOnComponent(dependOnComponent);
        }

        public void SetUniqueName(string name)
        {
            Octopus.Name = name;
            HasUniqueName = true;
        }

        public override string ToString()
        {
            return Name;
        }

        public static Dictionary<string, string> ConvertPassProperties(PassProperty[] passProperties)
        {
            var properties = new Dictionary<string, string>();

            foreach (var passProperty in passProperties)
            {
                properties.Add(passProperty.Name, passProperty.Value);
            }

            return properties;
        }

        public Component DuplicateComponent()
        {
            var duplicatedInstallStepComponent = this.MemberwiseClone() as Component;
            duplicatedInstallStepComponent.ParentComponents = new List<InstallRelationship>();
            duplicatedInstallStepComponent.InstallComponents = new List<InstallRelationship>();

            foreach (var installRelationship in this.InstallComponents)
            {
                var clonedInstallRelationship = new InstallRelationship(
                    installRelationship.ParentComponent,
                    installRelationship.InstallComponent,
                    installRelationship.PassProperties);

                duplicatedInstallStepComponent.InstallComponents.Add(clonedInstallRelationship);
            }

            duplicatedInstallStepComponent.Octopus = Util.CloneObject<OctopusComponent>(Octopus);

            duplicatedInstallStepComponent.ClonedFromComponent = this;

            return duplicatedInstallStepComponent;
        }

        public void ClearRelationships()
        {
            InstallComponents.Clear();
            ParentComponents.Clear();
        }

        public void ClearDependencies()
        {
            DependsOnComponents.Clear();
            DependedByComponents.Clear();
        }
    }

    public interface IActionComponent : IInstallComponent
    {
        InstallElement OriginalInstallElement { get; }        
    }

    /// <summary>
    /// Marks a component that can be used by other components (e.g. Install Step, RunMsi, RunCommand)
    /// </summary>
    public interface IInstallComponent : IBaseComponent
    {
        List<InstallRelationship> ParentComponents { get; }

        void SetUniqueName(string name);

        Component DuplicateComponent();
    }

    public interface IParentComponent : IBaseComponent
    {
        // Component Aggregates
        List<InstallRelationship> InstallComponents { get; }

        // Dependencies
        List<DependOnComponent> DependsOnComponents { get; }
        List<IParentComponent> DependedByComponents { get; }

        void AddInstallComponent(IInstallComponent installComponent, Dictionary<string, string> passProperties);
        void AddDependsOnComponent(DependOnComponent dependsOnComponent);
        void AddDependsOnComponent(ReleaseComponent dependsOnComponent);
    }

    public interface IBaseComponent
    {
        string Name { get; }
        string OriginalName { get; }
        bool HasUniqueName { get; }

        OctopusComponent Octopus { get; }

        ILanguageTopElement OriginalTopLanguageElement { get; }
        string OriginalDefinitionFileName { get; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\src\Language\LanguageComponent.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml.Serialization;
using System.Xml;

namespace xonline.tools.deploymentlanguage.Language
{
    public enum ComponentServersValue
    {  
        [XmlEnum("select")]
        Select,
        [XmlEnum("all")]
        All        
    }

    [XmlRoot("components")]
    public class LanguageComponents : LanguageElement
    {
        [XmlElement("component")]
        public LanguageComponent[] ComponentList { get; set; }
    }

    public class LanguageComponent : LanguageElement, ILanguageTopElement
    {
        private int? _minServers = 0;
        private int? _maxServers;
        
        [XmlIgnore()]
        public string FileName { get; set; }
        
        [XmlIgnore()]
        public int? MinServersValue
        {
            get { return _minServers; }
        }

        [XmlIgnore()]
        public int? MaxServersValue
        {
            get { return _maxServers; }
        }

        [XmlAttribute("name")]
        public string Name { get; set; }

        [XmlAttribute("deploymentPhase")]
        public string DeploymentPhase { get; set; }

        [XmlAttribute("minServers")]
        public int MinServers
        {
            set { _minServers = value; }
            get { return (int)_minServers; }
        }

        [XmlAttribute("maxServers")]
        public int MaxServers
        {
            set { _maxServers = value; }
            get { return (int)_maxServers; }
        }

        [XmlAttribute("servers")]
        public ComponentServersValue Servers { get; set; }

        [XmlAttribute("dependedByAllComponents")]
        public bool DependedByAllComponents { get; set; }

        [XmlAttribute("dependsOnAllComponents")]
        public bool DependsOnAllComponents { get; set; }

        [XmlElement("property")]
        public LanguageProperty[] PropertyList { get; set; }

        [XmlAnyElement("prerequisiteChecks")]
        public XmlElement PrerequisiteChecks { get; set; }

        [XmlAnyElement("postDeploymentChecks")]
        public XmlElement PostDeploymentChecks { get; set; }

        [XmlElement("runCommand", typeof(RunCommand))]
        [XmlElement("runMsi", typeof(RunMsi))]
        [XmlElement("install", typeof(Install))]
        public InstallElement[] InstallElementList { get; set; }

        [XmlElement("dependsOn")]
        public DependsOn[] DependsOnList { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\src\Language\LanguageDeploymentPhase.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml.Serialization;

namespace xonline.tools.deploymentlanguage.Language
{
    [XmlRoot("deploymentPhases")]
    public class DeploymentPhases : LanguageElement
    {
        [XmlElement("deploymentPhase")]
        public LanguageDeploymentPhase[] DeploymentPhaseList { get; set; }
    }

    public class LanguageDeploymentPhase : LanguageElement, ILanguageTopElement
    {
        [XmlIgnore()]
        public string FileName { get; set; }

        [XmlAttribute("name")]
        public string Name { get; set; }

        [XmlAttribute("default")]
        public bool Default { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\src\Language\LanguageProperty.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml.Serialization;
using System.Xml;

namespace xonline.tools.deploymentlanguage.Language
{
    [XmlRoot("properties")]
    public class LanguageProperties : LanguageElement
    {
        [XmlElement("property")]
        public LanguageProperty[] PropertyList { get; set; }
    }

    public class LanguageProperty : LanguageElement, ILanguageTopElement
    {
        [XmlIgnore()]
        public string FileName { get; set; }

        [XmlAttribute("name")]
        public string Name { get; set; }

        [XmlAttribute("value")]
        public string Value { get; set; }

        [XmlAttribute("mergeSeparator")]
        public string MergeSeparator { get; set; }

        [XmlElement("serverList")]
        public ServerList ServerList { get; set; }

        [XmlAnyElement("userInput")]
        public XmlElement UserInput { get; set; }
    }
    
    public enum ServerListType
    {
        [XmlEnum("component")]
        Component,
        [XmlEnum("publishInterface")]
        PublishInterface,
        [XmlEnum("requireInterface")]
        RequireInterface
    }

    [Serializable]
    public class ServerList
    {
        [XmlAttribute("type")]
        public ServerListType Type { get; set; }

        [XmlAttribute("name")]
        public string Name { get; set; }

        [XmlAttribute("separator")]
        public string Separator { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\src\Language\RunMsi.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml.Serialization;
using System.Xml;

namespace xonline.tools.deploymentlanguage.Language
{
    [XmlRoot("runMsi")]
    public class RunMsi : InstallElement
    {
        [XmlAttribute("name")]
        public string RunMsiName { get; set; }

        [XmlElement("property")]
        public LanguageProperty[] PropertyList { get; set; }

        [XmlAnyElement("conditionChecks")]
        public XmlElement ConditionChecks { get; set; }

        [XmlAnyElement("prerequisiteChecks")]
        public XmlElement PrerequisiteChecks { get; set; }

        [XmlAnyElement("reboot")]
        public XmlElement Reboot { get; set; }

        [XmlAnyElement("postDeploymentChecks")]
        public XmlElement PostDeploymentChecks { get; set; }

        [XmlElement("msi")]
        public Msi Msi { get; set; }

        [XmlIgnore()]
        public override string Name { get { return RunMsiName; } }
    }

    public class Msi : LanguageElement
    {
        [XmlAttribute("path")]
        public string Path { get; set; }

        [XmlAttribute("passPropertiesOnUninstall")]
        public bool PassPropertiesOnUninstall { get; set; }

        [XmlElement("property")]
        public LanguageProperty[] PropertyList { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\src\Language\LanguageRelease.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml.Serialization;

namespace xonline.tools.deploymentlanguage.Language
{
    [XmlRoot("releases")]
    public class Releases : LanguageElement
    {
        [XmlElement("release")]
        public LanguageRelease[] ReleaseList { get; set; }
    }

    public class LanguageRelease : LanguageElement, ILanguageTopElement
    {
        [XmlIgnore()]
        public string FileName { get; set; }

        [XmlAttribute("name")]
        public string Name { get; set; }

        [XmlElement("componentRef")]
        public ComponentRef[] ComponentList { get; set; }
    }

    public class ComponentRef : LanguageElement
    {
        [XmlAttribute("name")]
        public string Name { get; set; }

        [XmlElement("passProperty")]
        public PassProperty[] PassProperty { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\src\Language\LanguageElement.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Reflection;
using System.Xml.Serialization;

namespace xonline.tools.deploymentlanguage.Language
{
    public abstract class InstallElement : LanguageElement
    {
        public abstract string Name { get; }
    }

    public interface ILanguageTopElement
    {
        string Name { get; }

        string FileName { get; set; }
    }

    public abstract class LanguageElement
    {
        public void CreateEmptyListsOnNulls()
        {
            Type type = this.GetType();

            foreach (var property in type.GetProperties())
            {
                if (property.PropertyType.IsArray)
                {
                    if (property.GetValue(this, null) == null)
                    {
                        // If it's an array and the property value is null, create an empty array
                        property.SetValue(this, Array.CreateInstance(property.PropertyType.GetElementType(), 0), null);
                    }
                    else if (property.PropertyType.GetElementType().IsSubclassOf(typeof(LanguageElement)))
                    {
                        // If it's an array, and the element type is a LanguageElement, loop through all items and call CreateEmptyListsOnNulls()
                        foreach (var item in (object[])property.GetValue(this, null))
                        {
                            typeof(LanguageElement).InvokeMember("CreateEmptyListsOnNulls", BindingFlags.InvokeMethod, null, item, null);
                        }
                    }
                }
                else if (property.PropertyType.IsSubclassOf(typeof(LanguageElement)))
                {
                    // If it's not an array and the property is subclass of LanguageElement
                    // and the value is not null, call CreateEmptyListsOnNulls() on it
                    var item = property.GetValue(this, null);

                    if (item != null)
                    {
                        typeof(LanguageElement).InvokeMember("CreateEmptyListsOnNulls", BindingFlags.InvokeMethod, null, item, null);
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\src\Language\RunCommand.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml.Serialization;
using System.Xml;

namespace xonline.tools.deploymentlanguage.Language
{
    public class RunCommand : InstallElement
    {
        [XmlAttribute("name")]
        public string RunCommandName { get; set; }

        [XmlElement("property")]
        public LanguageProperty[] PropertyList { get; set; }

        [XmlAnyElement("conditionChecks")]
        public XmlElement ConditionChecks { get; set; }

        [XmlAnyElement("prerequisiteChecks")]
        public XmlElement PrerequisiteChecks { get; set; }

        [XmlAnyElement("reboot")]
        public XmlElement Reboot { get; set; }

        [XmlAnyElement("postDeploymentChecks")]
        public XmlElement PostDeploymentChecks { get; set; }

        [XmlElement("installCommand")]
        public InstallCommand InstallCommand { get; set; }

        [XmlElement("uninstallCommand")]
        public InstallCommand UninstallCommand { get; set; }

        [XmlIgnore()]
        public override string Name { get { return RunCommandName; } }
    }

    public class InstallCommand
    {
        [XmlAttribute("name")]
        public string Name { get; set; }

        [XmlAttribute("cmd")]
        public string Command { get; set; }

        [XmlAnyElement("statusCodes")]
        public XmlElement StatusCodes { get; set; }

        [XmlElement("inputFiles")]
        public InputFiles InputFiles { get; set; }

        [XmlAnyElement("outputFiles")]
        public XmlElement OutputFiles { get; set; }
    }

    public class InputFiles
    {
        [XmlElement("file")]
        public InputFile[] FileList { get; set; }
    }

    public class InputFile
    {
        [XmlAttribute("sourcePath")]
        public string SourcePath { get; set; }

        [XmlAttribute("destinationPath")]
        public string DestinationPath { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\src\Octopus\OctopusProperty.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.tools.deploymentlanguage.Language;

namespace xonline.tools.deploymentlanguage.Octopus
{
    [Serializable]
    public class OctopusProperty
    {
        public string Name { get; set; }

        public string Value { get; set; }

        public string MergeSeparator { get; set; }

        public ServerList ServerList { get; set; }

        public string UserInput { get; set; }

        public bool HasValue
        {
            get
            {
                return UserInput != null || ServerList != null || Value != null;
            }
        }

        public static Dictionary<string, OctopusProperty> GetPropertyList(LanguageProperty[] properties)
        {
            Dictionary<string, OctopusProperty> octopusPropertyList = new Dictionary<string, OctopusProperty>();

            foreach (var property in properties)
            {
                var octopusProperty = new OctopusProperty();
                octopusProperty.Name = property.Name;
                octopusProperty.Value = property.Value;
                octopusProperty.MergeSeparator = property.MergeSeparator;

                if (property.ServerList != null)
                {
                    octopusProperty.ServerList = new ServerList()
                    {
                        Type = property.ServerList.Type,
                        Name = property.ServerList.Name,
                        Separator = property.ServerList.Separator
                    };
                }

                if (property.UserInput != null)
                {
                    octopusProperty.UserInput = property.UserInput.OuterXml;
                }

                octopusPropertyList.Add(octopusProperty.Name, octopusProperty);
            }

            return octopusPropertyList;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\src\Octopus\OctopusComponent.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.tools.deploymentlanguage.Language;
using System.Xml;
using System.Xml.Serialization;

namespace xonline.tools.deploymentlanguage.Octopus
{
    [Serializable]
    public class OctopusMsi
    {
        public string Path { get; set; }
        public bool PassPropertiesOnUninstall { get; set; }
        public Dictionary<string, OctopusProperty> PropertyList { get; set; }
    }

    [Serializable]
    public class OctopusCommand
    {
        public string Name { get; set; }
        public string Command { get; set; }
        public string StatusCodes { get; set; }
        public List<OctopusInputFile> InputFiles { get; set; }
        public string OutputFiles { get; set; }

        public void SetInputFiles(InputFile[] inputFiles)
        {
            InputFiles = new List<OctopusInputFile>();

            foreach (var inputFile in inputFiles)
            {
                InputFiles.Add(new OctopusInputFile() { SourcePath = inputFile.SourcePath, DestinationPath = inputFile.DestinationPath });
            }
        }
    }

    [Serializable]
    public class OctopusInputFile
    {
        public string SourcePath { get; set; }
        public string DestinationPath { get; set; }
    }

    [Serializable]
    public class AggregateComponent
    {
        public string Name { get; private set; }
        public Dictionary<string, string> PassProperties { get; private set; }

        public AggregateComponent(string name, Dictionary<string, string> passProperties)
        {
            Name = name;
            PassProperties = passProperties;

            if (PassProperties == null)
            {
                PassProperties = new Dictionary<string, string>();
            }
        }
    }

    [Serializable]
    public class RequireInterface
    {
        public string Name { get; private set; }
        public DependsOnWaitValue Wait { get; private set; }

        public RequireInterface(string name, DependsOnWaitValue wait)
        {
            Name = name;
            Wait = wait;
        }

        public RequireInterface(string name)
            : this(name, DependsOnWaitValue.All)
        {
        }
    }

    [Serializable]
    public class RequireInterfaceCollection : Dictionary<string, RequireInterface>
    {
        public string Name { get; private set; }
        public DependsOnWaitValue Wait { get; private set; }

        public RequireInterfaceCollection()
            : base()
        {
        }

        public RequireInterfaceCollection(RequireInterfaceCollection requireInterfaces)
            : base(requireInterfaces)
        {
        }

        public void Add(string name)
        {
            this.Add(name, DependsOnWaitValue.All);
        }

        public void Add(string name, DependsOnWaitValue wait)
        {
            if (this.ContainsKey(name))
            {
                if (this[name].Wait != DependsOnWaitValue.All)
                {
                    this[name] = new RequireInterface(name, wait);
                }
            }
            else
            {
                this.Add(name, new RequireInterface(name, wait));
            }
        }

        public void Add(RequireInterface requireInterface)
        {
            Add(requireInterface.Name, requireInterface.Wait);
        }
    }

    [Serializable]
    public class OctopusComponent
    {
        // Octopus Component Name
        public string Name { get; set; }

        // Octopus Dependencies
        public string PublishInterface { get; set; }
        public Dictionary<string, AggregateComponent> AggregateComponents { get; set; }
        public RequireInterfaceCollection RequireInterfaces { get; set; }

        public Dictionary<string, OctopusProperty> PropertyList { get; set; }
        public string PrerequisiteChecks { get; set; }
        public string PostDeploymentChecks { get; set; }
        public string ConditionChecks { get; set; }
        public string Reboot { get; set; }

        // Octopus Actions
        public OctopusMsi Msi { get; set; }
        public OctopusCommand InstallCommand { get; set; }
        public OctopusCommand UninstallCommand { get; set; }

        #region Helper Populating Functions

        public void PopulatePostDeploymentChecks(XmlElement postDeploymentChecks)
        {
            if (postDeploymentChecks != null)
            {
                PostDeploymentChecks = postDeploymentChecks.OuterXml;
            }
        }

        public void PopulatePrerequisiteChecks(XmlElement prerequisiteChecks)
        {
            if (prerequisiteChecks != null)
            {
                PrerequisiteChecks = prerequisiteChecks.OuterXml;
            }
        }

        public void PopulateConditionChecks(XmlElement conditionChecks)
        {
            if (conditionChecks != null)
            {
                ConditionChecks = conditionChecks.OuterXml;
            }
        }

        public void PopulateReboot(XmlElement reboot)
        {
            if (reboot != null)
            {
                Reboot = reboot.OuterXml;
            }
        }

        public void PopulateMsi(Msi msi)
        {
            if (msi != null)
            {
                Msi = new OctopusMsi();
                Msi.Path = msi.Path;
                Msi.PassPropertiesOnUninstall = msi.PassPropertiesOnUninstall;
                Msi.PropertyList = OctopusProperty.GetPropertyList(msi.PropertyList);
            }
        }

        public void PopulateInstallCommand(InstallCommand installCommand)
        {
            if (installCommand != null)
            {
                InstallCommand = new OctopusCommand();
                InstallCommand.Name = installCommand.Name;
                InstallCommand.Command = installCommand.Command;

                if (installCommand.InputFiles != null)
                {
                    InstallCommand.SetInputFiles(installCommand.InputFiles.FileList);
                }
                if (installCommand.OutputFiles != null)
                {
                    InstallCommand.OutputFiles = installCommand.OutputFiles.OuterXml;
                }
                if (installCommand.StatusCodes != null)
                {
                    InstallCommand.StatusCodes = installCommand.StatusCodes.OuterXml;
                }
            }
        }

        public void PopulateUninstallCommand(InstallCommand uninstallCommand)
        {
            if (uninstallCommand != null)
            {
                UninstallCommand = new OctopusCommand();
                UninstallCommand.Name = uninstallCommand.Name;
                UninstallCommand.Command = uninstallCommand.Command;

                if (uninstallCommand.InputFiles != null)
                {
                    UninstallCommand.SetInputFiles(uninstallCommand.InputFiles.FileList);
                }
                if (uninstallCommand.OutputFiles != null)
                {
                    UninstallCommand.OutputFiles = uninstallCommand.OutputFiles.OuterXml;
                }
                if (uninstallCommand.StatusCodes != null)
                {
                    UninstallCommand.StatusCodes = uninstallCommand.StatusCodes.OuterXml;
                }
            }
        }

        public void PopulateProperties(LanguageProperty[] properties)
        {
            PropertyList = OctopusProperty.GetPropertyList(properties);
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\src\Processors\ProcessCollections.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.tools.deploymentlanguage.Language;
using xonline.tools.deploymentlanguage.Octopus;
using System.Xml;
using xonline.tools.deploymentlanguage.Intermediate;

namespace xonline.tools.deploymentlanguage
{
    /// <summary>
    /// Collects all components and install steps to a list
    /// </summary>
    public class ProcessCollections : IProcessor
    {
        private LanguageDefinition _languageDefinition;
        private Definition _definition;
        private LanguageErrors _errorCollection;

        public void Process(LanguageDefinition languageDefinition, Definition definition, LanguageErrors errorCollection)
        {
            _languageDefinition = languageDefinition;
            _definition = definition;
            _errorCollection = errorCollection;

            CollectProperties();
            CollectReleases();
            CollectDeploymentPhases();
            CollectComponents();
            CollectInstallSteps();
        }

        private void CollectProperties()
        {
            _definition.SetGlobalProperties(_languageDefinition.Properties);
        }

        private void CollectReleases()
        {
            foreach (var languageRelease in _languageDefinition.Releases)
            {
                if (_definition.Releases.ContainsKey(languageRelease.Name))
                {
                    _errorCollection.Add(languageRelease.FileName,
                        ErrorId.DuplicateReleaseName, languageRelease.Name);

                    continue;
                }

                var release = new Release(languageRelease);
                _definition.Releases.Add(languageRelease.Name, release);
            }
        }

        private void CollectDeploymentPhases()
        {
            foreach (var languageDeploymentPhase in _languageDefinition.DeploymentPhases)
            {
                if (_definition.DeploymentPhases.ContainsKey(languageDeploymentPhase.Name))
                {
                    _errorCollection.Add(languageDeploymentPhase.FileName,
                        ErrorId.DuplicateDeploymentPhaseName, languageDeploymentPhase.Name);

                    continue;
                }

                var deploymentPhase = new DeploymentPhase(languageDeploymentPhase);

                _definition.DeploymentPhases.Add(deploymentPhase.Name, deploymentPhase);

                if (deploymentPhase.Default)
                {
                    // If there are more than one default deployment phase, we should show an error
                    if (_definition.DefaultDeploymentPhase != null)
                    {
                        _errorCollection.Add(languageDeploymentPhase.FileName,
                            ErrorId.MultipleDefaultDeploymentPhaseDefined);
                    }
                    else
                    {
                        _definition.SetDefaultDeploymentPhase(deploymentPhase);
                    }
                }
            }

            // If no deployment phases are specified, a default "Main" would be created
            if (_definition.DeploymentPhases.Count == 0)
            {
                var languageDeploymentPhase = new LanguageDeploymentPhase();
                languageDeploymentPhase.Name = "Main";
                languageDeploymentPhase.Default = true;
                languageDeploymentPhase.FileName = "";

                var deploymentPhase = new DeploymentPhase(languageDeploymentPhase);

                _definition.DeploymentPhases.Add(deploymentPhase.Name, deploymentPhase);
                _definition.SetDefaultDeploymentPhase(deploymentPhase);
            }

            if (_definition.DefaultDeploymentPhase == null)
            {
                _errorCollection.Add("", ErrorId.NoDefaultDeploymentPhaseDefined);
            }
        }

        /// <summary>
        /// Go through all high level components and add them to the list of Octopus components
        /// </summary>        
        private void CollectComponents()
        {
            System.Diagnostics.Debug.Assert(_definition.DefaultDeploymentPhase != null, "Default deployment phase should be created before ProcessCollection");

            // Go through all components and copy it to OctopusComponents
            foreach (var languageComponent in _languageDefinition.Components)
            {
                // Create Octopus Component copying over the values
                var component = new ReleaseComponent(languageComponent);

                try
                {
                    var deploymentPhaseName = component.OriginalComponentLanguage.DeploymentPhase;
                    var deploymentPhase = _definition.DefaultDeploymentPhase;

                    // If there's a deployment phase defined, add the component to that deployment phase
                    if (deploymentPhaseName != null)
                    {
                        if (_definition.DeploymentPhases.ContainsKey(deploymentPhaseName))
                        {
                            deploymentPhase = _definition.DeploymentPhases[deploymentPhaseName];                            
                        }
                        else
                        {
                            _errorCollection.Add(component.OriginalDefinitionFileName,
                                ErrorId.DeploymentPhaseNotFound,
                                deploymentPhaseName,
                                component.Name);
                        }
                    }

                    deploymentPhase.Components.Add(component.Name, component);
                    
                    if (component.OriginalComponentLanguage.DependedByAllComponents)
                    {
                        deploymentPhase.DependedByAllComponents.Add(component.Name, component);
                    }
                    else if (component.OriginalComponentLanguage.DependsOnAllComponents)
                    {
                        deploymentPhase.DependsOnAllComponents.Add(component.Name, component);
                    }

                    _definition.AllComponents.Add(component.Name, component);
                }
                catch (ArgumentException)
                {
                    _errorCollection.Add(languageComponent.FileName, ErrorId.DuplicateReleaseComponentName, languageComponent.Name);
                }
            }
        }

        /// <summary>
        /// Go through all Install Steps and add them to the list of Octopus components
        /// </summary>
        private void CollectInstallSteps()
        {
            foreach (var installStep in _languageDefinition.InstallSteps)
            {
                var installComponent = new InstallStepComponent(installStep);

                try
                {
                    _definition.AddInstallStepComponent(installComponent);
                }
                catch (ArgumentException)
                {
                    _errorCollection.Add(installStep.FileName, ErrorId.DuplicateInstallStepName, installStep.Name);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\src\Processors\ProcessDependencyCheck.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.tools.deploymentlanguage.Intermediate;

namespace xonline.tools.deploymentlanguage
{
    public class ProcessDependencyCheck : IProcessor
    {
        private LanguageDefinition _languageDefinition;
        private Definition _definition;
        private LanguageErrors _errorCollection;

        private HashSet<IParentComponent> _componentsWithLoop = new HashSet<IParentComponent>();

        public void Process(LanguageDefinition languageDefinition, Definition definition, LanguageErrors errorCollection)
        {
            _languageDefinition = languageDefinition;
            _definition = definition;
            _errorCollection = errorCollection;

            CheckDependencyLoopsOnComponents();
            CheckInstallStepLoops();
        }

        private void CheckDependencyLoopsOnComponents()
        {
            foreach (var component in _definition.Components.Values)
            {
                // Skip component if it's already found that it has a dependency loop
                if (_componentsWithLoop.Contains(component))
                {
                    continue;
                }

                var componentLoopList = new List<IParentComponent>();

                if (HasComponentDependencyLoops(componentLoopList, component))
                {
                    GatherLoopErrors(componentLoopList);
                }
            }
        }

        private bool HasComponentDependencyLoops(List<IParentComponent> componentLoopList, IParentComponent releaseComponent)
        {
            componentLoopList.Add(releaseComponent);

            // Go through all DependsOn components and check for loops
            foreach (var component in releaseComponent.DependsOnComponents)
            {
                if (componentLoopList.Contains(component.Component))
                {
                    componentLoopList.Add(component.Component);
                    return true;
                }
                else if (HasComponentDependencyLoops(componentLoopList, component.Component))
                {
                    return true;
                }
            }

            // Go through all install steps to see if there are dependsOn loops
            foreach (var installStep in releaseComponent.InstallComponents)
            {
                if (installStep.InstallComponent is InstallStepComponent)
                {
                    var installStepComponent = installStep.InstallComponent as InstallStepComponent;

                    if (componentLoopList.Contains(installStepComponent))
                    {
                        componentLoopList.Add(installStepComponent);
                        return true;
                    }
                    else if (HasComponentDependencyLoops(componentLoopList, installStepComponent))
                    {
                        return true;
                    }
                }
            }

            componentLoopList.Remove(releaseComponent);

            return false;
        }

        private void CheckInstallStepLoops()
        {
            foreach (var installStepComponent in _definition.InstallStepComponents.Values)
            {
                // Skip component if it's already found that it has a dependency loop
                if (_componentsWithLoop.Contains(installStepComponent))
                {
                    continue;
                }

                var componentLoopList = new List<IParentComponent>();

                if (HasInstallStepLoops(componentLoopList, installStepComponent))
                {
                    GatherLoopErrors(componentLoopList);
                }
            }
        }

        private bool HasInstallStepLoops(List<IParentComponent> componentLoopList, IParentComponent installComponent)
        {
            componentLoopList.Add(installComponent);

            // Go through all install steps to see if there are dependsOn loops
            foreach (var installStep in installComponent.InstallComponents)
            {
                if (installStep.InstallComponent is InstallStepComponent)
                {
                    var installStepComponent = installStep.InstallComponent as InstallStepComponent;

                    if (componentLoopList.Contains(installStepComponent))
                    {
                        componentLoopList.Add(installStepComponent);
                        return true;
                    }
                    else if (HasComponentDependencyLoops(componentLoopList, installStepComponent))
                    {
                        return true;
                    }
                }
            }

            componentLoopList.Remove(installComponent);

            return false;
        }

        /// <summary>
        /// Find the loop in the component list and 
        /// </summary>
        /// <param name="componentLoopList"></param>
        private void GatherLoopErrors(List<IParentComponent> componentLoopList)
        {
            var lastComponent = componentLoopList[componentLoopList.Count - 1];

            StringBuilder sb = new StringBuilder();
            for (int i = componentLoopList.IndexOf(lastComponent); i < componentLoopList.Count; i++)
            {
                // Add the components that contains a loop to the list so we can skip them later
                _componentsWithLoop.Add(componentLoopList[i]);

                if (sb.Length > 0)
                {
                    sb.Append(" -> ");
                }
                sb.Append(componentLoopList[i].Name);
                sb.AppendFormat(" ({0})", componentLoopList[i] is ReleaseComponent ? "Component" : "InstallStep");
            }

            if (lastComponent is ReleaseComponent)
            {
                _errorCollection.Add(
                    lastComponent.OriginalDefinitionFileName,
                    ErrorId.DependencyLoop,
                    lastComponent.Name,
                    sb.ToString());
            }
            else
            {
                _errorCollection.Add(
                    lastComponent.OriginalDefinitionFileName,
                    ErrorId.InstallStepLoop,
                    lastComponent.Name,
                    sb.ToString());
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\src\Processors\ProcessDuplicateComponents.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.tools.deploymentlanguage.Intermediate;

namespace xonline.tools.deploymentlanguage
{
    public class ProcessDuplicateComponents : IProcessor
    {
        private LanguageDefinition _languageDefinition;
        private Definition _definition;
        private LanguageErrors _errorCollection;

        public void Process(LanguageDefinition languageDefinition, Definition definition, LanguageErrors errorCollection)
        {
            _languageDefinition = languageDefinition;
            _definition = definition;
            _errorCollection = errorCollection;

            DuplicateComponents();
        }

        private void DuplicateComponents()
        {
            foreach (var component in _definition.Components.Values)
            {
                foreach (var installRelationship in component.InstallComponents)
                {
                    CloneComponentIfRequired(installRelationship);
                }
            }
        }

        /// <summary>
        /// Clone the whole component if the element is an install step without RunOnce marked as true
        /// </summary>
        /// <param name="installRelationship"></param>
        private void CloneComponentIfRequired(InstallRelationship installRelationship)
        {
            if (installRelationship.InstallComponent is InstallStepComponent)
            {
                var installStepComponent = installRelationship.InstallComponent as InstallStepComponent;

                // If the install step is not marked run once, we can clone it
                if (!installStepComponent.RunOnce)
                {
                    CloneComponent(installRelationship);

                    installStepComponent = installRelationship.InstallComponent as InstallStepComponent;

                    // Recursively clone child install components unless it is an install step that marked RunOnce
                    foreach (var childInstallRelationship in installStepComponent.InstallComponents)
                    {
                        if (childInstallRelationship.InstallComponent is InstallStepComponent)
                        {
                            CloneComponentIfRequired(childInstallRelationship);
                        }
                        else
                        {
                            CloneComponent(childInstallRelationship);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Clone a component by shadow copying the relationships and deep copying the Octopus elements
        /// </summary>
        /// <param name="installRelationship"></param>
        /// <returns></returns>
        private void CloneComponent(InstallRelationship installRelationship)
        {
            var installStepComponent = (IInstallComponent)installRelationship.InstallComponent;

            installRelationship.InstallComponent = installStepComponent.DuplicateComponent();
            installRelationship.InstallComponent.ParentComponents.Add(installRelationship);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\src\Processors\ProcessDependsOn.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.tools.deploymentlanguage.Intermediate;
using xonline.tools.deploymentlanguage.Language;

namespace xonline.tools.deploymentlanguage
{
    /// <summary>
    /// Resolves dependsOn lists to release components
    /// 
    /// Must run after ProcessComponents to ensure release component collection has been filled
    /// </summary>
    public class ProcessDependsOn : IProcessor
    {
        private LanguageDefinition _languageDefinition;
        private Definition _definition;
        private LanguageErrors _errorCollection;

        public void Process(LanguageDefinition languageDefinition, Definition definition, LanguageErrors errorCollection)
        {
            _languageDefinition = languageDefinition;
            _definition = definition;
            _errorCollection = errorCollection;

            ResolveComponentDependencies();
            ResolveInstallStepDependencies();
            ResolveAllComponentDependencies();
        }

        private void ResolveAllComponentDependencies()
        {
            foreach (var dependedByComponent in _definition.DependedByAllComponents.Values)
            {
                foreach (var component in _definition.Components.Values)
                {
                    if (!component.OriginalComponentLanguage.DependedByAllComponents &&
                        !component.OriginalComponentLanguage.DependsOnAllComponents)
                    {
                        component.AddDependsOnComponent(dependedByComponent);
                    }
                }
            }

            foreach (var dependsOnComponent in _definition.DependsOnAllComponents.Values)
            {
                foreach (var component in _definition.Components.Values)
                {
                    if (!component.OriginalComponentLanguage.DependedByAllComponents &&
                        !component.OriginalComponentLanguage.DependsOnAllComponents)
                    {
                        dependsOnComponent.AddDependsOnComponent(component);
                    }
                }
            }
        }

        private void ResolveComponentDependencies()
        {
            foreach (var component in _definition.Components.Values)
            {
                ResolveDependencies(component, component.OriginalComponentLanguage.DependsOnList);
            }
        }

        private void ResolveInstallStepDependencies()
        {
            foreach (var component in _definition.InstallStepComponents.Values)
            {
                ResolveDependencies(component, component.OriginalInstallStepLanguage.DependsOnList);
            }
        }

        private void ResolveDependencies(IParentComponent component, DependsOn[] dependsOnList)
        {
            foreach (var dependsOnElement in dependsOnList)
            {
                if (_definition.Components.ContainsKey(dependsOnElement.ComponentName))
                {
                    var releaseComponent = _definition.Components[dependsOnElement.ComponentName];

                    DependOnComponent dependOnComponent = new DependOnComponent(releaseComponent, dependsOnElement.Wait);
                    component.AddDependsOnComponent(dependOnComponent);
                }
                else if (component is ReleaseComponent)
                {
                    if (_definition.AllComponents.ContainsKey(dependsOnElement.ComponentName))
                    {
                        _errorCollection.Add(component.OriginalDefinitionFileName,
                            ErrorId.ReleaseComponentNotFoundInSameDeploymentPhase,
                            component.Name,
                            dependsOnElement.ComponentName,
                            _definition.CurrentDeploymentPhase.Name);
                    }
                    else
                    {
                        _errorCollection.Add(component.OriginalDefinitionFileName,
                            ErrorId.ReleaseComponentNotFound,
                            dependsOnElement.ComponentName);
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\src\Processors\ProcessResolveComponents.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.tools.deploymentlanguage.Language;
using xonline.tools.deploymentlanguage.Octopus;
using xonline.tools.deploymentlanguage.Intermediate;

namespace xonline.tools.deploymentlanguage
{
    /// <summary>
    /// Resolves install element names to real component references
    /// 
    /// Must run after ProcessCollections so component collections are filled up
    /// </summary>
    public class ProcessResolveComponents : IProcessor
    {
        private LanguageDefinition _languageDefinition;
        private Definition _definition;
        private LanguageErrors _errorCollection;

        public void Process(LanguageDefinition languageDefinition, Definition definition, LanguageErrors errorCollection)
        {
            _languageDefinition = languageDefinition;
            _definition = definition;
            _errorCollection = errorCollection;

            ResolveReleaseComponents();
            ResolveComponents();
            ResolveInstallComponents();
        }

        private void ResolveReleaseComponents()
        {
            foreach (var release in _definition.Releases.Values)
            {
                release.ReleaseComponents.Clear();

                foreach (var componentRef in release.OriginalReleaseElement.ComponentList)
                {
                    if (_definition.Components.ContainsKey(componentRef.Name))
                    {
                        release.ReleaseComponents.Add(_definition.Components[componentRef.Name]);
                    }
                    else if (!_definition.AllComponents.ContainsKey(componentRef.Name))
                    {
                        _errorCollection.Add(release.OriginalElementFileName,
                            ErrorId.ReleaseComponentNotFound,
                            componentRef.Name);
                    }
                }
            }
        }

        private void ResolveComponents()
        {
            foreach (var component in _definition.Components.Values)
            {
                foreach (var installStepElement in component.OriginalComponentLanguage.InstallElementList)
                {
                    Resolve(component, installStepElement);
                }
            }
        }

        private void ResolveInstallComponents()
        {
            foreach (var installStep in _definition.InstallStepComponents.Values)
            {
                foreach (var installStepElement in installStep.OriginalInstallStepLanguage.InstallElementList)
                {
                    Resolve(installStep, installStepElement);
                }
            }
        }

        private void Resolve(IParentComponent parentComponent, InstallElement installStepElement)
        {
            Component installComponent = null;
            Dictionary<string, string> passProperties = null;

            // If it's a RunCommand or RunMsi, create the install component as well and add them to the InstallComponents list
            // Will need to use the unique name generated instead of the install element name
            if (installStepElement is RunCommand)
            {
                installComponent = new RunCommandComponent(parentComponent.OriginalTopLanguageElement, (RunCommand)installStepElement);
            }
            else if (installStepElement is RunMsi)
            {
                installComponent = new RunMsiComponent(parentComponent.OriginalTopLanguageElement, (RunMsi)installStepElement);
            }
            else if (installStepElement is Install)
            {
                var install = (Install)installStepElement;

                if (_definition.InstallStepComponents.ContainsKey(installStepElement.Name))
                {
                    // Retrieve install step from list
                    installComponent = _definition.InstallStepComponents[installStepElement.Name];

                    // Get the pass properties
                    passProperties = Component.ConvertPassProperties(install.PassProperty);
                }
                else
                {
                    // If the install step is not found in any of the deployment phases, log the error
                    _errorCollection.Add(parentComponent.OriginalDefinitionFileName, ErrorId.InstallComponentNotFound, installStepElement.Name);
                }
            }

            if (installComponent != null)
            {
                parentComponent.AddInstallComponent(installComponent, passProperties);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\src\Processors\ProcessProperties.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.tools.deploymentlanguage.Intermediate;
using xonline.tools.deploymentlanguage.Octopus;
using System.Text.RegularExpressions;
using xonline.tools.deploymentlanguage.Language;

namespace xonline.tools.deploymentlanguage
{
    public class ProcessProperties : IProcessor
    {
        private LanguageDefinition _languageDefinition;
        private Definition _definition;
        private LanguageErrors _errorCollection;

        public void Process(LanguageDefinition languageDefinition, Definition definition, LanguageErrors errorCollection)
        {
            _languageDefinition = languageDefinition;
            _definition = definition;
            _errorCollection = errorCollection;

            ResolveProperties();
            CheckReleaseComponentProperties();
        }

        /// <summary>
        /// Go through all releases and check if all the properties are defined in the individual components
        /// </summary>
        private void CheckReleaseComponentProperties()
        {
            foreach (var release in _languageDefinition.Releases)
            {
                ValidateReleaseComponentProperties(release);
            }
        }

        private void ValidateReleaseComponentProperties(LanguageRelease release)
        {
            foreach (var componentRef in release.ComponentList)
            {
                foreach (var passProperty in componentRef.PassProperty)
                {
                    // Check if the property defined for the component in the release exists in the component itself
                    if (_definition.Components.ContainsKey(componentRef.Name) &&
                        !_definition.Components[componentRef.Name].Octopus.PropertyList.ContainsKey(passProperty.Name))
                    {
                        _errorCollection.Add(release.FileName, ErrorId.ReleaseComponentPropertyNotFound, passProperty.Name, componentRef.Name);
                    }
                }
            }
        }

        private void ResolveProperties()
        {
            foreach (var component in _definition.Components.Values)
            {
                PopulateProperties(component);
                CheckUnresolvedProperties(component);

                foreach (var installRelationship in component.InstallComponents)
                {
                    ResolveProperties(installRelationship);
                }
            }
        }

        private void ResolveProperties(InstallRelationship relationship)
        {
            var installComponent = relationship.InstallComponent as Component;

            PopulateProperties(installComponent);
            SetPassProperties(relationship);
            CheckUnresolvedProperties(relationship);

            foreach (var installRelationship in ((IParentComponent)installComponent).InstallComponents)
            {
                ResolveProperties(installRelationship);
            }
        }

        /// <summary>
        /// Go through all properties defined in the component and see if the parent component
        /// of the action step have the values. If it does, fill in the passProperty
        /// </summary>
        /// <param name="component"></param>
        private void SetPassProperties(InstallRelationship relationship)
        {
            SetPassProperties(relationship, relationship.InstallComponent.Octopus.PropertyList.Values);

            if (relationship.InstallComponent.Octopus.Msi != null)
            {
                SetPassProperties(relationship, relationship.InstallComponent.Octopus.Msi.PropertyList.Values);
            }
        }

        private void SetPassProperties(InstallRelationship relationship, IEnumerable<OctopusProperty> properties)
        {
            var childComponent = relationship.InstallComponent;
            var parentComponent = relationship.ParentComponent;

            foreach (var property in properties)
            {
                if (relationship.PassProperties.ContainsKey(property.Name) || (property.HasValue && property.Value == null))
                {
                    continue;
                }
                else if ((childComponent is RunCommandComponent || childComponent is RunMsiComponent) &&
                    parentComponent.Octopus.PropertyList.ContainsKey(property.Name))
                {
                    relationship.PassProperties.Add(property.Name, "[" + property.Name + "]");
                }
            }
        }

        /// <summary>
        /// Go through all properties defined in the component and see if it has been resolved
        /// either by passProperties or referenced in a global property. If not, log an error
        /// </summary>
        /// <param name="component"></param>
        private void CheckUnresolvedProperties(InstallRelationship relationship)
        {
            CheckUnresolvedProperties(relationship, relationship.InstallComponent.Octopus.PropertyList.Values);

            if (relationship.InstallComponent.Octopus.Msi != null)
            {
                CheckUnresolvedProperties(relationship, relationship.InstallComponent.Octopus.Msi.PropertyList.Values);
            }
        }

        private void CheckUnresolvedProperties(InstallRelationship relationship, IEnumerable<OctopusProperty> properties)
        {
            var childComponent = relationship.InstallComponent;
            var parentComponent = relationship.ParentComponent;

            foreach (var property in properties)
            {
                if (!relationship.PassProperties.ContainsKey(property.Name))
                {
                    if (property.HasValue)
                    {
                        foreach (var valueProperty in FindProperties(property.Value))
                        {
                            if (!(childComponent.Octopus.PropertyList.ContainsKey(valueProperty) || _definition.GlobalProperties.ContainsKey(valueProperty)))
                            {
                                _errorCollection.Add(childComponent.OriginalDefinitionFileName,
                                    ErrorId.UnresolvedPropertyGlobalOrParent,
                                    property.Name,
                                    parentComponent.Name);
                            }
                        }
                    }
                    else
                    {
                        _errorCollection.Add(childComponent.OriginalDefinitionFileName,
                            ErrorId.UnresolvedPropertyGlobalOrParent,
                            property.Name,
                            parentComponent.Name);
                    }
                }
            }
        }

        private void CheckUnresolvedProperties(Component component)
        {
            foreach (var property in component.Octopus.PropertyList.Values)
            {
                if (property.HasValue)
                {
                    foreach (var valueProperty in FindProperties(property.Value))
                    {
                        if (!(component.Octopus.PropertyList.ContainsKey(valueProperty) || _definition.GlobalProperties.ContainsKey(valueProperty)))
                        {
                            _errorCollection.Add(component.OriginalDefinitionFileName,
                                ErrorId.UnresolvedPropertyGlobal,
                                property.Name);
                        }
                    }
                }
                else
                {
                    _errorCollection.Add(component.OriginalDefinitionFileName,
                        ErrorId.UnresolvedPropertyGlobal,
                        property.Name);
                }
            }
        }

        /// <summary>
        /// Find property defined using [ ] and create the property names for it
        /// </summary>
        /// <param name="component"></param>
        private void PopulateProperties(Component component)
        {
            // Gather all properties defined in this component using [ ]
            var definedProperties = GetDefinedProperties(component.Octopus);

            // Add the defined properties to list of they don't already exists
            foreach (var definedPropertyName in definedProperties)
            {
                if (!component.Octopus.PropertyList.ContainsKey(definedPropertyName))
                {
                    // Make sure it does not exist in the msi as well as they share the same namespace
                    if (component.Octopus.Msi == null || !component.Octopus.Msi.PropertyList.ContainsKey(definedPropertyName))
                    {
                        var property = new OctopusProperty() { Name = definedPropertyName };

                        component.Octopus.PropertyList.Add(definedPropertyName, property);
                    }
                }
            }

            // Populate properties with global property values if they match and don't already have a value
            foreach (var property in component.Octopus.PropertyList.Values)
            {
                if (!property.HasValue && _definition.GlobalProperties.ContainsKey(property.Name))
                {
                    property.Value = "[" + property.Name + "]";

                    _definition.AddUsedGlobalProperty(property.Name);
                }
            }

            // Populate Msi properties with global property values if they match
            if (component.Octopus.Msi != null)
            {
                foreach (var property in component.Octopus.Msi.PropertyList.Values)
                {
                    if (!property.HasValue && _definition.GlobalProperties.ContainsKey(property.Name))
                    {
                        property.Value = "[" + property.Name + "]";

                        _definition.AddUsedGlobalProperty(property.Name);
                    }
                }
            }
        }

        private static HashSet<string> GetDefinedProperties(OctopusComponent component)
        {
            var properties = new HashSet<string>();

            if (component.InstallCommand != null)
            {
                properties.UnionWith(FindProperties(component.InstallCommand.Command));
            }

            if (component.UninstallCommand != null)
            {
                properties.UnionWith(FindProperties(component.UninstallCommand.Command));
            }

            properties.UnionWith(FindProperties(component.PostDeploymentChecks));
            properties.UnionWith(FindProperties(component.PrerequisiteChecks));
            properties.UnionWith(FindProperties(component.ConditionChecks));

            if (component.Msi != null)
            {
                foreach (var property in component.Msi.PropertyList.Values)
                {
                    properties.UnionWith(FindProperties(property.Value));
                }
            }

            return properties;
        }

        public static HashSet<string> FindProperties(string input)
        {
            var properties = new HashSet<string>();

            if (input != null)
            {
                MatchCollection matches = new Regex(@"\[(?<Property>.*?)\]").Matches(input);

                foreach (Match match in matches)
                {
                    properties.Add(match.Groups["Property"].Value);
                }
            }

            return properties;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\src\Processors\ProcessValidation.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml.Schema;
using System.IO;
using System.Reflection;
using xonline.tools.deploymentlanguage.Language;
using xonline.tools.deploymentlanguage.Intermediate;

namespace xonline.tools.deploymentlanguage
{
    public class ProcessValidation : IProcessor
    {
        private LanguageDefinition _languageDefinition;
        private Definition _definition;
        private LanguageErrors _errorCollection;

        public void Process(LanguageDefinition languageDefinition, Definition definition, LanguageErrors errorCollection)
        {
            _languageDefinition = languageDefinition;
            _definition = definition;
            _errorCollection = errorCollection;

            ValidateComponents();
            ValidateInstallStepNames();
            ValidateReleases();
            ValidateDeploymentPhaseNames();            
        }

        private void ValidateInstallStepNames()
        {
            foreach (var installStep in _languageDefinition.InstallSteps)
            {
                if (String.IsNullOrEmpty(installStep.Name))
                {
                    _errorCollection.Add(installStep.FileName,
                        ErrorId.InstallComponentNameEmpty);
                }
            }
        }

        private void ValidateComponents()
        {
            foreach (var component in _languageDefinition.Components)
            {
                ValidateComponentNames(component);
            }
        }

        private void ValidateComponentNames(LanguageComponent component)
        {
            if (String.IsNullOrEmpty(component.Name))
            {
                _errorCollection.Add(component.FileName,
                    ErrorId.ReleaseComponentNameEmpty);
            }
        }

        private void ValidateReleases()
        {
            foreach (var release in _languageDefinition.Releases)
            {
                ValidateReleaseName(release);
                ValidateReleaseNotEmpty(release);
            }
        }

        private void ValidateReleaseName(LanguageRelease release)
        {
            if (String.IsNullOrEmpty(release.Name))
            {
                _errorCollection.Add(release.FileName,
                    ErrorId.ReleaseNameEmpty);
            }
            else if (release.Name.Equals(OctopusDependenciesSetter.DefaultReleaseName))
            {
                _errorCollection.Add(release.FileName,
                        ErrorId.ReservedReleaseNameUsed,
                        OctopusDependenciesSetter.DefaultReleaseName);
            }
            else if (!Util.IsValidFilename(release.Name))
            {
                _errorCollection.Add(release.FileName,
                        ErrorId.InvalidReleaseNameCharacters,
                        release.Name);
            }
        }

        private void ValidateReleaseNotEmpty(LanguageRelease release)
        {
            if (release.ComponentList.Length == 0)
            {
                _errorCollection.Add(release.FileName,
                    ErrorId.ReleaseEmpty, release.Name);
            }
        }

        private void ValidateDeploymentPhaseNames()
        {
            foreach (var deploymentPhase in _languageDefinition.DeploymentPhases)
            {
                if (String.IsNullOrEmpty(deploymentPhase.Name))
                {
                    _errorCollection.Add(deploymentPhase.FileName,
                        ErrorId.DeploymentPhaseNameEmpty);
                }
                else if (!Util.IsValidFilename(deploymentPhase.Name))
                {
                    _errorCollection.Add(deploymentPhase.FileName,
                            ErrorId.InvalidDeploymentPhaseNameCharacters,
                            deploymentPhase.Name);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\src\Processors\ProcessUniqueNames.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.tools.deploymentlanguage.Intermediate;
using System.Xml.Linq;

namespace xonline.tools.deploymentlanguage
{
    public class ProcessUniqueNames : IProcessor
    {
        private LanguageDefinition _languageDefinition;
        private Definition _definition;
        private LanguageErrors _errorCollection;

        private HashSet<string> _componentNames;

        public void Process(LanguageDefinition languageDefinition, Definition definition, LanguageErrors errorCollection)
        {
            _languageDefinition = languageDefinition;
            _definition = definition;
            _errorCollection = errorCollection;

            // Start off with the list from the component names
            _componentNames = new HashSet<string>(_definition.Components.Keys);
            CreateUniqueNames();
        }

        private void CreateUniqueNames()
        {
            foreach (var component in _definition.Components.Values)
            {
                foreach (var installRelationship in component.InstallComponents)
                {
                    SetUniqueNames(component, null, installRelationship.InstallComponent);
                }
            }
        }

        private void SetUniqueNames(Component rootComponent, Component parentComponent, IInstallComponent installComponent)
        {
            if (installComponent.HasUniqueName)
            {
                return;
            }

            var componentName = rootComponent.OriginalName;

            if (String.IsNullOrEmpty(installComponent.OriginalName))
            {
                if (parentComponent != null && !rootComponent.Equals(parentComponent))
                {
                    componentName += " " + parentComponent.OriginalName;
                }

                if (installComponent is RunMsiComponent)
                {
                    componentName += " msi";
                }
                else if (installComponent is RunCommandComponent)
                {
                    componentName += " command";
                }
            }
            else if ((installComponent is InstallStepComponent && ((InstallStepComponent)installComponent).RunOnce))
            {
                componentName = installComponent.OriginalName;
            }
            else
            {
                componentName += " " + installComponent.OriginalName;
            }
            
            installComponent.SetUniqueName(GetUniqueComponentName(componentName));

            if (installComponent is RunCommandComponent)
            {
                var octopusComponent = installComponent.Octopus;

                if (octopusComponent.InstallCommand != null)
                {
                    if (String.IsNullOrEmpty(octopusComponent.InstallCommand.Name))
                    {
                        octopusComponent.InstallCommand.Name = "install";
                    }
                    
                    octopusComponent.InstallCommand.Name = installComponent.Name + " " + octopusComponent.InstallCommand.Name;
                }

                if (octopusComponent.UninstallCommand != null)
                {
                    if (String.IsNullOrEmpty(octopusComponent.UninstallCommand.Name))
                    {
                        octopusComponent.UninstallCommand.Name = "uninstall";
                    }

                    octopusComponent.UninstallCommand.Name = installComponent.Name + " " + octopusComponent.UninstallCommand.Name;

                    if (octopusComponent.InstallCommand != null && octopusComponent.UninstallCommand.Name == octopusComponent.InstallCommand.Name)
                    {
                        octopusComponent.UninstallCommand.Name += " uninstall";
                    }
                }
            }

            // Rename the commandChecks in prerequisiteChecks and conditionChecks to include the component name so they are unique through out the service.xml
            installComponent.Octopus.PrerequisiteChecks = RenameCommandChecks(installComponent.Name, "prereq", installComponent.Octopus.PrerequisiteChecks);
            installComponent.Octopus.ConditionChecks = RenameCommandChecks(installComponent.Name, "condition", installComponent.Octopus.ConditionChecks);
            installComponent.Octopus.PostDeploymentChecks = RenameCommandChecks(installComponent.Name, "postdeploymentcheck", installComponent.Octopus.PostDeploymentChecks);

            // If it's an install step, we need to recursively set the child component names
            if (installComponent is InstallStepComponent)
            {
                var installStepComponent = installComponent as InstallStepComponent;

                // If this install step only runs once, the child components should just use the install step name
                if (installStepComponent.RunOnce)
                {
                    rootComponent = installStepComponent;
                }

                foreach (var installRelationship in installStepComponent.InstallComponents)
                {
                    SetUniqueNames(rootComponent, installStepComponent, installRelationship.InstallComponent);
                }
            }
        }

        private string RenameCommandChecks(string componentName, string prefix, string xmlWithCommandChecks)
        {
            if (xmlWithCommandChecks != null)
            {
                var xDoc = XDocument.Parse(xmlWithCommandChecks);

                foreach (var commandCheckElement in xDoc.Descendants("commandCheck"))
                {
                    var commandCheckNameAttribute = commandCheckElement.Attribute("name");

                    if (commandCheckNameAttribute == null)
                    {
                        commandCheckElement.AddAttribute("name", componentName + " " + prefix + " commandCheck");
                    }
                    else
                    {
                        var commandCheckName = commandCheckElement.Attribute("name").Value;

                        if (String.IsNullOrEmpty(commandCheckName))
                        {
                            commandCheckElement.Attribute("name").Value = componentName + " " + prefix + " commandCheck";
                        }
                        else
                        {
                            commandCheckElement.Attribute("name").Value = componentName + " " + prefix + " " + commandCheckName;
                        }
                    }
                }

                return xDoc.ToString();
            }
            else
            {
                return null;
            }
        }

        private string GetUniqueComponentName(string name)
        {
            // If the name already exists in collection, generate a new name based on the original name
            // by adding a counter integer to the end. If the integer already exists, increment it by 1.
            while (_componentNames.Contains(name))
            {
                int counter;

                // If there's a space and that the last part is an integer, treat it as a counter value and increment it
                if (name.Contains(' ') && Int32.TryParse(name.Substring(name.LastIndexOf(' ') + 1), out counter))
                {
                    // Grab the string part and increment the counter value
                    name = name.Substring(0, name.LastIndexOf(' ')) + ' ' + ++counter;
                }
                else
                {
                    // When it doesn't look like a counter value at the end, just add a 2 to the name
                    name += " 2";
                }
            }

            _componentNames.Add(name);

            return name;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\test\SelfOrganizingTestNode.cs ===
using ServerTestFramework;
using System;
using System.IO;


/// <summary>
/// Helper class which organizes test data along with the
/// SelfOrganizingTestGroup class. This class must be nested in a corresponding
/// test group, or else it will fail.
/// 
/// 
/// This class is not threadsafe or re-entrant.
/// </summary>
public abstract class SelfOrganizingTestNode : TestNode
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\test\DeploymentLanguageTests.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Reflection;
using System.Security.Cryptography.X509Certificates;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using System.Runtime.Serialization;
using System.IO;
using System.Xml;
using System.Linq;

using xonline.tools.deploymentlanguage;
using xonline.tools.deploymentlanguage.Language;

namespace xonline.tools.deploymentlanguage.test.DeploymentLanguageUnitTests
{


    /// <summary>
    /// Base TestNode which most, if not all test nodes derive from. This class
    /// holds shared data used for validating tests, constants, and various helper
    /// methods. Additionally, this method makes sure that any dynamically overridden
    /// methods are restored before each test case complietes.
    /// </summary>
    public class DeploymentLanguageTestNode : SelfOrganizingTestGroup
    {
   
        public override void Run()
        {
            return base.Run();
        }


        /// <summary>
        /// An exception used to specify that we've encountered a problem. This is always a terminating condition.
        /// This intentionally shadows the STF exception of the same type. The one included in STF is not serializable
        /// and this is a requirement for throwing exceptions across AppDomains using remoting.
        /// </summary>
        [Serializable]
        public class UnexpectedTestResultException : Exception
        {
            public UnexpectedTestResultException(string message) : base(message) { }
            public UnexpectedTestResultException() { }
            public UnexpectedTestResultException(string message, Exception innerException) : base(message, innerException) { }
            public UnexpectedTestResultException(SerializationInfo serializationInfo, StreamingContext streamingContext)
                : base(serializationInfo, streamingContext) { }
        }

        #region Custom Assertions

        /// <summary>
        /// Used to indicate that a test case should never pass. This is usually only useful for test cases that
        /// are not finished and should not appear in any finished test case code.
        /// </summary>
        /// <param name="message">The reason why the test failed.</param>
        public static void Fail(string message)
        {
            throw new UnexpectedTestResultException(message);
        }

        /// <summary>
        /// A delegate used in combination with AssertThrowsException().
        /// </summary>
        public delegate void AssertionDelegate();

        /// <summary>
        /// Indicates that a specific block of code is expected to throw an exception of a certain type. Polymorphism for exception
        /// types is not supported. For example, this method will fail a test case if IllegalOperationException was thrown but Exception
        /// was expected.
        /// </summary>
        /// <param name="assertionDelegate">A single-cast delegate which represents the code that should not throw an exception</param>
        /// <param name="expectedExceptionType">The most specific type of the exception which is expected to be thrown.</param>
        public void AssertThrowsException(AssertionDelegate assertionDelegate, Type expectedExceptionType)
        {
            bool caughtExpectedException = false;
            try
            {
                assertionDelegate();
            }
            catch (Exception e)
            {
                Type actualExceptionType = e.GetType();
                if (expectedExceptionType != null && actualExceptionType != expectedExceptionType)
                {
                    throw new UnexpectedTestResultException(String.Format("Expected exception {0} to be thrown. Caught {1} instead.", expectedExceptionType, actualExceptionType), e);
                }
                caughtExpectedException = true;
            }

            if (!caughtExpectedException)
                throw new UnexpectedTestResultException(String.Format("Expected exception {0} to be thrown. No exception actually caught.", expectedExceptionType));
        }

        /// <summary>
        /// Indicates that value1 and value2 are not expected to be equal.
        /// </summary>
        /// <typeparam name="T">A generic type. This type must implement IEquatable[T] interface</typeparam>
        /// <param name="value1">The first value.</param>
        /// <param name="value2">The second value.</param>
        /// <param name="message">A message displayed to the test runner when this assertion fails.</param>
        public void AssertNotEqual<T>(T value1, T value2, string message) where T : IEquatable<T>
        {
            if (value1.Equals(value2))
            {
                if (message == null)
                    message = "Tested values are not supposed to be equal.";
                message = String.Format("{0}: {1} == {2}", message, value1, value2);
                throw new UnexpectedTestResultException(message);
            }
        }

        /// <summary>
        /// Indicates that value1 and value2 are expected to be equal.
        /// </summary>
        /// <typeparam name="T">A generic type. This type must implement IEquatable[T] interface</typeparam>
        /// <param name="value1">The first value.</param>
        /// <param name="value2">The second value.</param>
        /// <param name="message">A message displayed to the test runner when this assertion fails.</param>
        public void AssertEqual<T>(T value1, T value2, string message) where T : IEquatable<T>
        {
            if (!value1.Equals(value2))
            {
                if (message == null)
                    message = "Tested values are supposed to be equal.";
                message = String.Format("{0}: {1} != {2}", message, value1, value2);
                throw new UnexpectedTestResultException(message);
            }
        }

        /// <summary>
        /// Indicates that value1 and value2 are expected to reference the same object.
        /// </summary>
        /// <typeparam name="T">A generic type. This type must be Object or a subclass of Object</typeparam>
        /// <param name="value1">The first value.</param>
        /// <param name="value2">The second value.</param>
        /// <param name="message">A message displayed to the test runner when this assertion fails.</param>
        public void AssertReferencesEqual<T>(T a, T b, string message)
        {
            if (!object.ReferenceEquals(a, b))
            {
                if (message == null)
                    message = "Tested values are supposed to have equal references.";
                throw new UnexpectedTestResultException(message);
            }
        }

        /// <summary>
        /// Indicates that value1 and value2 are expected to reference different objects.
        /// </summary>
        /// <typeparam name="T">A generic type. This type must be Object or a subclass of Object</typeparam>
        /// <param name="value1">The first value.</param>
        /// <param name="value2">The second value.</param>
        /// <param name="message">A message displayed to the test runner when this assertion fails.</param>
        public void AssertReferencesNotEqual<T>(T a, T b, string message)
        {
            if (object.ReferenceEquals(a, b))
            {
                if (message == null)
                    message = "Tested values are supposed to have different references.";
                throw new UnexpectedTestResultException(message);
            }
        }

        /// <summary>
        /// Indicates that the reference o is not allowed to be null.
        /// </summary>
        /// <param name="o">The reference to test for null</param>
        /// <param name="message">A message displayed to the test runner when this assertion fails.</param>
        public void AssertNotNull(object o, string message)
        {
            if (o == null)
                throw new UnexpectedTestResultException(message); ;
        }

        /// <summary>
        /// Indicates that the reference o must be null.
        /// </summary>
        /// <param name="o">The reference to test for null</param>
        /// <param name="message">A message displayed to the test runner when this assertion fails.</param>
        public void AssertNull(object o, string message)
        {
            if (o != null)
                throw new UnexpectedTestResultException(message); ;
        }

        /// <summary>
        /// Indicates that the value passed in should be true
        /// </summary>
        /// <param name="checkValue">Value to check for true</param>
        /// <param name="message">A message displayed to the test runner when this assertion fails.</param>
        public void AssertTrue(bool checkValue, string message)
        {
            AssertEqual<bool>(true, checkValue, message);
        }

        #endregion

    }

    [TestGroup, Owner("emzephir"), TestFrequency("Daily"), EnvRequirement(""), TestCasePriority(1)]
    public partial class XmlObjectModel : SelfOrganizingTestGroup
    {
        [TestGroup]
        public class Parsers : SelfOrganizingTestGroup
        {
            [TestCase]
            public class AllocateOneParser : DeploymentLanguageTestNode
            {
                public override void Run()
                {
                    LanguageParser parser = new LanguageParser();

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class AllocateTwoParsers : DeploymentLanguageTestNode
            {
                public override void Run()
                {
                    LanguageParser parser = new LanguageParser();
                    LanguageParser parser2 = new LanguageParser();

                    return TEST_RESULTS.PASSED;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\test\SelfOrganizingTestGroup.cs ===
using ServerTestFramework;
using System.Reflection;
using System.IO;

/// <summary>
/// Helps automatically build a path for arranging Test Cases. Test files are in directories that match
/// the ones used to create the tests.
/// 
/// To use this class, create a new subclass.
/// 
/// This class does not support usage from multiple threads nor re-entrancy.
/// </summary>
public abstract class SelfOrganizingTestGroup : TestNode
{
    /// <summary>
    /// The original path. Null if this is the first group to run.
    /// </summary>
    string _originalPath;

    /// <summary>
    /// Returns the path where the group's testcases should be retrieved from.
    /// </summary>
    public static string TestDataPath { get; private set; }

    /// <summary>
    /// Appends a directory onto a stack.
    /// This function is called by STF automatically.
    /// </summary>
    public override void PreRun()
    {
        base.PreRun();

        _originalPath = TestDataPath;

        // start looking in the suites folder, plus our own folder.
        if (_originalPath == null)
        {
            TestDataPath = Path.Combine(Path.GetDirectoryName(Assembly.GetEntryAssembly().Location),
                string.Format("SuitesData\\{0}", Assembly.GetExecutingAssembly().GetName().Name));
        }

        TestDataPath = Path.Combine(TestDataPath, GetType().Name);
    }

    /// <summary>
    /// Puts the original path back.
    /// This function is called by STF automatically.
    /// </summary>
    public override void PostRun()
    {
        TestDataPath = _originalPath;

        base.PostRun();
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\test\UnitTests\DependencyCheckUnitTests.cs ===
﻿using ServerTestFramework;
using System.Linq;
using xonline.tools.deploymentlanguage.Language;
using xonline.tools.deploymentlanguage.Intermediate;
using System.Collections.Generic;

namespace xonline.tools.deploymentlanguage.test.DeploymentLanguageUnitTests
{
    partial class UnitTestsGroup
    {
        [TestGroup]
        public class DependencyCheckUnitTests : SelfOrganizingTestGroup
        {
            [TestCase]
            public class ComponentLoopTest : ProcessorsUnitTestNode
            {
                public override void Run()
                {
                    CreateComponent("LoopComponentA").AddDependsOn("LoopComponentB");
                    CreateComponent("LoopComponentB").AddDependsOn("LoopComponentC");
                    CreateComponent("LoopComponentC").AddDependsOn("LoopComponentA");

                    Process();

                    AssertEqual<int>(ErrorCollection.Count, 1, "Error count should be 1");
                    AssertEqual<int>((int)ErrorCollection[0].ErrorId, (int)ErrorId.DependencyLoop, "Error should be dependency loop");

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class ComponentLoopWithInstallStepTest : ProcessorsUnitTestNode
            {
                public override void Run()
                {
                    CreateComponent("LoopComponentA").AddInstall("LoopA");
                    CreateInstallStep("LoopA").AddDependsOn("LoopComponentB");
                    CreateComponent("LoopComponentB").AddDependsOn("LoopComponentC");
                    CreateComponent("LoopComponentC").AddDependsOn("LoopComponentA");

                    Process();

                    AssertEqual<int>(ErrorCollection.Count, 1, "Error count should be 1");
                    AssertEqual<int>((int)ErrorCollection[0].ErrorId, (int)ErrorId.DependencyLoop, "Error should be dependency loop");

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class InstallStepReferencedLoopTest : ProcessorsUnitTestNode
            {
                public override void Run()
                {
                    CreateComponent("LoopComponentA").AddInstall("LoopA");

                    CreateInstallStep("LoopA").AddInstall("LoopB");
                    CreateInstallStep("LoopB").AddInstall("LoopC");
                    CreateInstallStep("LoopC").AddInstall("LoopA");

                    Process();

                    AssertEqual<int>(ErrorCollection.Count, 1, "Error count should be 1");
                    AssertEqual<int>((int)ErrorCollection[0].ErrorId, (int)ErrorId.InstallStepLoop, "Error should be install step loop");

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class InstallStepNotReferencedLoopTest : ProcessorsUnitTestNode
            {
                public override void Run()
                {
                    CreateInstallStep("LoopA").AddInstall("LoopB");
                    CreateInstallStep("LoopB").AddInstall("LoopC");
                    CreateInstallStep("LoopC").AddInstall("LoopA");

                    Process();

                    AssertEqual<int>(ErrorCollection.Count, 1, "Error count should be 1");
                    AssertEqual<int>((int)ErrorCollection[0].ErrorId, (int)ErrorId.InstallStepLoop, "Error should be install step loop");

                    return TEST_RESULTS.PASSED;
                }
            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\test\UnitTests\DeploymentPhaseUnitTests.cs ===
﻿using ServerTestFramework;
using System.Linq;
using xonline.tools.deploymentlanguage.Language;
using xonline.tools.deploymentlanguage.Intermediate;
using xonline.tools.deploymentlanguage.Octopus;

namespace xonline.tools.deploymentlanguage.test.DeploymentLanguageUnitTests
{
    partial class UnitTestsGroup
    {
        [TestGroup]
        public class DeploymentPhaseUnitTests : SelfOrganizingTestGroup
        {
            [TestCase]
            public class NoDefaultDeploymentPhaseTest : ProcessorsUnitTestNode
            {
                public override void Run()
                {
                    CreateDeploymentPhase("Main", false);
                    CreateDeploymentPhase("DeploymentPhase", false);

                    Process();

                    AssertEqual<int>(ErrorCollection.Count, 1, "Should have 1 error");
                    AssertEqual<int>((int)ErrorCollection[0].ErrorId, (int)ErrorId.NoDefaultDeploymentPhaseDefined, "Error should be NoDefaultDeploymentPhaseDefined.");

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class MultipleDefaultDeploymentPhaseTest : ProcessorsUnitTestNode
            {
                public override void Run()
                {
                    CreateDeploymentPhase("Main", true);
                    CreateDeploymentPhase("DeploymentPhase", true);

                    Process();

                    AssertEqual<int>(ErrorCollection.Count, 1, "Should have 1 error");
                    AssertEqual<int>((int)ErrorCollection[0].ErrorId, (int)ErrorId.MultipleDefaultDeploymentPhaseDefined, "Error should be MultipleDefaultDeploymentPhaseDefined.");

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class ComponentInDefinedPhaseTest : ProcessorsUnitTestNode
            {
                public override void Run()
                {
                    CreateDeploymentPhase("Main");
                    CreateDeploymentPhase("Other", false);

                    var mainComponent = CreateComponent("TestComponentInMain");
                    var otherComponent = CreateComponent("TestComponentInOther");
                    otherComponent.DeploymentPhase = "Other";

                    Process();

                    AssertEqual<int>(ErrorCollection.Count, 0, "Should have no error");
                    AssertEqual<int>(Definition.DeploymentPhases["Main"].Components.Count, 1, "Main deployment phase should have 1 component");
                    AssertTrue(Definition.DeploymentPhases["Main"].Components.ContainsKey("TestComponentInMain"), "Component in main");
                    AssertEqual<int>(Definition.DeploymentPhases["Other"].Components.Count, 1, "Other deployment phase should have 1 component");
                    AssertTrue(Definition.DeploymentPhases["Other"].Components.ContainsKey("TestComponentInOther"), "Component in other");
                    
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class DuplicateDeploymentPhaseNameTest : ProcessorsUnitTestNode
            {
                public override void Run()
                {
                    CreateDeploymentPhase("Main");
                    CreateDeploymentPhase("Other", false);
                    CreateDeploymentPhase("Other", false);

                    Process();

                    AssertEqual<int>(ErrorCollection.Count, 1, "Should have one error");
                    AssertEqual<int>((int)ErrorCollection[0].ErrorId, (int)ErrorId.DuplicateDeploymentPhaseName, "Error should be DuplicateDeploymentPhaseName");

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class InvalidDeploymentPhaseNameTest : ProcessorsUnitTestNode
            {
                public override void Run()
                {
                    CreateDeploymentPhase("Main");
                    CreateDeploymentPhase("Other\\Other", false);

                    Process();

                    AssertEqual<int>(ErrorCollection.Count, 1, "Should have one error");
                    AssertEqual<int>((int)ErrorCollection[0].ErrorId, (int)ErrorId.InvalidDeploymentPhaseNameCharacters, "Error should be InvalidDeploymentPhaseNameCharacters");

                    return TEST_RESULTS.PASSED;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\test\UnitTests\CollectionUnitTests.cs ===
﻿using ServerTestFramework;
using System.Linq;
using xonline.tools.deploymentlanguage.Language;

namespace xonline.tools.deploymentlanguage.test.DeploymentLanguageUnitTests
{
    partial class XmlObjectModel
    {
        [TestGroup]
        public class CollectionUnitTests : SelfOrganizingTestGroup
        {
            public class CollectionUnitTestNode : DeploymentLanguageTestNode
            {
                public override void PreRun()
                {
                    base.PreRun();

                    Definition = new Definition();
                    LanguageDefinition = new LanguageDefinition();
                    ErrorCollection = new LanguageErrors();
                }

                public override void PostRun()
                {
                    Definition = null;
                    LanguageDefinition = null;
                    ErrorCollection = null;

                    base.PostRun();
                }

                protected void Process()
                {
                    ILanguageParser parser = new LanguageParser();
                    parser.ParseDirectory(TestDataPath, LanguageDefinition, ErrorCollection);

                    IProcessor processCollection = new ProcessCollections();
                    processCollection.Process(LanguageDefinition, Definition, ErrorCollection);
                }

                protected LanguageErrors ErrorCollection { get; private set; }
                protected LanguageDefinition LanguageDefinition { get; private set; }
                protected Definition Definition { get; private set; }
            }

            [TestCase, Owner("kenyip"), TestFrequency("Regression"), EnvRequirement("Manual")]
            public class ComponentTest : CollectionUnitTestNode
            {
                public override void Run()
                {
                    Process();

                    AssertEqual<string>(Definition.Components["TestComponent1"].Name, "TestComponent1", "Component name");

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase, Owner("kenyip"), TestFrequency("Regression"), EnvRequirement("Manual")]
            public class InstallStepTest : CollectionUnitTestNode
            {
                public override void Run()
                {
                    Process();

                    AssertEqual<string>(Definition.InstallStepComponents["InstallStep1"].Name, "InstallStep1", "Install Step name");

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase, Owner("kenyip"), TestFrequency("Regression"), EnvRequirement("Manual")]
            public class DuplicateComponentTest : CollectionUnitTestNode
            {
                public override void Run()
                {
                    Process();

                    AssertEqual<int>((int)ErrorCollection[0].ErrorId, (int)ErrorId.DuplicateReleaseComponentName, "Duplicate Component name error");

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase, Owner("kenyip"), TestFrequency("Regression"), EnvRequirement("Manual")]
            public class DuplicateInstallStepTest : CollectionUnitTestNode
            {
                public override void Run()
                {
                    Process();

                    AssertEqual<int>((int)ErrorCollection[0].ErrorId, (int)ErrorId.DuplicateInstallStepName, "Duplicate Install Step name error");

                    return TEST_RESULTS.PASSED;
                }
            }
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\test\UnitTests\ParserUnitTests.cs ===
﻿using ServerTestFramework;
using System.Linq;
using xonline.tools.deploymentlanguage.Language;

namespace xonline.tools.deploymentlanguage.test.DeploymentLanguageUnitTests
{
    partial class XmlObjectModel
    {
        [TestGroup]
        public class ParserUnitTests : SelfOrganizingTestGroup
        {
            [TestCase, Owner("kenyip"), TestFrequency("Regression"), EnvRequirement("Manual")]
            public class GeneralDirectoryXmlElementCountTest : StringTestNode
            {
                public override void Run()
                {
                    AddFile("components.xml", "<components><component name='TestComponent1'></component><component name='TestComponent2'></component><component name='TestComponent3'></component></components>");
                    AddFile("deploymentPhases.xml", "<deploymentPhases><deploymentPhase name='Phase1'></deploymentPhase><deploymentPhase name='Phase2'></deploymentPhase><deploymentPhase name='Phase3'></deploymentPhase></deploymentPhases>");
                    AddFile("installSteps.xml", "<installSteps><installStep name='InstallComponent1'></installStep><installStep name='InstallComponent2'></installStep></installSteps>");
                    AddFile("releases.xml", "<releases><release name='XSR'></release></releases>");
                    AddFile("properties.xml", "<properties><property name='PROPERTY1'></property></properties>");
                    ParseDirectory();

                    AssertEqual<int>(3, LanguageDefinition.Components.Count, "Number of components");
                    AssertEqual<int>(3, LanguageDefinition.DeploymentPhases.Count, "Number of deployment phases");
                    AssertEqual<int>(2, LanguageDefinition.InstallSteps.Count, "Number of install steps");
                    AssertEqual<int>(1, LanguageDefinition.Properties.Count, "Number of properties");
                    AssertEqual<int>(1, LanguageDefinition.Releases.Count, "Number of releases");

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase, Owner("kenyip"), TestFrequency("Regression"), EnvRequirement("Manual")]
            public class ComponentValuesTest : DeploymentLanguageTestNode
            {
                public override void Run()
                {
                    LanguageErrors errors = new LanguageErrors();
                    ILanguageParser parser = new LanguageParser();

                    LanguageDefinition languageDefinition = new LanguageDefinition();

                    parser.ParseDirectory(TestDataPath, languageDefinition, errors);

                    // Component names
                    AssertEqual<string>("Test Component 1", languageDefinition.Components[0].Name, "Name of component 1");
                    AssertEqual<string>("Test Component 2", languageDefinition.Components[1].Name, "Name of component 2");
                    AssertEqual<string>("Test Component 3", languageDefinition.Components[2].Name, "Name of component 3");

                    // Component 1
                    AssertEqual<string>("Component 1 Property", languageDefinition.Components[0].PropertyList[0].Name, "Name of component 1 property");
                    AssertEqual<string>("<userInput prompt=\"Component 1 Property prompt\" help=\"Component 1 Property help\" default=\"default\" />", languageDefinition.Components[0].PropertyList[0].UserInput.OuterXml, "Name of component 1 property UserInput");
                    AssertEqual<string>("Test Component 2", languageDefinition.Components[0].DependsOnList[0].ComponentName, "Name of component 1 dependsOn");
                    AssertEqual<string>("msi", languageDefinition.Components[0].InstallElementList[0].Name, "Name of component 1 runMsi Name");
                    AssertEqual<string>("msipath.msi", ((RunMsi)languageDefinition.Components[0].InstallElementList[0]).Msi.Path, "Name of component 1 runMsi Path");

                    // Component 2
                    AssertEqual<string>(@"<prerequisiteChecks><checkService help=""The SQL Service Agent (SqlServerAgent) must be started."" name=""SqlServerAgent"" startup=""ignore"" status=""started"" /></prerequisiteChecks>",
                        languageDefinition.Components[1].PrerequisiteChecks.OuterXml.Trim(), "PrerequisiteCheck for component 2");
                    AssertEqual<string>("Install Step 2", languageDefinition.Components[1].InstallElementList[0].Name, "Install Step 2 in Component 2");
                    AssertEqual<string>("P1", ((Install)languageDefinition.Components[1].InstallElementList[0]).PassProperty[0].Name, "Install Step 2 in Component 2 property 1 Name");
                    AssertEqual<string>("V1", ((Install)languageDefinition.Components[1].InstallElementList[0]).PassProperty[0].Value, "Install Step 2 in Component 2 property 1 Value");
                    AssertEqual<string>("P2", ((Install)languageDefinition.Components[1].InstallElementList[0]).PassProperty[1].Name, "Install Step 2 in Component 2 property 2 Name");
                    AssertEqual<string>("V2", ((Install)languageDefinition.Components[1].InstallElementList[0]).PassProperty[1].Value, "Install Step 2 in Component 2 property 2 Value");

                    // Component 3
                    AssertEqual<string>("Command", ((RunCommand)languageDefinition.Components[2].InstallElementList[0]).Name, "RunCommand in Component 3 Name");
                    AssertEqual<string>("file1.cmd", ((RunCommand)languageDefinition.Components[2].InstallElementList[0]).InstallCommand.InputFiles.FileList[0].SourcePath, "RunCommand in Component 3 input file 1");
                    AssertEqual<string>("file2.cmd", ((RunCommand)languageDefinition.Components[2].InstallElementList[0]).InstallCommand.InputFiles.FileList[1].SourcePath, "RunCommand in Component 3 input file 2");
                    AssertEqual<string>("Install", ((RunCommand)languageDefinition.Components[2].InstallElementList[0]).InstallCommand.Name, "RunCommand in Component 3 Install Command Name");
                    AssertEqual<string>("echo install command", ((RunCommand)languageDefinition.Components[2].InstallElementList[0]).InstallCommand.Command, "RunCommand in Component 3 Install Command");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase, Owner("kenyip"), TestFrequency("Regression"), EnvRequirement("Manual")]
            public class ComponentInstallElementOrderTest : XmlObjectModelTestNode
            {
                public override void Run()
                {
                    ParseDirectory();
                    AssertEqual<int>(LanguageDefinition.Components.Count, 1, "");
                    AssertEqual<int>(LanguageDefinition.Components[0].InstallElementList.Length, 4, "");
                    AssertEqual(LanguageDefinition.Components[0].InstallElementList[0].Name, "Install Step 2", "");
                    AssertEqual(LanguageDefinition.Components[0].InstallElementList[1].Name, "msi", "");
                    AssertEqual(LanguageDefinition.Components[0].InstallElementList[2].Name, "Command", "");
                    AssertEqual(LanguageDefinition.Components[0].InstallElementList[3].Name, "Install Step 1", "");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase, Owner("kenyip"), TestFrequency("Regression"), EnvRequirement("Manual")]
            public class UnknownElementTest : XmlObjectModelTestNode
            {
                public override void Run()
                {
                    ParseDirectory();
                    AssertEqual<int>(ErrorCollection.Count, 1, "Error Count should be 1");
                    AssertEqual<int>((int)ErrorCollection[0].ErrorId, (int)ErrorId.ParserValidationError, "Error should be ParserValidationError");
                    return TEST_RESULTS.PASSED;
                }
            }
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\test\UnitTests\DuplicateComponentUnitTests.cs ===
﻿using ServerTestFramework;
using System.Linq;
using xonline.tools.deploymentlanguage.Language;
using xonline.tools.deploymentlanguage.Intermediate;
using System.Collections.Generic;
using xonline.tools.deploymentlanguage.Octopus;

namespace xonline.tools.deploymentlanguage.test.DeploymentLanguageUnitTests
{
    partial class UnitTestsGroup
    {
        [TestGroup]
        public class DuplicateComponentUnitTests : SelfOrganizingTestGroup
        {
            [TestCase]
            public class InstallStepNoRunOnceTest : ProcessorsUnitTestNode
            {
                public override void Run()
                {
                    var component = CreateComponent("ComponentA");
                    component.AddInstall("InstallStepA");
                    component.AddInstall("InstallStepA");

                    var installStep = CreateInstallStep("InstallStepA");

                    Process();

                    var resultComponent = Definition.Components["ComponentA"];

                    AssertEqual<int>(resultComponent.InstallComponents.Count, 2, "There should be 2 install steps from ComponentA");

                    AssertReferencesNotEqual<IInstallComponent>(
                        resultComponent.InstallComponents[0].InstallComponent,
                        resultComponent.InstallComponents[1].InstallComponent,
                        "Install Steps should be of different objects");

                    AssertReferencesNotEqual<OctopusComponent>(
                        resultComponent.InstallComponents[0].InstallComponent.Octopus,
                        resultComponent.InstallComponents[1].InstallComponent.Octopus,
                        "Octopus Components should be of different objects");

                    AssertEqual<int>(resultComponent.InstallComponents[0].InstallComponent.ParentComponents.Count, 1, "Cloned install step 0 should only have 1 parent");
                    AssertEqual<int>(resultComponent.InstallComponents[1].InstallComponent.ParentComponents.Count, 1, "Cloned install step 1 should only have 1 parent");
                    
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class InstallStepNoRunOnceWithActionTest : ProcessorsUnitTestNode
            {
                public override void Run()
                {
                    var component = CreateComponent("ComponentA");
                    component.AddInstall("InstallStepA");
                    component.AddInstall("InstallStepA");

                    var installStep = CreateInstallStep("InstallStepA");
                    installStep.AddRunMsi("msi");

                    Process();

                    var resultComponent = Definition.Components["ComponentA"];

                    AssertEqual<int>(resultComponent.InstallComponents.Count, 2, "There should be 2 install steps from ComponentA");

                    AssertReferencesNotEqual<IInstallComponent>(
                        resultComponent.InstallComponents[0].InstallComponent,
                        resultComponent.InstallComponents[1].InstallComponent,
                        "Install Steps should be of different objects");

                    AssertReferencesNotEqual<OctopusComponent>(
                        resultComponent.InstallComponents[0].InstallComponent.Octopus,
                        resultComponent.InstallComponents[1].InstallComponent.Octopus,
                        "Octopus Components should be of different objects");

                    AssertEqual<int>(resultComponent.InstallComponents[0].InstallComponent.ParentComponents.Count, 1, "Cloned install step 0 should only have 1 parent");
                    AssertEqual<int>(resultComponent.InstallComponents[1].InstallComponent.ParentComponents.Count, 1, "Cloned install step 1 should only have 1 parent");

                    var installRelationship1 = ((InstallStepComponent)resultComponent.InstallComponents[0].InstallComponent).InstallComponents;
                    var installRelationship2 = ((InstallStepComponent)resultComponent.InstallComponents[1].InstallComponent).InstallComponents;

                    AssertReferencesNotEqual<IInstallComponent>(
                       installRelationship1[0].InstallComponent,
                       installRelationship2[0].InstallComponent,
                       "Install Step msi should be of different objects");

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class InstallStepNoRunOnceWithInstallStepNoRunOnceTest : ProcessorsUnitTestNode
            {
                public override void Run()
                {
                    var component = CreateComponent("ComponentA");
                    component.AddInstall("InstallStepA");
                    component.AddInstall("InstallStepA");

                    var installStepA = CreateInstallStep("InstallStepA");
                    installStepA.AddInstall("InstallStepB");

                    var installStepB = CreateInstallStep("InstallStepB");

                    Process();

                    var resultComponent = Definition.Components["ComponentA"];

                    AssertEqual<int>(resultComponent.InstallComponents.Count, 2, "There should be 2 install steps from ComponentA");

                    AssertReferencesNotEqual<IInstallComponent>(
                        resultComponent.InstallComponents[0].InstallComponent,
                        resultComponent.InstallComponents[1].InstallComponent,
                        "Install Steps should be of different objects");

                    AssertReferencesNotEqual<OctopusComponent>(
                        resultComponent.InstallComponents[0].InstallComponent.Octopus,
                        resultComponent.InstallComponents[1].InstallComponent.Octopus,
                        "Octopus Components should be of different objects");

                    AssertEqual<int>(resultComponent.InstallComponents[0].InstallComponent.ParentComponents.Count, 1, "Cloned install step 0 should only have 1 parent");
                    AssertEqual<int>(resultComponent.InstallComponents[1].InstallComponent.ParentComponents.Count, 1, "Cloned install step 1 should only have 1 parent");

                    var installRelationship1 = ((InstallStepComponent)resultComponent.InstallComponents[0].InstallComponent).InstallComponents;
                    var installRelationship2 = ((InstallStepComponent)resultComponent.InstallComponents[1].InstallComponent).InstallComponents;

                    AssertReferencesNotEqual<IInstallComponent>(
                       installRelationship1[0].InstallComponent,
                       installRelationship2[0].InstallComponent,
                       "Install Step's install step should be of different objects");

                    return TEST_RESULTS.PASSED;
                }
            }


            [TestCase]
            public class InstallStepNoRunOnceWithInstallStepRunOnceTest : ProcessorsUnitTestNode
            {
                public override void Run()
                {
                    var component = CreateComponent("ComponentA");
                    component.AddInstall("InstallStepA");
                    component.AddInstall("InstallStepA");

                    var installStepA = CreateInstallStep("InstallStepA");
                    installStepA.AddInstall("InstallStepB");

                    var installStepB = CreateInstallStep("InstallStepB");
                    installStepB.RunOnce = true;

                    Process();

                    var resultComponent = Definition.Components["ComponentA"];

                    AssertEqual<int>(resultComponent.InstallComponents.Count, 2, "There should be 2 install steps from ComponentA");

                    AssertReferencesNotEqual<IInstallComponent>(
                        resultComponent.InstallComponents[0].InstallComponent,
                        resultComponent.InstallComponents[1].InstallComponent,
                        "Install Steps should be of different objects");

                    AssertReferencesNotEqual<OctopusComponent>(
                        resultComponent.InstallComponents[0].InstallComponent.Octopus,
                        resultComponent.InstallComponents[1].InstallComponent.Octopus,
                        "Octopus Components should be of different objects");

                    AssertEqual<int>(resultComponent.InstallComponents[0].InstallComponent.ParentComponents.Count, 1, "Cloned install step 0 should only have 1 parent");
                    AssertEqual<int>(resultComponent.InstallComponents[1].InstallComponent.ParentComponents.Count, 1, "Cloned install step 1 should only have 1 parent");

                    var installRelationship1 = ((InstallStepComponent)resultComponent.InstallComponents[0].InstallComponent).InstallComponents;
                    var installRelationship2 = ((InstallStepComponent)resultComponent.InstallComponents[1].InstallComponent).InstallComponents;

                    AssertReferencesEqual<IInstallComponent>(
                       installRelationship1[0].InstallComponent,
                       installRelationship2[0].InstallComponent,
                       "Install Step's install step should be of same objects");

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class InstallStepRunOnceTest : ProcessorsUnitTestNode
            {
                public override void Run()
                {
                    var component = CreateComponent("ComponentA");
                    component.AddInstall("InstallStepA");
                    component.AddInstall("InstallStepA");

                    var installStep = CreateInstallStep("InstallStepA");
                    installStep.RunOnce = true;

                    Process();

                    var resultComponent = Definition.Components["ComponentA"];

                    AssertEqual<int>(resultComponent.InstallComponents.Count, 2, "There should be 2 install steps from ComponentA");

                    AssertReferencesEqual<IInstallComponent>(
                        resultComponent.InstallComponents[0].InstallComponent,
                        resultComponent.InstallComponents[1].InstallComponent,
                        "Install Steps should be of different objects");

                    AssertReferencesEqual<OctopusComponent>(
                        resultComponent.InstallComponents[0].InstallComponent.Octopus,
                        resultComponent.InstallComponents[1].InstallComponent.Octopus,
                        "Octopus Components should be of different objects");

                    AssertEqual<int>(resultComponent.InstallComponents[0].InstallComponent.ParentComponents.Count, 2, "Install step 0 should have 2 parents");
                    AssertEqual<int>(resultComponent.InstallComponents[1].InstallComponent.ParentComponents.Count, 2, "Install step 1 should have 2 parents");
                    
                    return TEST_RESULTS.PASSED;
                }
            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\test\UnitTests\PropertiesUnitTests.cs ===
﻿using ServerTestFramework;
using System.Linq;
using xonline.tools.deploymentlanguage.Language;
using xonline.tools.deploymentlanguage.Intermediate;
using System.Collections.Generic;

namespace xonline.tools.deploymentlanguage.test.DeploymentLanguageUnitTests
{
    partial class UnitTestsGroup
    {
        [TestGroup]
        public class PropertiesUnitTests : SelfOrganizingTestGroup
        {
            [TestCase]
            public class ActionPassPropertyTest : ProcessorsUnitTestNode
            {
                public override void Run()
                {
                    var component = CreateComponent("ComponentName");
                    var install = component.AddInstall("InstallStep");
                    install.AddPassProperty("Property1");

                    var installStep = CreateInstallStep("InstallStep");
                    installStep.PropertyList = new LanguageProperty[1];
                    installStep.PropertyList[0] = new LanguageProperty();
                    installStep.PropertyList[0].Name = "Property1";
                    installStep.PropertyList[0].Value = "Property1Value";

                    var runMsi = installStep.AddRunMsi("msi");
                    runMsi.PropertyList = new LanguageProperty[1];
                    runMsi.PropertyList[0] = new LanguageProperty();
                    runMsi.PropertyList[0].Name = "Property1";

                    Process();

                    AssertEqual<int>(ErrorCollection.Count, 0, "Error count should be 0");

                    var resultInstallStep = Definition.InstallStepComponents["InstallStep"];
                    AssertEqual<int>(resultInstallStep.InstallComponents[0].PassProperties.Count, 1, "PassProperty should have one value");
                    AssertEqual<string>(resultInstallStep.InstallComponents[0].PassProperties["Property1"], "[Property1]", "Property value should be inherited from install step");

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class ActionGlobalPropertyTest : ProcessorsUnitTestNode
            {
                public override void Run()
                {
                    CreateProperty("GlobalProperty1");

                    var component = CreateComponent("ComponentName");
                    var install = component.AddInstall("InstallStep");

                    var installStep = CreateInstallStep("InstallStep");
                    
                    var runMsi = installStep.AddRunMsi("msi");
                    runMsi.PropertyList = new LanguageProperty[1];
                    runMsi.PropertyList[0] = new LanguageProperty();
                    runMsi.PropertyList[0].Name = "GlobalProperty1";

                    Process();

                    AssertEqual<int>(ErrorCollection.Count, 0, "Error count should be 0");

                    var resultComponent = Definition.Components["ComponentName"];
                    var resultInstallStep = resultComponent.InstallComponents[0].InstallComponent as InstallStepComponent;
                    var resultRunMsi = resultInstallStep.InstallComponents[0].InstallComponent;

                    AssertEqual<int>(resultRunMsi.Octopus.PropertyList.Count, 1, "PropertyList should have one value");
                    AssertEqual<string>(resultRunMsi.Octopus.PropertyList["GlobalProperty1"].Value, "[GlobalProperty1]", "Property value should be from global");

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class ActionPropertyUndefinedTest : ProcessorsUnitTestNode
            {
                public override void Run()
                {
                    var component = CreateComponent("ComponentName");
                    var install = component.AddInstall("InstallStep");

                    var installStep = CreateInstallStep("InstallStep");
                    installStep.PropertyList = new LanguageProperty[1];
                    installStep.PropertyList[0] = new LanguageProperty();
                    installStep.PropertyList[0].Name = "GlobalProperty1";

                    var runMsi = installStep.AddRunMsi("msi");

                    Process();

                    AssertEqual<int>(ErrorCollection.Count, 1, "Error count should be 1");
                    AssertEqual<int>((int)ErrorCollection[0].ErrorId, (int)ErrorId.UnresolvedPropertyGlobalOrParent, "Error should be UnresolvedPropertyGlobalOrParent");

                    return TEST_RESULTS.PASSED;
                }
            }
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\test\UnitTests\ReleaseUnitTests.cs ===
﻿using ServerTestFramework;
using System.Linq;
using xonline.tools.deploymentlanguage.Language;
using xonline.tools.deploymentlanguage.Intermediate;
using xonline.tools.deploymentlanguage.Octopus;

namespace xonline.tools.deploymentlanguage.test.DeploymentLanguageUnitTests
{
    partial class UnitTestsGroup
    {
        [TestGroup]
        public class ReleaseUnitTests : SelfOrganizingTestGroup
        {
            [TestCase]
            public class ReleaseComponentTest : ProcessorsUnitTestNode
            {
                public override void Run()
                {
                    var release = CreateRelease("XSR");
                    release.AddComponent("TestComponent1");

                    CreateComponent("TestComponent1");

                    Process();

                    AssertEqual<int>(Definition.Releases.Count, 1, "Number of releases should be 1");
                    AssertEqual<string>(Definition.Releases["XSR"].Name, "XSR", "Name of release");
                    AssertEqual<int>(Definition.Releases["XSR"].ReleaseComponents.Count, 1, "Number of components should be 1");
                    AssertEqual<string>(Definition.Releases["XSR"].ReleaseComponents.Single<ReleaseComponent>().Name, "TestComponent1", "Component in release");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class ReleaseComponentNotExistsTest : ProcessorsUnitTestNode
            {
                public override void Run()
                {
                    var release = CreateRelease("XSR");
                    release.AddComponent("TestComponent1");

                    Process();

                    AssertEqual<int>(ErrorCollection.Count, 1, "Should have an error");
                    AssertEqual<int>((int)ErrorCollection[0].ErrorId, (int)ErrorId.ReleaseComponentNotFound, "Error should be ReleaseComponentNotFound");

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class DuplicateReleaseNameTest : ProcessorsUnitTestNode
            {
                public override void Run()
                {
                    CreateComponent("TestComponent1");

                    var release1 = CreateRelease("XSR");
                    release1.AddComponent("TestComponent1");

                    var release2 = CreateRelease("XSR");
                    release2.AddComponent("TestComponent1");

                    Process();

                    AssertEqual<int>(ErrorCollection.Count, 1, "Should have an error");
                    AssertEqual<int>((int)ErrorCollection[0].ErrorId, (int)ErrorId.DuplicateReleaseName, "Error should be DuplicateReleaseName");

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class InvalidReleaseNameTest : ProcessorsUnitTestNode
            {
                public override void Run()
                {
                    CreateComponent("TestComponent1");

                    var release1 = CreateRelease("XSR/XSR");
                    release1.AddComponent("TestComponent1");

                    Process();

                    AssertEqual<int>(ErrorCollection.Count, 1, "Should have an error");
                    AssertEqual<int>((int)ErrorCollection[0].ErrorId, (int)ErrorId.InvalidReleaseNameCharacters, "Error should be InvalidReleaseNameCharacters");

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class EmptyReleaseTest : ProcessorsUnitTestNode
            {
                public override void Run()
                {
                    var release1 = CreateRelease("XSR");

                    Process();

                    AssertEqual<int>(ErrorCollection.Count, 1, "Should have an error");
                    AssertEqual<int>((int)ErrorCollection[0].ErrorId, (int)ErrorId.ReleaseEmpty, "Error should be ReleaseEmpty");

                    return TEST_RESULTS.PASSED;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\test\XmlObjectModel\InstallSteps.cs ===
using ServerTestFramework;
using System.Linq;
using xonline.tools.deploymentlanguage.Language;

namespace xonline.tools.deploymentlanguage.test.DeploymentLanguageUnitTests
{
    partial class UnitTestsGroup
    {

        [TestGroup]
        public class InstallSteps : SelfOrganizingTestGroup
        {
            [TestCase]
            public class EmptyInstallStepsNode : StringTestNode
            {
                public override void Run()
                {
                    AddFile("steps.xml", "<installSteps></installSteps>");
                    ParseDirectory();
                    AssertEqual<int>(LanguageDefinition.InstallSteps.Count(), 0, "");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class NoInstallSteps : StringTestNode
            {
                public override void Run()
                {
                    ParseDirectory();
                    AssertEqual<int>(ErrorCollection.Count(), 0, "");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class ExtraAttributesInStep : StringTestNode
            {
                public override void Run()
                {
                    AddFile("steps.xml", "<installSteps><installStep name='foo' attributeThatDoesntExist='42'/></installSteps>");
                    ParseDirectory();
                    AssertEqual<bool>(ErrorCollection.Count() > 0, true, "");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class ExtraTagsInSteps : StringTestNode
            {
                public override void Run()
                {
                    AddFile("steps.xml", "<installSteps><someTagThatDoesntBelong/></installSteps>");
                    ParseDirectory();
                    AssertEqual<bool>(ErrorCollection.Count() > 0, true, "");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class ExtraTagsInStep : StringTestNode
            {
                public override void Run()
                {
                    AddFile("steps.xml", "<installSteps><installStep><someTagThatDoesntBelong/></installStep></installSteps>");
                    ParseDirectory();
                    AssertEqual<bool>(ErrorCollection.Count() > 0, true, "");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class ExtraAttributesInSteps : StringTestNode
            {
                public override void Run()
                {
                    AddFile("steps.xml", "<installSteps attributeThatDoesntExist='42'/>");
                    ParseDirectory();
                    AssertEqual<bool>(ErrorCollection.Count() > 0, true, "");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class ArraysExistWithZeroCount : StringTestNode
            {
                public override void Run()
                {
                    AddFile("steps.xml", "<installSteps><installStep name='foo'/></installSteps>");
                    ParseDirectory();

                    InstallStep installStep = LanguageDefinition.InstallSteps[0];
                    AssertNotNull(installStep.DependsOnList, "");
                    AssertEqual<int>(installStep.DependsOnList.Count(), 0, "");

                    AssertNotNull(installStep.PropertyList, "");
                    AssertEqual<int>(installStep.PropertyList.Count(), 0, "");

                    AssertNull(installStep.PostDeploymentChecks, "");
                    AssertNull(installStep.PrerequisiteChecks, "");

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class OneInstallStep : StringTestNode
            {
                public override void Run()
                {
                    AddFile("steps.xml", "<installSteps><installStep name='foo'/></installSteps>");
                    ParseDirectory();
                    AssertEqual<int>(LanguageDefinition.InstallSteps.Count(), 1, "");
                    AssertEqual(LanguageDefinition.InstallSteps[0].Name, "foo", "");
                    AssertEqual(LanguageDefinition.InstallSteps[0].FileName, GetPathForFile("steps.xml"), "");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class MultipleInstallSteps : StringTestNode
            {
                public override void Run()
                {
                    AddFile("steps.xml", "<installSteps><installStep name='foo'/><installStep name='bar'/>"+
                        "</installSteps>");
                    ParseDirectory();
                    AssertEqual<int>(LanguageDefinition.InstallSteps.Count(), 2, "");
                    InstallStep fooStep = LanguageDefinition.InstallSteps.Where(x => x.Name == "foo").FirstOrDefault();
                    InstallStep barStep = LanguageDefinition.InstallSteps.Where(x => x.Name == "bar").FirstOrDefault();

                    AssertNotNull(fooStep, "");
                    AssertNotNull(barStep, "");

                    AssertEqual(fooStep.FileName, GetPathForFile("steps.xml"), "");
                    AssertEqual(barStep.FileName, GetPathForFile("steps.xml"), "");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class MergedInstallSteps : StringTestNode
            {
                public override void Run()
                {
                    AddFile("foo_steps.xml", "<installSteps><installStep name='foo'/></installSteps>");
                    AddFile("bar_steps.xml", "<installSteps><installStep name='bar'/></installSteps>");
                    ParseDirectory();
                    AssertEqual<int>(LanguageDefinition.InstallSteps.Count(), 2, "");
                    InstallStep fooStep = LanguageDefinition.InstallSteps.Where(x => x.Name == "foo").FirstOrDefault();
                    InstallStep barStep = LanguageDefinition.InstallSteps.Where(x => x.Name == "bar").FirstOrDefault();

                    AssertNotNull(fooStep, "");
                    AssertNotNull(barStep, "");

                    AssertEqual(fooStep.FileName, GetPathForFile("foo_steps.xml"), "");
                    AssertEqual(barStep.FileName, GetPathForFile("bar_steps.xml"), "");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class AnyElementsAreNull : StringTestNode
            {
                public override void Run()
                {
                    AddFile("steps.xml", "<installSteps><installStep name='foo'/></installSteps>");
                    ParseDirectory();
                    AssertNull(LanguageDefinition.InstallSteps[0].PostDeploymentChecks,"");
                    AssertNull(LanguageDefinition.InstallSteps[0].PrerequisiteChecks, "");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class AcceptsPrerequsiteChecks : StringTestNode
            {
                public override void Run()
                {
                    AddFile("steps.xml", "<installSteps><installStep name='foo'><prerequisiteChecks/></installStep></installSteps>");
                    ParseDirectory();
                    AssertNotNull(LanguageDefinition.InstallSteps[0].PrerequisiteChecks, "");
                    AssertEqual(LanguageDefinition.InstallSteps[0].PrerequisiteChecks.Name, "prerequisiteChecks", "");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class AcceptsPostDeploymentChecks : StringTestNode
            {
                public override void Run()
                {
                    AddFile("steps.xml", "<installSteps><installStep name='foo'><postDeploymentChecks/></installStep></installSteps>");
                    ParseDirectory();
                    AssertNotNull(LanguageDefinition.InstallSteps[0].PostDeploymentChecks, "");
                    AssertEqual(LanguageDefinition.InstallSteps[0].PostDeploymentChecks.Name, "postDeploymentChecks", "");
                    return TEST_RESULTS.PASSED;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\test\XmlObjectModel\LanguageProperty.cs ===
using ServerTestFramework;
using System.Linq;
using xonline.tools.deploymentlanguage.Language;

namespace xonline.tools.deploymentlanguage.test.DeploymentLanguageUnitTests
{
    partial class UnitTestsGroup
    {

        [TestGroup]
        public class LanguageProperties : SelfOrganizingTestGroup
        {
            [TestCase]
            public class SingleInstallStepProperty : StringTestNode
            {
                public override void Run()
                {
                    AddFile("steps.xml", "<installSteps><installStep name='foo'><property /></installStep></installSteps>");
                    ParseDirectory();
                    AssertEqual<int>(LanguageDefinition.InstallSteps[0].PropertyList.Count(), 1, "");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class MultipleInstallStepProperties : StringTestNode
            {
                public override void Run()
                {
                    AddFile("steps.xml", "<installSteps><installStep name='foo'><property />"+
                    "<property /></installStep></installSteps>");
                    ParseDirectory();
                    AssertEqual<int>(LanguageDefinition.InstallSteps[0].PropertyList.Count(), 2, "");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class EmptyPropertiesNode : StringTestNode
            {
                public override void Run()
                {
                    AddFile("steps.xml", "<properties></properties>");
                    ParseDirectory();
                    AssertNotNull(LanguageDefinition.Properties, "");
                    AssertEqual<int>(LanguageDefinition.Properties.Count, 0, "");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class SingleProperty : StringTestNode
            {
                public override void Run()
                {
                    AddFile("steps.xml", "<properties><property /></properties>");
                    ParseDirectory();
                    AssertNotNull(LanguageDefinition.Properties, "");
                    AssertEqual<int>(LanguageDefinition.Properties.Count, 1, "");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class MultipleProperties : StringTestNode
            {
                public override void Run()
                {
                    AddFile("steps.xml", "<properties><property /><property /></properties>");
                    ParseDirectory();
                    AssertNotNull(LanguageDefinition.Properties, "");
                    AssertEqual<int>(LanguageDefinition.Properties.Count, 2, "");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class AttributesTest : StringTestNode
            {
                public override void Run()
                {
                    AddFile("steps.xml", "<properties><property name='foo' value='bar' mergeSeparator=';'/></properties>");
                    ParseDirectory();
                    AssertEqual<int>(LanguageDefinition.Properties.Count, 1, "");
                    AssertEqual(LanguageDefinition.Properties[0].Name, "foo", "");
                    AssertEqual(LanguageDefinition.Properties[0].Value, "bar", "");
                    AssertEqual(LanguageDefinition.Properties[0].MergeSeparator, ";", "");

                    return TEST_RESULTS.PASSED;
                }
            }

            public class AcceptsServerList : StringTestNode
            {
                public override void Run()
                {
                    AddFile("steps.xml", "<properties><property><serverList/></property></properties>");
                    ParseDirectory();
                    AssertEqual<int>(LanguageDefinition.Properties.Count, 1, "");
                    AssertNotNull(LanguageDefinition.Properties[0].ServerList, "");
                    AssertEqual(LanguageDefinition.Properties[0].ServerList.Name, "serverList", "");
                    return TEST_RESULTS.PASSED;
                }
            }

            public class AcceptsUserInput : StringTestNode
            {
                public override void Run()
                {
                    AddFile("steps.xml", "<properties><property><userInput/></property></properties>");
                    ParseDirectory();
                    AssertEqual<int>(LanguageDefinition.Properties.Count, 1, "");
                    AssertNotNull(LanguageDefinition.Properties[0].UserInput, "");
                    AssertEqual(LanguageDefinition.Properties[0].UserInput.Name, "userInput", "");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class NoProperties : StringTestNode
            {
                public override void Run()
                {
                    ParseDirectory();
                    AssertEqual<int>(ErrorCollection.Count(), 0, "");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class ExtraAttributesInProperty : StringTestNode
            {
                public override void Run()
                {
                    AddFile("steps.xml", "<properties><property attributeThatDoesntExist='42'/></properties>");
                    ParseDirectory();
                    AssertEqual<bool>(ErrorCollection.Count() > 0, true, "");
                    return TEST_RESULTS.PASSED;
                }
            }

            public class ExtraTagInProperty : StringTestNode
            {
                public override void Run()
                {
                    AddFile("steps.xml", "<properties><property><someTagThatDoesntBelong/></property></properties>");
                    ParseDirectory();
                    AssertEqual<bool>(ErrorCollection.Count() > 0, true, "");
                    return TEST_RESULTS.PASSED;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\test\UnitTests\ResolveComponentUnitTests.cs ===
﻿using ServerTestFramework;
using System.Linq;
using xonline.tools.deploymentlanguage.Language;
using xonline.tools.deploymentlanguage.Intermediate;
using xonline.tools.deploymentlanguage.Octopus;

namespace xonline.tools.deploymentlanguage.test.DeploymentLanguageUnitTests
{
    partial class UnitTestsGroup
    {
        [TestGroup]
        public class ResolveComponentUnitTests : SelfOrganizingTestGroup
        {
            public class ResolveComponentUnitTestNode : StringTestNode
            {
                public override void PreRun()
                {
                    base.PreRun();

                    Definition = new Definition();
                }

                public override void PostRun()
                {
                    Definition = null;

                    base.PostRun();
                }

                protected void Process()
                {
                    ParseDirectory();

                    IProcessor processCollection = new ProcessCollections();
                    processCollection.Process(LanguageDefinition, Definition, ErrorCollection);

                    IProcessor processResolveComponents = new ProcessResolveComponents();
                    processResolveComponents.Process(LanguageDefinition, Definition, ErrorCollection);
                }

                protected Definition Definition { get; private set; }
            }

            [TestCase]
            public class ComponentActionTest : ProcessorsUnitTestNode
            {
                public override void Run()
                {
                    var component = CreateComponent("TestComponent1");
                    component.AddRunMsi("msi");
                    
                    Process();

                    AssertTrue(Definition.Components["TestComponent1"].InstallComponents[0].InstallComponent is RunMsiComponent, "Install Component should be a RunMsiComponent");

                    var resultComponent = Definition.Components["TestComponent1"].InstallComponents[0].InstallComponent as RunMsiComponent;
                    AssertEqual<string>(resultComponent.OriginalName, "msi", "Msi Component name");

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase, Owner("kenyip"), TestFrequency("Regression"), EnvRequirement("Manual")]
            public class InstallStepActionTest : ProcessorsUnitTestNode
            {
                public override void Run()
                {
                    var installStep1 = CreateInstallStep("TestInstallStep1");
                    var installStep2 = installStep1.AddRunCommand("command");

                    Process();

                    AssertTrue(Definition.InstallStepComponents["TestInstallStep1"].InstallComponents[0].InstallComponent is RunCommandComponent, "Install Component should be a RunCommandComponent");

                    var component = Definition.InstallStepComponents["TestInstallStep1"].InstallComponents[0].InstallComponent as RunCommandComponent;
                    AssertEqual<string>(component.OriginalName, "command", "Command Component name");

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase, Owner("kenyip"), TestFrequency("Regression"), EnvRequirement("Manual")]
            public class ComponentInstallTest : ProcessorsUnitTestNode
            {
                public override void Run()
                {
                    var component = CreateComponent("TestComponent1");
                    component.AddInstall("TestInstallStep1");

                    var installStep = CreateInstallStep("TestInstallStep1");

                    Process();

                    AssertTrue(Definition.Components["TestComponent1"].InstallComponents[0].InstallComponent is InstallStepComponent, "Install Component should be a RunMsiComponent");

                    var resultComponent = Definition.Components["TestComponent1"].InstallComponents[0].InstallComponent as InstallStepComponent;
                    AssertEqual<string>(resultComponent.OriginalName, "TestInstallStep1", "Install Component name");

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase, Owner("kenyip"), TestFrequency("Regression"), EnvRequirement("Manual")]
            public class ComponentInstallPassPropertiesTest : ProcessorsUnitTestNode
            {
                public override void Run()
                {
                    var component = CreateComponent("TestComponent1");
                    component.AddInstall("TestInstallStep1").AddPassProperty("propertyName", "propertyValue");

                    var installStep = CreateInstallStep("TestInstallStep1");
                    installStep.AddProperty("propertyName");

                    Process();

                    AssertTrue(Definition.Components["TestComponent1"].InstallComponents[0].InstallComponent is InstallStepComponent, "Install Component should be a RunMsiComponent");

                    var resultComponent = Definition.Components["TestComponent1"].InstallComponents[0] as InstallRelationship;
                    AssertEqual<string>(resultComponent.InstallComponent.OriginalName, "TestInstallStep1", "Install Component name");
                    AssertEqual<string>(Definition.Components["TestComponent1"].InstallComponents[0].PassProperties["propertyName"], "propertyValue", "PassProperty Name and Value");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase, Owner("kenyip"), TestFrequency("Regression"), EnvRequirement("Manual")]
            public class ComponentMultipleInstallPassPropertiesTest : ProcessorsUnitTestNode
            {
                public override void Run()
                {
                    var component = CreateComponent("TestComponent1");
                    component.AddInstall("TestInstallStep1").AddPassProperty("propertyName", "propertyValue1");
                    component.AddInstall("TestInstallStep1").AddPassProperty("propertyName", "propertyValue2");

                    var installStep = CreateInstallStep("TestInstallStep1");
                    installStep.AddProperty("propertyName");

                    Process();

                    var resultComponent = Definition.Components["TestComponent1"];
                    AssertEqual<int>(resultComponent.InstallComponents.Count, 2, "InstallComponents count should be 2");
                    AssertTrue(resultComponent.InstallComponents[0].InstallComponent is InstallStepComponent, "Install Component should be type InstallStepComponent");

                    var installStep1 = Definition.Components["TestComponent1"].InstallComponents[0] as InstallRelationship;
                    AssertEqual<string>(installStep1.InstallComponent.OriginalName, "TestInstallStep1", "Install Component name");
                    AssertEqual<string>(installStep1.PassProperties["propertyName"], "propertyValue1", "PassProperty1 Name and Value");
                    AssertEqual<string>(installStep1.ParentComponent.Name, "TestComponent1", "Parent component should be TestComponent1");

                    var installStep2 = Definition.Components["TestComponent1"].InstallComponents[1] as InstallRelationship;
                    AssertEqual<string>(installStep2.PassProperties["propertyName"], "propertyValue2", "PassProperty2 Name and Value");
                    AssertEqual<string>(installStep2.ParentComponent.Name, "TestComponent1", "Parent component should be TestComponent1");
                    
                    // Ensure they really are different components
                    //AssertReferencesNotEqual<OctopusComponent>(installStep1.Octopus, installStep2.Octopus, "InstallSteps should not reference the same octopus component");
                    
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase, Owner("kenyip"), TestFrequency("Regression"), EnvRequirement("Manual")]
            public class ComponentMultipleInstallRunOncePassPropertiesTest : ProcessorsUnitTestNode
            {
                public override void Run()
                {
                    var component = CreateComponent("TestComponent1");
                    component.AddInstall("TestInstallStep1").AddPassProperty("propertyName", "propertyValue1");
                    component.AddInstall("TestInstallStep1").AddPassProperty("propertyName", "propertyValue2");

                    var installStep = CreateInstallStep("TestInstallStep1");
                    installStep.AddProperty("propertyName");
                    installStep.RunOnce = true;

                    Process();

                    var resultComponent = Definition.Components["TestComponent1"];
                    AssertEqual<int>(resultComponent.InstallComponents.Count, 2, "InstallComponents count should be 2");
                    AssertTrue(resultComponent.InstallComponents[0].InstallComponent is InstallStepComponent, "Install Component should be type InstallStepComponent");

                    var installStep1 = Definition.Components["TestComponent1"].InstallComponents[0] as InstallRelationship;
                    var installStep2 = Definition.Components["TestComponent1"].InstallComponents[1] as InstallRelationship;

                    // They should be the same install component
                    AssertReferencesEqual<IInstallComponent>(installStep1.InstallComponent, installStep2.InstallComponent, "InstallSteps should not be same reference since there are passProperties");
                    AssertReferencesEqual<OctopusComponent>(installStep1.InstallComponent.Octopus, installStep2.InstallComponent.Octopus, "InstallSteps should have the same octopus component since it should run only once");

                    AssertEqual<string>(installStep1.ParentComponent.Name, "TestComponent1", "installStep1 parent component should be TestComponent1");
                    AssertEqual<string>(installStep1.InstallComponent.OriginalName, "TestInstallStep1", "Install Component name");

                    AssertEqual<string>(installStep2.ParentComponent.Name, "TestComponent1", "installStep2 parent component should be TestComponent1");
                    AssertEqual<string>(installStep2.InstallComponent.OriginalName, "TestInstallStep1", "Install Component name");

                    AssertEqual<string>(installStep1.PassProperties["propertyName"], "propertyValue1", "PassProperty1 Name and Value");
                    AssertEqual<string>(installStep2.PassProperties["propertyName"], "propertyValue2", "PassProperty2 Name and Value");

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase, Owner("kenyip"), TestFrequency("Regression"), EnvRequirement("Manual")]
            public class ComponentMultipleInstallRunOnceNoPassPropertiesTest : ProcessorsUnitTestNode
            {
                public override void Run()
                {
                    var component = CreateComponent("TestComponent1");
                    component.AddInstall("TestInstallStep1");
                    component.AddInstall("TestInstallStep1");

                    var installStep = CreateInstallStep("TestInstallStep1");
                    installStep.AddProperty("propertyName");
                    installStep.RunOnce = true;

                    Process();

                    var resultComponent = Definition.Components["TestComponent1"];
                    AssertEqual<int>(resultComponent.InstallComponents.Count, 2, "InstallComponents count should be 2");
                    AssertTrue(resultComponent.InstallComponents[0].InstallComponent is InstallStepComponent, "Install Component should be type InstallStepComponent");

                    var installStep1 = Definition.Components["TestComponent1"].InstallComponents[0] as InstallRelationship;
                    AssertEqual<string>(installStep1.InstallComponent.OriginalName, "TestInstallStep1", "Install Component name");
                    AssertEqual<string>(installStep1.ParentComponent.Name, "TestComponent1", "Parent component should be TestComponent1");

                    var installStep2 = Definition.Components["TestComponent1"].InstallComponents[1] as InstallRelationship;

                    // Ensure they really are different components
                    AssertReferencesEqual<IInstallComponent>(installStep1.InstallComponent, installStep2.InstallComponent, "InstallSteps should be same reference when RunOnce = true");

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase, Owner("kenyip"), TestFrequency("Regression"), EnvRequirement("Manual")]
            public class ComponentInstallNotFoundTest : ProcessorsUnitTestNode
            {
                public override void Run()
                {
                    var component = CreateComponent("TestComponent1");
                    component.AddInstall("TestInstallStep1");

                    Process();

                    AssertEqual<int>(ErrorCollection.Count, 1, "Should have 1 error");
                    AssertEqual<int>((int)ErrorCollection[0].ErrorId, (int)ErrorId.InstallComponentNotFound, "Error should be InstallComponentNotFound");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase, Owner("kenyip"), TestFrequency("Regression"), EnvRequirement("Manual")]
            public class InstallStepInstallNotFoundTest : ProcessorsUnitTestNode
            {
                public override void Run()
                {
                    var installStep = CreateInstallStep("TestInstallStep1").AddInstall("TestInstallStep2");

                    Process();

                    AssertEqual<int>(ErrorCollection.Count, 1, "Should have 1 error");
                    AssertEqual<int>((int)ErrorCollection[0].ErrorId, (int)ErrorId.InstallComponentNotFound, "Error should be InstallComponentNotFound");
                    return TEST_RESULTS.PASSED;
                }
            }
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\test\UnitTests\UnitTestsGroup.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using System.Runtime.Serialization;
using System.IO;
using System.Xml;

using xonline.tools.deploymentlanguage;
using xonline.tools.deploymentlanguage.Language;

namespace xonline.tools.deploymentlanguage.test.DeploymentLanguageUnitTests
{
    [TestGroup, Owner("kenyip"), TestFrequency("Daily"), EnvRequirement(""), TestCasePriority(1)]
    public partial class UnitTestsGroup : SelfOrganizingTestGroup
	{
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\test\XmlObjectModel\Releases.cs ===
using ServerTestFramework;
using System.Linq;
using xonline.tools.deploymentlanguage.Language;


namespace xonline.tools.deploymentlanguage.test.DeploymentLanguageUnitTests
{
    partial class XmlObjectModel
    {

        [TestGroup]
        public class Releases : TestNode
        {
            [TestCase]
            public class NoReleases : StringTestNode
            {
                public override void Run()
                {
                    ParseDirectory();
                    AssertEqual<int>(LanguageDefinition.Releases.Count, 0, "");
                    return TEST_RESULTS.PASSED;
                }
            }


            // XBCS # 134269
            [TestCase]
            public class EmptyReleasesNode : StringTestNode
            {
                public override void Run()
                {
                    AddFile("releases.xml", "<releases></releases>");
                    ParseDirectory();
                    AssertEqual<int>(LanguageDefinition.Releases.Count, 0, "");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class ReleaseName : StringTestNode
            {
                public override void Run()
                {
                    AddFile("releases.xml", "<releases><release name='foo'/></releases>");
                    ParseDirectory();
                    AssertEqual<int>(LanguageDefinition.Releases.Count, 1, "");
                    AssertEqual(LanguageDefinition.Releases[0].Name, "foo", "");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class ReleaseFileName : StringTestNode
            {
                public override void Run()
                {
                    AddFile("releases.xml", "<releases><release name='foo'/></releases>");
                    ParseDirectory();
                    AssertEqual(LanguageDefinition.Releases[0].FileName, GetPathForFile("releases.xml"), "");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class MultipleReleases : StringTestNode
            {
                public override void Run()
                {
                    AddFile("releases.xml", "<releases><release name='foo'/><release name='bar'/></releases>");
                    ParseDirectory();
                    AssertEqual<int>(LanguageDefinition.Releases.Count, 2, "");

                    LanguageRelease fooRelease = LanguageDefinition.Releases.Where(x => x.Name == "foo").FirstOrDefault();
                    LanguageRelease barRelease = LanguageDefinition.Releases.Where(x => x.Name == "bar").FirstOrDefault();
                    AssertNotNull(fooRelease, "");
                    AssertNotNull(barRelease, "");
                    AssertEqual(fooRelease.FileName, GetPathForFile("releases.xml"), "");
                    AssertEqual(barRelease.FileName, GetPathForFile("releases.xml"), "");

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class MergedReleases : StringTestNode
            {
                public override void Run()
                {
                    AddFile("release_foo.xml", "<releases><release name='foo'/></releases>");
                    AddFile("release_bar.xml", "<releases><release name='bar'/></releases>");
                    ParseDirectory();
                    AssertEqual<int>(LanguageDefinition.Releases.Count, 2, "");

                    LanguageRelease fooRelease = LanguageDefinition.Releases.Where(x => x.Name == "foo").FirstOrDefault();
                    LanguageRelease barRelease = LanguageDefinition.Releases.Where(x => x.Name == "bar").FirstOrDefault();
                    AssertNotNull(fooRelease, "");
                    AssertNotNull(barRelease, "");
                    AssertEqual(fooRelease.FileName, GetPathForFile("release_foo.xml"), "");
                    AssertEqual(barRelease.FileName, GetPathForFile("release_bar.xml"), "");

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class SingleComponentRef : StringTestNode
            {
                public override void Run()
                {
                    AddFile("release.xml", "<releases><release name='foo'><componentRef name='bar'/></release>" +
                        "</releases>");
                    ParseDirectory();
                    AssertEqual<int>(LanguageDefinition.Releases[0].ComponentList.Length, 1, "");
                    AssertEqual(LanguageDefinition.Releases[0].ComponentList[0].Name, "bar", "");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class MultipleComponentRefs : StringTestNode
            {
                public override void Run()
                {
                    AddFile("release.xml", "<releases><release name='foo'><componentRef name='bar'/>" +
                        "<componentRef name='baz'/></release></releases>");
                    ParseDirectory();
                    AssertEqual<int>(LanguageDefinition.Releases[0].ComponentList.Length, 2, "");
                    AssertEqual<int>(LanguageDefinition.Releases[0].ComponentList.Where(x => x.Name == "bar").Count(), 1, "");
                    AssertEqual<int>(LanguageDefinition.Releases[0].ComponentList.Where(x => x.Name == "baz").Count(), 1, "");
                    return TEST_RESULTS.PASSED;
                }
            }

            //XBCS 134281
            [TestCase]
            public class NoComponentRefs : StringTestNode
            {
                public override void Run()
                {
                    AddFile("releases.xml", "<releases><release name='foo'/></releases>");
                    ParseDirectory();
                    AssertNotNull(LanguageDefinition.Releases[0].ComponentList, "");
                    AssertEqual<int>(LanguageDefinition.Releases[0].ComponentList.Length, 0, "");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class MissingComponentRefName : StringTestNode
            {
                public override void Run()
                {
                    AddFile("releases.xml", "<releases><release name='foo'/><componentRef/></releases>");
                    ParseDirectory();
                    AssertEqual<bool>(ErrorCollection.Count > 0, true, "");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class ExtraTagsInRelease : StringTestNode
            {
                public override void Run()
                {
                    AddFile("releases.xml", "<releases><release name='foo'><someTagThatDoesntBelong/></release>" +
                        "</releases>");
                    ParseDirectory();
                    AssertEqual<bool>(ErrorCollection.Count > 0, true, "");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class ExtraAttributesInRelease : StringTestNode
            {
                public override void Run()
                {
                    AddFile("releases.xml", "<releases><release name='foo' attributeThatDoesntExist='42'/></releases>");
                    ParseDirectory();
                    AssertEqual<bool>(ErrorCollection.Count > 0, true, "");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class ExtraTagsInReleases : StringTestNode
            {
                public override void Run()
                {
                    AddFile("releases.xml", "<releases><someTagThatDoesntBelong/></releases>");
                    ParseDirectory();
                    AssertEqual<bool>(ErrorCollection.Count > 0, true, "");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class ExtraAttributesInReleases : StringTestNode
            {
                public override void Run()
                {
                    AddFile("releases.xml", "<releases attributeThatDoesntExist='42'/>");
                    ParseDirectory();
                    AssertEqual<bool>(ErrorCollection.Count > 0, true, "");
                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class NoErrorsInCorrectDocument : StringTestNode
            {
                public override void Run()
                {
                    AddFile("release.xml", "<releases><release name='foo'><componentRef name='bar'/></release>" +
                        "</releases>");
                    ParseDirectory();
                    AssertEqual<int>(ErrorCollection.Count, 0, "");
                    return TEST_RESULTS.PASSED;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\test\UnitTests\ValidationUnitTests.cs ===
﻿using ServerTestFramework;
using System.Linq;
using xonline.tools.deploymentlanguage.Language;
using xonline.tools.deploymentlanguage.Intermediate;
using xonline.tools.deploymentlanguage.Octopus;

namespace xonline.tools.deploymentlanguage.test.DeploymentLanguageUnitTests
{
    partial class UnitTestsGroup
    {
        [TestGroup]
        public class ValidationUnitTests : SelfOrganizingTestGroup
        {
            [TestCase]
            public class RequiredFieldComponentNameTest : StringTestNode
            {
                public override void Run()
                {
                    AddFile("components.xml",
                        "<components><component></component></components>");

                    ParseDirectory();

                    AssertTrue(ErrorCollection.Count > 0, "Component Name required");
                    AssertEqual<int>((int)ErrorCollection[0].ErrorId, (int)ErrorId.ParserValidationError, "Should be ParserValidationError");

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class InvalidAttributeTest : StringTestNode
            {
                public override void Run()
                {
                    AddFile("components.xml",
                        "<components><component name='TestComponent' extraField='value'></component></components>");

                    ParseDirectory();

                    AssertTrue(ErrorCollection.Count > 0, "Invalid attribute should fail");
                    AssertEqual<int>((int)ErrorCollection[0].ErrorId, (int)ErrorId.ParserValidationError, "Should be ParserValidationError");

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class InvalidElementTest : StringTestNode
            {
                public override void Run()
                {
                    AddFile("components.xml",
                        "<components><installStep name='TestComponent'></installStep></components>");

                    ParseDirectory();

                    AssertTrue(ErrorCollection.Count > 0, "Invalid element should fail");
                    AssertEqual<int>((int)ErrorCollection[0].ErrorId, (int)ErrorId.ParserValidationError, "Should be ParserValidationError");

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class ExtraAttributeTest : StringTestNode
            {
                public override void Run()
                {
                    AddFile("components.xml",
                        "<components><component name='TestComponent' name='TestComponent'></component></components>");

                    ParseDirectory();

                    AssertTrue(ErrorCollection.Count > 0, "Extra attribute should fail");
                    AssertEqual<int>((int)ErrorCollection[0].ErrorId, (int)ErrorId.ParserFailedToReadXml, "Should be ParserFailedToReadXml");

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class ExtraElementTest : StringTestNode
            {
                public override void Run()
                {
                    AddFile("components.xml",
                        "<components><component name='TestComponent'><runCommand><installCommand cmd='command.exe' /><installCommand cmd='command2.exe' /></runCommand></component></components>");

                    ParseDirectory();

                    AssertTrue(ErrorCollection.Count > 0, "Extra element should fail");
                    AssertEqual<int>((int)ErrorCollection[0].ErrorId, (int)ErrorId.ParserExtraElement, "Should be ParserExtraElement");
                    
                    return TEST_RESULTS.PASSED;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\test\UnitTests\UniqueNamesUnitTests.cs ===
﻿using ServerTestFramework;
using System.Linq;
using xonline.tools.deploymentlanguage.Language;
using xonline.tools.deploymentlanguage.Intermediate;
using System.Collections.Generic;

namespace xonline.tools.deploymentlanguage.test.DeploymentLanguageUnitTests
{
    partial class UnitTestsGroup
    {
        [TestGroup]
        public class UniqueNamesUnitTests : SelfOrganizingTestGroup
        {
            [TestCase]
            public class DuplicateComponentNameTest : ProcessorsUnitTestNode
            {
                public override void Run()
                {
                    CreateComponent("DuplicateName");
                    CreateComponent("DuplicateName");

                    Process();

                    AssertEqual<int>(ErrorCollection.Count, 1, "Error count should be 1");
                    AssertEqual<int>((int)ErrorCollection[0].ErrorId, (int)ErrorId.DuplicateReleaseComponentName, "Error should be DuplicateReleaseComponentName");

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class DuplicateInstallStepNameTest : ProcessorsUnitTestNode
            {
                public override void Run()
                {
                    CreateInstallStep("DuplicateName");
                    CreateInstallStep("DuplicateName");

                    Process();

                    AssertEqual<int>(ErrorCollection.Count, 1, "Error count should be 1");
                    AssertEqual<int>((int)ErrorCollection[0].ErrorId, (int)ErrorId.DuplicateInstallStepName, "Error should be DuplicateInstallStepName");

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class SameComponentInstallStepNameTest : ProcessorsUnitTestNode
            {
                public override void Run()
                {
                    CreateComponent("InstallStepName").AddInstall("InstallStepName");
                    CreateInstallStep("InstallStepName");

                    Process();

                    AssertEqual<int>(ErrorCollection.Count, 0, "There should be no errors");
                    AssertEqual<string>(Definition.Components["InstallStepName"].Name, "InstallStepName", "Component name should be the same");
                    AssertEqual<string>(Definition.Components["InstallStepName"].InstallComponents[0].InstallComponent.Name, "InstallStepName InstallStepName", "Install step name should be combined with component name");

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class CollidingComponentInstallStepNameTest : ProcessorsUnitTestNode
            {
                public override void Run()
                {
                    CreateComponent("InstallStepName InstallStepName");

                    CreateComponent("InstallStepName").AddInstall("InstallStepName");
                    CreateInstallStep("InstallStepName");

                    Process();

                    AssertEqual<int>(ErrorCollection.Count, 0, "There should be no errors");
                    AssertEqual<string>(Definition.Components["InstallStepName InstallStepName"].Name, "InstallStepName InstallStepName", "Component name should be the same");
                    AssertEqual<string>(Definition.Components["InstallStepName"].InstallComponents[0].InstallComponent.Name, "InstallStepName InstallStepName 2", "Install step name should be combined with component name");

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class CombinedComponentActionNameTest : ProcessorsUnitTestNode
            {
                public override void Run()
                {
                    var component = CreateComponent("ComponentName").AddRunMsi("MsiName");

                    Process();

                    var resultComponent = Definition.Components["ComponentName"];
                    var resultMsi = resultComponent.InstallComponents[0].InstallComponent as RunMsiComponent;

                    AssertEqual<int>(ErrorCollection.Count, 0, "There should be no errors");
                    AssertEqual<string>(Definition.Components["ComponentName"].Name, "ComponentName", "Component name should be the same");
                    AssertEqual<string>(resultMsi.Name, "ComponentName MsiName", "Action component name should be combined with the component name");

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class CollidingComponentActionNameTest : ProcessorsUnitTestNode
            {
                public override void Run()
                {
                    CreateComponent("ComponentName MsiName");

                    var component = CreateComponent("ComponentName").AddRunMsi("MsiName");

                    Process();

                    var resultComponent = Definition.Components["ComponentName"];
                    var resultMsi = resultComponent.InstallComponents[0].InstallComponent as RunMsiComponent;

                    AssertEqual<int>(ErrorCollection.Count, 0, "There should be no errors");
                    AssertEqual<string>(Definition.Components["ComponentName MsiName"].Name, "ComponentName MsiName", "Component name should be the same");
                    AssertEqual<string>(Definition.Components["ComponentName"].Name, "ComponentName", "Component name should be the same");
                    AssertEqual<string>(resultMsi.Name, "ComponentName MsiName 2", "Action component name should be combined with the component name + 1");

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class CombinedInstallStepActionNameTest : ProcessorsUnitTestNode
            {
                public override void Run()
                {
                    CreateComponent("ComponentName").AddInstall("InstallStepName");
                    var installStep = CreateInstallStep("InstallStepName").AddRunMsi("MsiName");

                    Process();

                    AssertEqual<int>(ErrorCollection.Count, 0, "There should be no errors");

                    var resultComponent = Definition.Components["ComponentName"];
                    var resultInstallStep = resultComponent.InstallComponents[0].InstallComponent as InstallStepComponent;

                    AssertEqual<string>(resultInstallStep.Name, "ComponentName InstallStepName", "InstallStep name should be the same");
                    AssertEqual<string>(resultInstallStep.InstallComponents[0].InstallComponent.Name, "ComponentName MsiName", "Action component name should be combined with the install step name");

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class CollidingComponentInstallStepActionNameTest : ProcessorsUnitTestNode
            {
                public override void Run()
                {
                    CreateComponent("ComponentName MsiName");

                    CreateComponent("ComponentName").AddInstall("InstallStepName");

                    var installStep = CreateInstallStep("InstallStepName").AddRunMsi("MsiName");

                    Process();

                    AssertEqual<int>(ErrorCollection.Count, 0, "There should be no errors");

                    var resultComponent = Definition.Components["ComponentName"];
                    var resultInstallStep = resultComponent.InstallComponents[0].InstallComponent as InstallStepComponent;

                    AssertEqual<string>(Definition.Components["ComponentName MsiName"].Name, "ComponentName MsiName", "Component name should be the same");
                    AssertEqual<string>(resultInstallStep.Name, "ComponentName InstallStepName", "InstallStep name should be the same");
                    AssertEqual<string>(resultInstallStep.InstallComponents[0].InstallComponent.Name, "ComponentName MsiName 2", "Action component name should be combined with the install step name + 1");

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class CollidingComponentActionName2Test : ProcessorsUnitTestNode
            {
                public override void Run()
                {
                    CreateComponent("ComponentName MsiName");
                    CreateComponent("ComponentName MsiName 2");

                    var component = CreateComponent("ComponentName").AddRunMsi("MsiName");

                    Process();

                    var resultComponent = Definition.Components["ComponentName"];
                    var resultMsi = resultComponent.InstallComponents[0].InstallComponent as RunMsiComponent;

                    AssertEqual<int>(ErrorCollection.Count, 0, "There should be no errors");
                    AssertEqual<string>(Definition.Components["ComponentName MsiName"].Name, "ComponentName MsiName", "Component name should be the same");
                    AssertEqual<string>(Definition.Components["ComponentName MsiName 2"].Name, "ComponentName MsiName 2", "Component name should be the same");
                    AssertEqual<string>(Definition.Components["ComponentName"].Name, "ComponentName", "Component name should be the same");
                    AssertEqual<string>(resultMsi.Name, "ComponentName MsiName 3", "Action component name should be combined with the component name + 1");

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase]
            public class InstallStepRunOnceNameTest : ProcessorsUnitTestNode
            {
                public override void Run()
                {
                    CreateComponent("ComponentName").AddInstall("InstallStep");

                    var installStep = CreateInstallStep("InstallStep");
                    installStep.RunOnce = true;

                    Process();

                    var resultComponent = Definition.Components["ComponentName"];
                    var resultInstallStep = resultComponent.InstallComponents[0].InstallComponent as InstallStepComponent;

                    AssertEqual<int>(ErrorCollection.Count, 0, "There should be no errors");
                    AssertEqual<string>(Definition.Components["ComponentName"].Name, "ComponentName", "Component name should be the same");
                    AssertEqual<string>(resultInstallStep.Name, "InstallStep", "Install step name should be the same");

                    return TEST_RESULTS.PASSED;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\MsiLoggingUtil\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\test\XmlObjectModel\ProcessorsUnitTestNode.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using System.Runtime.Serialization;
using System.IO;
using System.Xml;

using xonline.tools.deploymentlanguage;
using xonline.tools.deploymentlanguage.Language;
using System.Text.RegularExpressions;

namespace xonline.tools.deploymentlanguage.test.DeploymentLanguageUnitTests
{
    public static class ExtentionMethods
    {
        private static T[] ResizeArray<T>(T[] array)
        {
            Array.Resize<T>(ref array, array.Length + 1);
            return array;
        }

        public static Install AddInstall(this LanguageComponent component, string name)
        {
            component.InstallElementList = ResizeArray<InstallElement>(component.InstallElementList);

            var install = CreateInstall(name);
            component.InstallElementList[component.InstallElementList.Length - 1] = install;

            return install;
        }

        public static DependsOn AddDependsOn(this LanguageComponent component, string name)
        {
            component.DependsOnList = ResizeArray<DependsOn>(component.DependsOnList);

            var dependsOn = new DependsOn();
            dependsOn.ComponentName = name;

            component.DependsOnList[component.DependsOnList.Length - 1] = dependsOn;

            return dependsOn;
        }

        public static RunMsi AddRunMsi(this LanguageComponent component, string name)
        {
            component.InstallElementList = ResizeArray<InstallElement>(component.InstallElementList);

            var runMsi = CreateRunMsi(name);
            component.InstallElementList[component.InstallElementList.Length - 1] = runMsi;

            return runMsi;
        }

        public static RunCommand AddRunCommand(this LanguageComponent component, string name)
        {
            component.InstallElementList = ResizeArray<InstallElement>(component.InstallElementList);
            
            var runCommand = CreateRunCommand(name);
            component.InstallElementList[component.InstallElementList.Length - 1] = runCommand;

            return runCommand;
        }

        public static LanguageProperty AddProperty(this LanguageComponent component, string name)
        {
            return AddProperty(component, name);
        }

        public static LanguageProperty AddProperty(this LanguageComponent component, string name, string value)
        {
            component.PropertyList = ResizeArray<LanguageProperty>(component.PropertyList);

            var property = CreateProperty(name, value);
            component.PropertyList[component.PropertyList.Length - 1] = property;

            return property;
        }

        public static Install AddInstall(this InstallStep installStep, string name)
        {
            installStep.InstallElementList = ResizeArray<InstallElement>(installStep.InstallElementList);

            var install = CreateInstall(name);
            installStep.InstallElementList[installStep.InstallElementList.Length - 1] = install;

            return install;
        }

        public static DependsOn AddDependsOn(this InstallStep installStep, string name)
        {
            installStep.DependsOnList = ResizeArray<DependsOn>(installStep.DependsOnList);

            var dependsOn = new DependsOn();
            dependsOn.ComponentName = name;

            installStep.DependsOnList[installStep.DependsOnList.Length - 1] = dependsOn;

            return dependsOn;
        }

        public static RunMsi AddRunMsi(this InstallStep installStep, string name)
        {
            installStep.InstallElementList = ResizeArray<InstallElement>(installStep.InstallElementList);

            var runMsi = CreateRunMsi(name);
            installStep.InstallElementList[installStep.InstallElementList.Length - 1] = runMsi;

            return runMsi;
        }

        public static RunCommand AddRunCommand(this InstallStep installStep, string name)
        {
            installStep.InstallElementList = ResizeArray<InstallElement>(installStep.InstallElementList);

            var runCommand = CreateRunCommand(name);
            installStep.InstallElementList[installStep.InstallElementList.Length - 1] = runCommand;

            return runCommand;
        }

        public static LanguageProperty AddProperty(this InstallStep installStep, string name)
        {
            return AddProperty(installStep, name, null);
        }

        public static LanguageProperty AddProperty(this InstallStep installStep, string name, string value)
        {
            installStep.PropertyList = ResizeArray<LanguageProperty>(installStep.PropertyList);

            var property = CreateProperty(name, value);
            installStep.PropertyList[installStep.PropertyList.Length - 1] = property;

            return property;
        }

        public static PassProperty AddPassProperty(this Install install, string name)
        {
            return AddPassProperty(install, name, null);
        }

        public static PassProperty AddPassProperty(this Install install, string name, string value)
        {
            install.PassProperty = ResizeArray<PassProperty>(install.PassProperty);

            var property = CreatePassProperty(name, value);
            install.PassProperty[install.PassProperty.Length - 1] = property;

            return property;
        }

        #region Releases

        public static void AddComponent(this LanguageRelease release, string componentName)
        {
            release.ComponentList = ResizeArray<ComponentRef>(release.ComponentList);
            release.ComponentList[release.ComponentList.Length - 1] = new ComponentRef();
            release.ComponentList[release.ComponentList.Length - 1].Name = componentName;
        }

        #endregion

        private static Install CreateInstall(string stepName, params string[] properties)
        {
            var install = new Install();
            install.CreateEmptyListsOnNulls();
            install.StepName = stepName;

            if (properties != null)
            {
                install.PassProperty = new PassProperty[properties.Length];

                for (int i = 0; i < properties.Length; i++)
                {
                    install.PassProperty[i] = new PassProperty();
                    install.PassProperty[i].Name = properties[i];
                    install.PassProperty[i].Value = properties[i] + "Value";
                }
            }

            return install;
        }

        #region Action Components

        private static RunMsi CreateRunMsi(string name)
        {
            var runMsi = new RunMsi();
            runMsi.RunMsiName = name;
            runMsi.Msi = new Msi();
            runMsi.Msi.Path = name + ".msi";

            runMsi.CreateEmptyListsOnNulls();

            return runMsi;
        }

        private static RunCommand CreateRunCommand(string name)
        {
            var runCommand = new RunCommand();
            runCommand.RunCommandName = name;

            runCommand.CreateEmptyListsOnNulls();

            return runCommand;
        }

        #endregion

        #region Properties

        private static LanguageProperty CreateProperty(string name, string value)
        {
            var property = new LanguageProperty();

            property.Name = name;
            if (value != null)
            {
                property.Value = value;
            }
            property.CreateEmptyListsOnNulls();

            return property;
        }

        private static PassProperty CreatePassProperty(string name, string value)
        {
            var property = new PassProperty();

            property.Name = name;
            if (value != null)
            {
                property.Value = value;
            }
            property.CreateEmptyListsOnNulls();

            return property;
        }

        #endregion
    }

    public abstract class ProcessorsUnitTestNode : DeploymentLanguageTestNode
    {
        /// <summary>
        /// The language definition for this test run.
        /// </summary>
        protected LanguageDefinition LanguageDefinition { get; private set; }

        /// <summary>
        /// The results of using this parser on the directory pointed to by TestDataPath.
        /// </summary>
        protected Definition Definition { get; private set; }

        /// <summary>
        /// The errors collection from running the process.
        /// </summary>
        protected LanguageErrors ErrorCollection { get; private set; }

        protected void Process()
        {
            foreach (var preprocessor in Engine.DefaultPreprocessors)
            {
                if (ErrorCollection.Count > 0)
                {
                    return;
                }

                preprocessor.Process(LanguageDefinition, Definition, ErrorCollection);
            }

            foreach (var processor in Engine.DefaultProcessors)
            {
                if (ErrorCollection.Count > 0)
                {
                    break;
                }

                processor.Process(LanguageDefinition, Definition, ErrorCollection);
            }
        }

        public override void PreRun()
        {
            base.PreRun();

            // this technically isn't a fixture, but it runs over and over again.

            LanguageDefinition = new LanguageDefinition();
            Definition = new Definition();
            ErrorCollection = new LanguageErrors();
        }

        public override void PostRun()
        {
            // don't leak memory
            LanguageDefinition = null;
            Definition = null;
            ErrorCollection = null;
            base.PostRun();
        }

        #region Definition Helper

        protected LanguageDeploymentPhase CreateDeploymentPhase(string name)
        {
            return CreateDeploymentPhase(name, true);
        }

        protected LanguageDeploymentPhase CreateDeploymentPhase(string name, bool defaultPhase)
        {
            var languageDeploymentPhase = new LanguageDeploymentPhase();
            languageDeploymentPhase.CreateEmptyListsOnNulls();

            languageDeploymentPhase.Name = name;
            languageDeploymentPhase.Default = defaultPhase;

            LanguageDefinition.DeploymentPhases.Add(languageDeploymentPhase);

            return languageDeploymentPhase;
        }

        protected LanguageComponent CreateComponent(string name)
        {
            var languageComponent = new LanguageComponent();
            languageComponent.CreateEmptyListsOnNulls();

            LanguageDefinition.Components.Add(languageComponent);

            languageComponent.FileName = name + ".xml";
            languageComponent.Name = name;

            return languageComponent;
        }

        protected InstallStep CreateInstallStep(string name)
        {
            var installStep = new InstallStep();
            installStep.CreateEmptyListsOnNulls();
            LanguageDefinition.InstallSteps.Add(installStep);

            installStep.FileName = name + ".xml";
            installStep.Name = name;

            return installStep;
        }

        protected LanguageRelease CreateRelease(string name)
        {
            var release = new LanguageRelease();
            release.CreateEmptyListsOnNulls();

            release.Name = name;
            release.FileName = name + ".xml";

            LanguageDefinition.Releases.Add(release);

            return release;
        }

        protected LanguageProperty CreateProperty(string name)
        {
            var property = new LanguageProperty();
            property.CreateEmptyListsOnNulls();

            property.Name = name;

            LanguageDefinition.Properties.Add(property);

            return property;
        }

        protected LanguageProperty CreateProperty(string name, string value)
        {
            var property = CreateProperty(name);
            property.Value = value;

            return property;
        }

        #endregion
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\MsiLoggingUtil\MsiLoggingUtil.cpp ===
#include "MsiLoggingUtil.h"

HINSTANCE g_hInstance;

BOOLEAN WINAPI DllMain(HINSTANCE hDllHandle, DWORD nReason, LPVOID Reserved) {
   g_hInstance = hDllHandle;

   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\MsiLoggingUtil\EspMsiLoggingDirectory.cpp ===
#include "MsiLoggingUtil.h"

VOID _CreateDirectory(LPCTSTR szDirectory) {
   WCHAR wszDirectory[MAX_PATH] = {0};
   LPCWSTR wszPointer;

   if (sizeof(TCHAR) == sizeof(CHAR)) {
      if (!MultiByteToWideChar(CP_ACP, 0, (LPCSTR)szDirectory, -1, wszDirectory, ARRAYSIZE(wszDirectory)))
         return;

      wszPointer = (LPCWSTR)wszDirectory;
   }
   else
      wszPointer = (LPCWSTR)szDirectory;

   SHCreateDirectory(NULL, wszPointer);
}

VOID _CreateLoggingDirectory(MSIHANDLE hInstall, LPCTSTR szProperty) {
   TCHAR    szDirectory[MAX_PATH] = {0};
   UINT     uResult;

   uResult = GetProperty(hInstall, szProperty, szDirectory, ARRAYSIZE(szDirectory));
   if (ERROR_SUCCESS == uResult)
      _CreateDirectory(szDirectory);
}

VOID _CreateLoggingDirectories(MSIHANDLE hInstall) {
   _CreateLoggingDirectory(hInstall, TEXT("LOGGING_DIRECTORY_DEFAULT"));
   _CreateLoggingDirectory(hInstall, TEXT("LOGGING_DIRECTORY_WIDGETS"));
   _CreateLoggingDirectory(hInstall, TEXT("LOGGING_DIRECTORY_FRONTDOOR"));
   _CreateLoggingDirectory(hInstall, TEXT("LOGGING_DIRECTORY_INH"));
}

UINT _ReplacePath(LPTSTR szNewLoggingLocation, UINT cchNewLoggingLocation, LPCTSTR szDirectory, LPCTSTR szDatabaseRoot, LPCTSTR szBinaryLocation) {
   TCHAR szDatabasePath[MAX_PATH] = { 0 };
   UINT cchBinaryLocation = 0;
   UINT uReturn = ERROR_SUCCESS;

   _tcscpy_s(szNewLoggingLocation, cchNewLoggingLocation, szDirectory);
   
   cchBinaryLocation = _tcslen(szBinaryLocation);

   if (!_tcsnicmp(szDatabaseRoot, szBinaryLocation, cchBinaryLocation)) {
      LPTSTR szEndLocation;
      LPTSTR szStartLocation;

      _tcscpy_s(szDatabasePath, ARRAYSIZE(szDatabasePath), szDatabaseRoot);

      szStartLocation = szDatabasePath + cchBinaryLocation + 1;
      szEndLocation = _tcsrchr(szStartLocation, TEXT('\\'));

      if (szEndLocation > szStartLocation) {
         szEndLocation[0] = 0;
         if (_tcslen(szDirectory) + _tcslen(szStartLocation) + 2 > cchNewLoggingLocation) {
            uReturn = ERROR_BAD_PATHNAME;
            return uReturn;
         }

         
         if (szNewLoggingLocation[_tcslen(szNewLoggingLocation)-1] != TEXT('\\'))
            _tcscat_s(szNewLoggingLocation, cchNewLoggingLocation, TEXT("\\"));
         
         _tcscat_s(szNewLoggingLocation, cchNewLoggingLocation, szStartLocation);
      }
   }

   return uReturn;
}

MSIEXPORT EspMsiLoggingDirectory(MSIHANDLE hInstall) {
   TCHAR    szNewLoggingLocation[MAX_PATH] = {0};
   LPTSTR   szDirectory = NULL;
   TCHAR    szEnvironmentPath[MAX_PATH] = {0};
   LPTSTR   szDatabasePath = NULL;
   LPTSTR   szBinaryLocation = NULL;
   UINT     uResult = ERROR_SUCCESS;
   UINT     cchBinaryLocation;
   size_t   cchEnvironment;

   __try {
      uResult = GetProperty(hInstall, TEXT("OriginalDatabase"), &szDatabasePath);
      if (ERROR_SUCCESS != uResult)
         __leave;

      uResult = GetProperty(hInstall, TEXT("BINARY_LOCATION"), &szBinaryLocation, TRUE);
      if (ERROR_SUCCESS != uResult || (0 == (cchBinaryLocation = _tcslen(szBinaryLocation))))
         __leave;

      uResult = GetProperty(hInstall, TEXT("LOGGING_DIRECTORY_DEFAULT"), &szDirectory, TRUE);
      if (ERROR_SUCCESS != uResult || !_tcslen(szDirectory))
         __leave;

      uResult = _ReplacePath(szNewLoggingLocation, ARRAYSIZE(szNewLoggingLocation), szDirectory, szDatabasePath, szBinaryLocation);
      if (ERROR_SUCCESS != uResult)
         __leave;

      uResult = SetProperty(hInstall, TEXT("LOGGING_DIRECTORY_DEFAULT"), szNewLoggingLocation);
      if (ERROR_SUCCESS != uResult)
         __leave;

      _tgetenv_s(&cchEnvironment, szEnvironmentPath, ARRAYSIZE(szEnvironmentPath), TEXT("octopus.log.currentrelease.folder"));
      if (0 == cchEnvironment)
         __leave;

      uResult = _ReplacePath(szNewLoggingLocation, ARRAYSIZE(szNewLoggingLocation), szEnvironmentPath, szDatabasePath, szBinaryLocation);
      if (ERROR_SUCCESS != uResult)
         __leave;

      _tputenv_s(TEXT("octopus.log.currentrelease.folder"), szNewLoggingLocation);
   }
   __finally {
      SAFE_DELETE_A(szDirectory);
      SAFE_DELETE_A(szDatabasePath);
      SAFE_DELETE_A(szBinaryLocation);
   }

   _CreateLoggingDirectories(hInstall);

   return uResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\MsiLoggingUtil\CreateInstallUtilProperties.cpp ===
#include "MsiLoggingUtil.h"

UINT _GetParameter(LPTSTR szParameters, LPCTSTR szParameter, LPTSTR* szValue) {
   LPTSTR szFound;

   *szValue = NULL;

   szFound = _tcsstr(szParameters, szParameter);
   if (szFound) {
      LPTSTR szStart;
      LPTSTR szEnd;
      TCHAR chStop = TEXT('/');

      szStart = szFound + _tcslen(szParameter);
      while (szStart[0] && isspace(szStart[0]))
         szStart++;

      szEnd = szStart;
      while (szEnd[0]) {
         if (szEnd[0] == chStop && szEnd[1] == chStop)
            szEnd++;
         else if (szEnd[0] == chStop)
            break;

         szEnd++;
      }

      szEnd--;
      while (szEnd > szStart && isspace(szEnd[0]))
         szEnd--;

      // (1+(szEnd-szStart)) casted to a uint to make the 64-bit compiler happy. 
      if (NULL == (*szValue = StringCopy(szStart, (UINT)(1 + (szEnd - szStart)) )))
         return ERROR_OUTOFMEMORY;

      return ERROR_SUCCESS;
   }

   return ERROR_NOT_FOUND;
}

void _SayValue(LPCTSTR szValue, LPCTSTR szName) {
   TCHAR Debug[1024];
   _stprintf_s(Debug, ARRAYSIZE(Debug), TEXT("%s = '%s'"), szName, szValue);
   MessageBox(NULL, Debug, szName, MB_OK);
}

BOOL _ParseParameters(MSIHANDLE hInstall, LPTSTR szParameters, LPTSTR* pszInstDirectory, LPTSTR* pszInstInstall, LPTSTR* pszInstUinstall, LPTSTR* pszInstBinary) {
   UINT uResult;
   
   uResult = _GetParameter(szParameters, TEXT("/directory="), pszInstDirectory);
   if (ERROR_SUCCESS != uResult) {
      SetErrorProperty(hInstall, IDS_GETPROPERTY_DIRECTORY, uResult);
      return FALSE;
   }

   uResult = _GetParameter(szParameters, TEXT("/install="), pszInstInstall);
   if (ERROR_SUCCESS != uResult && ERROR_NOT_FOUND != uResult) {
      SetErrorProperty(hInstall, IDS_GETPROPERTY_INSTALL_LOG, uResult);
      return FALSE;
   }

   uResult = _GetParameter(szParameters, TEXT("/uninstall="), pszInstUinstall);
   if (ERROR_SUCCESS != uResult && ERROR_NOT_FOUND != uResult) {
      SetErrorProperty(hInstall, IDS_GETPROPERTY_UNINSTALL_LOG, uResult);
      return FALSE;
   }

   uResult = _GetParameter(szParameters, TEXT("/binary="), pszInstBinary);
   if (ERROR_SUCCESS != uResult) {
      SetErrorProperty(hInstall, IDS_GETPROPERTY_BINARY, uResult);
      return FALSE;
   }

   return TRUE;
}

UINT _ExpandArguments(MSIHANDLE hInstall, LPTSTR * pszArguments) {
   UINT uFilecount = 0;
   UINT cchLength = 0;
   LPTSTR szBuffer = NULL;
   LPTSTR szCurrent;
   LPTSTR szPrevious;
   LPCTSTR szStartSearch = TEXT("[");
   LPCTSTR szEndSearch = TEXT("]");
   UINT uResult = ERROR_SUCCESS;

   szCurrent = _tcsstr(*pszArguments, szStartSearch);
   while (szCurrent++) {
      uFilecount++;
      szCurrent = _tcsstr(szCurrent, szStartSearch);
   }

   cchLength = _tcslen(*pszArguments) + uFilecount * MAX_PATH + 1;

   __try {
      if (NULL == (szBuffer = new TCHAR[cchLength])) {
         uResult = ERROR_OUTOFMEMORY;
         __leave;
      }

      szBuffer[0] = 0;

      szPrevious = *pszArguments;
      szCurrent = _tcsstr(szPrevious, szStartSearch);

      while (szPrevious) {
         TCHAR szProperty[MAX_PATH] = {0};

         if (szCurrent)
            _tcsncat_s(szBuffer, cchLength, szPrevious, szCurrent - szPrevious);
         else
            _tcscat_s(szBuffer, cchLength, szPrevious);
         
         if (szCurrent) {
            TCHAR chOld;

            szPrevious = szCurrent + _tcslen(szStartSearch);
            if (NULL == (szCurrent = _tcsstr(szPrevious, szEndSearch))) {
               uResult = ERROR_BAD_ARGUMENTS;
               __leave;
            }

            chOld = szCurrent[0];
            szCurrent[0] = 0;
            if (szPrevious[0] == TEXT('#')) { //Dealing with a file name
               uResult = GetFilePath(hInstall, szPrevious + 1, szProperty, ARRAYSIZE(szProperty), TRUE);
               if (ERROR_SUCCESS != uResult) {
                  szCurrent[0] = chOld;
                  __leave;
               }
            }
            else { //Dealing with a regular property
               uResult = GetProperty(hInstall, szPrevious, szProperty, ARRAYSIZE(szProperty), TRUE);
               if (ERROR_SUCCESS != uResult) {
                  szCurrent[0] = chOld;
                  __leave;
               }
            }

            if (_tcslen(szProperty))
               _tcscat_s(szBuffer, cchLength, szProperty);
            else {
               _tcscat_s(szBuffer, cchLength, szStartSearch);
               _tcscat_s(szBuffer, cchLength, szPrevious);
               _tcscat_s(szBuffer, cchLength, szEndSearch);
            }

            szCurrent[0] = chOld;
            szPrevious = szCurrent + 1;
            szCurrent = _tcsstr(szPrevious, szStartSearch);
         }
         else
            szPrevious = NULL;
      }

      SAFE_DELETE_A(*pszArguments);
      *pszArguments = szBuffer;

      szBuffer = NULL;
   }
   __finally {
      SAFE_DELETE_A(szBuffer);
   }

   return uResult;
}

MSIEXPORT CreateInstallUtilProperties(MSIHANDLE hInstall) {
   LPTSTR   szInstCount = NULL;
   DWORD    dwCount;
   UINT     uResult;
   UINT     ret = ERROR_SUCCESS;
   
   __try {
      /**** Getting Properties ****/
      uResult = GetProperty(hInstall, TEXT("InstallUtil.Count"), &szInstCount);
      if (ERROR_SUCCESS != uResult) {
         ret = SetErrorProperty(hInstall, IDS_GETPROPERTY_COUNT, uResult);
         __leave;
      }

      if (1 != _stscanf_s(szInstCount, TEXT("%d"), &dwCount)) {
         ret = SetErrorProperty(hInstall, IDS_INVALIDVALUE_COUNT, szInstCount);
         __leave;
      }

      for (DWORD dwIndex=0; dwIndex<dwCount && ret == ERROR_SUCCESS; dwIndex++) {
         LPTSTR szInstParameters = NULL;
         LPTSTR szInstDirectory = NULL;
         LPTSTR szInstInstallLog = NULL;
         LPTSTR szInstUninstallLog = NULL;
         LPTSTR szLoggingDirectory = NULL;
         LPTSTR szInstBinary = NULL;
         LPTSTR szArguments = NULL;
         LPTSTR szComponentName = NULL;
         LPTSTR szInstInstallComponentLog = NULL;
         LPTSTR szInstUninstallComponentLog = NULL;

         LPTSTR szTargetDirectory = NULL;
         TCHAR  szLoggingPrefix[] = TEXT("/LogFile");
         TCHAR  szTargetInstallLogging[MAX_PATH+ARRAYSIZE(szLoggingPrefix)] = {0};
         TCHAR  szTargetUninstallLogging[MAX_PATH+ARRAYSIZE(szLoggingPrefix)] = {0};
         TCHAR  szTargetBinary[MAX_PATH] = {0};
         DWORD  cchTargetBinary;

         __try {
            uResult = GetProperty(hInstall, TEXT("InstallUtil.Parameters"), dwIndex, &szInstParameters, TRUE);
            if (ERROR_SUCCESS != uResult) {
               ret = SetErrorProperty(hInstall, IDS_GETPROPERTY_PARAMETERS, dwIndex, uResult);
               __leave;
            }

            if (!_tcslen(szInstParameters))
               __leave;

            if (!_ParseParameters(hInstall, szInstParameters, &szInstDirectory, &szInstInstallLog, &szInstUninstallLog, &szInstBinary)) {
               ret = ERROR_BAD_ARGUMENTS;
               __leave;
            }

            uResult = GetProperty(hInstall, TEXT("LOGGING_DIRECTORY"), &szLoggingDirectory);
            if (ERROR_SUCCESS != uResult) {
               ret = SetErrorProperty(hInstall, IDS_GETPROPERTY_LOGGING_DIRECTORY, uResult);
               __leave;
            }

            uResult = GetProperty(hInstall, TEXT("InstallUtil.Arguments"), dwIndex, &szArguments, TRUE);
            if (ERROR_SUCCESS != uResult) {
               ret = SetErrorProperty(hInstall, IDS_GETPROPERTY_ARGUMENTS, uResult);
               __leave;
            }

            uResult = GetProperty(hInstall, TEXT("COMPONENT"), &szComponentName);
            if (ERROR_SUCCESS != uResult) {
               ret = SetErrorProperty(hInstall, IDS_GETPROPERTY_COMPONENT, uResult);
               __leave;
            }

            /**** Generating Property Values ****/
            uResult = GetDirectory(hInstall, szInstDirectory, &szTargetDirectory, szInstDirectory);
            if (ERROR_SUCCESS != uResult) {
               ret = SetErrorProperty(hInstall, IDS_GETPROPERTY_UNINSTALL_LOG, dwIndex, uResult);
               __leave;
            }

            uResult = GetFilePath(hInstall, szInstBinary, szTargetBinary, ARRAYSIZE(szTargetBinary), FALSE);

            if (ERROR_SUCCESS != uResult) {
               ret = SetErrorProperty(hInstall, IDS_GETPROPERTY_BINARY, szInstBinary, uResult);
               __leave;
            }

            if (szInstInstallLog && _tcslen(szInstInstallLog)) {
               
               szInstInstallComponentLog = AppendLogName(szComponentName, szInstInstallLog);

               if (ARRAYSIZE(szTargetInstallLogging) <= _sctprintf(TEXT("\"%s=%s\\%s\""), szLoggingPrefix, szLoggingDirectory, szInstInstallComponentLog)) {
                  ret = SetErrorProperty(hInstall, IDS_INVALIDVALUE_TARGET_INSTALL_LOG, szLoggingDirectory, szInstInstallComponentLog, ARRAYSIZE(szTargetInstallLogging)-1);
                  __leave;
               }

               _stprintf_s(
                  szTargetInstallLogging, 
                  ARRAYSIZE(szTargetInstallLogging), 
                  TEXT("%s=%s\\%s"),
                  szLoggingPrefix,
                  szLoggingDirectory, 
                  szInstInstallComponentLog);
            }
            else
               _tcscpy_s(szTargetInstallLogging, ARRAYSIZE(szTargetInstallLogging), TEXT("/LogToConsole=true"));

            if (szInstUninstallLog && _tcslen(szInstUninstallLog)) {

               szInstUninstallComponentLog = AppendLogName(szComponentName, szInstUninstallLog);

               if (ARRAYSIZE(szTargetUninstallLogging) <= _sctprintf(TEXT("\"%s=%s\\%s\""), szLoggingPrefix, szLoggingDirectory, szInstUninstallComponentLog)) {
                  ret = SetErrorProperty(hInstall, IDS_INVALIDVALUE_TARGET_INSTALL_LOG, szLoggingDirectory, szInstUninstallComponentLog, ARRAYSIZE(szTargetInstallLogging)-1);
                  __leave;
               }

               _stprintf_s(
                  szTargetUninstallLogging, 
                  ARRAYSIZE(szTargetUninstallLogging), 
                  TEXT("%s=%s\\%s"),
                  szLoggingPrefix,
                  szLoggingDirectory, 
                  szInstUninstallComponentLog);
            }
            else
               _tcscpy_s(szTargetUninstallLogging, ARRAYSIZE(szTargetUninstallLogging), TEXT("/LogToConsole=true"));

            if (_tcslen(szArguments)) {
               uResult = _ExpandArguments(hInstall, &szArguments);
               if (ERROR_SUCCESS != uResult) {
                  ret = SetErrorProperty(hInstall, IDS_EXPAND_ARGUMENTS, dwIndex, szArguments ? szArguments : TEXT("(null)"), uResult);
                  __leave;
               }
            }

            /**** Setting Property Values ****/
            uResult = SetTargetPath(hInstall, TEXT("InstallUtil.Directory"), dwIndex, szTargetDirectory);
            if (ERROR_SUCCESS != uResult) {
               ret = SetErrorProperty(hInstall, IDS_SETPROPERTY_DIRECTORY, dwIndex, uResult);
               __leave;
            }

            uResult = SetProperty(hInstall, TEXT("InstallUtil.Install.LoggingMethod"), dwIndex, szTargetInstallLogging);
            if (ERROR_SUCCESS != uResult) {
               ret = SetErrorProperty(hInstall, IDS_SETPROPERTY_INSTALL_LOG, dwIndex, uResult);
               __leave;
            }

            uResult = SetProperty(hInstall, TEXT("InstallUtil.Uninstall.LoggingMethod"), dwIndex, szTargetUninstallLogging);
            if (ERROR_SUCCESS != uResult) {
               ret = SetErrorProperty(hInstall, IDS_SETPROPERTY_UNINSTALL_LOG, dwIndex, uResult);
               __leave;
            }

            uResult = SetProperty(hInstall, TEXT("InstallUtil.Binary"), dwIndex, szTargetBinary);
            if (ERROR_SUCCESS != uResult) {
               ret = SetErrorProperty(hInstall, IDS_SETPROPERTY_BINARY, dwIndex, uResult);
               __leave;
            }

            uResult = SetProperty(hInstall, TEXT("InstallUtil.Arguments"), dwIndex, szArguments);
            if (ERROR_SUCCESS != uResult) {
               ret = SetErrorProperty(hInstall, IDS_SETPROPERTY_ARGUMENTS, dwIndex, uResult);
               __leave;
            }

            uResult = SetProperty(hInstall, TEXT("InstallUtil"), dwIndex, TEXT("1"));
            if (ERROR_SUCCESS != uResult) {
               ret = SetErrorProperty(hInstall, IDS_SETPROPERTY_INSTALLUTIL, dwIndex, uResult);
               __leave;
            }
         }
         __finally{
            SAFE_DELETE_A(szInstDirectory);
            SAFE_DELETE_A(szInstInstallLog);
            SAFE_DELETE_A(szInstUninstallLog);
            SAFE_DELETE_A(szLoggingDirectory);
            SAFE_DELETE_A(szTargetDirectory);
            SAFE_DELETE_A(szArguments);
            SAFE_DELETE_A(szComponentName);
            SAFE_DELETE_A(szInstInstallComponentLog);
            SAFE_DELETE_A(szInstUninstallComponentLog);
         }
      }
   }
   __finally {
      SAFE_DELETE_A(szInstCount);
   }

   return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\test\XmlObjectModel\XmlObjectModelTestNode.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Reflection;
using System.Security.Cryptography.X509Certificates;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using System.Runtime.Serialization;
using System.IO;
using System.Xml;

using xonline.tools.deploymentlanguage;
using xonline.tools.deploymentlanguage.Language;

namespace xonline.tools.deploymentlanguage.test.DeploymentLanguageUnitTests
{

    public class XmlObjectModelTestNode : DeploymentLanguageTestNode
    {
        public override void PreRun()
        {
            base.PreRun();

            // this technically isn't a fixture, but it runs over and over again.

            LanguageParser = new LanguageParser();
            LanguageDefinition = new LanguageDefinition();
            ErrorCollection = new LanguageErrors();
            

        }

        public override void PostRun()
        {
            // don't leak memory
            LanguageParser = null;
            LanguageDefinition = null;
            ErrorCollection = null;
            base.PostRun();
        }

        public void ParseDirectory()
        {
            LanguageParser.ParseDirectory(TestDataPath, LanguageDefinition, ErrorCollection);
        }

        /// <summary>
        /// The language parser set up for this test run.
        /// </summary>
        protected ILanguageParser LanguageParser { get; private set; }

        /// <summary>
        /// The results of using this parser on the directory pointed to by TestDataPath.
        /// </summary>
        protected LanguageDefinition LanguageDefinition { get; private set; }

        /// <summary>
        /// The errors collection from running the process.
        /// </summary>
        protected LanguageErrors ErrorCollection { get; private set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\deploymentlanguage\test\XmlObjectModel\StringTestNode.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Reflection;
using System.Security.Cryptography.X509Certificates;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using System.Runtime.Serialization;
using System.IO;
using System.Xml;

using xonline.tools.deploymentlanguage;
using xonline.tools.deploymentlanguage.Language;

namespace xonline.tools.deploymentlanguage.test.DeploymentLanguageUnitTests
{

    public class StringTestNode : DeploymentLanguageTestNode
    {
        public override void PreRun()
        {
            base.PreRun();

            // this technically isn't a fixture, but it runs over and over again.

            LanguageParser = new LanguageParser();
            LanguageDefinition = new LanguageDefinition();
            ErrorCollection = new LanguageErrors();
            _files = new Dictionary<string, string>();

        }

        public override void PostRun()
        {
            // don't leak memory
            LanguageParser = null;
            LanguageDefinition = null;
            ErrorCollection = null;
            _files = null;
            _tempPath = null;

            base.PostRun();
        }

        public void ParseDirectory()
        {
            using (TemporaryDirectory dir = new TemporaryDirectory())
            {
                _tempPath = dir.Path;
                foreach (var fileDataPair in _files)
                {
                    File.WriteAllText(Path.Combine(dir.Path, fileDataPair.Key), fileDataPair.Value);
                }
                LanguageParser.ParseDirectory(dir.Path, LanguageDefinition, ErrorCollection);
            }
        }

        /// <summary>
        /// The language parser set up for this test run.
        /// </summary>
        protected ILanguageParser LanguageParser { get; private set; }

        /// <summary>
        /// The results of using this parser on the directory pointed to by TestDataPath.
        /// </summary>
        protected LanguageDefinition LanguageDefinition { get; private set; }

        /// <summary>
        /// The errors collection from running the process.
        /// </summary>
        protected LanguageErrors ErrorCollection { get; private set; }
        private Dictionary<string, string> _files;
        private string _tempPath;

        protected void AddFile(string fileName, string contents) {
            _files.Add(fileName, contents);
        }

        protected string GetPathForFile(string fileName)
        {
            return Path.Combine(_tempPath, fileName);
        }
        private class TemporaryDirectory : IDisposable
        {
            public TemporaryDirectory()
            {
                _path = System.IO.Path.Combine(System.IO.Path.GetTempPath(), System.IO.Path.GetRandomFileName());
                Directory.CreateDirectory(_path);
            }

            ~TemporaryDirectory()
            {
                if (_path != null)
                    Directory.Delete(_path, true);
            }

            private string _path;
            public string Path
            {
                get
                {
                    return _path;
                }
            }

            #region IDisposable Members

            public void Dispose()
            {
                if (_path != null)
                {
                    Directory.Delete(_path, true);
                }
                _path = null;
            }
            #endregion
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\MsiLoggingUtil\Helper.cpp ===
#include "MsiLoggingUtil.h"

LPTSTR AppendLogName(LPCTSTR szComponentName, LPCTSTR szLogName) {
   LPTSTR szDestination;
   int    cchDestination;

   cchDestination = _sctprintf(TEXT("%s_%s"), szComponentName, szLogName);
   if (szDestination = new TCHAR[++cchDestination])
      _stprintf_s(szDestination, cchDestination, TEXT("%s_%s"), szComponentName, szLogName);

   return szDestination;
}

LPTSTR StringCopy(LPCTSTR szSource, UINT cchCount) {
   LPTSTR szDestination;

   cchCount = cchCount ? cchCount : _tcslen(szSource);
   if (szDestination = new TCHAR[cchCount+1])
      _tcsncpy_s(szDestination, cchCount+1, szSource, cchCount);

   return szDestination;
}

TCHAR * _GetPropertyName(LPCTSTR szBasename, DWORD dwIndex) {
   LPTSTR szProperty;
   int    cchProperty;

   cchProperty = _sctprintf(TEXT("%s.%d"), szBasename, dwIndex);
   if (szProperty = new TCHAR[++cchProperty])
      _stprintf_s(szProperty, cchProperty, TEXT("%s.%d"), szBasename, dwIndex);

   return szProperty;
}

UINT SetTargetPath(MSIHANDLE hInstall, LPCTSTR szName, LPCTSTR szValue) {
   return MsiSetTargetPath(hInstall, szName, szValue);
}

UINT SetTargetPath(MSIHANDLE hInstall, LPCTSTR szBasename, DWORD dwIndex, LPCTSTR szValue) {
   LPTSTR szName;
   UINT   ret;

   if (NULL == (szName = _GetPropertyName(szBasename, dwIndex)))
      return ERROR_OUTOFMEMORY;

   ret = SetTargetPath(hInstall, szName, szValue);

   SAFE_DELETE_A(szName);

   return ret;
}

UINT SetProperty(MSIHANDLE hInstall, LPCTSTR szName, LPCTSTR szValue) {
   return MsiSetProperty(hInstall, szName, szValue);
}

UINT SetProperty(MSIHANDLE hInstall, LPCTSTR szBasename, DWORD dwIndex, LPCTSTR szValue) {
   LPTSTR szProperty;
   UINT   ret;

   if (NULL == (szProperty = _GetPropertyName(szBasename, dwIndex)))
      return ERROR_OUTOFMEMORY;

   ret = SetProperty(hInstall, szProperty, szValue);

   SAFE_DELETE_A(szProperty);

   return ret;
}

UINT SetProperty(MSIHANDLE hInstall, LPCTSTR szName, UINT uIdMessage, ...) {
   TCHAR    szFormat[256] = {0};
   LPTSTR   szValue;
   UINT     cchValue;
   va_list  args;
   UINT     ret;
   
   va_start(args, uIdMessage);

   if (!LoadString(g_hInstance, uIdMessage, szFormat, ARRAYSIZE(szFormat)))
      return GetLastError();

   cchValue = _vsctprintf(szFormat, args);
   if (NULL == (szValue = new TCHAR[++cchValue]))
      return ERROR_OUTOFMEMORY;

   _vstprintf_s(szValue, cchValue, szFormat, args);

   ret = SetProperty(hInstall, szName, szValue);

   SAFE_DELETE_A(szValue);

   return ret;
}

UINT GetFilePath(MSIHANDLE hInstall, LPCTSTR szName, LPTSTR szValue, DWORD cchValue, BOOL fOptional) {
   MSIHANDLE  hDatabase = NULL;
   MSIHANDLE  hView = NULL;
   MSIHANDLE  hRecord = NULL;
   UINT       uResult;
   TCHAR      szViewQuery[256];
   TCHAR      szFileName[128];
   TCHAR      szDirectoryName[128];
   LPCTSTR    szLongname;
   DWORD      cchBuffer;

   _stprintf_s(szViewQuery, ARRAYSIZE(szViewQuery),
      TEXT("SELECT File.FileName, Component.Directory_ FROM")
      TEXT("  File, Component WHERE")
      TEXT("  File.File = '%s' AND")
      TEXT("  File.Component_ = Component.Component"), 
      szName);

   __try {
      hDatabase = MsiGetActiveDatabase(hInstall);
      uResult = GetLastError();
      if (!hDatabase)
         __leave;

      uResult = MsiDatabaseOpenView(hDatabase, szViewQuery, &hView);
      if (NULL == hView)
         __leave;
      
      if (ERROR_SUCCESS != (uResult = MsiViewExecute(hView, NULL)))
         __leave;

      uResult = MsiViewFetch(hView, &hRecord);
      if (!hRecord)
         __leave;
      
      cchBuffer = ARRAYSIZE(szFileName);
      if (ERROR_SUCCESS != (uResult = MsiRecordGetString(hRecord, 1, szFileName, &cchBuffer)))
         __leave;
      
      cchBuffer = ARRAYSIZE(szDirectoryName);
      if (ERROR_SUCCESS != (uResult = MsiRecordGetString(hRecord, 2, szDirectoryName, &cchBuffer)))
         __leave;

      szLongname = _tcsstr(szFileName, TEXT("|"));
      szLongname = szLongname ? szLongname+1 : szFileName;

      if (ERROR_SUCCESS != (uResult = GetDirectory(hInstall, szDirectoryName, szValue, cchValue)))
         __leave;

      if (_tcslen(szValue) + 1 + _tcslen(szLongname) > cchValue) {
         uResult = ERROR_INSUFFICIENT_BUFFER;
         __leave;
      }

      _tcscat_s(szValue, cchValue, szLongname);
   }
   __finally {
      if (hView)
         MsiCloseHandle(hView);
      if (hDatabase)
         MsiCloseHandle(hDatabase);
      if (hRecord)
         MsiCloseHandle(hRecord);
   }

   return uResult;
}

UINT GetProperty(MSIHANDLE hInstall, LPCTSTR szName, LPTSTR szValue, DWORD cchValue, BOOL fOptional) {
   UINT uReturn;
   
   uReturn = MsiGetProperty(hInstall, szName, szValue, &cchValue);

   if (ERROR_SUCCESS == uReturn && !fOptional && !cchValue)
      uReturn = ERROR_EMPTY;

   return uReturn;
}

UINT GetProperty(MSIHANDLE hInstall, LPCTSTR szName, LPTSTR * pszValue, BOOL fOptional) {
   TCHAR* szBuffer = NULL;
   DWORD  cchBuffer = 0;
   UINT   uReturn;

   uReturn = MsiGetProperty(hInstall, szName, TEXT(""), &cchBuffer);
   if (ERROR_MORE_DATA == uReturn) {
      if (szBuffer = new TCHAR[++cchBuffer])
         uReturn = MsiGetProperty(hInstall, szName, szBuffer, &cchBuffer);
      else
         uReturn = ERROR_OUTOFMEMORY;
   }

   if (ERROR_SUCCESS == uReturn && !fOptional && !cchBuffer)
      uReturn = ERROR_EMPTY;

   if (ERROR_SUCCESS != uReturn)
      SAFE_DELETE_A(szBuffer);
   
   *pszValue = szBuffer;

   return uReturn;
}

UINT GetProperty(MSIHANDLE hInstall, LPCTSTR szBasename, DWORD dwIndex, LPTSTR * pszValue, BOOL fOptional) {
   LPTSTR szProperty;
   UINT   ret;

   if (NULL == (szProperty = _GetPropertyName(szBasename, dwIndex)))
      return ERROR_OUTOFMEMORY;

   ret = GetProperty(hInstall, szProperty, pszValue, fOptional);

   SAFE_DELETE_A(szProperty);

   return ret;
}

UINT GetDirectory(MSIHANDLE hInstall, LPCTSTR szIdentifier, LPTSTR szValue, DWORD cchValue, LPCTSTR szDefault) {
   UINT uReturn;
   DWORD cchBuffer;

   cchBuffer = cchValue;
   uReturn = MsiGetTargetPath(hInstall, szIdentifier, szValue, &cchBuffer);
   if (ERROR_DIRECTORY == uReturn && szDefault) {
      uReturn = ERROR_SUCCESS;
      _tcscpy_s(szValue, cchValue, szDefault);
   }

   return uReturn;
}

UINT GetDirectory(MSIHANDLE hInstall, LPCTSTR szIdentifier, LPTSTR * pszValue, LPCTSTR szDefault) {
   TCHAR* szBuffer = NULL;
   DWORD  cchBuffer = 0;
   UINT   uReturn;

   uReturn = MsiGetTargetPath(hInstall, szIdentifier, TEXT(""), &cchBuffer);
   cchBuffer = max(cchBuffer, _tcslen(szDefault));

   if (ERROR_MORE_DATA == uReturn || (ERROR_DIRECTORY == uReturn && szDefault)) {
      if (szBuffer = new TCHAR[++cchBuffer])
         uReturn = GetDirectory(hInstall, szIdentifier, szBuffer, cchBuffer);
      else
         uReturn = ERROR_OUTOFMEMORY;
   }

   if (ERROR_SUCCESS != uReturn)
      SAFE_DELETE_A(szBuffer);

   *pszValue = szBuffer;

   return uReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\MsiLoggingUtil\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_msiloggingutil_none_12.4.56.0_none_9d0acc3cb2fb1fbe
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_msiloggingutil_no-public-key_12.4.56.0_x-ww_153ecbb4
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=msiloggingutil
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_msiloggingutil_no-public-key_12.4.56.0_x-ww_153ecbb4
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_msiloggingutil_no-public-key_12.4.56.0_x-ww_153ecbb4.manifest
XP_MANIFEST_PATH=manifests\x86_msiloggingutil_no-public-key_12.4.56.0_x-ww_153ecbb4.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_msiloggingutil_no-public-key_12.4.56.0_x-ww_153ecbb4.cat
XP_CATALOG_PATH=manifests\x86_msiloggingutil_no-public-key_12.4.56.0_x-ww_153ecbb4.cat
XP_PAYLOAD_PATH=x86_msiloggingutil_no-public-key_12.4.56.0_x-ww_153ecbb4
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=msiloggingutil,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\MsiLoggingUtil\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by MsiLoggingUtil.rc
//
#define IDS_GETPROPERTY_COUNT           101
#define IDS_INVALIDVALUE_COUNT          102
#define IDS_GETPROPERTY_DIRECTORY       103
#define IDS_GETPROPERTY_INSTALL_LOG     104
#define IDS_GETPROPERTY_UNINSTALL_LOG   105
#define IDS_GETPROPERTY_LOGGING_DIRECTORY 106
#define IDS_INVALIDVALUE_TARGET_INSTALL_LOG 107
#define IDS_SETPROPERTY_DIRECTORY       108
#define IDS_SETPROPERTY_INSTALL_LOG     109
#define IDS_SETPROPERTY_UNINSTALL_LOG   110
#define IDS_SETPROPERTY_INSTALLUTIL     111
#define IDS_GETPROPERTY_PARAMETERS      112
#define IDS_GETPROPERTY_BINARY          113
#define IDS_GETBINARY_PATH              114
#define IDS_SETPROPERTY_BINARY          115
#define IDS_GETPROPERTY_ARGUMENTS       116
#define IDS_EXPAND_ARGUMENTS            117
#define IDS_SETPROPERTY_ARGUMENTS       118
#define IDS_GETPROPERTY_COMPONENT       119

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\MsiLoggingUtil\MsiLoggingUtil.h ===
#ifndef __MSI_LOGGING_UTIL_H__
#define __MSI_LOGGING_UTIL_H__

#include <windows.h>
#include <shlobj.h>
#include <msi.h>
#include <msiquery.h>
#include <stdio.h>
#include <tchar.h>
#include "resource.h"

#define MSIEXPORT                               extern "C" UINT __stdcall
#define SAFE_DELETE(x)                          { if (x) { delete (x); (x) = NULL; } }
#define SAFE_DELETE_A(x)                        { if (x) { delete [] (x); (x) = NULL; } }

#define SAY(x)    MessageBox(NULL, x, TEXT("Debugging"), MB_OK)
#define SAY2(x,y) MessageBox(NULL, x, y, MB_OK)

#define SetErrorProperty(hInstall, Fmt, ...)    SetProperty(hInstall, TEXT("InstallUtil.Error"), Fmt, __VA_ARGS__)

extern HINSTANCE g_hInstance;

/* Helper Methods */
LPTSTR StringCopy(LPCTSTR szSource, UINT cchCount);
LPTSTR AppendLogName(LPCTSTR szComponentName, LPCTSTR szLogName);

UINT SetTargetPath(MSIHANDLE hInstall, LPCTSTR szName, LPCTSTR szValue);
UINT SetTargetPath(MSIHANDLE hInstall, LPCTSTR szBasename, DWORD dwIndex, LPCTSTR szValue);

UINT SetProperty(MSIHANDLE hInstall, LPCTSTR szName, LPCTSTR szValue);
UINT SetProperty(MSIHANDLE hInstall, LPCTSTR szBasename, DWORD dwIndex, LPCTSTR szValue);
UINT SetProperty(MSIHANDLE hInstall, LPCTSTR szName, UINT uIdMessage, ...);

UINT GetFilePath(MSIHANDLE hInstall, LPCTSTR szName, LPTSTR szValue, DWORD cchValue, BOOL fOptional);

UINT GetProperty(MSIHANDLE hInstall, LPCTSTR szName, LPTSTR szValue, DWORD cchValue, BOOL fOptional = TRUE);
UINT GetProperty(MSIHANDLE hInstall, LPCTSTR szName, LPTSTR * pszValue, BOOL fOptional = FALSE);
UINT GetProperty(MSIHANDLE hInstall, LPCTSTR szBasename, DWORD dwIndex, LPTSTR * pszValue, BOOL fOptional = FALSE);

UINT GetDirectory(MSIHANDLE hInstall, LPCTSTR szIdentifier, LPTSTR szValue, DWORD cchValue, LPCTSTR szDefault = NULL);
UINT GetDirectory(MSIHANDLE hInstall, LPCTSTR szIdentifier, LPTSTR * pszValue, LPCTSTR szDefault = NULL);

/* DLL Entry Points */
MSIEXPORT CreateInstallUtilProperties(MSIHANDLE hInstall);
MSIEXPORT EspMsiLoggingDirectory(MSIHANDLE hInstall);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\MsiLoggingUtil\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_msiloggingutil_none_12.4.56.0_none_9d0acc3cb2fb1fbe
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_msiloggingutil_no-public-key_12.4.56.0_x-ww_153ecbb4
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=msiloggingutil
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_msiloggingutil_no-public-key_12.4.56.0_x-ww_153ecbb4
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_msiloggingutil_no-public-key_12.4.56.0_x-ww_153ecbb4.manifest
XP_MANIFEST_PATH=manifests\x86_msiloggingutil_no-public-key_12.4.56.0_x-ww_153ecbb4.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_msiloggingutil_no-public-key_12.4.56.0_x-ww_153ecbb4.cat
XP_CATALOG_PATH=manifests\x86_msiloggingutil_no-public-key_12.4.56.0_x-ww_153ecbb4.cat
XP_PAYLOAD_PATH=x86_msiloggingutil_no-public-key_12.4.56.0_x-ww_153ecbb4
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=msiloggingutil,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\SideBySidePDBs\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\SiteConfig\BackupConfig\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\SiteConfig\BackupConfig\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\SiteConfig\BackupConfig\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\SiteConfig\CertConfig\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\SiteConfig\BackupConfig\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_backupconfig_none_12.4.56.0_none_8599959fc1bd5cd8
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_backupconfig_no-public-key_12.4.56.0_x-ww_2f36a6ba
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=backupconfig
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_backupconfig_no-public-key_12.4.56.0_x-ww_2f36a6ba
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_backupconfig_no-public-key_12.4.56.0_x-ww_2f36a6ba.manifest
XP_MANIFEST_PATH=manifests\x86_backupconfig_no-public-key_12.4.56.0_x-ww_2f36a6ba.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_backupconfig_no-public-key_12.4.56.0_x-ww_2f36a6ba.cat
XP_CATALOG_PATH=manifests\x86_backupconfig_no-public-key_12.4.56.0_x-ww_2f36a6ba.cat
XP_PAYLOAD_PATH=x86_backupconfig_no-public-key_12.4.56.0_x-ww_2f36a6ba
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=backupconfig,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\SiteConfig\BackupConfig\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_backupconfig_none_12.4.56.0_none_8599959fc1bd5cd8
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_backupconfig_no-public-key_12.4.56.0_x-ww_2f36a6ba
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=backupconfig
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_backupconfig_no-public-key_12.4.56.0_x-ww_2f36a6ba
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_backupconfig_no-public-key_12.4.56.0_x-ww_2f36a6ba.manifest
XP_MANIFEST_PATH=manifests\x86_backupconfig_no-public-key_12.4.56.0_x-ww_2f36a6ba.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_backupconfig_no-public-key_12.4.56.0_x-ww_2f36a6ba.cat
XP_CATALOG_PATH=manifests\x86_backupconfig_no-public-key_12.4.56.0_x-ww_2f36a6ba.cat
XP_PAYLOAD_PATH=x86_backupconfig_no-public-key_12.4.56.0_x-ww_2f36a6ba
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=backupconfig,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\SiteConfig\CertConfig\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\SideBySidePDBs\PDBInstaller.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Configuration.Install;
using System.Runtime.InteropServices;
using System.ComponentModel;
using System.Collections;
using System.Reflection;
using System.IO;

/*
 * Disables warning for using the obsolete method Assembly.LoadWithPartialName()
 *
 * LoadWithPartialName() is used to for finding out whether the dll and version exists in the GAC, we do not
 * always have the PublicKeyToken available for satifying Assembly.Load().
 *
 * LoadWithPartialName() is an obsolete method since .NET 1.0 for disencouraging the use of partial binding.
 * The use for SideBySidePdbs is not to bind the assembly but only to check if it's in the GAC.
 * It felt safe to use in this scenario. It does not look like .NET will deprecate this function either since it
 * has been obsolete after .NET 1.0 and still available in .NET 4.0.
 */
#pragma warning disable 0618

namespace xonline.tools.deployment.SideBySidePDBs
{
    [ComVisible(false)]
    [RunInstaller(true)]
    public class PDBInstaller : Installer
    {
        private Assembly executingAssembly;
        private AssemblyName executingAssemblyName;

        private enum SystemArchitecture
        {
            x86,
            amd64
        }

        [Flags]
        enum MoveFileFlags
        {
            MOVEFILE_REPLACE_EXISTING = 0x00000001,
            MOVEFILE_COPY_ALLOWED = 0x00000002,
            MOVEFILE_DELAY_UNTIL_REBOOT = 0x00000004,
            MOVEFILE_WRITE_THROUGH = 0x00000008,
            MOVEFILE_CREATE_HARDLINK = 0x00000010,
            MOVEFILE_FAIL_IF_NOT_TRACKABLE = 0x00000020
        }

        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        static extern bool MoveFileEx(string lpExistingFileName, string lpNewFileName, MoveFileFlags dwFlags);

        public PDBInstaller()
        {
            executingAssembly = Assembly.GetExecutingAssembly();
            executingAssemblyName = new AssemblyName(executingAssembly.FullName);
        }

        public override void Install(IDictionary stateSaver)
        {
            base.Install(stateSaver);

            bool pdbFileMoved = false;

            string version = AssemblyVersion.ToString();

            // The PDB location would be common\<version>\<architecture>\*.pdb
            string commonPDBPath = GetCommonPdbLocation();

            // Loop through all PDB files and see if they exists
            string[] pdbFiles = Directory.GetFiles(Path.GetDirectoryName(AssemblyLocation), "*.pdb");

            foreach (string pdbFile in pdbFiles)
            {
                string dllName = Path.GetFileNameWithoutExtension(pdbFile);
                string dllAssemblyName = String.Format("{0}, Version={1}, Culture=neutral ", dllName, version);

                try
                {
                    Assembly dllAssembly = Assembly.LoadWithPartialName(dllAssemblyName);

                    if (dllAssembly.GlobalAssemblyCache)
                    {
                        LogMessage("{0} found in GAC, proceeding to move PDB to common location", dllAssemblyName);

                        // If we can load the assembly, we can assume it's in the GAC, so let's copy the PDB to the shared location
                        Directory.CreateDirectory(commonPDBPath);

                        try
                        {
                            File.Move(pdbFile, Path.Combine(commonPDBPath, Path.GetFileName(pdbFile)));
                        }
                        catch (IOException ex)
                        {
                            if (ex.Message.Contains("exists"))
                            {
                                File.Delete(pdbFile);
                            }
                            else
                            {
                                LogMessage("Failed to move file: {0}", ex.Message);
                            }
                        }

                        LogMessage("Moved {0} to {1}", Path.GetFileName(pdbFile), commonPDBPath);

                        pdbFileMoved = true;
                    }
                }
                catch (FileLoadException)
                {
                    LogMessage("{0} not found in GAC, skipping PDB move", dllAssemblyName);
                    File.Delete(pdbFile);
                }
                catch (FileNotFoundException)
                {
                    LogMessage("{0} not found in GAC, skipping PDB move", dllAssemblyName);
                    File.Delete(pdbFile);
                }
            }

            if (pdbFileMoved)
            {
                // Append path of PDB to _NT_SYMBOL_PATH if it didn't exists
                AddToNtSymbolPath(commonPDBPath);
            }
        }

        public override void Uninstall(IDictionary savedState)
        {
            base.Uninstall(savedState);

            try
            {
                foreach (string pdbVersionPath in Directory.GetDirectories(CommonPDBBasePath))
                {
                    string pdbVersion = Path.GetFileName(pdbVersionPath);

                    List<string> pdbNamesInDirectory = new List<string>();
                    List<string> pdbNamesToRemove = new List<string>();

                    // Find all PDB files for this version
                    foreach (string pdbFile in Directory.GetFiles(pdbVersionPath, "*.pdb", SearchOption.AllDirectories))
                    {
                        if (!pdbNamesInDirectory.Contains(Path.GetFileNameWithoutExtension(pdbFile)))
                        {
                            pdbNamesInDirectory.Add(Path.GetFileNameWithoutExtension(pdbFile));
                        }
                    }

                    // Check to see if DLL is still in GAC, add to a list to remove
                    foreach (string pdbName in pdbNamesInDirectory)
                    {
                        string dllAssemblyName = String.Format("{0}, Version={1}, Culture=neutral ", pdbName, pdbVersion);

                        try
                        {
                            Assembly dllAssembly = Assembly.LoadWithPartialName(dllAssemblyName);
                        }
                        catch (FileLoadException)
                        {
                            LogMessage("Version {0} of {1} not found in the GAC, adding to the list of removal", pdbVersion, pdbName);
                            pdbNamesToRemove.Add(pdbName);
                        }
                        catch (FileNotFoundException)
                        {
                            LogMessage("Version {0} of {1} not found in the GAC, adding to the list of removal", pdbVersion, pdbName);
                            pdbNamesToRemove.Add(pdbName);
                        }
                    }

                    // Remove each of the PDB files
                    foreach (string pdbNameToRemove in pdbNamesToRemove)
                    {
                        foreach (string pdbFile in Directory.GetFiles(pdbVersionPath, pdbNameToRemove + ".pdb", SearchOption.AllDirectories))
                        {
                            LogMessage("Removing PDB: {0}", pdbFile);
                            try
                            {
                                File.Delete(pdbFile);
                            }
                            catch (IOException ioe)
                            {
                                try
                                {
                                    LogMessage("Unable to remove file {0}: {1}", pdbFile, ioe.Message);
                                    LogMessage("Calling MoveFileEx to remove file after reboot");

                                    MoveFileEx(pdbFile, null, MoveFileFlags.MOVEFILE_DELAY_UNTIL_REBOOT);
                                }
                                catch (Exception e)
                                {
                                    LogMessage("Failed to schedule removal of file {0} due to exception: {1}, skipping...", pdbFile, e.Message);
                                }
                            }
                            catch (UnauthorizedAccessException uae)
                            {
                                try
                                {
                                    LogMessage("Unable to remove file {0}: {1}", pdbFile, uae.Message);
                                    LogMessage("Calling MoveFileEx to remove file after reboot");

                                    MoveFileEx(pdbFile, null, MoveFileFlags.MOVEFILE_DELAY_UNTIL_REBOOT);
                                }
                                catch (Exception e)
                                {
                                    LogMessage("Failed to schedule removal of file {0} due to exception: {1}, skipping...", pdbFile, e.Message);
                                }
                            }
                        }
                        pdbNamesInDirectory.Remove(pdbNameToRemove);
                    }

                    // Remove version directory if it should be empty
                    if (pdbNamesInDirectory.Count == 0)
                    {
                        try
                        {
                            Directory.Delete(pdbVersionPath, true);
                        }
                        catch (IOException ioe)
                        {
                            try
                            {
                                LogMessage("Unable to remove directory {0}: {1}", pdbVersionPath, ioe.Message);
                                LogMessage("Calling MoveFileEx to remove directory after reboot");

                                MoveFileEx(pdbVersionPath, null, MoveFileFlags.MOVEFILE_DELAY_UNTIL_REBOOT);
                            }
                            catch (Exception e)
                            {
                                LogMessage("Failed to schedule removal of directory {0} due to exception: {1}, skipping...", pdbVersionPath, e.Message);
                            }
                        }
                        catch (UnauthorizedAccessException uae)
                        {
                            try
                            {
                                LogMessage("Unable to remove directory {0}: {1}", pdbVersionPath, uae.Message);
                                LogMessage("Calling MoveFileEx to remove directory after reboot");

                                MoveFileEx(pdbVersionPath, null, MoveFileFlags.MOVEFILE_DELAY_UNTIL_REBOOT);
                            }
                            catch (Exception e)
                            {
                                LogMessage("Failed to schedule removal of directory {0} due to exception: {1}, skipping...", pdbVersionPath, e.Message);
                            }
                        }
                    }
                }
            }
            catch (DirectoryNotFoundException dnfe)
            {
                LogMessage("Directory not found, skipping PDB clean up. {0}", dnfe.Message);
            }
            catch (Exception e)
            {
                LogMessage("Unexpected exception, skipping PDB clean up. {0}", e.Message);
            }
        }

        private void AddToNtSymbolPath(string commonVersionedPDBPath)
        {
            string ntSymbolPathValue = System.Environment.GetEnvironmentVariable("_NT_SYMBOL_PATH");

            if (ntSymbolPathValue == null || !ntSymbolPathValue.Contains(commonVersionedPDBPath))
            {
                if (ntSymbolPathValue != null && !ntSymbolPathValue.EndsWith(";"))
                {
                    ntSymbolPathValue += ';';
                }

                ntSymbolPathValue += commonVersionedPDBPath;
            }

            System.Environment.SetEnvironmentVariable("_NT_SYMBOL_PATH", ntSymbolPathValue, EnvironmentVariableTarget.Machine);
        }

        private void RemoveFromNtSymbolPath(string commonVersionedPDBPath)
        {
            string ntSymbolPathValue = System.Environment.GetEnvironmentVariable("_NT_SYMBOL_PATH");

            if (ntSymbolPathValue.Contains(commonVersionedPDBPath))
            {
                ntSymbolPathValue.Replace(commonVersionedPDBPath, "");
                ntSymbolPathValue.Replace(";;", ";");
            }

            System.Environment.SetEnvironmentVariable("_NT_SYMBOL_PATH", ntSymbolPathValue, EnvironmentVariableTarget.Machine);
        }

        protected string GetCommonPdbLocation()
        {
            SystemArchitecture systemArchitecture = GetSystemArchitecture();

            return Path.Combine(Path.Combine(CommonPDBBasePath, AssemblyVersion.ToString()), systemArchitecture.ToString());
        }

        private SystemArchitecture GetSystemArchitecture()
        {
            if (Marshal.SizeOf(new IntPtr()) == 8)
            {
                return SystemArchitecture.amd64;
            }
            else
            {
                return SystemArchitecture.x86;
            }
        }

        protected Version AssemblyVersion
        {
            get
            {
                return executingAssemblyName.Version;
            }
        }

        protected string AssemblyPublicKeyToken
        {
            get
            {
                return BitConverter.ToString(executingAssemblyName.GetPublicKeyToken()).Replace("-", "");
            }
        }

        protected string AssemblyLocation
        {
            get
            {
                return executingAssembly.Location;
            }
        }

        private string CommonPDBBasePath
        {
            get
            {
                string pdbDir = @"Common\PDBs";

                string targetDir = this.Context.Parameters["TargetDir"];

                // If TargetDir is not provided, we assume this dll is one level deep since it goes with the side-by-side dlls
                // The PDBs would be put into Webroot\Common\PDBs\...
                if (targetDir == null)
                {
                    return Path.Combine(Path.GetDirectoryName(AssemblyLocation), Path.Combine("..", pdbDir));
                }
                else
                {
                    return Path.Combine(this.Context.Parameters["TargetDir"], pdbDir);
                }
            }
        }

        protected void LogMessage(String message)
        {
            String stampedMessage = String.Format("[{0:dd-MM-yyyy HH:mm:ss.fff}] {1}", DateTime.Now, message).
                Replace("\n", "\n                             ");

            Context.LogMessage(stampedMessage);
        }

        protected void LogMessage(String message, params Object[] args)
        {
            String formattedMessage = String.Format(message, args);

            LogMessage(formattedMessage);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\SiteConfig\CertConfig\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_certconfig_none_12.4.56.0_none_df8c3ea7c7bb6e44
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_certconfig_no-public-key_12.4.56.0_x-ww_8c6c137c
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=certconfig
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_certconfig_no-public-key_12.4.56.0_x-ww_8c6c137c
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_certconfig_no-public-key_12.4.56.0_x-ww_8c6c137c.manifest
XP_MANIFEST_PATH=manifests\x86_certconfig_no-public-key_12.4.56.0_x-ww_8c6c137c.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_certconfig_no-public-key_12.4.56.0_x-ww_8c6c137c.cat
XP_CATALOG_PATH=manifests\x86_certconfig_no-public-key_12.4.56.0_x-ww_8c6c137c.cat
XP_PAYLOAD_PATH=x86_certconfig_no-public-key_12.4.56.0_x-ww_8c6c137c
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=certconfig,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\SiteConfig\CertConfig\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_certconfig_none_12.4.56.0_none_df8c3ea7c7bb6e44
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_certconfig_no-public-key_12.4.56.0_x-ww_8c6c137c
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=certconfig
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_certconfig_no-public-key_12.4.56.0_x-ww_8c6c137c
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_certconfig_no-public-key_12.4.56.0_x-ww_8c6c137c.manifest
XP_MANIFEST_PATH=manifests\x86_certconfig_no-public-key_12.4.56.0_x-ww_8c6c137c.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_certconfig_no-public-key_12.4.56.0_x-ww_8c6c137c.cat
XP_CATALOG_PATH=manifests\x86_certconfig_no-public-key_12.4.56.0_x-ww_8c6c137c.cat
XP_PAYLOAD_PATH=x86_certconfig_no-public-key_12.4.56.0_x-ww_8c6c137c
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=certconfig,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\SiteConfig\CertConfig\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\SiteConfig\PartnerConfig\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\SiteConfig\CertConfig\CertConfig.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Security.AccessControl;
using System.Security.Cryptography.X509Certificates;
using System.Security.Principal;
using xonline.common.tools.console;
using System.Security.Cryptography;
using xonline.tools.deployment.siteconfig.common;

namespace xonline.tools.deployment.siteconfig.certconfig
{
    [ApplicationName("CertConfig")]
    [ApplicationDescription("CertConfig.exe verifies the existence of the " +
            "specified certificate file and updates SITE.XML.")]
    [ApplicationReturnDescription("On success, this tool returns 0 which " +
            "tells Octopus that the exection was successful.  Otherwise the " +
            "tool returns a non-zero value to indicate failure.")]
    class CertConfigParameters : CommandLineDefinition
    {
        [ParameterDescription("Specifies the path to SITE.xml.")]
        [ParameterRequired]
        public NamedParameter<String> Site = null;

        [ParameterRequired]
        [ParameterPosition(0)]
        [ParameterDescription("Identifier of the certificate in SITE.xml")]
        public PositionalParameter<String> CertId = null;

        [ParameterDescription("Specifies that CertConfig will only check " +
            "credentials but will not update site.xml")]
        public Flag Verify = null;

        [ParameterDescription("Specifies the PFX filename of the certificate. " +
            "Value will take two parameters, password and the path to the " +
            "certificate PFX file.  The second parameter is optional.")]
        [ParameterRequires("Component", "Property")]
        public Flag PFX = null;

        [ParameterDescription("Specifies the P7B file associated with this " +
            "certificate.  This property requires one parameter which is the " +
            "path to the P7B file.")]
        public Flag P7B = null;

        [ParameterDescription("Specifies the certificate trust list. This " +
            "property requires one parameter which is the path to the P7B " +
            "file")]
        public Flag CTL = null;

        [ParameterDescription("Causes the tool to do a full sanity check " +
            "for the certificate, i.e. checking the entire certificate " +
            "chain, and expiration date.  For modes other than /PFX, this " +
            "flag does nothing.")]
        [ParameterRequires("PFX")]
        public Flag FullCheck = null;

        [ParameterDescription("The name of the component in Octopus where all of " +
            "the users are defined.  This is required to determine if the user " +
            "specified a password.")]
        [ParameterRequires("PFX")]
        public NamedParameter<String> Component = null;

        [ParameterDescription("Name of the property which specifies the password " +
            "in service.xml.  This value is used to determine if the user specified " +
            "a password.")]
        [ParameterRequires("PFX")]
        public NamedParameter<String> Property = null;

        [ParameterRequired]
        [ParameterPosition(1)]
        [ParameterDescription("Path to the certificate file")]
        public PositionalParameter<String> CertFile = null;

        [ParameterPosition(2)]
        [ParameterDescription("Password for the PFX file")]
        public PositionalParameter<String> Password = null;
    }

    public class CertConfig
    {
        public static Boolean VerifyCertificate(X509Certificate2 certificate, out X509ChainStatus[] status)
        {
            X509Chain x509Chain = new X509Chain();
            x509Chain.ChainPolicy.VerificationFlags = X509VerificationFlags.IgnoreNotTimeValid;
            x509Chain.ChainPolicy.RevocationMode = X509RevocationMode.NoCheck;

            Boolean success = x509Chain.Build(certificate);
            status = x509Chain.ChainStatus;

            if (certificate.NotAfter < DateTime.Now)
                return false;

            return success;
        }
        public static int Main(String[] args)
        {
            CertConfigParameters parameters;

            try
            {
                // Parse the command line into PropCertParams
                if (!ArgReflector.Parse(out parameters, args))
                {
                    ArgReflector.DisplayUsage(out parameters);
                    return -1;
                }

                // Ensure that only one of /P7B, /PFX, and /CTL is specified
                int modes = 0;
                if (parameters.P7B.IsSet) modes++;
                if (parameters.PFX.IsSet) modes++;
                if (parameters.CTL.IsSet) modes++;
                if (modes != 1)
                {
                    Console.WriteLine("Only one of /PFX, /P7B, CTL may be specified.");

                    return -1;
                }

                // Check if we are being run from octopus.
                if (!File.Exists(Octopus.Log.CurrentDeployment.ConfigurationFile))
                {
                    Console.WriteLine("UserConfig must be run from Octopus!");
                    return -1;
                }

                // If the certfile is not specified, then bail happily
                if (!parameters.CertFile.IsSet || String.IsNullOrEmpty(parameters.CertFile.Value))
                {
                    return 4;
                }
                String certFile = parameters.CertFile.Value;

				// Ensure that the certFile specified is either a relative path
				// or is a UNC path to the certificate file.
				if( Path.IsPathRooted(certFile) 
						&& !certFile.StartsWith("\\\\") )
				{
					Console.WriteLine("The path to the certificate file must " +
							"either be a UNC path or specified relative to " +
							"the location of SITE.XML (setup_SecureUNC).");

					return 5;
				}

                // Make sure the path to the site.xml file exists.
                String setup_secureUNC = Path.GetDirectoryName(parameters.Site.Value);
                if (!Directory.Exists(setup_secureUNC))
                {
                    Console.WriteLine("The directory {0} does not exist.",
                        setup_secureUNC);
                    return 1;
                }

                // Make sure the certificate exists
                if (!File.Exists(certFile))
                {
                    // Try looking in the directory containing site.xml
                    certFile = Path.Combine(Path.GetDirectoryName(parameters.Site.Value), certFile);
                    if (!File.Exists(certFile))
                    {
                        Console.WriteLine("Could not find certificate file {0}.", parameters.CertFile.Value);
                        return 1;
                    }
                }
                
                // Attempt to access the specified site.xml.  
                SiteConfigData siteConfig = new SiteConfigData(parameters.Site.Value);

                // Attempt to get the certificate info for the certId. If it doesn't exist, 
                // create a new certificate, and populate it with the specified data.
                SiteConfigData.Certificate certInfo = siteConfig.GetCertificate(parameters.CertId.Value);
                if (certInfo == null)
                {
                    certInfo = new SiteConfigData.Certificate(parameters.CertId.Value);
                }

                // Handle PFX files
                if (parameters.PFX.IsSet)
                {
                    // Check Octopus to see if the user specified a password.  If so use what
                    // the user specified.  Relying on an empty password is not enough!
                    OctopusPropertyCollection properties = Octopus.GetComponentProperties(parameters.Component.Value);

                    // If the user specified a password, then use it. Otherwise use 
                    // whatever was specified.
                    if (properties[parameters.Property.Value] != null)
                    {
                        certInfo.Password = parameters.Password.Value;
                    }

                    // Attempt to access the password using the specified (or stored) password
                    X509Certificate2 certificate;
                    try
                    {
                        certificate = new X509Certificate2(certFile, certInfo.Password);
                    }
                    catch (CryptographicException ex)
                    {
                        Console.WriteLine(ex);
                        return 2;
                    }
        
                    // If a full check was requested, then verify the certificate chain
                    if (parameters.FullCheck.IsSet)
                    {
                        X509ChainStatus[] chainStatus;
                        if (!VerifyCertificate(certificate, out chainStatus))
                        {
                            Console.Error.WriteLine("Certificate verification failed. Possible causes are:");
                            foreach (X509ChainStatus status in chainStatus)
                            {
                                Console.Error.WriteLine("    {0,20}  {1}", status.Status, status.StatusInformation);
                            }

                            return 3;
                        }
                    }

                    // Update the certfile in site.xml
                    certInfo.File = parameters.CertFile.Value;
                }

                // Process P7B files.  No further checking is done beyond verify that they exist.
                if (parameters.P7B.IsSet)
                {
                    certInfo.P7BFile= parameters.CertFile.Value;
                }

                // Process CTL files.  No further checking is done beyond verify that they exist.
                if (parameters.CTL.IsSet)
                {
                    certInfo.CTLFile= parameters.CertFile.Value;
                }

                // Update Site.xml with the appropriate information
                if( !parameters.Verify.IsSet )
                {
                    siteConfig.UpdateCertificate(certInfo);
                    siteConfig.Save();
                }

                // Return success :)
                return 0;
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex);

                return 1;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\SiteConfig\BackupConfig\Program.cs ===
﻿using System;
using System.IO;

namespace xonline.tools.deployment.siteconfig.Backup
{
    class Program
    {
        static int Main(string[] args)
        {
            if (args.Length != 1)
            {
                Console.WriteLine("USAGE:");
                Console.WriteLine("   backup <filename>");
                Console.WriteLine();
                Console.WriteLine("   filename  name of the file to make a backup of");

                return -1;
            }

            try
            {
                String source = args[0];
				String destination;
				do
				{
					destination = String.Format("{0}.{1:yyyyMMddHHmmssfff}.bak", source, DateTime.Now);
				} while( File.Exists(destination) );

				Console.WriteLine("Backing {0} up as {1}", source, destination);


                File.Copy(source, destination);

                return 0;
            }
            catch (Exception ex)
            {
                Console.WriteLine("Backup failed with exception:");
                Console.WriteLine(ex);

                return -1;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\SiteConfig\PartnerConfig\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\SiteConfig\PartnerConfig\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\SiteConfig\PartnerConfig\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_partnerconfig_none_12.4.56.0_none_dc97aae365d951b3
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_partnerconfig_no-public-key_12.4.56.0_x-ww_c17864ad
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=partnerconfig
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_partnerconfig_no-public-key_12.4.56.0_x-ww_c17864ad
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_partnerconfig_no-public-key_12.4.56.0_x-ww_c17864ad.manifest
XP_MANIFEST_PATH=manifests\msil_partnerconfig_no-public-key_12.4.56.0_x-ww_c17864ad.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_partnerconfig_no-public-key_12.4.56.0_x-ww_c17864ad.cat
XP_CATALOG_PATH=manifests\msil_partnerconfig_no-public-key_12.4.56.0_x-ww_c17864ad.cat
XP_PAYLOAD_PATH=msil_partnerconfig_no-public-key_12.4.56.0_x-ww_c17864ad
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=partnerconfig,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\SiteConfig\PartnerConfig\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_partnerconfig_none_12.4.56.0_none_dc97aae365d951b3
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_partnerconfig_no-public-key_12.4.56.0_x-ww_c17864ad
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=partnerconfig
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_partnerconfig_no-public-key_12.4.56.0_x-ww_c17864ad
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_partnerconfig_no-public-key_12.4.56.0_x-ww_c17864ad.manifest
XP_MANIFEST_PATH=manifests\msil_partnerconfig_no-public-key_12.4.56.0_x-ww_c17864ad.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_partnerconfig_no-public-key_12.4.56.0_x-ww_c17864ad.cat
XP_CATALOG_PATH=manifests\msil_partnerconfig_no-public-key_12.4.56.0_x-ww_c17864ad.cat
XP_PAYLOAD_PATH=msil_partnerconfig_no-public-key_12.4.56.0_x-ww_c17864ad
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=partnerconfig,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\SiteConfig\UpdateNPDBUsers\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\SiteConfig\Common\SiteConfig.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Xml.Serialization;
using System.Xml;
using System.IO;

namespace xonline.tools.deployment.siteconfig.common
{
    public class SiteConfigData
    {
        public class User
        {
            public String Identifier;
            public String Name;
            public String Domain;
            public String Password;

            public User(String identifier)
            {
                Identifier = identifier;
            }

            public User(XmlNode xmlNode)
            {
                if (xmlNode.Attributes["Name"] != null)
                {
                    Name = xmlNode.Attributes["Name"].Value;
                }

                if (xmlNode.Attributes["Identifier"] != null)
                {
                    Identifier = xmlNode.Attributes["Identifier"].Value;
                }

                if (xmlNode["Password"] != null)
                {
                    Password = xmlNode["Password"].InnerText;
                }

                if (xmlNode.ParentNode.Attributes["Name"] != null)
                {
                    Domain = xmlNode.ParentNode.Attributes["Name"].Value;
                }
            }
        }

        public class Certificate
        {
            public String Identifier;
            public String File;
            public String Password;
            public String CTLFile;
            public String P7BFile;

            public Certificate(String identifier)
            {
                Identifier = identifier;
            }

            public Certificate(XmlNode xmlNode)
            {
                if (xmlNode.Attributes["Identifier"] != null)
                {
                    Identifier = xmlNode.Attributes["Identifier"].Value;
                }

                if (xmlNode.Attributes["File"] != null)
                {
                    File = xmlNode.Attributes["File"].Value;
                }

                if (xmlNode.Attributes["CTLFile"] != null)
                {
                    CTLFile = xmlNode.Attributes["CTLFile"].Value;
                }

                if (xmlNode.Attributes["P7BFile"] != null)
                {
                    P7BFile = xmlNode.Attributes["P7BFile"].Value;
                }

                if (xmlNode["Password"] != null)
                {
                    Password = xmlNode["Password"].InnerText;
                }
            }
        }

        public IEnumerable<String> UserRoles
        {
            get { return _users.Keys; }
        }

        public IEnumerable<String> Certificates
        {
            get { return _certificates.Keys; }
        }

        public SiteConfigData(String secureUNC)
        {
            _certificates = new SortedList<String, Certificate>();
            _users = new SortedList<String, User>();

            _siteConfigFile = secureUNC;

            XmlDocument _siteConfig = new XmlDocument();
            if (File.Exists(_siteConfigFile))
            {
                _siteConfig.Load(_siteConfigFile);
            }
            else
            {
                _siteConfig.LoadXml("<Site><Domain/><Certificates/></Site>");
            }

            foreach (XmlNode xmlNode in _siteConfig.SelectNodes("/Site/Domain/Account"))
            {
                User user = new User(xmlNode);

                if (!_users.ContainsKey(user.Identifier))
                {
                    _users.Add(user.Identifier, user);
                }
            }

            foreach (XmlNode xmlNode in _siteConfig.SelectNodes("/Site/Certificates/SSLCert"))
            {
                Certificate certificate = new Certificate(xmlNode);

                if (!_certificates.ContainsKey(certificate.Identifier))
                {
                    _certificates.Add(certificate.Identifier, certificate);
                }
            }
        }

        public void AddUser(User user)
        {
            _users.Add(user.Identifier, user);
        }

        public void UpdateUser(User user)
        {
            _users[user.Identifier] = user;
        }

        public User GetUser(String userId)
        {
            if (_users.ContainsKey(userId))
                return _users[userId];
            return null;
        }

        public void AddCertificate(Certificate cert)
        {
            _certificates.Add(cert.Identifier, cert);
        }

        public void UpdateCertificate(Certificate cert)
        {
            _certificates[cert.Identifier] = cert;
        }

        public Certificate GetCertificate(String certId)
        {
            if (_certificates.ContainsKey(certId))
                return _certificates[certId];
            return null;
        }

        public void Save()
        {
            Save(_siteConfigFile);
        }

        public void Save(String outfile)
        {
            XmlDocument siteCfg = new XmlDocument();


            if (File.Exists(outfile))
            {
                siteCfg.Load(outfile);
            }
            else
            {
                siteCfg.LoadXml("<Site />");
            }

            XmlNode siteNode = siteCfg.SelectSingleNode("/Site");

            foreach (String userId in _users.Keys)
            {
                User user = _users[userId];
                
                XmlNode domainNode = GetDomainNode(siteNode, user.Domain);

                XmlNode userNode = SelectObject(siteCfg, "/Site/Domain/Account[@Identifier='{0}']", user.Identifier);
                if (userNode == null)
                {
                    userNode = siteCfg.CreateElement("Account");
                    domainNode.AppendChild(userNode);
                }
                else
                {
                    if (userNode.ParentNode != domainNode)
                    {
                        if (userNode.ParentNode != null)
                        {
                            userNode.ParentNode.RemoveChild(userNode);
                        }
                        domainNode.AppendChild(userNode);
                    }
                }
                
                SetAttribute(userNode, "Identifier", user.Identifier);
                SetAttribute(userNode, "Name", user.Name);
                SetElement(userNode, "Password", user.Password);
            }

            XmlNode certNode = siteCfg.SelectSingleNode("/Site/Certificates");
            if (certNode == null)
            {
                certNode = siteCfg.CreateElement("Certificates");
                siteNode.AppendChild(certNode);
            }

            foreach (String certId in _certificates.Keys)
            {
                Certificate cert = _certificates[certId];

                XmlNode sslCertNode = SelectObject(siteCfg, "/Site/Certificates/SSLCert[@Identifier='{0}']", cert.Identifier);
                if (sslCertNode == null)
                {
                    sslCertNode = siteCfg.CreateElement("SSLCert");
                    certNode.AppendChild(sslCertNode);
                }

                SetAttribute(sslCertNode, "Identifier", cert.Identifier);
                SetAttribute(sslCertNode, "File", cert.File);
                SetAttribute(sslCertNode, "P7BFile", cert.P7BFile);
                SetAttribute(sslCertNode, "CTLFile", cert.CTLFile);
                SetElement(sslCertNode, "Password", cert.Password);
            }

            XmlWriterSettings settings = new XmlWriterSettings();
            settings.Indent = true;

            using (XmlWriter xmlWriter = XmlWriter.Create(outfile, settings))
            {
                siteCfg.WriteContentTo(xmlWriter);
            }
        }

        private XmlNode GetDomainNode(XmlNode siteNode, String domainName)
        {
            XmlNode lastDomainNode = null;
            foreach (XmlNode xmlNode in siteNode.ChildNodes)
            {
                if (xmlNode.Name == "Domain")
                {
                    lastDomainNode = xmlNode;

                    if (xmlNode.Attributes["Name"].Value.ToLower() == domainName.ToLower())
                    {
                        return xmlNode;
                    }
                }
            }
            
            XmlNode domainNode = siteNode.OwnerDocument.CreateElement("Domain");
            domainNode.Attributes.Append(siteNode.OwnerDocument.CreateAttribute("Name"));
            domainNode.Attributes["Name"].Value = domainName.ToUpper();
            siteNode.InsertAfter(domainNode, lastDomainNode);

            return domainNode;
        }

        private XmlNode SelectObject(XmlNode xmlRoot, String xpathFormat, params Object [] args)
        {
            String xpath = String.Format(xpathFormat, args);
            XmlNodeList xmlNodeList = xmlRoot.SelectNodes(xpath);

            if (xmlNodeList.Count == 0)
            {
                return null;
            }

            for (int duplicateIndex = 1; duplicateIndex < xmlNodeList.Count; duplicateIndex++)
            {
                XmlNode duplicateNode = xmlNodeList[duplicateIndex];
                if (duplicateNode.ParentNode != null)
                {
                    duplicateNode.ParentNode.RemoveChild(duplicateNode);
                }
            }

            return xmlNodeList[0];

        }

        private void SetElement(XmlNode xmlNode, String elementName, String value)
        {
            XmlElement xmlElement = xmlNode[elementName];

            if (xmlElement == null)
            {
                if (value == null)
                {
                    return;
                }

                xmlElement = xmlNode.OwnerDocument.CreateElement(elementName);
                xmlNode.AppendChild(xmlElement);
            }
            else
            {
                if (value == null)
                {
                    xmlNode.RemoveChild(xmlElement);
                    return;
                }
            }
            XmlCDataSection valueElement = xmlNode.OwnerDocument.CreateCDataSection(value);
            xmlElement.RemoveAll();
            xmlElement.AppendChild(valueElement);
        }

        private void SetAttribute(XmlNode xmlNode, String attributeName, String value)
        {
            XmlAttribute xmlAttribute = xmlNode.Attributes[attributeName];

            if (xmlAttribute == null)
            {
                if (value == null)
                {
                    return;
                }

                xmlAttribute = xmlNode.OwnerDocument.CreateAttribute(attributeName);
                xmlNode.Attributes.Append(xmlAttribute);
            }
            else
            {
                if (value == null)
                {
                    xmlNode.Attributes.Remove(xmlAttribute);
                    return;
                }
            }

            xmlAttribute.Value = value;
        }

        private SortedList<String, Certificate> _certificates;
        private SortedList<String, User> _users;
        private String _siteConfigFile;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\SiteConfig\UpdateNPDBUsers\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\SiteConfig\Common\Octopus.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Xml;

namespace xonline.tools.deployment.siteconfig.common
{
    public class OctopusPropertyCollection : IEnumerable<String>
    {
        public String this[String name]
        {
            get { return _properties.ContainsKey(name) ? _properties[name] : null; }
        }

        public int Count
        {
            get { return _properties.Count; }
        }

        public OctopusPropertyCollection(Dictionary<String, String> properties)
        {
            _properties = properties;
        }

        private Dictionary<String, String> _properties;

        public IEnumerator<string> GetEnumerator()
        {
            return _properties.Keys.GetEnumerator();
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return _properties.Keys.GetEnumerator();
        }
    }

    public static class Octopus
    {
        public static class Configuration
        {
            /// <summary>
            /// Corresponds to the releaseName attribute in the configuration file and also the release name chosen in the Configuration tab in Octopus GUI.
            /// </summary>
            public static String ChosenReleaseName = Environment.GetEnvironmentVariable("Octopus.Configuration.ChosenReleaseName");
            /// <summary>
            /// Corresponds to the log location value from the Configuration tab (and configuration file).
            /// </summary>
            public static String LogLocation = Environment.GetEnvironmentVariable("Octopus.Configuration.LogLocation");
            /// <summary>
            /// Corresponds to the service name from the Configuration tab (and service.xml files).
            /// </summary>
            public static String ServiceName = Environment.GetEnvironmentVariable("Octopus.Configuration.ServiceName");
            /// <summary>
            /// Corresponds to the source (build) location from the Configuration tab (and the configuration file).
            /// </summary>
            public static String SourceLocation = Environment.GetEnvironmentVariable("Octopus.Configuration.SourceLocation");
            /// <summary>
            /// The chosen topology name as in the Configuration tab/configuration file.
            /// </summary>
            public static String TopologyName = Environment.GetEnvironmentVariable("Octopus.Configuration.TopologyName");
        }

        public static class Controller
        {
            /// <summary>
            /// The name of the machine on which the Octopus Controller is running.
            /// </summary>
            public static String MachineName = Environment.GetEnvironmentVariable("Octopus.Controller.MachineName");
        }

        public static class CurrentCommand
        {
            /// <summary>
            /// Path to the local, temporary folder in which a command action executes on the target machine. Example C:\WINDOWS\TEMP\octtmp2
            /// </summary>
            public static String LocalFolder = Environment.GetEnvironmentVariable("Octopus.CurrentCommand.LocalFolder");
            /// <summary>
            /// The name (from the service.xml) of the currently executing command.
            /// </summary>
            public static String Name = Environment.GetEnvironmentVariable("Octopus.CurrentCommand.Name");
        }

        public static class CurrentRealease
        {
            /// <summary>
            /// The name of the release currently being deployed.
            /// </summary>
            public static String Name = Environment.GetEnvironmentVariable("Octopus.CurrentRelease.Name");
            /// <summary>
            /// Path of the folder which contains the service.xml file for the release currently being deployed.
            /// </summary>
            public static String SourceFolder = Environment.GetEnvironmentVariable("Octopus.CurrentRelease.Source.Folder");
        }

        public static class CurrentServer
        {
            /// <summary>
            /// List of roles assigned to this server.
            /// </summary>
            public static String[] Roles = Environment.GetEnvironmentVariable("Octopus.CurrentServer.RoleName[X]").Split(',');
        }

        public static class Log
        {
            public static class CurrentCommand
            {
                /// <summary>
                /// Log folder for the currently executing command.
                /// </summary>
                public static String Folder = Environment.GetEnvironmentVariable("Octopus.Log.CurrentCommand.Folder");
            }

            public static class CurrentDeployment
            {
                /// <summary>
                /// Path to a copy of the configuration file used for the current deployment.
                /// </summary>
                public static String ConfigurationFile = Environment.GetEnvironmentVariable("Octopus.Log.CurrentDeployment.ConfigurationFile");
                /// <summary>
                /// Path to the deploymentSession.xml file, which is the main Octopus xml file. This is the file you see when you press the "Common Log" button.
                /// </summary>
                public static String File = Environment.GetEnvironmentVariable("Octopus.Log.CurrentDeployment.File");
                /// <summary>
                /// Log folder of the currently executing deployment. Example: \\msnocttsta\OctopusSamplesLogs\2003-12-03_10-56-19
                /// </summary>
                public static String Folder = Environment.GetEnvironmentVariable("Octopus.Log.CurrentDeployment.Folder");
            }

            public static class CurrentRelease
            {
                /// <summary>
                /// Log folder for the currently executing command.
                /// </summary>
                public static String Folder = Environment.GetEnvironmentVariable("Octopus.Log.CurrentRelease.Folder");
            }

            public static class CurrentServer
            {
                /// <summary>
                /// Path to the serverSession.xml file for the current server. Example: \\msnocttsta\OctopusSamplesLogs\2003-12-03_10-56-19\msnocttsta\serverSession.xml
                /// </summary>
                public static String File = Environment.GetEnvironmentVariable("Octopus.Log.CurrentServer.File");
                /// <summary>
                /// Log folder for the current server. Example: \\msnocttsta\OctopusSamplesLogs\2003-12-03_10-56-19\msnocttsta
                /// </summary>
                public static String Folder = Environment.GetEnvironmentVariable("Octopus.Log.CurrentServer.Folder");
            }
            /// <summary>
            /// Path to the deployment history file located in the log location. Example: \\msnocttsta\OctopusSamplesLogs\Octopus.Log.history.xml
            /// </summary>
            public static String HistoryFile = Environment.GetEnvironmentVariable("Octopus.Log.HistoryFile");
        }

        public static String DeploymentType = Environment.GetEnvironmentVariable("Octopus.DeploymentType");

        public static OctopusPropertyCollection GetComponentProperties(String component)
        {
            Dictionary<String, String> properties = new Dictionary<String, String>();
            String queryBase = "/DeploymentInstance/ComponentConfiguration[@name=\"{0}\"]/PropertyValue";
            String[] propertyLevels = new String[] { 
                "<service level properties>",
                "<topology level properties>",
                component
            };

            foreach (String propertyLevel in propertyLevels)
            {
                String xpath = String.Format(queryBase, propertyLevel);
                foreach (XmlNode xmlNode in _xmlDocument.SelectNodes(xpath))
                {
                    String name = xmlNode.Attributes["name"].Value;
                    String value = xmlNode.Attributes["value"].Value;

                    properties[name] = value;
                }
            }

            return new OctopusPropertyCollection(properties);
        }

        private static XmlDocument _xmlDocument {
            get
            {
                if (_xmlDocumentObject == null)
                {
                    _xmlDocumentObject = new XmlDocument();
                    _xmlDocumentObject.Load(Log.CurrentDeployment.ConfigurationFile);
                } 
                
                return _xmlDocumentObject;
            }
        }

        private static XmlDocument _xmlDocumentObject;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\SiteConfig\UpdateNPDBUsers\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_updatenpdbusers_none_12.4.56.0_none_164e7c8806395923
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_updatenpdbusers_no-public-key_12.4.56.0_x-ww_184d2cd5
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=updatenpdbusers
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_updatenpdbusers_no-public-key_12.4.56.0_x-ww_184d2cd5
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_updatenpdbusers_no-public-key_12.4.56.0_x-ww_184d2cd5.manifest
XP_MANIFEST_PATH=manifests\x86_updatenpdbusers_no-public-key_12.4.56.0_x-ww_184d2cd5.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_updatenpdbusers_no-public-key_12.4.56.0_x-ww_184d2cd5.cat
XP_CATALOG_PATH=manifests\x86_updatenpdbusers_no-public-key_12.4.56.0_x-ww_184d2cd5.cat
XP_PAYLOAD_PATH=x86_updatenpdbusers_no-public-key_12.4.56.0_x-ww_184d2cd5
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=updatenpdbusers,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\SiteConfig\UpdateNPDBUsers\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\SiteConfig\PartnerConfig\Program.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using xonline.common.tools.console;
using System.Runtime.InteropServices;
using System.DirectoryServices;
using System.IO;
using System.Data.SqlClient;
using xonline.common.config;
using System.Data;
using System.Xml;
using System.Data.SqlTypes;
using System.Reflection;
using System.Xml.Schema;

namespace xonline.tools.deployment.siteconfig.pacdconfig
{
    [ApplicationName("PACDConfig.exe")]
    [ApplicationDescription("")]
    [ApplicationReturnDescription("")]
    class PACDConfigParameters : CommandLineDefinition
    {
        public Flag Update = null;
        public Flag Sync = null;

        [ParameterRequired]
        [ParameterPosition(0)]
        [ParameterDescription("filename to use for import/sync")]
        public PositionalParameter<String> FileName = null;
    }

    class Program
    {

        static int Main(string[] args)
        {
            PACDConfigParameters parameters;

            if (!Config.IsTestEnvironment())
            {
                Console.WriteLine("Running in a non-test environment.  Exiting ...");
                return 0;
            }

            try
            {
                // Parse the command line into the parameters variable
                if (!ArgReflector.Parse(out parameters, args))
                {
                    ArgReflector.DisplayUsage(out parameters);
                    return -1;
                }

                int modeCount = 0;
                if (parameters.Update.IsSet) modeCount++;
                if (parameters.Sync.IsSet) modeCount++;

                if (modeCount != 1)
                {
                    Console.WriteLine("Invalid flag passed.");
                    ArgReflector.DisplayUsage(out parameters);
                    return -1;
                }

                IInterfaceInfo webdbInterface = Config.GetSingleInterface(Interface.webdb);
                String connectionString = String.Format("Data Source={0};Initial Catalog={1};Integrated Security=True",
                    webdbInterface.ServerName, webdbInterface.DBName);

                using (SqlConnection connection = new SqlConnection(connectionString))
                {
                    SqlCommand command = new SqlCommand();
                    connection.Open();

                    SqlTransaction transaction = connection.BeginTransaction();
                    try
                    {
                        if (parameters.Sync.IsSet)
                        {
                            Console.WriteLine("Clearing");
                            command.Connection = connection;
                            command.CommandText = "p_webdb_pacd_clear";
                            command.CommandType = CommandType.StoredProcedure;
                            command.Transaction = transaction;
                            command.ExecuteNonQuery();
                        }

                        // HACK: Please FIX X360CS 25704 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                        // All of this is to work around the fact that PartnerMgr currently exports
                        // the Partner Access Control data in both the http://www.xboxlive.com namespace
                        // and the empty namespace.  This is tracked by Xbox 360 Console Software bug 25704.
                        // HACK: Please FIX X360CS 25704 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                        using (MemoryStream memoryStream = new MemoryStream())
                        {
                            using (StreamReader streamReader = new StreamReader(parameters.FileName.Value))
                            {
                                using (StreamWriter streamWriter = new StreamWriter(memoryStream))
                                {
                                    String line;

                                    while ((line = streamReader.ReadLine()) != null)
                                    {
                                        line = line.Replace("xmlns=\"\"", "");
                                        streamWriter.WriteLine(line);
                                    }
                                    streamWriter.Flush();
                                    memoryStream.Seek(0, SeekOrigin.Begin);

                                    XmlReaderSettings xmlReaderSettings = new XmlReaderSettings();
                                    using (Stream resourceStream =
                                            Assembly.GetExecutingAssembly().GetManifestResourceStream("PartnerConfig.xsd"))
                                    {
                                        using (XmlReader xmlSchemaReader = XmlReader.Create(resourceStream))
                                        {
                                            xmlReaderSettings.Schemas.Add(XmlSchema.Read(xmlSchemaReader, null));
                                            xmlReaderSettings.ValidationType = ValidationType.Schema;
                                        }
                                    }

                                    using (XmlReader xmlReader = XmlReader.Create(memoryStream, xmlReaderSettings))
                                    {
                                        Console.WriteLine("Importing");
                                        SqlXml pacdXml = new SqlXml(xmlReader);
                                        command.Connection = connection;
                                        command.CommandText = "p_webdb_pacd_import";
                                        command.CommandType = CommandType.StoredProcedure;
                                        command.Parameters.Add("@pacd_data", SqlDbType.Xml).Value = pacdXml;
                                        command.Transaction = transaction;
                                        command.ExecuteNonQuery();
                                    }
                                }
                            }
                        }
                        transaction.Commit();

                        Console.WriteLine("Done.");
                    }
                    catch
                    {
                        transaction.Rollback();
                        throw;
                    }
                }

                return 0;
            }
            catch (Exception ex)
            {
                // Write the exception to the deployment log, and exit with "failure unknown"
                Console.WriteLine(ex);
                return -1;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\SiteConfig\UserConfig\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\SiteConfig\UpdateNPDBUsers\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_updatenpdbusers_none_12.4.56.0_none_164e7c8806395923
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_updatenpdbusers_no-public-key_12.4.56.0_x-ww_184d2cd5
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=updatenpdbusers
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_updatenpdbusers_no-public-key_12.4.56.0_x-ww_184d2cd5
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_updatenpdbusers_no-public-key_12.4.56.0_x-ww_184d2cd5.manifest
XP_MANIFEST_PATH=manifests\x86_updatenpdbusers_no-public-key_12.4.56.0_x-ww_184d2cd5.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_updatenpdbusers_no-public-key_12.4.56.0_x-ww_184d2cd5.cat
XP_CATALOG_PATH=manifests\x86_updatenpdbusers_no-public-key_12.4.56.0_x-ww_184d2cd5.cat
XP_PAYLOAD_PATH=x86_updatenpdbusers_no-public-key_12.4.56.0_x-ww_184d2cd5
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=updatenpdbusers,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\SiteConfig\UpdateNPDBUsers\Program.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Data.SqlClient;
using System.Data;
using System.Xml;
using xonline.common.tools.console;
using System.IO;
using xonline.tools.deployment.siteconfig.common;
using System.Text.RegularExpressions;
using System.Security.Cryptography.X509Certificates;

namespace xonline.tools.deployment.siteconfig.UpdateNPDBUsers
{
    [ApplicationName("UpdateNPDBUsers")]
    [ApplicationDescription("Updates the t_environment_user_roles table in NPDB " +
        "from Octopus.")]
    class UpdateNPDBUsersParameters : CommandLineDefinition
    {
        [ParameterRequired]
        [ParameterPosition(0)]
        [ParameterDescription("Path to SITE.xml")]
        public PositionalParameter<String> Site = null;
    }
    class Program
    {
        static String GetCertificateCommonName(X509Certificate2 certificate)
        {
            // Break the Distinguished Name of the certificate up into pieces
            String[] nameParts = certificate.SubjectName.Decode(
            X500DistinguishedNameFlags.UseNewLines).Split('\n');

            // Look for the CN (Common Name) component of the distinguished name.
            foreach (String namePart in nameParts)
            {
                String[] tuple = namePart.Split('=');
                if (tuple[0].Trim() == "CN")
                {
                    return tuple[1].Trim();
                }
            }

            throw new Exception("Certificate does not have a Common Name.  The name specified was \"" + 
                certificate.Subject + "\".");
        }

        static int Main(string[] args)
        {
            UpdateNPDBUsersParameters parameters;

            try
            {
                // Parse the command line
                if (!ArgReflector.Parse(out parameters, args))
                {
                    Console.Error.WriteLine("Invalid parameters");
                    ArgReflector.DisplayUsage(out parameters);
                    return -1;
                }

                // Make sure we are running from Octopus.
                if (!File.Exists(Octopus.Log.CurrentDeployment.ConfigurationFile))
                {
                    Console.WriteLine("This tool MUST be run from within Octopus!");
                    return -1;
                }


                // Make sure the directory containing Site.xml exists
                String fullSitePath = Path.GetFullPath(parameters.Site.Value);
                String setup_secureUNC = Path.GetDirectoryName(fullSitePath);
                if (!Directory.Exists(setup_secureUNC))
                {
                    Console.WriteLine("The directory {0} does not exist.",
                        setup_secureUNC);
                    return 1;
                }

                // Make sure SITE.xml exists
                if (!File.Exists(fullSitePath))
                {
                    Console.WriteLine("The file {0} does not exist.",
                        parameters.Site.Value);
                    return 1;
                }                

                // Update the setup_secureUNC setting
                NPDB.UpdateEnvironmentSettingOverride("setup_secureUNC",
                    setup_secureUNC);

                // Open the Site.xml
                SiteConfigData siteConfig = new SiteConfigData(parameters.Site.Value);

                // Walk the file for data
                foreach (String userRole in siteConfig.UserRoles)
                {
                    SiteConfigData.User user = siteConfig.GetUser(userRole);
                    String userName = user.Domain + "\\" + user.Name;

                    // Update NPDB
                    try
                    {
                        NPDB.UpdateEnvironmentUserRole(user.Identifier, userName, user.Identifier);
                    }
                    catch
                    {
                        // UpdateEnvironmentUserRole failed, so add the role and try again
                        NPDB.AddUserRole(user.Identifier);
                        NPDB.UpdateEnvironmentUserRole(user.Identifier, userName, user.Identifier);
                    }
                }

                // Get the cert.spgclient certificate
                SiteConfigData.Certificate spgCertInfo = siteConfig.GetCertificate("cert.spgclient");
                if( spgCertInfo == null )
                {
                    Console.WriteLine("No certificate is defined for cert.spgclient");
                    return 1;
                }

                // Get the Certificate
                X509Certificate2 spgCert = new X509Certificate2(
                    Path.Combine(setup_secureUNC, spgCertInfo.File),
					spgCertInfo.Password);

                // Update t_setting_overrides for cert.spgclient
                NPDB.UpdateEnvironmentSettingOverride("dmp_clientCertSubject",
                    GetCertificateCommonName(spgCert));

                return 0;
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex);
                return -1;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\SiteConfig\UpdateNPDBUsers\NPDB.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Data.SqlClient;
using System.Data;
using System.IO;
using xonline.common.config;

namespace xonline.tools.deployment.siteconfig.UpdateNPDBUsers
{
    public static class NPDB
    {
        public static String CurrentEnvironment
        {
            get
            {
                if (_currentEnvironment == null)
                {
                    using (SqlConnection connection = new SqlConnection(Config.NpdbConnectionString))
                    {
                        using (SqlCommand command = connection.CreateCommand())
                        {
                            command.CommandText = "p_config_get_current_environment"; 
                            command.CommandType = CommandType.StoredProcedure;

                            connection.Open();
                            using (SqlDataReader reader = command.ExecuteReader())
                            {
                                if (!reader.HasRows || !reader.Read())
                                {
                                    throw new Exception("No current environment is set!");
                                }

                                _currentEnvironment = reader.GetString(0);
                            }
                        }
                    }
                }

                return _currentEnvironment;
            }
        }
        public static int UpdateEnvironmentSettingOverride(String setting, String value)
        {
            // call p_config_add_setting_override(setting, value, CurrentEnvironment, "ALL", -1, "ALL", true);
            // Initialize the SqlCommand
            SqlCommand command = new SqlCommand();
            try
            {
                command.Connection = new SqlConnection(Config.NpdbConnectionString);
                command.CommandType = CommandType.StoredProcedure;
                command.CommandText = "p_config_add_setting_override";
                command.Connection.Open();

                // Define setting
                SqlParameter prm_setting = new SqlParameter("@setting", SqlDbType.NVarChar);
                prm_setting.Direction = ParameterDirection.Input;
                prm_setting.Value = setting;
                command.Parameters.Add(prm_setting);

                // Define value
                SqlParameter prm_value = new SqlParameter("@value", SqlDbType.NVarChar);
                prm_value.Direction = ParameterDirection.Input;
                prm_value.Value = value;
                command.Parameters.Add(prm_value);

                // Define environment
                SqlParameter prm_environment = new SqlParameter("@environment", SqlDbType.NVarChar);
                prm_environment.Direction = ParameterDirection.Input;
                prm_environment.Value = CurrentEnvironment;
                command.Parameters.Add(prm_environment);

                // Define component
                SqlParameter prm_component = new SqlParameter("@component", SqlDbType.NVarChar);
                prm_component.Direction = ParameterDirection.Input;
                prm_component.Value = "ALL";
                command.Parameters.Add(prm_component);

                // Define siteId
                SqlParameter prm_siteId = new SqlParameter("@siteId", SqlDbType.Int);
                prm_siteId.Direction = ParameterDirection.Input;
                prm_siteId.Value = -1;
                command.Parameters.Add(prm_siteId);

                // Define server
                SqlParameter prm_server = new SqlParameter("@server", SqlDbType.NVarChar);
                prm_server.Direction = ParameterDirection.Input;
                prm_server.Value = "ALL";
                command.Parameters.Add(prm_server);

                // Define overwriteExistingValue
                SqlParameter prm_overwriteExistingValue = new SqlParameter("@overwriteExistingValue", SqlDbType.Bit);
                prm_overwriteExistingValue.Direction = ParameterDirection.Input;
                prm_overwriteExistingValue.Value = true;
                command.Parameters.Add(prm_overwriteExistingValue);

                // Define a SqlParameter to get the return value
                SqlParameter prm_return = new SqlParameter("@RETURN_VALUE", SqlDbType.Int, 4);
                prm_return.Direction = ParameterDirection.ReturnValue;
                command.Parameters.Add(prm_return);

                // Execute
                command.ExecuteNonQuery();

                // Collect the results


                return ((int)(prm_return.Value));
            }
            finally
            {
                command.Connection.Close();
            }
        }


        public static int UpdateEnvironmentUserRole(String userRole, String userName, String password)
        {
            // Call p_config_add_environment_user_role(CurrentEnvironment, userRole, userName, password, true);
            // Initialize the SqlCommand
            SqlCommand command = new SqlCommand();
            try
            {
                command.Connection = new SqlConnection(Config.NpdbConnectionString);
                command.CommandType = CommandType.StoredProcedure;
                command.CommandText = "p_config_add_environment_user_role";
                command.Connection.Open();

                // Define environment
                SqlParameter prm_environment = new SqlParameter("@environment", SqlDbType.NVarChar);
                prm_environment.Direction = ParameterDirection.Input;
                prm_environment.Value = CurrentEnvironment;
                command.Parameters.Add(prm_environment);

                // Define userRole
                SqlParameter prm_userRole = new SqlParameter("@userRole", SqlDbType.NVarChar);
                prm_userRole.Direction = ParameterDirection.Input;
                prm_userRole.Value = userRole;
                command.Parameters.Add(prm_userRole);

                // Define userName
                SqlParameter prm_userName = new SqlParameter("@userName", SqlDbType.NVarChar);
                prm_userName.Direction = ParameterDirection.Input;
                prm_userName.Value = userName;
                command.Parameters.Add(prm_userName);

                // Define password
                SqlParameter prm_password = new SqlParameter("@password", SqlDbType.NVarChar);
                prm_password.Direction = ParameterDirection.Input;
                prm_password.Value = password;
                command.Parameters.Add(prm_password);

                // Define overwriteExistingValue
                SqlParameter prm_overwriteExistingValue = new SqlParameter("@overwriteExistingValue", SqlDbType.Bit);
                prm_overwriteExistingValue.Direction = ParameterDirection.Input;
                prm_overwriteExistingValue.Value = true;
                command.Parameters.Add(prm_overwriteExistingValue);

                // Define a SqlParameter to get the return value
                SqlParameter prm_return = new SqlParameter("@RETURN_VALUE", SqlDbType.Int, 4);
                prm_return.Direction = ParameterDirection.ReturnValue;
                command.Parameters.Add(prm_return);

                // Execute
                command.ExecuteNonQuery();

                // Collect the results


                return ((int)(prm_return.Value));
            }
            finally
            {
                command.Connection.Close();
            }
        }

        public static int AddUserRole(String userRole)
        {
           // Call p_config_add_environment_user_role(CurrentEnvironment, userRole, userName, password, true);
           // Initialize the SqlCommand
           SqlCommand command = new SqlCommand();
           try
           {
              command.Connection = new SqlConnection(Config.NpdbConnectionString);
              command.CommandType = CommandType.StoredProcedure;
              command.CommandText = "p_config_add_user_role";
              command.Connection.Open();

              // Define userRole
              SqlParameter prm_userRole = new SqlParameter("@userRole", SqlDbType.NVarChar);
              prm_userRole.Direction = ParameterDirection.Input;
              prm_userRole.Value = userRole;
              command.Parameters.Add(prm_userRole);

              // Define a SqlParameter to get the return value
              SqlParameter prm_return = new SqlParameter("@RETURN_VALUE", SqlDbType.Int, 4);
              prm_return.Direction = ParameterDirection.ReturnValue;
              command.Parameters.Add(prm_return);

              // Execute
              command.ExecuteNonQuery();

              // Collect the results


              return ((int)(prm_return.Value));
           }
           finally
           {
              command.Connection.Close();
           }
        }

        private static String _currentEnvironment = null;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\SiteConfig\UserConfig\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\SiteConfig\UserConfig\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_userconfig_none_12.4.56.0_none_609b49721e97db8d
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_userconfig_no-public-key_12.4.56.0_x-ww_6d1c48c3
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=userconfig
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_userconfig_no-public-key_12.4.56.0_x-ww_6d1c48c3
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_userconfig_no-public-key_12.4.56.0_x-ww_6d1c48c3.manifest
XP_MANIFEST_PATH=manifests\x86_userconfig_no-public-key_12.4.56.0_x-ww_6d1c48c3.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_userconfig_no-public-key_12.4.56.0_x-ww_6d1c48c3.cat
XP_CATALOG_PATH=manifests\x86_userconfig_no-public-key_12.4.56.0_x-ww_6d1c48c3.cat
XP_PAYLOAD_PATH=x86_userconfig_no-public-key_12.4.56.0_x-ww_6d1c48c3
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=userconfig,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\SiteConfig\UserConfig\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_userconfig_none_12.4.56.0_none_609b49721e97db8d
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_userconfig_no-public-key_12.4.56.0_x-ww_6d1c48c3
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=userconfig
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_userconfig_no-public-key_12.4.56.0_x-ww_6d1c48c3
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_userconfig_no-public-key_12.4.56.0_x-ww_6d1c48c3.manifest
XP_MANIFEST_PATH=manifests\x86_userconfig_no-public-key_12.4.56.0_x-ww_6d1c48c3.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_userconfig_no-public-key_12.4.56.0_x-ww_6d1c48c3.cat
XP_CATALOG_PATH=manifests\x86_userconfig_no-public-key_12.4.56.0_x-ww_6d1c48c3.cat
XP_PAYLOAD_PATH=x86_userconfig_no-public-key_12.4.56.0_x-ww_6d1c48c3
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=userconfig,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\SiteConfig\UserConfig\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\XblCustomActions\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\SiteConfig\UserConfig\Win32.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Runtime.InteropServices;

namespace xonline.tools.deployment.siteconfig.userconfig
{
    public static class Win32
    {
        public enum LogonType : int
        {
            /// <summary>
            /// This logon type is intended for users who will be interactively using the computer, such as a user being logged on  
            /// by a terminal server, remote shell, or similar process.
            /// This logon type has the additional expense of caching logon information for disconnected operations; 
            /// therefore, it is inappropriate for some client/server applications,
            /// such as a mail server.
            /// </summary>
            LOGON32_LOGON_INTERACTIVE = 2,

            /// <summary>
            /// This logon type is intended for high performance servers to authenticate plaintext passwords.

            /// The LogonUser function does not cache credentials for this logon type.
            /// </summary>
            LOGON32_LOGON_NETWORK = 3,

            /// <summary>
            /// This logon type is intended for batch servers, where processes may be executing on behalf of a user without 
            /// their direct intervention. This type is also for higher performance servers that process many plaintext
            /// authentication attempts at a time, such as mail or Web servers. 
            /// The LogonUser function does not cache credentials for this logon type.
            /// </summary>
            LOGON32_LOGON_BATCH = 4,

            /// <summary>
            /// Indicates a service-type logon. The account provided must have the service privilege enabled. 
            /// </summary>
            LOGON32_LOGON_SERVICE = 5,

            /// <summary>
            /// This logon type is for GINA DLLs that log on users who will be interactively using the computer. 
            /// This logon type can generate a unique audit record that shows when the workstation was unlocked. 
            /// </summary>
            LOGON32_LOGON_UNLOCK = 7,

            /// <summary>
            /// This logon type preserves the name and password in the authentication package, which allows the server to make 
            /// connections to other network servers while impersonating the client. A server can accept plaintext credentials 
            /// from a client, call LogonUser, verify that the user can access the system across the network, and still 
            /// communicate with other servers.
            /// NOTE: Windows NT:  This value is not supported. 
            /// </summary>
            LOGON32_LOGON_NETWORK_CLEARTEXT = 8,

            /// <summary>
            /// This logon type allows the caller to clone its current token and specify new credentials for outbound connections.
            /// The new logon session has the same local identifier but uses different credentials for other network connections. 
            /// NOTE: This logon type is supported only by the LOGON32_PROVIDER_WINNT50 logon provider.
            /// NOTE: Windows NT:  This value is not supported. 
            /// </summary>
            LOGON32_LOGON_NEW_CREDENTIALS = 9,
        }

        public enum LogonProvider : int
        {
            /// <summary>
            /// Use the standard logon provider for the system. 
            /// The default security provider is negotiate, unless you pass NULL for the domain name and the user name 
            /// is not in UPN format. In this case, the default provider is NTLM. 
            /// NOTE: Windows 2000/NT:   The default security provider is NTLM.
            /// </summary>
            LOGON32_PROVIDER_DEFAULT = 0,
        }
        [DllImport("advapi32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool LogonUser(
            string lpszUsername,
            string lpszDomain,
            string lpszPassword,
            int dwLogonType,
            int dwLogonProvider,
            out IntPtr phToken
            );
        [DllImport("Kernel32.dll", SetLastError = true, CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Auto)]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool CloseHandle(IntPtr hObject);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\SiteConfig\UserConfig\Program.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using xonline.common.tools.console;
using System.Runtime.InteropServices;
using xonline.tools.deployment.siteconfig.common;
using System.DirectoryServices;
using System.IO;

namespace xonline.tools.deployment.siteconfig.userconfig
{
    [ApplicationName("UserConfig.exe")]
    [ApplicationDescription("UserConfig is a command line tool which verifies " +
        "user existence, and verifies user credentials. This tool also " +
        "updates SITE.xml with the correct password data if an updated " +
        "password is specified.")]
    [ApplicationReturnDescription("On success, this tool returns 0 which " +
        "tells Octopus that the exection was successful.  Otherwise the tool " +
        "returns a non-zero value to indicate failure.\nA return value of -1, " +
        "indicates that either the failure is unknown, or should not happen " +
        "under normal circumstances. A return code of 1 indicates that the " +
        "user does not exist, and a return code of 2 indicates a login failure ")]
    class UserConfigParameters : CommandLineDefinition
    {
        [ParameterDescription("Specifies the path to SITE.xml. If this " +
            "parameter is not specified, setup_SecureUNC is used to find " +
            "site.xml.")]
        [ParameterRequired]
        public NamedParameter<String> Site = null;

        [ParameterDescription("Specifies that UserConfig will only check " +
            "credentials but will not update site.xml")]
        public Flag Verify = null;

        [ParameterRequired]
        [ParameterPosition(0)]
        [ParameterDescription("User Role to look for in SITE.xml")]
        public PositionalParameter<String> UserRole = null;

        [ParameterRequired]
        [ParameterPosition(1)]
        [ParameterDescription("User\'s domain. For local users this is " +
            "the computer name")]
        public PositionalParameter<String> Domain = null;

        [ParameterRequired]
        [ParameterPosition(2)]
        [ParameterDescription("UserName")]
        public PositionalParameter<String> UserName = null;

        [ParameterRequired]
        [ParameterPosition(3)]
        [ParameterDescription("User\'s password")]
        public PositionalParameter<String> Password = null;
    }

    class Program
    {
        /// <summary>
        /// Check if the user exists in the given directory.
        /// </summary>
        /// <param name="domain">Domain to check.  This can be either the local computer name, or a domain name.</param>
        /// <param name="userName">Username to search for.</param>
        /// <returns>true if successful, false otherwise</returns>
        static Boolean UserExists(String domain, String userName)
        {
            try
            {
                DirectoryEntry directory = new DirectoryEntry("WinNT://" + domain);
                directory.Children.Find(userName, "user");
                return true;
            }
            catch
            {
                return false;
            }
        }

        /// <summary>
        /// Checks the user's credentials.
        /// </summary>
        /// <param name="domain">Domain or Computer containing the user who's credentials need verification</param>
        /// <param name="userName">Username to check.</param>
        /// <param name="password">User's Password credential.</param>
        /// <returns></returns>
        static Boolean UserCredentialsValid(String domain, String userName, String password)
        {
            IntPtr hUserToken;
            Boolean bSuccess;

            // Attempt to login for impersonation, and save the status
            bSuccess = Win32.LogonUser(
                userName, domain, password,
                (int)Win32.LogonType.LOGON32_LOGON_NETWORK,
                (int)Win32.LogonProvider.LOGON32_PROVIDER_DEFAULT,
                out hUserToken);

            // Close the returned handle regardless of success.  This 
            // call should not throw regardless of the state of the 
            // user token.
            Win32.CloseHandle(hUserToken);

            // Return the result of the login.  If it was successful, 
            // then the credentials are assumed to be valid.
            return bSuccess;
        }


        static int Main(string[] args)
        {
            UserConfigParameters parameters;

            try
            {
                // Parse the command line into the parameters variable
                if (!ArgReflector.Parse(out parameters, args))
                {
                    ArgReflector.DisplayUsage(out parameters);
                    return -1;
                }

                // Check if we are being run from octopus.
                if( !File.Exists(Octopus.Log.CurrentDeployment.ConfigurationFile) )
                {
                    Console.WriteLine("UserConfig must be run from Octopus!");
                    return -1;
                }

                // Attempt to access the specified site.xml.  
                SiteConfigData siteConfig = new SiteConfigData(parameters.Site.Value);

                // Attempt to get the user info for the user role. If it doesn't exist, 
                // create a new user role, and populate it with the specified data.
                SiteConfigData.User userInfo = siteConfig.GetUser(parameters.UserRole.Value);
                if (userInfo == null)
                {
                    userInfo = new SiteConfigData.User(parameters.UserRole.Value);
                }

                // If the user specified a password, then use it. Otherwise use 
                // whatever was specified.
                if (!String.IsNullOrEmpty(parameters.Password.Value ))
                {
                    userInfo.Password = parameters.Password.Value;
                }

                // Pave over the old values since this is only saved if the data
                // is valid, and the Domain and Username are required parameters 
                // in Octopus.
                userInfo.Domain = parameters.Domain.Value;
                userInfo.Name = parameters.UserName.Value;

                // Check if the user exists
                if (!UserExists(userInfo.Domain, userInfo.Name))
                {
                    Console.WriteLine("Invalid username or password");
                    return 2;
                }

                // Check the user's login info
                if (!UserCredentialsValid(userInfo.Domain, userInfo.Name, userInfo.Password))
                {
                    Console.WriteLine("Invalid username or password");
                    return 2;
                }

                // Update Site.xml with the appropriate information
                if( !parameters.Verify.IsSet )
				{
					siteConfig.UpdateUser(userInfo);
					siteConfig.Save();
				}

                // Return success :)
                return 0;
            }
            catch (Exception ex)
            {
                // Write the exception to the deployment log, and exit with "failure unknown"
                Console.WriteLine(ex);
                return -1;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\XblCustomActions\XblCustomActions.cpp ===
#include "XblCustomActions.h"

HINSTANCE g_hInstance;

BOOLEAN WINAPI DllMain(HINSTANCE hDllHandle, DWORD nReason, LPVOID Reserved) {
   g_hInstance = hDllHandle;

   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\XblCustomActions\XblCustomActions.h ===
#ifndef __MSI_LOGGING_UTIL_H__
#define __MSI_LOGGING_UTIL_H__

#include <windows.h>
#include <shlobj.h>

#include <stdio.h>

#include <tchar.h>
#include "MsiUtilities.h"

#define MSIEXPORT                               extern "C" UINT __stdcall
#define SAFE_DELETE(x)                          { if (x) { delete (x); (x) = NULL; } }
#define SAFE_DELETE_A(x)                        { if (x) { delete [] (x); (x) = NULL; } }

extern HINSTANCE g_hInstance;

///
MSIEXPORT XblExpandFQDN(MSIHANDLE hInstall);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\XblCustomActions\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xblcustomactions_none_12.4.56.0_none_879f9e13df65c6a0
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xblcustomactions_no-public-key_12.4.56.0_x-ww_796de6a0
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xblcustomactions
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xblcustomactions_no-public-key_12.4.56.0_x-ww_796de6a0
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xblcustomactions_no-public-key_12.4.56.0_x-ww_796de6a0.manifest
XP_MANIFEST_PATH=manifests\x86_xblcustomactions_no-public-key_12.4.56.0_x-ww_796de6a0.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xblcustomactions_no-public-key_12.4.56.0_x-ww_796de6a0.cat
XP_CATALOG_PATH=manifests\x86_xblcustomactions_no-public-key_12.4.56.0_x-ww_796de6a0.cat
XP_PAYLOAD_PATH=x86_xblcustomactions_no-public-key_12.4.56.0_x-ww_796de6a0
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xblcustomactions,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\XblCustomActions\MsiUtilities.cpp ===
#include "XblCustomActions.h"

#define SAFE_CLOSE(x) if (x) { MsiCloseHandle(x); (x) = NULL; }
#define GET_STRING(METHOD, ERRORCODE, P1, P2, VALUE, BUFFERLEN) { \
   BUFFERLEN = 0; ERRORCODE = METHOD(P1, P2, TEXT(""), &BUFFERLEN); \
   if (ERROR_MORE_DATA == ERRORCODE) { \
      VALUE.resize(++BUFFERLEN); ERRORCODE = METHOD(P1, P2, &VALUE[0], &BUFFERLEN); \
   } \
}

/// MsiProperty
MsiProperty::MsiProperty(MSIHANDLE installer, const tstring& propertyName) {
   m_Installer = installer;
   m_PropertyName = propertyName;
}

MsiProperty::~MsiProperty() {
   m_Installer = NULL;
   m_PropertyName.clear();
}

UINT MsiProperty::Read(tstring& value, BOOL optional) {
   DWORD  BufferLen = 0;
   UINT   ErrorCode;
   
   GET_STRING(MsiGetProperty, ErrorCode, m_Installer, m_PropertyName.c_str(), value, BufferLen);

   if (ERROR_SUCCESS == ErrorCode && !optional && !BufferLen)
      ErrorCode = ERROR_EMPTY;

   if (ERROR_SUCCESS != ErrorCode)
      value.clear();

   return ErrorCode;
}

UINT MsiProperty::Write(const tstring& value) {
   return MsiSetProperty(m_Installer, m_PropertyName.c_str(), value.c_str());
}

const tstring& MsiProperty::GetName() const {
   return m_PropertyName;
}

MSIHANDLE MsiProperty::GetHandle() {
   return m_Installer;
}

/// MsiRecord
MsiRecord::MsiRecord(MSIHANDLE record)
   : m_Record(record) { }

MsiRecord::~MsiRecord() {
   SAFE_CLOSE(m_Record);
}

tstring MsiRecord::ReadString(UINT ordinal) {
   tstring Value;
   ReadString(ordinal, Value);
   return Value;
}

UINT MsiRecord::ReadString(UINT ordinal, tstring& value) {
   DWORD  BufferLen = 0;
   UINT   ErrorCode;
   
   GET_STRING(MsiRecordGetString, ErrorCode, m_Record, ordinal, value, BufferLen);

   if (ERROR_SUCCESS == ErrorCode && !BufferLen)
      ErrorCode = ERROR_EMPTY;

   if (ERROR_SUCCESS != ErrorCode)
      value.clear();

   return ErrorCode;
}

tstring MsiRecord::ReadFormattedString(MSIHANDLE installer) {
   tstring Value;
   ReadFormattedString(installer, Value);
   return Value;
}

UINT MsiRecord::ReadFormattedString(MSIHANDLE installer, tstring& value) {
   DWORD  BufferLen = 0;
   UINT   ErrorCode;
   
   GET_STRING(MsiFormatRecord, ErrorCode, installer, m_Record, value, BufferLen);

   if (ERROR_SUCCESS == ErrorCode && !BufferLen)
      ErrorCode = ERROR_EMPTY;

   if (ERROR_SUCCESS != ErrorCode)
      value.clear();

   return ErrorCode;
}

tstring MsiRecord::ReadFormattedString(MSIHANDLE installer, UINT ordinal) {
   tstring Value;
   ReadFormattedString(installer, ordinal, Value);
   return Value;
}

UINT MsiRecord::ReadFormattedString(MSIHANDLE installer, UINT ordinal, tstring& value) {
   MSIHANDLE RecordHandle = MsiCreateRecord(1);
   SafePointer<MsiRecord> FormattedRecord(new MsiRecord(RecordHandle));
   UINT ErrorCode;

   if (NULL != RecordHandle && NULL != FormattedRecord && SUCCEEDED(ErrorCode = FormattedRecord->WriteString(0, ReadString(ordinal))))
      ErrorCode = FormattedRecord->ReadFormattedString(installer, value);
   else {
      value.clear();
      ErrorCode = GetLastError();
   }
   
   return ErrorCode;
}

UINT MsiRecord::WriteString(UINT ordinal, const tstring& value) {
   return MsiRecordSetString(m_Record, ordinal, value.c_str());
}

/// MsiView
MsiView::MsiView(MSIHANDLE database, const tstring& query) 
   : m_Database(database), m_View(NULL) 
{
   Query(query);
}

MsiView::MsiView(MSIHANDLE database) 
   : m_Database(database), m_View(NULL) { }

MsiView::~MsiView() {
   SAFE_CLOSE(m_View);
}

MsiRecord * MsiView::NextRecord() {
   if (m_View) {
      MSIHANDLE Record;
      if (ERROR_SUCCESS == MsiViewFetch(m_View, &Record))
         return new MsiRecord(Record);
   }

   return NULL;
}

UINT MsiView::Query(const tstring& query) {
   UINT ErrorCode = ERROR_INVALID_HANDLE;

   if (m_Database) {
      SAFE_CLOSE(m_View);
      
      if (SUCCEEDED(ErrorCode = MsiDatabaseOpenView(m_Database, query.c_str(), &m_View))) {
         if (FAILED(ErrorCode = MsiViewExecute(m_View, NULL)))
            SAFE_CLOSE(m_View);
      }
   }

   return ErrorCode;
}

/// MsiDatabase
MsiDatabase::MsiDatabase(MSIHANDLE database) 
   : m_Database(database) { }

MsiDatabase::~MsiDatabase() {
   SAFE_CLOSE(m_Database);
}

MsiView * MsiDatabase::CreateView(const tstring& query) {
   if (m_Database) {
      return query.size() ? 
         new MsiView(m_Database, query) :
         new MsiView(m_Database);
   }

   return NULL;
}

/// MsiInstaller
MsiInstaller::MsiInstaller(MSIHANDLE installer) {
   m_Installer = installer;
}

MsiInstaller::~MsiInstaller() {
   m_Installer = NULL;
}

MsiProperty * MsiInstaller::GetProperty(const tstring& propertyName) {
   return m_Installer ? 
      new MsiProperty(m_Installer, propertyName) :
      NULL;
}

MsiDatabase * MsiInstaller::GetActiveDatabase() {
   if (m_Installer) {
      MSIHANDLE Handle;
      Handle = MsiGetActiveDatabase(m_Installer);
      return Handle ?
         new MsiDatabase(Handle) :
         NULL;
   }

   return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\XblCustomActions\MsiUtilities.h ===
#pragma once

#include <string>
#include <msi.h>
#include <msiquery.h>

typedef std::basic_string<TCHAR> tstring;

template <class T>
class SafePointer {
public:
   SafePointer() : m_Pointer(NULL) { }
   SafePointer(T * pointer) : m_Pointer(pointer) { }
  ~SafePointer() { _Reset(NULL); }
   SafePointer& operator = (T * pointer) {
      _Reset(pointer);
      return *this;
   }

   T * operator -> () { return m_Pointer; }
   const T * operator -> () const { return m_Pointer; }

   operator T *() { return m_Pointer; }
   operator const T *() const { return m_Pointer; }

   T * Pointer() { return m_Pointer; }
   const T * Pointer() const { return m_Pointer; }

private:
   void _Reset(T * newPointer) {
      if (m_Pointer) {
         delete m_Pointer;
         m_Pointer = NULL;
      }

      m_Pointer = newPointer;
   }

   T * m_Pointer;
};

class MsiProperty {
public:
   MsiProperty(MSIHANDLE installer, const tstring& propertyName);
  ~MsiProperty();

   UINT Read(tstring& value, BOOL optional = FALSE);
   UINT Write(const tstring& value);

   const tstring& GetName() const;

   MSIHANDLE GetHandle();

private:
   MSIHANDLE   m_Installer;
   tstring     m_PropertyName;
};

class MsiRecord {
public:
   MsiRecord(MSIHANDLE record);
  ~MsiRecord();
   
   tstring ReadString(UINT ordinal);
   tstring ReadFormattedString(MSIHANDLE installer);
   tstring ReadFormattedString(MSIHANDLE installer, UINT ordinal);

   UINT ReadString(UINT ordinal, tstring& value);
   UINT WriteString(UINT ordinal, const tstring& value);
   UINT ReadFormattedString(MSIHANDLE installer, tstring& value);
   UINT ReadFormattedString(MSIHANDLE installer, UINT ordinal, tstring& value);
private:
   MSIHANDLE m_Record;
};

class MsiView {
public:
   MsiView(MSIHANDLE database, const tstring& query);
   MsiView(MSIHANDLE database);
  ~MsiView();

   MsiRecord * NextRecord();
   UINT Query(const tstring& query);

private:
   MSIHANDLE m_Database;
   MSIHANDLE m_View;
};

class MsiDatabase {
public:
   MsiDatabase(MSIHANDLE database);
  ~MsiDatabase();

   MsiView * CreateView(const tstring& query);
private:
   MSIHANDLE m_Database;
};

class MsiInstaller {
public:
   MsiInstaller(MSIHANDLE installer);
  ~MsiInstaller();

   MsiProperty * GetProperty(const tstring& szName);
   MsiDatabase * GetActiveDatabase();

private:
   MSIHANDLE m_Installer;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\XblCustomActions\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xblcustomactions_none_12.4.56.0_none_879f9e13df65c6a0
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xblcustomactions_no-public-key_12.4.56.0_x-ww_796de6a0
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xblcustomactions
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xblcustomactions_no-public-key_12.4.56.0_x-ww_796de6a0
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xblcustomactions_no-public-key_12.4.56.0_x-ww_796de6a0.manifest
XP_MANIFEST_PATH=manifests\x86_xblcustomactions_no-public-key_12.4.56.0_x-ww_796de6a0.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xblcustomactions_no-public-key_12.4.56.0_x-ww_796de6a0.cat
XP_CATALOG_PATH=manifests\x86_xblcustomactions_no-public-key_12.4.56.0_x-ww_796de6a0.cat
XP_PAYLOAD_PATH=x86_xblcustomactions_no-public-key_12.4.56.0_x-ww_796de6a0
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xblcustomactions,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\XblCustomActions\XblExpandFQDN.cpp ===
#include "XblCustomActions.h"

UINT SplitFQDN(const tstring& fqdn, tstring& domain, tstring& user) {
   std::basic_string<TCHAR>::size_type Index;
   
   if (std::string::npos != (Index = fqdn.find(_T('\\')))) {
      domain = fqdn.substr(0, Index);
      user = fqdn.substr(Index+1);
   }
   else
      user = fqdn;

   if (std::string::npos == Index || 0 == domain.size() || domain == _T(".")) {
      domain.resize(Index = MAX_COMPUTERNAME_LENGTH + 1);
      if (!GetComputerName(&domain[0], (LPDWORD)&Index))
         return GetLastError();
   }

   return ERROR_SUCCESS;
}

MSIEXPORT XblExpandFQDN(MSIHANDLE hInstall) {
   SafePointer<MsiInstaller> Installer;
   SafePointer<MsiDatabase> ActiveDatabase;
   UINT ErrorCode = ERROR_SUCCESS;

   Installer = new MsiInstaller(hInstall);
   if (NULL != (ActiveDatabase = Installer->GetActiveDatabase())) {
      SafePointer<MsiView> View;
      
      if (NULL != (View = ActiveDatabase->CreateView(_T("SELECT Value, DomainProperty, UserProperty FROM XblFQDN")))) {
         SafePointer<MsiRecord> Record;

         while (NULL != (Record = View->NextRecord())) {
            SafePointer<MsiProperty> DomainProperty;
            SafePointer<MsiProperty> UserProperty;
            tstring DomainName, UserName;
            
            if (ERROR_SUCCESS != (ErrorCode = SplitFQDN(Record->ReadFormattedString(hInstall, 1), DomainName, UserName)))
               break;

            DomainProperty = Installer->GetProperty(Record->ReadString(2));
            UserProperty = Installer->GetProperty(Record->ReadString(3));

            if (ERROR_SUCCESS != (ErrorCode = DomainProperty->Write(DomainName)))
               break;

            if (ERROR_SUCCESS != (ErrorCode = UserProperty->Write(UserName)))
               break;
         }
      }
   }

   return ErrorCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\xcmd\migrate.cpp ===
#include "xcmd.h"

BOOL __copyToLogDirectory(PDWORD pdwExit, LPCTSTR szLogDirectory, LPCTSTR szSourceLog) {
   TCHAR rgzTargetPath[MAX_PATH];
   LPCTSTR szFilename;
   DWORD dwLength;

   _tcscpy_s(rgzTargetPath, ARRAYSIZE(rgzTargetPath), szLogDirectory);

   if (NULL == (szFilename = _tcsrchr(szSourceLog, TEXT('\\')))) {
      szFilename = szSourceLog;
      _tcscat_s(rgzTargetPath, ARRAYSIZE(rgzTargetPath), TEXT("\\"));
   }

   dwLength = _tcslen(rgzTargetPath) + _tcslen(szFilename) + 1;
   if (ARRAYSIZE(rgzTargetPath) < dwLength) {
      FmtMessage(
         TEXT("ERROR: the log target path '%s%s' is too long."),
         rgzTargetPath,
         szFilename);

      *pdwExit = ERROR_INVALID_NAME;

      return FALSE;
   }

   _tcscat_s(rgzTargetPath, ARRAYSIZE(rgzTargetPath), szFilename);

   if (!CopyFile(szSourceLog, rgzTargetPath, FALSE)) {
      FmtMessage(
         TEXT("ERROR: failed to migrate log from '%s' to '%s' (%d)."),
         szSourceLog,
         rgzTargetPath,
         *pdwExit = GetLastError());

      return FALSE;
   }

   return TRUE;
}

BOOL MigrateLog(PDWORD pdwExit, PXCMD_PARAMETERS pxp, LPCTSTR szSourceLog) {
   if (!__createDirectory(pdwExit, pxp->rgzLogDirectory))
      return FALSE;

   if (!__copyToLogDirectory(pdwExit, pxp->rgzLogDirectory, szSourceLog))
      return FALSE;

   return TRUE;
}

BOOL MigrateTokenizedLog(PDWORD pdwExit, PXCMD_PARAMETERS pxp, LPCTSTR szTokenizedSourceLog, ptoken_map ptokens) {
   BOOL     fInToken;
   LPCTSTR  szDelimiter = TEXT("%");
   TCHAR *  szNextToken, * szToken;
   TCHAR    rgzSourceLog[MAX_PATH] = {0};
   TCHAR    rgzTokenizedSourceLog[MAX_PATH];

   _tcscpy_s(rgzTokenizedSourceLog, ARRAYSIZE(rgzTokenizedSourceLog), szTokenizedSourceLog);

   fInToken = (szTokenizedSourceLog[0] == szDelimiter[0]);
   
   szToken = _tcstok_s(rgzTokenizedSourceLog, szDelimiter, &szNextToken);
   
   while (szToken) {
      if (!fInToken)
         _tcscat_s(rgzSourceLog, ARRAYSIZE(rgzSourceLog), szToken);
      else if (ptokens->find(szToken) != ptokens->end())
         //use the token we stored token
         _tcscat_s(rgzSourceLog, ARRAYSIZE(rgzSourceLog), (*ptokens)[szToken]);
      else {
         //put the token back in
         _tcscat_s(rgzSourceLog, ARRAYSIZE(rgzSourceLog), TEXT("%"));
         _tcscat_s(rgzSourceLog, ARRAYSIZE(rgzSourceLog), szToken);
         _tcscat_s(rgzSourceLog, ARRAYSIZE(rgzSourceLog), TEXT("%"));
      }
      
      szToken = _tcstok_s(NULL, szDelimiter, &szNextToken);
      fInToken = !fInToken;
   }

   return MigrateLog(pdwExit, pxp, rgzSourceLog);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\xcmd\shell.cpp ===
#include "xcmd.h"

BOOL __createProcess(PDWORD pdwExit, TCHAR * tszCommand, PPROCESS_INFORMATION ppi, LPSTARTUPINFO psi) {
   DWORD dwResult;

   dwResult = CreateProcess(
      NULL,
      tszCommand,
      NULL, NULL, TRUE,
      CREATE_SEPARATE_WOW_VDM,
      NULL, NULL, 
      psi,
      ppi);

   if (!dwResult) {
      FmtMessage(TEXT("ERROR: failed to launch application (%d).\r\n"), 
         tszCommand, *pdwExit = HRESULT_FROM_WIN32(GetLastError()));
      
      return FALSE;
   }

   return TRUE;
}

BOOL __waitForProcess(PDWORD pdwExit, PPROCESS_INFORMATION ppi) {
   DWORD dwResult;

   dwResult = WaitForSingleObject(ppi->hProcess, INFINITE);

   if (WAIT_OBJECT_0 != dwResult) {
      FmtMessage(TEXT("ERROR: could not wait for process to complete (%d).\r\n"),
         *pdwExit = HRESULT_FROM_WIN32(GetLastError()));

      return FALSE;
   }

   return TRUE;
}

BOOL __waitForThread(PDWORD pdwExit, HANDLE hThread) {
   DWORD dwResult;

   dwResult = WaitForSingleObject(hThread, INFINITE);

   if (WAIT_OBJECT_0 != dwResult) {
      FmtMessage(TEXT("ERROR: could not wait for process to complete (%d).\r\n"),
         *pdwExit = GetLastError());

      return FALSE;
   }

   return TRUE;
}

BOOL __dumpPipe(PDWORD pdwExit, HANDLE hRead, HANDLE hWrite) {
   BYTE  abBuffer[128];
   DWORD dwRead;

   hWrite = hWrite ? hWrite : GetStdHandle(STD_OUTPUT_HANDLE);

   while (ReadFile(hRead, abBuffer, sizeof(abBuffer), &dwRead, NULL) && dwRead) {
      DWORD dwWritten;

      if (!WriteFile(hWrite, abBuffer, dwRead, &dwWritten, NULL) || (dwWritten != dwRead))
            break;

      if (hWrite) {
         
      }
   }

   if (ERROR_BROKEN_PIPE == (*pdwExit = GetLastError()))
      *pdwExit = ERROR_SUCCESS;

   return ERROR_SUCCESS == *pdwExit;
}

BOOL __createDirectory(PDWORD pdwExit, LPCTSTR szLogDirectory) {
   if (ERROR_SUCCESS != (*pdwExit = SHCreateDirectory(NULL, szLogDirectory))) {
      if (*pdwExit != ERROR_ALREADY_EXISTS) {
         FmtMessage(
            TEXT("ERROR: failed to create log directory '%s' (%d).\n"),
            szLogDirectory,
            *pdwExit);

         return FALSE;
      }

      *pdwExit = ERROR_SUCCESS;
   }

   return TRUE;
}

BOOL __createFile(PDWORD pdwExit, PXCMD_PARAMETERS pxp, LPCTSTR pszFilename, PHANDLE phFile, BOOL fAppend = TRUE) {
   if (_tcslen(pxp->rgzLogDirectory)) {
      if (!__createDirectory(pdwExit, pxp->rgzLogDirectory))
         return FALSE;

      FmtMessage(TEXT("Creating '%s'...\n"), pxp->szLogTarget);

      *phFile = CreateFile(
         pxp->szLogTarget,
         GENERIC_READ | GENERIC_WRITE,
         FILE_SHARE_READ,
         NULL,
         fAppend ? OPEN_ALWAYS : CREATE_ALWAYS,
         FILE_ATTRIBUTE_NORMAL,
         NULL);

      if (INVALID_HANDLE_VALUE == *phFile) {
         FmtMessage(
            TEXT("ERROR: failed to create file '%s' (%d).\n"), 
            pxp->szLogTarget,
            *pdwExit = GetLastError());

         return FALSE;
      }
      else if (fAppend) {
         if (INVALID_SET_FILE_POINTER == SetFilePointer(*phFile, 0, NULL, FILE_END)) {
            FmtMessage(
               TEXT("ERROR: failed to seek to end of file '%s' (%d).\n"),
               pxp->szLogTarget,
               *pdwExit = GetLastError());
            
            CloseHandle(*phFile);
            *phFile = NULL;

            return FALSE;
         }
      }
   }
   else
      FmtMessage(TEXT("=== Logging to console ===\n"));

   return TRUE;
}

VOID __getExecutableImageName(PXCMD_PARAMETERS pxp, LPTSTR rgzImagename, LPCTSTR szAppendedString) {
   TCHAR * szEnd;
   TCHAR * szStart;
   DWORD dwLength;

   dwLength = _tcslen(pxp->rgzExecutable);
   
   if (NULL == (szEnd = _tcsrchr(pxp->rgzExecutable, TEXT('.'))))
      szEnd = pxp->rgzExecutable + dwLength;

   if (NULL == (szStart = _tcsrchr(pxp->rgzExecutable, TEXT('\\'))))
      szStart = pxp->rgzExecutable;

   _tcsncpy_s(rgzImagename, MAX_PATH, szStart, szEnd-szStart);
   if (szAppendedString)
      _tcscat_s(rgzImagename, MAX_PATH, szAppendedString);
}

BOOL __createFileFromImagename(PDWORD pdwExit, PXCMD_PARAMETERS pxp, LPCTSTR szAppend, PHANDLE phFile) {
   TCHAR szFilename[MAX_PATH];
   __getExecutableImageName(pxp, szFilename, szAppend);
   return __createFile(pdwExit, pxp, szFilename, phFile);
}

VOID __logLoggingParameters(PXCMD_PARAMETERS pxp) {
   DWORD dwExit = 0;
   HANDLE hLogFile = NULL;

   if (__createFile(&dwExit, pxp, pxp->szLogTarget, &hLogFile, FALSE)) {
      DisplayParameterToHandle(pxp, hLogFile);
      CloseHandle(hLogFile);
   }
}

BOOL __commitPipeToLogFile(PDWORD pdwExit, PXCMD_PARAMETERS pxp, HANDLE hPipe, LPCTSTR szAppend, LPCTSTR szFriendlyName) {
   HANDLE hLogFile;
   BOOL tResult = FALSE;

   if (!__createFile(pdwExit, pxp, pxp->szLogTarget, &hLogFile)) {
      DWORD dwExit;
      
      // the process is depending on this to complete
      __dumpPipe(&dwExit, hPipe, GetStdHandle(STD_OUTPUT_HANDLE));

      return FALSE;
   }

   __try {
      if (!__dumpPipe(pdwExit, hPipe, hLogFile)) {
         FmtMessage(
            TEXT("ERROR: failed to write process %s to log file (%d).\n"),
            szFriendlyName,
            *pdwExit);
      }

      tResult = TRUE;
   }
   __finally {
      SAFE_CLOSE_HANDLE(hLogFile);
   }

   return tResult;
}

typedef struct _DRAIN_PARAMS {
   PXCMD_PARAMETERS  pxp;
   HANDLE            hPipe;
   LPCTSTR           pszSuffix;
   LPCTSTR           pszFriendlyName;
   DWORD*            pdwExitCode;
} DRAIN_PARAMS, * PDRAIN_PARAMS;

DWORD WINAPI _DrainPipe(LPVOID lpParameter) {
   PDRAIN_PARAMS pdp = (PDRAIN_PARAMS)lpParameter;
   
   __commitPipeToLogFile(
      pdp->pdwExitCode, 
      pdp->pxp, 
      pdp->hPipe,
      pdp->pszSuffix,
      pdp->pszFriendlyName);

   delete pdp;

   return S_OK;
}

HANDLE DrainPipe(PDWORD pdwExit, PXCMD_PARAMETERS pxp, HANDLE hPipe, LPCTSTR szAppend, LPCTSTR szFriendlyName) {
   PDRAIN_PARAMS pdp;
   DWORD dwThreadId;
   
   pdp = new DRAIN_PARAMS;

   pdp->pxp = pxp;
   pdp->pdwExitCode = pdwExit;
   pdp->hPipe = hPipe;
   pdp->pszSuffix = szAppend;
   pdp->pszFriendlyName = szFriendlyName;

   return CreateThread(NULL, 0, _DrainPipe, (LPVOID)pdp, 0, &dwThreadId);
}

int RunCommand(PXCMD_PARAMETERS pxp) {
   int                  iExitCode=0;
   int                  iShellReturnCode=0;
   bool                 fTerminated=false;
   int                  iThreadExitCode=0;
	STARTUPINFO          siProcess={0};
   SECURITY_ATTRIBUTES  saPipes={0};
   PROCESS_INFORMATION  piProcess={0};
   HANDLE               hReadout=NULL, hWriteout=NULL;
   HANDLE               hThread1=NULL;
   TCHAR                tszCommand[MAX_COMMAND_LINE_SIZE+MAX_PATH]={0};

   _tcscat_s(tszCommand, ARRAYSIZE(tszCommand), TEXT("\""));
   _tcscat_s(tszCommand, ARRAYSIZE(tszCommand), pxp->rgzExecutable);
   _tcscat_s(tszCommand, ARRAYSIZE(tszCommand), TEXT("\""));
   _tcscat_s(tszCommand, ARRAYSIZE(tszCommand), TEXT(" "));
   _tcscat_s(tszCommand, ARRAYSIZE(tszCommand), pxp->szCommandLine);

   siProcess.cb            = sizeof(siProcess);
   siProcess.hStdInput     = NULL;
   siProcess.dwFlags       = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;
   siProcess.wShowWindow   = SW_SHOWNORMAL;

   if (pxp->fUseShell)
      siProcess.lpDesktop     = TEXT("winsta0\\default");

   saPipes.nLength               = sizeof(SECURITY_ATTRIBUTES);
   saPipes.bInheritHandle        = TRUE;
   saPipes.lpSecurityDescriptor  = NULL;

   __logLoggingParameters(pxp);

   __try {
      if (pxp->szCurrentDirectory && !SetCurrentDirectory(pxp->szCurrentDirectory)) {
         FmtMessage(TEXT("ERROR: failed to set current directory (%d)."),
            iExitCode = GetLastError());

         __leave;
      }

      if (!CreatePipe(&hReadout, &hWriteout, &saPipes, LOGGING_BUFFER_SIZE)) {
         FmtMessage(TEXT("ERROR: failed to create STDOUT pipes for child process (%d).\r\n"),
            iExitCode = GetLastError());

         __leave;
      }

      SetHandleInformation(hReadout, HANDLE_FLAG_INHERIT, 0);
      SetHandleInformation(hReadout, HANDLE_FLAG_INHERIT, 0);

      siProcess.hStdOutput = hWriteout;
      siProcess.hStdError  = hWriteout;

      if (!__createProcess((PDWORD)&iExitCode, tszCommand, &piProcess, &siProcess))
         __leave;

      //Create the pipe drainer
      hThread1 = DrainPipe((PDWORD)&iExitCode, pxp, hReadout, TEXT(".outout.log"), TEXT("output"));
      if ((NULL == hThread1))
         __leave;

      if (!__waitForProcess((PDWORD)&iExitCode, &piProcess))
         __leave;

      if (!GetExitCodeProcess(piProcess.hProcess, (LPDWORD)&iShellReturnCode)) {
         FmtMessage(TEXT("ERROR: could not get exit code for process (%d).\r\n"),
            iExitCode = GetLastError());

         __leave;
      }

      FmtMessage(TEXT("Process terminated with exit code %d.\n"), iShellReturnCode);
      fTerminated = true;

      //Done with process close up handles
      SAFE_CLOSE_HANDLE(piProcess.hProcess);
      SAFE_CLOSE_HANDLE(piProcess.hThread);

      //Close up write handles so dump cant finish
      SAFE_CLOSE_HANDLE(hWriteout);

      FmtMessage(TEXT("Waiting for logging to finish committing to file...\n"));

      if (!__waitForThread((PDWORD)&iThreadExitCode, hThread1))
         __leave;
   }
   __finally {
      SAFE_CLOSE_HANDLE(piProcess.hProcess);
      SAFE_CLOSE_HANDLE(piProcess.hThread);
      SAFE_CLOSE_HANDLE(hWriteout);
      SAFE_CLOSE_HANDLE(hReadout);
      SAFE_CLOSE_HANDLE(hThread1);
   }

   return fTerminated ? iShellReturnCode : iExitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\xcmd\main.cpp ===
#include "xcmd.h"

int __cdecl _tmain(int argc, TCHAR ** argv) {
   XCMD_PARAMETERS   xp = { 0 };
   HRESULT           hr;

   if (FAILED(hr = ProcessCommandLine(argc - 1, argv + 1, &xp)))
      return hr;
   
   DisplayParameters(&xp);

   __try {
      if (xp.fUseShell) {
         if (FAILED(hr = PromoteLogonUser()))
            return hr;
      }

	   return RunCommand(&xp);
   }
   __finally {
      ClearParameters(&xp);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\xcmd\acl.cpp ===
#include "xcmd.h"

BOOL GetLogonSID (HANDLE hToken, PSID *ppsid);
VOID FreeLogonSID (PSID *ppsid);
BOOL AddAceToWindowStation(HWINSTA hwinsta, PSID psid);
BOOL AddAceToDesktop(HDESK hdesk, PSID psid);

#define MSG_AND_LEAVE(pszFormat, ...) \
{ \
   FmtMessage(pszFormat, __VA_ARGS__); \
   __leave; \
}

VOID FmtMessage(LPCTSTR pszFormat, ...) {
   LPTSTR   pszBuffer = NULL;
   DWORD    dwBuffer;
   va_list  va;

   va_start(va, pszFormat);
   
   dwBuffer  = _vsctprintf(pszFormat, va);
   pszBuffer = (TCHAR*)malloc(++dwBuffer * sizeof(TCHAR));
   assert(pszBuffer);

   __try { 
      _vstprintf_s(pszBuffer, dwBuffer, pszFormat, va);

      _tprintf(pszBuffer);
      OutputDebugString(pszBuffer);
   }
   __finally {
      free(pszBuffer);
      va_end(va);
   }
}

HRESULT PromoteLogonUser() {
   DWORD   dwError = ERROR_SUCCESS;
   HANDLE  hProcessToken=NULL;
   HDESK   hIntrDesktop=NULL; //Interactive Window Desktop
   HWINSTA hProcWindowStation=NULL; //Current Process Window Station
   HWINSTA hIntrWindowStation=NULL; //Interactive Window Station
   PSID    pSid=NULL;

   __try {
      if(!OpenProcessToken( GetCurrentProcess(), TOKEN_READ, &hProcessToken ))
         MSG_AND_LEAVE(TEXT("ERROR: getting process token (%d)\r\n"), dwError = GetLastError());

      if (NULL == (hProcWindowStation = GetProcessWindowStation()))
         MSG_AND_LEAVE(TEXT("ERROR: getting process window station (%d)\r\n"), dwError = GetLastError());

      if (NULL == (hIntrWindowStation = OpenWindowStation(L"winsta0", FALSE, READ_CONTROL | WRITE_DAC)))
         MSG_AND_LEAVE(TEXT("ERROR: getting interactive window station (%d)\r\n"), dwError = GetLastError());

      if (!SetProcessWindowStation(hIntrWindowStation))
         MSG_AND_LEAVE(TEXT("ERROR: moving process to interactive window station (%d)\r\n"), dwError = GetLastError());

      if (NULL == (hIntrDesktop = OpenDesktop(L"default", 0, FALSE, READ_CONTROL | WRITE_DAC | DESKTOP_WRITEOBJECTS | DESKTOP_READOBJECTS)))
         MSG_AND_LEAVE(TEXT("ERROR: getting interactive desktop (%d)\r\n"), dwError = GetLastError());

      if (!SetProcessWindowStation(hProcWindowStation))
         MSG_AND_LEAVE(TEXT("ERROR: restoring process window station (%d)\r\n"), dwError = GetLastError());

      hProcWindowStation = NULL;

      if (!GetLogonSID(hProcessToken, &pSid))
         MSG_AND_LEAVE(TEXT("ERROR: getting logon SID (%d)\r\n"), dwError = GetLastError());

      if (!AddAceToWindowStation(hIntrWindowStation, pSid))
         MSG_AND_LEAVE(TEXT("ERROR: grant full access to interactive window station (%d)\r\n"), dwError = GetLastError());

      if (!AddAceToDesktop(hIntrDesktop, pSid))
         MSG_AND_LEAVE(TEXT("ERROR: grant full access to interactive desktop (%d)\r\n"), dwError = GetLastError());
   }
   __finally {
      if (NULL != hProcWindowStation)
         SetProcessWindowStation(hProcWindowStation);

      if (pSid)
         FreeLogonSID(&pSid);

      if (hIntrWindowStation)
         CloseWindowStation(hIntrWindowStation);

      if (hIntrDesktop)
         CloseDesktop(hIntrDesktop);
   }


   return HRESULT_FROM_WIN32(dwError);
}

BOOL GetLogonSID (HANDLE hToken, PSID *ppsid) {
    BOOL            bSuccess    = FALSE;
    DWORD           dwIndex     = 0;
    DWORD           dwLength    = 0;
    PTOKEN_GROUPS   ptg         = NULL;

    
    // Verify the parameter passed in is not NULL.
    if (NULL == ppsid)
        goto Cleanup;
    
    // Primer call to determine buffer size requirements
    if (!GetTokenInformation(hToken, TokenGroups, (LPVOID) ptg, 0, &dwLength)) 
    {
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) 
            goto Cleanup;
        
        ptg = (PTOKEN_GROUPS)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwLength);
        if (ptg == NULL)
            goto Cleanup;
    }
    
    // Now make the actual call to get data
    if (!GetTokenInformation(hToken, TokenGroups, (LPVOID) ptg, dwLength, &dwLength)) 
    {
        goto Cleanup;
    }
    
    // Loop through the groups to find the logon SID.
    for (dwIndex = 0; dwIndex < ptg->GroupCount; dwIndex++) 
    {
        if ((ptg->Groups[dwIndex].Attributes & SE_GROUP_LOGON_ID) ==  SE_GROUP_LOGON_ID) 
        {
            // Found the logon SID; make a copy of it.
            dwLength = GetLengthSid(ptg->Groups[dwIndex].Sid);

            *ppsid = (PSID) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwLength);
            if (*ppsid == NULL)
                goto Cleanup;

            if (!CopySid(dwLength, *ppsid, ptg->Groups[dwIndex].Sid)) 
            {
                HeapFree(GetProcessHeap(), 0, (LPVOID)*ppsid);
                goto Cleanup;
            }
            break;
        }
    }
    
    bSuccess = TRUE;


Cleanup: 

    if (ptg != NULL)
        HeapFree(GetProcessHeap(), 0, (LPVOID)ptg);
    
    return bSuccess;
}

VOID FreeLogonSID (PSID *ppsid) {
    HeapFree(GetProcessHeap(), 0, (LPVOID)*ppsid);
}

BOOL AddAceToWindowStation(HWINSTA hwinsta, PSID psid) {
   ACCESS_ALLOWED_ACE   *pace;
   ACL_SIZE_INFORMATION aclSizeInfo;
   BOOL                 bDaclExist;
   BOOL                 bDaclPresent;
   BOOL                 bSuccess = FALSE;
   DWORD                dwNewAclSize;
   DWORD                dwSidSize = 0;
   DWORD                dwSdSizeNeeded;
   PACL                 pacl;
   PACL                 pNewAcl;
   PSECURITY_DESCRIPTOR psd = NULL;
   PSECURITY_DESCRIPTOR psdNew = NULL;
   PVOID                pTempAce;
   SECURITY_INFORMATION si = DACL_SECURITY_INFORMATION;
   unsigned int         i;

   __try
   {
      // Obtain the DACL for the window station.

      if (!GetUserObjectSecurity(
             hwinsta,
             &si,
             psd,
             dwSidSize,
             &dwSdSizeNeeded)
      )
      if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
      {
         psd = (PSECURITY_DESCRIPTOR)HeapAlloc(
               GetProcessHeap(),
               HEAP_ZERO_MEMORY,
               dwSdSizeNeeded);

         if (psd == NULL)
            __leave;

         psdNew = (PSECURITY_DESCRIPTOR)HeapAlloc(
               GetProcessHeap(),
               HEAP_ZERO_MEMORY,
               dwSdSizeNeeded);

         if (psdNew == NULL)
            __leave;

         dwSidSize = dwSdSizeNeeded;

         if (!GetUserObjectSecurity(
               hwinsta,
               &si,
               psd,
               dwSidSize,
               &dwSdSizeNeeded)
         )
            __leave;
      }
      else
         __leave;

      // Create a new DACL.

      if (!InitializeSecurityDescriptor(
            psdNew,
            SECURITY_DESCRIPTOR_REVISION)
      )
         __leave;

      // Get the DACL from the security descriptor.

      if (!GetSecurityDescriptorDacl(
            psd,
            &bDaclPresent,
            &pacl,
            &bDaclExist)
      )
         __leave;

      // Initialize the ACL.

      ZeroMemory(&aclSizeInfo, sizeof(ACL_SIZE_INFORMATION));
      aclSizeInfo.AclBytesInUse = sizeof(ACL);

      // Call only if the DACL is not NULL.

      if (pacl != NULL)
      {
         // get the file ACL size info
         if (!GetAclInformation(
               pacl,
               (LPVOID)&aclSizeInfo,
               sizeof(ACL_SIZE_INFORMATION),
               AclSizeInformation)
         )
            __leave;
      }

      // Compute the size of the new ACL.

      dwNewAclSize = aclSizeInfo.AclBytesInUse + (2*sizeof(ACCESS_ALLOWED_ACE)) + (2*GetLengthSid(psid)) - (2*sizeof(DWORD));

      // Allocate memory for the new ACL.

      pNewAcl = (PACL)HeapAlloc(
            GetProcessHeap(),
            HEAP_ZERO_MEMORY,
            dwNewAclSize);

      if (pNewAcl == NULL)
         __leave;

      // Initialize the new DACL.

      if (!InitializeAcl(pNewAcl, dwNewAclSize, ACL_REVISION))
         __leave;

      // If DACL is present, copy it to a new DACL.

      if (bDaclPresent)
      {
         // Copy the ACEs to the new ACL.
         if (aclSizeInfo.AceCount)
         {
            for (i=0; i < aclSizeInfo.AceCount; i++)
            {
               // Get an ACE.
               if (!GetAce(pacl, i, &pTempAce))
                  __leave;

               // Add the ACE to the new ACL.
               if (!AddAce(
                     pNewAcl,
                     ACL_REVISION,
                     MAXDWORD,
                     pTempAce,
                    ((PACE_HEADER)pTempAce)->AceSize)
               )
                  __leave;
            }
         }
      }

      // Add the first ACE to the window station.

      pace = (ACCESS_ALLOWED_ACE *)HeapAlloc(
            GetProcessHeap(),
            HEAP_ZERO_MEMORY,
            sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(psid) -
                  sizeof(DWORD));

      if (pace == NULL)
         __leave;

      pace->Header.AceType  = ACCESS_ALLOWED_ACE_TYPE;
      pace->Header.AceFlags = CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE | OBJECT_INHERIT_ACE;
      pace->Header.AceSize  = sizeof(ACCESS_ALLOWED_ACE) + (WORD) GetLengthSid(psid) - sizeof(DWORD);
      pace->Mask            = GENERIC_ACCESS;

      if (!CopySid(GetLengthSid(psid), &pace->SidStart, psid))
         __leave;

      if (!AddAce(
            pNewAcl,
            ACL_REVISION,
            MAXDWORD,
            (LPVOID)pace,
            pace->Header.AceSize)
      )
         __leave;

      // Add the second ACE to the window station.

      pace->Header.AceFlags = NO_PROPAGATE_INHERIT_ACE;
      pace->Mask            = WINSTA_ALL;

      if (!AddAce(
            pNewAcl,
            ACL_REVISION,
            MAXDWORD,
            (LPVOID)pace,
            pace->Header.AceSize)
      )
         __leave;

      // Set a new DACL for the security descriptor.

      if (!SetSecurityDescriptorDacl(
            psdNew,
            TRUE,
            pNewAcl,
            FALSE)
      )
         __leave;

      // Set the new security descriptor for the window station.

      if (!SetUserObjectSecurity(hwinsta, &si, psdNew))
         __leave;

      // Indicate success.

      bSuccess = TRUE;
   }
   __finally
   {
      // Free the allocated buffers.

      if (pace != NULL)
         HeapFree(GetProcessHeap(), 0, (LPVOID)pace);

      if (pNewAcl != NULL)
         HeapFree(GetProcessHeap(), 0, (LPVOID)pNewAcl);

      if (psd != NULL)
         HeapFree(GetProcessHeap(), 0, (LPVOID)psd);

      if (psdNew != NULL)
         HeapFree(GetProcessHeap(), 0, (LPVOID)psdNew);
   }

   return bSuccess;
}



BOOL AddAceToDesktop(HDESK hdesk, PSID psid) {
   ACL_SIZE_INFORMATION aclSizeInfo;
   BOOL                 bDaclExist;
   BOOL                 bDaclPresent;
   BOOL                 bSuccess = FALSE;
   DWORD                dwNewAclSize;
   DWORD                dwSidSize = 0;
   DWORD                dwSdSizeNeeded;
   PACL                 pacl;
   PACL                 pNewAcl;
   PSECURITY_DESCRIPTOR psd = NULL;
   PSECURITY_DESCRIPTOR psdNew = NULL;
   PVOID                pTempAce;
   SECURITY_INFORMATION si = DACL_SECURITY_INFORMATION;
   unsigned int         i;

   __try
   {
      // Obtain the security descriptor for the desktop object.

      if (!GetUserObjectSecurity(
            hdesk,
            &si,
            psd,
            dwSidSize,
            &dwSdSizeNeeded))
      {
         if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
         {
            psd = (PSECURITY_DESCRIPTOR)HeapAlloc(
                  GetProcessHeap(),
                  HEAP_ZERO_MEMORY,
                  dwSdSizeNeeded );

            if (psd == NULL)
               __leave;

            psdNew = (PSECURITY_DESCRIPTOR)HeapAlloc(
                  GetProcessHeap(),
                  HEAP_ZERO_MEMORY,
                  dwSdSizeNeeded);

            if (psdNew == NULL)
               __leave;

            dwSidSize = dwSdSizeNeeded;

            if (!GetUserObjectSecurity(
                  hdesk,
                  &si,
                  psd,
                  dwSidSize,
                  &dwSdSizeNeeded)
            )
               __leave;
         }
         else
            __leave;
      }

      // Create a new security descriptor.

      if (!InitializeSecurityDescriptor(
            psdNew,
            SECURITY_DESCRIPTOR_REVISION)
      )
         __leave;

      // Obtain the DACL from the security descriptor.

      if (!GetSecurityDescriptorDacl(
            psd,
            &bDaclPresent,
            &pacl,
            &bDaclExist)
      )
         __leave;

      // Initialize.

      ZeroMemory(&aclSizeInfo, sizeof(ACL_SIZE_INFORMATION));
      aclSizeInfo.AclBytesInUse = sizeof(ACL);

      // Call only if NULL DACL.

      if (pacl != NULL)
      {
         // Determine the size of the ACL information.

         if (!GetAclInformation(
               pacl,
               (LPVOID)&aclSizeInfo,
               sizeof(ACL_SIZE_INFORMATION),
               AclSizeInformation)
         )
            __leave;
      }

      // Compute the size of the new ACL.

      dwNewAclSize = aclSizeInfo.AclBytesInUse + sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(psid) - sizeof(DWORD);

      // Allocate buffer for the new ACL.

      pNewAcl = (PACL)HeapAlloc(
            GetProcessHeap(),
            HEAP_ZERO_MEMORY,
            dwNewAclSize);

      if (pNewAcl == NULL)
         __leave;

      // Initialize the new ACL.

      if (!InitializeAcl(pNewAcl, dwNewAclSize, ACL_REVISION))
         __leave;

      // If DACL is present, copy it to a new DACL.

      if (bDaclPresent)
      {
         // Copy the ACEs to the new ACL.
         if (aclSizeInfo.AceCount)
         {
            for (i=0; i < aclSizeInfo.AceCount; i++)
            {
               // Get an ACE.
               if (!GetAce(pacl, i, &pTempAce))
                  __leave;

               // Add the ACE to the new ACL.
               if (!AddAce(
                  pNewAcl,
                  ACL_REVISION,
                  MAXDWORD,
                  pTempAce,
                  ((PACE_HEADER)pTempAce)->AceSize)
               )
                  __leave;
            }
         }
      }

      // Add ACE to the DACL.

      if (!AddAccessAllowedAce(
            pNewAcl,
            ACL_REVISION,
            DESKTOP_ALL,
            psid)
      )
         __leave;

      // Set new DACL to the new security descriptor.

      if (!SetSecurityDescriptorDacl(
            psdNew,
            TRUE,
            pNewAcl,
            FALSE)
      )
         __leave;

      // Set the new security descriptor for the desktop object.

      if (!SetUserObjectSecurity(hdesk, &si, psdNew))
         __leave;

      // Indicate success.

      bSuccess = TRUE;
   }
   __finally
   {
      // Free buffers.

      if (pNewAcl != NULL)
         HeapFree(GetProcessHeap(), 0, (LPVOID)pNewAcl);

      if (psd != NULL)
         HeapFree(GetProcessHeap(), 0, (LPVOID)psd);

      if (psdNew != NULL)
         HeapFree(GetProcessHeap(), 0, (LPVOID)psdNew);
   }

   return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\xcmd\xcmd.h ===
#ifndef __XCMD_H_0eb3d2a9279f__
#define __XCMD_H_0eb3d2a9279f__

#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <shlobj.h>
#include <stdio.h>
#include <tchar.h>
#include <wchar.h>
#include <stdarg.h>
#include <malloc.h>
#include <assert.h>
#include <map>

#define MAX_COMMAND_LINE_PARAMETERS 64
#define MAX_COMMAND_LINE_SIZE       1024
#define LOGGING_BUFFER_SIZE         0x1000

#define DESKTOP_ALL (DESKTOP_READOBJECTS | DESKTOP_CREATEWINDOW | \
	DESKTOP_CREATEMENU | DESKTOP_HOOKCONTROL | DESKTOP_JOURNALRECORD | \
	DESKTOP_JOURNALPLAYBACK | DESKTOP_ENUMERATE | DESKTOP_WRITEOBJECTS | \
	DESKTOP_SWITCHDESKTOP | STANDARD_RIGHTS_REQUIRED)

#define WINSTA_ALL (WINSTA_ENUMDESKTOPS | WINSTA_READATTRIBUTES | \
	WINSTA_ACCESSCLIPBOARD | WINSTA_CREATEDESKTOP | WINSTA_WRITEATTRIBUTES | \
	WINSTA_ACCESSGLOBALATOMS | WINSTA_EXITWINDOWS | WINSTA_ENUMERATE | \
	WINSTA_READSCREEN | STANDARD_RIGHTS_REQUIRED)

#define GENERIC_ACCESS (GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | GENERIC_ALL)

#define SAFE_FREE(x)         if ((x)) { free((x)); (x)=NULL; }
#define SAFE_CLOSE_HANDLE(x) if ((x)) { CloseHandle((x)); (x)=NULL; }

typedef std::map<LPCTSTR, LPCTSTR> token_map, * ptoken_map;

typedef struct _XCMD_PARAMETERS {
   TCHAR*   szLogTarget;
   BOOL     fUseShell;
   BOOL     fSplitLog;
   TCHAR    rgzExecutable[MAX_PATH];
   TCHAR    rgzLogDirectory[MAX_PATH];
   TCHAR*   szCommandLine;
   TCHAR*   szCurrentDirectory;
} XCMD_PARAMETERS, * PXCMD_PARAMETERS;

HRESULT ProcessCommandLine(int argc, TCHAR ** argv, PXCMD_PARAMETERS pParams);
VOID    ClearParameters(PXCMD_PARAMETERS pParams);
VOID    DisplayParameters(PXCMD_PARAMETERS pxp);

BOOL    DisplayParameterToHandle(PXCMD_PARAMETERS pxp, HANDLE hFile);

HRESULT PromoteLogonUser();
int     RunCommand(PXCMD_PARAMETERS);
VOID    FmtMessage(LPCTSTR pszFormat, ...);

BOOL __createDirectory(PDWORD pdwExit, LPCTSTR szLogDirectory);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\xcmd\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xcmd_none_12.4.56.0_none_b4e83963192af9ec
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xcmd_no-public-key_12.4.56.0_x-ww_6a7f5c58
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xcmd
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xcmd_no-public-key_12.4.56.0_x-ww_6a7f5c58
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xcmd_no-public-key_12.4.56.0_x-ww_6a7f5c58.manifest
XP_MANIFEST_PATH=manifests\x86_xcmd_no-public-key_12.4.56.0_x-ww_6a7f5c58.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xcmd_no-public-key_12.4.56.0_x-ww_6a7f5c58.cat
XP_CATALOG_PATH=manifests\x86_xcmd_no-public-key_12.4.56.0_x-ww_6a7f5c58.cat
XP_PAYLOAD_PATH=x86_xcmd_no-public-key_12.4.56.0_x-ww_6a7f5c58
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xcmd,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\xcmd\commandline.cpp ===
#include "xcmd.h"

typedef DWORD (*XCMD_PARAMREADER) (DWORD dwPosition, DWORD dwCount, TCHAR ** rgpszParameters, PXCMD_PARAMETERS pxp);

typedef struct __XCMD_PARAMETER_DESC {
public:
   const TCHAR*      tszSwitch;
   DWORD             dwMinParameters;
   DWORD             dwMaxParameters;
   XCMD_PARAMREADER  fnParser;
   BOOL              fVisited;

   __XCMD_PARAMETER_DESC(
      const TCHAR* _tszSwitch,
      DWORD _dwMinParameters,
      DWORD _dwMaxParameters,
      XCMD_PARAMREADER _fnParser) : 
         tszSwitch(_tszSwitch),
         dwMinParameters(_dwMinParameters),
         dwMaxParameters(_dwMaxParameters),
         fnParser(_fnParser),
         fVisited(FALSE) { }

} _XCMD_PARAMETER_DESC, * _PXCMD_PARAMETER_DESC;

BOOL __checkSwitch(TCHAR * tszArgument, DWORD dwPosition) {
   TCHAR rgtszSwitchChars[]=TEXT("-\\/");

   if (NULL == _tcschr(rgtszSwitchChars, tszArgument[0])) {
      FmtMessage(
         TEXT("ERROR: unexpected parameter encountered '%s' in position %d.\n"), 
         tszArgument, 
         dwPosition+1);

      return FALSE;
   }

   return TRUE;
}

BOOL __isSameSwitch(_PXCMD_PARAMETER_DESC pDescriptor, TCHAR * tszArgument) {
   return pDescriptor && _tcsicmp(pDescriptor->tszSwitch, tszArgument+1) == 0;
}

BOOL __enforceSingleVisit(_PXCMD_PARAMETER_DESC pDescriptor, TCHAR * tszArgument) {
   if (pDescriptor->fVisited) {
      FmtMessage(
         TEXT("ERROR: switch '%s' was specified more than once.\n"),
         tszArgument);

      return FALSE;
   }

   pDescriptor->fVisited = TRUE;

   return TRUE;
}

BOOL __checkParameters(PXCMD_PARAMETERS pxp) {
   if (NULL == pxp->szLogTarget) {
      FmtMessage(TEXT("ERROR: /logtarget switch was not specified.\n"));
      return FALSE;
   }

   if (0 == _tcslen(pxp->rgzExecutable)) {
      FmtMessage(TEXT("ERROR: /app switch was not specified.\n"));
      return FALSE;
   }

   return TRUE;
}

BOOL __enforceMinimumParameterRequirement(_PXCMD_PARAMETER_DESC pDescriptor, DWORD dwCount, DWORD dwPosition, TCHAR * tszArgument) {
   if (pDescriptor->dwMinParameters > dwCount - dwPosition - 1) {
      FmtMessage(
         TEXT("ERROR: switch '%s' requires at least %d parameters.\n"),
         tszArgument,
         pDescriptor->dwMinParameters);

      return FALSE;
   }

   return TRUE;
}

DWORD readCurrentDirectory(DWORD dwPosition, DWORD dwCount, TCHAR ** rgpszParameters, PXCMD_PARAMETERS pxp) {
   TCHAR rgzFullpath[MAX_PATH];
   TCHAR * pszFilename;

   pxp->szCurrentDirectory = NULL; //OK value, ignored if null
   if (_tcslen(rgpszParameters[dwPosition]) && 0 != _tcscmp(rgpszParameters[dwPosition], TEXT("."))) {
      if (!GetFullPathName(rgpszParameters[dwPosition], ARRAYSIZE(rgzFullpath), rgzFullpath, &pszFilename)) {
         FmtMessage(TEXT("ERROR: could not get full path name (%d): %s"), GetLastError(), rgpszParameters[dwPosition]);
         return 0;
      }

      if (NULL == (pxp->szCurrentDirectory = _tcsdup(rgzFullpath))) {
         FmtMessage(TEXT("ERROR: out of memory; could not read current directory parameter.\n"));
         return 0;
      }
   }

   return dwPosition + 1;
}

DWORD readLogTarget(DWORD dwPosition, DWORD dwCount, TCHAR ** rgpszParameters, PXCMD_PARAMETERS pxp) {
   TCHAR  rgzFullpath[MAX_PATH];
   TCHAR* pszFilename;

   if (_tcslen(rgpszParameters[dwPosition]) && 0 != _tcscmp(rgpszParameters[dwPosition], TEXT("."))) {
      if (!GetFullPathName(rgpszParameters[dwPosition], ARRAYSIZE(rgzFullpath), rgzFullpath, &pszFilename)) {
         FmtMessage(TEXT("ERROR: could not get full path name (%d): %s"), GetLastError(), rgpszParameters[dwPosition]);
         return 0;
      }

      if (NULL == (pxp->szLogTarget = _tcsdup(rgzFullpath))) {
         FmtMessage(TEXT("ERROR: out of memory; could not read log target parameter.\n"));
         return 0;
      }

      _tcsncpy_s(
         pxp->rgzLogDirectory, 
         ARRAYSIZE(pxp->rgzLogDirectory),
         pxp->szLogTarget, 
         pszFilename - rgzFullpath);
   }
   else {
      if (NULL == (pxp->szLogTarget = _tcsdup(TEXT("")))) {
         FmtMessage(TEXT("ERROR: out of memory; could not read log target parameter.\n"));
         return 0;
      }

      _tcscpy_s(
         pxp->rgzLogDirectory,
         ARRAYSIZE(pxp->rgzLogDirectory),
         TEXT(""));
   }

   return dwPosition + 1;
}

DWORD readUseShell(DWORD dwPosition, DWORD dwCount, TCHAR ** rgpszParameters, PXCMD_PARAMETERS pxp) {
   pxp->fUseShell = TRUE;

   return dwPosition;
}

DWORD readSplitLog(DWORD dwPosition, DWORD dwCount, TCHAR ** rgpszParameters, PXCMD_PARAMETERS pxp) {
   pxp->fSplitLog = TRUE;

   return dwPosition;
}

DWORD readApplication(DWORD dwPosition, DWORD dwCount, TCHAR ** rgpszParameters, PXCMD_PARAMETERS pxp) {
   DWORD dwCurrentParameter = 0;
   DWORD cchParameters = 0;

   for (DWORD c=dwPosition+1; c<dwCount; c++) //account for (space | null terminator) & quotes
      cchParameters += _tcslen(rgpszParameters[c])+3;

   cchParameters = max(cchParameters, 1);

   if (cchParameters > MAX_COMMAND_LINE_SIZE) {
      FmtMessage(
         TEXT("ERROR: executable command line is too long %d, max is %d.\n"),
         cchParameters,
         MAX_COMMAND_LINE_SIZE);

      return 0;
   }

   if (_tcslen(rgpszParameters[dwPosition]) >= ARRAYSIZE(pxp->rgzExecutable)) {
      FmtMessage(TEXT("ERROR: path too long; could not read the app executable path parameter.\n"));
      return 0;
   }

   _tcscpy_s(pxp->rgzExecutable, ARRAYSIZE(pxp->rgzExecutable), rgpszParameters[dwPosition]);

   if (NULL == (pxp->szCommandLine = (TCHAR*)malloc(cchParameters * sizeof(TCHAR)))) {
      FmtMessage(TEXT("ERROR: out of memory; could not alloc the app executable command line buffer.\n"));
      return 0;
   }

   memset(pxp->szCommandLine, 0, sizeof(TCHAR) * cchParameters);

   while (++dwPosition < dwCount) {
      dwCurrentParameter++;

      _tcscat_s(pxp->szCommandLine, cchParameters, TEXT("\""));
      _tcscat_s(pxp->szCommandLine, cchParameters, rgpszParameters[dwPosition]);
      _tcscat_s(pxp->szCommandLine, cchParameters, TEXT("\""));
      if (dwPosition + 1 < dwCount)
         _tcscat_s(pxp->szCommandLine, cchParameters, TEXT(" "));
   }

   return dwPosition;
}

VOID __allocParameterDescriptors(_PXCMD_PARAMETER_DESC * ppxpd) {
   ppxpd[0] = new _XCMD_PARAMETER_DESC(TEXT("logtarget"), 1, 1, readLogTarget);
   ppxpd[1] = new _XCMD_PARAMETER_DESC(TEXT("app"),       1, MAX_COMMAND_LINE_PARAMETERS, readApplication);
   ppxpd[2] = new _XCMD_PARAMETER_DESC(TEXT("shell"),     0, 0, readUseShell);
   ppxpd[3] = new _XCMD_PARAMETER_DESC(TEXT("cd"),        1, 1, readCurrentDirectory);
}

VOID FreeCommandLine(int argc, TCHAR **& argv) {
   if (argc && argv) {
      for (int c=0; c<argc; c++)
         if (argv[c])
            free(argv[c]);

      delete [] argv;
   }

   argv = NULL;
}

BOOL _GetEnvironmentVariable(TCHAR * EnvBuffer, DWORD cchEnvBuffer, const TCHAR * Name) {
   size_t ReturnSize;

   _tgetenv_s(&ReturnSize, EnvBuffer, cchEnvBuffer, Name);

   return 0 != ReturnSize;
}

HRESULT _ExpandItem(TCHAR * src, TCHAR ** target) {
   DWORD dwBuffer;

   dwBuffer = ExpandEnvironmentStrings(src, NULL, 0);
   if (!dwBuffer)
      return HRESULT_FROM_WIN32(GetLastError());
   
   if (!(*target = (TCHAR*)malloc(sizeof(TCHAR)*(dwBuffer+1)))) {
      FmtMessage(TEXT("ERROR: out of memory.\n"));
      return E_OUTOFMEMORY;
   }

   if (!(dwBuffer = ExpandEnvironmentStrings(src, *target, dwBuffer)))
      return HRESULT_FROM_WIN32(GetLastError());

   return S_OK;
}

HRESULT ExpandCommandLine(int argc, TCHAR ** argv, TCHAR *** target) {
   HRESULT hr = E_FAIL;

   if (NULL == (*target = new TCHAR *[argc])) {
      FmtMessage(TEXT("ERROR: out of memory.\n"));
      return E_OUTOFMEMORY;
   }

   __try {
      memset(*target, 0, sizeof(TCHAR*)*argc);

      for (int c=0; c<argc; c++) {
         if (FAILED(hr = _ExpandItem(argv[c], &((*target)[c])))) {
            FmtMessage(TEXT("ERROR: failed to expand command line argument"));
            __leave;
         }
      }

      hr = S_OK;
   }
   __finally {
      if (FAILED(hr))
         FreeCommandLine(argc, *target);
   }

   return hr;
}

HRESULT ProcessCommandLine(int argc, TCHAR ** argv, PXCMD_PARAMETERS pxp) {
   _PXCMD_PARAMETER_DESC   rgpParameterDesc[4]={0};
   HRESULT                 hr = E_FAIL;
   DWORD                   cParameterDesc=ARRAYSIZE(rgpParameterDesc);
   TCHAR **                ppszArguments = NULL;

   assert(argv);
   assert(pxp);

   if (argc < 1) {
      FmtMessage(TEXT("ERROR: no command line arguments were specified.\n"));
      return hr;
   }

   if (FAILED(hr = ExpandCommandLine(argc, argv, &ppszArguments))) {
      FmtMessage(TEXT("ERROR: failed to expand parameters.\n"));
      return hr;
   }

   __try {
      DWORD dwPosition, 
            dwCount;

      __allocParameterDescriptors(rgpParameterDesc);

      dwCount = (DWORD)argc;
      dwPosition = 0;

      while (dwPosition < dwCount) {
         TCHAR* szArgument = ppszArguments[dwPosition];

         hr = E_INVALIDARG;
         if (!__checkSwitch(szArgument, dwPosition))
            __leave;

         for (DWORD c=0; c<cParameterDesc+1; c++) {
            _PXCMD_PARAMETER_DESC pDescriptor = rgpParameterDesc[c];

            if (c == cParameterDesc) {
               FmtMessage(
                  TEXT("ERROR: unknown switch encountered '%s' in position %d.\n"),
                  szArgument,
                  dwPosition+1);

               __leave;
            }

            if (__isSameSwitch(pDescriptor, szArgument)) {
               if (!__enforceSingleVisit(pDescriptor, szArgument)) 
                  __leave;

               if (!__enforceMinimumParameterRequirement(pDescriptor, dwCount, dwPosition, szArgument))
                  __leave;

               dwPosition = pDescriptor->fnParser(
                  dwPosition+1, 
                  dwCount,
                  ppszArguments,
                  pxp);

               if (0 == dwPosition)
                  __leave; //each parser is responsible for creating error messages.

               break;
            }
         }
      }

      if (!__checkParameters(pxp))
         __leave;

      hr = S_OK;
   }
   __finally {
      for (DWORD c=0; c<cParameterDesc; c++) {
         if (rgpParameterDesc[c]) {
            delete rgpParameterDesc[c];
            rgpParameterDesc[c] = NULL;
         }
      }

      FreeCommandLine(argc, ppszArguments);
   }

   return hr;
}

VOID ClearParameters(PXCMD_PARAMETERS pxp) {
   if (pxp) {
      memset(pxp->rgzExecutable, 0, sizeof(pxp->rgzExecutable));
      SAFE_FREE(pxp->szCommandLine);
      SAFE_FREE(pxp->szLogTarget);
      SAFE_FREE(pxp->szCurrentDirectory);
   }
}

VOID DisplayParameters(PXCMD_PARAMETERS pxp) {
   if (pxp) {
      FmtMessage(TEXT("\nApplication Parameters\n"));
      FmtMessage(TEXT("  LogTarget  = '%s'\n"), _tcslen(pxp->szLogTarget) ? pxp->szLogTarget : TEXT("(none)"));
      FmtMessage(TEXT("  Use Shell  = %s\n"), pxp->fUseShell ? TEXT("yes") : TEXT("no"));
      FmtMessage(TEXT("  Executable = '%s'\n"), pxp->rgzExecutable);
      FmtMessage(TEXT("  Arguments  = '%s'\n"), pxp->szCommandLine);
      FmtMessage(TEXT("  CurrentDir = '%s'\n"), pxp->szCurrentDirectory ? pxp->szCurrentDirectory : TEXT("(default)"));
   }
}

BOOL writeTextToFile(HANDLE hFile, LPCTSTR szText) {
   DWORD dwWritten;

   if (sizeof(TCHAR) == sizeof(WCHAR)) {
      LPCWSTR wszText = (LPCWSTR)szText;
      CHAR abBuffer[2048] = {0};

      if (WideCharToMultiByte(CP_ACP, 0, wszText, -1, abBuffer, ARRAYSIZE(abBuffer), NULL, NULL))
         return WriteFile(hFile, abBuffer, strlen(abBuffer), &dwWritten, NULL);
   }

   return WriteFile(hFile, szText, _tcslen(szText) * sizeof(TCHAR), &dwWritten, NULL);
}

BOOL DisplayParameterToHandle(PXCMD_PARAMETERS pxp, HANDLE hFile) {
   return 
      writeTextToFile(hFile, TEXT("Application Parameters")) &&
      writeTextToFile(hFile, TEXT(" \n  LogTarget  = '")) &&
         writeTextToFile(hFile, _tcslen(pxp->szLogTarget) ? pxp->szLogTarget : TEXT("(none)")) &&
      writeTextToFile(hFile, TEXT("'\n  Use Shell  = ")) &&
         writeTextToFile(hFile, pxp->fUseShell ? TEXT("yes") : TEXT("no")) &&
      writeTextToFile(hFile, TEXT(" \n  Executable = '")) &&
         writeTextToFile(hFile, pxp->rgzExecutable) &&
      writeTextToFile(hFile, TEXT("'\n  Arguments  = '")) &&
         writeTextToFile(hFile, pxp->szCommandLine) &&
      writeTextToFile(hFile, TEXT("'\n  CurrentDir = '")) &&
         writeTextToFile(hFile, pxp->szCurrentDirectory ? pxp->szCurrentDirectory : TEXT("(default)")) &&
      writeTextToFile(hFile, TEXT("'\n------------------------------------------------------------\n\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\xcmd\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xcmd_none_12.4.56.0_none_b4e83963192af9ec
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xcmd_no-public-key_12.4.56.0_x-ww_6a7f5c58
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xcmd
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xcmd_no-public-key_12.4.56.0_x-ww_6a7f5c58
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xcmd_no-public-key_12.4.56.0_x-ww_6a7f5c58.manifest
XP_MANIFEST_PATH=manifests\x86_xcmd_no-public-key_12.4.56.0_x-ww_6a7f5c58.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xcmd_no-public-key_12.4.56.0_x-ww_6a7f5c58.cat
XP_CATALOG_PATH=manifests\x86_xcmd_no-public-key_12.4.56.0_x-ww_6a7f5c58.cat
XP_PAYLOAD_PATH=x86_xcmd_no-public-key_12.4.56.0_x-ww_6a7f5c58
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xcmd,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\xreg\xerr.cpp ===
#include "xreg.h"

DEFINE_ERROR(E_QUALIFIED_PATH_LENGTH1 , E_INVALIDARG  , "the length of the qualified path is too long.\npath=%s.\n");
DEFINE_ERROR(E_EMPTY_ARG1             , E_INVALIDARG  , "the specified argument cannot be null or empty.\narg=%s.\n");
DEFINE_ERROR(E_MISSING_REG_PATH1      , E_INVALIDARG  , "the qualified path is missing the registry path portion.\npath=%s.\n");
DEFINE_ERROR(E_WSA_STARTUP1           , E_FAIL        , "failed to startup windows sockets (%d).\n");
DEFINE_ERROR(E_GET_HOST_NAME1         , E_FAIL        , "failed to get the machine host name (%d).\n");
DEFINE_ERROR(E_CONVERT_HOST1          , E_FAIL        , "failed to convert host name from ANSI to UNICODE (%d).\n");
DEFINE_ERROR(E_EXTRACT_MACHINE_NAME1  , E_INVALIDARG  , "could not extract the machine name from the qualified path.\npath=%s.\n");
DEFINE_ERROR(E_EMPTY_KEYNODE1         , E_INVALIDARG  , "invalid path value, key node name cannot be empty.\npartial-path=%s.\n");
DEFINE_ERROR(E_INVALID_ROOT_KEY1      , E_INVALIDARG  , "invalid path value, root key is not valid, accept values are (HKCR, HKCC, HKCU, HKLM).\npartial-path=%s.\n");
DEFINE_ERROR(E_INADEQUATE_PATH2       , E_INVALIDARG  , "invalid path value, registry path requires a depth of at least 2.\ndepth=%d, partial-path=%s.\n");
DEFINE_ERROR(E_INVALID_KEY1           , E_INVALIDARG  , "invalid key value, key names must be prefixed with '@'.\npartial-path=%s.\n");
DEFINE_ERROR(E_EXTRACT_PARAMETERS1    , E_INVALIDARG  , "could not extract parameters from the qualified path.\npath=%s.\n");
DEFINE_ERROR(E_INVALID_ARG1           , E_INVALIDARG  , "the specified argument is invalid.\narg=%s.\n");
DEFINE_ERROR(E_CONNECT_REGISTRY4      , E_FAIL        , "failed to connect to remote registry: %s (%d).\nmachine=%s, key=%s.\n");
DEFINE_ERROR(E_CREATE_REG_SUBKEY4     , E_FAIL        , "failed to create subkey on remote registry: %s (%d).\nmachine=%s, subkey=%s.\n");
DEFINE_ERROR(E_CREATE_SUBKEY1         , E_FAIL        , "count not create subkey on qualified path.\npath=%s.\n");
DEFINE_ERROR(E_SET_REG_KEYVALUE3      , E_FAIL        , "failed to set registry key value: %s (%d).\npath=%s.\n");
DEFINE_ERROR(E_DELETE_REG_SUBKEY3     , E_FAIL        , "failed to delete registry key and subkeys: %s (%d).\nsubkey=%s.\n");
DEFINE_ERROR(E_OPEN_REG_SUBKEY3       , E_FAIL        , "failed to open registry subkey: %s (%d).\nsubkey=%s.\n");
DEFINE_ERROR(E_ENUM_REG_SUBKEY3       , E_FAIL        , "failed to enumerate registry subkeys: %s (%d).\nsubkey=%s.\n");
DEFINE_ERROR(E_DELETE_REG_VALUE4      , E_FAIL        , "failed to delete registry value: %s (%d).\nsubkey=%s value=%s.\n");

DEFINE_ERROR(E_CMD_TOO_FEW_PARAMS3    , E_INVALIDARG  , "too few parameters specified for command.\ncommand=%s, specified=%d of %d.\n");
DEFINE_ERROR(E_CMD_TOO_MANY_PARAMS2   , E_INVALIDARG  , "too many parameters specified for command.\ncommand=%s, required=%d.\n");
DEFINE_ERROR(E_BAD_PARAM_DWORD2       , E_INVALIDARG  , "the specified parameter is not a valid dword.\ncommand=%s, parameter=%s.\n");
DEFINE_ERROR(E_UNKNOWN_COMMAND1       , E_INVALIDARG  , "encountered an unknown command.\ncommand=%s.\n");
DEFINE_ERROR(E_COMMAND_TOO_LONG       , E_INVALIDARG  , "command too long to process.\n");
DEFINE_ERROR(E_READ_COMMAND2          , E_FAIL        , "failed to read from the command pipe: %s (%d).\n");
DEFINE_ERROR(E_READ_COMMAND_END       , E_FAIL        , "unexpected in of file or pipe.\n");
DEFINE_ERROR(E_NO_CODE                , E_FAIL        , "this piece of functionality has not been coded.\n");
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\xreg\xreg-cps.cpp ===
/* XREG - Command Processing Stage */

#include "xreg.h"

HRESULT GetMultistringParameters(LPCTSTR szCommand, LPCTSTR* pszParameters, DWORD dwMin, DWORD dwMax, DWORD * pdwCount) {
   LPCTSTR szParameter;
   DWORD   dwCount = 0;
   LONG    lMax = (LONG)dwMax;
   LONG    lMin = (LONG)dwMin;

   szParameter = __nextParameter(szCommand);
   while (szParameter[0]) {
      if (!lMax)
         RETURN_ERROR(E_CMD_TOO_MANY_PARAMS2, szCommand, dwMax);

      pszParameters[0] = szParameter;
      
      szParameter = __nextParameter(szParameter);
      pszParameters++;
      lMax--;
      lMin--;
      dwCount++;
   }

   if (lMin > 0)
      RETURN_ERROR(E_CMD_TOO_FEW_PARAMS3, szCommand, dwMin - lMin, dwMin);

   if (pdwCount)
      *pdwCount = dwCount;

   return S_OK;
}

HRESULT GetMultistringParameters(LPCTSTR szCommand, LPCTSTR* pszParameters, DWORD dwCount) {
   return GetMultistringParameters(szCommand, pszParameters, dwCount, dwCount, NULL);
}

HRESULT ProcessCommand(TCHAR * szCommand) {
   LPCTSTR Parameters[4];
   HRESULT hr;

   if (!_tcsicmp(szCommand, COMMAND_WRITE_STRING)) {
      TOKEN Token;

      if (FAILED(hr = GetMultistringParameters(szCommand, Parameters, 2)))
         return hr;

      Token.dwType = TOKEN_TYPE_STRING;
      Token.Value.sz = Parameters[1];

      _tprintf(TEXT("Writing Registry String:\n   path  = %s\n   value = %s\n"), Parameters[0], Token.Value.sz);

      return WriteRegistry(Parameters[0], &Token);
   }
   else if (!_tcsicmp(szCommand, COMMAND_WRITE_DWORD)) {
      TOKEN Token;
      BOOL Parsed;

      if (FAILED(hr = GetMultistringParameters(szCommand, Parameters, 2)))
         return hr;

      Token.dwType = TOKEN_TYPE_DWORD;
      if (_tcsnicmp(Parameters[1], TEXT("0x"), 2))
         Parsed = (1 == _stscanf_s(Parameters[1], TEXT("%d"), &Token.Value.dw));
      else
         Parsed = (1 == _stscanf_s(Parameters[1]+2, TEXT("%x"), &Token.Value.dw));

      if (!Parsed)
         RETURN_ERROR(E_BAD_PARAM_DWORD2, szCommand, Parameters[1]);

      _tprintf(TEXT("Writing Registry DWORD:\n   path  = %s\n   value = %d\n"), Parameters[0], Token.Value.dw);

      return WriteRegistry(Parameters[0], &Token);
   }
   else if (!_tcsicmp(szCommand, COMMAND_DELETE)) {
      if (FAILED(hr = GetMultistringParameters(szCommand, Parameters, 1)))
         return hr;

      _tprintf(TEXT("Deleting Registry Key:\n   path  = %s\n"), Parameters[0]);

      return DeleteRegistry(Parameters[0]);
   }
   else
      RETURN_ERROR(E_UNKNOWN_COMMAND1, szCommand);
}

#define STATE_INIT         0
#define STATE_COMMAND      1
#define STATE_BLOCK_END    2
#define STATE_PARAMETER    3

HRESULT __ReadCommand(HANDLE hCommandSource, LPTSTR abBuffer, DWORD cchBuffer) {
   DWORD dwState;
   DWORD dwRead;
   TCHAR chPeek, chLast;

   cchBuffer--;
   dwState = STATE_INIT;
   while (cchBuffer && ReadFile(hCommandSource, &chPeek, sizeof(TCHAR), &dwRead, NULL)) {
      if (chPeek == TEXT('\r')) /// Text processing, ignored
         continue;
      else if (chPeek == TEXT('\n')) { /// Text process, automatically ends a command
         if (2 > cchBuffer)
            RETURN_ERROR(E_COMMAND_TOO_LONG);

         abBuffer[0] = abBuffer[1] = TEXT('\0');
         
         return S_OK;
      }
      else
         abBuffer[0] = chPeek;

      switch (dwState) {
         case STATE_INIT:
            if  (abBuffer[0]) dwState = STATE_COMMAND;
            else return S_OK; //Protocol for end of command stream
            break;
         case STATE_COMMAND:
            if (!abBuffer[0]) dwState = STATE_BLOCK_END;
            break;
         case STATE_BLOCK_END:
            if (abBuffer[0]) dwState = STATE_PARAMETER;
            else return S_OK; //Protocol for last command
            break;
         case STATE_PARAMETER:
            if (!abBuffer[0]) dwState = STATE_BLOCK_END;
            break;
      }

      abBuffer++;
      cchBuffer--;
      chLast = chPeek;
   }

   if (0 == cchBuffer) {
      RETURN_ERROR(E_COMMAND_TOO_LONG);
   }
   else if (ERROR_BROKEN_PIPE == GetLastError()) {
      abBuffer[0] = abBuffer[1] = TEXT('\0'); /// Terminate the command

      if (dwState == STATE_INIT || dwState == STATE_BLOCK_END)
         return S_OK;
      else {
         RETURN_ERROR(E_READ_COMMAND_END);
      }
   }
   else {
      RETURN_ERROR_WITH_MSG(E_READ_COMMAND2, GetLastError(), Message, GetLastError());
   }

   return S_OK;
}

HRESULT ProcessCommandPipe(HANDLE hCommandSource) {
   TCHAR CommandBuffer[1024];
   HRESULT hr;
   
   while (SUCCEEDED(hr = __ReadCommand(hCommandSource, CommandBuffer, ARRAYSIZE(CommandBuffer)))) {
      if (0 == _tcslen(CommandBuffer))
         break; //Done

      if (FAILED(hr = ProcessCommand(CommandBuffer)))
         break;
   }

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\xreg\xipe.h ===
#ifndef __XONLINE_REG_IPE_H__
#define __XONLINE_REG_IPE_H__

#define TOKEN_TYPE_STRING  0xfeedbabe
#define TOKEN_TYPE_DWORD   0x1badb001

#define REGISTER_COUNT     8

typedef struct _TOKEN {
   union {
      LPCTSTR sz;
      DWORD   dw;
   } Value;

   DWORD dwType;
} TOKEN, * PTOKEN;

struct less_str : public std::binary_function <LPTSTR, LPTSTR, bool> 
{
   bool operator()(TCHAR * const _Left, TCHAR * const _Right) const {
      return 0 < _tcscmp(_Left, _Right);
   }

   bool operator()(const TCHAR * const _Left, const TCHAR * const _Right) const {
      return 0 < _tcscmp(_Left, _Right);
   }
};

typedef std::map<LPTSTR, LPTSTR, less_str> token_map, replace_map;
typedef std::pair<LPTSTR, LPTSTR> replacement;
typedef std::vector<replacement> reg_stack;
/* 
   Token Treatment
   - add ability for context based lookup
 */
typedef struct _IPEnvironment {
   reg_stack   Registers[REGISTER_COUNT];
   token_map   Tokens;
} IPEnvironment, * PIPEnvironment;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\xreg\xerr.h ===
#ifndef __XONLINE_REG_ERRORS_H__
#define __XONLINE_REG_ERRORS_H__

#define DECLARE_ERROR(x)					\
	extern const HRESULT x;					\
	extern LPCTSTR x##_STR;

#define DEFINE_ERROR(x, code, msg)		\
	const HRESULT x = (HRESULT)code;		\
	LPCTSTR x##_STR	 = TEXT(msg);

#define GET_MESSAGE(err, abBuf)          \
   FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,0,err,0,abBuf,ARRAYSIZE(abBuf),NULL) 

#define PRINT_ERROR(x, ...)				\
	_tprintf(TEXT("ERR(%08x): "), x);	\
	_tprintf(x##_STR, __VA_ARGS__);

#define RETURN_ERROR(x, ...)				\
{													\
	PRINT_ERROR(x, __VA_ARGS__);			\
	return x;									\
}

#define RETURN_ERROR_WITH_MSG(x, err, ...)   \
{                                            \
   TCHAR    Message[256] = {0};        \
   GET_MESSAGE(err, Message);          \
   RETURN_ERROR(x, __VA_ARGS__);              \
}

#define SAFE_CLOSE(x) if ((x)) { CloseHandle(x); (x) = NULL; }

DECLARE_ERROR(E_QUALIFIED_PATH_LENGTH1);
DECLARE_ERROR(E_EMPTY_ARG1);
DECLARE_ERROR(E_MISSING_REG_PATH1);
DECLARE_ERROR(E_WSA_STARTUP1);
DECLARE_ERROR(E_GET_HOST_NAME1);
DECLARE_ERROR(E_CONVERT_HOST1);
DECLARE_ERROR(E_EXTRACT_MACHINE_NAME1);
DECLARE_ERROR(E_EMPTY_KEYNODE1);
DECLARE_ERROR(E_INVALID_ROOT_KEY1);
DECLARE_ERROR(E_INADEQUATE_PATH2);
DECLARE_ERROR(E_INVALID_KEY1);
DECLARE_ERROR(E_EXTRACT_PARAMETERS1);
DECLARE_ERROR(E_INVALID_ARG1);
DECLARE_ERROR(E_CONNECT_REGISTRY4);
DECLARE_ERROR(E_CREATE_REG_SUBKEY4);
DECLARE_ERROR(E_CREATE_SUBKEY1);
DECLARE_ERROR(E_SET_REG_KEYVALUE3);
DECLARE_ERROR(E_DELETE_REG_SUBKEY3);
DECLARE_ERROR(E_OPEN_REG_SUBKEY3);
DECLARE_ERROR(E_ENUM_REG_SUBKEY3);
DECLARE_ERROR(E_DELETE_REG_VALUE4);
DECLARE_ERROR(E_CMD_TOO_FEW_PARAMS3);
DECLARE_ERROR(E_CMD_TOO_MANY_PARAMS2);
DECLARE_ERROR(E_BAD_PARAM_DWORD2);
DECLARE_ERROR(E_UNKNOWN_COMMAND1);
DECLARE_ERROR(E_COMMAND_TOO_LONG);
DECLARE_ERROR(E_READ_COMMAND2);
DECLARE_ERROR(E_READ_COMMAND_END);
DECLARE_ERROR(E_NO_CODE);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\xreg\main.cpp ===
#include "xreg.h"

void __collect(TCHAR* Buffer, size_t Length) {
   _tprintf(TEXT("\n > "));
   _getts_s(Buffer, Length - 1);
}

IPEnvironment g_Environment;

std::list<LPTSTR>::iterator __tryInc(std::list<LPTSTR>* pList, std::list<LPTSTR>::iterator it, int count = 1) {
   while (count-- > 0)
      it = pList->end() == it ? it : ++it;

   return it;
}

void BreakInput(std::list<LPTSTR>* ptokenlist, std::list<LPTSTR>::iterator at, LPTSTR szString, LPCTSTR szTokens) {
   TCHAR * Current, * Context;

   at = __tryInc(ptokenlist, at);

   Current = _tcstok_s(szString, szTokens, &Context);
   while (Current) {
      at = ++ptokenlist->insert(at, Current);
      Current = _tcstok_s(NULL, szTokens, &Context);
   }
}

HRESULT FeedFileToPipe(HANDLE hSrc, LPCTSTR szPath) {
   FILE * fpInput;
   TCHAR* szTemp;

   if ( 0 == _tfopen_s( &fpInput, szPath, TEXT("r") ) ) {
      while (!feof(fpInput)) {
         std::list<LPTSTR> tokenlist;
         std::list<LPTSTR>::iterator at, next;

         TCHAR abLineBuffer[1024] = {0};

         if (_fgetts(abLineBuffer, ARRAYSIZE(abLineBuffer), fpInput)) {
            _tcstok_s(abLineBuffer, TEXT("\n"), &szTemp);

            BreakInput(&tokenlist, tokenlist.begin(), abLineBuffer, TEXT("\""));

            at = tokenlist.begin();
            while (at != tokenlist.end()) {
               next = at;
               next = __tryInc(&tokenlist, at, 2);
               BreakInput(&tokenlist, at, *at, TEXT(" \t"));
               tokenlist.erase(at);
               at = next;
            }

            if (tokenlist.size()) {
               DWORD dwWritten;
               DWORD dwTokens = 0;

               for (at=tokenlist.begin(); at != tokenlist.end(); at++) {
                  if (_tcslen(*at)) {
                     dwTokens ++;
                     if (!WriteFile(hSrc, *at, (_tcslen(*at)+1)*sizeof(TCHAR), &dwWritten, NULL)) {
                        fclose(fpInput);
                        return E_FAIL;
                     }
                  }
               }

               if (dwTokens) {
                  if (!WriteFile(hSrc, TEXT("\0"), sizeof(TCHAR), &dwWritten, NULL)) {
                     fclose(fpInput);
                     return E_FAIL;
                  }
               }
            }
         }
      }

      fclose(fpInput);

      return S_OK;
   }

   return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
}

int __cdecl _tmain(int argc, TCHAR ** argv) {
   PIPEnvironment pEnvironment = NULL;
   
   HANDLE hInputSrc,    hInputSink;
   HANDLE hReplaceSrc,  hReplaceSink;
   HANDLE hTokenSrc,    hTokenSink;
   HANDLE hCommandSrc,  hCommandSink;

   HRESULT hr;

   if (argc == 1) {
      _tprintf(TEXT("no input files specified.\n"));
      return E_INVALIDARG;
   }

   pEnvironment = &g_Environment;

   CreatePipe(&hInputSink,    &hInputSrc,    NULL, 0x10000);
   CreatePipe(&hReplaceSink,  &hReplaceSrc,  NULL, 0x10000);
   CreatePipe(&hTokenSink,    &hTokenSrc,    NULL, 0x10000);
   CreatePipe(&hCommandSink,  &hCommandSrc,  NULL, 0x1000000);

   if (ERROR_SUCCESS != GetLastError()) {
      _tprintf(TEXT("ERROR: could not create communication pipes (%d).\n"), GetLastError());
      return GetLastError();
   }

   __try {
      for (int c=1; c<argc; c++) {
         hr = FeedFileToPipe(hInputSrc, argv[c]);

         if (FAILED(hr)) {
            _tprintf(TEXT("ERROR: failed to read input from file (%08x).\npath=%s\n"), hr, argv[c]);
            __leave;
         }
      }

      SAFE_CLOSE(hInputSrc);
      hr = InputCommandPipe(pEnvironment, hInputSink, hReplaceSrc);
      SAFE_CLOSE(hInputSink);

      if (FAILED(hr)) {
         _tprintf(TEXT("ERROR: failed to process input stage (%08x).\n"), hr);
         __leave;
      }

      SAFE_CLOSE(hReplaceSrc);
      hr = ReplaceCommandPipe(pEnvironment, hReplaceSink, hTokenSrc);
      SAFE_CLOSE(hReplaceSink);

      if (FAILED(hr)) {
         _tprintf(TEXT("ERROR: failed to perform string replacement stage (%08x).\n"), hr);
         __leave;
      }

      SAFE_CLOSE(hTokenSrc);
      hr = TokenExpandCommandPipe(pEnvironment, hTokenSink, hCommandSrc);
      SAFE_CLOSE(hTokenSink);

      if (FAILED(hr)) {
         _tprintf(TEXT("ERROR: failed to perform token expansion stage (%08x).\n"), hr);
         __leave;
      }

      SAFE_CLOSE(hCommandSrc);
      hr = ProcessCommandPipe(hCommandSink);
      SAFE_CLOSE(hCommandSink);

      if (FAILED(hr)) {
         _tprintf(TEXT("ERROR: failed to process command stage (%08x).\n"), hr);
         __leave;
      }
   }
   __finally {
      SAFE_CLOSE(hInputSrc);
      SAFE_CLOSE(hInputSink);
      SAFE_CLOSE(hReplaceSrc);
      SAFE_CLOSE(hReplaceSink);
      SAFE_CLOSE(hTokenSrc);
      SAFE_CLOSE(hTokenSink);
      SAFE_CLOSE(hCommandSrc);
      SAFE_CLOSE(hCommandSink);

      CleanupEnvironment(pEnvironment);
   }

   _tprintf(TEXT("exit code(%08x)"), hr);

   return (int)hr;

   /*
   TCHAR Buffer[1024] = {0};
   TOKEN Token;

   __collect(Buffer, ARRAYSIZE(Buffer));

   Token.Value.sz = TEXT("Testing xreg...");
   Token.dwType = TOKEN_TYPE_STRING;

   Environment.Tokens[TEXT("machine")] = TEXT("jojohn2\0jojohn-w2k3-001\0");
   Environment.Tokens[TEXT("comp")] = TEXT("database\0widgets\0frontdoor\0");
   Environment.Registers[0].push_back(replacement(TEXT("JOJOHN-W2K3-001"), TEXT("%machine%")));
   Environment.Registers[1].push_back(replacement(TEXT("/"), TEXT("\\")));

   while (_tcsicmp(Buffer, TEXT("quit"))) {
      if (!_tcsnicmp(Buffer, TEXT("w "), 2))
         WriteRegistry(Buffer+2, &Token);
      else if (!_tcsnicmp(Buffer, TEXT("d "), 2))
         DeleteRegistry(Buffer+2);
      else if (!_tcsicmp(Buffer, TEXT("token")))
         TokenExpandCommand(&Environment, TEXT("w \0\\\\%machine%\\@%comp%\0%machine%\n\0"), GetStdHandle(STD_OUTPUT_HANDLE));
      else if (!_tcsicmp(Buffer, TEXT("replace")))
         ReplaceCommand(&Environment, TEXT("w \0//JOJOHN-W2K3-001/@%comp%\0%machine%\n\0"), GetStdHandle(STD_OUTPUT_HANDLE));

      __collect(Buffer, ARRAYSIZE(Buffer));
   }
   */
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\xreg\xreg-ips.cpp ===
/* XREG - Input Processing Stage */

#include "xreg.h"

BOOL __GetDWORD(LPCTSTR szSource, DWORD* pdw) {
   return 1 == _stscanf_s(szSource, TEXT("%d"), pdw);
}

VOID __PopStack(reg_stack * pRegister) {
   replacement * pReplacement;

   pReplacement = &pRegister->back();
   pRegister->pop_back();

   free(pReplacement->first);
   free(pReplacement->second);
}

VOID __ClearToken(token_map * pTokens, token_map::iterator it) {
   if (it != pTokens->end()) {
      free(it->first);
      free(it->second);
      pTokens->erase(it);
   }
}

HRESULT ForwardCommand(LPCTSTR szCommand, HANDLE hCommandOutput) {
   LPCTSTR szEnd = szCommand;
   DWORD dwWritten;
   size_t cchBlock;

   while (cchBlock = _tcslen(szEnd))
      szEnd += cchBlock + 1;

   if (!WriteFile(hCommandOutput, szCommand, ((szEnd - szCommand) + 1)*sizeof(TCHAR), &dwWritten, NULL))
      return HRESULT_FROM_WIN32(GetLastError());

   return S_OK;
}

HRESULT InputCommand(PIPEnvironment pEnvironment, LPCTSTR szCommand, HANDLE hCommandOutput) {
   LPCTSTR Parameters[4];
   HRESULT hr;

   if (!_tcsicmp(szCommand, INPUT_PUSH_RREG)) { // push [0-7] [search] [replace-value]
      DWORD dwRegister;

      if (FAILED(hr = GetMultistringParameters(szCommand, Parameters, 3)))
         return hr;

      if (!__GetDWORD(Parameters[0], &dwRegister))
         RETURN_ERROR(E_BAD_PARAM_DWORD2, szCommand, Parameters[0]);

      if (dwRegister >= REGISTER_COUNT)
         return E_FAIL;

      pEnvironment->Registers[dwRegister].push_back(
         replacement(_tcsdup(Parameters[1]), _tcsdup(Parameters[2])));
   }
   else if (!_tcsicmp(szCommand, INPUT_POP_RREG)) { // pop [0-7]
      DWORD dwRegister;

      if (FAILED(hr = GetMultistringParameters(szCommand, Parameters, 1)))
         return hr;

      if (!__GetDWORD(Parameters[0], &dwRegister))
         RETURN_ERROR(E_BAD_PARAM_DWORD2, szCommand, Parameters[0]);

      if (dwRegister >= REGISTER_COUNT)
         return E_FAIL;

      __PopStack(&pEnvironment->Registers[dwRegister]);      
   }
   else if (!_tcsicmp(szCommand, INPUT_CLEAR_REPLACE)) { // clear [0-7]
      DWORD dwRegister;

      if (FAILED(hr = GetMultistringParameters(szCommand, Parameters, 1)))
         return hr;

      if (!__GetDWORD(Parameters[0], &dwRegister))
         RETURN_ERROR(E_BAD_PARAM_DWORD2, szCommand, Parameters[0]);

      if (dwRegister >= REGISTER_COUNT)
         return E_FAIL;

      while (pEnvironment->Registers[dwRegister].size())
         __PopStack(&pEnvironment->Registers[dwRegister]);
   }
   else if (!_tcsicmp(szCommand, INPUT_ADD_TOKEN)) { // add [token] [value1;value2;...;valueN]
      LPTSTR Values;
      LPTSTR Context;
      size_t cchBuffer;

      if (FAILED(hr = GetMultistringParameters(szCommand, Parameters, 2)))
         return hr;

      __ClearToken(&pEnvironment->Tokens, pEnvironment->Tokens.find((LPTSTR)Parameters[0]));

      if (_tcsstr(Parameters[1], TEXT(";;")))
         return E_INVALIDARG;

      cchBuffer = _tcslen(Parameters[1])+2;
      Values = (TCHAR*)malloc(cchBuffer*sizeof(TCHAR));
      _tcscpy_s(Values, cchBuffer, Parameters[1]);
      Values[cchBuffer-1] = TEXT('\0');

      pEnvironment->Tokens[_tcsdup(Parameters[0])] = Values;
      
      /// Tokenize the values
      while (_tcstok_s(Values, TEXT(";"), &Context))
         Values = NULL;
   }
   else if (!_tcsicmp(szCommand, INPUT_DEL_TOKEN)) {
      if (FAILED(hr = GetMultistringParameters(szCommand, Parameters, 1)))
         return hr;

      __ClearToken(&pEnvironment->Tokens, pEnvironment->Tokens.find((LPTSTR)Parameters[0]));
   }
   else
      return ForwardCommand(szCommand, hCommandOutput);

   return S_OK;
}

HRESULT InputCommandPipe(PIPEnvironment pEnvironment, HANDLE hCommandSource, HANDLE hCommandOutput) {
   TCHAR CommandBuffer[1024];
   HRESULT hr;
   
   while (SUCCEEDED(hr = __ReadCommand(hCommandSource, CommandBuffer, ARRAYSIZE(CommandBuffer)))) {
      if (0 == _tcslen(CommandBuffer))
         break; //Done
      if (FAILED(hr = InputCommand(pEnvironment, CommandBuffer, hCommandOutput)))
         break;
   }

   return hr;
}

VOID CleanupEnvironment(PIPEnvironment pEnvironment) {
   for (int c=0; c<ARRAYSIZE(pEnvironment->Registers); c++) {
      while (pEnvironment->Registers[c].size())
         __PopStack(&pEnvironment->Registers[c]);
   }

   while (pEnvironment->Tokens.begin() != pEnvironment->Tokens.end())
      __ClearToken(&pEnvironment->Tokens, pEnvironment->Tokens.begin());
      
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\xreg\xreg-rps.cpp ===
/* XREG - Replacement Processing Stage */

#include "xreg.h"

HRESULT ReplaceCommand(PIPEnvironment pEnvironment, LPCTSTR szCommand, HANDLE hCommandOutput) {
   LPCTSTR  Parameters[MAX_PARAMETERS];
   DWORD    dwCount;
   HRESULT  hr;
   DWORD    dwWritten;
   TCHAR    EmptyCharacter = TEXT('\0');

   if (FAILED(hr = GetMultistringParameters(szCommand, Parameters, 0, ARRAYSIZE(Parameters), &dwCount)))
      return hr;

   if (!WriteFile(hCommandOutput, szCommand, (_tcslen(szCommand)+1)*sizeof(TCHAR), &dwWritten, NULL))
      return E_FAIL;

   for (int c=0; c<(int)dwCount; c++) {
      LPCTSTR szEnd = NULL;
      LPCTSTR szStart = Parameters[c];

      while (szStart[0]) {
         LPCTSTR szValue = NULL;
         LPCTSTR szReplacement = NULL;

         szEnd = szStart + _tcslen(szStart);
         for (int r=0; r<ARRAYSIZE(pEnvironment->Registers); r++) {
            LPCTSTR szOccurance;

            if (pEnvironment->Registers[c].size()) {
               szOccurance = _tcsstr(szStart, pEnvironment->Registers[c].back().first);
               if (szOccurance && szOccurance < szEnd) {
                  szEnd = szOccurance;
                  szReplacement = pEnvironment->Registers[c].back().first;
                  szValue = pEnvironment->Registers[c].back().second;
               }
            }
         }

         if (szStart != szEnd) {
            if (!WriteFile(hCommandOutput, szStart, (szEnd-szStart)*sizeof(TCHAR), &dwWritten, NULL))
               return E_FAIL;
         }

         if (szReplacement && szValue) {
            if (!WriteFile(hCommandOutput, szValue, _tcslen(szValue)*sizeof(TCHAR), &dwWritten, NULL))
               return E_FAIL;
            szEnd += _tcslen(szReplacement);
         }

         szStart = szEnd;
      }

      if (!WriteFile(hCommandOutput, &EmptyCharacter, sizeof(EmptyCharacter), &dwWritten, NULL))
         return E_FAIL;
   }

   if (!WriteFile(hCommandOutput, &EmptyCharacter, sizeof(EmptyCharacter), &dwWritten, NULL))
      return E_FAIL;

   return S_OK;
}

HRESULT ReplaceCommandPipe(PIPEnvironment pEnvironment, HANDLE hCommandSource, HANDLE hCommandOutput) {
   TCHAR CommandBuffer[1024];
   HRESULT hr;
   
   while (SUCCEEDED(hr = __ReadCommand(hCommandSource, CommandBuffer, ARRAYSIZE(CommandBuffer)))) {
      if (0 == _tcslen(CommandBuffer))
         break; //Done

      if (FAILED(hr = ReplaceCommand(pEnvironment, CommandBuffer, hCommandOutput)))
         break;
   }

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\xreg\xreg-qpp.cpp ===
/* XREG - Qualified Path Parser */

#include "xreg.h"

HRESULT _ExtractMachineName(LPCTSTR szQualifiedPath, LPCTSTR* pszMark, LPTSTR abMachine) {
	assert(MAX_MACHINE_LENGTH > MACHINE_PREFIX_LEN);

	if (!_tcsncmp(szQualifiedPath, SC_MACHINE_PREFIX, MACHINE_PREFIX_LEN)) {
		if (NULL == (*pszMark = _tcschr(szQualifiedPath + MACHINE_PREFIX_LEN, SC_PATH_SEP)))
			RETURN_ERROR(E_MISSING_REG_PATH1, szQualifiedPath);

		_tcsncpy_s(abMachine, MAX_MACHINE_LENGTH, szQualifiedPath, *pszMark - szQualifiedPath);
	}
	else {
      WSADATA wsa;

		(*pszMark) = szQualifiedPath;

		_tcscpy_s(abMachine, MAX_MACHINE_LENGTH, SC_MACHINE_PREFIX);
      if (WSAStartup( MAKEWORD(2, 2), &wsa))
         RETURN_ERROR(E_WSA_STARTUP1, WSAGetLastError());

      __try {
#ifdef UNICODE
		CHAR AnsiHost[MAX_MACHINE_LENGTH-MACHINE_PREFIX_LEN] = {0};
		TCHAR WideHost[MAX_MACHINE_LENGTH-MACHINE_PREFIX_LEN] = {0};

		if (gethostname(AnsiHost, ARRAYSIZE(AnsiHost)))
			RETURN_ERROR(E_GET_HOST_NAME1, WSAGetLastError());
		if (!MultiByteToWideChar(CP_ACP, 0, AnsiHost, ARRAYSIZE(AnsiHost), WideHost, ARRAYSIZE(WideHost)))
			RETURN_ERROR(E_CONVERT_HOST1, GetLastError());

		_tcscat_s(abMachine, MAX_MACHINE_LENGTH, WideHost);
#else
		if (gethostname(abMachine+MACHINE_PREFIX_LEN, MAX_MACHINE_LENGTH-MACHINE_PREFIX_LEN))
			RETURN_ERROR(E_GET_HOST_NAME1, WSAGetLastError());
#endif
      }
      __finally {
         WSACleanup();
      }
	}

	(*pszMark)++;

	return S_OK;
}

BOOL __validateKeyLength(LPCTSTR Start, LPCTSTR End) {
   return End ? ( Start != End ) : _tcslen(Start) > 0;
}

BOOL __validateRootKeyIIFWeAreAtRoot(int Depth, LPCTSTR Start, LPCTSTR End) {
   if (1 == Depth) { /* We are at the root */
      TCHAR    Buffer[ROOT_KEY_LENGTH+2] = {0};
      LPCTSTR  RootCompare = SC_ALLOWED_ROOT_KEYS;

      _tcsncpy_s(Buffer, ARRAYSIZE(Buffer), Start, min(End - Start, ROOT_KEY_LENGTH+1));
      
      while (RootCompare[0]) {
         if (_tcsnicmp(Buffer, RootCompare, ROOT_KEY_LENGTH+1))
            RootCompare += _tcslen(RootCompare)+1;
         else
            return TRUE;
      }

      return FALSE;
   }

   return TRUE;
}

HRESULT _ExtractRegistryPath(LPCTSTR szPartialPath, LPCTSTR* pszMark, LPTSTR abPath) {
	LPCTSTR Next;
   LPCTSTR Current;
   int Depth = 0;

   abPath[0] = 0;
   Current = szPartialPath;
   Next = _tcschr(Current, SC_PATH_SEP);

   while (Current) {
      Depth++;

      if (Next) {
         if (!__validateKeyLength(Current, Next))
            RETURN_ERROR(E_EMPTY_KEYNODE1, szPartialPath);

         if (!__validateRootKeyIIFWeAreAtRoot(Depth, Current, Next))
            RETURN_ERROR(E_INVALID_ROOT_KEY1, szPartialPath);

         _tcsncat_s(abPath, MAX_REGPATH_LENGTH, Current, (++Next) - Current);
         *pszMark = Next;
      }
      else if (Current != _tcschr(Current, SC_KEY_PREFIX)) {
         if (!__validateKeyLength(Current, NULL))
            RETURN_ERROR(E_EMPTY_KEYNODE1, abPath);

         _tcscat_s(abPath, MAX_REGPATH_LENGTH, Current);
         _tcscat_s(abPath, MAX_REGPATH_LENGTH, SC_PATH_SEP_STR);
         *pszMark = Current + _tcslen(Current);
      }
      else
         Depth--;

      if (Current = Next)
         Next = _tcschr(Next, SC_PATH_SEP);
   }

   if (Depth < 2)
      RETURN_ERROR(E_INADEQUATE_PATH2, Depth, szPartialPath);

   return S_OK;
}

HRESULT _ExtractKeyName(LPCTSTR szPartialPath, LPCTSTR* pszMark, LPTSTR abKey) {
   if (szPartialPath == _tcschr(szPartialPath, SC_KEY_PREFIX) && 1 < _tcslen(szPartialPath))
      _tcscpy_s(abKey, MAX_KEY_LENGTH, szPartialPath + 1);
   else if (0 == _tcslen(szPartialPath))
      abKey[0] = 0;
   else
      RETURN_ERROR(E_INVALID_KEY1, szPartialPath);

	return S_OK;
}

HRESULT _ExtractPathComponents(LPCTSTR szQualifiedPath, LPTSTR abMachine, LPTSTR abPath, LPTSTR abKey) {
	LPCTSTR Mark;

	if (szQualifiedPath && MAX_QUALIFIED_PATH == _tcsnlen(szQualifiedPath, MAX_QUALIFIED_PATH))
		RETURN_ERROR(E_QUALIFIED_PATH_LENGTH1, szQualifiedPath);

	if (!szQualifiedPath || !_tcslen(szQualifiedPath))
		RETURN_ERROR(E_EMPTY_ARG1, TEXT("machine and path qualified registry key"));

	if (FAILED(_ExtractMachineName(szQualifiedPath, &Mark, abMachine)))
		RETURN_ERROR(E_EXTRACT_MACHINE_NAME1, szQualifiedPath);

	if (FAILED(_ExtractRegistryPath(Mark, &Mark, abPath)))
		RETURN_ERROR(E_NO_CODE, szQualifiedPath);

	if (FAILED(_ExtractKeyName(Mark, &Mark, abKey)))
		RETURN_ERROR(E_NO_CODE, szQualifiedPath);

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\xreg\xreg.cpp ===
#include "xreg.h"

HRESULT _ExtractMachineName(LPCTSTR szQualifiedPath, LPCTSTR* pszMark, LPTSTR abMachineName);
HRESULT _ExtractRegistryPath(LPCTSTR szQualifiedPath, LPCTSTR* pszMark, LPTSTR abPath);
HRESULT _ExtractKeyName(LPCTSTR szQualifiedPath, LPCTSTR* pszMark, LPTSTR abKey);
HRESULT _ExtractPathComponents(LPCTSTR szQualifiedPath, LPTSTR abMachine, LPTSTR abPath, LPTSTR abKey);

inline LPCTSTR __GetSubkeyPath(LPCTSTR szPath) {
   return szPath + ROOT_KEY_LENGTH + 1;
}

HRESULT _ConnectToRoot(LPCTSTR szMachine, LPCTSTR szPath, HKEY* phkRoot) {
   TCHAR    SystemMessage[256] = {0};
   LONG     lResult;
   LPCTSTR  szRoots[] = { 
      TEXT("HKCR"), 
      TEXT("HKCC"), 
      TEXT("HKCU"), 
      TEXT("HKLM") 
   };
   HKEY     hkRoots[] = {
      HKEY_CLASSES_ROOT,
      HKEY_CURRENT_CONFIG,
      HKEY_CURRENT_USER,
      HKEY_LOCAL_MACHINE
   };
   
   *phkRoot = NULL;

   assert(ARRAYSIZE(szRoots) == ARRAYSIZE(hkRoots));

   for (int c=0; c<ARRAYSIZE(szRoots); c++) {
      if (!_tcsnicmp(szPath, szRoots[c], ROOT_KEY_LENGTH)) {
         if (ERROR_SUCCESS != ((lResult = RegConnectRegistry(szMachine, hkRoots[c], phkRoot)))) {
            GET_MESSAGE(lResult, SystemMessage);
            RETURN_ERROR(E_CONNECT_REGISTRY4, SystemMessage, lResult, szMachine, szRoots[c]);
         }

         return S_OK;
      }
   }

   RETURN_ERROR(E_INVALID_ROOT_KEY1, szPath);
}

HRESULT _CreateSubkey(LPCTSTR szMachine, LPCTSTR szPath, HKEY * phkRoot, HKEY * phkSubkey) {
   HKEY     hkRoot;
   HKEY     hkSubkey;
   LONG     lResult;

   *phkRoot = NULL;
   *phkSubkey = NULL;

   if (FAILED(_ConnectToRoot(szMachine, szPath, &hkRoot)))
      return E_CONNECT_REGISTRY4;

   if (ERROR_SUCCESS != ((lResult = RegCreateKey(hkRoot, __GetSubkeyPath(szPath), &hkSubkey)))) {
      RegCloseKey(hkRoot);
      RETURN_ERROR_WITH_MSG(E_CREATE_REG_SUBKEY4, lResult, Message, lResult, szMachine, __GetSubkeyPath(szPath));
   }

   *phkRoot = hkRoot;
   *phkSubkey = hkSubkey;

   return S_OK;
}

HRESULT WriteRegistryString(
   LPCTSTR szQualifiedPath, 
   LPCTSTR abKey,
   HKEY    hkSubkey,
   LPCTSTR szValue) 
{
   LONG  lResult;
   TCHAR SystemMessage[256] = {0};

   lResult = RegSetValueEx(hkSubkey, abKey, 0, REG_SZ, (const BYTE*)szValue, sizeof(TCHAR)*(_tcslen(szValue)+1));

   if (ERROR_SUCCESS != lResult) {
      GET_MESSAGE(lResult, SystemMessage);
      RETURN_ERROR(E_SET_REG_KEYVALUE3, SystemMessage, lResult, szQualifiedPath);
   }

	return S_OK;
}

HRESULT WriteRegistryDWORD(
   LPCTSTR szQualifiedPath, 
   LPCTSTR abKey,
   HKEY    hkSubkey,
   DWORD   dwValue) 
{
   LONG  lResult;
   TCHAR SystemMessage[256] = {0};
   lResult = RegSetValueEx(hkSubkey, abKey, 0, REG_DWORD, (const BYTE*)&dwValue, sizeof(dwValue));

   if (ERROR_SUCCESS != lResult) {
      GET_MESSAGE(lResult, SystemMessage);
      RETURN_ERROR(E_SET_REG_KEYVALUE3, SystemMessage, lResult, szQualifiedPath);
   }

	return S_OK;
}

HRESULT WriteRegistry(LPCTSTR szQualifiedPath, PTOKEN pToken) {
   TCHAR   Machine[MAX_MACHINE_LENGTH] = {0};
	TCHAR   Path[MAX_REGPATH_LENGTH] = {0};
	TCHAR   Key[MAX_KEY_LENGTH] = {0};
   HKEY    hkRoot;
   HKEY    hkSubkey;

   if (FAILED(_ExtractPathComponents(szQualifiedPath, Machine, Path, Key)))
		RETURN_ERROR(E_EXTRACT_PARAMETERS1, szQualifiedPath ? szQualifiedPath : TEXT("(null)"));

   if (FAILED(_CreateSubkey(Machine, Path, &hkRoot, &hkSubkey)))
      RETURN_ERROR(E_CREATE_SUBKEY1, szQualifiedPath);
   
   __try {
      if (pToken->dwType == TOKEN_TYPE_STRING)
         return WriteRegistryString(szQualifiedPath, Key, hkSubkey, pToken->Value.sz);
      else if (pToken->dwType == TOKEN_TYPE_DWORD)
         return WriteRegistryDWORD(szQualifiedPath, Key, hkSubkey, pToken->Value.dw);
      else
         return E_FAIL;
   }
   __finally {
      RegCloseKey(hkSubkey);
      RegCloseKey(hkRoot);
   }
}

HRESULT _DeleteRegistryKey(HKEY hkRoot, LPCTSTR szSubkey, LPCTSTR szKey) {
   HKEY  hkSubkey = NULL;
   LONG  lResult;
   DWORD dwIndex=0;
   TCHAR Subkey[64] = {0};
   HRESULT hr = S_OK;

   lResult = RegOpenKey(hkRoot, szSubkey, &hkSubkey);
   if (ERROR_FILE_NOT_FOUND == lResult)
      return S_OK;
   else if (ERROR_SUCCESS != lResult)
      RETURN_ERROR_WITH_MSG(E_OPEN_REG_SUBKEY3, lResult, Message, lResult, szSubkey);

   if (_tcslen(szKey)) {
      lResult = RegDeleteValue(hkSubkey, szKey);
      
      RegCloseKey(hkSubkey);

      if (ERROR_FILE_NOT_FOUND == lResult)
         return S_OK;
      else if (ERROR_SUCCESS == lResult)
         return S_OK;
      else
         RETURN_ERROR_WITH_MSG(E_DELETE_REG_VALUE4, lResult, Message, lResult, szSubkey, szKey);
   }
   else {
      while (ERROR_NO_MORE_ITEMS != (lResult = RegEnumKey(hkSubkey, dwIndex, Subkey, ARRAYSIZE(Subkey)))) {
         if (ERROR_KEY_DELETED == lResult)
            break;

         if (ERROR_SUCCESS != lResult) {
            RegCloseKey(hkSubkey);
            RETURN_ERROR_WITH_MSG(E_ENUM_REG_SUBKEY3, lResult, Message, lResult, szSubkey, dwIndex);
         }

         if (FAILED(hr = _DeleteRegistryKey(hkSubkey, Subkey, szKey)))
            break;

         dwIndex++;
      }
   }

   if (hkSubkey) RegCloseKey(hkSubkey);
   lResult = RegDeleteKey(hkRoot, szSubkey);
   if (ERROR_FILE_NOT_FOUND == lResult)
      return S_OK;
   else if (ERROR_SUCCESS != lResult)
      RETURN_ERROR_WITH_MSG(E_DELETE_REG_SUBKEY3, lResult, Message, lResult, szSubkey);

   return hr;
}

HRESULT _OpenSubkey(LPCTSTR szPath, HKEY hkRoot, HKEY* phkSubkey) {
   LONG     lResult;

   if (ERROR_SUCCESS != ((lResult = RegOpenKey(hkRoot, szPath, phkSubkey))))
      RETURN_ERROR_WITH_MSG(E_OPEN_REG_SUBKEY3, lResult, Message, lResult, szPath);

   return S_OK;
}

HRESULT DeleteRegistry(LPCTSTR szQualifiedPath) {
   TCHAR   Machine[MAX_MACHINE_LENGTH] = {0};
	TCHAR   Path[MAX_REGPATH_LENGTH] = {0};
	TCHAR   Key[MAX_KEY_LENGTH] = {0};
   HKEY    hkRoot;
   HRESULT hr;

   if (FAILED(_ExtractPathComponents(szQualifiedPath, Machine, Path, Key)))
		RETURN_ERROR(E_EXTRACT_PARAMETERS1, szQualifiedPath ? szQualifiedPath : TEXT("(null)"));

   if (FAILED(hr = _ConnectToRoot(Machine, Path, &hkRoot)))
      return hr;
   
   hr = _DeleteRegistryKey(hkRoot, __GetSubkeyPath(Path), Key);
   RegCloseKey(hkRoot);

   if (FAILED(hr))
      return hr;

   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\xreg\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xreg_none_12.4.56.0_none_b4e6d40f192c9216
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xreg_no-public-key_12.4.56.0_x-ww_f29c95f2
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xreg
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xreg_no-public-key_12.4.56.0_x-ww_f29c95f2
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xreg_no-public-key_12.4.56.0_x-ww_f29c95f2.manifest
XP_MANIFEST_PATH=manifests\x86_xreg_no-public-key_12.4.56.0_x-ww_f29c95f2.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xreg_no-public-key_12.4.56.0_x-ww_f29c95f2.cat
XP_CATALOG_PATH=manifests\x86_xreg_no-public-key_12.4.56.0_x-ww_f29c95f2.cat
XP_PAYLOAD_PATH=x86_xreg_no-public-key_12.4.56.0_x-ww_f29c95f2
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xreg,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\xreg\xreg.h ===
#ifndef __XONLINE_REG_H__
#define __XONLINE_REG_H__

#define MAX_MACHINE_LENGTH    64
#define MAX_REGPATH_LENGTH    256
#define MAX_KEY_LENGTH        32

#define MAX_QUALIFIED_PATH    (MAX_MACHINE_LENGTH + MAX_REGPATH_LENGTH + MAX_KEY_LENGTH + 3)

#define SC_TOKEN              TEXT('%')
#define SC_TOKEN_STR          TEXT("%")
#define SC_KEY_PREFIX         TEXT('@')
#define SC_PATH_SEP           TEXT('\\')
#define SC_PATH_SEP_STR       TEXT("\\")
#define SC_MACHINE_PREFIX     TEXT("\\\\")
#define SC_ALLOWED_ROOT_KEYS  TEXT("HKCR\0HKCC\0HKCU\0HKLM\0")

#define MAX_PARAMETERS        4
#define MAX_TOKENS            16

//xreg /c [command] & [command] & [command]
#define INPUT_PUSH_RREG       TEXT("push")
#define INPUT_POP_RREG        TEXT("pop")
#define INPUT_CLEAR_REPLACE   TEXT("clear")
#define INPUT_ADD_TOKEN       TEXT("atok")
#define INPUT_DEL_TOKEN       TEXT("dtok")

#define COMMAND_WRITE_STRING  TEXT("write-sz")
#define COMMAND_WRITE_DWORD   TEXT("write-dw")
#define COMMAND_DELETE        TEXT("del")

#define MACHINE_PREFIX_LEN    2
#define ROOT_KEY_LENGTH       4

#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <winsock2.h>
#include <assert.h>
#include <stdio.h>
#include <tchar.h>
#include <wchar.h>
#include <map>
#include <functional>
#include <vector>
#include <list>

#include "xerr.h"
#include "xipe.h"

inline LPCTSTR __nextParameter(LPCTSTR szParameter) {
   return szParameter + _tcslen(szParameter) + 1;
}

VOID CleanupEnvironment(PIPEnvironment pEnvironment);

HRESULT WriteRegistry(LPCTSTR szQualifiedPath, PTOKEN pToken);
HRESULT DeleteRegistry(LPCTSTR szQualifiedPath);

HRESULT GetMultistringParameters(LPCTSTR szCommand, LPCTSTR* pszParameters, DWORD dwCount);
HRESULT GetMultistringParameters(LPCTSTR szCommand, LPCTSTR* pszParameters, DWORD dwMin, DWORD dwMax, DWORD * pdwCount);

HRESULT __ReadCommand(HANDLE hCommandSource, LPTSTR abBuffer, DWORD cchBuffer);
HRESULT ForwardCommand(LPCTSTR szCommand, HANDLE hCommandOutput);

HRESULT InputCommand(PIPEnvironment pEnvironment, LPCTSTR szCommand, HANDLE hCommandOutput);
HRESULT InputCommandPipe(PIPEnvironment pEnvironment, HANDLE hCommandSource, HANDLE hCommandOutput);

HRESULT ProcessCommand(LPCTSTR szCommand);
HRESULT ProcessCommandPipe(HANDLE hCommandSource);

HRESULT TokenExpandCommand(PIPEnvironment pEnvironment, LPCTSTR szCommand, HANDLE hCommandOutput);
HRESULT TokenExpandCommandPipe(PIPEnvironment pEnvironment, HANDLE hCommandSource, HANDLE hCommandOutput);

HRESULT ReplaceCommand(PIPEnvironment pEnvironment, LPCTSTR szCommand, HANDLE hCommandOutput);
HRESULT ReplaceCommandPipe(PIPEnvironment pEnvironment, HANDLE hCommandSource, HANDLE hCommandOutput);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\xreg\xreg-tps.cpp ===
/* XREG - Command Processing Stage */
/* Rushed: needs refactoring and better error reporting */

#include "xreg.h"

HRESULT TokenExpandCommand(PIPEnvironment pEnvironment, LPCTSTR szCommand, HANDLE hCommandOutput) {
   LPCTSTR                 Parameters[MAX_PARAMETERS];
   TCHAR                   SourceBuffers[MAX_PARAMETERS][MAX_PATH];
   std::vector<LPTSTR>     Markers;
   std::map<LPCTSTR, int, less_str>  TokensPresent;
   std::vector<LPCTSTR>    TokenValues;
   std::vector<LPCTSTR>    TokenExpandedValues;
   
   DWORD                   dwCount;
   BOOL                    fToken, fDone;
   HRESULT                 hr;

   if (FAILED(hr = GetMultistringParameters(szCommand, Parameters, 0, ARRAYSIZE(Parameters), &dwCount)))
      return hr;

   /// Marking up the command parameters
   for (int c=0; c<(int)dwCount; c++) {
      LPTSTR Marker;
      LPTSTR Context;

      _tcscpy_s(SourceBuffers[c], ARRAYSIZE(SourceBuffers[c]), Parameters[c]);

      if (SourceBuffers[c] != (Marker = _tcstok_s(SourceBuffers[c], SC_TOKEN_STR, &Context))) {
         //First must be non-token (even if empty)
         SourceBuffers[c][0] = TEXT('\0');
         Markers.push_back(SourceBuffers[c]);
      }

      while (Marker) {
         Markers.push_back(Marker);
         Marker = _tcstok_s(NULL, SC_TOKEN_STR, &Context);
      }

      Markers.push_back(NULL);
   }

   /// Collecting the tokens
   fToken = FALSE;
   for (int c=0; c<(int)Markers.size(); c++) {
      if (Markers[c]) {
         if (fToken) {
            _tcslwr_s(Markers[c], _tcslen(Markers[c]) + 1); //tokens must be in lower case
            if (TokensPresent.find(Markers[c]) == TokensPresent.end()) {
               if (pEnvironment->Tokens.find(Markers[c]) == pEnvironment->Tokens.end())
                  TokenValues.push_back(NULL);
               else
                  TokenValues.push_back(pEnvironment->Tokens[Markers[c]]);

               TokenExpandedValues.push_back(TokenValues.back());
               TokensPresent[Markers[c]] = TokenValues.size() - 1;
            }
         }
         fToken = !fToken;
      }
      else
         fToken = FALSE;
   }

   fDone = FALSE;
   /// Expand Command with cross product of the value set of unique tokens
   while (!fDone) {
      TCHAR EmptyCharacter = TEXT('\0');
      DWORD dwWritten;
      
      if (!WriteFile(hCommandOutput, szCommand, (_tcslen(szCommand)+1)*sizeof(TCHAR), &dwWritten, NULL))
         return E_FAIL;

      fToken = FALSE;
      for (int c=0; c<(int)Markers.size(); c++) {
         if (Markers[c]) {
            if (fToken) {
               LPCTSTR TokenValue = TokenExpandedValues[TokensPresent[Markers[c]]];

               if (TokenValue) {
                  if (!WriteFile(hCommandOutput, TokenValue, _tcslen(TokenValue)*sizeof(TCHAR), &dwWritten, NULL))
                     return E_FAIL;
               }
            }
            else {
               if (!WriteFile(hCommandOutput, Markers[c], _tcslen(Markers[c])*sizeof(TCHAR), &dwWritten, NULL))
                  return E_FAIL;
            }

            fToken = !fToken;
         }
         else {
            /// End of Parameter
            if (!WriteFile(hCommandOutput, &EmptyCharacter, sizeof(EmptyCharacter), &dwWritten, NULL))
               return E_FAIL;

            fToken = FALSE;
         }
      }

      /// End of Command
      if (!WriteFile(hCommandOutput, &EmptyCharacter, sizeof(EmptyCharacter), &dwWritten, NULL))
         return E_FAIL;

      /// Pivot Expanded Token Values
      for (int c=0; c<=(int)TokenExpandedValues.size(); c++) {
         if (TokenExpandedValues.size() == c) {
            fDone = TRUE;
            break;
         }

         if (TokenExpandedValues[c]) {
            TokenExpandedValues[c] = __nextParameter(TokenExpandedValues[c]);
            if (TokenExpandedValues[c][0])
               break;
            else
               TokenExpandedValues[c] = TokenValues[c];
         }
      }
   }

   return S_OK;
}

HRESULT TokenExpandCommandPipe(PIPEnvironment pEnvironment, HANDLE hCommandSource, HANDLE hCommandOutput) {
   TCHAR CommandBuffer[1024];
   HRESULT hr;
   
   while (SUCCEEDED(hr = __ReadCommand(hCommandSource, CommandBuffer, ARRAYSIZE(CommandBuffer)))) {
      if (0 == _tcslen(CommandBuffer))
         break; //Done

      if (FAILED(hr = TokenExpandCommand(pEnvironment, CommandBuffer, hCommandOutput)))
         break;
   }

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\diag\putltc\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\diag\putltc\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\deployment\xreg\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xreg_none_12.4.56.0_none_b4e6d40f192c9216
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xreg_no-public-key_12.4.56.0_x-ww_f29c95f2
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xreg
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xreg_no-public-key_12.4.56.0_x-ww_f29c95f2
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xreg_no-public-key_12.4.56.0_x-ww_f29c95f2.manifest
XP_MANIFEST_PATH=manifests\x86_xreg_no-public-key_12.4.56.0_x-ww_f29c95f2.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xreg_no-public-key_12.4.56.0_x-ww_f29c95f2.cat
XP_CATALOG_PATH=manifests\x86_xreg_no-public-key_12.4.56.0_x-ww_f29c95f2.cat
XP_PAYLOAD_PATH=x86_xreg_no-public-key_12.4.56.0_x-ww_f29c95f2
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xreg,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\diag\putxlast\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\diag\putxlast\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\diag\putltc\putltcUsage.cs ===
namespace xonline.tools.diag
{

// The C# parser in Source Insight (my editor) doesn't understand multi-line
// string, which messes up the syntax highlighting and code nagivation
// features of the editor for files with multi-line strings. So I've put
// this string into its own file to keep it from messing up LiveMatch.cs
class PutLtcUsage
{
/*
0.........1.........2.........3.........4.........5.........6.........7.........8
*/
    public const string Usage = @"
Unconditionally puts the contents of a file into t_live_title_config in npdb.

Usage:
    PutLtc /titleid:<titleid> /xlast:<filename>

No checks are performed on the file. It can be completely invalid and will still
be put into t_live_title_config. Use with caution.
";

}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\diag\putltc\putltc.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Globalization;
using System.IO;
using System.Reflection;
using System.Security.Principal;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.tools.console;
using xonline.common.utilities2;

[assembly: XomAreaDefinition(XomAreaName.log)]

namespace xonline.tools.diag
{

class PutLtc
{
    public static int Main(string[] args)
    {
        XomLoggingControl.Init();
        try
        {
            string version = Assembly.GetExecutingAssembly().GetName().Version.ToString();
            string user = WindowsIdentity.GetCurrent().Name;
            string msg = "PutLtc build(" + version + "), user(" + user + ")";
            Console.WriteLine(msg);
            Xom.Log(XomAreaName.log, msg);
            Xom.Log(XomAreaName.log, "parameters: " + CollectionUtil.ToString(args));

            string[] _cmdLineTags =
            {
                "?",
                "help",
                "titleid",
                "ltc"
            };

            NamedArgParser argParser = new NamedArgParser(_cmdLineTags);
            if(!argParser.Parse(args))
            {
                Console.WriteLine(PutLtcUsage.Usage);
                throw new ExceptionWithEventId(XEvent.Id.TOOLS_INFO_0,
                    "Invalid command line parameter found");
            }

            if(argParser.Count == 0 ||
                argParser["?"] != null || argParser["help"] != null)
            {
                Console.WriteLine(PutLtcUsage.Usage);
                Xom.Log(XomAreaName.log, "command line help shown");
                return 0;
            }

            string title = argParser["titleid"];
            if (title == null || title == "")
            {
                throw new ExceptionWithEventId(XEvent.Id.TOOLS_INFO_1,
                    "titleid must be provided using /titleid");
            }

            string ltc = argParser["ltc"];
            if (ltc == null || ltc == "")
            {
                throw new ExceptionWithEventId(XEvent.Id.TOOLS_INFO_2,
                    "ltc filename must be provided using /ltc");
            }

            if (title.Length < 2 || !title.StartsWith("0x"))
            {
                title = "0x" + title;
            }

            // parse the titleid
            uint titleId = UInt32.Parse(title.Substring(2), NumberStyles.HexNumber);
            Xom.Log(XomAreaName.log, "title id on command line: " + titleId.ToString("X8"));

            if (!File.Exists(ltc))
            {
                throw new ExceptionWithEventId(XEvent.Id.TOOLS_INFO_3,
                    ltc + " does not exist");
            }

            IInterfaceInfo iinfo = Config.GetSingleInterface(Interface.npdb);
            using (SqlConnection cxn = new SqlConnection(iinfo.SqlConnectionString))
            {
                cxn.Open();

                SqlCommand cmd = cxn.CreateCommand();
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.CommandText = "p_live_title_config_set";
                cmd.Parameters.Add(new SqlParameter("@i_title_id", unchecked((int)titleId)));
                cmd.Parameters.Add(new SqlParameter("@xml_title_config", ReadLiveTitleConfigFile(ltc)));

                msg = "Calling p_live_title_config_set to save " + ltc + " to npdb";
                Console.WriteLine(msg);
                Xom.Log(XomAreaName.log, msg);

                cmd.ExecuteNonQuery();
                msg = ltc + " saved to npdb.t_live_title_config";
                Console.WriteLine(msg);
                Xom.Log(XomAreaName.log, msg);
            }
        }
        catch (ExceptionWithEventId e)
        {
            Console.WriteLine("\nError: " + e.Message);
            Xom.Log(XomAreaName.log, "Error: " + e.Message);
            EventBuilder.LogEvent(e.EventId, e.Message, e);
            return -1;
        }
        catch (Exception e)
        {
            Console.WriteLine("\nError: " + e.Message);
            Xom.Log(XomAreaName.log, "Error: " + e.Message);
            EventBuilder.LogEvent(XEvent.Id.TOOLS_CODE_2, e.Message, e);
            return -1;
        }
        finally
        {
            Xom.Log(XomAreaName.log, "PutLtc exiting.");
            XomLoggingControl.Close();
        }

        return 0;
    }

    private static string ReadLiveTitleConfigFile(string filename)
    {
        FileStream liveTitleConfig = new FileStream(filename, FileMode.Open);
        StreamReader reader = new StreamReader(liveTitleConfig);
        return reader.ReadToEnd();
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\diag\putxlast\putxlastUsage.cs ===
namespace xonline.tools.diag
{

// The C# parser in Source Insight (my editor) doesn't understand multi-line
// string, which messes up the syntax highlighting and code nagivation
// features of the editor for files with multi-line strings. So I've put
// this string into its own file to keep it from messing up LiveMatch.cs
class PutXlastUsage
{
/*
0.........1.........2.........3.........4.........5.........6.........7.........8
*/
    public const string Usage = @"
Unconditionally puts the contents of a file into t_game_config in npdb.

Usage:
    PutXlast /titleid:<titleid> /xlast:<filename>

No checks are performed on the file. It can be completely invalid and will still
be put into t_game_config. Use with caution.
";

}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\diag\putxlast\putxlast.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Globalization;
using System.IO;
using System.Reflection;
using System.Security.Principal;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.tools.console;
using xonline.common.utilities2;

[assembly: XomAreaDefinition(XomAreaName.log)]

namespace xonline.tools.diag
{

class PutXlast
{
    public static int Main(string[] args)
    {
        XomLoggingControl.Init();
        try
        {
            string version = Assembly.GetExecutingAssembly().GetName().Version.ToString();
            string user = WindowsIdentity.GetCurrent().Name;
            string msg = "PutXlast build(" + version + "), user(" + user + ")";
            Console.WriteLine(msg);
            Xom.Log(XomAreaName.log, msg);
            Xom.Log(XomAreaName.log, "parameters: " + CollectionUtil.ToString(args));

            string[] _cmdLineTags =
            {
                "?",
                "help",
                "titleid",
                "xlast"
            };

            NamedArgParser argParser = new NamedArgParser(_cmdLineTags);
            if(!argParser.Parse(args))
            {
                Console.WriteLine(PutXlastUsage.Usage);
                throw new ExceptionWithEventId(XEvent.Id.TOOLS_INFO_4,
                    "Invalid command line parameter found");
            }

            if(argParser.Count == 0 ||
                argParser["?"] != null || argParser["help"] != null)
            {
                Console.WriteLine(PutXlastUsage.Usage);
                Xom.Log(XomAreaName.log, "command line help shown");
                return 0;
            }

            string titleid = argParser["titleid"];
            if (titleid == null || titleid == "")
            {
                throw new ExceptionWithEventId(XEvent.Id.TOOLS_INFO_5,
                    "titleid must be provided using /titleid");
            }

            string xlast = argParser["xlast"];
            if (xlast == null || xlast == "")
            {
                throw new ExceptionWithEventId(XEvent.Id.TOOLS_INFO_6,
                    "xlast filename must be provided using /xlast");
            }

            if (titleid.Length < 2 || !titleid.StartsWith("0x"))
            {
                titleid = "0x" + titleid;
            }

            // parse the titleid
            uint titleId = UInt32.Parse(titleid.Substring(2), NumberStyles.HexNumber);
            Xom.Log(XomAreaName.log, "title id on command line: " + titleId.ToString("X8"));

            if (!File.Exists(xlast))
            {
                throw new ExceptionWithEventId(XEvent.Id.TOOLS_INFO_7,
                    xlast + " does not exist");
            }

            IInterfaceInfo iinfo = Config.GetSingleInterface(Interface.npdb);
            using (SqlConnection cxn = new SqlConnection(iinfo.SqlConnectionString))
            {
                cxn.Open();

                SqlCommand cmd = cxn.CreateCommand();
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.CommandText = "p_game_save_config";
                cmd.Parameters.Add(new SqlParameter("@i_title_id", unchecked((int)titleId)));
                cmd.Parameters.Add(new SqlParameter("@xml_config", ReadGameConfigFile(xlast)));
                cmd.Parameters.Add(new SqlParameter("@vc_xdk_version", "DEFAULT"));

                msg = "Calling p_game_save_config to save " + xlast + " to npdb";
                Console.WriteLine(msg);
                Xom.Log(XomAreaName.log, msg);

                cmd.ExecuteNonQuery();
                msg = xlast + " saved to npdb.t_game_config";
                Console.WriteLine(msg);
                Xom.Log(XomAreaName.log, msg);
            }
        }
        catch (ExceptionWithEventId e)
        {
            Console.WriteLine("\nError: " + e.Message);
            Xom.Log(XomAreaName.log, "Error: " + e.Message);
            EventBuilder.LogEvent(e.EventId, e.Message, e);
            return -1;
        }
        catch (Exception e)
        {
            Console.WriteLine("\nError: " + e.Message);
            Xom.Log(XomAreaName.log, "Error: " + e.Message);
            EventBuilder.LogEvent(XEvent.Id.TOOLS_CODE_3, e.Message, e);
            return -1;
        }
        finally
        {
            Xom.Log(XomAreaName.log, "PutXlast exiting.");
            XomLoggingControl.Close();
        }

        return 0;
    }

    private static string ReadGameConfigFile(string filename)
    {
        FileStream gameConfig = new FileStream(filename, FileMode.Open);
        StreamReader reader = new StreamReader(gameConfig);
        return reader.ReadToEnd();
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\DMLScriptGen\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\DMLScriptGen\DMLFileWriter.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Collections;
using System.IO;
using System.ComponentModel;

namespace xonline.tools.DMLScriptGenerator
{
    class DMLFileWriter:IReadGeneratedScript, IDisposable
    {
        StreamWriter m_objStreamWriterInserts  = null;
        StreamWriter m_objStreamWriterDeletes  = null;
        StreamWriter m_objStreamWriterWarnings = null;

        Component component = new Component();
        bool m_bdisposed = false;

        
        public DMLFileWriter(string szFullPathInserts, string szFullPathDeletes, string szFullPathWarnings)
        {
            m_objStreamWriterInserts  = CreateStreamWriter(szFullPathInserts);
            m_objStreamWriterDeletes  = CreateStreamWriter(szFullPathDeletes);
            m_objStreamWriterWarnings = CreateStreamWriter(szFullPathWarnings);
        }

        StreamWriter CreateStreamWriter(string szFullPathFile)
        {
            FileInfo objFileInfo = new FileInfo(szFullPathFile);

            objFileInfo.Delete();

            return objFileInfo.CreateText();
        }
        
        public void OnInsertScript(string szTable, string szLine)
        {
            SafeStreamWriterWrites(m_objStreamWriterInserts, string.Format("\r\n{0}\r\n", szLine));
        }
        
        public void OnDeleteScript(string szTable, string szLine)
        {
            SafeStreamWriterWrites(m_objStreamWriterDeletes, string.Format("\r\n{0}\r\n", szLine));
        }
        
        public void OnTableSchemaChanged(string szTable)
        {
            SafeStreamWriterWrites(m_objStreamWriterWarnings, string.Format("Schema-Changed [Columns Added/Deleted] {0}", szTable));
        }
        
        public void OnTableToAdd(string szTable)
        {
            SafeStreamWriterWrites(m_objStreamWriterWarnings, string.Format("New-Table {0}", szTable));
        }

        public void OnTableTooComplex(string szTable)
        {
            SafeStreamWriterWrites(m_objStreamWriterWarnings, string.Format("Too-Complex-Table [UnSupported Column Type]{0}", szTable));
        }

        public void OnTableCantProcess(string szTable)
        {
            SafeStreamWriterWrites(m_objStreamWriterWarnings, string.Format("Cant-Process-Table [Foreign Dependency Not Satisfied] {0}", szTable));
        }

        public void OnTableToDrop(string szTable)
        {
            SafeStreamWriterWrites(m_objStreamWriterWarnings, string.Format("Deprecated-Table {0}", szTable));
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        private void Dispose(bool bDisposing)
        {
            // Check to see if Dispose has already been called.
            if(!m_bdisposed)
            {
                // If disposing equals true, dispose all managed 
                // and unmanaged resources.
                if(bDisposing)
                {   
                    // Dispose managed resources.
                    component.Dispose();
                }

                SafeCloseStreamWriter(m_objStreamWriterInserts);
                SafeCloseStreamWriter(m_objStreamWriterDeletes);
                SafeCloseStreamWriter(m_objStreamWriterWarnings);

                m_objStreamWriterInserts  = null;
                m_objStreamWriterDeletes  = null;
                m_objStreamWriterWarnings = null;
            }
            
            m_bdisposed = true;         
        }

        void SafeCloseStreamWriter(StreamWriter objStreamWriter)
        {
            if (null != objStreamWriter)
            {
                objStreamWriter.Close();
            }
        }

        void SafeStreamWriterWrites(StreamWriter objStreamWriter, string szFormattedLine)
        {
            lock (this)
            {
                if (null != objStreamWriter)
                {
                    objStreamWriter.WriteLine(szFormattedLine);
                }
            }
        }
        
        ~DMLFileWriter()      
        {
            Dispose(false);
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\DMLScriptGen\DMLExclude.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Collections;
using System.IO;


namespace xonline.tools.DMLScriptGenerator
{
    class DMLExclude:IExcludedFiles
    {
        Hashtable m_htExcludedFile = new Hashtable();
        
        public DMLExclude(string szFullPathFile)
        {
            if (null != szFullPathFile)
            {
                ReadExcludedFile(szFullPathFile);
            }
        }

        public void ReadExcludedFile(string szFullPathFile)
        {
            using (StreamReader objReader = new StreamReader(szFullPathFile)) 
            {
                string szLine = null;
                // Read and display lines from the file until the end of 
                // the file is reached.
                while ((szLine = objReader.ReadLine()) != null) 
                {
                    string [] arrExcludedFile = szLine.Split(new Char [] {' ', ',', ';'});
                    foreach (string szFile in arrExcludedFile)
                    {
                        if (m_htExcludedFile[szFile] == null)
                        {
                            m_htExcludedFile.Add(szFile.Trim().ToLower(), 1);
                        }
                    }
                }
            }
        }

        public bool IsExcluded(string szTable)
        {
            return (m_htExcludedFile[szTable.Trim().ToLower()] != null);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\DMLScriptGen\DMLDBHelper.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Data.Sql;
using System.Data.SqlClient;
using System.Collections;

namespace xonline.tools.DMLScriptGenerator
{    
    //all data Reader Style execution will inherit from this class
    public abstract class DataReaderBase:IDataRead
    {
        string m_szConnectionString = null;
        string m_szQueryString      = null;
        string m_szServer           = null;

        public string GetConnectionString()
        {
            return m_szConnectionString;
        }

        public string DataReaderQuery
        {
            get
            {
                return m_szQueryString;
            }

            set
            {
                m_szQueryString = value;
            }
        }
        
        public DataReaderBase(string szServer)
        {
            m_szServer   = szServer;

            m_szConnectionString = string.Format("Data Source={0};Integrated Security=SSPI", m_szServer);
        }

        public abstract void OnStart();
        public abstract void OnEnd();
        public abstract void OnNewRow(SqlDataReader objReader);

        public void ExecuteDataReader()
        {
            SqlConnection objCon    = null;
            SqlCommand objCommand   = null;
            SqlDataReader objReader = null;

            try 
            {
                objCon = new SqlConnection(m_szConnectionString); 
                objCon.Open();

                objCommand                = objCon.CreateCommand();
                objCommand.CommandText    = DataReaderQuery;

                objReader                 = objCommand.ExecuteReader(); 

                OnStart();
                while(objReader.Read()) 
                {
                    OnNewRow(objReader);
                } 
                OnEnd();
            }
            catch
            {
                throw;
            }
            finally
            {
                if (null != objReader)
                {
                    objReader.Close();    
                }
                
                if (null != objCon)
                {
                    objCon.Close();
                    objCon = null;
                }
            }
                      
        } 
    }


    //retrieve all tables a table has foreign key dependency on
    public class ForeignTableDependency:DataReaderBase
    {
        List<string> listTables = new List<string>();
        string m_szServer = null;
        string m_szDatabase = null;
        
        public ForeignTableDependency(string szServer, string szDatabase, string szServerRunOn):base(szServerRunOn)
        {
            m_szServer   = szServer;
            m_szDatabase = szDatabase;
        }
        
        public override void OnStart()
        {
            listTables.Clear();
        }
        
        public override void OnEnd()
        {
            
        }
        
        public override void OnNewRow(SqlDataReader objReader)
        {
            listTables.Add((string)objReader["table_name"]);
        }        

        public string [] GetForeignTableDependency(string szTable)
        {
            DataReaderQuery = string.Format(" SELECT table_name  = pk.table_name " +                        
                                            " FROM {0}.{1}.information_schema.referential_constraints c " +  
                                            " INNER JOIN {0}.{1}.information_schema.table_constraints fk " + 
                                            " ON c.constraint_name = fk.constraint_name " + 
                                            " INNER JOIN {0}.{1}.information_schema.table_constraints pk " +  
                                            " ON c.unique_constraint_name = pk.constraint_name " + 
                                            " WHERE FK.TABLE_NAME = '{2}'",
                                            m_szServer, m_szDatabase, szTable);


            
            ExecuteDataReader();

            return listTables.ToArray();   
        }
        
    }


    //a class to read the actual data rows from which scripts will be generated
    public class DataRowScripts:DataReaderBase
    {
        public const string SOURCE = "source";
        public const string TARGET = "target";

        public const int    INSERT = 1;
        public const int    DELETE = 0;

        public const string SQLCOMMENT = "--";

        string m_szServerSource;
        string m_szServerTarget;
        string m_szDatabaseSource;
        string m_szDatabaseTarget;
        string m_szTable;

        IReadGeneratedScript m_iOutputCallBack;
        string [] m_arrPrimaryKeys;
        string [] m_arrAllColumns;

        bool      m_bDeleteOperation;
        bool      m_bTableContainsIdentity;

        public DataRowScripts(string szServerSource, string szServerTarget, string szDatabaseSource, string szDatabaseTarget, string szServerToRunOn, bool bDelete):base(szServerToRunOn)
        {
            m_szServerSource   = szServerSource;
            m_szServerTarget   = szServerTarget;
            m_szDatabaseSource = szDatabaseSource;
            m_szDatabaseTarget = szDatabaseTarget;
            m_bDeleteOperation = bDelete;
        }
        
        public override void OnStart()
        {
        }
        
        public override void OnEnd()
        {
            
        }
        
        public override void OnNewRow(SqlDataReader objReader)
        {
            if (null != m_iOutputCallBack)
            {
                int nTableName = (int)objReader["TableName"];
                if (INSERT == nTableName && false == m_bDeleteOperation)
                {
                    m_iOutputCallBack.OnInsertScript(m_szTable, GenerateInsertScript(objReader));
                }
                else if (DELETE == nTableName && true == m_bDeleteOperation)
                {
                    m_iOutputCallBack.OnDeleteScript(m_szTable, GenerateDeleteScript(objReader));
                }
                //else do nothing
            }
        }

        public void GetAllScriptsForNewTable(string [] arrPrimaryKeys, string [] arrAllColumns , string [] arrTypes, string szTable, IReadGeneratedScript iOutputCallBack, bool bTableContainsIdentity)
        {
            m_iOutputCallBack   = iOutputCallBack;
            m_szTable           = szTable;
            m_arrPrimaryKeys    = arrPrimaryKeys;
            m_arrAllColumns     = arrAllColumns;
            m_bTableContainsIdentity   = bTableContainsIdentity;
            
 
            DataReaderQuery  =  string.Format(" SELECT 1 as TableName, {3}" +
                                              " FROM {0}.{1}.dbo.{2}", 
                                              m_szServerTarget, m_szDatabaseTarget, szTable,
                                              GetColumnsToRetrieveClause(arrAllColumns, arrTypes)
                                              );
           
            
            ExecuteDataReader();
        }

        public void GetAllScriptsForTable(string [] arrPrimaryKeys, string [] arrAllColumns , string [] arrTypes, string szTable, IReadGeneratedScript iOutputCallBack, bool bTableContainsIdentity)
        {
            m_iOutputCallBack   = iOutputCallBack;
            m_szTable           = szTable;
            m_arrPrimaryKeys    = arrPrimaryKeys;
            m_arrAllColumns     = arrAllColumns;
            m_bTableContainsIdentity   = bTableContainsIdentity;
            
 
            DataReaderQuery  =  string.Format(" SELECT MIN(TableName) as TableName, {5}" +
                                              " FROM ( " +
                                              "     SELECT 0 as TableName, {6} FROM {0}.{2}.dbo.{4}" + 
                                              "     UNION ALL " + 
                                              "     SELECT 1 as TableName, {6} FROM {1}.{3}.dbo.{4}" +
                                              " ) as TMPUNION" + 
                                              " GROUP BY {7} " +
                                              " HAVING COUNT(*) = 1", 
                                              m_szServerSource, m_szServerTarget, m_szDatabaseSource, m_szDatabaseTarget, szTable,
                                              GetAggregatedColumnsToRetrieveClause(arrAllColumns), 
                                              GetColumnsToRetrieveClause(arrAllColumns, arrTypes),
                                              GetGroupByClause(arrPrimaryKeys)
                                              );
           
            
            ExecuteDataReader();
        }

        string [] GetNotPrimaryKeys(string [] arrAllColumns, string [] arrPrimaryKeys)
        {
            List<string> listTables = new List<string>();
            bool bIsPrimary = false;
            foreach (string szColumn in arrAllColumns)
            {

                bIsPrimary = false;
                foreach (string szPrimaryCol in arrPrimaryKeys)
                {
                    if (szColumn == szPrimaryCol)
                    {
                        bIsPrimary = true;
                    }
                }

                if (false == bIsPrimary)
                {
                    listTables.Add(szColumn);
                }
            }

            return listTables.ToArray();
        }


        string GenerateInsertScript(SqlDataReader objReader)
        {   
            string szExistCheck = string.Format("IF NOT EXISTS " + 
                                                "(SELECT null from {0}" +
                                                " WHERE {1})" +
                                                "\r\n{2}BEGIN",
                                                m_szTable, 
                                                GetExistClause(m_arrPrimaryKeys, objReader), GetCommented());
            
            string szInsert  = string.Format("\tINSERT INTO {0}({1})" +
                                             "\r\n{3}\tVALUES ({2})", 
                                             m_szTable, GetColumns(m_arrAllColumns), 
                                             GetValueClause(m_arrAllColumns, objReader), GetCommented());

            string szEnd = "END";

            return string.Format("{3}{0}\r\n{3}{1}\r\n{3}{2}", szExistCheck, szInsert, szEnd, GetCommented());
        }

        string GenerateDeleteScript(SqlDataReader objReader)
        {
            string szExistCheck = string.Format("IF EXISTS " + 
                                                "(SELECT null from {0}" +
                                                " WHERE {1})" +
                                                "\r\n{2}BEGIN",
                                                m_szTable, 
                                                GetExistClause(m_arrPrimaryKeys, objReader), GetCommented());
            
            string szDelete  = string.Format("\tDELETE {0}" +
                                             "\r\n{2}\tWHERE {1}", 
                                             m_szTable, GetExistClause(m_arrPrimaryKeys, objReader), GetCommented());

            string szEnd = "END";

            return string.Format("{3}{0}\r\n{3}{1}\r\n{3}{2}", szExistCheck, szDelete, szEnd, GetCommented());
        }

        //rules to comment the code
        string GetCommented()
        {
            if (m_bTableContainsIdentity)
            {
                return SQLCOMMENT;
            }
            else
            {
                return "";
            }
        }
        
        string GetExistClause(string [] arrColumns, SqlDataReader objReader)
        {
            System.Text.StringBuilder sb = new StringBuilder();
            int i = 0;
            
            for (i = 0; i < arrColumns.Length - 1; i++)
            {
                sb.Append(string.Format("{0}{1}{2} AND ", arrColumns[i], GetComparator(objReader[arrColumns[i]]), FormatSqlValue(objReader[arrColumns[i]])));
            }

            sb.Append(string.Format("{0}{1}{2} ", arrColumns[i], GetComparator(objReader[arrColumns[i]]), FormatSqlValue(objReader[arrColumns[i]])));

            return sb.ToString();
        }

        string GetValueClause(string [] arrColumns, SqlDataReader objReader)
        {
            System.Text.StringBuilder sb = new StringBuilder();
            int i = 0;
            
            for (i = 0; i < arrColumns.Length - 1; i++)
            {
                sb.Append(string.Format("{0},", FormatSqlValue(objReader[arrColumns[i]])));
            }

            sb.Append(string.Format("{0}", FormatSqlValue(objReader[arrColumns[i]])));

            return sb.ToString();
        }

        string GetComparator(object o)
        {
            string szReturn = "=";
            if (null != o)
            {
                if (o is DBNull)
                {
                    szReturn = " IS ";
                }
            }

            return szReturn;
        }
        
        string FormatSqlValue(object o)
        {
            string szReturn = "NULL";
            if (null != o)
            {
                if (o is string )
                {
                    szReturn = string.Format("N'{0}'", EscapeString(o.ToString()));
                }
                else if (o is DateTime)
                {
                    szReturn = string.Format("'{0}'", o.ToString());
                }
                else if (o is DBNull)
                {
                    szReturn = "NULL";
                }
                else
                {
                    szReturn = o.ToString();
                }
            }

            return szReturn;
        }

        //make sql happy about the string
        string EscapeString(string s)
        {
            string szReturn = (string)s.Clone();
            
            szReturn.Replace("'", "''");

            return szReturn;
        }

        //arrKeysToJoinOn length needs to be at least 1
        string GetJoinClause(string [] arrKeysToJoinOn)
        {
            System.Text.StringBuilder sb = new StringBuilder();

            int i = 0;
            
            for (i = 0; i < arrKeysToJoinOn.Length - 1; i++)
            {
                sb.Append(string.Format("{0}.{2}={1}.{2} AND ", SOURCE, TARGET, arrKeysToJoinOn[i]));
            }

            sb.Append(string.Format("{0}.{2}={1}.{2} ", SOURCE, TARGET, arrKeysToJoinOn[i]));

            return sb.ToString();
        }

        string GetAggregatedColumnsToRetrieveClause(string[] arrColumn)
        {
            System.Text.StringBuilder sb = new StringBuilder();

            int i = 0;
            for (i = 0; i < arrColumn.Length - 1; i++)
            {
                sb.Append(string.Format(" MIN({0}) as {0},", arrColumn[i]));
            }

            sb.Append(string.Format(" MIN({0}) as {0}", arrColumn[i]));

            return sb.ToString();
        }

        string GetColumnsToRetrieveClause(string[] arrColumn, string[] arrTypes)
        {
            System.Text.StringBuilder sb = new StringBuilder();

            int i = 0;
            string szFormatted = null;
            for (i = 0; i < arrColumn.Length - 1; i++)
            {
                szFormatted = GetColumnToRetrieve(arrColumn[i], arrTypes[i]);
                sb.Append(string.Format(" {0},", szFormatted));
            }

            szFormatted = GetColumnToRetrieve(arrColumn[i], arrTypes[i]);
            sb.Append(string.Format(" {0}", szFormatted));

            return sb.ToString();
        }

        string GetColumnToRetrieve(string szColumn, string szType)
        {
            string szReturn = string.Format(" {0}", szColumn);
            switch (szType)
            {
                case "bit":
                    szReturn = string.Format(" cast ({0} as int) as {0}", szColumn);
                    break;

                case "text":
                    szReturn = string.Format(" cast ({0} as varchar(4096)) as {0}", szColumn);
                    break;

                case "ntext":
                    szReturn = string.Format(" cast ({0} as varchar(4096)) as {0}", szColumn);
                    break;

                default:
                    break;
            }
            return szReturn;
        }

        string GetGroupByClause(string[] arrColumn)
        {
            System.Text.StringBuilder sb = new StringBuilder();

            int i = 0;
            for (i = 0; i < arrColumn.Length - 1; i++)
            {
                sb.Append(string.Format(" {0},", arrColumn[i]));
            }

            sb.Append(string.Format(" {0}", arrColumn[i]));

            return sb.ToString();
        }

        string GetColumns(string[] arrColumn)
        {
            System.Text.StringBuilder sb = new StringBuilder();

            int i = 0;
            for (i = 0; i < arrColumn.Length - 1; i++)
            {
                sb.Append(string.Format("{0},", arrColumn[i]));
            }

            sb.Append(string.Format("{0}", arrColumn[i]));

            return sb.ToString();
        }

        
        string GetWhereClause(string[] arrColumn)
        {
            System.Text.StringBuilder sb = new StringBuilder();

            int i = 0;
            for (i = 0; i < arrColumn.Length - 1; i++)
            {
                sb.Append(string.Format("{0}.{1} is NULL AND ", TARGET, arrColumn[i]));
            }

            sb.Append(string.Format("{0}.{1} is NULL ", TARGET, arrColumn[i]));

            return sb.ToString();
        }
    }


    public class TablesWithIdentity:DataReaderBase
    {
        Hashtable m_TablesWithIdentity = new Hashtable();
        
        public TablesWithIdentity(string szServerTarget, string szDatabaseTarget, string szServerToRunOn):base(szServerToRunOn)
        {
            DataReaderQuery =  string.Format(" USE {2}" +
                                             " SELECT table_name " +
                                             " FROM {0}.{1}.information_schema.columns " +
                                             " WHERE table_schema = 'dbo' " +
                                             " AND     columnproperty(object_id(table_name), column_name, 'IsIdentity') = 1  " +
                                             " ORDER BY table_name ASC", 
                                             szServerTarget, szDatabaseTarget, szDatabaseTarget);

        }

        public void Load()
        {
            ExecuteDataReader();
        }
        
        public override void OnStart()
        {
           
        }
        
        public override void OnEnd()
        {
            
        }
        
        public override void OnNewRow(SqlDataReader objReader)
        {
            string szTable = (string)objReader["table_name"];
            if (m_TablesWithIdentity[szTable] == null)
            {
                m_TablesWithIdentity.Add(szTable, 1);
            }
        }        

        public bool TableContainsIdentity(string szTable)
        {
           return (m_TablesWithIdentity[szTable] != null);
        }
    }


    public class KeysForTable:DataReaderBase
    {
        public const string m_szPrimaryKey = "PRIMARY KEY";
        public const string m_szForeignKey = "FOREIGN KEY";
        
        List<string> listColumns = new List<string>(); //the columns which constitute the constraint type
        string m_szDatabase = null;
        string m_szServer   = null;
        
        public KeysForTable(string szServer, string szDatabase, string szServerToRunOn):base(szServerToRunOn)
        {
            m_szServer   = szServer;
            m_szDatabase = szDatabase;
        }
        
        public override void OnStart()
        {
            listColumns.Clear();
        }
        
        public override void OnEnd()
        {
            
        }
        
        public override void OnNewRow(SqlDataReader objReader)
        {
            listColumns.Add((string)objReader["COLUMN_NAME"]);
        }

        public string [] GetPrimaryKeysForTable(string szTable)
        {
            return GetKeysForTable(szTable, m_szPrimaryKey);
        }

        public string [] GetForeignKeysForTable(string szTable)
        {
            return GetKeysForTable(szTable, m_szForeignKey);
        }

        protected string [] GetKeysForTable(string szTable, string szKeyType)
        {
            DataReaderQuery = string.Format(" SELECT column_name  " +
                                            " FROM {0}.{1}.information_schema.table_constraints table_constraint " +
                                            " INNER JOIN {0}.{1}.information_schema.key_column_usage column_usage " +
                                            " ON table_constraint.constraint_name = column_usage.constraint_name " +
                                            " WHERE table_constraint.table_name = '{2}' " +
                                            " AND CONSTRAINT_TYPE = '{3}' " +
                                            " ORDER BY column_name ASC ", m_szServer, m_szDatabase, szTable, szKeyType);
                                            

            
            ExecuteDataReader();

            return listColumns.ToArray();  
        }

        public string [] GetAllColumns(string szTable)
        {
            DataReaderQuery = string.Format("SELECT column_name FROM {0}.{1}.information_schema.columns WHERE table_name = '{2}' ORDER BY column_name ASC", 
                                                        m_szServer, m_szDatabase, szTable);    

            ExecuteDataReader();

            return listColumns.ToArray();  
        }
        
    }


    public class TableColumnTypes:DataReaderBase
    {
        List<string> listTables = new List<string>();
        
        public TableColumnTypes(string szServerTarget, string szDatabaseTarget, string szTableName, string szServerToRunOn):base(szServerToRunOn)
        {
            DataReaderQuery =  string.Format(" SELECT data_type " +
                                             " FROM {0}.{1}.information_schema.columns " +
                                             " WHERE table_name = '{2}' ORDER BY column_name ASC", 
                                             szServerTarget, szDatabaseTarget, szTableName);
        }
        
        public override void OnStart()
        {
            listTables.Clear();
        }
        
        public override void OnEnd()
        {
            
        }
        
        public override void OnNewRow(SqlDataReader objReader)
        {
            listTables.Add((string)objReader["data_type"]);
        }        

        public string [] GetColumnsType()
        {
            ExecuteDataReader();

            return listTables.ToArray();   
        }
    }



    public class CommonTable:DataReaderBase
    {
        List<string> listTables = new List<string>();
        
        public CommonTable(string szServerSource, string szServerTarget, string szDatabaseSource, string szDatabaseTarget, string szServerToRunOn):base(szServerToRunOn)
        {
            DataReaderQuery =  string.Format(" SELECT source.name " +
                                             " FROM {0}.{2}.dbo.sysobjects source " +
                                             " INNER JOIN {1}.{3}.dbo.sysobjects target " +
                                             " ON source.name = target.name " +
                                             " WHERE source.type = 'U'", 
                                             szServerSource, szServerTarget, szDatabaseSource, szDatabaseTarget);
        }
        
        public override void OnStart()
        {
            listTables.Clear();
        }
        
        public override void OnEnd()
        {
            
        }
        
        public override void OnNewRow(SqlDataReader objReader)
        {
            listTables.Add((string)objReader["name"]);
        }        

        public string [] GetAllCommonTables()
        {
            ExecuteDataReader();

            return listTables.ToArray();   
        }
    }

    public class NonCommonTable:DataReaderBase
    {
        List<string> listTables = new List<string>();
        
        public NonCommonTable(string szServerSource, string szServerTarget, string szDatabaseSource, string szDatabaseTarget, string szServerToRunOn):base(szServerToRunOn)
        {
            DataReaderQuery =  string.Format(" SELECT source.name " +
                                             " FROM {0}.{2}.dbo.sysobjects source " +
                                             " LEFT OUTER JOIN {1}.{3}.dbo.sysobjects target " +
                                             " ON source.name = target.name " +
                                             " WHERE source.type = 'U' AND target.name IS NULL", 
                                             szServerSource, szServerTarget, szDatabaseSource, szDatabaseTarget);
        }
        
        public override void OnStart()
        {
            listTables.Clear();
        }
        
        public override void OnEnd()
        {
            
        }
        
        public override void OnNewRow(SqlDataReader objReader)
        {
            listTables.Add((string)objReader["name"]);
        }        

        public string [] GetNonCommonTables()
        {
            ExecuteDataReader();

            return listTables.ToArray();   
        }
    }

    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\DMLScriptGen\DMLInterface.cs ===
using System;
using System.Data.Sql;
using System.Data.SqlClient;

namespace xonline.tools.DMLScriptGenerator
{  
    public interface IReadGeneratedScript
    {
        void OnInsertScript(string szTable, string szLine);
        void OnDeleteScript(string szTable, string szLine);
        void OnTableSchemaChanged(string szTable);
        void OnTableToAdd(string szTable);
        void OnTableToDrop(string szTable);
        void OnTableTooComplex(string szTable);
        void OnTableCantProcess(string szTable); 
    }

    public interface IDataRead
    {
        void OnStart();
        void OnNewRow(SqlDataReader objReader);
        void OnEnd();
    }

    public interface IExcludedFiles
    {
        bool IsExcluded(string szTable);   
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\DMLScriptGen\DMLScriptGenerator.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Data.Sql;
using System.Data.SqlClient;
using System.Collections;

namespace xonline.tools.DMLScriptGenerator
{  
    class DMLScriptGenerator
    {
        string m_szSourceServer;
        string m_szTargetServer;
        string m_szSourceDB;
        string m_szTargetDB;
        string m_szServerToRunOn;

        Hashtable m_htSchemaChanged = new Hashtable();
        Hashtable m_htTableToGenScript = new Hashtable();
        Hashtable m_htTableToBeDeleted = new Hashtable();            
        Hashtable m_htTableToBeAdded   = new Hashtable();
        Hashtable m_htTableTooComplex  = new Hashtable();
        Hashtable m_htTablePartOfIdentity = new Hashtable();

        IReadGeneratedScript m_iOutputCallBack;
        IExcludedFiles m_iExcludedFiles;

        string [] m_arrSupportedTypes = new string [] {"int", "bigint", "smallint", "tinyint", "bit", "float", "real", "datetime", 
                                                       "smalldatetime", "char", "varchar", "uniqueidentifier", "nchar", "nvarchar", "text", "ntext"};
        
        public DMLScriptGenerator(string szSourceServer, string szTargetServer, string szSourceDB, string szTargetDB, IReadGeneratedScript iOutputCallBack, IExcludedFiles iExcludedFiles)
        {
            m_szSourceServer = szSourceServer;
            m_szTargetServer = szTargetServer;
            m_szSourceDB     = szSourceDB;
            m_szTargetDB     = szTargetDB;
            m_szServerToRunOn = m_szTargetServer;

            m_iOutputCallBack = iOutputCallBack;
            m_iExcludedFiles  = iExcludedFiles;
        }
        public void Generate()
        {
            //Get common tables in both database servers
            CommonTable objGetAllCommonTable = new CommonTable(m_szSourceServer, m_szTargetServer, m_szSourceDB, m_szTargetDB, m_szServerToRunOn);
            string [] arrCommonTables = objGetAllCommonTable.GetAllCommonTables();

            KeysForTable objPrimaryKeysFromSource = new KeysForTable(m_szSourceServer, m_szSourceDB, m_szServerToRunOn);
            KeysForTable objPrimaryKeysFromTarget = new KeysForTable(m_szTargetServer, m_szTargetDB, m_szServerToRunOn);
                            
            foreach (string szTable in arrCommonTables)
            {
                string [] arrAllColumnSource = objPrimaryKeysFromSource.GetAllColumns(szTable);
                string [] arrAllColumnTarget = objPrimaryKeysFromTarget.GetAllColumns(szTable);

                if (!IsArrayOfStringEqual(arrAllColumnSource, arrAllColumnTarget))
                {
                    AddIfNotExist(m_htSchemaChanged, szTable, null);
                }
                else if (TableTooComplex(m_szTargetServer, m_szTargetDB, szTable))
                {
                    //continue here
                    AddIfNotExist(m_htTableTooComplex, szTable, null);
                }
               
                //All common table needs to be remembered so dependency can be properly computed - including blacklisted files
                AddIfNotExist(m_htTableToGenScript, szTable, null);
            }

            NonCommonTable objTableToDeleteInSource = new NonCommonTable(m_szSourceServer, m_szTargetServer, m_szSourceDB, m_szTargetDB, m_szServerToRunOn);
            string [] arrTableToDeleteInSource = objTableToDeleteInSource.GetNonCommonTables();

            foreach (string szTable in arrTableToDeleteInSource)
            {
                AddIfNotExist(m_htTableToBeDeleted, szTable, null);
            }

            NonCommonTable objTableToAdd = new NonCommonTable(m_szTargetServer , m_szSourceServer , m_szTargetDB , m_szSourceDB, m_szServerToRunOn); //flipping target and source
            string [] arrTableToAddInSource = objTableToAdd.GetNonCommonTables();

            foreach (string szTable in arrTableToAddInSource)
            {
                AddIfNotExist(m_htTableToBeAdded, szTable, 1);
                AddIfNotExist(m_htTableToGenScript, szTable, null); //we will generate scripts for newly added tables too
            }
            
            TablesWithIdentity objAllTablesWithIdentity = new TablesWithIdentity(m_szTargetServer, m_szTargetDB, m_szServerToRunOn);
            objAllTablesWithIdentity.Load();
            
            ForeignTableDependency objForeignTableInTarget = new ForeignTableDependency(m_szTargetServer, m_szTargetDB,m_szServerToRunOn);

            string[] arrTablesToGenScripts = new string[m_htTableToGenScript.Keys.Count];    
            m_htTableToGenScript.Keys.CopyTo(arrTablesToGenScripts, 0);

            //figure out all dependency for all tables in htTableToGenScript
            foreach (string szTable in arrTablesToGenScripts)
            {
                string [] arrForeignKeyDependency = objForeignTableInTarget.GetForeignTableDependency(szTable);

                m_htTableToGenScript[szTable] = arrForeignKeyDependency;
            }
            
            //at this point figure out which table to execute first of all tables in htTableToGenScript
            int nTableProcessed = 0;
            int nTableProcessedPrev = 0;
            int nPass = 0;

            Stack<string> stackToDelete = new Stack<string>(); //delete needs to be processed in the reverse order

            while (nTableProcessed < m_htTableToGenScript.Keys.Count)
            {
                nTableProcessedPrev = nTableProcessed;
                
                foreach (string szTable in arrTablesToGenScripts)
                {
                    try
                    {
                        if (null == m_htTableToGenScript[szTable])
                            continue; //this is already done

                        if (!ShouldProcess(szTable) && !m_htTableToBeAdded.ContainsKey(szTable))
                            continue;
                        
                        if (DependencySatisfied(szTable, m_htTableToGenScript))
                        {
                            Console.WriteLine("{0}\tInsert {1}", nPass++, szTable);
                            stackToDelete.Push(szTable);

                            bool bPartOfIdentityChain =  IsPartOfIdentityChain(m_htTableToGenScript,objAllTablesWithIdentity , szTable);

                            if (bPartOfIdentityChain)
                            {
                                AddIfNotExist(m_htTablePartOfIdentity, szTable, 1);
                            }

                            GenerateScriptsForSingleTable(szTable, false, bPartOfIdentityChain, m_htTableToBeAdded.ContainsKey(szTable));                            
                            
                            m_htTableToGenScript[szTable] = null;
                            nTableProcessed = nTableProcessed + 1;
                        }
                    }
                    catch (Exception eInsert)
                    {
                        Console.WriteLine("!!!Error During Insert Script Generation {0}", szTable);
                        Console.WriteLine(eInsert.Message);
                    }
                }

                if (nTableProcessedPrev == nTableProcessed)
                {
                    //reach a situation where no more table can be processed
                    break;
                }
            }

            nPass = 0;
            while (stackToDelete.Count > 0)
            {
                string szTableToDelete =stackToDelete.Pop();
                Console.WriteLine("{0}\tDelete {1}", nPass++, szTableToDelete);
                try
                {
                    if (m_htTableToBeAdded.ContainsKey(szTableToDelete))
                        continue;// no delete script for newly added column
                        
                    GenerateScriptsForSingleTable(szTableToDelete, true, (m_htTablePartOfIdentity[szTableToDelete]!=null), false);
                }
                catch (Exception eDelete)
                {
                    Console.WriteLine("!!!Error During Delete Script Generation{0}", szTableToDelete);
                    Console.WriteLine(eDelete.Message);
                }
            }

            GenerateAllWarnings(); //all tables this tool will not generate script for
        }


        bool IsPartOfIdentityChain(Hashtable htDependency, TablesWithIdentity objIdentity, string szTable)
        {
            string [] arrDependency = (string [])htDependency[szTable];
            
            if (null == arrDependency)
            {
                //those which has been processed can't be part of the identity chain
                return false;
            }
            if (0  == arrDependency.Length)
            {
                return objIdentity.TableContainsIdentity(szTable);
            }
            else
            {
                foreach(string szTableDependOn in arrDependency)
                {
                    bool bIsPartOfIdentity = IsPartOfIdentityChain(htDependency, objIdentity, szTableDependOn);
                    if (true ==  bIsPartOfIdentity)
                    {
                        return true;
                    }
                }

                return objIdentity.TableContainsIdentity(szTable);
            }
        }

        bool ShouldProcess(string szTable)
        {
            KeysForTable objColumnsFromSource = new KeysForTable(m_szSourceServer, m_szSourceDB, m_szServerToRunOn);
            KeysForTable objColumnsFromTarget = new KeysForTable(m_szTargetServer, m_szTargetDB, m_szServerToRunOn);
                            
            string [] arrAllColumnSource = objColumnsFromSource.GetAllColumns(szTable);
            string [] arrAllColumnTarget = objColumnsFromTarget.GetAllColumns(szTable);

            if (m_iExcludedFiles.IsExcluded(szTable))
            {
                return false;
            }
            else if (!IsArrayOfStringEqual(arrAllColumnSource, arrAllColumnTarget))
            {
                return false;
            }
            else if (TableTooComplex(m_szTargetServer, m_szTargetDB, szTable))
            {
                return false;
            }
            else
            {
                return true;
            }
                
        }

        void GenerateAllWarnings()
        {
            if (null != m_iOutputCallBack)
            {
                foreach (string szTable in m_htSchemaChanged.Keys)
                {
                    m_iOutputCallBack.OnTableSchemaChanged(szTable);
                }

                foreach (string szTable in m_htTableToBeDeleted.Keys)
                {
                    m_iOutputCallBack.OnTableToDrop(szTable);
                }

                foreach (string szTable in m_htTableToBeAdded.Keys)
                {
                    m_iOutputCallBack.OnTableToAdd(szTable);
                }

                foreach (string szTable in m_htTableTooComplex.Keys)
                {
                    m_iOutputCallBack.OnTableTooComplex(szTable);
                }

                foreach (string szTable in m_htTableToGenScript.Keys)
                {
                    if (m_htTableToGenScript[szTable] != null && ShouldProcess(szTable) == true)
                    {
                        //i should have processed this table but i could not - foreign key constraint can't be satisfied?
                        m_iOutputCallBack.OnTableCantProcess(szTable);
                    }
                }
            }
        }

        /**
            1. Should be called when all dependency has been satisfied and tables verified to be compatible
        */
        void GenerateScriptsForSingleTable(string szTable, bool bDelete, bool bTableWithIdentity, bool bNewTable)
        {
            KeysForTable objColumns = new KeysForTable(m_szTargetServer, m_szSourceDB, m_szServerToRunOn);
            string [] arrPrimaryKeys = objColumns.GetPrimaryKeysForTable(szTable);
            string [] arrAllColumns  = objColumns.GetAllColumns(szTable);

            DataRowScripts objDataRowScript = new DataRowScripts(m_szSourceServer, m_szTargetServer, m_szSourceDB, m_szTargetDB, m_szServerToRunOn, bDelete);

            TableColumnTypes objTableType = new TableColumnTypes(m_szTargetServer, m_szTargetDB, szTable, m_szServerToRunOn);
            string [] arrTypes = objTableType.GetColumnsType();

            if (!bNewTable)
            {
                if (0 == arrPrimaryKeys.Length)
                {
                    objDataRowScript.GetAllScriptsForTable(arrAllColumns, arrAllColumns, arrTypes, szTable, m_iOutputCallBack, bTableWithIdentity);
                }
                else
                {
                    objDataRowScript.GetAllScriptsForTable(arrPrimaryKeys, arrAllColumns, arrTypes, szTable, m_iOutputCallBack, bTableWithIdentity);
                }
            }
            else
            {
                if (0 == arrPrimaryKeys.Length)
                {
                    objDataRowScript.GetAllScriptsForNewTable(arrAllColumns, arrAllColumns, arrTypes, szTable, m_iOutputCallBack, bTableWithIdentity);
                }
                else
                {
                    objDataRowScript.GetAllScriptsForNewTable(arrPrimaryKeys, arrAllColumns, arrTypes, szTable, m_iOutputCallBack, bTableWithIdentity);
                }
            }
        }


        //find out if this table contains some complex columns
        bool TableTooComplex(string szServer, string szDatabase, string szTable)
        {
            TableColumnTypes objTableType = new TableColumnTypes(szServer, szDatabase, szTable, m_szServerToRunOn);
            string [] arrTypes = objTableType.GetColumnsType();

            foreach (string szType in arrTypes)
            {
                if (!IsTypeSupported(szType))
                {
                    return true;
                }
            }

            return false;
        }


        bool IsTypeSupported(string szType)
        {
            foreach (string szSupportedType in m_arrSupportedTypes)
            {
                if (szType == szSupportedType)
                {
                    return true;
                }
            }

            return false;
        }

        bool IsArrayOfStringEqual(string [] arrString1, string [] arrString2)
        {
            if (arrString1.Length != arrString2.Length)
            {
                return false;
            }

            for (int i=0;i<arrString1.Length;i++)
            {
                if (arrString1[i] != arrString2[i])
                {
                    return false;
                }
            }

            return true;
        }

        void AddIfNotExist(Hashtable ht, object key, object value)
        {
            if (null == ht[key])
            {
                ht.Add(key, value);
            }
        }

        bool DependencySatisfied(string szTable, Hashtable ht)
        {
            string [] arrDependency = (string [])ht[szTable];

            if (0  == arrDependency.Length)
            {
                return true;
            }
            else
            {
                foreach(string szTableDependOn in arrDependency)
                {
                    if (null != ht[szTableDependOn])
                    {
                        return false;
                    }
                }

                return true;
            }
            
        }

        static void Usage()
        {
            Console.WriteLine("------------------------------------------------------------------");
            Console.WriteLine("DMLScriptGenerator -source SOURCE_SERVER -target TARGET_SERVER -sourcedb SOURCE_DB -targetdb TARGET_DB -exclude EXCLUDEDTABLES -o OUTPUT_NAME_SEED"); 
            Console.WriteLine("SOURCE_SERVER    :   The server where the old database resides");
            Console.WriteLine("TARGET_SERVER    :   The server where the new database resides");
            Console.WriteLine("SOURCE_DB        :   The name of the source db");
            Console.WriteLine("TARGET_DB        :   The name of the target db");      
            Console.WriteLine("EXCLUDEDTABLES   :   A TXT file containing all tables the tool should ignore");
            Console.WriteLine("OUTPUT_NAME_SEED :   2 files will be generated in the current directory. OUTPUT_NAME_SEED_INSERT.txt & OUTPUT_NAME_SEED_DELETES.txt");
            Console.WriteLine("e.g.     DMLScriptGenerator -source hpleung5 -target jacobr3 -sourcedb npdb -targetdb npdb -o test");
            Console.WriteLine("------------------------------------------------------------------");
            
        }

        static void Main(string[] args)
        {
            string szSourceServer = null;
            string szTargetServer = null;
            string szSourceDB     = null;
            string szTargetDB     = null;
            string szOutputNameSeed = null;
            string szOutputFileInsert = null; //contains all the insert script
            string szOutputFileDelete = null; //contains all the delete script
            string szOutputFileWarning = null;//contains all the tables which needs to be manually verified
            string szInputFileExcluded = null;

            try
            {
                for (int i = 0; i < args.Length; i++)
                {
                    if (args[i] == "-source")
                    {
                        szSourceServer = args[i + 1];
                        i = i + 1;
                    }

                    if (args[i] == "-target")
                    {
                        szTargetServer = args[i + 1];
                        i = i + 1;
                    }

                    if (args[i] == "-sourcedb")
                    {
                        szSourceDB = args[i + 1];
                        i = i + 1;
                    }

                    if (args[i] == "-targetdb")
                    {
                        szTargetDB = args[i + 1];
                        i = i + 1;
                    }

                    if (args[i] == "-exclude")
                    {
                        szInputFileExcluded = args[i+1];
                        i = i + 1;
                    }

                    if (args[i] == "-o")
                    {
                        szOutputNameSeed = args[i + 1];
                        i = i + 1;

                        szOutputFileInsert = String.Format("{0}_INSERT.txt", szOutputNameSeed);
                        szOutputFileDelete = String.Format("{0}_DELETE.txt", szOutputNameSeed);
                        szOutputFileWarning = String.Format("{0}_WARNING.txt", szOutputNameSeed);
                    }
                }

                if (null == szSourceServer || null == szTargetServer || null == szSourceDB || null == szTargetDB || null == szOutputNameSeed)
                {
                    throw new Exception("Some argument are invalid");
                }
            }
            catch (Exception e)
            {
                Console.WriteLine(e.Message);
                Usage();
                return;
            }

            //At this point all arguments were supplied
            Console.WriteLine(String.Format("Source Server  : {0}", szSourceServer));
            Console.WriteLine(String.Format("Source Database: {0}", szSourceDB));
            
            Console.WriteLine(String.Format("Destination Server  : {0}", szTargetServer));            
            Console.WriteLine(String.Format("Destination Database: {0}", szTargetDB));

            Console.WriteLine("Files to be generated");
            Console.WriteLine(String.Format("Inserts  : {0}", szOutputFileInsert));
            Console.WriteLine(String.Format("Deletes  : {0}", szOutputFileDelete));
            Console.WriteLine(String.Format("Warning  : {0}", szOutputFileWarning));       

            Console.WriteLine("Files Excluded path");
            Console.WriteLine(String.Format("Excluded : {0}", null==szInputFileExcluded?"NULL":szInputFileExcluded));

            //
            try
            {
                DMLFileWriter      objFileOutput      = new DMLFileWriter(szOutputFileInsert, szOutputFileDelete, szOutputFileWarning);
                DMLExclude         objFileExclude     = new DMLExclude(szInputFileExcluded);
                DMLScriptGenerator objScriptGenerator = new DMLScriptGenerator(szSourceServer, szTargetServer, szSourceDB, szTargetDB, objFileOutput, objFileExclude);

                objScriptGenerator.Generate();

                objFileOutput.Dispose(); //so the file get properly closed
            }
            catch (Exception eExecute)
            {
                Console.WriteLine("Error Encountered");
                Console.WriteLine(eExecute.Message);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\DMLScriptGen\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\DMLScriptGen\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\DMLScriptGen\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_dmlscriptgenerator_none_12.4.56.0_none_46d7b3b93bdffdb8
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_dmlscriptgenerator_no-public-key_12.4.56.0_x-ww_fa524188
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=dmlscriptgenerator
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_dmlscriptgenerator_no-public-key_12.4.56.0_x-ww_fa524188
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_dmlscriptgenerator_no-public-key_12.4.56.0_x-ww_fa524188.manifest
XP_MANIFEST_PATH=manifests\msil_dmlscriptgenerator_no-public-key_12.4.56.0_x-ww_fa524188.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_dmlscriptgenerator_no-public-key_12.4.56.0_x-ww_fa524188.cat
XP_CATALOG_PATH=manifests\msil_dmlscriptgenerator_no-public-key_12.4.56.0_x-ww_fa524188.cat
XP_PAYLOAD_PATH=msil_dmlscriptgenerator_no-public-key_12.4.56.0_x-ww_fa524188
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=dmlscriptgenerator,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\DMLScriptGen\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_dmlscriptgenerator_none_12.4.56.0_none_46d7b3b93bdffdb8
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_dmlscriptgenerator_no-public-key_12.4.56.0_x-ww_fa524188
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=dmlscriptgenerator
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_dmlscriptgenerator_no-public-key_12.4.56.0_x-ww_fa524188
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_dmlscriptgenerator_no-public-key_12.4.56.0_x-ww_fa524188.manifest
XP_MANIFEST_PATH=manifests\msil_dmlscriptgenerator_no-public-key_12.4.56.0_x-ww_fa524188.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_dmlscriptgenerator_no-public-key_12.4.56.0_x-ww_fa524188.cat
XP_CATALOG_PATH=manifests\msil_dmlscriptgenerator_no-public-key_12.4.56.0_x-ww_fa524188.cat
XP_PAYLOAD_PATH=msil_dmlscriptgenerator_no-public-key_12.4.56.0_x-ww_fa524188
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=dmlscriptgenerator,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\dmltransform\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\DocToHtml\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\DspFileValidator\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\dmltransform\dmltransform.cs ===
using System;
using System.Text;
using System.Collections;
using System.IO;
using System.Xml;
using System.Xml.Schema;
using System.Xml.Xsl;

using xonline.common.utilities2;

namespace xonline.tools.dmltransform
{     
    class DmlTransform
    {
        // Makes messages visible to the build system
        static string Canonicalize(string source, int? line, int? column, string code, string message, params object[] args)
        {
            if (line != null)
            {
                if (column != null)
                {
                    source = string.Format("{0}({1},{2})", source, line, column);
                }
                else
                {
                    source = string.Format("{0}({1})", source, line);
                }
            }

            return string.Format("{0} : {1}: {2}", source, code, string.Format(message, args));
        }

        static void CanonicalError(string source, int? line, int? column, string code, string message, params object[] args)
        {
            Console.Error.WriteLine(Canonicalize(source, line, column, code, message, args));
        }

        static void Usage()
        {
            Console.WriteLine("------------------------------------------------------------------");
            Console.WriteLine("dmltransform -xml XML -xsl XSL -xsd XSD -out OUTFILE -env ENVNAME -qfe QFENAME -delete");     
            Console.WriteLine("XML   :   The XML file containing the DATA");
            Console.WriteLine("XSL   :   The XSL file for the transform");
            Console.WriteLine("XSD   :   The XSD file for the schema validation");
            Console.WriteLine("ENVNAME   :   The ENVIRONMENT name");
            Console.WriteLine("QFENAME   :   Optional QFE name");
            Console.WriteLine("e.g.     dmltransform -xml npdb.xml -xsl dml.xsl -xsd dml.xsd -out npdb.sql -env xblob");
            Console.WriteLine("------------------------------------------------------------------");
            
        }
        static int Main(string[] args)
        {
            XmlDocument doc;

            string szXMLPath = null;
            string szXSLPath = null;
            string szXSDPath = null;
            string szOutputFile = null;
            string szEnv     = "xblob";
            string szQfe = null;
            bool bProcessToken = false;
            bool bProcessDelete = false;

            try
            {
                for (int i = 0; i < args.Length; i++)
                {
                    if (args[i] == "-delete")
                    {
                        bProcessDelete = true;
                    }

                    if (args[i] == "-xml")
                    {
                        szXMLPath = args[i + 1];
                        i = i + 1;
                    }

                    if (args[i] == "-env")
                    {
                        szEnv = args[i + 1];
                        i = i + 1;
                    }

                    if (args[i] == "-qfe")
                    {
                        szQfe = args[i + 1];
                        i = i + 1;
                    }

                    if (args[i] == "-token")
                    {
                        bProcessToken = true;
                    }

                    if (args[i] == "-xsl")
                    {
                        szXSLPath = args[i + 1];
                        i = i + 1;
                    }

                    if (args[i] == "-xsd")
                    {
                        szXSDPath = args[i + 1];
                        i = i + 1;
                    }

                    if (args[i] == "-out")
                    {
                        szOutputFile = args[i + 1];
                        i = i + 1;
                    }

                    if (args[i] == "/?" || args[i] == "-help")
                    {
                        Usage();
                    }
                }

                if (null == szXMLPath || null == szXSLPath || null == szXSDPath || null == szOutputFile)
                {
                    throw new Exception("Some arguments are invalid");
                }

                XmlValidator xmlvalidate = new XmlValidator();

                try
                {
                    //First we Read the XSD File
                    doc = xmlvalidate.Validate(szXSDPath, szXMLPath);
                }
                catch (XmlSchemaValidationException xmlException)
                {
                    CanonicalError(
                        szXMLPath, 
                        xmlException.LineNumber, 
                        xmlException.LinePosition, 
                        "error XSD1", 
                        "XML Validation Failed - {0}",
                        xmlException.Message);

                    return 1;
                }

                XmlNamespaceManager ns = new XmlNamespaceManager(doc.NameTable);
                ns.AddNamespace("dml", "http://www.xboxlive.com/dml");

                XmlNodeList nodes = doc.SelectNodes("/dml:database/dml:table/dml:release/dml:row/*/@_import/..", ns);

                foreach (XmlNode column in nodes)
                {
                    string path;
                    string import;

                    if (column.InnerText.Length > 0)
                    {
                        CanonicalError(szXMLPath, null, null, "error E1", "_import attribute can only be applied to empty columns.  offending column xml: {0}", column.OuterXml);

                        return 1;
                    }

                    path = Environment.ExpandEnvironmentVariables(column.Attributes["_import"].Value);

                    Console.WriteLine("Importing {0}...", path);

                    try
                    {
                        import = File.ReadAllText(path);
                    }
                    catch (Exception e)
                    {
                        CanonicalError(path, null, null, "error E2", "failed to import the specified file. {0}", e.Message);

                        return 1;
                    }

                    if (column.Attributes["_format"] == null || column.Attributes["_format"].Value != "binary")
                    {
                        StringBuilder text;

                        text = new StringBuilder();
                        text.Append("N'");
                        text.Append(import.Replace("'", "''")); // replace quotes with dual quotes for SQL
                        text.Append("'");

                        column.AppendChild(doc.CreateCDataSection(text.ToString()));
                    }
                    else
                    {
                        StringBuilder binary;
                        
                        binary = new StringBuilder();
                        binary.Append("0x");
                        binary.Append(((Blob)Encoding.UTF8.GetBytes(import)).ToString());

                        column.InnerText = binary.ToString();
                    }
                }

                XslCompiledTransform xslt = new XslCompiledTransform();
                xslt.Load(szXSLPath);

                // Create the XsltArgumentList.
                XsltArgumentList argList = new XsltArgumentList();
                argList.AddParam("env", "", szEnv);
                // Add the QFE option if it was defined
                if (null != szQfe)
                {
                    argList.AddParam("qfename", "", szQfe);
                }
                if (bProcessDelete)
                {
                    argList.AddParam("processdelete", "", true);
                }

                if (bProcessToken)
                {
                    argList.AddParam("tokenize", "", true);
                }

                using (StreamWriter sw = new StreamWriter(szOutputFile, false, Encoding.Unicode))
                {
                    // Execute the transform and output the results to a file.
                    xslt.Transform(doc, argList, sw);
                }

                return 0;

            }
            catch (Exception ex)
            {
                Console.Error.WriteLine("DML Transform failed.");
                Console.Error.WriteLine(ex.ToString());

                return 1;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\dmltransform\xmlvalidator.cs ===
using System;
    using System.Xml;               // For XmlTextReader
    using System.Xml.Schema;        // For ValidationEventArgs

    namespace xonline.tools.dmltransform
    { 
        /// <summary>
        /// Validate either an XML file against an XSD
        /// </summary>
        class XmlValidator
        {
           public XmlDocument Validate(string szXSDPath, string szXMLPath)
           {
                // Create the XmlSchemaSet class.
                XmlDocument doc = new XmlDocument();
                XmlSchemaSet sc = new XmlSchemaSet();
                // Add the schema to the collection.
                sc.Add(null, szXSDPath);

                XmlReaderSettings settings = new XmlReaderSettings();
                settings.ValidationType = ValidationType.Schema;

                settings.ValidationEventHandler += new ValidationEventHandler(ValidationCallback);
                settings.Schemas = sc;

                // Create the XmlReader object.
                XmlReader reader = XmlReader.Create(szXMLPath, settings);

                // Parse the file. 
                doc.Load(reader);

                if (null != validationException)
                {
                    throw validationException;
                }

                return doc;
            }
           
            private void ValidationCallback(object sender, ValidationEventArgs args)
            {
                if (null == validationException)
                {
                    // Save the validation exception
                    validationException = args.Exception;
                }

                // Add this offender's information to the exception
            }   // ValidationCallback


            private Exception       validationException = null;
        }   // class XmlValidator
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\DspFileValidator\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\DspFileValidator\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\dumpstats\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\DspFileValidator\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_dspfilevalidator_none_12.4.56.0_none_67a3c3efb142045a
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_dspfilevalidator_no-public-key_12.4.56.0_x-ww_f3a5a5f8
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=dspfilevalidator
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_dspfilevalidator_no-public-key_12.4.56.0_x-ww_f3a5a5f8
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_dspfilevalidator_no-public-key_12.4.56.0_x-ww_f3a5a5f8.manifest
XP_MANIFEST_PATH=manifests\msil_dspfilevalidator_no-public-key_12.4.56.0_x-ww_f3a5a5f8.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_dspfilevalidator_no-public-key_12.4.56.0_x-ww_f3a5a5f8.cat
XP_CATALOG_PATH=manifests\msil_dspfilevalidator_no-public-key_12.4.56.0_x-ww_f3a5a5f8.cat
XP_PAYLOAD_PATH=msil_dspfilevalidator_no-public-key_12.4.56.0_x-ww_f3a5a5f8
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=dspfilevalidator,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\DspFileValidator\DspFileValidator.cs ===
using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Xml;
using System.Xml.Schema;

namespace xonline.tools.dspfilevalidator
{
    /// <summary>
    /// This tool is used to validate a DSP Xml file. It will validate both that the size
    /// of the file is not greater some fixed amount, and that is conforms to an XSD.
    /// 
    /// The general overview is this: A delegate is defined for a validation method. New
    /// validation methods adhearing to the delegate can then be created. There is a static
    /// list of all the validation delegates (called 'validations'). The main method simply
    /// calls a static method that loops through and invokes each of the validator methods -
    /// looping stops when a validator fails (i.e. it does not progress and do any of the other
    /// validations).
    /// </summary>
    class DspFileValidator
    {
        // The maximum size that a DSP file should be
        // 51200 = 50k
        private static readonly Int64 MaxFileSizeInBytes = 51200;

        // The delegate for a validation - public such that a validator can be written in
        // a separate class if necessary
        public delegate String FileValidation(String dspFileName, String xsdFileName);

        // The list of all validations to be performed. Validators are added in the static class constructor
        public static readonly List<FileValidation> validations = new List<FileValidation>();

        // A static instance of DspFileValidator
        private static readonly DspFileValidator DspFileValidatorInstance = new DspFileValidator();

        // Variable to hold xml validation error information
        private static String XmlValidationError;

        private String _dspFileName;
        /// <summary>
        /// The fully qualified name of the dsp xml file
        /// </summary>
        public String DspFileName
        {
            get { return _dspFileName; }
            protected set { _dspFileName = value; }
        }

        private String _xsdFileName;
        /// <summary>
        /// The fully qualified name of the xsd file used for validating the dsp xml file
        /// </summary>
        public String XsdFileName
        {
            get { return _xsdFileName; }
            protected set { _xsdFileName = value; }
        }

        /// <summary>
        /// Static constructor is used to set up the list of validations that should be performed.
        /// If a new validating method is created, it should be added to the (ordered) list below.
        /// </summary>
        static DspFileValidator()
        {
            validations.Add(ValidateDspXmlFileExists);
            validations.Add(ValidateDspXsdFileExists);
            validations.Add(ValidateFileEncoding);
            validations.Add(ValidateFileSize);
            validations.Add(ValidateXmlAgainstXsd);
        }

        /// <summary>
        /// Validates that the DSP filename passed in by the user actually exists
        /// </summary>
        /// <param name="dspFileName">The fully qualified path to the xml file</param>
        /// <param name="xsdFileName">The fully qualified path to the xsd file</param>
        /// <returns>Null if the XML file exists; an error message if the file cannot be located.</returns>
        public static String ValidateDspXmlFileExists(String dspFileName, String xsdFileName)
        {
            if (!File.Exists(dspFileName))
            {
                return String.Format("Error: The specified DSP xml file does not exist. File: {0}", dspFileName);
            }
            return null;
        }

        /// <summary>
        /// Validates that the XSD file to be used in validating the XML file, actually exists
        /// </summary>
        /// <param name="dspFileName">The fully qualified path to the xml file</param>
        /// <param name="xsdFileName">The fully qualified path to the xsd file</param>
        /// <returns>Null if the file exists; an error message if the XSD file cannot be located.</returns>
        public static String ValidateDspXsdFileExists(String dspFileName, String xsdFileName)
        {
            if (!File.Exists(xsdFileName))
            {
                return String.Format("Error: The specified XSD file to use in validation does not exist. File: {0}", xsdFileName);
            }
            return null;
        }

        /// <summary>
        /// Validates that the xml file is UTF-8 encoded
        /// </summary>
        /// <param name="dspFileName">The fully qualified path to the xml file</param>
        /// <param name="xsdFileName">The fully qualified path to the xsd file</param>
        /// <returns>Null if encoding is correct; an error message otherwise</returns>
        public static String ValidateFileEncoding(String dspFileName, String xsdFileName)
        {
            using (StreamReader sr = new StreamReader(dspFileName))
            {
                // read at least one line so that the files encoding can be determined
                sr.ReadLine();

                // verify encoding is UTF8
                if (sr.CurrentEncoding != Encoding.UTF8)
                {
                    return "Error: File is not UTF-8 encoded.";
                }
            }
            Console.WriteLine("Validation step passed: file is UTF-8 encoded");
            return null;
        }

        /// <summary>
        /// Validates that the xml file has less than 'MaxFileSizeInBytes' bytes.
        /// </summary>
        /// <param name="dspFileName">The fully qualified path to the xml file</param>
        /// <param name="xsdFileName">The fully qualified path to the xsd file</param>
        /// <returns>Null if the file is less than or equal to the max file size; an error message if it is larger</returns>
        public static String ValidateFileSize(String dspFileName, String xsdFileName)
        {
            using (FileStream fs = new FileStream(dspFileName, FileMode.Open ))
            {
                Int64 currentFileSize = 0;
                while (fs.ReadByte() > -1)
                {
                    currentFileSize++;
                }

                if (currentFileSize > MaxFileSizeInBytes)
                {
                    return String.Format( "Error: File is too large - must be less than {0} bytes in size. Current size is {1}", MaxFileSizeInBytes, currentFileSize );
                }
            }
            Console.WriteLine(String.Format("Validation step passed: file is less than {0} bytes in size", MaxFileSizeInBytes));
            return null;
        }

        public static String ValidateXmlAgainstXsd(String dspFileName, String xsdFileName)
        {
            XmlSchemaSet sc = new XmlSchemaSet();

            // Add the schema to the collection.
            sc.Add(String.Empty, xsdFileName);

            // Set the validation settings.
            XmlReaderSettings settings = new XmlReaderSettings();
            settings.ValidationType = ValidationType.Schema;
            settings.Schemas = sc;
            settings.ValidationEventHandler += new ValidationEventHandler(ValidationCallBack);

            XmlValidationError = null;

            // Create the XmlReader object.
            XmlReader reader = XmlReader.Create(dspFileName, settings);

            // Parse the file. 
            try
            {
                while (reader.Read())
                {
                }
            }
            catch (XmlException e)
            {
                StringBuilder builder = new StringBuilder();
                builder.Append(e.Message);
                builder.Append("\n");
                builder.Append(String.Format("line number: {0}", e.LineNumber));
                return builder.ToString();
            }
            catch (Exception e)
            {
                return String.Format("Error: unexpected error parsing xml file. {0}", e.Message);
            }

            if (XmlValidationError == null)
            {
                Console.WriteLine("Validation step passed: DSP xml file validates against schema.");
            }

            return XmlValidationError;
        }

        private static void ValidationCallBack(object sender, ValidationEventArgs e)
        {
            StringBuilder builder = new StringBuilder();
            builder.Append(e.Message);
            builder.Append("\n");
            if (e.Exception != null)
            {
                builder.Append(String.Format("line number: {0}", e.Exception.LineNumber));
            }
            XmlValidationError = builder.ToString();
        }

        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        ///
        [STAThread]
        static int Main(string[] args)
        {
            // Parse the command line parameters
            String errorString = ParseCommandLineArguments(args) ;
            if (!String.IsNullOrEmpty(errorString))
            {
                Usage(errorString);
                return 1;
            }

            // Invoke the validators 
            String result = DspFileValidatorInstance.Validate();
            if (!String.IsNullOrEmpty(result))
            {
                Usage(result);
                return 1;
            }

            return 0;
        }

        /// <summary>
        /// Pull out arguments from the command line parameters
        /// </summary>
        public static String ParseCommandLineArguments(String[] args)
        {
            try
            {
                if (args.Length <= 0)
                {
                    return "No parameters specified.";
                }

                Regex regex = new Regex("=");
                foreach (String param in args)
                {
                    // Verify we have a non null, non  emty string
                    if (String.IsNullOrEmpty(param))
                    {
                        return "Invalid parameter specified";
                    }

                    // split into what comes before the '=' and what comes after.
                    // The parameter '1' limits it to a single split
                    String[] nameValuePair = regex.Split(param, 2);

                    // Check that we have atleast two parts 
                    if (nameValuePair.Length <= 1)
                    {
                        Console.WriteLine("split is [{0}] and [{1}]", nameValuePair[0], nameValuePair[1]);
                        return String.Format("The parameter {0} is not in the correct format. Must be -?=xxxx", param);
                    }

                    // Verify the individual bits
                    switch (nameValuePair[0])
                    {
                        case "-f":
                            DspFileValidatorInstance.DspFileName = nameValuePair[1];
                            break;

                        case "-x":
                            DspFileValidatorInstance.XsdFileName = nameValuePair[1];
                            break;

                        default:
                            return String.Format("The parameter {0} is unknown", nameValuePair[0]);
                    }
                }
            }
            catch (Exception e)
            {
                return String.Format("Unexpected error parsing command line arguments: {0}", e);
            }

            // Verify that everything that needs to be set has been set
            if (String.IsNullOrEmpty(DspFileValidatorInstance.DspFileName))
            {
                return "The xml file to be validated was not specified.";
            }

            if (String.IsNullOrEmpty( DspFileValidatorInstance.XsdFileName))
            {
                return "The xsd file to validate with has not been specified.";
            }

            return null;
        }

        /// <summary>
        /// Prints information on how to use the application
        /// </summary>
        public static void Usage( String errorMessage )
        {
            Console.WriteLine();
            if (!String.IsNullOrEmpty(errorMessage))
            {
                Console.WriteLine(errorMessage);
                Console.WriteLine();
            }
            Console.WriteLine("usage:");
            Console.WriteLine("\tDspFileValidator -x=xsdFile -f=dspFile");
            Console.WriteLine("");
            Console.WriteLine("\t-x=xsdFile\tfully qualified path to the file containing xsd used to validate the dsp file.");
            Console.WriteLine("\t-f=dspFile\tthe dsp file to be validated. Must be utf-8 encoded.");
            Console.WriteLine();
        }

        /// <summary>
        /// Method to run through and invoke each validator, passing in the requisite parameters.
        /// On the first occurrence of a failure of a validator, the loop stops and the error string
        /// is returned.
        /// </summary>
        /// <returns>null if all validators pass; a string error message if for the first validator that fails</returns>
        public String Validate()
        {
            foreach (FileValidation v in validations)
            {
                String result = v(DspFileName, XsdFileName);
                if (!String.IsNullOrEmpty(result))
                {
                    return result;
                }
            }

            return null;
        }
    }

    public class InvalidFileException : Exception
    {
        String _fileName;
        public String FileName
        {
            get { return _fileName; }
        }

        public InvalidFileException(String fileName)
        {
            _fileName = fileName;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\dumpv1stats\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\DspFileValidator\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_dspfilevalidator_none_12.4.56.0_none_67a3c3efb142045a
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_dspfilevalidator_no-public-key_12.4.56.0_x-ww_f3a5a5f8
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=dspfilevalidator
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_dspfilevalidator_no-public-key_12.4.56.0_x-ww_f3a5a5f8
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_dspfilevalidator_no-public-key_12.4.56.0_x-ww_f3a5a5f8.manifest
XP_MANIFEST_PATH=manifests\msil_dspfilevalidator_no-public-key_12.4.56.0_x-ww_f3a5a5f8.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_dspfilevalidator_no-public-key_12.4.56.0_x-ww_f3a5a5f8.cat
XP_CATALOG_PATH=manifests\msil_dspfilevalidator_no-public-key_12.4.56.0_x-ww_f3a5a5f8.cat
XP_PAYLOAD_PATH=msil_dspfilevalidator_no-public-key_12.4.56.0_x-ww_f3a5a5f8
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=dspfilevalidator,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\DocToHtml\DocToHtml.cs ===
using System;
using System.Xml;
using System.Xml.Xsl;
using System.Reflection;
using System.Collections;
using System.Text;
using System.IO;


namespace DocToHtml
{

	class VerifyRule
	{
		enum VerifyTypes
		{
			Class,
			Function,
			Enum,
			Max
		};

		string name = null;
		VerifyTypes type = VerifyTypes.Max;
		uint properties = 0;
		ArrayList attributes = null;
		ArrayList docrules = null;
		ArrayList extensions = null;
		ArrayList implements = null;
		ArrayList categories = null;

		public string Name
		{
			get{return name;}
		}
		class DocRule
		{
			public char count;
			public string xpath;
		}


		enum ExtensionTypes
		{
			Attribute,
			Max
		}

		class Extension
		{
			public ExtensionTypes match;
			public string name;
			public string extension;
		}

		class Category
		{
			public string nodename;
			public string xpath;
		}

		#region protected VerifyRule()
		protected VerifyRule()
		{
		}
		#endregion

		#region static <Type> GetAttribute(XmlAttribute a, <Type> def)
		static string GetAttribute(XmlAttribute a, string def)
		{
			if(a == null)
				return def;
			return a.Value;
		}

		static bool GetAttribute(XmlAttribute a, bool def)
		{
			if(a == null)
				return def;

			switch(a.Value.ToLower())
			{
				case "0":
				case "false":
				case "no":
					return false;
				case "1":
				case "true":
				case "yes":
					return true;
			};
			return def;
		}

		static ExtensionTypes GetAttribute(XmlAttribute a, ExtensionTypes def)
		{
			if(a == null)
				return def;
			
			string vt;
			string at = a.Value.ToLower();
			for(int i = 0; i < (int) ExtensionTypes.Max; ++i)
			{
				vt = ((ExtensionTypes) i).ToString().ToLower();
				if(vt == at)
					return (ExtensionTypes) i;
			}
			return def;
		}

		static VerifyTypes GetAttribute(XmlAttribute a, VerifyTypes def)
		{
			if(a == null)
				return def;
			
			string vt;
			string at = a.Value.ToLower();
			for(int i = 0; i < (int) VerifyTypes.Max; ++i)
			{
				vt = ((VerifyTypes) i).ToString().ToLower();
				if(vt == at)
					return (VerifyTypes) i;
			}
			return def;
		}
		#endregion

		/// <summary>
		/// Deserializes a VerifyRule object from the rules xml document
		/// </summary>
		/// <param name="n">Node to deserialize</param>
		/// <returns>VerifyRule if successful, null otherwise</returns>
		#region public static VerifyRule Deserialize(XmlNode n)
		public static VerifyRule Deserialize(XmlNode n)
		{
			if(n.Name != "Rule")
				return null;

			VerifyRule vr = new VerifyRule();

			vr.name = GetAttribute(n.Attributes["name"], null);
			vr.type = GetAttribute(n.Attributes["type"], VerifyTypes.Max);
			if(vr.name == null || vr.type == VerifyTypes.Max)
				return null;

			// Properties
			vr.properties |= GetAttribute(n.Attributes["public"], false) ? ((uint) TypeAttributes.Public) : 0;

			vr.implements = new ArrayList();
			vr.attributes = new ArrayList();
			vr.docrules = new ArrayList();
			vr.extensions = new ArrayList();
			vr.categories = new ArrayList();
			foreach(XmlNode c in n.ChildNodes)
			{
				if(c.NodeType != XmlNodeType.Element)
					continue;
				switch(c.Name)
				{
					case "Category":
						if(c.Attributes["name"] == null || c.Attributes["xpath"] == null)
							continue;
						Category cat = new Category();
						cat.nodename = c.Attributes["name"].Value;
						cat.xpath = c.Attributes["xpath"].Value;
						vr.categories.Add(cat);
						break;
					case "Attribute":
						if(c.Attributes["name"] == null)
							continue;
						vr.attributes.Add(c.Attributes["name"].Value);
						break;
					case "Implements":
						if(c.Attributes["name"] == null)
							continue;
						vr.implements.Add(c.Attributes["name"].Value);
						break;
					case "Doc":
						if(c.Attributes["count"] == null || 
							c.Attributes["count"].Value.Length > 1 || 
							(c.Attributes["count"].Value[0] != '0' &&
							c.Attributes["count"].Value[0] != '1' &&
							c.Attributes["count"].Value[0] != '+' &&
							c.Attributes["count"].Value[0] != '*') ||
							c.Attributes["xpath"] == null)
							continue;
						DocRule dr = new DocRule();
						dr.count = c.Attributes["count"].Value[0];
						dr.xpath = c.Attributes["xpath"].Value;
						vr.docrules.Add(dr);
						break;
					case "Extension":
						ExtensionTypes et = GetAttribute(c.Attributes["match"], ExtensionTypes.Max);
						if(et == ExtensionTypes.Max || 
							c.Attributes["name"] == null ||
							c.Attributes["extension"] == null)
							continue;
						Extension ex = new Extension();
						ex.match = et;
						ex.name = c.Attributes["name"].Value;
						ex.extension = c.Attributes["extension"].Value;
						vr.extensions.Add(ex);
						break;
				};
			}

			return vr;
		}
		#endregion

		/// <summary>
		/// Callback routine for FindInterfaces to verify that classes implement certain interfaces
		/// </summary>
		/// <param name="typeObj">The interface to test</param>
		/// <param name="criteriaObj">The arraylist of names of types (can be fully qualified or the shortname)</param>
		/// <returns>bool, indicating match</returns>
		#region static bool MyInterfaceFilter(Type typeObj, object criteriaObj)
		static bool MyInterfaceFilter(Type typeObj, object criteriaObj)
		{
			ArrayList names = (ArrayList) criteriaObj;
			foreach(string n in names)
			{
				if(typeObj.FullName == n || typeObj.Name == n)
					return true;
			}
			return false;
		}
		#endregion

		/// <summary>
		/// Determines if the set of interfaces listed in the implements array of strings are implemented by the passed in type.
		/// </summary>
		/// <param name="t">Type to search</param>
		/// <returns>Whether all interfaces (and base types) are implemented</returns>
		#region public bool MatchImplements(Type t)
		protected bool MatchImplements(Type t)
		{
			if(implements.Count == 0)
				return true;
			ArrayList srch = new ArrayList();
			ArrayList types = new ArrayList();
			Hashtable found = new Hashtable();	// Used to guarantee only one hit on a type
			srch.AddRange(implements);
			found[t.FullName] = t;
			types.Add(t);
			while(types.Count > 0 && srch.Count > 0)
			{
				// Do a breadth first search on the type passed in.  Add it's base type if it exists and it's interfaces
				// To my list of types to examine.
				Type cur = (Type) types[0];
				types.RemoveAt(0);
				if(cur.BaseType != null && found[cur.BaseType.FullName] == null)
				{
					found[cur.BaseType.FullName] = cur.BaseType;
					types.Add(cur.BaseType);
				}
				Type [] ifaces = cur.GetInterfaces();
				foreach(Type ifc in ifaces)
				{
					if(found[ifc.FullName] == null)
					{
						found[ifc.FullName] = ifc;
						types.Add(ifc);
					}
				}

				// Take the current node I've removed from the top and see if it matches any of the strings.  
				// Remove any matched strings.  If there are no strings left, I know I've got a full match and I'm done.
				foreach(string s in srch)
				{
					if(cur.FullName == s || cur.Name == s)
					{
						srch.Remove(s);
						if(srch.Count == 0)
							return true;
						break;
					}
				}
			}
			if(srch.Count == 0)
				return true;
			return false;
		}
		#endregion

		/// <summary>
		/// Determines if the rules specified match the object specified by t
		/// </summary>
		/// <param name="t">The type to attempt to match the rules to</param>
		/// <returns>true if it is a match, false otherwise</returns>
		#region public bool Match(Type t)
		public bool Match(Type t)
		{
			switch(type)
			{
				case VerifyTypes.Class:
					if(!t.IsClass)
						return false;
					break;
				case VerifyTypes.Function:
					return false;
				case VerifyTypes.Enum:
					if(!t.IsEnum)
						return false;
					break;
			}

			if(t.IsClass && !MatchImplements(t))
				return false;

			return Match((uint) t.Attributes, t.GetCustomAttributes(true));
		}
		#endregion

		/// <summary>
		/// Determines if the rules specified match the method specified by mi
		/// </summary>
		/// <param name="mi">The method to attempt to match the rules to</param>
		/// <returns>true if it is a match, false otherwise</returns>
		#region public bool Match(MethodInfo mi)
		public bool Match(MethodInfo mi)
		{
			switch(type)
			{
				case VerifyTypes.Function:
					break;
				case VerifyTypes.Class:
				case VerifyTypes.Enum:
					return false;
			}

			return Match((uint) mi.Attributes, mi.GetCustomAttributes(true));
		}
		#endregion

		/// <summary>
		/// Determines if the rules match the document node for the matching type or method
		/// </summary>
		/// <param name="n">Document node to test against</param>
		/// <returns>true if a match, false otherwise</returns>
		#region public bool ProcessNode(Type t, XmlNode n, Hashtable cats)
		public bool ProcessNode(Type t, XmlNode n, Hashtable cats)
		{
			XmlNode d = n.SelectSingleNode("Doc");
			foreach(DocRule dr in docrules)
			{
				XmlNodeList l = d.SelectNodes(dr.xpath);
				switch(dr.count)
				{
					case '0':
						if(l.Count != 0)
							DocToHtml.AddFailure(n, this, "Expected exactly zero nodes found at: " + dr.xpath);
						break;
					case '1':
						if(l.Count != 1)
							DocToHtml.AddFailure(n, this, "Expected exactly one node found at: " + dr.xpath);
						break;
					case '+':
						if(l.Count == 0)
							DocToHtml.AddFailure(n, this, "Expected at least one node found at: " + dr.xpath);
						break;
				};
			}

			ExtractCategories(d, cats);
			Extend(t, n);
			return true;
		}

		public bool ProcessNode(MethodInfo mi, XmlNode n, Hashtable cats)
		{
			XmlNode d = n.SelectSingleNode("Doc");
			foreach(DocRule dr in docrules)
			{
				XmlNodeList l = d.SelectNodes(dr.xpath);
				switch(dr.count)
				{
					case '0':
						if(l.Count != 0)
							DocToHtml.AddFailure(n, this, "Expected exactly zero nodes found at: " + dr.xpath);
						break;
					case '1':
						if(l.Count != 1)
							DocToHtml.AddFailure(n, this, "Expected exactly one node found at: " + dr.xpath);
						break;
					case '+':
						if(l.Count == 0)
							DocToHtml.AddFailure(n, this, "Expected at least one node found at: " + dr.xpath);
						break;
				};
			}

            ExtractCategories(d, cats);
			Extend(mi, n);
			return true;
		}
		#endregion

		/// <summary>
		/// Takes the node and extracts the category information into a hashtable for later spewing into a file
		/// </summary>
		/// <param name="n">Doc node that contains the interesting information</param>
		/// <param name="cats">Hashtable to populate with the category information</param>
		#region static void ExtractCategories(XmlNode n, Hashtable cats)
		void ExtractCategories(XmlNode n, Hashtable cats)
		{
			Hashtable t;
			foreach(Category cat in categories)
			{
				XmlNodeList l = n.SelectNodes(cat.xpath);
				if(l.Count == 0)
					continue;
				t = (Hashtable) cats[cat.nodename];
				if(t == null)
				{
					t = new Hashtable();
					cats[cat.nodename] = t;
				}
				foreach(XmlNode c in l)
				{
					t[c.InnerXml] = 1;
				}
			}
		}
		#endregion

		/// <summary>
		/// Extends the documentation information in the doc node n for type t based on the extension rules provided
		/// </summary>
		/// <param name="t">Type to pull the information from</param>
		/// <param name="n">Documentation node to extend</param>
		#region void Extend(Type t, XmlNode n)
		void Extend(Type t, XmlNode n)
		{
			object [] attrs = t.GetCustomAttributes(true);
			foreach(Extension e in extensions)
			{
				string n2 = e.name + "Attribute";
				switch(e.match)
				{
					case ExtensionTypes.Attribute:
						foreach(object o in attrs)
						{
							if(o.GetType().Name == e.name || o.GetType().Name == n2)
							{
								XmlNode exs = n.SelectSingleNode("extensions");
								if(exs == null)
								{
									exs = n.OwnerDocument.CreateElement("extensions");
									n.AppendChild(exs);
								}
								XmlNode ex = n.OwnerDocument.CreateElement("extension");
								XmlAttribute at = n.OwnerDocument.CreateAttribute("value");
								at.Value = e.extension;
								ex.Attributes.Append(at);
								exs.AppendChild(ex);
							}
						}
						break;
				};
			}
		}

		void Extend(MethodInfo mi, XmlNode n)
		{
			object [] attrs = mi.GetCustomAttributes(true);
			foreach(Extension e in extensions)
			{
				switch(e.match)
				{
					case ExtensionTypes.Attribute:
						foreach(object o in attrs)
						{
							if(o.GetType().Name == e.name)
							{
								XmlNode exs = n.SelectSingleNode("extensions");
								if(exs == null)
								{
									exs = n.OwnerDocument.CreateElement("extensions");
									n.AppendChild(exs);
								}
								XmlNode ex = n.OwnerDocument.CreateElement("extension");
								XmlAttribute at = n.OwnerDocument.CreateAttribute("value");
								at.Value = e.extension;
								ex.Attributes.Append(at);
								exs.AppendChild(ex);
							}
						}
						break;
				};
			}
		}
		#endregion

		// Helper function for matching information
		#region bool Match(uint typeAttrs, object [] customAttrs)
		bool Match(uint typeAttrs, object [] customAttrs)
		{
			if(attributes.Count == 0)
				return true;

			if((typeAttrs & properties) != properties)
				return false;

			foreach(string s in attributes)
			{
				string s2 = s + "Attribute";
				bool fFound = false;
				foreach(object o in customAttrs)
				{
					if(o.GetType().Name == s || o.GetType().Name == s2)
					{
						fFound = true;
						break;
					}
				}
				if(!fFound)
					return false;
			}
            return true;
		}
		#endregion
	}
	/// <summary>
	/// Summary description for DocToHtml.
	/// </summary>
	class DocToHtml
	{
		static ArrayList rules = null;
		static XslTransform transform = null;
		static ArrayList types = null;
		static XmlDocument doc = null;
		static XmlTextWriter target = null;
		static ArrayList searchPaths = new ArrayList();
		static bool debug = false;
		static bool wait = false;
		static bool nofail = false;
		static XmlDocument dest = null;
		static string docloc = null;

		static Assembly NameResolutionEventHandler(object sender, ResolveEventArgs args)
		{
			foreach(string searchPath in searchPaths) 
			{
				string chk = searchPath + "\\" + args.Name.Substring(0, args.Name.IndexOf(',')) + ".dll";
				DebugOutput("AssemblyNameResolutionEventHandler: Checking {0}", chk);
				if(File.Exists(chk))
					return Assembly.LoadFile(chk);
			}
			return null;
		}

		static void DebugOutput(string format, params object[] args)
		{
			if(debug)
			{
				Console.WriteLine(String.Format(format, args));
			}
		}

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		/// 
		[STAThread]
		static void Main(string[] args)
		{
			bool fErrors = false;

			// add assembly path resolver
			AppDomain.CurrentDomain.AssemblyResolve += new ResolveEventHandler(NameResolutionEventHandler);

			// add current directory to search path
			searchPaths.Add(Environment.CurrentDirectory);

			#region Parse arguments
			for(int i = 0; i < args.Length; ++i)
			{
				string arg = args[i].ToLower();

				// ignore all non parameter arguments
				if(!arg.StartsWith("/"))
				{
					DebugOutput("Parameter skipped: {0}", args[i]);
					continue;
				}

				// get the paramater
				int sep = arg.IndexOf(":");
				string s = "", t = "";
				if(sep > 0)
				{
					s = arg.Substring(0, sep);
					t = arg.Substring(sep + 1);
				}
				else
				{
					s = arg;
				}

				DebugOutput("Param[{0}]: {1}", s, t);
			
				// multi valued argument
				if(sep > 0)
				{
					if(s == "/r" || s == "/rules")
					{
						try
						{
							rules = new ArrayList();
							XmlDocument d = new XmlDocument();
							d.Load(t);
							foreach(XmlNode n in d.FirstChild.ChildNodes)
							{
								VerifyRule vr = VerifyRule.Deserialize(n);
								if(vr != null)
									rules.Add(vr);
							}
						}
						catch(System.Exception e)
						{
							Console.WriteLine("Failed to load rules: {0}. Error: {1}", t, e.Message);
							fErrors = true;
						}
					}
					else if(s == "/t" || s == "/transform")
					{
						try
						{
							transform = new XslTransform();
							transform.Load(t);
						}
						catch(System.Exception e)
						{
							Console.WriteLine("Failed to load transform: {0}. Error: {1}", t, e.Message);
							fErrors = true;
						}
					}
					else if(s == "/c" || s == "/component")
					{
						try
						{
							string FullPath = System.IO.Path.GetFullPath(t);
							
							// add the component's directory and parent directory to path
							searchPaths.Add(System.IO.Path.GetDirectoryName(FullPath));
							searchPaths.Add(System.IO.Path.GetDirectoryName(FullPath) + "\\..");

							Assembly component;
							component = System.Reflection.Assembly.LoadFile(FullPath);
							types = new ArrayList();
							Type [] ts = component.GetTypes();
							foreach(Type mt in ts)
								types.Add(mt);

						}
						catch(System.Exception e)
						{
							Console.WriteLine("Failed to load component: {0}. Error: {1}", t, e.Message);
							fErrors = true;
						}
					}
					else if(s == "/d" || s == "/doc")
					{
						try
						{
							doc = new XmlDocument();
							doc.Load(t);
							docloc = t;
						}
						catch(System.Exception e)
						{
							Console.WriteLine("Failed to load doc: {0}. Error: {1}", t, e.Message);
							fErrors = true;
						}
					}
					else if(s  == "/o" || s == "/out")
					{
						target = new XmlTextWriter(t, Encoding.UTF8);
					}
				}
				else // single valued parameters
				{
					if(s == "/debug")
					{
						debug = true;
					}											   
					else if(s == "/wait")
					{
						wait = true;
					}
					else if(s == "/nofail")
					{
						nofail = true;
					}
				}
			}
			#endregion

			#region Verify arguments
			if(transform == null)
			{
				Console.WriteLine("Transform file was either not found or not provided.");
				fErrors = true;
			}
			if(rules != null && rules.Count == 0)
			{
				Console.WriteLine("Warning: Rules file didn't have any parseable rules.  Component file will be skipped.");
			}
			if(rules != null && types == null)
			{
				Console.WriteLine("Component file was either not found or not provided.");
				fErrors = true;
			}
			else if(rules == null && types != null)
			{
				Console.WriteLine("Component file supplied, however no rules were specified.  Component file will be ignored.");
			}
			if(doc == null)
			{
				Console.WriteLine("Doc file was either not found or not provided.");
				fErrors = true;
			}
			if(fErrors)
			{
				DisplayHelp();
				goto lbEndMain;
			}
			#endregion

			if(rules != null  && rules.Count > 0)
			{
				try
				{
					ValidateAndAnnotate();		// Only useful if there are rules defining annotation
				}
				catch(System.Exception e)
				{
					Console.WriteLine("Failed to validate & annotate the help doc.  Message: {0}", e.Message);
					Console.WriteLine("Call Stack: {0}", e.StackTrace.ToString());
					goto lbEndMain;
				}
			}
			else
			{
				dest = doc;
			}

			if(debug)
			{
				XmlTextWriter tw = new XmlTextWriter("debug.xml", Encoding.UTF8);
				tw.Formatting = Formatting.Indented;
				dest.Save(tw);
				tw.Close();
			}
			if(target == null)
			{
				target = new XmlTextWriter(docloc + ".html", Encoding.UTF8);
			}
			try
			{
				transform.Transform(dest, null, target, null); 
			}
			catch(System.Exception e)
			{
				Console.WriteLine("Failed to complete transformation.  Message: {0}", e.Message);
				Console.WriteLine("Call Stack: {0}", e.StackTrace.ToString());
			}
			target.Close();

lbEndMain:
			if(wait)
			{
				Console.WriteLine("[Press any key to continue]");
				Console.ReadLine();
			}
		}

		/// <summary>
		/// Returns the current node, creating all intermediate nodes as specified.
		/// </summary>
		#region static XmlNode GetThisStarNodeByName(XmlDocument dest, Hashtable ht, string nm)
		static char [] seps = new char[] {'.'};
		static XmlNode GetThisStarNodeByName(XmlDocument dest, Hashtable ht, string nm)
		{
			XmlNode parent = dest.FirstChild;
			XmlNode child = null;

			// explicitly build path Xml nodes and link them if they do not exist
			// do not process the last node
			string []path = nm.Split('.');
			string nodename = "";
			for(int i = 0; i < path.Length; ++i)
			{
				nodename += (i == 0 ? "" : ".") + path[i];

				// see if we have indexed this node yet
				child = ht[nodename] as XmlNode;
				if(child == null)
				{
					DebugOutput("Indexing new path node: {0}", nodename);
					child = dest.CreateElement(path[i]);
					ht[nodename] = child;
					parent.AppendChild(child);
				}
				parent = child;
			}

			return parent;
		}
		#endregion

		#region static void ValidateAndAnnotate()
		static void ValidateAndAnnotate()
		{
			Hashtable typeNodes = new Hashtable();
			Hashtable methodNodes = new Hashtable();
			Hashtable namespaceNodes = new Hashtable();
			Hashtable categories = new Hashtable();
			uint typeMatches = 0, typeToRuleMatches = 0;
			uint methodMatches = 0, methodToRuleMatches = 0;

			dest = new XmlDocument();
			dest.LoadXml("<Documentation />");
			namespaceNodes[""] = dest.FirstChild;

			XmlNodeList nodes = doc.SelectNodes("/doc/members/member[starts-with(attribute::name, 'T:')]");
			foreach(XmlNode n in nodes)
			{
				typeNodes[n.Attributes["name"].Value.Substring(2)] = n;
			}

			nodes = doc.SelectNodes("/doc/members/member[starts-with(attribute::name, 'M:')]");
			foreach(XmlNode n in nodes)
			{
				methodNodes[n.Attributes["name"].Value.Substring(2)] = n;
			}

			// Verify all the types and methods as part of types
			for(int i = 0; i < types.Count; ++i)
			{
				Type t = (Type) types[i];
				string nm = t.FullName.Replace('+', '.');
				// Attempt to determine if the current type needs to be verified and/or annotated
				XmlNode n = (XmlNode) typeNodes[nm];
				bool fMatched = false;
				foreach(VerifyRule vr in rules)
				{
					if(vr.Match(t))
					{
						fMatched = true;
						typeToRuleMatches++;

						// Attempt to find the node this belongs to.  If not found, add it along the way.
						XmlNode thisNode = GetThisStarNodeByName(dest, namespaceNodes, nm);
						if(n != null)	// Copy the inner commentary if it exists
						{
							XmlNode d = thisNode.OwnerDocument.CreateElement("Doc");
							d.InnerXml = n.InnerXml;
							thisNode.AppendChild(d);
						}

						AddMatch(thisNode, vr);
						if(n == null)		// If I didn't find the documentation node
						{
							AddFailure(thisNode, vr, "Matched a rule but no corresponding documentation was found for it.");
						}
						else
						{
							vr.ProcessNode(t, thisNode, categories);	// Found the doc node, verify the contents and possibly add more information
						}
					}
				}

				if(fMatched)
				{
					DebugOutput("+ Matched Type: {0}", t.FullName);
					typeMatches++;
				}
				else
				{
					DebugOutput("- Unmatched Type: {0}", t.FullName);
				}

				/*
				foreach(Type subtype in t.GetNestedTypes())
				{
					types.Add(subtype);
				}
				*/
				// For each method of each type verify that if it matches a rule that it A has a document and B conforms to the doc's rules (if any)
				MethodInfo [] mis = t.GetMethods();
				foreach(MethodInfo mi in mis)
				{
					nm = GetFullMethodName(t, mi);
					n = (XmlNode) methodNodes[nm];
					fMatched = false;
					foreach(VerifyRule vr in rules)
					{
						if(vr.Match(mi))
						{
							fMatched = true;
							methodToRuleMatches++;

							XmlNode thisNode = GetThisStarNodeByName(dest, namespaceNodes, nm);
							if(n != null)
							{
								XmlNode d = thisNode.OwnerDocument.CreateElement("Doc");
								d.InnerXml = n.InnerXml;
								thisNode.AppendChild(d);
							}

							AddMatch(thisNode, vr);
							if(n == null)		// If I didn't find the documentation node
							{
								AddFailure(thisNode, vr, "Matched a rule but no corresponding documentation was found for it.");
							}
							else
							{
								vr.ProcessNode(mi, thisNode, categories);		// Found the doc node, verify the contents and possibly add more information
							}
						}
					}
					if(fMatched)
					{
						DebugOutput("+ Matched Method: {0}", nm);
						methodMatches++;
					}
					else
					{
						DebugOutput("- Unmatched Method: {0}", nm);
					}
				}
			}

			ListCategories(dest.FirstChild, categories);
		}
		#endregion

		#region static void ListCategories(Hashtable cats)
		static void ListCategories(XmlNode n, Hashtable cats)
		{
			if(cats.Count == 0)
				return;
			XmlNode cs = n.OwnerDocument.CreateElement("Categories");
			n.AppendChild(cs);
			foreach(string nm in cats.Keys)
			{
				Hashtable ht = (Hashtable) cats[nm];
				foreach(string val in ht.Keys)
				{
					XmlNode c = n.OwnerDocument.CreateElement("Category");
					XmlAttribute at = n.OwnerDocument.CreateAttribute("value");
					at.Value = val;
					c.Attributes.Append(at);
					at = n.OwnerDocument.CreateAttribute("name");
					at.Value = nm;
					c.Attributes.Append(at);
					cs.AppendChild(c);
				}
			}
		}
		#endregion

		#region static void AddFailure(XmlNode n, VerifyRule vr, string text)
		static public void AddFailure(XmlNode n, VerifyRule vr, string text)
		{
			// Allow the command line to control failure output
			if(nofail)
				return;

			XmlNode f = n.OwnerDocument.CreateElement("Failure");
			XmlAttribute at = n.OwnerDocument.CreateAttribute("rule");
			at.Value = vr.Name;
			f.Attributes.Append(at);
			XmlNode t = n.OwnerDocument.CreateTextNode(text);
			f.AppendChild(t);
			n.AppendChild(f);
		}
		#endregion

		#region static void AddMatch(XmlNode n, VerifyRule vr)
		static void AddMatch(XmlNode n, VerifyRule vr)
		{
			XmlNode m = n.OwnerDocument.CreateElement("Match");
			XmlAttribute at = n.OwnerDocument.CreateAttribute("rule");
			at.Value = vr.Name;
			m.Attributes.Append(at);
			n.AppendChild(m);
		}
		#endregion


		#region static string GetFullMethodName(Type t, MethodInfo mi)
		static string GetFullMethodName(Type t, MethodInfo mi)
		{
			// Construct the actual name.  This is necessary for multiple methods with the same name but different parameters.
			StringBuilder sb = new StringBuilder();
			sb.Append(t.FullName.Replace('+', '.')).Append(".").Append(mi.Name);
			ParameterInfo [] pis = mi.GetParameters();
			if(pis.Length > 0)
			{
				sb.Append("(");
				bool fNeedComma = false;
				foreach(ParameterInfo pi in pis)
				{
					if(fNeedComma)
						sb.Append(",");
					sb.Append(pi.Name);
					fNeedComma = true;
				}
				sb.Append(")");
			}
			return sb.ToString();
		}
		#endregion

		#region static void DisplayHelp()
		static void DisplayHelp()
		{
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\ErrorLookup\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\dumpv1stats\dumpv1stats.cs ===
using System;
using System.Data.SqlClient;
using System.Data;
using System.IO;
using System.Data.SqlTypes;
using System.Collections;
using System.Text;

namespace dumpv1stats
{
    /// <summary>
    /// Summary description for Class1.
    /// </summary>
    class Class1
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main(string[] args)
        {

            if (args.Length != 4)
            {
                Console.WriteLine("dumpv1stats <sql server> <database> <title> <lb>");
                return;
            }

            string server = args[0];
            string database = args[1];
            uint titleid = Convert.ToUInt32(args[2]);
            uint lb = Convert.ToUInt32(args[3]);
            bool header = true;

            SqlBinary sqlbin;
            MemoryStream stream;
            BinaryReader br;


            using (SqlConnection cxn = new SqlConnection("Data Source="+server
                       + ";Initial Catalog=" + database + ";Integrated Security=SSPI;Timeout=2400"))
            {
                cxn.Open();

                SqlCommand cmd = new SqlCommand(
                    "select a.bi_user_id, r.bi_rating, a.i_att_size, a.nvc_att_path_name, n.nvc_nickname, a.vb_attrib_data " +
                    " from dbo.t_leader_board lb " +
                    " join dbo.t_attrib a on lb.uid_leader_board_id = a.uid_leader_board_id " +
                    " left outer join dbo.t_rating r on a.uid_leader_board_id = r.uid_leader_board_id and a.bi_user_id = r.bi_user_id " +
                    " left outer join dbo.t_nickname n on a.uid_leader_board_id = n.uid_leader_board_id and a.bi_user_id = n.bi_user_id " +
                    " where i_title_id = " + titleid +
                    " and i_leader_board_type = " + lb +
                    " order by r.bi_rating desc", cxn);

                SqlDataReader reader = cmd.ExecuteReader();
                while(reader.Read())
                {
                    if (header)
                    {
                        Console.Write("PUID\tRating\tatt_size\tatt_path\tnickname");

                        sqlbin = reader.GetSqlBinary(5);
                        stream = new MemoryStream(sqlbin.Value, 0, sqlbin.Length, false, true);
                        br = new BinaryReader(stream);

                        while(stream.Position != stream.Length)
                        {
                            ushort statId;
                            ushort type;
                            object val;

                            ReadFromDbFormat(br, out statId, out type, out val);

                            Console.Write("\t" + statId.ToString("x"));
                        }

                        Console.WriteLine("");

                        header = false;
                    }

                    Console.Write("0x" + reader.GetInt64(0).ToString("x") + "\t" + reader.GetInt64(1));
                    Console.Write("\t" + (reader.GetSqlInt32(2).IsNull ? "(null)" : reader.GetInt32(2).ToString()));
                    Console.Write("\t" + (reader.GetSqlString(3).IsNull ? "(null)" : reader.GetString(3)));
                    Console.Write("\t" + (reader.GetSqlString(4).IsNull ? "(null)" : reader.GetString(4)));

                    sqlbin = reader.GetSqlBinary(5);
                    stream = new MemoryStream(sqlbin.Value, 0, sqlbin.Length, false, true);
                    br = new BinaryReader(stream);

                    while(stream.Position != stream.Length)
                    {
                        ushort statId;
                        ushort type;
                        object val;

                        ReadFromDbFormat(br, out statId, out type, out val);

                        //Console.Write("\t" + statId +","+ type +",");
                        Console.Write("\t");

                        AttrType attrType = (AttrType) type;

                        switch(attrType)
                        {
                            case AttrType.Long:
                                Console.Write((int)val);
                                break;
                            case AttrType.LongLong:
                                Console.Write((long)val);
                                break;
                            case AttrType.Double:
                                Console.Write((double)val);
                                break;
                            default:
                                throw new Exception("Bad encoding. Data corruption?");
                        }

                    }

                    Console.WriteLine("");
                }




            }
        }
        // Attribute types
        public enum AttrType
        {
            None        = 0,
            Long        = 1,
            LongLong    = 2,
            Double      = 3,
            String      = 4
        }

        // ReadFromDbFormat
        static public void ReadFromDbFormat(
            BinaryReader    br,
            out ushort      usStatId,
            out ushort      type,
            out object      val )
        {
            usStatId = br.ReadUInt16();
            type = br.ReadUInt16();
            AttrType attrType = (AttrType) type;

            switch(attrType)
            {
                case AttrType.Long:
                    val = (int)br.ReadInt64();
                    break;
                case AttrType.LongLong:
                    val = br.ReadInt64();
                    break;
                case AttrType.Double:
                    val = br.ReadDouble();
                    break;
                default:
                    throw new Exception("Bad encoding. Data corruption?");
            }


        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\ErrorLookup\ErrorLookup.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

namespace xonline.tools.errorlookup 
{
	/// <summary>
	/// Summary description for WebForm1.
	/// </summary>
	public class WebForm1 : System.Web.UI.Page
	{
		private void Page_Load(object sender, System.EventArgs e)
		{
			// Put user code to initialize the page here
		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.Load += new System.EventHandler(this.Page_Load);
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\ErrorLookup\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\errparse\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\dumpstats\dumpstats.cs ===
/*
 * dumpstats.cs
 *
 * Xbox Live Operations / Voucher Management tool
 *
 * Copyright (c) Microsoft Corporation. All Rights Reserved.
 *
 * Author: SLamb
 */

using System;
using System.IO;
using System.Collections;
using System.Text;
using System.Diagnostics;
using xonline.common.service;
using xonline.common.protocol;
using xonline.common.config;

namespace xonline.tools.dumpstats
{
public class DumpStatsApp
{
    public static void Help()
    {
        Console.WriteLine("dumpstats <titleid> <lbid> [<attributes>] [/v1]");
    }
    public static void Main(string[] args)
    {
        uint titleId;
        uint lbId;
        ushort[] attribs = null;


        if (args.Length < 2)
        {
            Help();
            return;
        }

        bool useV1 = (Array.IndexOf(args, "/v1") != -1);

        titleId = SafeConvert.ToUInt32(args[0]);
        lbId = SafeConvert.ToUInt32(args[1]);

        if (args.Length > 2)
        {
            attribs = new ushort[args.Length - 2 - (useV1 ? 1 : 0)];
            for (int i = 0; i < attribs.Length; i++)
            {
                if (args[i+2] != "/v1")
                    attribs[i] = (ushort)SafeConvert.ToUInt32(args[i + 2]);
            }
        }

        Console.WriteLine("=================");
        Console.WriteLine("Enumerating all stats for");
        Console.WriteLine("TitleId: 0x" + titleId.ToString("x"));
        Console.WriteLine("Leaderboard: 0x" + lbId.ToString("x"));
        Console.Write("Attributes: ");
        if (attribs == null)
        {
            Console.WriteLine("all");
        }
        else
        {
            for (int i = 0; i < attribs.Length; i++)
            {
                Console.Write(attribs[i].ToString("x") + " ");
            }
            Console.WriteLine("");
        }

        Console.WriteLine("=================");

        if (attribs == null)
        {
            // fill in attribs with 0..63
            attribs = new ushort[64];
            for (ushort i = 0; i < attribs.Length; i++)
            {
                attribs[i] = i;
            }
        }

        if (useV1)
        {
            DumpStats_v1Prot(titleId, lbId, attribs);
            return;
        }


        //Console.Write("Rank\tPuid\tGamertag\tRating");
        Console.Write("Puid\tRating");
        for (int i = 0; i < attribs.Length; i++)
        {
            Console.Write("\t0x" + attribs[i].ToString("x"));
        }
        Console.WriteLine();

        StatsEnumByRankRequest req = new StatsEnumByRankRequest();
        req.TitleId = titleId;
        req.PageSize = XOn.XONLINE_MAX_STATS_ENUM_COUNT;
        req.Rank = 1;
        req.Specs = new StatsSpec[1];
        req.Specs[0] = new StatsSpec();
        req.Specs[0].ViewId = lbId;
        req.Specs[0].ColumnIds = attribs;

        StatsEnumResponse resp = new StatsEnumResponse();


        XrlRequest xrlreq = new XrlRequest();
        xrlreq.TargetVirtualInterface = VirtualInterface.xstatsfd_int;
        xrlreq.AuthData = new HTTPAuthData().ConstructBase64String();
        xrlreq.RequestOb = req;
        xrlreq.ResponseOb = resp;
        xrlreq.Path = req.GetXRL();

        while(true)
        {
            uint hr = xrlreq.Send();
            if (HResult.Failed(hr))
            {
                Console.WriteLine("ERROR: Enum request returned 0x" + hr.ToString("x"));
                return;
            }

            for (int i = 0; i < resp.Results[0].Rows.Length; i++)
            {
                StatsRow row = resp.Results[0].Rows[i];
                //Console.Write(row.Rank + "\t 0x" + row.Puid.ToString("x") + "\t " + row.GamerTag + "\t" + row.Rating);
                Console.Write("0x" + row.Puid.ToString("x") + "\t " + row.Rating);

                for (int j = 0; j < row.Columns.Length; j++)
                {
                    Console.Write("\t");
                    switch(row.Columns[j].Type)
                    {
                        case StatParam.Null:
                            Console.Write("(null)");
                            break;
                        case StatParam.Int8:
                            Console.Write((Byte) row.Columns[j].Data);
                            break;
                        case StatParam.Int16:
                            Console.Write((Int16) row.Columns[j].Data);
                            break;
                        case StatParam.Int32:
                            Console.Write((Int32) row.Columns[j].Data);
                            break;
                        case StatParam.Int64:
                            Console.Write((Int64) row.Columns[j].Data);
                            break;
                        case StatParam.Float:
                            Console.Write((Double) row.Columns[j].Data);
                            break;
                        case StatParam.Utf8string:
                        {
                            Console.Write((string)row.Columns[j].Data);
                            break;
                        }
                        case StatParam.Puid:
                            Console.Write((UInt64) row.Columns[j].Data);
                            break;
                        default:
                            Console.Write("UNKNOWN TYPE!");
                            break;
                    }

                }

                Console.WriteLine();
            }

            if (req.Rank + (ulong)resp.Results[0].Rows.Length >= resp.Results[0].ViewSize)
            {
                break;
            }

            // adjust starting rank and go again
            req.Rank = resp.Results[0].Rows[resp.Results[0].Rows.Length-1].Rank + 1;

        }
    }

    public static void DumpStats_v1Prot(uint titleId, uint lbId, ushort[] attribs)
    {
        MsgEnumLB req = new MsgEnumLB();

        req._uiTitleId = titleId;
        req._uiLb = lbId;
        req._uiAttrCount = (uint)attribs.Length;
        req._attrIds = attribs;
        req._uiPageSize = 100;
        req._bIsPivotUser = 0;
        req._ulPivotOrPageStart = 1;


        XrlRequest xrlreq = new XrlRequest();
        xrlreq.TargetVirtualInterface = VirtualInterface.xstatsfd_int;
        xrlreq.AuthData = new HTTPAuthData().ConstructBase64String();

        xrlreq.Path = "/xstats/xstatsenumlb.ashx";

        while(true)
        {
            MemoryStream stream = new MemoryStream();
            BinaryWriter writer = new BinaryWriter(stream);
            req.WriteTo(writer);

            xrlreq.PostData = stream.ToArray();

            uint hr = xrlreq.Send();
            if (HResult.Failed(hr))
            {
                Console.WriteLine("ERROR: Enum request returned 0x" + hr.ToString("x"));
                return;
            }

            RepEnumLB resp = new RepEnumLB();
            stream = new MemoryStream(xrlreq.ResponseData);
            BinaryReader reader = new BinaryReader(stream);
            resp.ReadFrom(reader);



            for (int i = 0; i < resp._uiRepUserCount; i++)
            {
                RepEnumLBUser row = resp._users[i];

                //Console.Write(row.Rank + "\t 0x" + row.Puid.ToString("x") + "\t " + row.GamerTag + "\t" + row.Rating);
                Console.Write("0x" + row._ulUser.ToString("x") + "\t " + row._lRating);

                for (int j = 0; j < row._attribs.Length; j++)
                {
                    Console.Write("\t");
                    switch((AttrType)row._attribs[j]._bAttrType)
                    {
                        case AttrType.None:
                            Console.Write("(null)");
                            break;
                        case AttrType.Long:
                            Console.Write((Int32) row._attribs[j]._value);
                            break;
                        case AttrType.LongLong:
                            Console.Write((Int64) row._attribs[j]._value);
                            break;
                        case AttrType.Double:
                            Console.Write((Double) row._attribs[j]._value);
                            break;
                        case AttrType.String:
                        {
                            Console.Write((string)row._attribs[j]._value);
                            break;
                        }
                        default:
                            Console.Write("UNKNOWN TYPE!");
                            break;
                    }

                }

                Console.WriteLine();
            }

            if (req._ulPivotOrPageStart + (ulong)resp._users.Length >= resp._uiLbSize)
            {
                break;
            }

            // adjust starting rank and go again
            req._ulPivotOrPageStart  = resp._users[resp._users.Length-1]._uiRank+ 1;

        }
    }




}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\ErrorLookup\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_errorlookup_none_12.4.56.0_none_4b850e8e0522d2dd
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_errorlookup_no-public-key_12.4.56.0_x-ww_d35987c5
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=errorlookup
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_errorlookup_no-public-key_12.4.56.0_x-ww_d35987c5
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_errorlookup_no-public-key_12.4.56.0_x-ww_d35987c5.manifest
XP_MANIFEST_PATH=manifests\msil_errorlookup_no-public-key_12.4.56.0_x-ww_d35987c5.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_errorlookup_no-public-key_12.4.56.0_x-ww_d35987c5.cat
XP_CATALOG_PATH=manifests\msil_errorlookup_no-public-key_12.4.56.0_x-ww_d35987c5.cat
XP_PAYLOAD_PATH=msil_errorlookup_no-public-key_12.4.56.0_x-ww_d35987c5
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=errorlookup,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\errparse\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\ErrorLookup\Global.asax.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Web;
using System.Web.SessionState;

namespace xonline.tools.errorlookup  
{
	/// <summary>
	/// Summary description for Global.
	/// </summary>
	public class Global : System.Web.HttpApplication
	{
		public Global()
		{
			InitializeComponent();
		}	
		
		protected void Application_Start(Object sender, EventArgs e)
		{

		}
 
		protected void Session_Start(Object sender, EventArgs e)
		{

		}

		protected void Application_BeginRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_EndRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_AuthenticateRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_Error(Object sender, EventArgs e)
		{

		}

		protected void Session_End(Object sender, EventArgs e)
		{

		}

		protected void Application_End(Object sender, EventArgs e)
		{

		}
			
		#region Web Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\ErrorLookup\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_errorlookup_none_12.4.56.0_none_4b850e8e0522d2dd
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_errorlookup_no-public-key_12.4.56.0_x-ww_d35987c5
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=errorlookup
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_errorlookup_no-public-key_12.4.56.0_x-ww_d35987c5
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_errorlookup_no-public-key_12.4.56.0_x-ww_d35987c5.manifest
XP_MANIFEST_PATH=manifests\msil_errorlookup_no-public-key_12.4.56.0_x-ww_d35987c5.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_errorlookup_no-public-key_12.4.56.0_x-ww_d35987c5.cat
XP_CATALOG_PATH=manifests\msil_errorlookup_no-public-key_12.4.56.0_x-ww_d35987c5.cat
XP_PAYLOAD_PATH=msil_errorlookup_no-public-key_12.4.56.0_x-ww_d35987c5
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=errorlookup,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\errparse\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\errparse\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_errparse_none_12.4.56.0_none_8c33beec4d351a1b
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_errparse_no-public-key_12.4.56.0_x-ww_a0a56011
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=errparse
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_errparse_no-public-key_12.4.56.0_x-ww_a0a56011
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_errparse_no-public-key_12.4.56.0_x-ww_a0a56011.manifest
XP_MANIFEST_PATH=manifests\msil_errparse_no-public-key_12.4.56.0_x-ww_a0a56011.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_errparse_no-public-key_12.4.56.0_x-ww_a0a56011.cat
XP_CATALOG_PATH=manifests\msil_errparse_no-public-key_12.4.56.0_x-ww_a0a56011.cat
XP_PAYLOAD_PATH=msil_errparse_no-public-key_12.4.56.0_x-ww_a0a56011
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=errparse,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\EventWeb\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\errparse\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_errparse_none_12.4.56.0_none_8c33beec4d351a1b
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_errparse_no-public-key_12.4.56.0_x-ww_a0a56011
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=errparse
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_errparse_no-public-key_12.4.56.0_x-ww_a0a56011
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_errparse_no-public-key_12.4.56.0_x-ww_a0a56011.manifest
XP_MANIFEST_PATH=manifests\msil_errparse_no-public-key_12.4.56.0_x-ww_a0a56011.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_errparse_no-public-key_12.4.56.0_x-ww_a0a56011.cat
XP_CATALOG_PATH=manifests\msil_errparse_no-public-key_12.4.56.0_x-ww_a0a56011.cat
XP_PAYLOAD_PATH=msil_errparse_no-public-key_12.4.56.0_x-ww_a0a56011
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=errparse,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\EventWeb\Default.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Data.SqlClient;

namespace Events
{
	/// <summary>
	/// Summary description for WebForm1.
	/// </summary>
	public class WebForm1 : System.Web.UI.Page
	{
		protected System.Web.UI.WebControls.Panel Panel2;
		protected System.Web.UI.WebControls.Panel RSearch;
		protected System.Web.UI.WebControls.Panel AdvSearchPanel;
		protected System.Web.UI.WebControls.Panel Panel4;
		protected System.Web.UI.WebControls.Panel Panel5;
		protected System.Web.UI.WebControls.Panel Panel7;
		protected System.Web.UI.WebControls.Panel Panel9;
		protected System.Web.UI.WebControls.Button Search;
		protected System.Web.UI.WebControls.Button AdvSearch;
		protected System.Web.UI.WebControls.Panel Panel3;
		protected System.Web.UI.WebControls.Label Label1;
		protected System.Web.UI.WebControls.Label Label2;
		protected System.Web.UI.WebControls.Label l5;
		protected System.Web.UI.WebControls.Button AdvSearchBt;
		protected System.Web.UI.WebControls.Panel Panel6;
		protected System.Web.UI.WebControls.Label Label4;
		protected System.Web.UI.WebControls.Panel Panel8;
		protected System.Web.UI.WebControls.Label Label3;
		protected System.Web.UI.WebControls.Label Service;
		protected System.Web.UI.WebControls.CheckBoxList CheckBoxList1;
		protected System.Web.UI.WebControls.Image Image1;
		protected System.Web.UI.WebControls.Panel Panel12;
		protected System.Web.UI.WebControls.Panel Panel14;
		protected System.Web.UI.WebControls.Label title;
		protected System.Web.UI.WebControls.Panel Panel13;
		protected System.Web.UI.WebControls.Panel Panel16;
		protected System.Web.UI.WebControls.Label Label5;
		protected System.Web.UI.WebControls.Panel Panel18;
		protected System.Web.UI.WebControls.Label Label8;
		protected eWorld.UI.CalendarPopup calendarPopup1;
		protected eWorld.UI.CalendarPopup Calendarpopup2;
		protected System.Web.UI.WebControls.Label t2;
		protected System.Web.UI.WebControls.Panel AdvSearchPanelshort;
		protected System.Web.UI.WebControls.Label Label9;
		protected System.Web.UI.WebControls.Label Label10;
		protected System.Web.UI.WebControls.Button refine;
		protected System.Web.UI.WebControls.Panel Results;
		protected System.Web.UI.WebControls.DataGrid DataGrid1;
		protected System.Web.UI.WebControls.TextBox tb_contains;
		protected System.Web.UI.WebControls.DropDownList ServerList;
		protected System.Web.UI.WebControls.DropDownList TypeList;
		protected System.Web.UI.WebControls.Panel ResultHead;
		protected System.Web.UI.WebControls.Panel DetailPanel;
		protected System.Web.UI.WebControls.Panel Panel20;
		protected System.Web.UI.WebControls.Label Label12;
		protected System.Web.UI.WebControls.Panel Panel21;
		protected System.Web.UI.WebControls.Label lbpuid;
		protected System.Web.UI.WebControls.Label lbtitle;
		protected System.Web.UI.WebControls.Panel Panel22;
		protected System.Web.UI.WebControls.Label lbcomputer;
		protected System.Web.UI.WebControls.Label lbsource;
		protected System.Web.UI.WebControls.Label lbeventid;
		protected System.Web.UI.WebControls.Label lbtype;
		protected System.Web.UI.WebControls.Label lbtime;
		protected System.Web.UI.WebControls.Panel Panel23;
		protected System.Web.UI.WebControls.Label lbdate;
		protected System.Web.UI.WebControls.Panel Panel24;
		protected System.Web.UI.WebControls.Panel Panel25;
		protected System.Web.UI.WebControls.Panel Panel26;
		protected System.Web.UI.WebControls.ListBox ListBox1;
		protected System.Web.UI.WebControls.TextBox tb_Detail;
		protected System.Web.UI.WebControls.ImageButton ImageButton1;
		protected System.Web.UI.WebControls.ImageButton ImageButton2;
		protected System.Web.UI.WebControls.Label l13;
		protected System.Web.UI.WebControls.Label l14;
		protected System.Web.UI.WebControls.TextBox AllWords;
		protected System.Web.UI.WebControls.TextBox Atlestwords;
		protected System.Web.UI.WebControls.TextBox NoWords;
		protected System.Web.UI.WebControls.Label Label13;
		protected System.Web.UI.WebControls.Label Label15;
		protected System.Web.UI.WebControls.Label Label16;
		protected System.Web.UI.WebControls.TextBox Tbstarthh;
		protected System.Web.UI.WebControls.TextBox Tbendhh;
		protected System.Web.UI.WebControls.Label Label17;
		protected System.Web.UI.WebControls.TextBox tbstartmm;
		protected System.Web.UI.WebControls.TextBox tbendmm;
		protected System.Web.UI.WebControls.Label Label19;
		protected System.Web.UI.WebControls.Label Label20;
		protected System.Web.UI.WebControls.CustomValidator CustomValidator1;
		protected System.Web.UI.WebControls.CustomValidator CustomValidator2;
		protected System.Web.UI.WebControls.Label i1;
		protected System.Web.UI.WebControls.DropDownList ddl_PageSize;
		protected System.Web.UI.WebControls.TextBox tb_eventids;
		protected System.Web.UI.WebControls.TextBox tb_Title;
		protected System.Web.UI.WebControls.Label Label11;
		protected System.Web.UI.WebControls.CheckBoxList Computernames;
		protected System.Web.UI.WebControls.CheckBoxList MachineALL;
		protected System.Web.UI.WebControls.Label Label14;
		protected System.Web.UI.WebControls.Label Label21;
		protected System.Web.UI.WebControls.CheckBox CheckBox1;
		protected System.Web.UI.WebControls.CheckBoxList CheckBoxList2;
		protected System.Web.UI.WebControls.Label Label7;
		protected System.Web.UI.WebControls.TextBox TextBox1;
		protected System.Web.UI.WebControls.Label Label22;
		protected System.Web.UI.WebControls.Panel Panel15;
		protected System.Web.UI.WebControls.Label testNetTime;
		protected System.Web.UI.WebControls.Button ReQuery;
		protected System.Web.UI.WebControls.Label l23;
		protected System.Web.UI.WebControls.Button backtoResults;
		protected System.Web.UI.WebControls.Panel Panel10;
		protected System.Web.UI.WebControls.Panel Panel11;
		protected System.Web.UI.WebControls.CheckBox excludetitle;
		protected System.Web.UI.WebControls.CheckBox excludeevents;
		protected System.Web.UI.WebControls.Label Label6;
		protected System.Web.UI.WebControls.TextBox txgamertag;
		protected System.Web.UI.WebControls.Label Label18;
		protected System.Web.UI.WebControls.Panel Panel1;
	
		private void Page_Load(object sender, System.EventArgs e)
		{
			// Put user code to initialize the page here
			
			if( !this.IsPostBack)
			{
				ServerList.Items.Clear();
				EventDB.GetServerList(ServerList.Items);
				int idx= ServerList.Items.Count;
				ServerList.Items.Add(new ListItem("All Server","All Server"));
				ServerList.SelectedIndex=idx;
				MachineALL.Items[0].Selected=true;
				MachineALL.Items[1].Selected=true;
				MachineALL.Items[2].Selected=true;
				MachineALL.Items[3].Selected=true;
				MachineALL.Items[4].Selected=true;
			}

			testNetTime.Text ="XBLOB-TESTNET Time in GMT: "+DateTime.Now;
		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.Search.Click += new System.EventHandler(this.Search_Click);
			this.AdvSearch.Click += new System.EventHandler(this.AdvSearch_Click);
			this.refine.Click += new System.EventHandler(this.refine_Click);
			this.ReQuery.Click += new System.EventHandler(this.ReQuery_Click);
			this.backtoResults.Click += new System.EventHandler(this.backtoResults_Click);
			this.AdvSearchBt.Click += new System.EventHandler(this.AdvSearchBt_Click);
			this.MachineALL.SelectedIndexChanged += new System.EventHandler(this.MachineALL_SelectedIndexChanged);
			this.DataGrid1.PageIndexChanged += new System.Web.UI.WebControls.DataGridPageChangedEventHandler(this.DataGrid1_PageIndexChanged);
			this.DataGrid1.SortCommand += new System.Web.UI.WebControls.DataGridSortCommandEventHandler(this.DataGrid1_SortCommand);
			this.DataGrid1.SelectedIndexChanged += new System.EventHandler(this.DataGrid1_SelectedIndexChanged);
			this.ImageButton1.Click += new System.Web.UI.ImageClickEventHandler(this.ImageButton1_Click);
			this.ImageButton2.Click += new System.Web.UI.ImageClickEventHandler(this.ImageButton2_Click);
			this.Load += new System.EventHandler(this.Page_Load);

		}
		#endregion

		private void AdvSearch_Click(object sender, System.EventArgs e)
		{
			AdvSearchPanel.Visible=true;
			AdvSearchPanelshort.Visible=true;
			RSearch.Visible=false;
			refine.Visible=false;
			ReQuery.Visible=false;
			backtoResults.Visible=false;
			DateTime today= DateTime.Today;
			DateTime lowerd= today.AddDays(-3);
			calendarPopup1.UpperBoundDate= today;
			//calendarPopup1.LowerBoundDate= lowerd;
			Calendarpopup2.UpperBoundDate= today;
			//Calendarpopup2.LowerBoundDate= lowerd;
			initAdvtab();

		}
		private void initAdvtab()
		{
			DateTime end =DateTime.Now;
			DateTime start = end.AddHours(-12);
			Calendarpopup2.SelectedDate=start;
			calendarPopup1.SelectedDate=end;

			Tbstarthh.Text=start.Hour<10?"0"+start.Hour.ToString():start.Hour.ToString();
			tbstartmm.Text=start.Minute<10?"0"+start.Minute.ToString():start.Minute.ToString();
			Tbendhh.Text=end.Hour<10?"0"+end.Hour.ToString():end.Hour.ToString();
			tbendmm.Text=end.Minute<10?"0"+end.Minute.ToString():end.Minute.ToString();
			
			CheckBoxList1.Items.Clear();
			EventDB.GetServerList(CheckBoxList1.Items);
				
		}

		private void AdvSearchBt_Click(object sender, System.EventArgs e)
		{
			AdvSearchPanel.Visible=false;
			RSearch.Visible=false;
			AdvSearchPanelshort.Visible=true;
			refine.Visible=true;
			ReQuery.Visible=true;
			Results.Visible= true;
			DetailPanel.Visible=false;
			backtoResults.Visible=false;
			

			///Advance Search
			DataGrid1.PageSize= Convert.ToInt32(ddl_PageSize.SelectedItem.Value,10);
			DataGrid1.DataSource= LoadData(BuildAdvQuery());
			DataGrid1.CurrentPageIndex=0;
			DataGrid1.CurrentPageIndex=0;
			DataGrid1.DataBind();
			DataGrid1.Visible=true;
		}

		private string BuildAdvQuery()
		{

			QueryData Qdata= new QueryData();

			Qdata.AllWordstxt=AllWords.Text;
			Qdata.Atlestwords=Atlestwords.Text;
			Qdata.NoWords=NoWords.Text;

			for (int p=0;p< CheckBoxList1.Items.Count;p++)
			{
				if( CheckBoxList1.Items[p].Selected)
					Qdata.vc_apps.Add(CheckBoxList1.Items[p].Text);
			}

			for (int p=0; p<CheckBoxList2.Items.Count;p++)
			{
				if( CheckBoxList2.Items[p].Selected)
					Qdata.Etypes.Add(CheckBoxList2.Items[p].Text);
				
			}
			
			if(CheckBox1.Checked==true)
			{
				Qdata.useDateRange = true;

				DateTime start=Calendarpopup2.SelectedDate.Date;
				start=start.AddHours(Convert.ToInt32(Tbstarthh.Text));
				start =start.AddMinutes(Convert.ToInt32(tbstartmm.Text));
				Qdata.start=start;

				DateTime end=calendarPopup1.SelectedDate.Date;
				end=end.AddHours(Convert.ToInt32(Tbendhh.Text));
				end= end.AddMinutes(Convert.ToInt32(tbendmm.Text));
				Qdata.end=end;

				
			}
			else
			{
				Qdata.useDateRange = false;
				Qdata.Durationinmin =Convert.ToInt32(TextBox1.Text);
			}

			Qdata.AllIIS =MachineALL.Items[0].Selected;
			Qdata.AllINH =MachineALL.Items[1].Selected;
			Qdata.AllWBCA=MachineALL.Items[2].Selected;
			Qdata.AllKDC=MachineALL.Items[3].Selected;
			Qdata.AllSG=MachineALL.Items[4].Selected;
			
			foreach (ListItem item in Computernames.Items)
			{
				if(item.Selected)
					Qdata.CompNames.Add(item.Text.Trim());
			}
			Qdata.Events=tb_eventids.Text.Trim();
			Qdata.titles=tb_Title.Text.Trim();

			Qdata.ExcludeEvents=excludeevents.Checked;
			Qdata.Excludetitles=excludetitle.Checked;
			Qdata.gamertags=txgamertag.Text.Trim();


			
			

			return QueryBuilder.GetAdvQuery(Qdata);

		}

		private void refine_Click(object sender, System.EventArgs e)
		{
			AdvSearchPanel.Visible=true;
			RSearch.Visible=false;
			AdvSearchPanelshort.Visible=true;
			refine.Visible=false;
			ReQuery.Visible=false;
			backtoResults.Visible=false;
		}

		
		

		void FillPoolINH(ListItemCollection items)
		{
			for (int i=1;i<9;i++)
			{
				string tmp = "XEPOOLINH"+i.ToString("d3");
				items.Add(new ListItem(tmp,tmp));
			}
		}
		void FillPoolIIS(ListItemCollection items)
		{
			for (int i=1;i<21;i++)
			{
				string tmp = "XEPOOLIIS"+i.ToString("d3");
				items.Add(new ListItem(tmp,tmp));
			}
					
		}

		void FillWBCA(ListItemCollection items)
		{
			for (int i=1;i<7;i++)
			{
				string tmp = "XEWBCAIIS"+i.ToString("d3");
				items.Add(new ListItem(tmp,tmp));
			}			
		}

		void FillKDCMAC(ListItemCollection items)
		{
			for (int i=1;i<3;i++)
			{
				string tmp = "XEXMACINH"+i.ToString("d3");
				items.Add(new ListItem(tmp,tmp));
			}
		}

		void FillSG(ListItemCollection items)
		{
			for (int i=1;i<3;i++)
			{
				string tmp = "XESECUINH"+i.ToString("d3");
				items.Add(new ListItem(tmp,tmp));
			}
		}

		private void Search_Click(object sender, System.EventArgs e)
		{
			Results.Visible= true;
			//Regular search
			string query =QueryBuilder.GetReqularQuery(tb_contains.Text,ServerList.SelectedItem.Text,TypeList.SelectedItem.Text);
			DataGrid1.DataSource= LoadData(query);
			DataGrid1.CurrentPageIndex=0;
			DataGrid1.CurrentPageIndex=0;
			DataGrid1.DataBind();
			DataGrid1.Visible=true;
		}

		private void populateDetail() 
		{
			
			int  reindex = (DataGrid1.CurrentPageIndex*DataGrid1.PageSize)+DataGrid1.SelectedIndex;

			DataView dv = (DataView)Session["Dataview"];

			if(reindex > dv.Count)
			{
				return;
			}
			lbdate.Text = "Date:-  "+dv[reindex][3].ToString();
			lbtime.Text = "Time:-  "+dv[reindex][4].ToString();
			lbtype.Text = "Type:-  "+dv[reindex][2].ToString();
			lbeventid.Text = "Event ID:-  "+dv[reindex][6].ToString();
			
			lbsource.Text = "Source:-  "+dv[reindex][5].ToString();
			
			lbcomputer.Text = "Computer:-  "+dv[reindex][7].ToString();
			Label18.Text= "Occurrence Count Per Minute:-"+dv[reindex][10].ToString();
			
			tb_Detail.Text = EventDB.GetEventDetail((int)dv[reindex][0]);
			
			if(DataGrid1.CurrentPageIndex<=0 && DataGrid1.SelectedIndex<=0)
				ImageButton1.Visible=false;
			else
				ImageButton1.Visible=true;

			if(DataGrid1.CurrentPageIndex>=DataGrid1.PageCount && DataGrid1.SelectedIndex>=DataGrid1.PageSize)
				ImageButton2.Visible=false;
			else
				ImageButton2.Visible=true;


											

		}



		
		
		
		protected ICollection LoadData(string mySelectQuery)
		{
			DataView dv = EventDB.GetResult(mySelectQuery);
			dv.Sort= "DateTime DESC";
			Session.Add("Dataview",dv);
			Session.Add("sortorder","DESC");
			Session.Add("currentPage",(int)0);
			return dv;

		}

		private void DataGrid1_SelectedIndexChanged(object sender, System.EventArgs e)
		{
			DetailPanel.Visible=true;
			backtoResults.Visible=true;
			Results.Visible= false;
			populateDetail();
		
		}

		private void DataGrid1_PageIndexChanged(object source, System.Web.UI.WebControls.DataGridPageChangedEventArgs e)
		{
			DataView dv = (DataView)Session["Dataview"];
			
			// Set CurrentPageIndex to the page the user clicked.
			DataGrid1.CurrentPageIndex = e.NewPageIndex;

			// Re-bind the data to refresh the DataGrid control. 
			DataGrid1.DataSource = dv;
			DataGrid1.DataBind();
		}

		private void ImageButton1_Click(object sender, System.Web.UI.ImageClickEventArgs e)
		{
			//up
			// do previous here
			if(DataGrid1.SelectedIndex-1<0)
			{
				if(DataGrid1.CurrentPageIndex-1>0)
				{
					DataGrid1.CurrentPageIndex=DataGrid1.CurrentPageIndex-1;
					DataGrid1.SelectedIndex=DataGrid1.PageSize-1;
				}
				else
					return;
			}
			else
			{
				DataGrid1.SelectedIndex=DataGrid1.SelectedIndex-1;
			}
			
			populateDetail();
		}

		private void ImageButton2_Click(object sender, System.Web.UI.ImageClickEventArgs e)
		{
			// Do next here 
			
			if(DataGrid1.SelectedIndex+1>=DataGrid1.Items.Count)
			{
				
				if(DataGrid1.CurrentPageIndex+1<DataGrid1.PageCount)
				{
					DataGrid1.CurrentPageIndex=DataGrid1.CurrentPageIndex+1;
					DataGrid1.SelectedIndex=0;
				}
				else
					return;
			}
					
			else
			{
				DataGrid1.SelectedIndex=DataGrid1.SelectedIndex+1;
			}
			
			populateDetail();
		}

		private void DataGrid1_SortCommand(object source, System.Web.UI.WebControls.DataGridSortCommandEventArgs e)
		{
			DataView dv = (DataView)Session["Dataview"];


			string sortorder =(string) Session["sortorder"];
			if(sortorder =="DESC")
			{
				dv.Sort= "DateTime ASC";
				Session.Add("sortorder","ASC");
			}
			else
			{
				dv.Sort= "DateTime DESC";
				Session.Add("sortorder","DESC");
			}
			
						
			// Re-bind the data to refresh the DataGrid control. 
			DataGrid1.DataSource = dv;
			DataGrid1.DataBind();
		}

		

		private void MachineALL_SelectedIndexChanged(object sender, System.EventArgs e)
		{
			Computernames.Items.Clear();
			
			if(MachineALL.Items[0].Selected!=true)
			{
				FillPoolIIS(Computernames.Items);
			}
			if(MachineALL.Items[1].Selected!=true)
			{
				FillPoolINH(Computernames.Items);
			}
			if(MachineALL.Items[2].Selected!=true)
			{
				FillWBCA(Computernames.Items);
			}
			if(MachineALL.Items[3].Selected!=true)
			{
				FillKDCMAC(Computernames.Items);
			}
			if(MachineALL.Items[4].Selected!=true)
			{
				FillSG(Computernames.Items);
			}
		}

		private void ReQuery_Click(object sender, System.EventArgs e)
		{
			AdvSearchPanel.Visible=false;
			RSearch.Visible=false;
			AdvSearchPanelshort.Visible=true;
			refine.Visible=true;
			ReQuery.Visible=true;
			Results.Visible= true;
			DetailPanel.Visible=false;
			backtoResults.Visible=false;
			

			///Advance Search
			DataGrid1.PageSize= Convert.ToInt32(ddl_PageSize.SelectedItem.Value,10);
			DataGrid1.DataSource= LoadData(BuildAdvQuery());
			DataGrid1.CurrentPageIndex=0;
			DataGrid1.CurrentPageIndex=0;
			DataGrid1.DataBind();
			DataGrid1.Visible=true;
		}

		private void backtoResults_Click(object sender, System.EventArgs e)
		{
			AdvSearchPanel.Visible=false;
			RSearch.Visible=false;
			AdvSearchPanelshort.Visible=true;
			refine.Visible=true;
			ReQuery.Visible=true;
			Results.Visible= true;
			DetailPanel.Visible=false;
			backtoResults.Visible=false;
		}

		

	



		
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\errparse\errparse.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Net;
using System.Reflection;
using System.Security.Cryptography;
using System.Text.RegularExpressions;
using System.Xml;
using System.Xml.Schema;
using System.Xml.Serialization;

using xonline.common.tools.console;
using xonline.common.errlookup;

namespace xonline.tools.errparse
{
    public class ErrParse
    {
        public static Errors m_errors;
        public static Hashtable m_errLookup;

        public class XmlTextWriterMinimalist : System.Xml.XmlTextWriter
        {
            public XmlTextWriterMinimalist(System.IO.TextWriter w) : base(w)
            {
            }

            public override void WriteStartDocument()
            {
                // suppress writing "<?xml version="1.0"?>"
            }

            public override void WriteWhitespace(string ws)
            {
                // suppress whitespace in xml
            }
        }

        public class ErrorComparer : IComparer
        {
            int IComparer.Compare(object a, object b)
            {
                Error e1 = (Error) a;
                Error e2 = (Error) b;

                return ((new CaseInsensitiveComparer()).Compare(e1.errorCode, e2.errorCode));
            }
        }

        public static string ConvertObjectToXml(Object serializableObject)
        {
            XmlSerializer serializer = new XmlSerializer(serializableObject.GetType());
            StringWriter stringWriter = new StringWriter();
            XmlTextWriterMinimalist xmlWriter = new XmlTextWriterMinimalist(stringWriter);
//          XmlTextWriter xmlWriter = new XmlTextWriter(stringWriter);
            string xml = null;
            try
            {
                serializer.Serialize(xmlWriter, serializableObject);
                xml = stringWriter.ToString();
            }
            finally
            {
                xmlWriter.Close();
                stringWriter.Close();
            }
            return xml;
        }

        static void ParseCSharp(TextReader r, string source)
        {
            int codes = 0;

            Regex regex = new Regex(
                @"\s*public\s+const\s+uint\s+(\w+)\s*=\s*([0-9a-fx]+)\s*;(?:\s*\/\/\s*(.*))?",
                RegexOptions.Compiled | RegexOptions.IgnoreCase
                );

            string s = r.ReadLine();
            while (s != null)
            {
                Match m  = regex.Match(s);
                if (m.Success)
                {
                    string errorCode = m.Groups[2].Captures[0].Value.Trim();
                    string symbolicName = m.Groups[1].Captures[0].Value.Trim();
                    string description = null;
                    if (m.Groups[3].Success)
                        description = m.Groups[3].Captures[0].Value.Trim();

                    object o = m_errLookup[errorCode];
                    if (o != null)
                    {
                        ArrayList a = (ArrayList) o;
    					bool duplicate = false;
                        foreach (Error e in a)
                        {
    						if (string.Compare(e.symbolicName, symbolicName, true) == 0)
    						{
                                if (e.description == null)
                                    e.description = description;

    							duplicate = true;

    							break;
    						}
                        }

                        if (duplicate)
                        {
                            s = r.ReadLine();

                            continue;
                        }
                    }

                    Error error = m_errors.errorCollection.Add();

                    error.errorCode = errorCode;
                    error.symbolicName = symbolicName;
                    error.description = description;

                    if (source != null)
                        error.source = source;

                    codes++;

                    if (o == null)
                    {
                        ArrayList a = new ArrayList(1);
                        a.Add(error);

                        m_errLookup[errorCode] = a;
                    }
                    else
                    {
                        ArrayList a = (ArrayList) m_errLookup[errorCode];
                        a.Add(error);
                    }
                }

                s = r.ReadLine();
            }

            // Console.WriteLine("{0} codes in {1}", codes, source);
        }

        static void ParseCHeader(TextReader r, string source)
        {
            int codes = 0;

            Regex regex = new Regex(
                @"(?:\/\/\s*\n\/\/\s*([^\n]*)\n\/\/\s*\n\s*)?\#define\s+(\w+)\s+_HRESULT_TYPEDEF_\(([0-9a-fx]+)L?\)\s*(?:\/\/\s*([^\n]*))?",
                RegexOptions.Compiled | RegexOptions.IgnoreCase | RegexOptions.Multiline
                );

            string s = r.ReadToEnd();
            MatchCollection matches = regex.Matches(s);
            foreach (Match m in matches)
            {
                string errorCode = m.Groups[3].Captures[0].Value.Trim();
                string symbolicName = m.Groups[2].Captures[0].Value.Trim();
                string description = null;
                if (m.Groups[1].Success)
                    description = m.Groups[1].Captures[0].Value.Trim();
                else if (m.Groups[4].Success)
                    description = m.Groups[4].Captures[0].Value.Trim();

                object o = m_errLookup[errorCode];
                if (o != null)
                {
                    ArrayList a = (ArrayList) o;
					bool duplicate = false;
                    foreach (Error e in a)
                    {
						if (string.Compare(e.symbolicName, symbolicName, true) == 0)
						{
                            if (e.description == null)
                                e.description = description;

							duplicate = true;

							break;
						}
                    }

                    if (duplicate)
                        continue;
                }

                Error error = m_errors.errorCollection.Add();

                error.errorCode = errorCode;
                error.symbolicName = symbolicName;
                error.description = description;

                if (source != null)
                    error.source = source;

                codes++;

                if (o == null)
                {
                    ArrayList a = new ArrayList(1);
                    a.Add(error);

                    m_errLookup[errorCode] = a;
                }
                else
                {
                    ArrayList a = (ArrayList) m_errLookup[errorCode];
                    a.Add(error);
                }
            }

            // Console.WriteLine("{0} codes in {1}", codes, source);
        }

        static void MakeTableFiles(string file)
        {
            ErrLookupUtil errLookup = new ErrLookupUtil();
            errLookup.LoadDefinitions(file);

            Hashtable sources = new Hashtable(10);

            foreach (DictionaryEntry entry in errLookup.Errors)
            {
                Error e = (Error) entry.Value;

                object o = sources[e.source];
                if (o == null)
                {
                    ArrayList a = new ArrayList();
                    a.Add(e);
                    sources[e.source] = a;
                }
                else
                {
                    ArrayList a = (ArrayList) o;
                    a.Add(e);
                }
            }

            foreach (DictionaryEntry entry in sources)
            {
                string sourceName = (string) entry.Key;
                string tableFileName = sourceName.Replace(".", "_").ToLower() + ".tbl";

                ArrayList a = (ArrayList) entry.Value;

                using(TextWriter w = new StreamWriter(tableFileName, false))
                {
                    char [] delims = { '.' };
                    string [] pieces = sourceName.Split(delims);
                    w.WriteLine("PRE({0}, \".{1}\")", pieces[0], pieces[1]);

                    foreach (Error e in a)
                    {
                        if (e.description != null)
                        {
                            string description = e.description.Replace("\\", "\\\\").Replace("\"", "\\\"");
                            w.WriteLine("QMSG({0}, \"{1}\", \"{2}\")", e.errorCode, e.symbolicName, description);
                        }
                        else
                            w.WriteLine("QMSG({0}, \"{1}\", NULL)", e.errorCode, e.symbolicName);
                    }

                    w.WriteLine("POST({0}, \".{1}\")", pieces[0], pieces[1]);
                }
            }
        }

        static void PrintErrors()
        {
            IComparer errorComparer = new ErrorComparer();
            m_errors.errorCollection.Sort(errorComparer);

            Console.WriteLine(ConvertObjectToXml(m_errors));
        }

        static void Usage()
        {
            Console.WriteLine("Usage:");
            Console.WriteLine();
            Console.WriteLine("  errparse -[hfiles|csfiles]:<file1>,<file2>,...");
            Console.WriteLine("  errparse -mktables:<file>");
        }

        static void Main(string [] rawArgs)
        {
            NamedArgParser args = new NamedArgParser();
            args.Parse(rawArgs);

            m_errors = new Errors();
            m_errLookup = new Hashtable(5000);

            try
            {
                string csfiles = args["csfiles"];
                if (csfiles != null)
                {
                    char [] delims = { ',' };
                    string [] files = csfiles.Split(delims);

                    foreach (string file in files)
                    {
                        FileInfo info = new FileInfo(file);
                        ParseCSharp(new StreamReader(file), info.Name.ToLower());
                    }
                }

                string hfiles = args["hfiles"];
                if (hfiles != null)
                {
                    char [] delims = { ',' };
                    string [] files = hfiles.Split(delims);

                    foreach (string file in files)
                    {
                        FileInfo info = new FileInfo(file);
                        ParseCHeader(new StreamReader(file), info.Name.ToLower());
                    }
                }

                string mktables = args["mktables"];
                if (mktables != null)
                {
                    MakeTableFiles(mktables);
                }

                if (csfiles != null || hfiles != null)
                    PrintErrors();
            }
            catch (Exception e)
            {
                Console.WriteLine(e.ToString());
                Usage();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\EventWeb\QueryBuilder.cs ===
using System;
using System.Collections;
using xonline.common.protocol;

namespace Events
{
    /// <summary>
    /// Summary description for QueryBuilder.
    /// </summary>
    
    public class QueryData
    {    
        public string AllWordstxt="";
        public string Atlestwords="";
        public string NoWords="";
        public ArrayList vc_apps= new ArrayList();
        public ArrayList Etypes= new ArrayList();
        public bool  useDateRange = false;
        public DateTime start;
        public DateTime end;
        public int Durationinmin;
        public bool AllIIS = false;
        public bool AllINH = false;
        public bool AllWBCA = false;
        public bool AllKDC    =false;
        public bool AllSG    =false;
        public ArrayList CompNames = new ArrayList();
        public string Events="";
        public string titles="";
        public bool ExcludeEvents=false;
        public bool Excludetitles=false;
        public string gamertags;
    }
    public class QueryBuilder
    {

        static string  hexstr="0123456789abcdef";
        public QueryBuilder()
        {
            //
            // TODO: Add constructor logic here
            //
        }
        static public int getInt(string data)
        {
            int tmp=-1;
            data=data.ToLower();

            if(data.StartsWith("0x"))
            {
                // the value is in Hex 
                tmp=Convert.ToInt32(data,16);
            }
            else
            {
                // value is in desimal
                tmp=Convert.ToInt32(data,10);
            }
            


            return tmp;
        }

        static public ArrayList Parseids(string data)
        {

            // event id's
            ArrayList idList= new ArrayList();
            string txtdata= data.Trim();
            if(txtdata !=null && txtdata.Length>0)
            {
                string[] ids=txtdata.Split(new char[]{' ',',',';'});

                for(int l=0;l<ids.Length;l++)
                {
                    string tmp = ids[l].Trim();
                    if(tmp.Length>0)
                    {
                        try
                        {
                            idList.Add(getInt(tmp));
                        }
                        catch(System.Exception)
                        {
                            // ignore the exception...
                        }
                    }

                }
            }

            return idList;

        }


        static public bool isnumber(string data)
        {

            
            if(data.StartsWith("0x"))
            {
                for(int i=2;i<data.Length;i++)
                {
                    if(hexstr.IndexOf(data[i])==-1)
                        return false;
                                    
                }
            }
            else
            {
                for(int i=0;i<data.Length;i++)
                {
                    if(!Char.IsNumber(data[i]))
                        return false;
                }
            }

            return true;
        }
    

        static public long getPUID(string data)
        {
            long tmp=-1;
            data=data.ToLower();


            if(isnumber(data))
            {
                if(data.StartsWith("0x"))
                {
                    // the value is in Hex 
                    tmp=Convert.ToInt64(data,16);
                }
                else
                {
                    // value is in desimal
                    tmp=Convert.ToInt64(data,10);
                }
            }
            else
            {
                // its a gamertag . use xcache to convert to puid.
                tmp = (long)XCache.LookupPUID(data);
            }

            return tmp;
        }


        static public ArrayList ParseGamertagsorpuids(string data)
        {

            // event id's
            ArrayList idList= new ArrayList();
            string txtdata= data.Trim();
            if(txtdata !=null && txtdata.Length>0)
            {
                string[] ids=txtdata.Split(new char[]{' ',',',';'});

                for(int l=0;l<ids.Length;l++)
                {
                    string tmp = ids[l].Trim();
                    if(tmp.Length>0)
                    {
                        try
                        {
                            long puid  =getPUID(tmp);
                            if(puid>0)
                                idList.Add(puid);
                        }
                        catch(System.Exception e)
                        {
                            string tmpe = e.ToString();
                            
                            // ignore the exception...
                        }
                    }

                }
            }

            return idList;

        }


        static public string GetReqularQuery(string SearchTxt,string server, string Type )
        {
            
            string Freetext= null;

            if(SearchTxt.Length>0)
            {
                string tcontains = SearchTxt.Trim();
                string [] array = tcontains.Split(new char[]{' '});
                ArrayList temp = new ArrayList();

                for(int i=0;i<array.Length;i++)
                {
                    if(array[i].Trim()!="")
                        temp.Add(array[i]);
                }

                bool IsLastWordSeparator =false;
                for(int i=0;i<temp.Count;i++)
                {
                    string word = (string) temp[i];
                    if(word.ToLower() !="or" && word.ToLower() !="and" )
                    {
                        if(i+1 <temp.Count)
                        {
                            string iplus1= (string)temp[i+1];
                            if(iplus1.ToLower().Trim() !="and" && !IsLastWordSeparator )
                                Freetext+= temp[i]+" or ";
                            else
                                Freetext+= temp[i]+" ";
                        }
                        else
                            Freetext+= temp[i]+" ";

                        IsLastWordSeparator= false;
                    }
                    else 
                    {
                        if(i>0)
                        {
                            if (word.ToLower() =="and")
                            {
                                if(i+1 <temp.Count)
                                {
                                    string iplus1=  (string)temp[i+1];
                                    if(iplus1.ToLower().Trim() !="and" && iplus1.ToLower().Trim() !="or" )
                                        Freetext+= temp[i]+" ";
                                    
                                }
                            }

                            IsLastWordSeparator= true;
                        }
                        
                    }
                    
                }

            }
            // build Query here 
            string mySelectQuery = "select i_index, c_type, dt_time,vc_app,i_event_id,vc_server,i_title_id,i_Count_lastmin from t_events ";
            if(server !="All Server")
            {
                mySelectQuery+="where vc_app='"+server+"' ";
                if(Freetext!=null && Freetext.Length>0)
                    mySelectQuery+=" and contains(vc_description,'"+Freetext+"') ";
                if(Type !="All Type")
                {
                    if(Type.Trim() =="Error")
                    {
                        mySelectQuery+=" and c_type='E' ";
                    }
                    else if(Type.Trim() =="Warning")
                    {
                        mySelectQuery+=" and c_type='W' ";
                    }
                    else
                    {
                        mySelectQuery+=" and c_type='I' ";
                    }
                    
                }
                mySelectQuery+=" and dt_time > DATEADD(Hour,-12,getdate())";
            }
            else if(Type !="All Type")
            {
                if(Type.Trim() =="Error")
                {
                    mySelectQuery+=" where c_type='E' ";
                }
                else if(Type.Trim() =="Warning")
                {
                    mySelectQuery+=" where c_type='W' ";
                }
                else
                {
                    mySelectQuery+=" where c_type='I' ";
                }

                if(Freetext!=null  && Freetext.Length>0)
                    mySelectQuery+=" and contains(vc_description,'"+Freetext+"') ";
                
                mySelectQuery+=" and dt_time > DATEADD(Hour,-12,getdate())";
                
            }
            else if(Freetext!=null && Freetext.Length>0)
            {
                mySelectQuery+=" where contains(vc_description,'"+Freetext+"') ";
                mySelectQuery+=" and dt_time > DATEADD(Hour,-12,getdate())";
            }
            else
            {
                mySelectQuery+=" where dt_time > DATEADD(Hour,-12,getdate())";
            }

            

            mySelectQuery+=" order by dt_time DESC";

            return mySelectQuery;

        }



        static public string GetAdvQuery(QueryData qdata)
        {
            string Query ="select i_index, c_type, dt_time,vc_app,i_event_id,vc_server,i_title_id,i_Count_lastmin from t_events";
            string contains=null;
            int containscount=0;

            string[] _allwords =(qdata.AllWordstxt.Trim()).Split(new char[]{' '});
            string[] _anywords =(qdata.Atlestwords.Trim()).Split(new char[]{' '}); 
            string[] _nowords = (qdata.NoWords.Trim()).Split(new char[]{' '});

            for(int i=0; i<_allwords.Length;i++)
            {
                string temp=_allwords[i].ToLower();
                if(temp!="" && temp!="and" && temp!="or" && temp!="not")
                {
                    if(containscount<=0)
                        contains =temp;
                    else
                        contains+=" and "+temp;
                    containscount++;
                    

                }
            }

            for(int i=0; i<_anywords.Length;i++)
            {
                string temp=_anywords[i].ToLower();
                if(temp!="" && temp!="and" && temp!="or" && temp!="not")
                {
                    if(containscount<=0)
                        contains =temp;
                    else
                        contains+=" or "+temp;
                    containscount++;
                    

                }
            }

            for(int i=0; i<_nowords.Length;i++)
            {
                string temp=_nowords[i].ToLower();
                if(temp!="" && temp!="and" && temp!="or" && temp!="not")
                {
                    if(containscount>0)
                    {
                        contains+=" and not "+temp;
                        containscount++;
                    }

                }
            }
            string servires= null;
            int serviresidx=0;

            for (int p=0;p< qdata.vc_apps.Count;p++)
            {
                if(serviresidx<=0)
                    servires = " vc_app='"+qdata.vc_apps[p]+"'";
                else
                    servires +=" or vc_app='"+qdata.vc_apps[p]+"'";
                    
                serviresidx++;
                
            }

            string types= null;
            int typesidx=0;

            for (int p=0; p<qdata.Etypes.Count;p++)
            {
                string dat = (string)qdata.Etypes[p];
                string val;
                if(dat =="Error")
                {
                    val="E";
                }
                else if(dat =="Warning")
                {
                    val="W";
                }
                else
                {
                    val="I";
                }
                
                if(typesidx<=0)
                    types = " c_type='"+val+"'";
                else
                    types +=" or  c_type='"+ val+"'";
                    
                typesidx++;
                
            }

            string timeserch=null;
            if(qdata.useDateRange)
            {

                // time search...
                
                DateTime start=qdata.start;
                DateTime end=qdata.start;
                
                if(start >end)
                    return "";
                else
                {
                    timeserch="dt_time>'"+start.ToString()+"' and dt_time<'"+end.ToString()+"'";
                }
            }
            else
            {
                timeserch = "dt_time > DATEADD(Minute,-"+qdata.Durationinmin+",getdate())";

            }

            string Compname= null;
                
            bool IsfirstSelecteditem=true;

            if(qdata.AllIIS)
            {
                Compname= " vc_server like '%POOLIIS%' ";
                IsfirstSelecteditem=false;
            }
            if(qdata.AllINH)
            {
                if(IsfirstSelecteditem==true)
                {
                    Compname = " vc_server like '%POOLINH%' ";
                    IsfirstSelecteditem=false;
                }
                else
                    Compname+= " or vc_server like '%POOLINH%' ";

            }
            if(qdata.AllWBCA)
            {
                if(IsfirstSelecteditem==true)
                {
                    Compname= " vc_server like '%WBCA%' ";
                    IsfirstSelecteditem=false;
                }
                else
                    Compname+= " or vc_server like '%WBCA%' ";
            }
            if(qdata.AllKDC)
            {
                if(IsfirstSelecteditem==true)
                {
                    Compname= " vc_server like '%XEXMACINH%' ";
                    IsfirstSelecteditem=false;
                }
                else
                    Compname+= " or vc_server like '%XEXMACINH%' ";
            }
            if(qdata.AllSG)
            {
                if(IsfirstSelecteditem==true)
                {
                    Compname= " vc_server like '%XESECUINH%' ";
                    IsfirstSelecteditem=false;
                }
                else
                    Compname+= " or vc_server like '%XESECUINH%' ";
            }



            foreach (string item in qdata.CompNames)
            {
                if(IsfirstSelecteditem)
                {
                    Compname= " vc_server='"+item.Trim()+"' ";
                    IsfirstSelecteditem=false;
                }
                else
                    Compname+= " or vc_server='"+item.Trim()+"' ";
                
            }


            // event id's

            ArrayList ids = Parseids(qdata.Events.Trim());
            string eventids=null;
            
            
            for(int l=0;l<ids.Count;l++)
            {
                if(l==0)
                {
                    if(qdata.ExcludeEvents)
                        eventids+="i_event_id <>'"+ids[l]+"'";
                    else
                        eventids+="i_event_id ='"+ids[l]+"'";
                    
                }
                else
                {
                    if(qdata.ExcludeEvents)
                        eventids+=" and i_event_id <>'"+ids[l]+"'";
                    else
                        eventids+=" or i_event_id ='"+ids[l]+"'";
                }
            }

            // titleIDs
            ArrayList tids = Parseids(qdata.titles.Trim());
            string titleids=null;
            
            
            for(int l=0;l<tids.Count;l++)
            {
                if(l==0)
                {
                    if(qdata.Excludetitles)
                        titleids+="i_title_id <>'"+tids[l]+"'";
                    else
                        titleids+="i_title_id ='"+tids[l]+"'";
                }
                else
                {
                    if(qdata.Excludetitles)
                        titleids+=" and i_title_id <>'"+tids[l]+"'";
                    else
                        titleids+=" or i_title_id ='"+tids[l]+"'";
                }
            }

            // gamertags 

                ArrayList puids = ParseGamertagsorpuids(qdata.gamertags.Trim());

            

            if(containscount >0 || serviresidx>0 ||typesidx>0 ||timeserch !=null || Compname!=null || eventids!=null)
            {
                Query +=" where ";
                if(containscount >0)
                {
                    Query+= " contains(vc_description,'"+ contains+"')";
                }
                
                if(serviresidx>0)
                {
                    if(containscount >0)
                        Query+="and ("+servires+") ";
                    else
                        Query+=" ("+servires+") ";
                }
                
                if (typesidx>0)
                {
                    if(containscount >0 || serviresidx>0 )
                        Query+="and ("+types+") ";
                    else
                        Query+=" ("+types+") ";
                }
                
                if(timeserch !=null)
                {
                    if(containscount >0 || serviresidx>0 ||typesidx>0)
                        Query+="and "+timeserch;
                    else
                        Query+=" "+timeserch;

                }

                if(Compname!=null)
                {
                    if(containscount >0 || serviresidx>0 ||typesidx>0 ||timeserch !=null)
                        Query+="and ("+Compname+") ";
                    else
                        Query+=" ("+Compname+") ";
                }

                if(eventids !=null)
                {
                    if(containscount >0 || serviresidx>0 ||typesidx>0 ||timeserch !=null||Compname!=null)
                        Query+=" and ("+eventids+" )";
                    else
                        Query+=" "+eventids;
                }

                if(titleids!=null)
                {
                    if(containscount >0 || serviresidx>0 ||typesidx>0 ||timeserch !=null||Compname!=null || eventids !=null)
                        Query+=" and ("+titleids+")";
                    else
                        Query+=" "+titleids;
                }

            }
            
            

            return Query;

        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\EventWeb\EventDB.cs ===
using System;
using System.Data;
using System.Collections;
using System.ComponentModel;
using System.Data.SqlClient;
using System.Web.UI.WebControls;


namespace Events
{
	/// <summary>
	/// Summary description for EventDB.
	/// </summary>
	public class EventDB
	{
		//static string myConnString = "Data Source=10.20.2.62 ;Initial Catalog=xblobeventdb;user id=EventDB;password=EventDB";
		static string myConnString = "Data Source=10.20.2.62 ;Initial Catalog=eventsdb;user id=EventDB;password=EventDB";
		public EventDB()
		{
		}

		static public void GetServerList(ListItemCollection items)
		{
			SqlConnection _EventCnt =null;
			try
			{
				
				string mySelectQuery = "select vc_app from dbo.Application group by vc_app";
				
				_EventCnt= new SqlConnection(myConnString);
				_EventCnt.Open();


				SqlCommand myCommand = new SqlCommand(mySelectQuery, _EventCnt);
				myCommand.CommandType = CommandType.Text;
				SqlDataReader myReader = myCommand.ExecuteReader();
				while(myReader.Read()) 
				{
					string tmp=myReader.GetString(0);
					items.Add(new ListItem(tmp.Trim(),tmp.Trim()));
				}
				myReader.Close();

			}
			finally
			{
				if(_EventCnt!=null)
				{
					_EventCnt.Close();
					_EventCnt=null;
				}

			}
		}

		static public string GetEventDetail(int idx ) 
		{
			string detail = "";
			SqlConnection _EventCnt =null;
			try
			{
				
				string mySelectQuery = "select vc_description from t_events where i_index="+idx.ToString();
				_EventCnt= new SqlConnection(myConnString);
				_EventCnt.Open();


				SqlCommand myCommand = new SqlCommand(mySelectQuery, _EventCnt);
				myCommand.CommandType = CommandType.Text;
				detail = (string) myCommand.ExecuteScalar();
			}
			finally
			{
				if(_EventCnt!=null)
				{
					_EventCnt.Close();
					_EventCnt=null;
				}

			}
			return detail;

		}

		static public DataView GetResult(string Query)
		{

			DataTable dt = new DataTable();
			DataRow dr;
			

			dt.Columns.Add(new DataColumn("Index", typeof(Int32)));
			dt.Columns.Add(new DataColumn("ImageType", typeof(string)));
			dt.Columns.Add(new DataColumn("Type", typeof(string)));
			dt.Columns.Add(new DataColumn("Date", typeof(string)));
			dt.Columns.Add(new DataColumn("Time", typeof(string)));
			dt.Columns.Add(new DataColumn("Source", typeof(string)));
			dt.Columns.Add(new DataColumn("Event", typeof(string)));
			dt.Columns.Add(new DataColumn("Computer", typeof(string)));
			dt.Columns.Add(new DataColumn("Title", typeof(string)));
			dt.Columns.Add(new DataColumn("DateTime", typeof(DateTime)));
			dt.Columns.Add(new DataColumn("Occurrence", typeof(Int32)));

		

			SqlConnection _EventCnt =null;
			try
			{
				_EventCnt= new SqlConnection(myConnString);
				_EventCnt.Open();


				SqlCommand myCommand = new SqlCommand(Query, _EventCnt);
				myCommand.CommandType = CommandType.Text;
				SqlDataReader myReader = myCommand.ExecuteReader();
				while(myReader.Read()) 
				{
					dr = dt.NewRow();
					dr[0] = myReader.GetInt32(0);
					string tmp =myReader.GetString(1);
					dr[1] = FormatURL(tmp);
					dr[2] = FormatText(tmp);
					dr[3] = myReader.GetDateTime(2).ToShortDateString();
					dr[4] = myReader.GetDateTime(2).ToShortTimeString();
					dr[5] = myReader.GetString(3);
					dr[6] = myReader.GetInt32(4);
					dr[7] = myReader.GetString(5);
					dr[8] = "0x"+myReader.GetInt32(6).ToString("x"); // title
					dr[9] =myReader.GetDateTime(2);
					if(!myReader.GetSqlInt32(7).IsNull)
						dr[10] =myReader.GetInt32(7);
					else
						dr[10] =0;
 
					dt.Rows.Add(dr);
				}
				myReader.Close();


			}
			finally
			{
				if(_EventCnt!=null)
				{
					_EventCnt.Close();
					_EventCnt=null;
				}

			}
 
			return( new DataView(dt));

		}

		static public string FormatText(string type)
		{
			//<%#  DataBinder.Eval(Container.DataItem, "ImageType") %>
			string lower = type.ToLower().Trim();
			string retval = null;
			if(lower == "e")
				retval= "Error";
			else if (lower == "w")
				retval = "Warning";
			else
				retval ="Info";
		
			return retval;
		}

		static public string FormatURL(string type)
		{
			//<%#  DataBinder.Eval(Container.DataItem, "ImageType") %>
			string lower = type.ToLower().Trim();
			string retval = null;
			if(lower == "e")
				retval= "error.gif";
			else if (lower == "w")
				retval = "warning.gif";
			else
				retval ="info.gif";
			
			return retval;
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\FixSubmissions\FixMarch05ForM2\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\findbadlf\findbadlf.cpp ===
////////////////////////////////////////////////////////////////////////////////////////////////////////
// 
// File: findbadlf.cpp
//
// Description:
//    Defines the entry point for the console application.
//
// Copyright (c) Microsoft Corporation.  All rights reserved
//
// History:
// 08/16/2002  masonb    Created
//

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif // WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>
#include <assert.h>


// Function forward declarations ///////////////////////////////////////////////////////////////////////
HRESULT ProcessFolder( LPCTSTR pszParentPath, LPCTSTR pszFolder, BOOL fTestOnly, BOOL fSubdirectories );
HRESULT ProcessFile( LPCTSTR pszFolderPath, LPCTSTR pszFileName, BOOL fTestOnly );
BOOL IsRecognizedExtension( LPCTSTR pszExtension );

// Global variables ////////////////////////////////////////////////////////////////////////////////////
DWORD g_dwLargestFileSize = 0;
LPSTR g_pszFileBuffer = NULL;
DWORD g_dwFileBufferSize = 0x400000; // 4MB buffer by default

LPCTSTR g_rgszFileExtensions[ 64 ] = 
{ 
    _T( "cpp" ), 
    _T( "cxx" ),
    _T( "c" ),
    _T( "cs" ),
    _T( "h" ),
    _T( "hxx" ),
    _T( "idl" ),
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
};
#define BUILTIN_EXTENSION_COUNT 7

// Macros //////////////////////////////////////////////////////////////////////////////////////////////
#ifndef _COUNTOF
#define _COUNTOF( x ) ( sizeof( x ) / sizeof( x[ 0 ] ) )
#endif // _COUNTOF

// Constants ///////////////////////////////////////////////////////////////////////////////////////////
const TCHAR c_szUsageText[] = 
    _T( "FindBadLineFeed:\n" )
    _T( "    This application searches the current directory for files that contain\n" )
    _T( "    line breaks without carriage returns.  The C++ compiler and some other\n" )
    _T( "    tools treat these characters as not beginning a new line and can cause\n" )
    _T( "    hard to find source errors.\n" )
    _T( "\n" )
    _T( "    Usage:\n" )
    _T( "        findbadlf.exe [/f] [/m:<size>] [/e:<ext1,ext2,etc>] [/s]\n" )
    _T( "\n" )
    _T( "    Parameters:\n" )
    _T( "        /? - Displays this help text.\n" )
    _T( "        /f - Adds carriage returns to files that do not have them.\n" )
    _T( "        /m - Specifies the size of the buffer used to load files.  The\n" )
    _T( "             default is 4MB.  Files larger than this value will cause\n" )
    _T( "             memory to be dynamically allocated.\n" )
    _T( "        /e - Specifies additional extensions of files that are to be searched.\n" )
    _T( "             The built-in extensions are cpp, cxx, c, cs, h, hxx, and idl.\n" )
    _T( "        /s - Search the current directory and all subdirectories.\n" );

// Function implementations ////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// Function: _tmain
//
// Description:
//     Processes command line arguments and goes through all files and folders
//     from the current folder down looking for source files that contain
//     line feeds that are not immediately followed by carriage returns.  If
//     requested, any bad files found are also fixed.
// 
// Returns:
//     0 - Everything succeeded.
//     -1 - There was an error.
//
int __cdecl _tmain(int argc, TCHAR* argv[])
{
    int iRet = 0;
    TCHAR szCurrentDirectory[ MAX_PATH ];
    BOOL fTestOnly = TRUE;
    BOOL fSubdirectories = FALSE;
    HRESULT hr;
    int iArg;

    // Make sure the extension array and count stay in sync
    assert( g_rgszFileExtensions[ BUILTIN_EXTENSION_COUNT ] == NULL &&
            g_rgszFileExtensions[ BUILTIN_EXTENSION_COUNT - 1 ] != NULL );

    if( 0 == GetCurrentDirectory( _COUNTOF( szCurrentDirectory ), szCurrentDirectory ) )
    {
        _tprintf( _T( "ERROR: Couldn't get current directory\n" ) );
        iRet = -1;
        goto Done;
    }
    szCurrentDirectory[ _COUNTOF( szCurrentDirectory ) - 1 ] = _T( '\0' );

    // Parse the command line arguments
    for( iArg = 0; iArg < argc; iArg++ )
    {
        if( argv[ iArg ][ 0 ] == _T( '-' ) ||
            argv[ iArg ][ 0 ] == _T( '/' )
            )
        {
            switch( argv[ iArg ][ 1 ] )
            {
            case _T( '?' ):
                // Display help text
                _putts( c_szUsageText );
                goto Done;
            case _T( 'f' ):
                // Fix problems found
                fTestOnly = FALSE;
                break;
            case _T( 'm' ):
                // Override memory buffer size
                if( _T( ':' ) != argv[ iArg ][ 2 ] )
                {
                    _tprintf( _T( "ERROR: No ':' found after /m\n\n" ) );
                    _putts( c_szUsageText );
                    iRet = -1;
                    goto Done;
                }
                g_dwFileBufferSize = _ttoi( &argv[ iArg ][ 3 ] );
                break;
            case _T( 'e' ):
                {
                    // Check additional file extensions
                    if( _T( ':' ) != argv[ iArg ][ 2 ] )
                    {
                        _tprintf( _T( "ERROR: No ':' found after /e\n\n" ) );
                        _putts( c_szUsageText );
                        iRet = -1;
                        goto Done;
                    }

                    DWORD dwExtCount = 0;
                    LPTSTR pszExt = _tcstok( &argv[ iArg ][ 3 ], _T( " ," ) );
                    // Leave room at the end of the array to always have a NULL
                    while( NULL != pszExt && dwExtCount < ( _COUNTOF( g_rgszFileExtensions ) - BUILTIN_EXTENSION_COUNT - 1) )
                    {
                        g_rgszFileExtensions[ BUILTIN_EXTENSION_COUNT + dwExtCount ] = pszExt;
                        dwExtCount++;
                        pszExt = _tcstok( NULL, _T( " ," ) );
                    }
                }
                break;
            case _T( 's' ):
                // Search subdirectories
                fSubdirectories = TRUE;
                break;
            default:
                // Unknown extension
                _tprintf( _T( "ERROR: Unrecognized command line option: %s\n\n" ), argv[ iArg ] );
                _putts( c_szUsageText );
                iRet = -1;
                goto Done;
            }
        }
    }

    // Create the buffer used to load files into.  We first try to use this buffer and dynamically 
    // allocate a buffer if the file is too big.
    g_pszFileBuffer = (LPSTR)malloc( g_dwFileBufferSize );
    if( NULL == g_pszFileBuffer )
    {
        _tprintf( _T( "ERROR: Failed allocating file buffer\n" ) );
        iRet = -1;
        goto Done;
    }

    if( fTestOnly )
    {
        _tprintf( _T( "Checking files only...\n" ) );
    }
    else
    {
        _tprintf( _T( "Checking and fixing files...\n" ) );
    }

    _tprintf( _T( "\n    Bad Files:\n    ----------\n\n" ) );

    // Start processing at the root folder.  This will search recursively if fSubdirectories is TRUE.
    hr = ProcessFolder( szCurrentDirectory, _T( "" ), fTestOnly, fSubdirectories );
    if( FAILED( hr ) )
    {
        _tprintf( _T( "ERROR: Failed processing current folder: %s\n" ), szCurrentDirectory );
        iRet = -1;
        goto Done;
    }
    if( S_FALSE == hr )
    {
        _tprintf( _T( "    No bad files found\n" ) );
    }

    _tprintf( _T( "\nLargest file was %d bytes\n" ), g_dwLargestFileSize );

Done:
    if( NULL != g_pszFileBuffer )
    {
        free( g_pszFileBuffer );
        g_pszFileBuffer = NULL;
    }

	return 0;
}


/////////////////////////////////////////////////////////////////////////////
//
// Function: ProcessFolder
//
// Description:
//     Enumerates all of a folder's sub-folders and files.  If fSubdirectories
//     is TRUE a recursive call is made to this function for all sub-folders.
//     ProcessFile is called on each file found.
// 
// Returns:
//     S_OK - Everything succeeded and a replacement was made if requested.
//     S_FALSE - Everything succeeded and there was nothing to replace.
//     E_FAIL - There was an error.
//
HRESULT ProcessFolder( LPCTSTR pszParentPath, LPCTSTR pszFolder, BOOL fTestOnly, BOOL fSubdirectories )
{
    HRESULT hr = S_FALSE;
    WIN32_FIND_DATA FileData; 
    HANDLE hSearch = INVALID_HANDLE_VALUE;    
    TCHAR szSearchPath[ MAX_PATH ] = { 0 }; 
    BOOL fFoundBadFile = FALSE;

    // Build up the path to search
    if( NULL != pszParentPath )
    {
        if( 0 > _sntprintf( szSearchPath, _COUNTOF( szSearchPath ) - 1, _T( "%s\\" ), pszParentPath ) )
        {
            hr = E_FAIL;
            goto Done;
        }
        szSearchPath[ _COUNTOF( szSearchPath ) - 1 ] = _T( '\0' );
    }
    if( NULL != pszFolder && 0 != _tcslen( pszFolder ) )
    {
        if( 0 > _sntprintf( szSearchPath, _COUNTOF( szSearchPath ) - 1, _T( "%s%s\\*" ), szSearchPath, pszFolder ) )
        {
            hr = E_FAIL;
            goto Done;
        }
        szSearchPath[ _COUNTOF( szSearchPath ) - 1 ] = _T( '\0' );
    }
    else
    {
        if( 0 > _sntprintf( szSearchPath, _COUNTOF( szSearchPath ) - 1, _T( "%s*" ), szSearchPath ) )
        {
            hr = E_FAIL;
            goto Done;
        }
        szSearchPath[ _COUNTOF( szSearchPath ) - 1 ] = _T( '\0' );
    }

    // Kick off the search
    hSearch = FindFirstFile( szSearchPath, &FileData );
    if( hSearch == INVALID_HANDLE_VALUE )
    {
        // For this to happen the directory has to not exist which could occur if it was deleted
        // while we are running.  For now that case is treated as a failure.
        _tprintf( _T( "Error: Unable to find first file\n" ) );
        return E_FAIL;
    }

    // Take the '\*' off so that we can re-use the path below
    szSearchPath[ _tcslen( szSearchPath ) - 1 ] = _T( '\0' );
    szSearchPath[ _tcslen( szSearchPath ) - 1 ] = _T( '\0' );

    while( TRUE )
    {
        // See if we have found a directory or a file
        if( FileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
        {
            // If we have been told to search subdirectories then do so recursively
            if( fSubdirectories &&
                0 != _tcsicmp( _T( "." ), FileData.cFileName ) &&
                0 != _tcsicmp( _T( ".." ), FileData.cFileName ) )
            {
                // Look at any subdirectories of this directory
                hr = ProcessFolder( szSearchPath, FileData.cFileName, fTestOnly, fSubdirectories );
                if( FAILED( hr ) )
                {
                    _tprintf( _T( "Error: Failed finding subdirectories of '%s'\n" ), FileData.cFileName );
                    break;
                }
                if( S_OK == hr )
                {
                    // Keep track of whether or not we have yet seen a bad file
                    fFoundBadFile = TRUE;
                }
            }
        }
        else
        {
            // We have found a file, see if it needs fixing
            hr = ProcessFile( szSearchPath, FileData.cFileName, fTestOnly );
            if( FAILED( hr ) )
            {
                _tprintf( _T( "Error: Failed processing file '%s\\%s'\n" ), szSearchPath, FileData.cFileName );
                break;
            }
            if( S_OK == hr )
            {
                // Inform the user that this file has a line break with no carriage return
                _tprintf( _T( "    %s\\%s\n" ), szSearchPath, FileData.cFileName );

                // Keep track of whether or not we have yet seen a bad file
                fFoundBadFile = TRUE;
            }
        }

        // Get the next file in the search
        if( !FindNextFile( hSearch, &FileData ) )
        {
            if( ERROR_NO_MORE_FILES != GetLastError() )
            {
                _tprintf( _T( "Error: Unable to find next file\n" ) );
                hr = E_FAIL;
            }

            break;
        }
    }

Done:
    // Close the search handle.
    if( INVALID_HANDLE_VALUE != hSearch )
    {
        FindClose( hSearch );
    }

    if( SUCCEEDED( hr ) )
    {
        hr = fFoundBadFile ? S_OK : S_FALSE;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// Function: IsRecognizedExtension
//
// Description:
//     Looks at a given file extension to see if it is one which we are 
//     interested in performing an action on.  There are built-in file 
//     extensions and additional ones can be specified on the command line.
// 
// Returns:
//     TRUE - This is a recognized file extension
//     FALSE - This is NOT a recognized file extension
//
BOOL IsRecognizedExtension( LPCTSTR pszExtension )
{
    if( NULL == pszExtension || pszExtension[ 0 ] != _T( '.' ) )
    {
        return FALSE;
    }

    // Go through our array of extensions and see if this matches any of them
    LPCTSTR* ppszCompareExt = g_rgszFileExtensions;
    while( NULL != *ppszCompareExt )
    {
        // Skip the '.' in the passed in extension
        if( 0 == _tcsicmp( &pszExtension[ 1 ], *ppszCompareExt ) )
        {
            return TRUE;
        }

        ppszCompareExt++;
    }

    return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
//
// Function: ProcessFile
//
// Description:
//     Looks at a given file to see if it contains line feeds that are not
//     followed by carriage returns.  If the fTestOnly parameter is FALSE
//     then also fix bad files by adding a carriage return after the line
//     feed.  Source files should always be ANSI so the contents are 
//     processed as ANSI.
// 
// Returns:
//     S_OK - Everything succeeded and a replacement was made if requested.
//     S_FALSE - Everything succeeded and there was nothing to replace.
//     E_FAIL - There was an error.
//
HRESULT ProcessFile( LPCTSTR pszFolderPath, LPCTSTR pszFileName, BOOL fTestOnly )
{
    HRESULT hr = S_FALSE;
    TCHAR szFullPath[ MAX_PATH ];
    HANDLE hFileRead = INVALID_HANDLE_VALUE;
    HANDLE hFileWrite = INVALID_HANDLE_VALUE;
    LPCSTR pszFile = NULL;
    LPSTR pszNewFile;
    DWORD dwCharsAdded = 0;
    BOOL fUsingFileBuffer = FALSE;

    // Get a pointer to the extension
    LPCTSTR pszExtension = _tcsrchr( pszFileName, _T( '.' ) );
    if( IsRecognizedExtension( pszExtension ) )
    {
        if( 0 > _sntprintf( szFullPath, MAX_PATH - 1, _T( "%s\\%s" ), pszFolderPath, pszFileName ) )
        {
            hr = E_FAIL;
            goto Done;
        }
        szFullPath[ MAX_PATH - 1 ] = _T( '\0' );

        // We only need read access if we are in test-only mode
        hFileRead = CreateFile( szFullPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
        if( INVALID_HANDLE_VALUE == hFileRead )
        {
            // The file may have just been deleted
            hr = E_FAIL;
            goto Done;
        }

        DWORD dwTemp;
        DWORD dwFileSize = GetFileSize( hFileRead, &dwTemp );
        if( 0 == dwFileSize )
        {
            // File is zero length, nothing to do
            goto Done;
        }

        if( dwFileSize > g_dwLargestFileSize )
        {
            g_dwLargestFileSize = dwFileSize;
        }

        // NOTE: Here I am allocating enough room for the file, as well as enough room for twice as
        // much after it.  Assuming the file was just full of \r, when I change it to \r\n I would
        // need twice as much room.
        if( dwFileSize * 3 > g_dwFileBufferSize )
        {
            pszFile = (LPSTR)malloc( dwFileSize * 3 );
        }
        else
        {
            fUsingFileBuffer = TRUE;
            pszFile = g_pszFileBuffer;
        }
        if( NULL == pszFile )
        {
            hr = E_FAIL;
            goto Done;
        }

        pszNewFile = (LPSTR)pszFile + dwFileSize;

        if( !ReadFile( hFileRead, (BYTE*)pszFile, dwFileSize, &dwTemp, NULL ) )
        {
            hr = E_FAIL;
            goto Done;
        }

        // Handle Unicode files
        if( dwFileSize >= 2 && (BYTE)pszFile[ 0 ] == 0xFF && (BYTE)pszFile[ 1 ] == 0xFE )
        {
            _tprintf( _T( "    Skipping Unicode file: %s\n" ), szFullPath );

            // Non-fatal error
            goto Done;
        }

        for( DWORD iLoc = 0; iLoc < dwFileSize; iLoc++ )
        {
            // Copy this character to the new file
            pszNewFile[ iLoc + dwCharsAdded ] = pszFile[ iLoc ];

            // If either we have a \r without a following \n or a \r at the end of
            // the file, we need to add a \n.
            if( pszFile[ iLoc ] == '\r' && 
                ( iLoc == dwFileSize - 1 ||
                  pszFile[ iLoc + 1 ] != '\n' ) )
            {
                // Add a \n to the new file
                dwCharsAdded++;
                pszNewFile[ iLoc + dwCharsAdded ] = '\n';

                if( fTestOnly )
                {
                    // For the test-only case it is sufficient that we found something
                    hr = S_OK;
                    goto Done;
                }
            }
        }

        // If nothing changed we don't need to write the file
        if( 0 != dwCharsAdded )
        {
            // Close the readable version so that we can open a writable one.  We wait until now
            // to open the writable copy because otherwise we couldn't go through read-only files
            // in the code above.
            CloseHandle( hFileRead );
            hFileRead = INVALID_HANDLE_VALUE;

            hFileWrite = CreateFile( szFullPath, GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
            if( INVALID_HANDLE_VALUE == hFileWrite )
            {
                _tprintf( _T( "ERROR: File '%s' could not be opened for writing\n" ), szFullPath );

                // The file is probably read-only, this is a non-fatal failure
            }
            else
            {
                // Write out the changes
                if( !WriteFile( hFileWrite, pszNewFile, dwFileSize + dwCharsAdded, &dwTemp, NULL ) )
                {
                    hr = E_FAIL;
                    goto Done;
                }

                // Set a new end of file marker
                if( !SetEndOfFile( hFileWrite ) )
                {
                    hr = E_FAIL;
                    goto Done;
                }
            }

            // hr should no longer be S_FALSE, because we replaced something
            hr = S_OK;
        }
    }

Done:
    if( INVALID_HANDLE_VALUE != hFileRead )
    {
        CloseHandle( hFileRead );
    }
    if( INVALID_HANDLE_VALUE != hFileWrite )
    {
        CloseHandle( hFileWrite );
    }
    if( NULL != pszFile && !fUsingFileBuffer )
    {
        free( (LPSTR)pszFile );
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\EventWeb\Global.asax.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Web;
using System.Web.SessionState;

namespace Events 
{
	/// <summary>
	/// Summary description for Global.
	/// </summary>
	public class Global : System.Web.HttpApplication
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		public Global()
		{
			InitializeComponent();
		}	
		
		protected void Application_Start(Object sender, EventArgs e)
		{

		}
 
		protected void Session_Start(Object sender, EventArgs e)
		{

		}

		protected void Application_BeginRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_EndRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_AuthenticateRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_Error(Object sender, EventArgs e)
		{

		}

		protected void Session_End(Object sender, EventArgs e)
		{

		}

		protected void Application_End(Object sender, EventArgs e)
		{

		}
			
		#region Web Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.components = new System.ComponentModel.Container();
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\FixSubmissions\FixMarch05ForM2\test\dvt\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\dll\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\FixSubmissions\FixMarch05ForM2\App.cs ===
using System;
using System.IO;
using System.Xml;

namespace xonline.tools.FixSubmissions.FixMarch05ForM2
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	public class FixMarch05ForM2App
	{
        private static void Usage()
        {
            Console.WriteLine("\r\nUsage:\r\n\r\n\r\n\tFixMarch05ForM2 <input file> <output file>\r\n\r\n");
        }

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		public static void Main(string[] args)
		{
            if(args.Length != 2)
            {
                Usage();
                return;
            }

            try
            {
                XmlDocument doc = new XmlDocument();

                if(!File.Exists(args[0]))
                    throw new FileNotFoundException("Missing input file.", args[0]);

                doc.Load(args[0]);

                int contextsFound = -1;
                int contextsFixed = -1;
                bool foundMatchInfo = false;

                FixMarch05ForM2.DoFix(doc, ref contextsFound, ref contextsFixed, ref foundMatchInfo);

                doc.Save(args[1]);

                Console.WriteLine("\r\nContexts found: {0}\r\nContexts fixed: {1}", contextsFound, contextsFixed);

                if(foundMatchInfo)
                {
                    Console.WriteLine("\r\n\r\nThis file contains matchmaking information which must be propped by hand.  Send this file to phansen.");
                }
            }
            catch(Exception e)
            {
                Console.WriteLine(e.Message);
            }
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\dll\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\findtabs\findtabs.cpp ===
////////////////////////////////////////////////////////////////////////////////////////////////////////
// 
// File: findtabs.cpp
//
// Description:
//    Defines the entry point for the console application.
//
// Copyright (c) Microsoft Corporation.  All rights reserved
//
// History:
// 08/16/2002  masonb    Created
//

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif // WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>
#include <assert.h>


// Function forward declarations ///////////////////////////////////////////////////////////////////////
HRESULT ProcessFolder( LPCTSTR pszParentPath, LPCTSTR pszFolder, BOOL fTestOnly, BOOL fSubdirectories );
HRESULT ProcessFile( LPCTSTR pszFolderPath, LPCTSTR pszFileName, BOOL fTestOnly );
BOOL IsRecognizedExtension( LPCTSTR pszExtension );

// Global variables ////////////////////////////////////////////////////////////////////////////////////
DWORD g_dwLargestFileSize = 0;
LPSTR g_pszFileBuffer = NULL;
DWORD g_dwFileBufferSize = 0x400000; // 4MB buffer by default

LPCTSTR g_rgszFileExtensions[ 64 ] = 
{ 
    _T( "cpp" ), 
    _T( "cxx" ),
    _T( "c" ),
    _T( "cs" ),
    _T( "h" ),
    _T( "hxx" ),
    _T( "idl" ),
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
};
#define BUILTIN_EXTENSION_COUNT 7

// Macros //////////////////////////////////////////////////////////////////////////////////////////////
#ifndef _COUNTOF
#define _COUNTOF( x ) ( sizeof( x ) / sizeof( x[ 0 ] ) )
#endif // _COUNTOF

// Constants ///////////////////////////////////////////////////////////////////////////////////////////
const TCHAR c_szUsageText[] = 
    _T( "FindTabs:\n" )
    _T( "    This application searches the current directory for files that contain\n" )
    _T( "    tabs and optionally replaces them with 4 spaces.\n" )
    _T( "\n" )
    _T( "    Usage:\n" )
    _T( "        findtabs.exe [/f] [/m:<size>] [/e:<ext1,ext2,etc>] [/s]\n" )
    _T( "\n" )
    _T( "    Parameters:\n" )
    _T( "        /? - Displays this help text.\n" )
    _T( "        /f - Replaces tabs with 4 spaces.\n" )
    _T( "        /m - Specifies the size of the buffer used to load files.  The\n" )
    _T( "             default is 4MB.  Files larger than this value will cause\n" )
    _T( "             memory to be dynamically allocated.\n" )
    _T( "        /e - Specifies additional extensions of files that are to be searched.\n" )
    _T( "             The built-in extensions are cpp, cxx, c, cs, h, hxx, and idl.\n" )
    _T( "        /s - Search the current directory and all subdirectories.\n" );

// Function implementations ////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// Function: _tmain
//
// Description:
//     Processes command line arguments and goes through all files and folders
//     from the current folder down looking for source files that contain
//     tabs.  If requested, tabs are replaced by 4 spaces.
// 
// Returns:
//     0 - Everything succeeded.
//     -1 - There was an error.
//
int __cdecl _tmain(int argc, TCHAR* argv[])
{
    int iRet = 0;
    TCHAR szCurrentDirectory[ MAX_PATH ];
    BOOL fTestOnly = TRUE;
    BOOL fSubdirectories = FALSE;
    HRESULT hr;
    int iArg;

    // Make sure the extension array and count stay in sync
    assert( g_rgszFileExtensions[ BUILTIN_EXTENSION_COUNT ] == NULL &&
            g_rgszFileExtensions[ BUILTIN_EXTENSION_COUNT - 1 ] != NULL );

    if( 0 == GetCurrentDirectory( _COUNTOF( szCurrentDirectory ), szCurrentDirectory ) )
    {
        _tprintf( _T( "ERROR: Couldn't get current directory\n" ) );
        iRet = -1;
        goto Done;
    }
    szCurrentDirectory[ _COUNTOF( szCurrentDirectory ) - 1 ] = _T( '\0' );

    // Parse the command line arguments
    for( iArg = 0; iArg < argc; iArg++ )
    {
        if( argv[ iArg ][ 0 ] == _T( '-' ) ||
            argv[ iArg ][ 0 ] == _T( '/' )
            )
        {
            switch( argv[ iArg ][ 1 ] )
            {
            case _T( '?' ):
                // Display help text
                _putts( c_szUsageText );
                goto Done;
            case _T( 'f' ):
                // Fix problems found
                fTestOnly = FALSE;
                break;
            case _T( 'm' ):
                // Override memory buffer size
                if( _T( ':' ) != argv[ iArg ][ 2 ] )
                {
                    _tprintf( _T( "ERROR: No ':' found after /m\n\n" ) );
                    _putts( c_szUsageText );
                    iRet = -1;
                    goto Done;
                }
                g_dwFileBufferSize = _ttoi( &argv[ iArg ][ 3 ] );
                break;
            case _T( 'e' ):
                {
                    // Check additional file extensions
                    if( _T( ':' ) != argv[ iArg ][ 2 ] )
                    {
                        _tprintf( _T( "ERROR: No ':' found after /e\n\n" ) );
                        _putts( c_szUsageText );
                        iRet = -1;
                        goto Done;
                    }

                    DWORD dwExtCount = 0;
                    LPTSTR pszExt = _tcstok( &argv[ iArg ][ 3 ], _T( " ," ) );
                    // Leave room at the end of the array to always have a NULL
                    while( NULL != pszExt && dwExtCount < ( _COUNTOF( g_rgszFileExtensions ) - BUILTIN_EXTENSION_COUNT - 1) )
                    {
                        g_rgszFileExtensions[ BUILTIN_EXTENSION_COUNT + dwExtCount ] = pszExt;
                        dwExtCount++;
                        pszExt = _tcstok( NULL, _T( " ," ) );
                    }
                }
                break;
            case _T( 's' ):
                // Search subdirectories
                fSubdirectories = TRUE;
                break;
            default:
                // Unknown extension
                _tprintf( _T( "ERROR: Unrecognized command line option: %s\n\n" ), argv[ iArg ] );
                _putts( c_szUsageText );
                iRet = -1;
                goto Done;
            }
        }
    }

    // Create the buffer used to load files into.  We first try to use this buffer and dynamically 
    // allocate a buffer if the file is too big.
    g_pszFileBuffer = (LPSTR)malloc( g_dwFileBufferSize );
    if( NULL == g_pszFileBuffer )
    {
        _tprintf( _T( "ERROR: Failed allocating file buffer\n" ) );
        iRet = -1;
        goto Done;
    }

    if( fTestOnly )
    {
        _tprintf( _T( "Checking files only...\n" ) );
    }
    else
    {
        _tprintf( _T( "Checking and fixing files...\n" ) );
    }

    _tprintf( _T( "\n    Bad Files:\n    ----------\n\n" ) );

    // Start processing at the root folder.  This will search recursively if fSubdirectories is TRUE.
    hr = ProcessFolder( szCurrentDirectory, _T( "" ), fTestOnly, fSubdirectories );
    if( FAILED( hr ) )
    {
        _tprintf( _T( "ERROR: Failed processing current folder: %s\n" ), szCurrentDirectory );
        iRet = -1;
        goto Done;
    }
    if( S_FALSE == hr )
    {
        _tprintf( _T( "    No bad files found\n" ) );
    }

    _tprintf( _T( "\nLargest file was %d bytes\n" ), g_dwLargestFileSize );

Done:
    if( NULL != g_pszFileBuffer )
    {
        free( g_pszFileBuffer );
        g_pszFileBuffer = NULL;
    }

	return 0;
}


/////////////////////////////////////////////////////////////////////////////
//
// Function: ProcessFolder
//
// Description:
//     Enumerates all of a folder's sub-folders and files.  If fSubdirectories
//     is TRUE a recursive call is made to this function for all sub-folders.
//     ProcessFile is called on each file found.
// 
// Returns:
//     S_OK - Everything succeeded and a replacement was made if requested.
//     S_FALSE - Everything succeeded and there was nothing to replace.
//     E_FAIL - There was an error.
//
HRESULT ProcessFolder( LPCTSTR pszParentPath, LPCTSTR pszFolder, BOOL fTestOnly, BOOL fSubdirectories )
{
    HRESULT hr = S_FALSE;
    WIN32_FIND_DATA FileData; 
    HANDLE hSearch = INVALID_HANDLE_VALUE;    
    TCHAR szSearchPath[ MAX_PATH ] = { 0 }; 
    BOOL fFoundBadFile = FALSE;

    // Build up the path to search
    if( NULL != pszParentPath )
    {
        if( 0 > _sntprintf( szSearchPath, _COUNTOF( szSearchPath ) - 1, _T( "%s\\" ), pszParentPath ) )
        {
            hr = E_FAIL;
            goto Done;
        }
        szSearchPath[ _COUNTOF( szSearchPath ) - 1 ] = _T( '\0' );
    }
    if( NULL != pszFolder && 0 != _tcslen( pszFolder ) )
    {
        if( 0 > _sntprintf( szSearchPath, _COUNTOF( szSearchPath ) - 1, _T( "%s%s\\*" ), szSearchPath, pszFolder ) )
        {
            hr = E_FAIL;
            goto Done;
        }
        szSearchPath[ _COUNTOF( szSearchPath ) - 1 ] = _T( '\0' );
    }
    else
    {
        if( 0 > _sntprintf( szSearchPath, _COUNTOF( szSearchPath ) - 1, _T( "%s*" ), szSearchPath ) )
        {
            hr = E_FAIL;
            goto Done;
        }
        szSearchPath[ _COUNTOF( szSearchPath ) - 1 ] = _T( '\0' );
    }

    // Kick off the search
    hSearch = FindFirstFile( szSearchPath, &FileData );
    if( hSearch == INVALID_HANDLE_VALUE )
    {
        // For this to happen the directory has to not exist which could occur if it was deleted
        // while we are running.  For now that case is treated as a failure.
        _tprintf( _T( "Error: Unable to find first file\n" ) );
        return E_FAIL;
    }

    // Take the '\*' off so that we can re-use the path below
    szSearchPath[ _tcslen( szSearchPath ) - 1 ] = _T( '\0' );
    szSearchPath[ _tcslen( szSearchPath ) - 1 ] = _T( '\0' );

    while( TRUE )
    {
        // See if we have found a directory or a file
        if( FileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
        {
            // If we have been told to search subdirectories then do so recursively
            if( fSubdirectories &&
                0 != _tcsicmp( _T( "." ), FileData.cFileName ) &&
                0 != _tcsicmp( _T( ".." ), FileData.cFileName ) )
            {
                // Look at any subdirectories of this directory
                hr = ProcessFolder( szSearchPath, FileData.cFileName, fTestOnly, fSubdirectories );
                if( FAILED( hr ) )
                {
                    _tprintf( _T( "Error: Failed finding subdirectories of '%s'\n" ), FileData.cFileName );
                    break;
                }
                if( S_OK == hr )
                {
                    // Keep track of whether or not we have yet seen a bad file
                    fFoundBadFile = TRUE;
                }
            }
        }
        else
        {
            // We have found a file, see if it needs fixing
            hr = ProcessFile( szSearchPath, FileData.cFileName, fTestOnly );
            if( FAILED( hr ) )
            {
                _tprintf( _T( "Error: Failed processing file '%s\\%s'\n" ), szSearchPath, FileData.cFileName );
                break;
            }
            if( S_OK == hr )
            {
                // Inform the user that this file has a line break with no carriage return
                _tprintf( _T( "    %s\\%s\n" ), szSearchPath, FileData.cFileName );

                // Keep track of whether or not we have yet seen a bad file
                fFoundBadFile = TRUE;
            }
        }

        // Get the next file in the search
        if( !FindNextFile( hSearch, &FileData ) )
        {
            if( ERROR_NO_MORE_FILES != GetLastError() )
            {
                _tprintf( _T( "Error: Unable to find next file\n" ) );
                hr = E_FAIL;
            }

            break;
        }
    }

Done:
    // Close the search handle.
    if( INVALID_HANDLE_VALUE != hSearch )
    {
        FindClose( hSearch );
    }

    if( SUCCEEDED( hr ) )
    {
        hr = fFoundBadFile ? S_OK : S_FALSE;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// Function: IsRecognizedExtension
//
// Description:
//     Looks at a given file extension to see if it is one which we are 
//     interested in performing an action on.  There are built-in file 
//     extensions and additional ones can be specified on the command line.
// 
// Returns:
//     TRUE - This is a recognized file extension
//     FALSE - This is NOT a recognized file extension
//
BOOL IsRecognizedExtension( LPCTSTR pszExtension )
{
    if( NULL == pszExtension || pszExtension[ 0 ] != _T( '.' ) )
    {
        return FALSE;
    }

    // Go through our array of extensions and see if this matches any of them
    LPCTSTR* ppszCompareExt = g_rgszFileExtensions;
    while( NULL != *ppszCompareExt )
    {
        // Skip the '.' in the passed in extension
        if( 0 == _tcsicmp( &pszExtension[ 1 ], *ppszCompareExt ) )
        {
            return TRUE;
        }

        ppszCompareExt++;
    }

    return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
//
// Function: ProcessFile
//
// Description:
//     Looks at a given file to see if it contains tabs.  If the fTestOnly 
//     parameter is FALSE then tabs will be replaced with four spaces.  
//     Source files should always be ANSI so the contents are processed as 
//     ANSI.
// 
// Returns:
//     S_OK - Everything succeeded and a replacement was made if requested.
//     S_FALSE - Everything succeeded and there was nothing to replace.
//     E_FAIL - There was an error.
//
HRESULT ProcessFile( LPCTSTR pszFolderPath, LPCTSTR pszFileName, BOOL fTestOnly )
{
    HRESULT hr = S_FALSE;
    TCHAR szFullPath[ MAX_PATH ];
    HANDLE hFileRead = INVALID_HANDLE_VALUE;
    HANDLE hFileWrite = INVALID_HANDLE_VALUE;
    LPCSTR pszFile = NULL;
    LPSTR pszNewFile;
    DWORD dwCharsAdded = 0;
    BOOL fUsingFileBuffer = FALSE;

    // Get a pointer to the extension
    LPCTSTR pszExtension = _tcsrchr( pszFileName, _T( '.' ) );
    if( IsRecognizedExtension( pszExtension ) )
    {
        if( 0 > _sntprintf( szFullPath, MAX_PATH - 1, _T( "%s\\%s" ), pszFolderPath, pszFileName ) )
        {
            hr = E_FAIL;
            goto Done;
        }
        szFullPath[ MAX_PATH - 1 ] = _T( '\0' );

        // We only need read access if we are in test-only mode
        hFileRead = CreateFile( szFullPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
        if( INVALID_HANDLE_VALUE == hFileRead )
        {
            // The file may have just been deleted
            hr = E_FAIL;
            goto Done;
        }

        DWORD dwTemp;
        DWORD dwFileSize = GetFileSize( hFileRead, &dwTemp );
        if( 0 == dwFileSize )
        {
            // File is zero length, nothing to do
            goto Done;
        }

        if( dwFileSize > g_dwLargestFileSize )
        {
            g_dwLargestFileSize = dwFileSize;
        }

        // NOTE: Here I am allocating enough room for the file, as well as enough room for four times as
        // much after it.  Assuming the file was just full of \t, when I change it to 4 spaces I would
        // need four times as much room.
        if( dwFileSize * 5 > g_dwFileBufferSize )
        {
            pszFile = (LPSTR)malloc( dwFileSize * 3 );
        }
        else
        {
            fUsingFileBuffer = TRUE;
            pszFile = g_pszFileBuffer;
        }
        if( NULL == pszFile )
        {
            hr = E_FAIL;
            goto Done;
        }

        pszNewFile = (LPSTR)pszFile + dwFileSize;

        if( !ReadFile( hFileRead, (BYTE*)pszFile, dwFileSize, &dwTemp, NULL ) )
        {
            hr = E_FAIL;
            goto Done;
        }

        // Handle Unicode files
        if( dwFileSize >= 2 && (BYTE)pszFile[ 0 ] == 0xFF && (BYTE)pszFile[ 1 ] == 0xFE )
        {
            _tprintf( _T( "    Skipping Unicode file: %s\n" ), szFullPath );

            // Non-fatal error
            goto Done;
        }

        for( DWORD iLoc = 0; iLoc < dwFileSize; iLoc++ )
        {
            // Copy this character to the new file
            pszNewFile[ iLoc + dwCharsAdded ] = pszFile[ iLoc ];

            if( pszFile[ iLoc ] == '\t' )
            {
                // Add spaces to the new file
                memset( &pszNewFile[ iLoc + dwCharsAdded ], ' ', 4 );
                dwCharsAdded += 3;

                if( fTestOnly )
                {
                    // For the test-only case it is sufficient that we found something
                    hr = S_OK;
                    goto Done;
                }
            }
        }

        // If nothing changed we don't need to write the file
        if( 0 != dwCharsAdded )
        {
            // Close the readable version so that we can open a writable one.  We wait until now
            // to open the writable copy because otherwise we couldn't go through read-only files
            // in the code above.
            CloseHandle( hFileRead );
            hFileRead = INVALID_HANDLE_VALUE;

            hFileWrite = CreateFile( szFullPath, GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
            if( INVALID_HANDLE_VALUE == hFileWrite )
            {
                _tprintf( _T( "ERROR: File '%s' could not be opened for writing\n" ), szFullPath );

                // The file is probably read-only, this is a non-fatal failure
            }
            else
            {
                // Write out the changes
                if( !WriteFile( hFileWrite, pszNewFile, dwFileSize + dwCharsAdded, &dwTemp, NULL ) )
                {
                    hr = E_FAIL;
                    goto Done;
                }

                // Set a new end of file marker
                if( !SetEndOfFile( hFileWrite ) )
                {
                    hr = E_FAIL;
                    goto Done;
                }
            }

            // hr should no longer be S_FALSE, because we replaced something
            hr = S_OK;
        }
    }

Done:
    if( INVALID_HANDLE_VALUE != hFileRead )
    {
        CloseHandle( hFileRead );
    }
    if( INVALID_HANDLE_VALUE != hFileWrite )
    {
        CloseHandle( hFileWrite );
    }
    if( NULL != pszFile && !fUsingFileBuffer )
    {
        free( (LPSTR)pszFile );
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\dll\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_toolsframework_none_12.4.56.0_none_60a43ba954e0a1ca
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_toolsframework_no-public-key_12.4.56.0_x-ww_ede02a06
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=toolsframework
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_toolsframework_no-public-key_12.4.56.0_x-ww_ede02a06
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_toolsframework_no-public-key_12.4.56.0_x-ww_ede02a06.manifest
XP_MANIFEST_PATH=manifests\msil_toolsframework_no-public-key_12.4.56.0_x-ww_ede02a06.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_toolsframework_no-public-key_12.4.56.0_x-ww_ede02a06.cat
XP_CATALOG_PATH=manifests\msil_toolsframework_no-public-key_12.4.56.0_x-ww_ede02a06.cat
XP_PAYLOAD_PATH=msil_toolsframework_no-public-key_12.4.56.0_x-ww_ede02a06
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=toolsframework,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\dll\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\FixSubmissions\FixMarch05ForM2\test\dvt\FixMarch05ForM2Dvt.cs ===
using System;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Xml;
using xonline.tools.FixSubmissions.FixMarch05ForM2;
using ServerTestFramework;
using ServerTestFramework.Utilities;

namespace xonline.tools.FixSubmissions.FixMarch05ForM2.Dvt
{
    [TestGroup, DVT]
    public class FixMarch05ForM2Dvt  : TestNode
    {
        #region Utility Methods

        private static string AssemblyPath
        {
            get
            {
                Assembly dvtDll = Assembly.GetExecutingAssembly();
                string dllPath = dvtDll.Location;
                dllPath = Path.GetDirectoryName(dllPath);
                return dllPath;
            }
        }

        private static string FixExePath
        {
            get
            {
                return Path.Combine(AssemblyPath, "..\\..\\..\\..\\objd\\i386\\fixmarch05form2.exe");
            }
        }

        private static int RunCommandLine(string file, string args, string workingDir, ref string output)
        {
            if(!File.Exists(file))
                throw new FileNotFoundException("FixMarch05ForM2.exe not found", file);

            Process p = new Process();
            p.StartInfo.WorkingDirectory = workingDir;
            p.StartInfo.FileName = file;
            p.StartInfo.Arguments = args;
            p.StartInfo.CreateNoWindow = true;
            p.StartInfo.UseShellExecute = false;
            p.StartInfo.RedirectStandardOutput = true;
            p.StartInfo.RedirectStandardError = true;
            p.Start();

            output = p.StandardOutput.ReadToEnd();
            output += p.StandardError.ReadToEnd();

            p.WaitForExit();

            return p.ExitCode;
        }

        #endregion

        #region Command Line Tests

        [TestCase]
        public void Pos_CmdLine()
        {
            string inputFilename = Path.Combine(AssemblyPath, "..\\..\\xmlPos_CmdLine.xlast");
            string outputFilename = Path.Combine(AssemblyPath, "..\\..\\xmlPos_CmdLine_Out.xlast");

            string output = "";
            RunCommandLine(FixExePath, inputFilename + " " + outputFilename, AssemblyPath, ref output);

            ValueCheck.Test("Pos_CmdLine", Pos_CmdLine_Expected, output);
        }

        [TestCase]
        public void Neg_FileNotFound()
        {
            string output = "";
            RunCommandLine(FixExePath, "fooblarksky.xlast fooblarsky_out.xlast", AssemblyPath, ref output);

            ValueCheck.Test("Neg_FileNotFound", Neg_FileNotFound_Expected, output);
        }

        [TestCase]
        public void Neg_CantWriteOutput()
        {
            string inputFilename = Path.Combine(AssemblyPath, "..\\..\\xmlPos_CmdLine.xlast");
            string outputFilename = Path.Combine(AssemblyPath, "..\\..\\xmlPos_CmdLine_RO.xlast");

            string output = "";
            RunCommandLine(FixExePath, inputFilename + " " + outputFilename, AssemblyPath, ref output);

            ValueCheck.Test("Neg_BadArgs", Neg_CantWriteOutput_Expected, output);
        }

        [TestCase]
        public void Neg_InvalidOutputLocation()
        {
            string inputFilename = Path.Combine(AssemblyPath, "..\\..\\xmlPos_CmdLine.xlast");
            string outputFilename = Path.Combine(AssemblyPath, "q:\\xmlPos_CmdLine_Out.xlast");

            string output = "";
            RunCommandLine(FixExePath, inputFilename + " " + outputFilename, AssemblyPath, ref output);

            ValueCheck.Test("Neg_BadArgs", Neg_InvalidOutputLocation_Expected, output);
        }

        [TestCase]
        public void Neg_BadArgs()
        {
            string output = "";
            RunCommandLine(FixExePath, "", AssemblyPath, ref output);

            ValueCheck.Test("Neg_BadArgs", Neg_BadArgs_Expected, output);
        }

        #endregion

        #region Positive Tests

        [TestCase]
        public void Pos_1_1()
        {
            int contextsFound = -1;
            int contextsFixed = -1;
            bool foundMatchInfo = false;

            XmlDocument doc = new XmlDocument();
            doc.LoadXml(xmlPos_1_1);

            FixMarch05ForM2.DoFix(doc, ref contextsFound, ref contextsFixed, ref foundMatchInfo);
            ValueCheck.Equals(contextsFound, 1);
            ValueCheck.Equals(contextsFixed, 1);
            ValueCheck.IsTrue(!foundMatchInfo, "foundMatchInfo");
            ValueCheck.Test("Checking converted xml for correctness", xmlPos_1_1_Expected, doc.OuterXml);
        }

        [TestCase]
        public void Pos_0_0()
        {
            int contextsFound = -1;
            int contextsFixed = -1;
            bool foundMatchInfo = false;

            XmlDocument doc = new XmlDocument();
            doc.LoadXml(xmlPos_0_0);

            FixMarch05ForM2.DoFix(doc, ref contextsFound, ref contextsFixed, ref foundMatchInfo);
            ValueCheck.Equals(contextsFound, 0);
            ValueCheck.Equals(contextsFixed, 0);
            ValueCheck.IsTrue(!foundMatchInfo, "foundMatchInfo");
        }

        [TestCase]
        public void Pos_1_0()
        {
            int contextsFound = -1;
            int contextsFixed = -1;
            bool foundMatchInfo = false;

            XmlDocument doc = new XmlDocument();
            doc.LoadXml(xmlPos_1_0);

            FixMarch05ForM2.DoFix(doc, ref contextsFound, ref contextsFixed, ref foundMatchInfo);
            ValueCheck.Equals(contextsFound, 1);
            ValueCheck.Equals(contextsFixed, 1);
            ValueCheck.IsTrue(!foundMatchInfo, "foundMatchInfo");
        }

        [TestCase]
        public void Pos_MatchFound()
        {
            int contextsFound = -1;
            int contextsFixed = -1;
            bool foundMatchInfo = false;

            XmlDocument doc = new XmlDocument();
            doc.LoadXml(xmlPos_FoundMatch);

            FixMarch05ForM2.DoFix(doc, ref contextsFound, ref contextsFixed, ref foundMatchInfo);
            ValueCheck.Equals(contextsFound, 1);
            ValueCheck.Equals(contextsFixed, 1);
            ValueCheck.IsTrue(foundMatchInfo, "foundMatchInfo");
        }

        [TestCase]
        public void Pos_OneLenId()
        {
            int contextsFound = -1;
            int contextsFixed = -1;
            bool foundMatchInfo = false;

            XmlDocument doc = new XmlDocument();
            doc.LoadXml(xmlPos_OneLenId);

            FixMarch05ForM2.DoFix(doc, ref contextsFound, ref contextsFixed, ref foundMatchInfo);
            ValueCheck.Equals(contextsFound, 1);
            ValueCheck.Equals(contextsFixed, 0);
            ValueCheck.IsTrue(!foundMatchInfo, "foundMatchInfo");
        }

        #endregion

        #region Negative Tests

        [TestCase]
        public void Neg_NoFriendlyName()
        {
            int contextsFound = -1;
            int contextsFixed = -1;
            bool foundMatchInfo = false;

            XmlDocument doc = new XmlDocument();
            doc.LoadXml(xmlNeg_NoFriendlyName);

            try
            {
                FixMarch05ForM2.DoFix(doc, ref contextsFound, ref contextsFixed, ref foundMatchInfo);
            }
            catch(ApplicationException e)
            {
                ValueCheck.Test("Missing Friendly Name Exception", "Found a Context node without a friendlyName attribute.  This file is invalid!", e.Message);
            }
        }

        [TestCase]
        public void Neg_NoId()
        {
            int contextsFound = -1;
            int contextsFixed = -1;
            bool foundMatchInfo = false;

            XmlDocument doc = new XmlDocument();
            doc.LoadXml(xmlNeg_NoId);

            try
            {
                FixMarch05ForM2.DoFix(doc, ref contextsFound, ref contextsFixed, ref foundMatchInfo);
            }
            catch(ApplicationException e)
            {
                ValueCheck.Test("Missing Id Exception", "Context node \"node1\" did not have an id attribute.  This file is invalid!", e.Message);
            }
        }

        [TestCase]
        public void Neg_ZeroLenId()
        {
            int contextsFound = -1;
            int contextsFixed = -1;
            bool foundMatchInfo = false;

            XmlDocument doc = new XmlDocument();
            doc.LoadXml(xmlNeg_ZeroLenId);

            try
            {
                FixMarch05ForM2.DoFix(doc, ref contextsFound, ref contextsFixed, ref foundMatchInfo);
            }
            catch(ApplicationException e)
            {
                ValueCheck.Test("Missing Id Exception", "Context node \"node1\" had a zero length id attribute.  This file is invalid!", e.Message);
            }
        }

        [TestCase]
        public void Neg_NoDigitsId()
        {
            int contextsFound = -1;
            int contextsFixed = -1;
            bool foundMatchInfo = false;

            XmlDocument doc = new XmlDocument();
            doc.LoadXml(xmlNeg_NoDigitsId);

            try
            {
                FixMarch05ForM2.DoFix(doc, ref contextsFound, ref contextsFixed, ref foundMatchInfo);
            }
            catch(ApplicationException e)
            {
                ValueCheck.Test("Missing Id Exception", "Context node \"node1\" did not have any hex digits after the 0x hex specifier.  This file is invalid!", e.Message);
            }
        }

        [TestCase]
        public void Neg_IdParseError()
        {
            int contextsFound = -1;
            int contextsFixed = -1;
            bool foundMatchInfo = false;

            XmlDocument doc = new XmlDocument();
            doc.LoadXml(xmlNeg_IdParseError);

            try
            {
                FixMarch05ForM2.DoFix(doc, ref contextsFound, ref contextsFixed, ref foundMatchInfo);
            }
            catch(ApplicationException e)
            {
                ValueCheck.Test("Missing Id Exception", "Context node \"node1\" did not have any hex digits after the 0x hex specifier.  This file is invalid!", e.Message);
            }
        }

        #endregion

        #region XML Input Strings for Non-command line tests

        private string xmlPos_1_1 = @"<Root xmlns=""http://www.xboxlive.com/xlast""><Contexts><Context friendlyName=""node1"" id=""0x123""/></Contexts><Foobar><Context friendlyName=""node2"" id=""0x123""/></Foobar></Root>";
        private string xmlPos_1_1_Expected = @"<Root xmlns=""http://www.xboxlive.com/xlast""><Contexts><Context friendlyName=""node1"" id=""291"" /></Contexts><Foobar><Context friendlyName=""node2"" id=""0x123"" /></Foobar></Root>";

        private string xmlPos_0_0 = @"<Root xmlns=""http://www.xboxlive.com/xlast""><Contexts></Contexts><Foobar><Context friendlyName=""node2"" id=""0x123""/></Foobar></Root>";
        private string xmlPos_1_0 = @"<Root xmlns=""http://www.xboxlive.com/xlast""><Contexts><Context friendlyName=""node1"" id=""666""/></Contexts><Foobar><Context friendlyName=""node2"" id=""0x123""/></Foobar></Root>";
        private string xmlPos_FoundMatch = @"<Root xmlns=""http://www.xboxlive.com/xlast""><Matchmaking><Queries><Query></Query><Query></Query></Queries></Matchmaking><Foobar><Context friendlyName=""node2"" id=""0x123""/></Foobar></Root>";
        private string xmlPos_OneLenId = @"<Root xmlns=""http://www.xboxlive.com/xlast""><Contexts><Context id=""0"" friendlyName=""node1""/></Contexts><Foobar><Context friendlyName=""node2"" id=""0x123""/></Foobar></Root>";
    
        private string xmlNeg_NoFriendlyName = @"<Root xmlns=""http://www.xboxlive.com/xlast""><Contexts><Context id=""0x123""/></Contexts><Foobar><Context friendlyName=""node2"" id=""0x123""/></Foobar></Root>";
        private string xmlNeg_NoId = @"<Root><Contexts xmlns=""http://www.xboxlive.com/xlast""><Context friendlyName=""node1""/></Contexts><Foobar><Context friendlyName=""node2"" id=""0x123""/></Foobar></Root>";
        private string xmlNeg_ZeroLenId = @"<Root xmlns=""http://www.xboxlive.com/xlast""><Contexts><Context id="""" friendlyName=""node1""/></Contexts><Foobar><Context friendlyName=""node2"" id=""0x123""/></Foobar></Root>";
        private string xmlNeg_NoDigitsId = @"<Root xmlns=""http://www.xboxlive.com/xlast""><Contexts><Context id=""0x"" friendlyName=""node1""/></Contexts><Foobar><Context friendlyName=""node2"" id=""0x123""/></Foobar></Root>";
        private string xmlNeg_IdParseError = @"<Root xmlns=""http://www.xboxlive.com/xlast""><Contexts><Context id=""0xx"" friendlyName=""node1""/></Contexts><Foobar><Context friendlyName=""node2"" id=""0x123""/></Foobar></Root>";

        #endregion

        #region Expected Command Line Output Strings

        private string Pos_CmdLine_Expected = "\r\nContexts found: 3\r\nContexts fixed: 3\r\n";
        private string Neg_FileNotFound_Expected = "Missing input file.\r\n";
        private string Neg_CantWriteOutput_Expected = "Access to the path \"c:\\xbox\\xonline\\xenon-m2\\private\\tools\\fixsubmissions\\fixmarch05form2\\test\\dvt\\xmlPos_CmdLine_RO.xlast\" is denied.\r\n";
        private string Neg_InvalidOutputLocation_Expected = "Could not find a part of the path \"q:\\xmlPos_CmdLine_Out.xlast\".\r\n";
        private string Neg_BadArgs_Expected = "\r\nUsage:\r\n\r\n\r\n\tFixMarch05ForM2 <input file> <output file>\r\n\r\n\r\n";

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\FixSubmissions\FixMarch05ForM2\FixMarch05ForM2.cs ===
using System;
using System.IO;
using System.Xml;

namespace xonline.tools.FixSubmissions.FixMarch05ForM2
{
    public class FixMarch05ForM2
    {
        public static void DoFix(XmlDocument doc, ref int contextsFound, ref int contextsFixed, ref bool foundMatchInfo)
        {
            contextsFound = 0;
            contextsFixed = 0;
            foundMatchInfo = false;

            XmlNamespaceManager xmlnsMgr = new XmlNamespaceManager(doc.NameTable);

            xmlnsMgr.AddNamespace("xlast", "http://www.xboxlive.com/xlast");

            //
            //  Convert id attribute on every Context element
            //

            XmlNodeList contextNodes = doc.SelectNodes("//xlast:Contexts/xlast:Context", xmlnsMgr);

            foreach(XmlNode n in contextNodes)
            {
                if(n.LocalName != "Context")
                    continue;

                ++contextsFound;

                XmlAttribute friendlyNameAttr = n.Attributes["friendlyName"];
                if(friendlyNameAttr == null)
                    throw new ApplicationException("Found a Context node without a friendlyName attribute.  This file is invalid!");

                string friendlyName = friendlyNameAttr.Value;

                XmlAttribute idAttr = n.Attributes["id"];
                if(idAttr == null)
                    throw new ApplicationException("Context node \"" + friendlyName + "\" did not have an id attribute.  This file is invalid!");

                string oldId = idAttr.Value;

                if(oldId.Length == 0)
                    throw new ApplicationException("Context node \"" + friendlyName + "\" had a zero length id attribute.  This file is invalid!");
                
                if(oldId.Length < 2)
                    continue; //  Single digit, can't start with 0x so no work needed here

                if(oldId.Substring(0, 2) != "0x")
                    continue;
                
                if(oldId.Length == 2)
                    throw new ApplicationException("Context node \"" + friendlyName + "\" did not have any hex digits after the 0x hex specifier.  This file is invalid!");

                uint newId;

                try
                {
                    newId = UInt32.Parse(oldId.Substring(2), System.Globalization.NumberStyles.HexNumber);
                }
                catch(FormatException)
                {
                    throw new ApplicationException("Context node \"" + friendlyName + "\" did not have any hex digits after the 0x hex specifier.  This file is invalid!");
                }

                n.Attributes["id"].Value = newId.ToString("D");

                ++contextsFixed;
            }

            //
            //  Is there matchmaking info that needs to be hand-converted?
            //

            XmlNodeList queryNodes = doc.SelectNodes("//xlast:Matchmaking/xlast:Queries/xlast:Query", xmlnsMgr);
            if(queryNodes.Count != 0)
                foundMatchInfo = true;

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\dll\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_toolsframework_none_12.4.56.0_none_60a43ba954e0a1ca
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_toolsframework_no-public-key_12.4.56.0_x-ww_ede02a06
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=toolsframework
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_toolsframework_no-public-key_12.4.56.0_x-ww_ede02a06
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_toolsframework_no-public-key_12.4.56.0_x-ww_ede02a06.manifest
XP_MANIFEST_PATH=manifests\msil_toolsframework_no-public-key_12.4.56.0_x-ww_ede02a06.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_toolsframework_no-public-key_12.4.56.0_x-ww_ede02a06.cat
XP_CATALOG_PATH=manifests\msil_toolsframework_no-public-key_12.4.56.0_x-ww_ede02a06.cat
XP_PAYLOAD_PATH=msil_toolsframework_no-public-key_12.4.56.0_x-ww_ede02a06
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=toolsframework,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\fixetx\fixetx.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Data.SqlTypes;
using System.Diagnostics;
using System.Reflection;
using System.Xml;
using System.Linq;

using xonline.common.config;
using xonline.common.sql.sqlclient;
using xonline.common.core.etx;

namespace xonline.tools.deployment
{
    public static class FixEtx
    {
        private static FieldInfo categoryContent;

        static FixEtx()
        {
            Type eventType;

            eventType = typeof(Event);

            categoryContent = eventType.GetField("categoryContent", BindingFlags.NonPublic | BindingFlags.Instance);

            if (null == categoryContent)
            {
                Console.ForegroundColor = ConsoleColor.Red;
                Console.WriteLine("ERROR: Unable to find the categoryContent field on the Event class through reflection.");
                Console.ResetColor();

                throw new InvalidOperationException("Unable to find the categoryContent field on the Event class through reflection.");
            }
        }

        public static void Main(string[] args)
        {
            string server, db;
            bool patch;

            patch   = false;
            server  = null;
            db      = "npdb";

            try
            {
                foreach (string arg in args)
                {
                    string normalized;

                    normalized = arg.Trim().ToLower();

                    if (arg.StartsWith("-"))
                    {
                        try
                        {
                            switch (normalized.Substring(1).Split(':')[0])
                            {
                                case "patch":
                                    patch = true;
                                    break;
                                case "server":
                                    server = normalized.Split(':')[1];
                                    break;
                                case "db":
                                    db = normalized.Split(':')[1];
                                    break;
                                default:
                                    throw new ArgumentException("Unrecognized parameter", arg);
                            }
                        }
                        catch (ArgumentException)
                        {
                            throw;
                        }
                        catch (Exception e)
                        {
                            throw new ArgumentException("Parameter format invalid", arg, e);
                        }
                    }
                    else
                    {
                        throw new ArgumentException("Invalid argument specified, arguments must start with -", arg);
                    }
                }

                if (patch == false)
                {
                    throw new ArgumentException("-patch operation not specified");
                }
            }
            catch (Exception e)
            {
                Console.ForegroundColor = ConsoleColor.Red;
                Console.WriteLine("Error: {0}", e.Message);
                Console.WriteLine();
                Console.ResetColor();

                ShowHelp();

                return;
            }

            PatchEtx(server, db);
        }

        public static void PatchEtx(string server, string db)
        {
            EtxManifest manifest;
            Stopwatch watch;

            manifest = new EtxManifest();

            if (!string.IsNullOrEmpty(server) && !string.IsNullOrEmpty(db))
            {
                Environment.SetEnvironmentVariable("XBL_CONFIG_SERVER", server);
                Environment.SetEnvironmentVariable("XBL_CONFIG_DATABASE", db);
            }

            // Trigger setting load of header version in advance so that it may be
            // cached and prevent a transaction lockup on first attempt to read it.
            Config.GetIntSetting(Setting.etx_default_header_version);
            
            using (SqlClient connection = new SqlClient(db))
            {
                watch = new Stopwatch();
                watch.Start();

                /// BEGINNING TRANSACTION
                connection.Command.Transaction = connection.Command.Connection.BeginTransaction(IsolationLevel.Serializable);

                connection.Command.CommandText = "SELECT xml_producer FROM t_etx_manifest_producers WHERE vb_producer_fingerprint <> 0x00";
                connection.Command.CommandType = CommandType.Text;

                Console.WriteLine("Downloading all producers:");

                using (SqlDataReader results = connection.Command.ExecuteReader())
                {
                    while (results.Read())
                    {
                        using (XmlReader producerReader = results.GetSqlXml(0).CreateReader())
                        {
                            Producer producer;

                            producer = new Producer(producerReader);
                            Console.WriteLine("  {0} - {1}", producer.Symbol.PadRight(20), producer.Fingerprint);

                            manifest.Producers.Add(producer);

                            // replace event categories with their symbol
                            // regenerate fingerprint
                            Array.ForEach(
                                producer.Events.ToArray(),
                                ev =>
                                {
                                    if (ev.Category != EventCategory.Invalid)
                                    {
                                        categoryContent.SetValue(ev, ev.Category.ToString());
                                    }

                                    // replace TitleName and HResult output types with HexNumber since
                                    // to address some eip ingestion issues related to this
                                    Array.ForEach(
                                        ev.DataFields.ToArray(),
                                        df =>
                                        {
                                            if (df.OutType == OutputType.TitleName || df.OutType == OutputType.HResult)
                                            {
                                                df.OutType = OutputType.HexNumber;
                                            }
                                        });

                                    ev.InvalidateFingerprint();
                                });
                        }
                    }
                }

                Console.WriteLine("All producers downloaded.");
                Console.WriteLine("  elapsed time: {0} ms", watch.ElapsedMilliseconds);

                watch.Reset();
                watch.Start();

                /// Destroy Original ETX Definitions
                Console.WriteLine("Destroying all producers");

                connection.Command.CommandText  = "DELETE FROM t_etx_producer_event_mappings WHERE vb_producer_fingerprint <> 0x00\n";
                connection.Command.CommandText += "DELETE FROM t_etx_manifest_producers WHERE vb_producer_fingerprint <> 0x00\n";
                connection.Command.CommandText += "DELETE FROM t_etx_manifest_events WHERE vb_event_fingerprint NOT IN (SELECT vb_event_fingerprint FROM t_etx_producer_event_mappings)";
                connection.Command.CommandType  = CommandType.Text;

                connection.Command.ExecuteNonQuery();

                Console.WriteLine("All producers and events destroyed.");
                Console.WriteLine("  elapsed time: {0} ms", watch.ElapsedMilliseconds);

                watch.Reset();
                watch.Start();

                /// Uploading the new definitions
                Console.WriteLine("Uploading manifest");

                EtxLoader.NPDB.UploadManifest(connection, manifest);

                Console.WriteLine("Upladed all producers");
                Console.WriteLine("  elapsed time: {0} ms", watch.ElapsedMilliseconds);

                /// COMMITTING TRANSACTION
                connection.CommitTransaction();
            }
        }

        public static void ShowHelp()
        {
            Console.WriteLine("FixEtx Usage");
            Console.WriteLine();
            Console.WriteLine("To reconstruct etx manifest from AugXSR schema to SepXSR schema.");
            Console.WriteLine();
            Console.WriteLine("  fixetx -patch [-server:<npdbServer> -db:<npdbName>]");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\Framework\CIni.cs ===
using System;
using System.Collections;
using System.IO;
using System.Text;

namespace xonline.tools.framework 
{

    public class CIni
    {
        private SortedList m_slSections = null;
        private bool m_bChanged = false;

        public bool Changed
        {
            get { return m_bChanged; }
        }

        public void SetSetting(string sSection, string sSetting, string sValue)
        {
            if (sSetting == null)
            {
                throw new ArgumentNullException("sSetting");
            }
            if (sValue == null)
            {
                throw new ArgumentNullException("sValue");
            }

            if(m_slSections == null)
            {
                // no settings yet, create the section list, unless we're trying to remove the setting
                m_slSections = new SortedList();
            }

            // get the sorted list for this section
            SortedList slSettings = (SortedList)m_slSections[sSection.ToUpper()];
            if(slSettings == null)
            {
                // whoops, section doesn't exist yet, so create it
                slSettings = new SortedList();
                m_slSections[sSection.ToUpper()] = slSettings;
            }

            slSettings[sSetting.ToUpper()] = sValue;
            m_bChanged = true;
        }

        public string GetSetting(string sSection, string sSetting)
        {
            if (sSection == null)
            {
                throw new ArgumentNullException("sSection");
            }
            if (sSetting == null)
            {
                throw new ArgumentNullException("sSetting");
            }

            if (m_slSections == null)
            {
                // no sections, no setting, return null to indicate setting doesn't exist
                return null;
            }

            SortedList slSettings = (SortedList)m_slSections[sSection.ToUpper()];
            if (slSettings == null)
            {
                // section doesn't exist, return null to indicate setting doesn't exist
                return null;
            }

            string sValue = (string)slSettings[sSetting.ToUpper()];

            // if setting isn't in list, then sValue is null
            return sValue;
        }

        public SortedList GetSection(string sSection)
        {
            if (sSection == null)
            {
                throw new ArgumentNullException("sSection");
            }

            if (m_slSections == null)
            {
                // no sections, no setting, return null to indicate section doesn't exist
                return null;
            }

            // once we give them the section, they can modify it, so we have
            // to assume they will...
            m_bChanged = true;
            return (SortedList)m_slSections[sSection.ToUpper()];
        }

        public SortedList GetSections()
        {
            // once we give them the sections, they can modify it, so we have
            // to assume they will...
            m_bChanged = true;
            return m_slSections;
        }

        public void Save(string sIniPathAndFileName)
        {
            if (sIniPathAndFileName == null)
            {
                throw new ArgumentNullException("sIniPathAndFileName");
            }

            StreamWriter streamWriter = File.CreateText(sIniPathAndFileName);

            try
            {
                foreach(DictionaryEntry deSection in m_slSections)
                {
                    streamWriter.WriteLine("[" + deSection.Key.ToString().ToUpper() + "]");

                    SortedList slSettings = (SortedList)deSection.Value;

                    foreach(DictionaryEntry deSetting in slSettings)
                    {
                        streamWriter.WriteLine(deSetting.Key.ToString().ToUpper() + "=" + deSetting.Value.ToString());
                    }

                    streamWriter.WriteLine("");
                    m_bChanged = false;
                }
            }
            finally
            {
                streamWriter.Close();
            }
        }

        public CIni()
        {
            m_slSections = null;
        }

        public CIni(string sIniPathAndFileName)
        {
            if (sIniPathAndFileName == null)
            {
                throw new ArgumentNullException("sIniPathAndFileName");
            }

            if (!File.Exists(sIniPathAndFileName))
            {
                throw new ArgumentException("Xbox.Tools.Framework.CIni.ctor: "
                    + "Ini file "
                    + sIniPathAndFileName
                    + " does not exist.",
                    "sIniPathAndFileName");
            }

            m_bChanged = false;
            StreamReader streamReader = File.OpenText(sIniPathAndFileName);
            try
            {
                string sCurSection = "global";
                string sSetting;
                string sValue;

                int iLine;
                string sLine;
                int n;
                for (sLine = streamReader.ReadLine(), iLine=0; sLine != null; sLine = streamReader.ReadLine(), ++iLine)
                {
                    sLine = sLine.Trim();

                    // emtpy line
                    if (sLine == "") 
                        continue;

                    // comment
                    if (sLine.StartsWith(";")) 
                        continue;

                    // new section
                    if (sLine.StartsWith("["))
                    {
                        n = sLine.IndexOf(']');
                        if (n <= 1)
                        {
                            throw new ApplicationException("Format error in ini file: ']' expected on line " + iLine);
                        }

                        sCurSection = sLine.Substring(1, n-1).ToUpper();
                        continue;
                    }

                    // name/value pair
                    n = sLine.IndexOf("=");
                    if (n <= 0)
                    {
                            throw new ApplicationException("Format error in ini file: '=' expected on line " + iLine);
                    }

                    sSetting = sLine.Substring(0, n).Trim().ToUpper();

                    if (n < sLine.Length-1)
                    {
                        sValue = sLine.Substring(n+1).Trim();
                    }
                    else
                    {
                        // no val specified (a=)
                        sValue = "";
                    }

                    if (m_slSections == null)
                    {
                        m_slSections = new SortedList();
                    }
                    if (m_slSections[sCurSection] == null)
                    {
                        m_slSections[sCurSection] = new SortedList();
                    }

                    ((SortedList)(m_slSections[sCurSection]))[sSetting] = sValue;
                }
            }
            finally
            {
                streamReader.Close();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\Framework\CAlternateTitleIds.cs ===
using Microsoft.Webstore.WstClient;
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.EnterpriseServices;
using System.Runtime.Serialization;

using xonline.common.config;

namespace xonline.tools.framework
{
    /// <summary>
    /// Wrapper class for managing alternate title id settings in uodb.
    /// </summary>
    class CAlternateTitleIds
    {
        public static uint[] GetAlternateTitleIds(CTitleId tid, CLog log)
        {
            if(log == null)
                log = new CLogNull();

            log.FullTrace("Xbox.Tools.Framework.CAlternateTitleIds.GetAlternateTitleIds: "
                + "Getting alternate title id list for "
                + tid.sTitleIdHexNoPrefix);

            uint [] aAlternateTitleIds = new uint[4] { 0, 0, 0, 0 };
            WstConnection conn = null;
            WstCommand cmd = null;
            WstDataReader dataset = null;
            SqlParameter ret = null;

            try
            {
                conn = new WstConnection(ConfigUtil.UodbWebstoreApp);
                conn.Open();

                cmd = conn.CreateCommand();
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.CommandText = "p_svc_get_alternate_titleids";
                cmd.WstFailoverMode = WstFailoverMode.PrimaryThenSecondary;
                cmd.PartitionType = WstPartitionType.Physical;

                ret = new SqlParameter();
                ret.Direction = ParameterDirection.ReturnValue;
                ret.DbType = DbType.Int32;

                cmd.Parameters.Add(ret);
                cmd.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)tid.uiTitleId;

                cmd.Partition = WstCommand.AnyPartition;
                dataset = cmd.ExecuteReader();

                if (dataset.Read())
                {
                    // Column zero is the primary title id, don't need it

                    aAlternateTitleIds[0] = (uint)dataset.GetInt32(1);
                    aAlternateTitleIds[1] = (uint)dataset.GetInt32(2);
                    aAlternateTitleIds[2] = (uint)dataset.GetInt32(3);
                    aAlternateTitleIds[3] = (uint)dataset.GetInt32(4);
                }
            }
            catch(Exception e)
            {
                log.LogFile("Error: Retrieving alternate title ids from UODB\r\n" + e.ToString());
                throw;
            }
            finally
            {
                if(dataset != null)
                {
                    dataset.Close();
                    dataset = null;
                }

                if(conn != null)
                {
                    conn.Close();
                    conn = null;
                }
            }

            log.FullTrace("Xbox.Tools.Framework.CAlternateTitleIds.GetAlternateTitleIds: returning");

            return aAlternateTitleIds;
        }


        public static void SetAlternateTitleIds(CTitleId tid, uint [] aAlternateTitleIds, CLog log, bool bReportOnly)
        {
            if(tid == null)
                throw new ArgumentNullException("tid");
            if(aAlternateTitleIds == null)
                throw new ArgumentNullException("aAlternateTitleIds");
            if(aAlternateTitleIds.Length != 4)
                throw new ArgumentException("Alternate title ids array must have exactly four elements.", "aAlternateTitleIds");

            if(log == null)
                log = new CLog();

            ArrayList aConnections = new ArrayList();
            ArrayList aCommands = new ArrayList();

            try
            {
                int iPhysicalPartitions;

                //
                //  First we're going to open a WstConnection, solely for the
                //  purpose of determining the number of physical partitions.
                //

                using(WstConnection conn = new WstConnection(ConfigUtil.UodbWebstoreApp))
                {
                    conn.Open();
                    iPhysicalPartitions = conn.SqlPartitions.Count;
                }

                //
                //  Iterate through the physical partitions
                //

                for(int iPhysicalPartition = 0; iPhysicalPartition < iPhysicalPartitions; ++iPhysicalPartition)
                {
                    WstConnection conn = new WstConnection(ConfigUtil.UodbWebstoreApp);
                    conn.Open();

                    //
                    //  We'll need to clean up this connection later
                    //

                    aConnections.Add(conn);

                    //
                    //  Set up the command and execute
                    //

                    WstCommand cmd = new WstCommand("p_svc_set_alternate_titleids",conn, iPhysicalPartition, WstFailoverMode.PrimaryThenSecondary);
                    
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.PartitionType = WstPartitionType.Physical;
                    cmd.Transaction = conn.BeginTransaction();

                    cmd.Parameters.Add("@i_title_id",      SqlDbType.Int).Value = (int)tid.uiTitleId;
                    cmd.Parameters.Add("@i_alternate_id1", SqlDbType.Int).Value = (int)aAlternateTitleIds[0];
                    cmd.Parameters.Add("@i_alternate_id2", SqlDbType.Int).Value = (int)aAlternateTitleIds[1];
                    cmd.Parameters.Add("@i_alternate_id3", SqlDbType.Int).Value = (int)aAlternateTitleIds[2];
                    cmd.Parameters.Add("@i_alternate_id4", SqlDbType.Int).Value = (int)aAlternateTitleIds[3];

                    log.DataMod("Xbox.Tools.Framekwork.CAlternateTitleIds.SetAlternateTitleIds: "
                        + "Setting alternate title ids { "
                        + aAlternateTitleIds[0].ToString("X") + ", "
                        + aAlternateTitleIds[1].ToString("X") + ", "
                        + aAlternateTitleIds[2].ToString("X") + ", "
                        + aAlternateTitleIds[3].ToString("X") + ", "
                        + " for title " + tid.sTitleIdHexNoPrefix);

                    if(!bReportOnly)
                        cmd.ExecuteNonQuery();

                    //
                    //  We need to commit this command later.
                    //

                    aCommands.Add(cmd);
                }

                //
                //  No exceptions thrown.  Commit all writes.
                //

                foreach(WstCommand cmd in aCommands)
                {
                    cmd.Transaction.Commit();
                }
            }
            catch(Exception)
            {
                //
                //  Rollback all open transactions and then rethrow.
                //

                foreach(WstCommand cmd in aCommands)
                {
                    cmd.Transaction.Rollback();
                }

                throw;
            }
            finally
            {
                foreach(WstConnection conn in aConnections)
                {
                    conn.Close();
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\Framework\CLocale.cs ===
using System;

namespace xonline.tools.framework 
{
    /// <summary>
    /// This class encapsulates a locale, and provides operations for 
    /// representing that locale in various formats relevant to Xbox Live.
    /// Once constructed, an object of this class is immutable.
    /// </summary>
    public class CLocale
    {
        // internally store the locale in enum form, then use the array
        // below to get the string when it is needed
        private string m_sLocale;
        //private ELocale m_enumLocale;

        /// <summary>
        /// An array to map locale strings to enum values.
        /// The ordering of this array is significant, because it is intended that you 
        /// can use the enum value to index the array to come up with the right
        /// string for that locale.
        /// This is protected to make unit testing easier.
        /// </summary>
        protected static string[] m_rgsLocaleStringMapping =
        {
            "da-DK",
            "de-AT",
            "de-CH",
            "de-DE",
            "en-AU",
            "en-CA",
            "en-IE",
            "en-GB",
            "en-SG",
            "en-US",
            "es-ES",
            "fi-FI",
            "fr-BE",
            "fr-CA",
            "fr-CH",
            "fr-FR",
            "it-IT",
            "ja-JP",
            "ko-KR",
            "nb-NO",
            "nl-BE",
            "nl-NL",
            "sv-SE",
            "zh-HK",
            "zh-TW",
        };

        /// <summary>
        /// Checks to see if the string passed to the function 
        /// is a valid supported locale string.
        /// </summary>
        /// <param name="enumLocale">
        /// The string to be tested.
        /// </param>
        public static bool IsSupported(string sLocale)
        {
            // the constructor already has this logic, so just wrap it
            try
            {
                CLocale loc = new CLocale(sLocale);
                return true;
            }
            catch (InvalidLocaleException)
            {
                return false;
            }
        }

        public static CLocale[] SupportedList()
        {
            CLocale[] rgLoc = new CLocale[m_rgsLocaleStringMapping.Length];
            for (int i = 0; i < m_rgsLocaleStringMapping.Length; ++i)
            {
                rgLoc[i] = new CLocale(m_rgsLocaleStringMapping[i]);
            }
            return rgLoc;
        }

        /// <summary>
        /// Creates a locale object given a string representing a locale
        /// </summary>
        /// <param name="sLocale">
        /// The locale, in string form, that this object represents.
        /// </param>
        /// <exception cref="InvalidLocaleException">
        /// Thrown if sLocale does not represent a supported locale
        /// </exception>
        public CLocale(string sLocale)
        {
            for (int i = 0; i < (int)m_rgsLocaleStringMapping.Length; ++i)
            {
                if (sLocale == m_rgsLocaleStringMapping[i])
                {
                    m_sLocale= m_rgsLocaleStringMapping[i];
                    return;
                }
            }
            // if we get here, the locale string was not found
            // in the locale string array
            throw new InvalidLocaleException(
                "Invalid locale string '"
                + sLocale
                + "' passed to TitleMgr.CLocale.CLocale(string)");
        }

        /// <summary>
        /// Gets the locale in string format, for example "en-US" for US English
        /// </summary>
        public override string ToString()
        {
            return m_sLocale;
        }

    }

    public class InvalidLocaleException : ApplicationException
    {
        public InvalidLocaleException() : base() {}
        public InvalidLocaleException(string s) : base(s) {}
        protected InvalidLocaleException(
            System.Runtime.Serialization.SerializationInfo si,
            System.Runtime.Serialization.StreamingContext sc
        ) : base(si, sc) {}
        public InvalidLocaleException(string s, Exception e) : base(s, e) {}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\Framework\CAlertsSync.cs ===
using System;
using System.Collections;
using xonline.tools.framework;

namespace xonline.tools.framework 
{
    public class CAlertsSync
    {
        public static void AlertsSync(
            CTitleId tid, 
            CRepository repository, 
            CAlertsMgr alertsMgr,
            bool bReportOnly,
            CLog log)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            if (repository == null)
            {
                throw new ArgumentNullException("repository");
            }
            if (alertsMgr == null)
            {
                throw new ArgumentNullException("alertsMgr");
            }
            if (log == null)
            {
                throw new ArgumentNullException("log");
            }

            log.StackTrace("Xbox.Tools.Framework.CAlertsSync.AlertsSync("
                + tid.sTitleIdHexNoPrefix + ", "
                + "{repository}, "
                + "{alertsMgr}, "
                + bReportOnly + ", "
                + "{log})");

            // get the list of title descriptions from the repository, indexed
            // by locale
            SortedList slDescByLocale = repository.TitleDescGetListByLocale(tid);

            // iterate through the list of descriptions, adding each description
            // to the alerts service
            foreach (DictionaryEntry de in slDescByLocale)
            {
                string sLocale = (string)de.Key;
                string sDesc = (string)de.Value;

                log.StackTrace("Xbox.Tools.Framework.CAlertsSync.AlertsSync: "
                    + "Adding title description "
                    + sDesc
                    + " to alerts service for locale "
                    + sLocale);
                if (!bReportOnly)
                {
                    uint uiRet = alertsMgr.AddTitle(tid.uiTitleId, sDesc, sLocale);
                    if (uiRet != 0)
                    {
                        string sErr = "Xbox.Tools.Framework.CAlertsSync.AlertsSync: "
                            + "CAlertsMgr.AddTitle() returned "
                            + uiRet;
                        log.LogFile(sErr);
                        throw new CAlertsSyncException(sErr);
                    }
                }
            }

            log.StackTrace("Xbox.Tools.Framework.CAlertsSync.AlertsSync complete");
        }
    }

    public class CAlertsSyncException : ApplicationException
    {
        public CAlertsSyncException() : base() {}
        public CAlertsSyncException(string s) : base(s) {}
        protected CAlertsSyncException(
            System.Runtime.Serialization.SerializationInfo si,
            System.Runtime.Serialization.StreamingContext sc
        ) : base(si, sc) {}
        public CAlertsSyncException(string s, Exception e) : base(s, e) {}
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\Framework\CLog.cs ===
using System;
using System.IO;
using System.Text;
using System.Data;
using System.Data.SqlClient;
using System.Collections;

namespace xonline.tools.framework 
{
    /// <summary>
    /// The existing titlemgr code base uses simple WriteLine and WriteLineV members 
    /// of the CTitleMgr class to write log lines to the console, file, and event log. Unfortunately,
    /// these functions rely on globals, which messes up my unit testing. Therefore, my new
    /// code is designed to be passed a logging object, either CLog or a decendant. CLog implements
    /// a simple wrapper around Console.WriteLine, which is exactly what I want for unit testing,
    /// as well as serving as a place to collect useful logging functions such as SqlCommandToString,
    /// that encapsulate the intelligence to crack and log more complex object types.
    /// </summary>
    public class CLog
    {
        // log level conventions:
        // 
        // level 1 - "CONSOLE" - end user level output, in console apps, expected to go to stdout
        //           messages generally shouldn't be prefixed with class name & method
        //           unless they are unexpected errors that indicate bugs. To make it easy
        //           to search for errors and warnings in scripts, try to prefix messages 
        //           with "Error: " and "Warning: " when appropriate.
        //
        // level 2 - "LOGFILE" - useful information for a normal verbosity log file,
        //           When a library function encounters an error, it should write a note
        //           to the log at this level and then throw. Somewhere higher in the call
        //           stack the app can choose to output to level 1 if appropriate. Should
        //           be prefixed with class name and method.
        //
        // level 3 - "DATAMOD" - When calling .net functions or other code outside the framework
        //           that will make changes to persistent data such as files on disk or rows
        //           in database, log those operations using this level. Should be prefixed with class
        //           name and method.
        //
        // level 4 - "DATAMOD2" - Similar to DATAMOD, but used when making changes to in-memory
        //           copies of data that may or may not then be persisted later. For example,
        //           the CRepository class uses this level to log changes made to XmlDocument objects
        //           loaded in memory, but uses the DATAMOD level to note when those changes are
        //           actually comitted to disk
        //
        // level 5 - "STACKTRACE" - Should log all unction entries and exits to public methods of framework
        //           classes at this level. No need to log entry and exit of private methods.
        //           Should log parameters passed, and return value, if its a simple type.
        //           Should prefix with 
        //
        // level 6 - "FULLTRACE" - anything and everything. Prefix with class name and method.
        //           this is full on debugging info. You should be able to figure out exactly
        //           what code path was run at this level.

        public const int CONSOLE = 1;
        public const int LOGFILE = 2;
        public const int DATAMOD = 3;
        public const int DATAMOD2 = 4;
        public const int STACKTRACE = 5;
        public const int FULLTRACE = 6;

        private int m_iLevel = CONSOLE;

        public int Level
        {
            get
            {
                return m_iLevel;
            }
            set
            {
                m_iLevel = value;
            }
        }

        // Generic function - overloaded by derived classes.
        // This default implementation just outputs to the system console with 
        // a level prefix
        virtual protected void WriteLine(int iLevel, string s)
        {
            if (m_iLevel >= iLevel)
            {
                System.Console.WriteLine(LevelPrefix(iLevel)+s);
                System.Console.Out.Flush();
            }
        }

        protected string LevelPrefix(int iLevel)
        {
            switch (iLevel)
            {
                case CONSOLE:
                    return "[1]|";

                case LOGFILE:
                    return "  [2]|";

                case DATAMOD:
                    return "    [3]|";

                case DATAMOD2:
                    return "      [4]|";

                case STACKTRACE:
                    return "        [5]|";

                case FULLTRACE:
                    return "          [6]|";

                default:
                    return "["+iLevel+"]|";
            }
        }

        // Useful wrappers
        public void Console(string s)
        {
            WriteLine(CONSOLE, s);
        }
        public void LogFile(string s)
        {
            WriteLine(LOGFILE, s);
        }
        public void DataMod(string s)
        {
            WriteLine(DATAMOD, s);
        }
        public void DataMod2(string s)
        {
            WriteLine(DATAMOD2, s);
        }
        public void StackTrace(string s)
        {
            WriteLine(STACKTRACE, s);
        }
        public void FullTrace(string s)
        {
            WriteLine(FULLTRACE, s);
        }

        // aliases for compatibility with titlemgr code
        public void WriteLineV(string s)
        {
            FullTrace(s);
        }

        public void WriteLine(string s)
        {
            Console(s);
        }

        public static string CollectionToString(ICollection collection)
        {
            if (collection == null)
            {
                return "null";
            }
            StringBuilder sb = new StringBuilder();
            sb.Append("{");
            IEnumerator enumerator = collection.GetEnumerator();
            bool bNext = enumerator.MoveNext();
            while (bNext)
            {
                sb.Append(enumerator.Current == null ? "null" : enumerator.Current.ToString());
                bNext = enumerator.MoveNext();
                if (bNext)
                {
                    sb.Append(",");
                }
            }
            sb.Append("}");
            return sb.ToString();
        }

        public static string SqlCommandToString(SqlCommand sqlCommand)
        {
            if (sqlCommand == null)
            {
                throw new ArgumentNullException("sqlCommand");
            }

            if (sqlCommand.CommandText == null || sqlCommand.CommandText.Length == 0)
            {
                return "SqlCommand.CommandText is empty";
            }

            switch (sqlCommand.CommandType)
            {
            case CommandType.Text:
                return sqlCommand.CommandText;

            case CommandType.StoredProcedure:
                StringBuilder sb = new StringBuilder();
                sb.Append(sqlCommand.CommandText);
                foreach (SqlParameter sParam in sqlCommand.Parameters)
                {
                    sb.Append(" ");
                    sb.Append(sParam.ParameterName);
                    sb.Append("=");
                    if (sParam.Value == null)
                    {
                         sb.Append("null");
                    }
                    else
                    {
                        sb.Append(sParam.Value.ToString());
                    }
                }
                sb.Append(" CommandTimeout="+sqlCommand.CommandTimeout);
                return sb.ToString();

            default:
                return "Unknown SqlCommand.CommandType. SqlCommand.CommandText is: " + sqlCommand.CommandText;
            }
        }
    }

    /// <summary>
    /// Instead of checking for a null log reference everywhere we write to the log, instead, when we detect a null 
    /// log reference, we set that reference to CLogNull - this effectively disables logging without having to protect
    /// each log writing statement with an if (null) clause.
    /// </summary>
    public class CLogNull : CLog
    {
        protected override void WriteLine(int iLevel, string s)
        {
            // do nothing
            return;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\Framework\CNPDBSync.cs ===
using System;
using System.Collections;

namespace xonline.tools.framework 
{
    public class CNPDBSync
    {
        // the default language to use, if not otherwise specified in the repository
        private static readonly ELanguageName c_langDefault = ELanguageName.english;

        // string id 0 is for title descriptions
        private const int c_iTitleDescStringId = 0;
        private const int c_iDefaultDescLang = 0;

        public static void NPDBSync(
            CTitleId tid, 
            CRepository repository, 
            CNPDB npdb,
            bool bReportOnly,
            CLog log)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            if (repository == null)
            {
                throw new ArgumentNullException("repository");
            }
            if (npdb == null)
            {
                throw new ArgumentNullException("npdb");
            }
            if (log == null)
            {
                throw new ArgumentNullException("log");
            }

            log.StackTrace("Xbox.Tools.Framework.CNPDBSync.NPDBSync("
                + tid.sTitleIdHexNoPrefix + ", "
                + "{repository}, "
                + "{npdb}, "
                + bReportOnly+", "
                + "{log})");

            //   0        1        2        3        4        5        6        7        8
            log.Console(
                "Syncing title descriptions in NPDB.");

            // Get the default locale,  if any from the repository
            CLocale locDefault = null;
            ELanguageName langDefault = c_langDefault;
            if (repository.TitleDefaultLocaleGet(tid, ref locDefault))
            {
                // there was a default locale in the repository, see it
                // corresponds to one of the supported languages
                if (!CRepository.LocaleToLang(locDefault, ref langDefault))
                {
                    // doesn't correspond to a supported lang, so use the
                    // default default lang
                    langDefault = c_langDefault;
                }
            }
            else
            {
                // no default locale in repository, use the default default lang
                langDefault = c_langDefault;
            }

            // get the title descriptions configured in the repository
            SortedList slTitleDescInRepository = repository.TitleDescGetListByLang(tid);

            // get the title descriptions currently in NPDB
            SortedList slTitleDescInNPDB = npdb.StringGetList(tid, c_iTitleDescStringId);

            // if there no descriptions in the repository, then clear out npdb
            if (slTitleDescInRepository.Count == 0)
            {
                //   0        1        2        3        4        5        6        7        8
                log.Console(
                    "Note: No title descriptions found in repository.");

                // delete any title descriptions found in NPDB
                int iCount = 0;
                foreach (DictionaryEntry de in slTitleDescInNPDB)
                {
                    int iLang = (int)de.Key;
                    //   0        1        2        3        4        5        6        7        8
                    log.Console(
                        "Deleting title description for language code "+iLang+" from NPDB");
                    npdb.StringDelete(
                        tid, 
                        c_iTitleDescStringId, 
                        iLang,
                        bReportOnly);
                    ++iCount;
                }

                // sync is complete
                //   0        1        2        3        4        5        6        7        8
                log.Console(
                    "Success: NPDB title sync complete, "+iCount+" title descriptions deleted");
                return;
            }

            // if we get here, we know there's at least one title description in the repository

            // make sure we have a description for the default language
            if (!slTitleDescInRepository.ContainsKey(langDefault))
            {
                //   0        1        2        3        4        5        6        7        8
                log.Console(
                    "Error: Missing default ("+langDefault.ToString()+") title description");
                log.Console(
                    "       No title descriptions sent to NPDB");
            }

            // see if we need to delete any title descriptions from NPDB
            foreach (DictionaryEntry de in slTitleDescInNPDB)
            {
                int iLang = (int)de.Key;
                if (iLang != c_iDefaultDescLang)
                {
                    // we ignore the default string, we'll be updating that no matter what
                    // and it doesn't correspond to an actual language code

                    if (!slTitleDescInRepository.ContainsKey((ELanguageName)iLang))
                    {
                        // this description is no longer in the repository, so remove
                        // it from NPDB
                        //   0        1        2        3        4        5        6        7        8
                        log.Console(
                            "Deleting title description for language code "+iLang+" from NPDB");
                        npdb.StringDelete(
                            tid, 
                            c_iTitleDescStringId, 
                            iLang,
                            bReportOnly);
                    }
                }
            }

            // anything that needed to be deleted has been deleted, so add or update
            // whatever descriptions are in the repository

            // title strings should have an expiration date of UTC+100 years
            // I'd like to use DateTime.MaxValue, but bug 35714 prevents me.
            DateTime dtExpire = DateTime.UtcNow;
            dtExpire = dtExpire.AddYears(100);

            int iCountUpdate = 0;

            // first, add the default description
            //   0        1        2        3        4        5        6        7        8
            log.LogFile(
                "Updating default title description for in NPDB");
            npdb.StringSet(
                tid, 
                c_iTitleDescStringId, 
                c_iDefaultDescLang,
                dtExpire,
                (string)slTitleDescInRepository[langDefault],
                bReportOnly);
            ++iCountUpdate;

            // now add all the language specific descriptions
            foreach (DictionaryEntry de in slTitleDescInRepository)
            {
                int iLang = (int)de.Key;
                string sDesc = (string)de.Value;

                //   0        1        2        3        4        5        6        7        8
                log.LogFile(
                    "Updating "+((ELanguageName)iLang)+" title description for in NPDB");
                npdb.StringSet(
                    tid, 
                    c_iTitleDescStringId, 
                    iLang,
                    dtExpire,
                    sDesc,
                    bReportOnly);
                ++iCountUpdate;
            }

            //   0        1        2        3        4        5        6        7        8
            log.Console(
                "Success: "+iCountUpdate+" title descriptions added/updated in NPDB");

            log.StackTrace("Xbox.Tools.Framework.CNPDBSync.NPDBSync complete");
        }
    }

    public class CNPDBSyncException : ApplicationException
    {
        public CNPDBSyncException() : base() {}
        public CNPDBSyncException(string s) : base(s) {}
        protected CNPDBSyncException(
            System.Runtime.Serialization.SerializationInfo si,
            System.Runtime.Serialization.StreamingContext sc
        ) : base(si, sc) {}
        public CNPDBSyncException(string s, Exception e) : base(s, e) {}
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\Framework\CNPDB.cs ===
using System;
using System.Net;
using System.Text;
using System.Data;
using System.Data.SqlClient;
using System.Collections;

using xonline.common.utilities;

namespace xonline.tools.framework 
{

    public class CNPDB
    {
        private CLog m_log;
        private string m_sNPDBConnectionString;
        private SqlConnection m_sqlConnection = null;

        public CNPDB(
            string sNPDBConnectionString,
            CLog log)
        {
            if (log == null)
            {
                // if they didn't give us a logging object, then create one that
                // does nothing
                m_log = new CLogNull();
            }
            else
            {
                m_log = log;
            }

            // make sure all non-log parameters are non-null. An empty array is ok, just not null.
            if (sNPDBConnectionString == null)
            {
                throw new ArgumentNullException("sNPDBConnectionString");
            }

            m_log.WriteLineV(
                "Xbox.Tools.Framework.CNPDB.ctor(" +
                sNPDBConnectionString + ")");

            m_sNPDBConnectionString = sNPDBConnectionString;

            // Create a sql connection. Note, I've decided not to track
            // the opened state of this connection. I'll rely on the
            // sql classes to throw the appropriate exceptions if someone
            // calls Close on this class and then attempts to use some
            // other methods.
            try
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CNPDB.ctor: "
                    + "Opening connection to stats database using connection string '"
                    + m_sNPDBConnectionString
                    + "'");
                m_sqlConnection = new SqlConnection(m_sNPDBConnectionString);
                m_sqlConnection.Open();
            }
            catch (SqlException sqlException)
            {
                string sErr = "Xbox.Tools.Framework.CNPDB.ctor: "
                    + "Opening a connection to "
                    + m_sNPDBConnectionString
                    + " caused a SqlException. Exception details: "
                    + sqlException.Message;
                m_log.WriteLineV(sErr);
                throw new CNPDBException(sErr, sqlException);
            }
            catch (ArgumentException ArgumentException)
            {
                // this gets thrown if the connection string is improperly formatted
                string sErr = "Xbox.Tools.Framework.CNPDB.ctor: "
                    + "Opening a connection to "
                    + m_sNPDBConnectionString
                    + " caused an ArgumentException. Exception details: "
                    + ArgumentException.Message;
                m_log.WriteLineV(sErr);
                throw new CNPDBException(sErr, ArgumentException);
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CNPDB.ctor complete");
        }

        public void Close()
        {
            m_log.WriteLineV(
                "Xbox.Tools.Framework.CNPDB.Close()");

            if (m_sqlConnection != null && m_sqlConnection.State != ConnectionState.Closed)
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CNPDB.Close: "
                    + "Closing sql connection "
                    + m_sqlConnection.ConnectionString);
                m_sqlConnection.Close();
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CNPDB.Close complete");
        }

        // I had this little code block repeated all over the place in this
        // file, so I finally decided to put it in this little helper function
        // It's not always useful, because sometimes I want to check the return
        // code for specific values, but I found that most of the time
        // I just threw the same message if it was non-zero
        private void ExecuteNonQuery(
            SqlCommand sqlCommand,
            string sContext)
        {
            try
            {
                sqlCommand.ExecuteNonQuery();
                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    string sErr = sContext
                        + ": The stored procedure "
                        + sqlCommand.CommandText
                        + " returned " 
                        + iRet;
                    m_log.WriteLineV(sErr);
                    throw new CNPDBException(sErr);
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = sContext
                    + ": The stored procedure "
                    + sqlCommand.CommandText 
                    + " caused a SqlException. Details: "
                    + sqlException.Message;
                m_log.WriteLineV(sErr);
                throw new CNPDBException(sErr, sqlException);
            }
        }

        public SortedList StringGetList(CTitleId tid, int iStringId)
        {
            m_log.WriteLineV(
                "Xbox.Tools.Framework.CNPDB.StringGetList("
                + tid.sTitleIdHexNoPrefix+", "
                + iStringId+")");

            SqlCommand sqlCommand = m_sqlConnection.CreateCommand();
            sqlCommand.CommandText = "p_stringsvr_strings_get_by_title_and_id";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("@i_string_id", SqlDbType.Int).Value = (int)iStringId;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.WriteLineV(
                "Xbox.Tools.Framework.CNPDB.StringGetList: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            SortedList sl = new SortedList();
            SqlDataReader sqlDataReader = null;
            try
            {
                // run the command!
                sqlDataReader = sqlCommand.ExecuteReader();

                // get the results
                while (sqlDataReader.Read())
                {
                    // save the results in the out parameters

                    // from the table definition:
                    // i_title_id                int               not null
                    //,i_string_id               int               not null
                    //,vc_locale                 varchar(10)       not null
                    //,dt_modified               datetime          not null
                    //,dt_expire                 datetime          not null
                    //,nvc_text                  nvarchar(512)     not null

                    string locale = (string)sqlDataReader["vc_locale"];
                    string sString = (string)sqlDataReader["nvc_text"];

                    // add this data to our list
                    // Note: the caller is expecting an 'int' as the key
                    sl.Add((int)(Locale.v1LanguageIdFromLocale(locale)), sString);
                }

                // close the reader so we can check the return code
                sqlDataReader.Close();

                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    string sErr = "Xbox.Tools.Framework.CNPDB.StringGetList: The stored procedure "
                        + sqlCommand.CommandText
                        + " returned " 
                        + iRet;
                    m_log.WriteLineV(sErr);
                    throw new CNPDBException(sErr);
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "Xbox.Tools.Framework.CNPDB.StringGetList: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;
                m_log.WriteLineV(sErr);
                throw new CNPDBException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }

            // return the sorted list
            m_log.WriteLineV("Xbox.Tools.Framework.CNPDB.StringGetList complete");
            return sl;
        }

        public void StringSet(
            CTitleId tid, 
            int iStringId, 
            int iLang,
            DateTime dtExpire,
            string sString,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            m_log.WriteLineV(
                "Xbox.Tools.Framework.CNPDB.StringSet(" +
                tid.ToString() + ", " +
                iStringId + ", "+
                iLang+ ", "+
                dtExpire+ ", "+
                sString+ ", "+
                bReportOnly+ ")");

            // REVIEW: consider if the titlemgr repository should begin storing
            //  locales directly for Xenon instead of the old v1 language IDs
            string locale = Locale.LocaleFromv1LanguageId( (ushort)iLang ); 

            SqlCommand sqlCommand = m_sqlConnection.CreateCommand();
            sqlCommand.CommandText = "p_stringsvr_string_add_by_id";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("@i_string_id", SqlDbType.Int).Value = (int)iStringId;
            sqlCommand.Parameters.Add("@vc_locale", SqlDbType.VarChar).Value = locale;
            sqlCommand.Parameters.Add("@dt_expire", SqlDbType.DateTime).Value = (DateTime)dtExpire;
            sqlCommand.Parameters.Add("@nvc_text", SqlDbType.NVarChar).Value = (string)sString;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.WriteLineV(
                "Xbox.Tools.Framework.CNPDB.StringSet: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            if (!bReportOnly)
            {
                ExecuteNonQuery(sqlCommand, "Xbox.Tools.Framework.CNPDB.StringSet");
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CNPDB.StringSet complete");
        }

        public void StringDelete(
            CTitleId tid, 
            int iStringId, 
            int iLang,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            m_log.WriteLineV(
                "Xbox.Tools.Framework.CNPDB.StringDelete(" +
                tid.ToString() + ", " +
                
                bReportOnly+ ")");

            // REVIEW: consider if the titlemgr repository should begin storing
            //  locales directly for Xenon instead of the old v1 language IDs
            string locale = Locale.LocaleFromv1LanguageId( (ushort)iLang ); 
            
            SqlCommand sqlCommand = m_sqlConnection.CreateCommand();
            sqlCommand.CommandText = "p_stringsvr_string_delete";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("@i_string_id", SqlDbType.Int).Value = (int)iStringId;
            sqlCommand.Parameters.Add("@vc_locale", SqlDbType.VarChar).Value = locale;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.WriteLineV(
                "Xbox.Tools.Framework.CNPDB.StringDelete: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            if (!bReportOnly)
            {
                ExecuteNonQuery(sqlCommand, "Xbox.Tools.Framework.CNPDB.StringDelete");
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CNPDB.StringDelete complete");
        }

        public class Outage
        {
            private DateTime m_Start;
            private DateTime m_End;
            private uint m_Id;
            private static uint m_IdCounter = 0;

            public DateTime Start
            {
                get
                {
                    return m_Start;
                }
                
                set
                {
                    m_Start = value;
                }
            }

            public DateTime End
            {
                get
                {
                    return m_End;
                }
                
                set
                {
                    m_End = value;
                }
            }

            public uint Id
            {
                get
                {
                    return m_Id;
                }
                
                set
                {
                    m_Id = value;
                }
            }

            static public uint IdCounter
            {
                get
                {
                    return m_IdCounter;
                }
                
                set
                {
                    m_IdCounter = value;
                }
            }

            public Outage()
            {
                m_Id = m_IdCounter++;
                m_Start = m_End = DateTime.UtcNow;
            }

            public Outage(DateTime StartTime, DateTime EndTime)
            {
                m_Id = m_IdCounter++;
                m_Start = StartTime;
                m_End = EndTime;
            }
            
       }

        public void CompOutageDowntimeSet(
            DateTime StartTimeNew,
            DateTime EndTimeNew,
            bool ReportOnly) 
        {
            SqlCommand sqlCommand = m_sqlConnection.CreateCommand();
            sqlCommand.CommandText = "p_svc_set_downtime";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@dt_start_new", SqlDbType.DateTime).Value = StartTimeNew;
            sqlCommand.Parameters.Add("@dt_end_new", SqlDbType.DateTime).Value = EndTimeNew;
            sqlCommand.Parameters.Add("@dt_start_old", SqlDbType.DateTime).Value = "1/1/1753"; // min sql datetime
            sqlCommand.Parameters.Add("@dt_end_old", SqlDbType.DateTime).Value = "1/1/1753"; // min sql datetime
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            if (StartTimeNew >= EndTimeNew)
            {
                    string sErr = "Start Time must precede End Time.";
                    throw new CNPDBException(sErr);
            }

            if (DateTime.UtcNow >= StartTimeNew)
            {
                    string sErr = "Start Time must NOT precede current system time.";
                    throw new CNPDBException(sErr);
            }

            TimeSpan TimeDiff1 = EndTimeNew.Subtract(StartTimeNew);
            if (TimeDiff1.TotalMinutes < 11)
            {
                    string sErr = "Start Time must precede End Time by at least 11 minutes.";
                    throw new CNPDBException(sErr);
            }

            TimeSpan TimeDiff2 = StartTimeNew.Subtract(DateTime.UtcNow);
            if (TimeDiff2.TotalMinutes < 11)
            {;
                    string sErr = "Current system time must precede Start Time by at least 11 minutes.";
                    throw new CNPDBException(sErr);
            }

            m_log.WriteLineV(
                "Xbox.Tools.Framework.CNPDB.CompOutageDowntimeSet: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            if (!ReportOnly)
            {
                try
                {
                    sqlCommand.ExecuteNonQuery();
                    int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                    if (iRet == 1)
                    {
                        string sErr = "Xbox.Tools.Framework.CNPDB.CompOutageDowntimeSet: "
                            + "Overlapping outage detected. Insert not committed.";
                        m_log.WriteLineV(sErr);
                        throw new CNPDBException(sErr);
                    }
                    else if (iRet != 0)
                    {
                        string sErr = "Xbox.Tools.Framework.CNPDB.CompOutageDowntimeSet: "
                            + " The stored procedure "
                            + sqlCommand.CommandText
                            + " returned " 
                            + iRet;
                        m_log.WriteLineV(sErr);
                        throw new CNPDBException(sErr);
                    }
                }
                catch (SqlException sqlException)
                {
                    string sErr = "Xbox.Tools.Framework.CNPDB.CompOutageDowntimeSet: "
                        + " The stored procedure "
                        + sqlCommand.CommandText 
                        + " caused a SqlException. Details: "
                        + sqlException.Message;
                    m_log.WriteLineV(sErr);
                    throw new CNPDBException(sErr, sqlException);
                }
           }

            m_log.WriteLineV("Xbox.Tools.Framework.CNPDB.CompOutageDowntimeSet complete");
        }
        

        public Outage [] CompOutageDowntimesGet()
        {

            Outage.IdCounter = 0;
            ArrayList OutageArray = new ArrayList();

            SqlCommand sqlCommand = m_sqlConnection.CreateCommand();
            sqlCommand.CommandText = "p_svc_get_all_downtimes";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.WriteLineV(
                "Xbox.Tools.Framework.CNPDB.CompOutageDowntimesGet: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));
                
            SqlDataReader sqlDataReader = null;
            try
            {
                // run the command!
                sqlDataReader = sqlCommand.ExecuteReader();

                while (sqlDataReader.Read())
                {
                    //dt_downtime_start               datetime          not null
                    //dt_downtime_end                 datetime          not null
                    Outage Out = new Outage((DateTime)sqlDataReader["dt_downtime_start"],
                        (DateTime)sqlDataReader["dt_downtime_end"]);
                    OutageArray.Add(Out);
                }

                // close the reader so we can check the return code
                sqlDataReader.Close();

                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    string sErr = "Xbox.Tools.Framework.CNPDB.CompOutageDowntimesGet: The stored procedure "
                        + sqlCommand.CommandText
                        + " returned " 
                        + iRet;
                    m_log.WriteLineV(sErr);
                    throw new CNPDBException(sErr);
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "Xbox.Tools.Framework.CNPDB.CompOutageDowntimesGet: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;
                m_log.WriteLineV(sErr);
                throw new CNPDBException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }

            // return the sorted list
            Outage [] rgui = new Outage[OutageArray.Count];
            OutageArray.CopyTo(rgui);
            m_log.WriteLineV("Xbox.Tools.Framework.CNPDB.CompOutageDowntimesGet complete");
            return rgui;
        }

        public void CompOutageDowntimeDelete(
            DateTime StartTimeOld, 
            DateTime EndTimeOld,
            bool ReportOnly) 
        {

            SqlCommand sqlCommand = m_sqlConnection.CreateCommand();
            sqlCommand.CommandText = "p_svc_del_downtime";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@dt_start_old", SqlDbType.DateTime).Value = StartTimeOld;
            sqlCommand.Parameters.Add("@dt_end_old", SqlDbType.DateTime).Value = EndTimeOld;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.WriteLineV(
                "Xbox.Tools.Framework.CNPDB.CompOutageDowntimeDelete: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            if (!ReportOnly)
            {
                ExecuteNonQuery(sqlCommand, "Xbox.Tools.Framework.CNPDB.CompOutageDowntimeDelete");
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CNPDB.CompOutageDowntimeDelete complete");

        }
    }

    public class CNPDBException: ApplicationException
    {
        public CNPDBException() : base() {}
        public CNPDBException(string s) : base(s) {}
        protected CNPDBException(
            System.Runtime.Serialization.SerializationInfo si,
            System.Runtime.Serialization.StreamingContext sc
        ) : base(si, sc) {}
        public CNPDBException(string s, Exception e) : base(s, e) {}
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\Framework\calertsmgr.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Threading;
using System.Xml;
using System.Xml.Serialization;

using xonline.common.config;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.sql.webstore;

using Microsoft.Webstore.WstClient;


namespace xonline.tools.framework 
{
    // Subscription object used for creating subscriptions (both live and content)
    //  This is the data that the client needs to provide to the service
    public class AlertSubscription
    {
        public uint type;               // Alert Type
        public string locale;           // Locale            
    }
    
    // Subscription object used for returning data to the client on enumerate
    //  for Live subscriptions only
    public class LiveSubscription
    {
        public LiveSubscription()
        {
        }
        
        public LiveSubscription(AlertSubscription als)
        {
            subscriptionID = 0;
            type = als.type;
            name = null;
            locale = als.locale;
            subscriberXUID = 0;
        }
        
        public ulong subscriptionID;    // SubscriptionId
        public uint type;               // Alert Type
        public string name;             // Subscriber gamertag        
        public string locale;           // Locale            

        [XmlIgnore]
        public ulong subscriberXUID;    // Subscribers XBOX ID        
    }

    // Subscription object used for returning data to the client on enumerate
    //  for Content subscriptions only
    public class ContentSubscription
    {
        public ContentSubscription()
        {
        }
        
        public ContentSubscription(AlertSubscription als)
        {
            subscriptionID = 0;
            type = als.type;
            locale = als.locale;
        }
        
        public ulong subscriptionID;    // SubscriptionId
        public uint type;               // Alert Type
        public string locale;           // Locale            
    }


    /// <summary>
    /// This class provides functionality for communicating with the XBOX Live Alerts System for managing static data (titles) as well as 
    ///  dynamic data (subscriptions and events)
    /// </summary>
    public class CAlertsMgr
    {
        protected string m_instanceServer;
        protected string m_applicationServer;
        protected string m_device;
        
        /// <summary>
        /// This method provided for backcompat with unconverted services
        /// </summary>
        public CAlertsMgr(string alertsServer, string alertsDevice) : this (alertsDevice)
        {
        }
        
        /// <summary>
        /// Setup object to communicate with Alerts server
        /// </summary>
        public CAlertsMgr(string alertsDevice)
        {
            // Get server names for the databases
            string[] servers;

            servers = Config.GetServerListByInterface(Interface.alertsInstance);

            if (servers.Length == 0)
            {
                throw new ApplicationException("Could not find Interface element named "
                    + Interface.alertsInstance.ToString()
                    + " under any Server element");
            }
            if (servers.Length > 1)
            {
                throw new ApplicationException("More than one Interface element named "
                    + Interface.alertsInstance.ToString()
                    + " was found when only one was expected");
            }

            m_instanceServer = servers[0];

            servers = Config.GetServerListByInterface(Interface.alertsApp);

            if (servers.Length == 0)
            {
                throw new ApplicationException("Could not find Interface element named "
                    + Interface.alertsApp.ToString()
                    + " under any Server element");
            }
            if (servers.Length > 1)
            {
                throw new ApplicationException("More than one Interface element named "
                    + Interface.alertsApp.ToString()
                    + " was found when only one was expected");
            }

            m_applicationServer = servers[0];

            // Store the device name for subscriptions managed by this instance
            if (alertsDevice == null)
            {
                m_device = "MSAlertsDevice";
            }
            else
            {
                m_device = alertsDevice;
            }
        }


        private string FormatWebID(ulong webID)
        {
            string  subscriberID;
            uint    high;
            uint    low;

            high = (uint)(webID >> 32);
            low = (uint)webID;
            
            // Format the webID into the form '0x00020100:0x02eee066'. Note the alpha chars will all be lower case
            subscriberID = "0x" + high.ToString("x8") + ":0x" + low.ToString("x8");
            
            return subscriberID;
        }


        /// <summary>
        /// Subscriber management: This method writes the subscription boolean 
        ///  into the user record in UODB and informs Presence that the users
        ///  state has changed
        /// </summary>
        public void SetUserSubscriptionFlag(ulong userID, bool fSubscribed)
        {
            WSClient    ws;
            HResult     hr = HResult.S_OK;
            
            // Talk to the database to update the users subscription flag
            ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE);
            ws.SetHashVal(userID);
            
            ws.StoredProc = "dbo.p_user_update_alerts";
            ws.AddParameter(ParamType.RETVAL,  "@RETVAL",           hr);
            ws.AddParameter(ParamType.INPUT,   "@bi_user_puid",     userID);
            ws.AddParameter(ParamType.INPUT,   "@ti_subscribed",    (byte)(fSubscribed ? 1 : 0));
            
            ws.ExecuteNonQuery();
            
            hr = (uint)ws.GetIntParameter("@RETVAL");
            
            if(HResult.Failed(hr))
            {
                throw new ApplicationException("CAlertsMgr::SetUserSubscriptionFlag: Database error on p_user_update_alerts: hr = " + hr + " user=0x" + userID.ToString("x") + " fSubscribed=" + fSubscribed.ToString() );                    
            }                

            // Invalidate the user in Presence so that the setting gets reloaded into the persistant user cache            
            InvalidateUserMsg         request = new InvalidateUserMsg();
            XRLObject2                xrlo = null;

            request.qwUserID = userID;

            HTTPAuthData httpAuthData = new HTTPAuthData( 0, 0, 0, userID, XOn.WEB_TITLE_ID, (uint) XOService.PresNotification, 0 );
            
            hr = XRLUtil.PostXrlRequest( VirtualInterface.xpnfd_presence_int, request.GetXRL(), httpAuthData.GetBase64EncodedString(), request, ref xrlo );

            if (HResult.Failed(hr))
            {
                throw new ApplicationException("CAlertsMgr::SetUserSubscriptionFlag: Unexpected failure calling InvalidateUser. hr = " + hr + " user=0x" + userID.ToString("x") + " fSubscribed=" + fSubscribed.ToString() );                    
            }
        }
        
        
        /// <summary>
        /// Subscriber management: This method can add a subscriber to the Alerts service
        /// </summary>
        public void AddSubscriber(ulong webID, ulong userID)
        {
            SqlConnection   cxn = null;
            SqlCommand      cmd = null;
            string  subscriberID;
            string  scalar;
            
            IInterfaceInfo alertsInstanceInfo = Config.GetInterface(m_instanceServer, Interface.alertsInstance);            
            cxn = new SqlConnection("Data Source=" + alertsInstanceInfo.IPAddressString + ";Initial Catalog=" + alertsInstanceInfo.DBName + ";Integrated Security=SSPI");
            
            try
            {                
                subscriberID = FormatWebID(webID);
                
                cxn.Open();

                // There is no PK enforcement on the subscriber table, so we have to do our own checking to ensure that 
                //  we don't insert a duplicate                
                cmd = new SqlCommand("NSGetSubscribers", cxn);
                cmd.CommandType = CommandType.StoredProcedure;

                cmd.Parameters.Add("@SubscriberId", SqlDbType.NVarChar, 255).Value = subscriberID;
                
                scalar = (string)cmd.ExecuteScalar();

                if (scalar != null)
                {
                    scalar = scalar.ToLower();
                }

                if (scalar != subscriberID)
                {
                    // Add the subscriber object                
                    cmd = new SqlCommand("NSInsertSubscriber", cxn);
                    cmd.CommandType = CommandType.StoredProcedure;

                    cmd.Parameters.Add("@SubscriberId", SqlDbType.NVarChar, 255).Value = subscriberID;
                    cmd.Parameters.Add("@Enabled", SqlDbType.Bit).Value = true;
                    
                    cmd.ExecuteNonQuery();
                }


                // There is no PK enforcement on the devices table, so we have to do our own checking to ensure that 
                //  we don't insert a duplicate. There should only be one device per user               
                cmd = new SqlCommand("NSGetSubscriberDevices", cxn);
                cmd.CommandType = CommandType.StoredProcedure;

                cmd.Parameters.Add("@SubscriberId", SqlDbType.NVarChar, 255).Value = subscriberID;
                
                scalar = (string)cmd.ExecuteScalar();

                if (scalar != m_device)
                {
                    // Add the subscriber device
                    cmd = new SqlCommand("NSInsertSubscriberDevice", cxn);
                    cmd.CommandType = CommandType.StoredProcedure;

                    cmd.Parameters.Add("@SubscriberId", SqlDbType.NVarChar, 255).Value = subscriberID;
                    cmd.Parameters.Add("@DeviceName", SqlDbType.NVarChar, 255).Value = m_device;
                    cmd.Parameters.Add("@DeviceTypeName", SqlDbType.NVarChar, 255).Value = "HttpLogger";
                    cmd.Parameters.Add("@DeviceAddress", SqlDbType.NVarChar, 255).Value = null;
                    cmd.Parameters.Add("@DeliveryChannelName", SqlDbType.NVarChar, 255).Value = "MSAlerts";
                    
                    cmd.ExecuteNonQuery();
                }
                
                cmd = null;                

                // Inform UODB that this user has subscribed to Alerts. 
                SetUserSubscriptionFlag(userID, true);
            }
            finally
            {
                if (cmd != null)     cmd.Cancel();
                if (cxn != null)     cxn.Close();
            }            
        }


        /// <summary>
        /// Subscriber management: Check to see if the subscriber exists in the system already. This method can be 
        ///  used to determine if the user has ever initialized the system previously.
        /// </summary>
        public bool SubscriberExists(ulong webID)
        {
            SqlConnection   cxn = null;
            SqlCommand      cmd = null;
            string          subscriberID;
            string          scalar;
            bool            result = false;
            
            IInterfaceInfo alertsInstanceInfo = Config.GetInterface(m_instanceServer, Interface.alertsInstance);            
            cxn = new SqlConnection("Data Source=" + alertsInstanceInfo.IPAddressString + ";Initial Catalog=" + alertsInstanceInfo.DBName + ";Integrated Security=SSPI");
            
            try
            {                
                subscriberID = FormatWebID(webID);
                
                cxn.Open();

                // There is no PK enforcement on the subscriber table, so we have to do our own checking to ensure that 
                //  we don't insert a duplicate                
                cmd = new SqlCommand("NSGetSubscribers", cxn);
                cmd.CommandType = CommandType.StoredProcedure;

                cmd.Parameters.Add("@SubscriberId", SqlDbType.NVarChar, 255).Value = subscriberID;
                
                scalar = (string)cmd.ExecuteScalar();

                if (scalar != null)
                {
                    scalar = scalar.ToLower();
                }

                if (scalar == subscriberID)
                {
                    result = true;
                }
                
                cmd = null;                
            }
            finally
            {
                if (cmd != null)     cmd.Cancel();
                if (cxn != null)     cxn.Close();
            }            

            return result;
        }

        
        /// <summary>
        /// Subscriber management: This method can remove subscribers from the Alerts service
        /// </summary>
        public void DeleteSubscriber(ulong webID, ulong userID)
        {
            SqlConnection cxn = null;
            SqlCommand cmd = null;
            string  subscriberID;
            
            IInterfaceInfo alertsInstanceInfo = Config.GetInterface(m_instanceServer, Interface.alertsInstance);            
            cxn = new SqlConnection("Data Source=" + alertsInstanceInfo.IPAddressString + ";Initial Catalog=" + alertsInstanceInfo.DBName + ";Integrated Security=SSPI");
            
            try
            {
                subscriberID = FormatWebID(webID);
                
                cxn.Open();

    
                // Add the subscriber device
                cmd = new SqlCommand("NSDeleteSubscriberDevice", cxn);
                cmd.CommandType = CommandType.StoredProcedure;

                cmd.Parameters.Add("@SubscriberId", SqlDbType.NVarChar, 255).Value = subscriberID;
                cmd.Parameters.Add("@DeviceName", SqlDbType.NVarChar, 255).Value = m_device;
                
                cmd.ExecuteNonQuery();


                // Remove the subscriber object                
                cmd = new SqlCommand("NSDeleteSubscriber", cxn);
                cmd.CommandType = CommandType.StoredProcedure;

                cmd.Parameters.Add("@SubscriberId", SqlDbType.NVarChar, 255).Value = subscriberID;
                
                cmd.ExecuteNonQuery();


                cmd = null;

                // Inform UODB that this user has subscribed to Alerts. 
                SetUserSubscriptionFlag(userID, false);                
            }
            finally
            {
                if (cmd != null)     cmd.Cancel();
                if (cxn != null)     cxn.Close();
            }            
        }


        /// <summary>
        /// Subscription management: This method deletes all alerts subscriptions for the given userID
        /// </summary>
        public void DeleteAccountSubscriptions(ulong webID, ulong userID, bool deleteContentSubscriptions)
        {
            HResult                hr;
            LiveSubscription[]     liveSubscriptions;

            hr = EnumerateLiveSubscriptions(webID, userID, out liveSubscriptions);

            if (HResult.Failed(hr))
            {
                throw new Exception("Could not enumerate live subscriptions for user " + userID.ToString("x"));
            }

            if (liveSubscriptions != null)
            {
                foreach(LiveSubscription ls in liveSubscriptions)
                {
                    DeleteLiveSubscription(webID, ls.subscriptionID);
                }
            }

            if (deleteContentSubscriptions)
            {
                ContentSubscription[]  contentSubscriptions;
                
                hr = EnumerateContentSubscriptions(webID, userID, out contentSubscriptions);

                if (HResult.Failed(hr))
                {
                    throw new Exception("Could not enumerate content subscriptions for user " + userID.ToString("x"));
                }

                if (contentSubscriptions != null)
                {
                    foreach(ContentSubscription cs in contentSubscriptions)
                    {
                        DeleteContentSubscription(webID, cs.subscriptionID);
                    }
                }
            }
        }

        
        /// <summary>
        /// Subscription management: This method adds a live alerts subscription for the given user
        /// </summary>
        public HResult AddLiveSubscription(ulong webID, string locale, uint liveType, ulong xuid, string name, out ulong subscriptionID)
        {
            SqlConnection cxn = null;
            SqlCommand cmd = null;
            string  subscriberID;
            HResult hr = HResult.S_FALSE;
            
            IInterfaceInfo alertsApplicationInfo = Config.GetInterface(m_applicationServer, Interface.alertsApp);            
            cxn = new SqlConnection("Data Source=" + alertsApplicationInfo.IPAddressString + ";Initial Catalog=" + alertsApplicationInfo.DBName + ";Integrated Security=SSPI");
            
            try
            {
                subscriberID = FormatWebID(webID);
                
                cxn.Open();
    
                // Add the subscription object                
                cmd = new SqlCommand("NSInsertxLiveSubscriptionsSubscription", cxn);
                cmd.CommandType = CommandType.StoredProcedure;

                SqlParameter ret = cmd.Parameters.Add("@Ret", SqlDbType.Int);
                ret.Direction = ParameterDirection.ReturnValue;                
                
                SqlParameter subID = cmd.Parameters.Add("@SubscriptionId", SqlDbType.BigInt);
                subID.Direction = ParameterDirection.Output;                
                
                cmd.Parameters.Add("@Enabled", SqlDbType.Bit).Value = true;
                cmd.Parameters.Add("@Type", SqlDbType.Int).Value = unchecked((int)liveType);
                cmd.Parameters.Add("@DeviceName", SqlDbType.NVarChar, 255).Value = m_device;
                cmd.Parameters.Add("@SubscriberXUID", SqlDbType.BigInt).Value = xuid;
                cmd.Parameters.Add("@Subscriber", SqlDbType.NChar, 16).Value = name;
                cmd.Parameters.Add("@SubscriberLocale", SqlDbType.NChar, 10).Value = locale;
                cmd.Parameters.Add("@SubscriberId", SqlDbType.NVarChar, 255).Value = subscriberID;
                cmd.ExecuteNonQuery();

                hr = (uint)(int)ret.Value;
                subscriptionID = unchecked((ulong)(long)subID.Value);
                
                
                cmd = null;                
            }
            finally
            {
                if (cmd != null)     cmd.Cancel();
                if (cxn != null)     cxn.Close();
            }            

            return hr;
        }


        /// <summary>
        /// Subscription management: This method removes a content subscription for the given user
        /// </summary>
        public HResult EnumerateLiveSubscriptions(ulong webID, ulong userID, out LiveSubscription[] subscriptions)
        {
            SqlConnection       cxn = null;
            SqlCommand          cmd = null;
            SqlDataReader       reader = null;
            ArrayList           subscriptionList = new ArrayList();
            LiveSubscription    sub;
            string              subscriberID;
            HResult             hr = HResult.S_FALSE;
            
            IInterfaceInfo alertsApplicationInfo = Config.GetInterface(m_applicationServer, Interface.alertsApp);            
            cxn = new SqlConnection("Data Source=" + alertsApplicationInfo.IPAddressString + ";Initial Catalog=" + alertsApplicationInfo.DBName + ";Integrated Security=SSPI");
            
            try
            {
                subscriberID = FormatWebID(webID);
                subscriptions = null;
                
                cxn.Open();
    
                // Add the subscription object                
                cmd = new SqlCommand("NSGetxLiveSubscriptionsSubscriptionBySubscriberId", cxn);
                cmd.CommandType = CommandType.StoredProcedure;
                
                cmd.Parameters.Add("@SubscriberId", SqlDbType.NVarChar, 255).Value = subscriberID;
                
                reader = cmd.ExecuteReader();                

                while(reader.Read())
                {
                    sub = new LiveSubscription();

                    sub.subscriptionID = unchecked((ulong)reader.GetInt64(reader.GetOrdinal("SubscriptionID")));
                    sub.type = unchecked((uint)reader.GetInt32(reader.GetOrdinal("Type")));
                    sub.subscriberXUID = unchecked((ulong)reader.GetInt64(reader.GetOrdinal("SubscriberXUID")));
                    sub.name = reader.GetString(reader.GetOrdinal("Subscriber")).Trim();
                    sub.locale = reader.GetString(reader.GetOrdinal("SubscriberLocale")).Trim();

                    if ( (userID == 0) || (userID == sub.subscriberXUID) )
                    {
                        if ( (reader.GetBoolean(reader.GetOrdinal("Enabled"))) && (reader.GetString(reader.GetOrdinal("SubscriberID")) == subscriberID) && (reader.GetString(reader.GetOrdinal("DeviceName")) == m_device) )
                        {                        
                            subscriptionList.Add(sub);
                        }
                    }
                }

                if (subscriptionList.Count > 0)
                {
                    subscriptions = new LiveSubscription[subscriptionList.Count];
                    subscriptionList.CopyTo(subscriptions);

                    hr = HResult.S_OK;
                }
            }
            finally
            {
                if (reader != null)  reader.Close();
                if (cmd != null)     cmd.Cancel();
                if (cxn != null)     cxn.Close();
            }            

            return hr;
        }


        /// <summary>
        /// Subscription management: This method adds a live alerts subscription for the given user
        /// </summary>
        public void UpdateLiveSubscription(ulong webID, ulong subscriptionID, string locale, uint liveType, ulong xuid, string name)
        {
            SqlConnection cxn = null;
            SqlCommand cmd = null;
            string  subscriberID;
            
            IInterfaceInfo alertsApplicationInfo = Config.GetInterface(m_applicationServer, Interface.alertsApp);            
            cxn = new SqlConnection("Data Source=" + alertsApplicationInfo.IPAddressString + ";Initial Catalog=" + alertsApplicationInfo.DBName + ";Integrated Security=SSPI");
            
            try
            {
                subscriberID = FormatWebID(webID);
                
                cxn.Open();
    
                // Add the subscription object                
                cmd = new SqlCommand("NSUpdatexLiveSubscriptionsSubscription", cxn);
                cmd.CommandType = CommandType.StoredProcedure;
                
                cmd.Parameters.Add("@SubscriptionId", SqlDbType.BigInt).Value = subscriptionID;
                cmd.Parameters.Add("@Enabled", SqlDbType.Bit).Value = true;
                cmd.Parameters.Add("@Type", SqlDbType.Int).Value = unchecked((int)liveType);
                cmd.Parameters.Add("@DeviceName", SqlDbType.NVarChar, 255).Value = m_device;
                cmd.Parameters.Add("@SubscriberXUID", SqlDbType.BigInt).Value = xuid;
                cmd.Parameters.Add("@Subscriber", SqlDbType.NChar, 16).Value = name;
                cmd.Parameters.Add("@SubscriberLocale", SqlDbType.NChar, 10).Value = locale;
                cmd.ExecuteNonQuery();

                cmd = null;                
            }
            finally
            {
                if (cmd != null)     cmd.Cancel();
                if (cxn != null)     cxn.Close();
            }            
        }
        
        /// <summary>
        /// Subscription management: This method removes a live alerts subscription for the given user
        /// </summary>
        public HResult DeleteLiveSubscription(ulong webID, ulong subscriptionID)
        {
            SqlConnection cxn = null;
            SqlCommand cmd = null;
            SqlDataReader reader = null;
            string  subscriberID;
            HResult hr = HResult.S_FALSE;
            
            IInterfaceInfo alertsApplicationInfo = Config.GetInterface(m_applicationServer, Interface.alertsApp);            
            cxn = new SqlConnection("Data Source=" + alertsApplicationInfo.IPAddressString + ";Initial Catalog=" + alertsApplicationInfo.DBName + ";Integrated Security=SSPI");
            
            try
            {
                subscriberID = FormatWebID(webID);
                
                cxn.Open();


                // Check to ensure that this user is modifying their own subscription 
                cmd = new SqlCommand("NSGetxLiveSubscriptionsSubscriptionBySubscriptionId", cxn);
                cmd.CommandType = CommandType.StoredProcedure;

                cmd.Parameters.Add("@SubscriptionId", SqlDbType.BigInt, 255).Value = subscriptionID;                
                
                reader = cmd.ExecuteReader();

                if ( (reader.Read()) && (reader.GetString(reader.GetOrdinal("subscriberID")) == subscriberID) )
                {
                    reader.Close();
                    
                    // Delete the subscription object                
                    cmd = new SqlCommand("NSDeletexLiveSubscriptionsSubscription", cxn);
                    cmd.CommandType = CommandType.StoredProcedure;
                    
                    cmd.Parameters.Add("@SubscriptionId", SqlDbType.BigInt, 255).Value = subscriptionID;                
                    
                    cmd.ExecuteNonQuery();

                    hr = HResult.S_OK;
                }
                else
                {
                    hr = HResult.XONLINE_E_ALERTS_SUBSCRIPTION_NOT_FOUND;
                }
                
                cmd = null;                
            }
            finally
            {
                if (reader != null)  reader.Close();
                if (cmd != null)     cmd.Cancel();
                if (cxn != null)     cxn.Close();
            }            

            return hr;
        }


        /// <summary>
        /// Subscription management: This method adds a content subscription for the given user
        /// </summary>
        public HResult AddContentSubscription(ulong webID, string locale, uint contentType, out ulong subscriptionID)
        {
            SqlConnection cxn = null;
            SqlCommand cmd = null;
            string  subscriberID;
            HResult hr = HResult.S_FALSE;
            
            IInterfaceInfo alertsApplicationInfo = Config.GetInterface(m_applicationServer, Interface.alertsApp);            
            cxn = new SqlConnection("Data Source=" + alertsApplicationInfo.IPAddressString + ";Initial Catalog=" + alertsApplicationInfo.DBName + ";Integrated Security=SSPI");
            
            try
            {
                subscriberID = FormatWebID(webID);
                
                cxn.Open();
    
                // Add the subscription object                
                cmd = new SqlCommand("NSInsertxContentSubscriptionsSubscription", cxn);
                cmd.CommandType = CommandType.StoredProcedure;

                SqlParameter ret = cmd.Parameters.Add("@Ret", SqlDbType.Int);
                ret.Direction = ParameterDirection.ReturnValue;                
                
                SqlParameter subID = cmd.Parameters.Add("@SubscriptionId", SqlDbType.BigInt);
                subID.Direction = ParameterDirection.Output;                
                
                cmd.Parameters.Add("@Enabled", SqlDbType.Bit).Value = true;
                cmd.Parameters.Add("@Type", SqlDbType.Int).Value = unchecked((int)contentType);
                cmd.Parameters.Add("@DeviceName", SqlDbType.NVarChar, 255).Value = m_device;
                cmd.Parameters.Add("@SubscriberLocale", SqlDbType.NChar, 10).Value = locale;
                cmd.Parameters.Add("@SubscriberId", SqlDbType.NVarChar, 255).Value = subscriberID;

                cmd.ExecuteNonQuery();

                hr = (uint)(int)ret.Value;
                subscriptionID = unchecked((ulong)(long)subID.Value);
                
                
                cmd = null;                
            }
            finally
            {
                if (cmd != null)     cmd.Cancel();
                if (cxn != null)     cxn.Close();
            }            

            return hr;
        }

        /// <summary>
        /// Subscription management: This method removes a content subscription for the given user
        /// </summary>
        public HResult EnumerateContentSubscriptions(ulong webID, ulong userID, out ContentSubscription[] subscriptions)
        {
            SqlConnection           cxn = null;
            SqlCommand              cmd = null;
            SqlDataReader           reader = null;
            ArrayList               subscriptionList = new ArrayList();
            ContentSubscription     sub;
            string                  subscriberID;
            HResult                 hr = HResult.S_FALSE;
            
            IInterfaceInfo alertsApplicationInfo = Config.GetInterface(m_applicationServer, Interface.alertsApp);            
            cxn = new SqlConnection("Data Source=" + alertsApplicationInfo.IPAddressString + ";Initial Catalog=" + alertsApplicationInfo.DBName + ";Integrated Security=SSPI");
            
            try
            {
                subscriberID = FormatWebID(webID);
                subscriptions = null;
                
                cxn.Open();
    
                // Add the subscription object                
                cmd = new SqlCommand("NSGetxContentSubscriptionsSubscriptionBySubscriberId", cxn);
                cmd.CommandType = CommandType.StoredProcedure;

                cmd.Parameters.Add("@SubscriberId", SqlDbType.NVarChar, 255).Value = subscriberID;
                
                reader = cmd.ExecuteReader();                

                while(reader.Read())
                {
                    sub = new ContentSubscription();

                    sub.subscriptionID = unchecked((ulong)reader.GetInt64(reader.GetOrdinal("SubscriptionID")));
                    sub.type = unchecked((uint)reader.GetInt32(reader.GetOrdinal("Type")));
                    sub.locale = reader.GetString(reader.GetOrdinal("SubscriberLocale")).Trim();

                    if ( (reader.GetBoolean(reader.GetOrdinal("Enabled"))) && (reader.GetString(reader.GetOrdinal("SubscriberID")) == subscriberID) && (reader.GetString(reader.GetOrdinal("DeviceName")) == m_device) )
                    {
                        subscriptionList.Add(sub);
                    }
                }

                if (subscriptionList.Count > 0)
                {
                    subscriptions = new ContentSubscription[subscriptionList.Count];
                    subscriptionList.CopyTo(subscriptions);

                    hr = HResult.S_OK;
                }
            }
            finally
            {
                if (reader != null)  reader.Close();
                if (cmd != null)     cmd.Cancel();
                if (cxn != null)     cxn.Close();
            }            

            return hr;
        }
        
        /// <summary>
        /// Subscription management: This method removes a content subscription for the given user
        /// </summary>
        public HResult DeleteContentSubscription(ulong webID, ulong subscriptionID)
        {
            SqlConnection cxn = null;
            SqlCommand cmd = null;
            SqlDataReader reader = null;
            string  subscriberID;
            HResult hr = HResult.S_FALSE;
            
            IInterfaceInfo alertsApplicationInfo = Config.GetInterface(m_applicationServer, Interface.alertsApp);            
            cxn = new SqlConnection("Data Source=" + alertsApplicationInfo.IPAddressString + ";Initial Catalog=" + alertsApplicationInfo.DBName + ";Integrated Security=SSPI");
            
            try
            {
                subscriberID = FormatWebID(webID);
                
                cxn.Open();


                // Check to ensure that this user is modifying their own subscription 
                cmd = new SqlCommand("NSGetxContentSubscriptionsSubscriptionBySubscriptionId", cxn);
                cmd.CommandType = CommandType.StoredProcedure;

                cmd.Parameters.Add("@SubscriptionId", SqlDbType.BigInt, 255).Value = subscriptionID;                
                
                reader = cmd.ExecuteReader();

                if ( (reader.Read()) && (reader.GetString(reader.GetOrdinal("subscriberID")) == subscriberID) )
                {
                    reader.Close();
                    
                    // Delete the subscription object                
                    cmd = new SqlCommand("NSDeletexContentSubscriptionsSubscription", cxn);
                    cmd.CommandType = CommandType.StoredProcedure;

                    cmd.Parameters.Add("@SubscriptionId", SqlDbType.BigInt, 255).Value = subscriptionID;                
                    
                    cmd.ExecuteNonQuery();

                    hr = HResult.S_OK;
                }
                else
                {
                    hr = HResult.XONLINE_E_ALERTS_SUBSCRIPTION_NOT_FOUND;
                }
                
                
                cmd = null;                
            }
            finally
            {
                if (reader != null)  reader.Close();
                if (cmd != null)     cmd.Cancel();
                if (cxn != null)     cxn.Close();
            }            

            return hr;
        }



        /// <summary>
        /// Title name management:
        ///  This method allows for the insertion or update the mapping of titleID + Locale to localized titleName string in the Alerts service. 
        ///  These alerts are only sourced from Titlemgr
        /// </summary>
        public HResult AddTitle(uint titleID, string titleName, string locale)
        {
            SqlConnection cxn = null;
            SqlCommand cmd = null;
            SqlParameter ret = null;
            HResult hr = HResult.S_FALSE;
            
            IInterfaceInfo alertsApplicationInfo = Config.GetInterface(m_applicationServer, Interface.alertsApp);            
            cxn = new SqlConnection("Data Source=" + alertsApplicationInfo.IPAddressString + ";Initial Catalog=" + alertsApplicationInfo.DBName + ";Integrated Security=SSPI");
            
            try
            {
                cxn.Open();


                // Start a titleEvent batch               
                cmd = new SqlCommand("NSEventBeginBatchxTitleEvents", cxn);
                cmd.CommandType = CommandType.StoredProcedure;

                ret = cmd.Parameters.Add("@Ret", SqlDbType.Int);
                ret.Direction = ParameterDirection.ReturnValue;                
                
                cmd.Parameters.Add("@ProviderName", SqlDbType.NVarChar, 255).Value = "xTitleEP";
                
                SqlParameter batchID = cmd.Parameters.Add("@EventBatchId", SqlDbType.BigInt);
                batchID.Direction = ParameterDirection.Output;                
                                
                cmd.ExecuteNonQuery();

                hr = (uint)(int)ret.Value;

                
                // Add the Event
                cmd = new SqlCommand("NSEventWritexTitleEvents", cxn);
                cmd.CommandType = CommandType.StoredProcedure;

                ret = cmd.Parameters.Add("@Ret", SqlDbType.Int);
                ret.Direction = ParameterDirection.ReturnValue;                
                
                cmd.Parameters.Add("@EventBatchId", SqlDbType.BigInt).Value = batchID.Value;
                cmd.Parameters.Add("@TitleId", SqlDbType.Int).Value = (int)titleID;
                cmd.Parameters.Add("@TitleLocale", SqlDbType.NVarChar, 10).Value = locale;
                cmd.Parameters.Add("@TitleName", SqlDbType.NVarChar, 30).Value = titleName;
                                                
                cmd.ExecuteNonQuery();

                hr = (uint)(int)ret.Value;


                // Commit the batch
                cmd = new SqlCommand("NSEventFlushBatchxTitleEvents", cxn);
                cmd.CommandType = CommandType.StoredProcedure;

                ret = cmd.Parameters.Add("@Ret", SqlDbType.Int);
                ret.Direction = ParameterDirection.ReturnValue;                
                
                cmd.Parameters.Add("@EventBatchId", SqlDbType.BigInt).Value = batchID.Value;
                cmd.Parameters.Add("@EventCount", SqlDbType.Int).Value = 1;
                                                
                cmd.ExecuteNonQuery();

                hr = (uint)(int)ret.Value;


                cmd = null;
            }
            finally
            {
                if (cmd != null)     cmd.Cancel();
                if (cxn != null)     cxn.Close();
            }            

            return hr;
        }


        /// <summary>
        /// Title name management:
        ///  This method inserts a live Alert in the Alerts Service. 
        ///  These typically are sourced from internal XBOX Live services. 
        /// </summary>
        public HResult AddLiveEvent(uint titleID, ushort liveType, ushort flags, ulong webIDRecipient, string senderGamertag, string data, ulong subscriberXUID, ulong senderXUID)
        {
            SqlConnection cxn = null;
            SqlCommand cmd = null;
            SqlParameter ret = null;
            string  subscriberID;
            HResult hr = HResult.S_FALSE;
            
            IInterfaceInfo alertsApplicationInfo = Config.GetInterface(m_applicationServer, Interface.alertsApp);            
            cxn = new SqlConnection("Data Source=" + alertsApplicationInfo.IPAddressString + ";Initial Catalog=" + alertsApplicationInfo.DBName + ";Integrated Security=SSPI");
            
            try
            {
                subscriberID = FormatWebID(webIDRecipient);

                
                cxn.Open();


                // Start a liveEvent batch               
                cmd = new SqlCommand("NSEventBeginBatchxLiveEvents", cxn);
                cmd.CommandType = CommandType.StoredProcedure;

                ret = cmd.Parameters.Add("@Ret", SqlDbType.Int);
                ret.Direction = ParameterDirection.ReturnValue;                
                
                cmd.Parameters.Add("@ProviderName", SqlDbType.NVarChar, 255).Value = "xLiveEP";
                
                SqlParameter batchID = cmd.Parameters.Add("@EventBatchId", SqlDbType.BigInt);
                batchID.Direction = ParameterDirection.Output;                
                                
                cmd.ExecuteNonQuery();

                hr = (uint)(int)ret.Value;

                
                // Add the Event
                cmd = new SqlCommand("NSEventWritexLiveEvents", cxn);
                cmd.CommandType = CommandType.StoredProcedure;

                ret = cmd.Parameters.Add("@Ret", SqlDbType.Int);
                ret.Direction = ParameterDirection.ReturnValue;                
                
                cmd.Parameters.Add("@EventBatchId", SqlDbType.BigInt).Value = batchID.Value;
                cmd.Parameters.Add("@Type", SqlDbType.Int).Value = liveType;
                cmd.Parameters.Add("@Flags", SqlDbType.SmallInt).Value = flags;
                cmd.Parameters.Add("@Sender", SqlDbType.NVarChar, 16).Value = senderGamertag;
                cmd.Parameters.Add("@Data", SqlDbType.NVarChar, 255).Value = data;
                cmd.Parameters.Add("@TitleId", SqlDbType.Int).Value = titleID;
                cmd.Parameters.Add("@SenderXUID", SqlDbType.BigInt).Value = senderXUID;
                cmd.Parameters.Add("@SubscriberXUID", SqlDbType.BigInt).Value = subscriberXUID;
                cmd.Parameters.Add("@SubscriberId", SqlDbType.NVarChar, 22).Value = subscriberID;

                cmd.ExecuteNonQuery();

                hr = (uint)(int)ret.Value;


                // Commit the batch
                cmd = new SqlCommand("NSEventFlushBatchxLiveEvents", cxn);
                cmd.CommandType = CommandType.StoredProcedure;

                ret = cmd.Parameters.Add("@Ret", SqlDbType.Int);
                ret.Direction = ParameterDirection.ReturnValue;                
                
                cmd.Parameters.Add("@EventBatchId", SqlDbType.BigInt).Value = batchID.Value;
                cmd.Parameters.Add("@EventCount", SqlDbType.Int).Value = 1;
                                                
                cmd.ExecuteNonQuery();

                hr = (uint)(int)ret.Value;


                cmd = null;
            }
            finally
            {
                if (cmd != null)     cmd.Cancel();
                if (cxn != null)     cxn.Close();
            }            

            return hr;
        }


        /// <summary>
        /// Title name management:
        ///  Thismethod inserts a content Alert in the Alerts Service. 
        ///  These typically are sourced from an XBOX.com producer via a tool
        /// </summary>
        public HResult AddContentEvent(uint contentType, string contentLocale, string contentMessage, DateTime deliveryTime)
        {
            SqlConnection cxn = null;
            SqlCommand cmd = null;
            SqlParameter ret = null;
            HResult hr = HResult.S_FALSE;
            
            IInterfaceInfo alertsApplicationInfo = Config.GetInterface(m_applicationServer, Interface.alertsApp);            
            cxn = new SqlConnection("Data Source=" + alertsApplicationInfo.IPAddressString + ";Initial Catalog=" + alertsApplicationInfo.DBName + ";Integrated Security=SSPI");
            
            try
            {
                cxn.Open();


                // Start a titleEvent batch               
                cmd = new SqlCommand("NSEventBeginBatchxContentEvents", cxn);
                cmd.CommandType = CommandType.StoredProcedure;

                ret = cmd.Parameters.Add("@Ret", SqlDbType.Int);
                ret.Direction = ParameterDirection.ReturnValue;                
                
                cmd.Parameters.Add("@ProviderName", SqlDbType.NVarChar, 255).Value = "xContentEP";
                
                SqlParameter batchID = cmd.Parameters.Add("@EventBatchId", SqlDbType.BigInt);
                batchID.Direction = ParameterDirection.Output;                
                                
                cmd.ExecuteNonQuery();

                hr = (uint)(int)ret.Value;

                
                // Add the Event
                cmd = new SqlCommand("NSEventWritexContentEvents", cxn);
                cmd.CommandType = CommandType.StoredProcedure;

                ret = cmd.Parameters.Add("@Ret", SqlDbType.Int);
                ret.Direction = ParameterDirection.ReturnValue;                
                
                cmd.Parameters.Add("@EventBatchId", SqlDbType.BigInt).Value = batchID.Value;
                cmd.Parameters.Add("@Type", SqlDbType.Int).Value = unchecked((int)contentType);
                cmd.Parameters.Add("@Locale", SqlDbType.NVarChar, 10).Value = contentLocale;
                cmd.Parameters.Add("@Message", SqlDbType.NVarChar, 255).Value = contentMessage;
                cmd.Parameters.Add("@DeliveryTime", SqlDbType.DateTime).Value = deliveryTime;
                    
                cmd.ExecuteNonQuery();

                hr = (uint)(int)ret.Value;


                // Commit the batch
                cmd = new SqlCommand("NSEventFlushBatchxContentEvents", cxn);
                cmd.CommandType = CommandType.StoredProcedure;

                ret = cmd.Parameters.Add("@Ret", SqlDbType.Int);
                ret.Direction = ParameterDirection.ReturnValue;                
                
                cmd.Parameters.Add("@EventBatchId", SqlDbType.BigInt).Value = batchID.Value;
                cmd.Parameters.Add("@EventCount", SqlDbType.Int).Value = 1;
                                                
                cmd.ExecuteNonQuery();

                hr = (uint)(int)ret.Value;


                cmd = null;
            }
            finally
            {
                if (cmd != null)     cmd.Cancel();
                if (cxn != null)     cxn.Close();
            }            

            return hr;
        }
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\Framework\CServiceMgr.cs ===
///
///  CServiceMgr.cs :  Manages database work in UODB for managing services.
///
///  Date:  April 6/2004
///  Dev:  lohab
///  Copyright (c) Microsoft Corporation.  All rights reserved.
///

using System;
using System.Data;
using System.Data.SqlClient;
using System.Collections;
using System.Collections.Specialized;
using System.IO;
using xonline.common.config;
using Microsoft.Webstore.WstClient;

namespace xonline.tools.framework
{
    /// <summary>
    /// Summary description for CServiceMgr.
    /// </summary>
    public class CServiceMgr
    {
        public CServiceMgr( string uodbDatabase, uint uodbDatabaseTimeout, CLog log )
        {
            _uodbDatabase = uodbDatabase;
            _uodbDatabaseTimeout = uodbDatabaseTimeout;
            _log = log;
        }

        /// <summary>
        /// Add_Service:  adds a service to the t_services table on all partitions
        /// </summary>
        /// <param name="serviceId">CService Id of the service to add.</param>
        /// <param name="kerbServiceName">Kerberos CService Name</param>
        /// <param name="kerbDomainName">Kerberos domain name</param>
        /// <param name="description">Description of what the service is about.</param>
        /// <param name="isMachineOnly">Is a machine only service flag</param>
        /// <returns>True if the service has been added or modified.  False for any other errors.</returns>
        public bool Add_Service( uint serviceId, string kerbServiceName, string kerbDomainName, string description, bool isMachineOnly )
        {
            bool result = true;
            ArrayList aConnections = new ArrayList();
            ArrayList aCommands = new ArrayList();
            int iPhysicalPartitions = 0;
            int queryResult = 0;

            try
            {
                using(WstConnection conn = new WstConnection(ConfigUtil.UodbWebstoreApp))
                {
                    conn.Open();
                    iPhysicalPartitions = conn.SqlPartitions.Count;
                    conn.Close();
                }

                for (int i = 0; i < iPhysicalPartitions; i++)
                {
                    WstConnection conn = null;
                    WstCommand cmd = null;
                    // Open a connection
                    conn = new WstConnection( _uodbDatabase );
                    conn.Open();

                    // save this connection so we can clean it later.
                    aConnections.Add(conn);

                    // Create a command to call the stored procedure
                    cmd = new WstCommand(
                        "dbo.p_svc_service_create",
                        conn,
                        i,
                        WstFailoverMode.PrimaryOnly);
                    cmd.CommandTimeout = (int)_uodbDatabaseTimeout;
                    cmd.PartitionType = WstPartitionType.Physical;
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.Transaction = conn.BeginTransaction();

                    // the return value.
                    cmd.Parameters.Add(new SqlParameter( "?", SqlDbType.Int, 4, ParameterDirection.ReturnValue,
                        true, 0, 0, "?", DataRowVersion.Current, 0 ) );

                    // add the params
                    cmd.Parameters.Add("@i_service_id", SqlDbType.Int).Value            = (int)serviceId;
                    cmd.Parameters.Add("@vc_kerb_service_name", SqlDbType.VarChar).Value = kerbServiceName;
                    cmd.Parameters.Add("@vc_kerb_domain_name", SqlDbType.VarChar).Value = kerbDomainName;
                    cmd.Parameters.Add("@vc_description", SqlDbType.VarChar).Value      = description;
                    cmd.Parameters.Add("@i_machine_only", SqlDbType.Int).Value          = isMachineOnly;

                    // keep this command to submit later.
                    aCommands.Add(cmd);

                    // Execute stored procedure
                    cmd.ExecuteNonQuery();

                    // read the params ... find the result.
                    queryResult = (int)(cmd.Parameters["?"].Value);

                    // check that the result is 0
                    if ( queryResult != 0 )
                    {
                        result = false;
                        throw new Exception("(ERROR) Failed to successfully modify UODB. " + GetStoredProcErrorString( queryResult) );
                    }

                }

                // commit our transactions.
                foreach(WstCommand cmd in aCommands)
                {
                    cmd.Transaction.Commit();
                }


            }
            catch( Exception e )
            {
                // TODO: (lohab) do necessary logging here.
                _log.Console( "ServiceMgr::Add_Service: (Error) " + e.ToString() );
                foreach(WstCommand cmd in aCommands)
                {
                    cmd.Transaction.Rollback();
                }
                result = false;
            }
            finally
            {
                foreach(WstConnection conn in aConnections)
                {
                    conn.Close();
                }
            }

            return result;
        }

        /// <summary>
        /// Add_Service_Instance:  Adds a service instance to the UODB.
        /// </summary>
        /// <param name="serviceId">CService id that this instance belongs to</param>
        /// <param name="titleId">Title Id for the instance</param>
        /// <param name="titleVersion">Title Version for the instance</param>
        /// <param name="titleRegion">Title Region for the instance</param>
        /// <param name="siteId">The site id for where this service can be found.</param>
        /// <param name="port">Port to talk to on that site</param>
        /// <param name="serviceAvailable">flags if the service should be available for access.</param>
        /// <returns>True if the instance has been added to all partitions in the UODB.  False for all errors.</returns>
        public bool Add_Service_Instance( uint serviceId, uint titleId, uint titleVersion, uint titleRegion,uint siteId, ushort port, bool serviceAvailable )
        {
            bool result = true;
            ArrayList aConnections = new ArrayList();
            ArrayList aCommands = new ArrayList();
            int iPhysicalPartitions = 0;
            int queryResult = 0;

            try
            {
                using(WstConnection conn = new WstConnection(ConfigUtil.UodbWebstoreApp))
                {
                    conn.Open();
                    iPhysicalPartitions = conn.SqlPartitions.Count;
                    conn.Close();
                }

                for (int i = 0; i < iPhysicalPartitions; i++)
                {
                    WstConnection conn = null;
                    WstCommand cmd = null;
                    // Open a connection
                    conn = new WstConnection( _uodbDatabase );
                    conn.Open();

                    // save this connection so we can clean it later.
                    aConnections.Add(conn);

                    // Create a command to call the stored procedure
                    cmd = new WstCommand(
                        "dbo.p_svc_service_create_instance",
                        conn,
                        i,
                        WstFailoverMode.PrimaryOnly);
                    cmd.CommandTimeout = (int)_uodbDatabaseTimeout;
                    cmd.PartitionType = WstPartitionType.Physical;
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.Transaction = conn.BeginTransaction();

                    // the return value.
                    cmd.Parameters.Add(new SqlParameter( "?", SqlDbType.Int, 4, ParameterDirection.ReturnValue,
                        true, 0, 0, "?", DataRowVersion.Current, 0 ) );

                    // add the params
                    cmd.Parameters.Add("@i_service_id", SqlDbType.Int).Value        = (int)serviceId;
                    cmd.Parameters.Add("@i_site_id", SqlDbType.Int).Value           = (int)siteId;
                    cmd.Parameters.Add("@i_title_Id", SqlDbType.Int).Value          = (int)titleId;
                    cmd.Parameters.Add("@i_title_version", SqlDbType.Int).Value     = (int)titleVersion;
                    cmd.Parameters.Add("@i_title_region", SqlDbType.Int).Value      = (int)titleRegion;
                    cmd.Parameters.Add("@i_port", SqlDbType.Int).Value              = (int)port;
                    cmd.Parameters.Add("@i_service_available", SqlDbType.Int).Value = serviceAvailable;

                    // keep this command to submit later.
                    aCommands.Add(cmd);

                    // Execute stored procedure
                    cmd.ExecuteNonQuery();

                    // read the params ... find the result.
                    queryResult = (int)(cmd.Parameters["?"].Value);

                    // check that the result is 0
                    if ( queryResult != 0 )
                    {
                        result = false;
                        throw new Exception("(ERROR) Failed to successfully modify UODB. " + GetStoredProcErrorString( queryResult) );
                    }

                }

                // commit our transactions.
                foreach(WstCommand cmd in aCommands)
                {
                    cmd.Transaction.Commit();
                }

            }
            catch( Exception e )
            {
                // TODO: (lohab) do necessary logging here.
                _log.Console( "ServiceMgr::Add_Service_Instance: (Error) " + e.ToString() );
                foreach(WstCommand cmd in aCommands)
                {
                    cmd.Transaction.Rollback();
                }
                result = false;
            }
            finally
            {
                foreach(WstConnection conn in aConnections)
                {
                    conn.Close();
                }
            }

            return result;
        }

        /// <summary>
        /// Add_Service_Offer:  Add an offer
        /// </summary>
        /// <param name="serviceId">Serivce Id</param>
        /// <param name="offerId">Offer Id</param>
        /// <returns>True if the service offer has been added.</returns>
        public bool Add_Service_Offer( uint serviceId, ulong offerId )
        {
            bool result = true;
            ArrayList aConnections = new ArrayList();
            ArrayList aCommands = new ArrayList();
            int iPhysicalPartitions = 0;
            int queryResult = 0;

            try
            {
                using(WstConnection conn = new WstConnection(ConfigUtil.UodbWebstoreApp))
                {
                    conn.Open();
                    iPhysicalPartitions = conn.SqlPartitions.Count;
                    conn.Close();
                }

                for (int i = 0; i < iPhysicalPartitions; i++)
                {
                    WstConnection conn = null;
                    WstCommand cmd = null;
                    // Open a connection
                    conn = new WstConnection( _uodbDatabase );
                    conn.Open();

                    // save this connection so we can clean it later.
                    aConnections.Add(conn);

                    // Create a command to call the stored procedure
                    cmd = new WstCommand(
                        "dbo.p_svc_service_create_offer",
                        conn,
                        i,
                        WstFailoverMode.PrimaryOnly);
                    cmd.CommandTimeout = (int)_uodbDatabaseTimeout;
                    cmd.PartitionType = WstPartitionType.Physical;
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.Transaction = conn.BeginTransaction();

                    // the return value.
                    cmd.Parameters.Add(new SqlParameter( "?", SqlDbType.Int, 4, ParameterDirection.ReturnValue,
                        true, 0, 0, "?", DataRowVersion.Current, 0 ) );

                    // add the params
                    cmd.Parameters.Add("@i_service_id", SqlDbType.Int).Value    = (int)serviceId;
                    cmd.Parameters.Add("@bi_offer_id", SqlDbType.BigInt).Value  = (long)offerId;

                    // keep this command to submit later.
                    aCommands.Add(cmd);

                    // Execute stored procedure
                    cmd.ExecuteNonQuery();

                    // read the params ... find the result.
                    queryResult = (int)(cmd.Parameters["?"].Value);

                    // check that the result is 0
                    if ( queryResult != 0 )
                    {
                        result = false;
                        throw new Exception("(ERROR) Failed to successfully modify UODB. " + GetStoredProcErrorString( queryResult) );
                    }
                }

                // commit our transactions.
                foreach(WstCommand cmd in aCommands)
                {
                    cmd.Transaction.Commit();
                }

            }
            catch( Exception e )
            {
                // TODO: (lohab) do necessary logging here.
                _log.Console( "ServiceMgr::Add_Service_Offer: (Error) " + e.ToString() );
                foreach(WstCommand cmd in aCommands)
                {
                    cmd.Transaction.Rollback();
                }
                result = false;
            }
            finally
            {
                foreach(WstConnection conn in aConnections)
                {
                    conn.Close();
                }
            }

            return result;
        }

        /// <summary>
        /// Get_Services:  Gets a list of all services in the UODB.
        /// </summary>
        /// <returns>A Hybrid Dictionary with all the service ids.  key - uint, value - uint.</returns>
        public HybridDictionary Get_Services()
        {
            HybridDictionary serviceList = new HybridDictionary();

            WstConnection conn = null;
            WstCommand cmd = null;
            WstDataReader wstReader = null;

            try
            {
                // Open a connection
                conn = new WstConnection( _uodbDatabase );
                conn.Open();

                // Create a command to call the stored procedure
                cmd = conn.CreateCommand();
                cmd.CommandTimeout = (int)_uodbDatabaseTimeout;
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.CommandText = "dbo.p_svc_service_get_all";

                cmd.PartitionType = WstPartitionType.Logical;
                cmd.Partition = WstCommand.AnyPartition;

                // Execute stored procedure
                wstReader = cmd.ExecuteReader();

                // read until the result set is complete.
                while ( wstReader.Read() )
                {
                    int serviceId = 0;

                    // read the service id.
                    serviceId = wstReader.GetInt32( 0 );

                    // read the row.
                    serviceList.Add( (uint)serviceId, (uint)serviceId );
                }

            }
            catch( Exception e )
            {
                _log.Console( "CServiceMgr::Get_Services: (Error) " + e.ToString() );
                serviceList = null;
            }
            finally
            {
                if (conn != null)
                {
                    conn.Close();
                    conn = null;
                }
                if ( wstReader != null )
                {
                    wstReader.Close();
                    wstReader = null;
                }
            }

            return serviceList;
        }

        /// <summary>
        /// Get_Service:  Gets details of a specfic service.
        /// </summary>
        /// <param name="serviceId">CService id</param>
        /// <returns>A CService structure with all the details associated with this service.</returns>
        public CService Get_Service( uint serviceId )
        {
            CService service = null;
            WstConnection conn = null;
            WstCommand cmd = null;
            WstDataReader wstReader = null;
            int instCtr = 0;

            try
            {
                // Open a connection
                conn = new WstConnection( _uodbDatabase );
                conn.Open();

                // Create a command to call the stored procedure
                cmd = conn.CreateCommand();
                cmd.CommandTimeout = (int)_uodbDatabaseTimeout;
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.CommandText = "dbo.p_svc_service_get";

                cmd.PartitionType = WstPartitionType.Logical;
                cmd.Partition = WstCommand.AnyPartition;

                cmd.Parameters.Add("@i_service_id", SqlDbType.Int).Value = (int)serviceId;

                // Execute stored procedure
                wstReader = cmd.ExecuteReader();

                // first row contains the sites information
                if ( wstReader.Read() )
                {
                    service = new CService(
                        serviceId, // service id
                        wstReader.GetString( 0 ),      // service kerb name
                        wstReader.GetString( 1 ),      // domain kerb name
                        wstReader.GetString( 2 ),      // description
                        ( wstReader.GetInt32( 3 ) == 1 ) // machine only service flag
                        );
                }
                else
                {
                    service = null;
                    goto Exit;
                }

                // get the next result.
                if ( ! wstReader.NextResult() )
                {
                    throw new Exception( "p_svc_service_get does not have to correct format.  Unable to read second result set.");
                }

                instCtr = 0;
                // the second result set contains all the service instances.
                while ( wstReader.Read() )
                {
                    CServiceInstance si = new CServiceInstance(
                        (uint)instCtr,
                        (uint)serviceId,
                        (uint)wstReader.GetInt32( 0 ),
                        (uint)wstReader.GetInt32( 1 ),
                        (uint)wstReader.GetInt32( 2 ),
                        (uint)wstReader.GetInt32( 3 ),
                        (ushort)wstReader.GetInt32( 4 ),
                        ( wstReader.GetInt32( 5 ) == 1 )
                        );

                    service.Instances.Add( instCtr, si );

                    instCtr++;
                }

                // get the next result.
                if ( ! wstReader.NextResult() )
                {
                    throw new Exception( "p_svc_service_get does not have to correct format.  Unable to read second result set.");
                }

                // third result set contains the list of associated services.
                while ( wstReader.Read() )
                {
                    ulong offerId = 0;

                    // read the site id.
                    offerId = (ulong)wstReader.GetInt64( 0 );

                    // read the row.
                    service.Offers.Add( (ulong)offerId, (ulong)offerId );
                }

            Exit:
                // finish reading
                if ( service == null )
                {
                    _log.FullTrace("CServiceMgr::Get_Service: No service data returned for requested service  " + serviceId + "." );
                }
            }
            catch( Exception e )
            {
                _log.Console( "CServiceMgr::Get_Service: (Error) " + e.ToString() );
                service = null;
            }
            finally
            {
                if (conn != null)
                {
                    conn.Close();
                    conn = null;
                }
                if ( wstReader != null )
                {
                    wstReader.Close();
                    wstReader = null;
                }
            }

            return service;
        }

        /// <summary>
        /// Remove_Service:  Remove service from the UODB.
        /// </summary>
        /// <param name="serviceId">Id of the service</param>
        /// <returns>True if the service is removed from all partitions.</returns>
        public bool Remove_Service( uint serviceId )
        {
            bool result = true;
            ArrayList aConnections = new ArrayList();
            ArrayList aCommands = new ArrayList();
            int iPhysicalPartitions = 0;
            int queryResult = 0;

            try
            {
                using(WstConnection conn = new WstConnection(ConfigUtil.UodbWebstoreApp))
                {
                    conn.Open();
                    iPhysicalPartitions = conn.SqlPartitions.Count;
                    conn.Close();
                }

                for (int i = 0; i < iPhysicalPartitions; i++)
                {
                    WstConnection conn = null;
                    WstCommand cmd = null;
                    // Open a connection
                    conn = new WstConnection( _uodbDatabase );
                    conn.Open();

                    // save this connection so we can clean it later.
                    aConnections.Add(conn);


                    // Create a command to call the stored procedure
                    cmd = new WstCommand(
                        "dbo.p_svc_service_remove",
                        conn,
                        i,
                        WstFailoverMode.PrimaryOnly);
                    cmd.CommandTimeout = (int)_uodbDatabaseTimeout;
                    cmd.PartitionType = WstPartitionType.Physical;
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.Transaction = conn.BeginTransaction();

                    // the return value.
                    cmd.Parameters.Add(new SqlParameter( "?", SqlDbType.Int, 4, ParameterDirection.ReturnValue,
                        true, 0, 0, "?", DataRowVersion.Current, 0 ) );

                    // add the params
                    cmd.Parameters.Add("@i_service_id", SqlDbType.Int).Value = (int)serviceId;

                    // keep this command to submit later.
                    aCommands.Add(cmd);

                    // Execute stored procedure
                    cmd.ExecuteNonQuery();

                    // read the params ... find the result.
                    queryResult = (int)(cmd.Parameters["?"].Value);

                    // check that the result is 0
                    if ( queryResult != 0 )
                    {
                        result = false;
                        throw new Exception("(ERROR) Failed to successfully modify UODB. " + GetStoredProcErrorString( queryResult) );
                    }

                }

                // commit our transactions.
                foreach(WstCommand cmd in aCommands)
                {
                    cmd.Transaction.Commit();
                }

            }
            catch( Exception e )
            {
                // TODO: (lohab) do necessary logging here.
                _log.Console( "ServiceMgr::Remove_Service: (Error) " + e.ToString() );
                foreach(WstCommand cmd in aCommands)
                {
                    cmd.Transaction.Rollback();
                }
                result = false;
            }
            finally
            {
                foreach(WstConnection conn in aConnections)
                {
                    conn.Close();
                }
            }

            return result;
        }

        public bool Remove_Service_Instance( CServiceInstance instance  )
        {
            return Remove_Service_Instance( instance.ServiceId, instance.TitleId, instance.TitleVersion, instance.TitleRegion );
        }

        public bool Remove_Service_Instance( uint serviceId, uint titleId, uint titleVersion, uint titleRegion )
        {
            bool result = true;
            ArrayList aConnections = new ArrayList();
            ArrayList aCommands = new ArrayList();
            int iPhysicalPartitions = 0;
            int queryResult = 0;

            try
            {
                using(WstConnection conn = new WstConnection(ConfigUtil.UodbWebstoreApp))
                {
                    conn.Open();
                    iPhysicalPartitions = conn.SqlPartitions.Count;
                    conn.Close();
                }

                for (int i = 0; i < iPhysicalPartitions; i++)
                {
                    WstConnection conn = null;
                    WstCommand cmd = null;
                    // Open a connection
                    conn = new WstConnection( _uodbDatabase );
                    conn.Open();

                    // save this connection so we can clean it later.
                    aConnections.Add(conn);

                    // Create a command to call the stored procedure
                    cmd = new WstCommand(
                        "dbo.p_svc_service_remove_instance",
                        conn,
                        i,
                        WstFailoverMode.PrimaryOnly);
                    cmd.CommandTimeout = (int)_uodbDatabaseTimeout;
                    cmd.PartitionType = WstPartitionType.Physical;
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.Transaction = conn.BeginTransaction();

                    // the return value.
                    cmd.Parameters.Add(new SqlParameter( "?", SqlDbType.Int, 4, ParameterDirection.ReturnValue,
                        true, 0, 0, "?", DataRowVersion.Current, 0 ) );

                    // add the params
                    cmd.Parameters.Add("@i_service_id", SqlDbType.Int).Value        = (int)serviceId;
                    cmd.Parameters.Add("@i_title_Id", SqlDbType.Int).Value          = (int)titleId;
                    cmd.Parameters.Add("@i_title_version", SqlDbType.Int).Value     = (int)titleVersion;
                    cmd.Parameters.Add("@i_title_region", SqlDbType.Int).Value      = (int)titleRegion;

                    // keep this command to submit later.
                    aCommands.Add(cmd);

                    // Execute stored procedure
                    cmd.ExecuteNonQuery();

                    // read the params ... find the result.
                    queryResult = (int)(cmd.Parameters["?"].Value);

                    // check that the result is 0
                    if ( queryResult != 0 )
                    {
                        result = false;
                        throw new Exception("Failed to successfully modify UODB. " + GetStoredProcErrorString( queryResult) );
                    }

                }

                // commit our transactions.
                foreach(WstCommand cmd in aCommands)
                {
                    cmd.Transaction.Commit();
                }

            }
            catch( Exception e )
            {
                // TODO: (lohab) do necessary logging here.
                _log.Console( "ServiceMgr::Remove_Service_Instance: (Error) " + e.ToString() );
                foreach(WstCommand cmd in aCommands)
                {
                    cmd.Transaction.Rollback();
                }
                result = false;
            }
            finally
            {
                foreach(WstConnection conn in aConnections)
                {
                    conn.Close();
                }
            }

            return result;
        }

        /// <summary>
        /// Remove_Service_Offer:  Removes a service offer from the UODB.
        /// </summary>
        /// <param name="serviceId">id of the service offer</param>
        /// <param name="offerId">id of the offer</param>
        /// <returns>True if successfully removed from all partitions.</returns>
        public bool Remove_Service_Offer( uint serviceId, ulong offerId )
        {
            bool result = true;
            ArrayList aConnections = new ArrayList();
            ArrayList aCommands = new ArrayList();
            int iPhysicalPartitions = 0;
            int queryResult = 0;

            try
            {
                using(WstConnection conn = new WstConnection(ConfigUtil.UodbWebstoreApp))
                {
                    conn.Open();
                    iPhysicalPartitions = conn.SqlPartitions.Count;
                    conn.Close();
                }

                for (int i = 0; i < iPhysicalPartitions; i++)
                {
                    WstConnection conn = null;
                    WstCommand cmd = null;
                    // Open a connection
                    conn = new WstConnection( _uodbDatabase );
                    conn.Open();

                    // save this connection so we can clean it later.
                    aConnections.Add(conn);

                    // Create a command to call the stored procedure
                    cmd = new WstCommand(
                        "dbo.p_svc_service_remove_offer",
                        conn,
                        i,
                        WstFailoverMode.PrimaryOnly);
                    cmd.CommandTimeout = (int)_uodbDatabaseTimeout;
                    cmd.PartitionType = WstPartitionType.Physical;
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.Transaction = conn.BeginTransaction();

                    // the return value.
                    cmd.Parameters.Add(new SqlParameter( "?", SqlDbType.Int, 4, ParameterDirection.ReturnValue,
                        true, 0, 0, "?", DataRowVersion.Current, 0 ) );

                    // add the params
                    cmd.Parameters.Add("@i_service_id", SqlDbType.Int).Value    = (int)serviceId;
                    cmd.Parameters.Add("@bi_offer_id", SqlDbType.BigInt).Value  = (long)offerId;

                    // keep this command to submit later.
                    aCommands.Add(cmd);

                    // Execute stored procedure
                    cmd.ExecuteNonQuery();

                    // read the params ... find the result.
                    queryResult = (int)(cmd.Parameters["?"].Value);

                    // check that the result is 0
                    if ( queryResult != 0 )
                    {
                        result = false;
                        throw new Exception("(ERROR) Failed to successfully modify UODB. " + GetStoredProcErrorString( queryResult) );
                    }

                }

                // commit our transactions.
                foreach(WstCommand cmd in aCommands)
                {
                    cmd.Transaction.Commit();
                }


            }
            catch( Exception e )
            {
                // TODO: (lohab) do necessary logging here.
                _log.Console( "ServiceMgr::Remove_Service_Offer: (Error) " + e.ToString()  );
                foreach(WstCommand cmd in aCommands)
                {
                    cmd.Transaction.Rollback();
                }
                result = false;
            }
            finally
            {
                foreach(WstConnection conn in aConnections)
                {
                    conn.Close();
                }
            }

            return result;
        }


        /// <summary>
        /// GetStoredProcErrorString:  Returns associated error string to stored proc error.
        /// </summary>
        /// <param name="error">Error value from stored proc</param>
        /// <returns>Error String</returns>
        private string GetStoredProcErrorString( int error )
        {
            string result = "";
            switch ( error )
            {
                case c_ServiceCreationFailed:
                {
                    result = "Failed to create the service in t_services.";
                }
                    break;
                case c_ServiceInstanceCreationFailed:
                {
                    result = "Failed to create the service instance in t_service_instances.";
                }
                    break;
                case c_ServiceOfferCreationFailed:
                {
                    result = "Failed to create the service offer instance in t_offer_services.  ";
                }
                    break;
                case c_ServiceOfferAlreadyExists:
                {
                    result = "Desired service offer instance already exists in t_offer_services.  ";
                }
                    break;
                case c_ServiceRemovalFailed:
                {
                    result = "Failed to remove service from t_services.  ";
                }
                    break;
                default:
                {
                    result = "Unknown Error: Error Value = " + error;
                }
                    break;
            }

            return result;
        }

        // attributes.
        protected string    _uodbDatabase;
        protected uint      _uodbDatabaseTimeout;
        protected CLog      _log;

        #region Stored Proc return errors
        protected const int    c_ServiceCreationFailed         = 5;
        protected const int    c_ServiceInstanceCreationFailed = 6;
        protected const int    c_ServiceOfferCreationFailed    = 7;
        protected const int    c_ServiceOfferAlreadyExists     = 8;
        protected const int    c_ServiceRemovalFailed          = 9;

        #endregion


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\Framework\CPathUtil.cs ===
using System;
using System.IO;

namespace xonline.tools.framework 
{
    public class CPathUtil
    {
        public static string AddPathTerminator(string sPath)
        {
            string sDirectorySeparator = new string(Path.DirectorySeparatorChar, 1);
            string sPathWithTerminator = sPath;
            if (!sPathWithTerminator.EndsWith(sDirectorySeparator))
            {
                sPathWithTerminator += sDirectorySeparator;
            }
            return sPathWithTerminator;
        }

        public static string AddExeExtension(string sFileName)
        {
            string sExtension = Path.GetExtension(sFileName);
            if (sExtension == String.Empty)
            {
                if (sFileName.EndsWith("."))
                {
                    return sFileName + "exe";
                }
                return sFileName + ".exe";
            }
            return sFileName;
        }

        public static string SearchPath(string sProgramName)
        {
            // check to make sure no path information was provided
            if (Path.GetDirectoryName(sProgramName) != String.Empty)
            {
                throw new ArgumentException("Path information should not be passed to "
                    + "CPathUtil.SearchPath()", "sProgramName");
            }

            // check the current directory for the program first
            string sPathAndFileName 
                = AddPathTerminator(Directory.GetCurrentDirectory())
                + sProgramName;
            if (File.Exists(sPathAndFileName))
            {
                return sPathAndFileName;
            }

            string sSystemPath = Environment.GetEnvironmentVariable("PATH");
            string[] rgsSystemPathSplit = sSystemPath.Split(';');
            foreach (string sPath in rgsSystemPathSplit)
            {
                string sPathWithTerminator = AddPathTerminator(sPath);
                sPathAndFileName = sPathWithTerminator + sProgramName;
                if (File.Exists(sPathAndFileName))
                {
                    return sPathAndFileName;
                }
            }

            // if we get here, the program wasn't found on the path
            return null;
        }

        public static void RemovePath(string sPath)
        {
            // first delete any subdirectories, recusively
            string[] rgsSubdirectories = Directory.GetDirectories(sPath);
            foreach (string sSubdirectory in rgsSubdirectories)
            {
                RemovePath(sSubdirectory);
            }

            // then delete any files, overriding any read-only attributes
            string[] rgsFiles = Directory.GetFiles(sPath);
            foreach (string sFile in rgsFiles)
            {
                FileAttributes fileAttrib = File.GetAttributes(sFile);
                if ((fileAttrib & FileAttributes.ReadOnly) != 0)
                {
                    // turn off the readonly bit, leave the rest alone
                    fileAttrib &= (~FileAttributes.ReadOnly);
                    File.SetAttributes(sFile, fileAttrib);
                }
                File.Delete(sFile);
            }

            // finally, now that the directory is empty, remove it
            Directory.Delete(sPath);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\Framework\CServer.cs ===
using System;
using System.Net;
using System.Text;

namespace xonline.tools.framework 
{
    /// <summary>
    /// A simple class that encapsulates an array of IP addresses that can be
    /// used to contact a particular server. A server is not limited to only one
    /// IP address, and we take advantage of that fact in our production data
    /// center by configuring each server with two IP addresses, each of which
    /// is routed through a separate switch. This, if all our code is written correctly,
    /// allows us to fail over gracefully if one switch fails, because there is still
    /// a completely independant route in operation. Therefore, when we want
    /// to identify a server in the tools framework, we use this class instead of
    /// using the IP directly. We also, for good measure, put the server name
    /// in this class.
    /// </summary>
    public class CServer
    {
        public string sServerName;
        public IPAddress[] rgipAddresses;

        public CServer()
        {
            sServerName = null;
            rgipAddresses = null;
        }

        public CServer(
            string _sServerName,
            IPAddress[] _rgipAddresses)
        {
            sServerName = _sServerName;
            rgipAddresses = _rgipAddresses;
        }

        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("{");
            sb.Append(sServerName == null ? "null" : sServerName);
            sb.Append(",");
            sb.Append(rgipAddresses == null ? "null" : CLog.CollectionToString(rgipAddresses));
            sb.Append("}");
            return sb.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\Framework\CSelectiveUpdate.cs ===
using Microsoft.Webstore.WstClient;
using System;
using System.Data;
using System.Data.SqlClient;
using System.Runtime.Serialization;

using xonline.common.config;

namespace xonline.tools.framework
{
    public class SerialNumNotExistException : Exception, ISerializable
    {
        const string message = "Serial number does not exist.";

        public SerialNumNotExistException( ) :
            base( message )
        { }

        public SerialNumNotExistException( string auxMessage ) :
            base( message + " - " + auxMessage )
        { }

        public SerialNumNotExistException( string auxMessage, Exception inner ) :
            base( message + " - " + auxMessage, inner )
        { }

        public SerialNumNotExistException( SerializationInfo info, StreamingContext context ) :
            base( info, context )
        { }
    }

    /// <summary>
    /// Summary description for Class1.
    /// </summary>
    class CSelectiveUpdate
    {
        public static void SetID(string strSerialNum, int iTitleID)
        {
            WstConnection conn = null;
            WstCommand cmd = null;
            SqlParameter ret = null;

            try
            {
                conn = new WstConnection(ConfigUtil.UodbWebstoreApp);
                conn.Open();

                cmd = conn.CreateCommand();
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.CommandText = "p_sput_set_beta_id";
                cmd.WstFailoverMode = WstFailoverMode.PrimaryThenSecondary;
                cmd.PartitionType = WstPartitionType.Physical;

                ret = new SqlParameter();
                ret.Direction = ParameterDirection.ReturnValue;
                cmd.Parameters.Add(ret);

                cmd.Parameters.Add("@vc_serial_num", SqlDbType.NVarChar).Value = strSerialNum;
                cmd.Parameters.Add("@i_beta_title_id", SqlDbType.Int).Value = iTitleID;

                for(int iPhysicalPartition = 0; iPhysicalPartition < conn.SqlPartitions.Count; ++iPhysicalPartition)
                {
                    cmd.Partition = iPhysicalPartition;
                    cmd.ExecuteNonQuery();

                    int hr = (int)(cmd.Parameters[0].Value);

                    //
                    //  Returns 0 on success, 1 if serial number not found
                    //

                    if(hr == 1)
                        continue;

                    //  Updated

                    return;
                }

                throw new SerialNumNotExistException();
            }
            finally
            {
                if(conn != null)
                {
                    conn.Close();
                    conn = null;
                }
            }
        }

        public static int Dump(string strSerialNum)
        {
            WstConnection conn = null;
            WstCommand cmd = null;
            WstDataReader dataset = null;

            try
            {
                conn = new WstConnection(ConfigUtil.UodbWebstoreApp);
                conn.Open();

                cmd = conn.CreateCommand();
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.CommandText = "p_sput_get_beta_id";
                cmd.WstFailoverMode = WstFailoverMode.PrimaryThenSecondary;
                cmd.PartitionType = WstPartitionType.Physical;

                cmd.Parameters.Add("@vc_serial_num", SqlDbType.NVarChar).Value = strSerialNum;

                //
                //  Iterate through the physical partitions
                //

                for(int iPhysicalPartition = 0; iPhysicalPartition < conn.SqlPartitions.Count; ++iPhysicalPartition)
                {
                    cmd.Partition = iPhysicalPartition;
                    dataset = cmd.ExecuteReader();

                    if (dataset.Read())
                    {
                        if(dataset.IsDBNull(0))
                            return 0;
                        else
                            return dataset.GetInt32(0);
                    }

                    dataset.Close();
                    dataset = null;
                }

                throw new SerialNumNotExistException();
            }
            finally
            {
                if(dataset != null)
                {
                    dataset.Close();
                    dataset = null;
                }

                if(conn != null)
                {
                    conn.Close();
                    conn = null;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\Framework\CServiceSync.cs ===
///
///  CServiceSync.cs :  Syncs service repository with UODB.
///  
///  Date:  April 6/2004
///  Dev:  lohab
///  Copyright (c) Microsoft Corporation.  All rights reserved.
///

using System;
using System.Data;
using System.Collections;
using System.Collections.Specialized;
using System.IO;

namespace xonline.tools.framework 
{
    /// <summary>
    /// Summary description for CSiteSync.
    /// </summary>
    public class CServiceSync
    {
        /// <summary>
        /// CServiceSync:  Static constructor that syncs repository and UODB.
        /// </summary>
        /// <param name="tid">Title id</param>
        /// <param name="repository">The repository object</param>
        /// <param name="serviceMgr">UODB service manager interface.  Already initialized.</param>
        /// <param name="bReportOnly">???</param>
        /// <param name="log">Logging interface.</param>
        public static void ServiceSync(
            CTitleId tid, 
            CRepository repository, 
            CServiceMgr serviceMgr,
            bool bReportOnly,
            CLog log
            )
        {
            CService[] repositoryServices = null;

            // ensure args
            if ( log == null )
            {
                throw new ArgumentException( "Error: log class is null.  This should not happen.", "log" );
            }

            if ( tid == null || 
                repository == null ||
                serviceMgr == null 
                )
            {
                log.Console( "Error:  CServiceSync::CServiceSync: Invalid parameters." );
                log.Console( "" );
                return;           
            }

            log.FullTrace("CServiceSync::CServiceSync:  Syncing repository and UODB for services." );

            try
            {
                // get the list from the respoitory.
                repository.TitleLSPServiceGetList( tid, ref repositoryServices );
                if ( repositoryServices == null )
                {
                    log.WriteLineV("Title: " + tid.uiTitleId + ".  No entries in repository.");
                    return;
                }

                // for each entry in the list.  Look up the corresponding entry in the UODB.
                foreach ( CService repoService in repositoryServices )
                {
                    CService uodbService = serviceMgr.Get_Service( repoService.ServiceId );
 
                    // if the entry is found.  Compare entries.
                    if ( uodbService == null )
                    {
                        // add the service.
                        if ( !bReportOnly )
                        {
                            if ( !AddModifyService( serviceMgr, repoService, log ) )
                            {
                                continue;
                            }
                        }

                        // add all the service instances in this list.
                        foreach ( Object objInst in repoService.Instances.Values )
                        {
                            CServiceInstance sInst = (CServiceInstance)objInst;
                            if ( !bReportOnly )
                            {
                                AddServiceInstance( serviceMgr, sInst, log );
                            }
                        }

                        // add all the service instances in this list.
                        foreach ( Object objOffer in repoService.Offers.Values )
                        {
                            ulong offer = (ulong)objOffer;
                            if ( !bReportOnly )
                            {
                                AddServiceOffer( serviceMgr, repoService.ServiceId, offer, log );
                            }
                        }
                    }
                    else
                    {
                        // check to see if the repo site is the same as the UODB site.
                        if ( uodbService == repoService )
                        {
                            // if the entries are equal, we do nothing.
                            continue;
                        }
                        else
                        {    
                            Object[] diffList = null;

                            if ( !bReportOnly )
                            {
                                // if the entries are different, update the UODB.
                                if ( !AddModifyService( serviceMgr, repoService, log ) )
                                {
                                    continue;
                                }
                            }

                            // FOR SERVICE INSTANCES
                            // look for mismatched entries in the 2 lists.
                            GetOutStandingSrvInst( uodbService.Instances, repoService.Instances, ref diffList );

                            // if they're in the uodb but not in the repository... delete them from UODB.
                            foreach( object obj in diffList )
                            {
                                CServiceInstance sInst = (CServiceInstance)obj;
                                if ( !bReportOnly )
                                {
                                    if (! serviceMgr.Remove_Service_Instance( sInst ) )
                                    {
                                        log.Console("WARNING:  Failed to successfully remove this service instance on all partitions.  " 
                                            + "  Service Instance: " 
                                            + sInst.ToString());
                                    }
                                }
                            }

                            // look for mismatched entries in the 2 lists.
                            GetOutStandingSrvInst( repoService.Instances, uodbService.Instances, ref diffList );

                            //  if they're in the repository but not in the uodb... add them from UODB.
                            foreach( object obj in diffList )
                            {
                                CServiceInstance sInst = (CServiceInstance)obj;
                                if ( !bReportOnly )
                                {
                                    AddServiceInstance( serviceMgr, sInst, log );
                                }
                            }

                            // FOR OFFERS
                            // look for mismatched entries in the 2 lists.
                            GetOutStandingOffers( uodbService.Offers, repoService.Offers, ref diffList );

                            // 
                            // if they're in the uodb but not in the repository... delete them from UODB.
                            foreach( object obj in diffList )
                            {
                                ulong offer = (ulong)obj;
                                if ( !bReportOnly )
                                {
                                    if (! serviceMgr.Remove_Service_Offer( repoService.ServiceId, offer ) )
                                    {
                                        log.Console("WARNING:  Failed to successfully remove this offer on all partitions.  " 
                                            + "Service Id: 0x" 
                                            + repoService.ServiceId.ToString("X") + ", OfferId: 0x" + offer.ToString("X") );
                                    }
                                }
                            }

                            // look for mismatched entries in the 2 lists.
                            GetOutStandingOffers( repoService.Offers, uodbService.Offers, ref diffList );

                            //  if they're in the repository but not in the uodb... add them from UODB.
                            foreach( object obj in diffList )
                            {
                                ulong offer = (ulong)obj;
                                if ( !bReportOnly )
                                {
                                    AddServiceOffer( serviceMgr, repoService.ServiceId, offer, log );
                                }
                            }

                        }
                    
                    }
                }
            }
            catch ( Exception e )
            {
                log.Console("Xbox.Tools.Framework.CServiceSync.CServiceSync: (Error) " + e.ToString() );
                throw new Exception( "Xbox.Tools.Framework.CServiceSync.CServiceSync: (Error) " + e.Message, e );
            }

        }

        /// <summary>
        /// AddModifyService:  Adds for modifies a service in the UODB using the mgr.
        /// </summary>
        /// <param name="serviceMgr">Service Mgr interface</param>
        /// <param name="service">Service to add for modify</param>
        /// <param name="log">Log interface to write too.</param>
        /// <returns>True if successful across all partitions.</returns>
        private static bool AddModifyService( CServiceMgr serviceMgr, CService service, CLog log )
        {
            bool result = true;

            // if the entry is not found in the database then add it.
            if ( !serviceMgr.Add_Service( service.ServiceId, 
                service.KerbServiceName,
                service.KerbDomainName,
                service.Description,
                service.IsMachineOnly )
                )
            {
                log.Console("WARNING:  Failed to successfully add/modify this service on all partitions.  " +
                    "Please investigate reason and try again.  " +                                 
                    "Service Data: " + service.ToString() );
                log.Console("");

                result = false;
            }

            return result;
        }

        /// <summary>
        /// AddServiceInstance:  Puts a service instance into the UODB.
        /// </summary>
        /// <param name="serviceMgr">Service Mgr interface with UODB.</param>
        /// <param name="sInst">Service Instance to add.</param>
        /// <param name="log">Logging interface.</param>
        private static void AddServiceInstance( CServiceMgr serviceMgr, CServiceInstance sInst, CLog log )
        {
            if ( ! serviceMgr.Add_Service_Instance( sInst.ServiceId,
                sInst.TitleId,
                sInst.TitleVersion,
                sInst.TitleRegion, 
                sInst.SiteId, 
                sInst.Port, 
                sInst.ServiceAvailable ) )
            {
                log.Console("WARNING:  Failed to successfully add this service instance on all partitions.  " +
                    "Please investigate reason and try again.  " +                                 
                    "Service Instance : " + sInst.ToString() );
                log.Console("");
            }                                                            
        }

        /// <summary>
        /// AddServiceOffer:  
        /// </summary>
        /// <param name="serviceMgr">Service Manager interface to UODB</param>
        /// <param name="serviceId">Service Id for this entry</param>
        /// <param name="offerId">Offer Id for this entry</param>
        /// <param name="log">Logging interface</param>
        private static void AddServiceOffer( CServiceMgr serviceMgr, uint serviceId, ulong offerId, CLog log )
        {
            if ( ! serviceMgr.Add_Service_Offer( serviceId, offerId) )
            {
                log.Console("WARNING:  Failed to successfully add this offer service on all partitions.  " +
                    "Please investigate reason and try again.  " +                                 
                    "Service Id : 0x" + serviceId.ToString("X") + ", Offer Id : 0x" + offerId.ToString("X")
                    );
                log.Console("");
            }                                                            
        }

        private static void GetOutStandingSrvInst( HybridDictionary compareFromList, HybridDictionary compareToList, ref object[] outArr )
        {
            ArrayList outArrList = new ArrayList();

            // for each entry in list 1
            foreach ( Object objX in compareFromList.Values )
            {
                CServiceInstance instX = (CServiceInstance)objX;
                bool bFound = false;

                // compare it to all the entries in list 2.
                foreach ( Object objY in compareToList.Values )
                {
                    CServiceInstance instY = (CServiceInstance)objY;

                    // if they are equal then mark it and stop looking.
                    if ( instX == instY )
                    {
                        bFound = true;
                        break;
                    }
                }

                // if not found add to the outstanding array.
                if ( !bFound )
                {
                    outArrList.Add( instX );
                }
            }

            outArr = outArrList.ToArray();
        }

        private static void GetOutStandingOffers( HybridDictionary compareFromList, HybridDictionary compareToList, ref object[] outArr )
        {
            ArrayList outArrList = new ArrayList();

            // for each entry in list 1
            foreach ( Object objX in compareFromList.Values )
            {
                ulong offerX = (ulong)objX;
                bool bFound = false;

                // compare it to all the entries in list 2.
                foreach ( Object objY in compareToList.Values )
                {
                    ulong offerY = (ulong)objY;
                    // if they are equal then mark it and stop looking.
                    if ( offerX == offerY )
                    {
                        bFound = true;
                        break;
                    }
                }

                // if not found add to the outstanding array.
                if ( !bFound )
                {
                    outArrList.Add( offerX );
                }
            }

            outArr = outArrList.ToArray();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\Framework\CSiteSync.cs ===
///
///  CSiteSync.cs :  Syncs Site repository with UODB.
///  
///  Date:  April 27/2004
///  Dev:  lohab
///  Copyright (c) Microsoft Corporation.  All rights reserved.
///

using System;
using System.Data;
using System.Collections.Specialized;
using System.IO;
using Microsoft.Webstore.WstClient;
    

namespace xonline.tools.framework 
{
    /// <summary>
    /// Summary description for CSiteSync.
    /// </summary>
    public class CSiteSync
    {
        public static void SiteSync(
            CTitleId tid, 
            CRepository repository, 
            CSiteMgr siteMgr,
            bool bReportOnly,
            CLog log
            )
        {
            CSite[] repositorySites = null;

            // ensure args
            if ( log == null )
            {
                throw new ArgumentException( "Error: log class is null.  This should not happen.", "log" );
            }

            if ( tid == null || 
                repository == null ||
                siteMgr == null 
                )
            {
                log.Console( "Error:  CSiteSync::CSiteSync: Invalid parameters." );
                log.Console( "" );
                return;           
            }

            try
            {
                // get the list from the respoitory.
                repository.TitleLSPSiteGetList( tid, ref repositorySites );

                if ( repositorySites == null )
                {
                    log.WriteLineV("Title: " + tid.uiTitleId + ".  No entries in repository.");
                    return;
                }

                // for each entry in the list.  Look up the corresponding entry in the UODB.
                foreach ( CSite repoSite in repositorySites )
                {
                    CSite uodbSite = siteMgr.Get_Site( repoSite.SiteId );
 
                    // if the entry is found.  Compare entries.
                    if ( uodbSite == null )
                    {
                        // if the entry is not found in the database then add it.
                        if ( !bReportOnly )
                        {
                            if ( !siteMgr.Add_Site( repoSite, repoSite.CreateNewKey ) )
                            {
                                log.Console("WARNING:  Failed to successfully add on all partitions.  " +
                                    "Please investigate reason and try again.  " +                                 
                                    "By performing another submit on this information, the " +
                                    "problem will be corrected once all partitions are operational.  Site: " +
                                    repoSite.ToString()
                                    );
                                log.Console("");

                                continue;
                            }
                        }

                    }
                    else
                    {
                        // check to see if the repo site is the same as the UODB site.
                        if ( uodbSite == repoSite )
                        {
                            // if the entries are equal, we do nothing.
                            continue;
                        }
                        else
                        {                    
                            if ( !bReportOnly )
                            {
                                // if the entries are different, update the UODB.
                                if ( !siteMgr.Add_Site( repoSite, repoSite.CreateNewKey ) )
                                {
                                    log.Console("WARNING:  Failed to successfully update all partitions.  " +
                                        "Please investigate reason and try again.  " + 
                                        "By performing another submit, the " +
                                        "problem will be corrected once all partitions are operational.  Site: " +
                                        repoSite.ToString() );

                                    log.Console("");
                                
                                }
                            }
                        }
                    
                    }

                    // if the create new key flag was set... set it to false now and submit.
                    if ( !bReportOnly )
                    {
                        if ( repoSite.CreateNewKey )
                        {
                            repoSite.CreateNewKey = false;
                            repository.TitleLSPSiteSet( tid, repoSite );
                            repository.TitleSubmit( tid, "Xbox.Tools.Framework.CSiteSync.CSiteSync: updating createnewkey setting.  Only necessary once." );
                        }
                    }

                }
            }
            catch ( Exception e )
            {
                log.Console("Xbox.Tools.Framework.CSiteSync.CSiteSync: (Error) " + e.ToString() );
                throw new Exception( "Xbox.Tools.Framework.CSiteSync.CSiteSync: (Error) " + e.Message, e);
            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\Framework\CSiteMgr.cs ===
///
///  CSiteMgr.cs :  Manages database work in UODB for managing sites.
///
///  Date:  April 6/2004
///  Dev:  lohab
///  Copyright (c) Microsoft Corporation.  All rights reserved.
///

using System;
using System.Data;
using System.Data.SqlClient;
using System.Collections;
using System.Collections.Specialized;
using System.IO;
using Microsoft.Webstore.WstClient;
using xonline.common.config;
using xonline.common.crypto;


namespace xonline.tools.framework
{
    /// <summary>
    /// Summary description for CSiteMgr.
    /// </summary>
    public class CSiteMgr
    {
        public CSiteMgr( string uodbDatabase, uint uodbDatabaseTimeout, string publicMasterKeyFile, CLog log )
        {
            _uodbDatabase = uodbDatabase;
            _uodbDatabaseTimeout = uodbDatabaseTimeout;
            _publicMasterKeyFile = publicMasterKeyFile;
            _log = log;
        }

        /// <summary>
        /// Add_Site:  Adds a site with given information to the UODB.
        /// </summary>
        /// <param name="newSite">CSite structure with information to add.</param>
        /// <param name="assignNewSiteKey">flags the need for a new key</param>
        /// <returns>True if the site was successfully created.</returns>
        public bool Add_Site( CSite newSite, bool assignNewSiteKey )
        {
            // make sure we're not accessing null
            if ( newSite == null )
            {
                return false;
            }

            // add the site
            return Add_Site( newSite.SiteId, newSite.KerbServiceName, newSite.KerbDomainName, newSite.Description, newSite.IpAddr, newSite.TicketLifeTime, assignNewSiteKey );
        }

        /// <summary>
        /// Add_Site:  Adds a site with given information to the UODB.
        /// </summary>
        /// <param name="siteId">Sites id</param>
        /// <param name="kerbSeviceName">Kerberos service name.</param>
        /// <param name="kerbDomainName">Kerberos domain name</param>
        /// <param name="description">Description of the site</param>
        /// <param name="ipAddr">Ip address for the site.</param>
        /// <param name="ticketLifeTime">KDC ticket lifetime for this site.</param>
        /// <param name="assignNewSiteKey">flags the creation of a new key.</param>
        /// <returns>True if the site was successfully created.</returns>
        public bool Add_Site( uint siteId, string kerbSeviceName, string kerbDomainName, string description, string ipAddr, int ticketLifeTime, bool assignNewSiteKey )
        {
            bool result = true;
            byte[] encryptedKey = {0};
            uint masterKeyVersion = 0;
            int queryResult = 0;

            try
            {

                // do we need to generate a key?
                if ( assignNewSiteKey )
                {
                    CryptoTools ct = new CryptoTools( );

                    // generate a random encrypted key
                    encryptedKey = ct.GenerateRandomEncryptedKey( c_SiteKeySize, _publicMasterKeyFile, ref masterKeyVersion );
                }

                using (SqlConnection conn = new SqlConnection(Config.NpdbConnectionString))
                {
                    conn.Open();

                    // Create a command to call the stored procedure
                    using (SqlCommand command = new SqlCommand())
                    {
                        command.CommandTimeout = Config.NpdbConnectionTimeout;
                        command.CommandType = CommandType.StoredProcedure;
                        command.CommandText = "dbo.p_svc_site_create";
                                
                        // the return value.
                        command.Parameters.Add(new SqlParameter( "?", SqlDbType.Int, 4, ParameterDirection.ReturnValue,
                            true, 0, 0, "?", DataRowVersion.Current, 0 ) );

                        // add the params
                        command.Parameters.Add("@i_site_id", SqlDbType.Int).Value           = (int)siteId;
                        command.Parameters.Add("@vc_kerb_service_name", SqlDbType.VarChar).Value = kerbSeviceName;
                        command.Parameters.Add("@vc_kerb_domain_name", SqlDbType.VarChar).Value = kerbDomainName;
                        command.Parameters.Add("@vc_ip", SqlDbType.VarChar).Value           = ipAddr;
                        command.Parameters.Add("@i_ticket_lifetime", SqlDbType.Int).Value   = (int)ticketLifeTime;
                        command.Parameters.Add("@i_masterkey_version", SqlDbType.Int).Value = masterKeyVersion;
                        command.Parameters.Add("@vb_key", SqlDbType.VarBinary).Value        = encryptedKey;

                        // Execute stored procedure
                        command.ExecuteNonQuery();

                        // read the params ... find the result.
                        queryResult = (int)(command.Parameters["?"].Value);

                        // check that the result is 0
                        if ( queryResult != 0 )
                        {
                            result = false;
                            throw new Exception("Failed to add site to NPDB. " + GetStoredProcErrorString( queryResult) );
                        }
                    }
                }
            }
            catch( Exception e )
            {
                // TODO: (lohab) do necessary logging here.
                _log.Console( "SiteMgr::Add_Site: (Error) " + e.ToString() );

                result = false;
            }

            return result;
        }

        /// <summary>
        /// Get_Sites:  Gets a list of all sites in the UODB.
        /// </summary>
        /// <returns>Hybrid diction of site ids... key = uint, value = uint</returns>
        public HybridDictionary Get_Sites()
        {
            HybridDictionary siteList = new HybridDictionary();

            try
            {
                using (SqlConnection conn = new SqlConnection(Config.NpdbConnectionString))
                {
                    conn.Open();

                    // Create a command to call the stored procedure
                    using (SqlCommand command = new SqlCommand())
                    {
                        command.CommandTimeout = Config.NpdbConnectionTimeout;
                        command.CommandType = CommandType.StoredProcedure;
                        command.CommandText = "dbo.p_svc_site_get_all";

                        using (SqlDataReader reader = command.ExecuteReader())
                        {
                            // read until the result set is complete.
                            while ( reader.Read() )
                            {
                                int siteId = 0;

                                // read the site id.
                                siteId = reader.GetInt32( 0 );

                                // read the row.
                                siteList.Add( (uint)siteId, (uint)siteId );
                            }
                        }
                    }
                }
            }
            catch( Exception e )
            {
                _log.Console( "CSiteMgr::Get_Sites: (Error) " + e.ToString() );
                siteList = null;
            }

            return siteList;
        }

        /// <summary>
        /// Get_Site:  Gets specific information about a site.
        /// </summary>
        /// <param name="siteId">CSite id of the desired site.</param>
        /// <returns>CSite struct with filled in CSite information.</returns>
        public CSite Get_Site( uint siteId )
        {
            CSite site = null;
            WstConnection conn = null;
            WstCommand cmd = null;
            WstDataReader wstReader = null;

            try
            {
                using (SqlConnection sqlConn = new SqlConnection(Config.NpdbConnectionString))
                {
                    sqlConn.Open();

                    // Create a command to call the stored procedure
                    using (SqlCommand command = new SqlCommand())
                    {
                        command.CommandTimeout = Config.NpdbConnectionTimeout;
                        command.CommandType = CommandType.StoredProcedure;
                        command.CommandText = "dbo.p_svc_site_get";
                                
                        // add the params
                        command.Parameters.Add("@i_site_id", SqlDbType.Int).Value = (int)siteId;

                        // Execute stored procedure
                        using (SqlDataReader reader = command.ExecuteReader())
                        {
                            // first row contains the sites information
                            if ( reader.Read() )
                            {
                                site = new CSite(
                                                 (uint)(reader.GetInt32( 0 )), // site id
                                                 reader.GetString( 1 ),      // service kerb name
                                                 reader.GetString( 2 ),      // domain kerb name
                                                 "",                            // description
                                                 reader.IsDBNull( 3 ) ? 0 :reader.GetInt32( 3 ),       // ticketlifetime
                                                 reader.GetString( 4 )       // ip
                                            );

                            }
                        }
                    }
                }
                
                // Open a connection
                conn = new WstConnection( _uodbDatabase );
                conn.Open();

                // Create a command to call the stored procedure
                cmd = conn.CreateCommand();
                cmd.CommandTimeout = (int)_uodbDatabaseTimeout;
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.CommandText = "dbo.p_svc_site_get";

                cmd.PartitionType = WstPartitionType.Logical;
                cmd.Partition = WstCommand.AnyPartition;

                cmd.Parameters.Add("@i_site_id", SqlDbType.Int).Value = (int)siteId;

                // Execute stored procedure
                wstReader = cmd.ExecuteReader();

                // result set contains the list of associated services.
                while ( wstReader.Read() )
                {
                    int serviceId = 0;

                    // read the site id.
                    serviceId = wstReader.GetInt32( 0 );
                    CService service = new CService();
                    service.ServiceId = (uint)serviceId;

                    // read the row.
                    if ( ! site.Services.Contains( (uint)serviceId ) )
                    {
                        site.Services.Add( (uint)serviceId, service );
                    }
                }

            }
            catch( Exception e )
            {
                _log.Console( "CSiteMgr::Get_Sites: (Error) " + e.ToString() );
                site = null;
            }
            finally
            {
                if (conn != null)
                {
                    conn.Close();
                    conn = null;
                }
                if ( wstReader != null )
                {
                    wstReader.Close();
                    wstReader = null;
                }
            }

            return site;
        }

        /// <summary>
        /// Remove_Site:  Removes a site from UODB.
        /// </summary>
        /// <param name="siteId">Id of site to remove.</param>
        /// <returns>True if the site is remove otherwise false.</returns>
        public bool Remove_Site( uint siteId )
        {
            bool result = true;
            ArrayList aConnections = new ArrayList();
            ArrayList aCommands = new ArrayList();
            int iPhysicalPartitions = 0;
            int queryResult = 0;


            try
            {
                using(WstConnection conn = new WstConnection(ConfigUtil.UodbWebstoreApp))
                {
                    conn.Open();
                    iPhysicalPartitions = conn.SqlPartitions.Count;
                    conn.Close();
                }

                for (int i = 0; i < iPhysicalPartitions; i++)
                {
                    WstConnection conn = null;
                    WstCommand cmd = null;

                    // Open a connection
                    conn = new WstConnection( _uodbDatabase );
                    conn.Open();

                    // save this connection so we can clean it later.
                    aConnections.Add(conn);

                    // Create a command to call the stored procedure
                    cmd = new WstCommand(
                        "dbo.p_svc_site_delete",
                        conn,
                        i,
                        WstFailoverMode.PrimaryOnly);
                    cmd.CommandTimeout = (int)_uodbDatabaseTimeout;
                    cmd.PartitionType = WstPartitionType.Physical;
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.Transaction = conn.BeginTransaction();

                    // the return value.
                    cmd.Parameters.Add(new SqlParameter( "?", SqlDbType.Int, 4, ParameterDirection.ReturnValue,
                        true, 0, 0, "?", DataRowVersion.Current, 0 ) );

                    // add the params
                    cmd.Parameters.Add("@i_site_id", SqlDbType.Int).Value           = (int)siteId;

                    // keep this command to submit later.
                    aCommands.Add(cmd);

                    // Execute stored procedure
                    cmd.ExecuteNonQuery();

                    // read the params ... find the result.
                    queryResult = (int)(cmd.Parameters["?"].Value);

                    // check that the result is 0
                    if ( queryResult != 0 )
                    {
                        result = false;
                        throw new Exception("(ERROR) Failed to successfully modify UODB. " + GetStoredProcErrorString( queryResult) );
                    }

                }

                using (SqlConnection conn = new SqlConnection(Config.NpdbConnectionString))
                {
                    conn.Open();

                    // Create a command to call the stored procedure
                    using (SqlCommand command = new SqlCommand())
                    {
                        command.CommandTimeout = Config.NpdbConnectionTimeout;
                        command.CommandType = CommandType.StoredProcedure;
                        command.CommandText = "dbo.p_svc_site_delete";
                                
                        // the return value.
                        command.Parameters.Add(new SqlParameter( "?", SqlDbType.Int, 4, ParameterDirection.ReturnValue,
                            true, 0, 0, "?", DataRowVersion.Current, 0 ) );

                        // add the params
                        command.Parameters.Add("@i_site_id", SqlDbType.Int).Value           = (int)siteId;

                        // Execute stored procedure
                        command.ExecuteNonQuery();

                        // read the params ... find the result.
                        queryResult = (int)(command.Parameters["?"].Value);

                        // check that the result is 0
                        if ( queryResult != 0 )
                        {
                            result = false;
                            throw new Exception("Failed to delete site from NPDB. " + GetStoredProcErrorString( queryResult) );
                        }
                    }
                }
                

                // commit our transactions.
                foreach(WstCommand cmd in aCommands)
                {
                    cmd.Transaction.Commit();
                }

            }
            catch( Exception e )
            {
                // TODO: (lohab) do necessary logging here.
                _log.Console( "SiteMgr::Remove_Site: (Error) " + e.ToString() );
                foreach(WstCommand cmd in aCommands)
                {
                    cmd.Transaction.Rollback();
                }

                result = false;
            }
            finally
            {
                foreach(WstConnection conn in aConnections)
                {
                    conn.Close();
                }
            }

            return result;
        }


        /// <summary>
        /// GetStoredProcErrorString:  Returns associated error string to stored proc error.
        /// </summary>
        /// <param name="error">Error value from stored proc</param>
        /// <returns>Error String</returns>
        private string GetStoredProcErrorString( int error )
        {
            string result = "";
            switch ( error )
            {
                case c_KeyCreationFailed:
                {
                    result = "Failed to create the site key in t_service_keys.";
                }
                    break;
                case c_SiteCreationFailed:
                {
                    result = "Failed to create the site in t_sites.";
                }
                    break;
                case c_SiteRemoveFailed:
                {
                    result = "Failed to remove the site from t_sites.  ";
                }
                    break;
                case c_KeyRemoveFailed:
                {
                    result = "Failed to remove the site key from t_service_keys.  ";
                }
                    break;
                default:
                {
                    result = "Unknown Error: Error Value = " + error;
                }
                    break;
            }

            return result;
        }

        // constants
        protected const uint    c_keyVersionSize    = 4;            // key versions are 4 bytes big.
        protected const string  c_cspContainerName  = "XOMasterKey";
        protected const string  c_cspProviderName   = "Microsoft Enhanced Cryptographic Provider";
        protected const uint    c_PROV_RSA_FULL     = 1;
        protected const uint    c_SiteKeySize       = 16;

        // attributes.
        protected string    _uodbDatabase;
        protected uint      _uodbDatabaseTimeout;
        protected string    _publicMasterKeyFile;
        protected CLog      _log;

        #region Stored Proc return errors
        protected const int    c_KeyCreationFailed  = 1;
        protected const int    c_SiteCreationFailed = 2;
        protected const int    c_SiteRemoveFailed   = 3;
        protected const int    c_KeyRemoveFailed    = 4;
        protected const int    c_SiteUpdateFailed   = 5;

        #endregion


    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\Framework\CSiteServiceNodes.cs ===
///
///  CSiteServiceNodes.cs :  Nodes/structures used to represent service and site data.
///  
///  Date:  April 6/2004
///  Dev:  lohab
///  Copyright (c) Microsoft Corporation.  All rights reserved.
///

using System;
using System.Collections.Specialized;
using System.Globalization;
using System.Xml;

namespace xonline.tools.framework
{
    public class CSite
    {
        public CSite()
        {
            _siteId = 0;
            _kerbServiceName = "invalid";
            _kerbDomainName = "invalid";
            _ipAddr = "0.0.0.0";
            _description = "";
            _ticketLifetime = 129600;
            _createNewKey = false;
            _serviceList = new HybridDictionary();
        }

        public CSite( uint siteid, string kerbSeviceName, string kerbDomainName, string description, int ticketLifetime, string ipAddr )
        {
            _siteId = siteid;
            _kerbServiceName = kerbSeviceName;
            _kerbDomainName = kerbDomainName;
            _ipAddr = ipAddr;
            _description = description;
            _ticketLifetime = ticketLifetime;
            _createNewKey = false;
            _serviceList = new HybridDictionary();
        }

        public CSite( XmlNode xml )
        {
            if ( ! xml.HasChildNodes )
            {
                throw new Exception( "CSite::CSite(): ERROR:  XML format invalid.  CSite data is missing." );
            }

            _siteId = 0;
            _kerbServiceName = "invalid";
            _kerbDomainName = "invalid";
            _ipAddr = "0.0.0.0";
            _description = "";
            _ticketLifetime = 129600;
            _createNewKey = false;

            foreach (XmlNode item in xml.ChildNodes )
            {
                switch( item.LocalName.ToLower() )
                {
                    case "siteid":
                    {
                        if ( item.InnerText.StartsWith("0x") )
                        {
                            _siteId = UInt32.Parse( item.InnerText.Substring( 2 ), NumberStyles.HexNumber );
                        }
                        else
                        {
                            _siteId = UInt32.Parse( item.InnerText );
                        }
                    }
                        break;
                    case "kerbservicename":
                        _kerbServiceName = item.InnerText;
                        break;
                    case "kerbdomainname":
                        _kerbDomainName = item.InnerText;
                        break;
                    case "ip":
                        _ipAddr = item.InnerText;
                        break;
                    case "ticketlifetime":
                        _ticketLifetime = Int32.Parse( item.InnerText );
                        break;
                    case "description":
                        _description = item.InnerText;
                        break;
                    case "createnewkey":
                        _createNewKey = bool.Parse( item.InnerText );
                        break;
                    default:
                        // don't worry about extra information... it may pertain to later versions.
                        break;                                   
                }
            }

            // set up the new service list.
            _serviceList = new HybridDictionary();            

        }

        public override bool Equals(object obj)
        {
            if ( obj.GetType() != this.GetType() )
            {
                return false;
            }
            return ( this == (CSite)obj );
        }

        public override int GetHashCode()
        {
            return base.GetHashCode ();
        }

        public override string ToString()
        {
            string result = "";
            
            result += "Siteid=0x" + _siteId.ToString("X") + ", ";
            result += "kerbservicename=\"" + _kerbServiceName+ "\", ";
            result += "kerbdomainname=" + _kerbDomainName + "\", ";
            result += "description=\"" + _description + "\", ";
            result += "ticketlifetime=" + _ticketLifetime + ", ";
            result += "ip=\"" + _ipAddr + "\", ";
            result += "createnewkey=\"" + _createNewKey + "\" ";

            return result;
        }

        public XmlNode ToXml( XmlDocument xmlDoc )
        {
            XmlNode xmlResult = xmlDoc.CreateElement("site");
            XmlNode xmlEle = null;
            
            // add the service id.
            xmlEle = xmlDoc.CreateElement("siteid");
            xmlEle.InnerText = "0x" + _siteId.ToString("X");
            xmlResult.AppendChild( xmlEle );

            // add the kerb service naem.
            xmlEle = xmlDoc.CreateElement("kerbservicename");
            xmlEle.InnerText = _kerbServiceName.ToString();
            xmlResult.AppendChild( xmlEle );

            // add the kerb domain name.
            xmlEle = xmlDoc.CreateElement("kerbdomainname");
            xmlEle.InnerText = _kerbDomainName.ToString();
            xmlResult.AppendChild( xmlEle );

            // add the description.
            xmlEle = xmlDoc.CreateElement("description");
            xmlEle.InnerText = _description.ToString();
            xmlResult.AppendChild( xmlEle );

            // add the new ip.
            xmlEle = xmlDoc.CreateElement("ip");
            xmlEle.InnerText = _ipAddr.ToString();
            xmlResult.AppendChild( xmlEle );

            // add the create new keys.
            xmlEle = xmlDoc.CreateElement("createnewkey");
            xmlEle.InnerText = _createNewKey.ToString();
            xmlResult.AppendChild( xmlEle );

            return xmlResult;
        }


        public static bool operator == ( CSite site1, CSite site2 )
        {
            if ( Object.ReferenceEquals( site1, site2 ) )
            {
                return true;
            }
            else if( Object.ReferenceEquals( site1, null ) || Object.ReferenceEquals( site2, null )  )
            {
                return false;
            }

            return (
                    site1.SiteId          == site2.SiteId           &&
                    site1.KerbServiceName == site2.KerbServiceName  &&
                    site1.KerbDomainName  == site2.KerbDomainName   &&
                    site1.IpAddr          == site2.IpAddr           &&
                    site1.Description     == site2.Description      &&
                    site1.CreateNewKey    == site2.CreateNewKey );
        }

        public static bool operator != ( CSite site1, CSite site2 )
        {
            return !( site1 == site2 );
        }

        // properties.

        // CSite Id
        public uint SiteId
        {
            get
            {
                return _siteId;
            }
            set
            {
                _siteId = value;
            }
        }

        // Kerberos service name of site
        public string KerbServiceName
        {
            get
            {
                return _kerbServiceName;
            }
            set
            {
                _kerbServiceName = value;
            }
        }

        // kerberos domain name of site
        public string KerbDomainName
        {
            get
            {
                return _kerbDomainName;
            }
            set
            {
                _kerbDomainName = value;
            }
        }

        // description of site
        public string Description
        {
            get
            {
                return _description;
            }
            set
            {
                _description = value;
            }
        }

        // ip address of site
        public string IpAddr
        {
            get
            {
                return _ipAddr;
            }
            set
            {
                _ipAddr = value;
            }
        }

        // ticket lifetime in seconds of site
        public int TicketLifeTime
        {
            get
            {
                return _ticketLifetime;
            }
            set
            {
                _ticketLifetime = value;
            }
        }

        // flags creating new key for the site.
        public bool CreateNewKey
        {
            get
            {
                return _createNewKey;
            }
            set
            {
                _createNewKey = value;
            }
        }

        // Associated Services.
        public HybridDictionary Services
        {
            get
            {
                return _serviceList;
            }
        }

        // attributes
        protected uint              _siteId;
        protected string            _kerbServiceName;
        protected string            _kerbDomainName;
        protected string            _description;
        protected int               _ticketLifetime;
        protected string            _ipAddr;
        protected bool              _createNewKey;
        protected HybridDictionary  _serviceList;
    }        

    public class CService
    {
        public CService()
        {
            _serviceId = 0;
            _kerbServiceName = "invalid";
            _kerbDomainName = "invalid";
            _description = "";
            _isMachineOnly = false;
            _instances = new HybridDictionary();
            _offers = new HybridDictionary();
        }

        public CService( uint serviceId, string kerbSeviceName, string kerbDomainName, string description, bool isMachineOnly )
        {
            _serviceId = serviceId;
            _kerbServiceName = kerbSeviceName;
            _kerbDomainName = kerbDomainName;
            _description = description;
            _isMachineOnly = isMachineOnly;
            _instances = new HybridDictionary();
            _offers = new HybridDictionary();
        }

        public CService( XmlNode xml )
        {
            uint instanceCnt = 0;

            if ( ! xml.HasChildNodes )
            {
                throw new Exception( "CService::CService(): ERROR:  XML format invalid.  CSite data is missing." );
            }

            _serviceId = 0;
            _kerbServiceName = "invalid";
            _kerbDomainName = "invalid";
            _description = "";
            _isMachineOnly = false;

            // fill in the instances
            _instances = new HybridDictionary();
            instanceCnt = 0;

            // fill in the offers.
            _offers = new HybridDictionary();


            // we need the service id before we can continue.  This is slow be will be worth it.
            foreach (XmlNode item in xml.ChildNodes )
            {
                switch( item.LocalName.ToLower() )
                {
                    case "serviceid":
                    {
                        if ( item.InnerText.StartsWith("0x") )
                        {
                            _serviceId = UInt32.Parse( item.InnerText.Substring( 2 ), NumberStyles.HexNumber );
                        }
                        else
                        {
                            _serviceId = UInt32.Parse( item.InnerText );
                        }
                    }
                        break;
                    default:
                        break;
                }
            }

            // read the rest of the information.
            foreach (XmlNode item in xml.ChildNodes )
            {
                switch( item.LocalName.ToLower() )
                {
                    case "kerbservicename":
                        _kerbServiceName = item.InnerText;
                        break;
                    case "kerbdomainname":
                        _kerbDomainName = item.InnerText;
                        break;
                    case "description":
                        _description = item.InnerText;
                        break;
                    case "machineonly":
                        _isMachineOnly = bool.Parse( item.InnerText );
                        break;
                    case "instance":
                    {
                        _instances.Add( instanceCnt, new CServiceInstance( instanceCnt, _serviceId, item ) );
                        instanceCnt++;
                    }
                        break;
                    case "offer":
                    {
                        bool hasSomething = false;
                        // check for children.
                        if (! item.HasChildNodes )
                        {
                            throw new Exception( "CService::CService(): ERROR:  XML format invalid.  Offer element has no child nodes.  It should have at least an offer id." );
                        }

                        // look through children for offerid.
                        foreach ( XmlNode offerElement in item )
                        {
                            if ( offerElement.LocalName.ToLower() == "offerid" )
                            {
                                ulong offerId = 0;
                                if ( item.InnerText.StartsWith("0x") )
                                {
                                    offerId = UInt64.Parse( offerElement.InnerText.Substring( 2 ), NumberStyles.HexNumber );
                                }
                                else
                                {
                                    offerId = UInt64.Parse( offerElement.InnerText );
                                }
                                _offers.Add( offerId, offerId );
                                hasSomething = true;
                            }
                        }

                        // check to make sure we at least got 1 offer id.
                        if ( !hasSomething )
                        {
                            throw new Exception( "CService::CService(): ERROR:  XML format invalid.  Offer element has no child nodes.  It should have at least an offer id." );
                        }
                    }
                        break;
                    default:
                        // don't worry about extra information... it may pertain to later versions.
                        break;                                   
                }
            }
        }

        public override bool Equals(object obj)
        {
            if ( obj.GetType() != this.GetType() )
            {
                return false;
            }
            return ( this == (CService)obj );
        }

        public override int GetHashCode()
        {
            return base.GetHashCode ();
        }

        public override string ToString()
        {
            string result = "";
            
            result += "Serviceid=0x" + _serviceId.ToString("X") + ", ";
            result += "kerbservicename=\"" + _kerbServiceName+ "\", ";
            result += "kerbdomainname=\"" + _kerbDomainName + "\", ";
            result += "description=\"" + _description + "\", ";
            result += "Machine Only=\"" + this._isMachineOnly + "\" \n";

            return result;
        }

        /// <summary>
        /// ToXml:  Translates this structure into an XML node.
        /// </summary>
        /// <param name="xmlDoc">XML document</param>
        /// <returns>Node with information from this structure.</returns>
        public XmlNode ToXml( XmlDocument xmlDoc )
        {
            XmlNode xmlResult = xmlDoc.CreateElement("service");
            XmlNode xmlEle = null;
            
            // add the service id.
            xmlEle = xmlDoc.CreateElement("serviceid");
            xmlEle.InnerText = "0x" + _serviceId.ToString("X");
            xmlResult.AppendChild( xmlEle );

            // add the kerb service naem.
            xmlEle = xmlDoc.CreateElement("kerbservicename");
            xmlEle.InnerText = _kerbServiceName.ToString();
            xmlResult.AppendChild( xmlEle );

            // add the kerb domain name.
            xmlEle = xmlDoc.CreateElement("kerbdomainname");
            xmlEle.InnerText = _kerbDomainName.ToString();
            xmlResult.AppendChild( xmlEle );

            // add the description.
            xmlEle = xmlDoc.CreateElement("description");
            xmlEle.InnerText = _description.ToString();
            xmlResult.AppendChild( xmlEle );

            // add the machine only flag.
            xmlEle = xmlDoc.CreateElement("machineonly");
            xmlEle.InnerText = _isMachineOnly.ToString();
            xmlResult.AppendChild( xmlEle );

            foreach ( Object objInst in _instances.Values )
            {
                CServiceInstance inst = (CServiceInstance)objInst;

                // put the resulting node where it should be.
                xmlResult.AppendChild( inst.ToXml( xmlDoc ) );
            }

            foreach ( Object objOffer in _offers.Values )
            {
                ulong offer = (ulong)objOffer;

                // create the offer node.
                xmlEle = xmlDoc.CreateElement("offer");

                // create the offer id node.
                XmlNode innerOfferIdNode = xmlDoc.CreateElement("offerid");

                // add the text.
                innerOfferIdNode.InnerText = "0x" + offer.ToString("X");

                // put the nodes in place.
                xmlEle.AppendChild( innerOfferIdNode );
                xmlResult.AppendChild( xmlEle );
            }
            
            return xmlResult;
        }

        /// <summary>
        /// == operator:  compares attributes, Instance list and offers list to ensure everything is equal.
        /// </summary>
        /// <param name="service1">CService 1 to compare</param>
        /// <param name="service2">CService 2 to compare</param>
        /// <returns></returns>
        public static bool operator == ( CService service1, CService service2 )
        {
            bool result = true;

            if ( Object.ReferenceEquals( service1, service2 ) )
            {
                return true;
            }
            else if( Object.ReferenceEquals( service1, null ) || Object.ReferenceEquals( service2, null )  )
            {
                return false;
            }

            // check service attributes.
            if ( 
                service1.ServiceId  != service2.ServiceId             ||
                service1.KerbServiceName != service2.KerbServiceName  ||
                service1.KerbDomainName  != service2.KerbDomainName   ||
                service1.Description     != service2.Description      ||
                service1.IsMachineOnly   != service2.IsMachineOnly )
            {
                result = false;
                goto Exit;
            }

            // check instances
            if ( service1.Instances.Count != service2.Instances.Count )
            {
                result = false;
                goto Exit;
            }

            // scan and match entries.  This could be faster if we used a sorted list as opposed to a hybrid list,
            //  however we feel the number of services instances will never get to a number where this operation will
            //  take a significant amount of time to compute.  Worst case (O(n^2))
            foreach ( Object s1Inst in service1.Instances.Values )
            {
                bool wasFound = false;
                CServiceInstance s1 = (CServiceInstance)s1Inst;

                // look for service 1 instance in the service 2 subset.
                foreach ( Object s2Inst in service2.Instances.Values )
                {
                    CServiceInstance s2 = (CServiceInstance)s2Inst;

                    if ( s2 == s1 )
                    {
                        wasFound = true;
                        break;
                    }
                }

                // if this service 1 instance was not found in service 2, then dont' search anymore.
                if ( ! wasFound )
                {
                    result = false;
                    goto Exit;
                }
            }

            // check offers.
            if ( service1.Offers.Count != service2.Offers.Count )
            {
                result = false;
                goto Exit;
            }

            // scan and match entries.  This could be faster if we used a sorted list as opposed to a hybrid list,
            //  however we feel the number of services instances will never get to a number where this operation will
            //  take a significant amount of time to compute.  Worst case (O(n^2))
            foreach ( Object s1Offer in service1.Offers.Values )
            {
                bool wasFound = false;
                ulong s1 = (ulong)s1Offer;

                // look for service 1 instance in the service 2 subset.
                foreach ( Object s2Offer in service2.Offers.Values )
                {
                    ulong s2 = (ulong)s2Offer;

                    // check if this is it.
                    if ( s2 == s1 )
                    {
                        wasFound = true;
                        break;
                    }
                }

                // if this service 1 instance was not found in service 2, then dont' search anymore.
                if ( ! wasFound )
                {
                    result = false;
                    goto Exit;
                }
            }

            Exit:

            return result;
        }

        /// <summary>
        /// != operator:  not compares attributes, Instance list and offers list to ensure everything is equal.
        /// </summary>
        /// <param name="service1">CService 1 to compare</param>
        /// <param name="service2">CService 2 to compare</param>
        /// <returns></returns>
        public static bool operator != ( CService service1, CService service2 )
        {
            return !( service1 == service2 );
        }

        // properties.

        // CService Id
        public uint ServiceId
        {
            get
            {
                return _serviceId;
            }
            set
            {
                _serviceId = value;
            }
        }

        // Kerberos service name of service
        public string KerbServiceName
        {
            get
            {
                return _kerbServiceName;
            }
            set
            {
                _kerbServiceName = value;
            }
        }

        // kerberos domain name of service
        public string KerbDomainName
        {
            get
            {
                return _kerbDomainName;
            }
            set
            {
                _kerbDomainName = value;
            }
        }

        // description of CService
        public string Description
        {
            get
            {
                return _description;
            }
            set
            {
                _description = value;
            }
        }

        // machine only service flag
        public bool IsMachineOnly
        {
            get
            {
                return _isMachineOnly;
            }
            set
            {
                _isMachineOnly = value;
            }
        }

        // Associated service instances.
        public HybridDictionary Instances 
        {
            get
            {
                return _instances;
            }
        }

        // associated service offers
        public HybridDictionary Offers
        {
            get
            {
                return _offers;
            }
        }

        // attributes
        protected uint              _serviceId;
        protected string            _kerbServiceName;
        protected string            _kerbDomainName;
        protected string            _description;
        protected bool              _isMachineOnly;
        protected HybridDictionary  _instances;
        protected HybridDictionary  _offers;
    }        


    public class CServiceInstance
    {
        public CServiceInstance()
        {
            _instanceId         = 0;
            _serviceId          = 0;
            _titleId            = 0;
            _titleVersion       = 0;
            _titleRegion        = 0;
            _siteId             = 0;
            _port               = 0;
            _serviceAvailable   = false;

        }

        public CServiceInstance( uint instanceId, uint serviceId, uint titleId, uint titleVersion, uint titleRegion, uint siteId, ushort port, bool serviceAvailable )
        {
            _instanceId         = instanceId;
            _serviceId          = serviceId;
            _titleId            = titleId;
            _titleVersion       = titleVersion;
            _titleRegion        = titleRegion;
            _siteId             = siteId;
            _port               = port;
            _serviceAvailable   = serviceAvailable;
        }

        public CServiceInstance( uint instanceId, uint serviceId, XmlNode xml )
        {
            _instanceId         = instanceId;
            _serviceId          = serviceId; 

            if ( ! xml.HasChildNodes )
            {
                throw new Exception( "CService::CService(): ERROR:  XML format invalid.  CSite data is missing." );
            }

            _titleId            = 0;
            _titleVersion       = 0;
            _titleRegion        = 0;
            _siteId             = 0;
            _port               = 0;
            _serviceAvailable   = false;

            // read the rest of the information.
            foreach (XmlNode item in xml.ChildNodes )
            {
                switch( item.LocalName.ToLower() )
                {
                    case "titleid":
                    {
                        if ( item.InnerText.StartsWith("0x") )
                        {
                            _titleId = UInt32.Parse( item.InnerText.Substring( 2 ), NumberStyles.HexNumber );
                        }
                        else
                        {
                            _titleId = UInt32.Parse( item.InnerText );
                        }
                    }
                        break;
                    case "titleversion":
                    {
                        if ( item.InnerText.StartsWith("0x") )
                        {
                            _titleVersion = UInt32.Parse( item.InnerText.Substring( 2 ), NumberStyles.HexNumber );
                        }
                        else
                        {
                            _titleVersion = UInt32.Parse( item.InnerText );
                        }
                    }
                        break;
                    case "titleregion":
                    {
                        if ( item.InnerText.StartsWith("0x") )
                        {
                            _titleRegion = UInt32.Parse( item.InnerText.Substring( 2 ), NumberStyles.HexNumber );
                        }
                        else
                        {
                            _titleRegion = UInt32.Parse( item.InnerText );
                        }
                    }
                        break;
                    case "siteid":
                    {
                        if ( item.InnerText.StartsWith("0x") )
                        {
                            _siteId = UInt32.Parse( item.InnerText.Substring( 2 ), NumberStyles.HexNumber );
                        }
                        else
                        {
                            _siteId = UInt32.Parse( item.InnerText );
                        }
                    }
                        break;
                    case "port":
                    {
                        if ( item.InnerText.StartsWith("0x") )
                        {
                            _port = UInt16.Parse( item.InnerText.Substring( 2 ), NumberStyles.HexNumber );
                        }
                        else
                        {
                            _port = UInt16.Parse( item.InnerText );
                        }
                    }
                        break;
                    case "serviceavailable":
                        _serviceAvailable = bool.Parse( item.InnerText );
                        break;
                    default:
                        // don't worry about extra information... it may pertain to later versions.
                        break;                                   
                }
            }
        }

        public override bool Equals(object obj)
        {
            if ( obj.GetType() != this.GetType() )
            {
                return false;
            }
            return ( this == (CServiceInstance)obj );
        }

        public override int GetHashCode()
        {
            return base.GetHashCode ();
        }

        public override string ToString()
        {
            string result = "instance ";
            
            result += "Serviceid=0x" + _serviceId.ToString("X") + ", ";
            result += "titleid=0x" + _titleId.ToString("X") + ", ";
            result += "titlerversion=0x" + _titleVersion.ToString("X") + ", ";
            result += "titleregion=0x" + _titleRegion.ToString("X") + ", ";
            result += "siteid=" + _siteId + ", ";
            result += "port=\"" + _port + ", ";
            result += "serviceavailable=\"" + _serviceAvailable + "\" ";

            return result;
        }

        /// <summary>
        /// ToXml:  Translates contents of this structure into xml format.
        /// </summary>
        /// <param name="xmlDoc">XML document.</param>
        /// <returns>The Xml node containing data in this structure.</returns>
        public XmlNode ToXml( XmlDocument xmlDoc )
        {
            XmlNode xmlResult = xmlDoc.CreateElement("instance");
            XmlNode xmlEle = null;
            
            // add the title id.
            xmlEle = xmlDoc.CreateElement("titleid");
            xmlEle.InnerText = "0x" + _titleId.ToString("X");
            xmlResult.AppendChild( xmlEle );

            // add the title version.
            xmlEle = xmlDoc.CreateElement("titleversion");
            xmlEle.InnerText = "0x" + _titleVersion.ToString("X");
            xmlResult.AppendChild( xmlEle );

            // add the title region
            xmlEle = xmlDoc.CreateElement("titleregion");
            xmlEle.InnerText = "0x" + _titleRegion.ToString("X");
            xmlResult.AppendChild( xmlEle );

            // add the site id
            xmlEle = xmlDoc.CreateElement("siteid");
            xmlEle.InnerText = "0x" + _siteId.ToString("X");
            xmlResult.AppendChild( xmlEle );

            xmlEle = xmlDoc.CreateElement("port");
            xmlEle.InnerText = _port.ToString();
            xmlResult.AppendChild( xmlEle );

            xmlEle = xmlDoc.CreateElement("serviceavailable");
            xmlEle.InnerText = _serviceAvailable.ToString();
            xmlResult.AppendChild( xmlEle );
            
            return xmlResult;
        }

        public static bool operator == ( CServiceInstance si1, CServiceInstance si2 )
        {
            if ( Object.ReferenceEquals( si1, si2 ) )
            {
                return true;
            }
            else if( Object.ReferenceEquals( si1, null ) || Object.ReferenceEquals( si2, null )  )
            {
                return false;
            }

            return (                
                si1.ServiceId       == si2.ServiceId    &&
                si1.TitleId         == si2.TitleId      &&
                si1.TitleVersion    == si2.TitleVersion &&
                si1.TitleRegion     == si2.TitleRegion  &&
                si1.SiteId          == si2.SiteId       &&
                si1.Port            == si2.Port         &&
                si1.ServiceAvailable== si2.ServiceAvailable 
                );
        }

        public static bool operator != ( CServiceInstance si1, CServiceInstance si2 )
        {
            return !( si1 == si2 );
        }

        // properties.

        // CService Id
        public uint InstanceId
        {
            get
            {
                return _instanceId;
            }
            set
            {
                _instanceId = value;
            }
        }

        // CService Id
        public uint ServiceId
        {
            get
            {
                return _serviceId;
            }
            set
            {
                _serviceId = value;
            }
        }

        // Title Id
        public uint TitleId
        {
            get
            {
                return _titleId;
            }
            set
            {
                _titleId = value;
            }
        }

        // Title Version
        public uint TitleVersion
        {
            get
            {
                return _titleVersion;
            }
            set
            {
                _titleVersion = value;
            }
        }

        // title region
        public uint TitleRegion
        {
            get
            {
                return _titleRegion;
            }
            set
            {
                _titleRegion = value;
            }
        }

        // site id
        public uint SiteId
        {
            get
            {
                return _siteId;
            }
            set
            {
                _siteId = value;
            }
        }

        // port
        public ushort Port
        {
            get
            {
                return _port;
            }
            set
            {
                _port = value;
            }
        }

        // service available flag
        public bool ServiceAvailable
        {
            get
            {
                return _serviceAvailable;
            }
            set
            {
                _serviceAvailable = value;
            }
        }

        // attributes
        protected uint              _instanceId;
        protected uint              _serviceId;
        protected uint              _titleId;
        protected uint              _titleVersion;
        protected uint              _titleRegion;
        protected uint              _siteId;
        protected ushort            _port;
        protected bool              _serviceAvailable;

    }  
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\Framework\CSourceDepot.cs ===
using System;
using System.Text;
using System.Diagnostics;
using System.Collections;

namespace xonline.tools.framework 
{
    /// <summary>
    /// A simple wrapper around source depot commands
    /// </summary>
    public class CSourceDepot
    {
        private string m_sSdPort;
        private string m_sSdClient;
        private CLog m_log;

        // a cache for the sd repository and client name
        private string m_sSdClientRoot;
        private string m_sSdClientName;

        public CSourceDepot(string sSdPort, string sSdClient, CLog log)
        {
            m_log = log;
            if (m_log == null)
            {
                m_log = new CLogNull();
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CSourceDepot.ctor("
                + (sSdPort == null ? "null" : sSdPort) + ", "
                + (sSdClient == null ? "null" : sSdClient) + ", "
                + "{log})");

            m_sSdPort = sSdPort;
            m_sSdClient = sSdClient;

            m_sSdClientName = InfoValueGet("Client name:");
            if (m_sSdClientName == null)
            {
                string sErr = "Xbox.Tools.Framework.CRepository.ctor: "
                    + "Could not determine sd client name";
                m_log.WriteLineV(sErr);
                throw new CSourceDepotException(sErr);
            }
            m_log.WriteLineV("Xbox.Tools.Framework.CRepository.ctor: "
                + "sd client name is: "
                + m_sSdClientName);

            m_sSdClientRoot = InfoValueGet("Client root:");
            if (m_sSdClientRoot == null)
            {
                string sErr = "Xbox.Tools.Framework.CRepository.ctor: "
                    + "Could not determine sd client root name";
                m_log.WriteLineV(sErr);
                throw new CSourceDepotException(sErr);
            }
            m_log.WriteLineV("Xbox.Tools.Framework.CRepository.ctor: "
                + "sd client root is: "
                + m_sSdClientRoot);

            m_log.WriteLineV("Xbox.Tools.Framework.CSourceDepot.ctor complete");
        }

        // I have decided to go with the crude but simple and reliable method
        // of executing sd through the shell for now, instead of trying to 
        // figure out the right version of sdapi to use, if I should use COM
        // or IDispatch, etc. etc. Particularly since I don't need to do anything
        // fancy, just check in and check out files.
        public int sd(
            string sCommand, 
            string sArgs, 
            out string[] rgsTexts,
            out string[] rgsInfos, 
            out string[] rgsWarnings,
            out string[] rgsErrors)
        {
            Process process = new Process();
            process.StartInfo.FileName = "sd.exe";

            StringBuilder sb = new StringBuilder();
            sb.Append("-s ");
            if (m_sSdClient != null)
            {
                sb.Append("-c ");
                sb.Append(m_sSdClient);
                sb.Append(" ");
            }
            if (m_sSdPort != null)
            {
                sb.Append("-p ");
                sb.Append(m_sSdPort);
                sb.Append(" ");
            }
            sb.Append(sCommand);
            sb.Append(" ");
            sb.Append(sArgs);

            process.StartInfo.Arguments = sb.ToString();
            process.StartInfo.UseShellExecute = false;
            process.StartInfo.CreateNoWindow = true;
            process.StartInfo.RedirectStandardOutput = true;
            process.StartInfo.RedirectStandardError = false;

            m_log.WriteLineV("Xbox.Tools.Framework.CRepository: "
                + "Running source depot command: "
                + process.StartInfo.FileName
                + " "
                + process.StartInfo.Arguments);

            process.Start();
            string sOutput = process.StandardOutput.ReadToEnd();
            process.WaitForExit();
            process.Close();

            // parse the output
            ArrayList alTexts = new ArrayList();
            ArrayList alInfos = new ArrayList();
            ArrayList alWarnings = new ArrayList();
            ArrayList alErrors = new ArrayList();
            int iExit = -1;

            string[] rgsOutputLines = sOutput.Split('\n');
            foreach (string sOutputLine in rgsOutputLines)
            {
                // dump this to the log.
                m_log.WriteLineV(sOutputLine);

                // get the index of the first ':'
                int iColonIndex = sOutputLine.IndexOf(':');
                if (iColonIndex == -1)
                {
                    // shouldn't happen, save this line in errors unchanged
                    alErrors.Add(sOutputLine);
                    continue;
                }

                // extract the tag at the begining of the line, and the rest of the line
                string sTag = sOutputLine.Substring(0, iColonIndex);
                string sContent = sOutputLine.Substring(iColonIndex+1);
                
                if (sTag == "exit")
                {
                    iExit = Int32.Parse(sContent);
                }
                else if (sTag == "error")
                {
                    alErrors.Add(sContent);
                }
                else if (sTag == "text")
                {
                    alTexts.Add(sContent);
                }
                else if (sTag == "info" || sTag == "info1" || sTag == "info2")
                {
                    alInfos.Add(sContent);
                }
                else if (sTag == "warning" || sTag == "warning1" || sTag == "warning2")
                {
                    alWarnings.Add(sContent);
                }
            }

            // convert the arraylists to arrays
            rgsErrors = new string[alErrors.Count];
            alErrors.CopyTo(rgsErrors);
            rgsWarnings = new string[alWarnings.Count];
            alWarnings.CopyTo(rgsWarnings);
            rgsInfos = new string[alInfos.Count];
            alInfos.CopyTo(rgsInfos);
            rgsTexts = new string[alTexts.Count];
            alTexts.CopyTo(rgsTexts);
            m_log.WriteLineV("Xbox.Tools.Framework.CRepository: "
                + "Source depot command complete, returning "
                + iExit);
            return iExit;
        }

        public string InfoValueGet(string sSdInfoLinePrefix)
        {
            string[] rgsTexts;
            string[] rgsInfos;
            string[] rgsWarnings;
            string[] rgsErrors;
            int iExit = sd("info", "", out rgsTexts, out rgsInfos, out rgsWarnings, out rgsErrors);

            if (iExit != 0)
            {
                string sErr = "Xbox.Tools.Framework.CRepository: Unable to retrieve sd info";
                m_log.WriteLineV(sErr);
                throw new CSourceDepotException(sErr);
            }

            // search the info array for a value that matches the one
            // we're after
            string sSdInfoValue = null;
            foreach (string sInfo in rgsInfos)
            {
                int iSdInfoLinePrefix = sInfo.IndexOf(sSdInfoLinePrefix);
                if (iSdInfoLinePrefix != -1)
                {
                    sSdInfoValue = sInfo.Substring(iSdInfoLinePrefix + sSdInfoLinePrefix.Length).Trim();
                    break;
                }
            }

            // this will return null if the value wasn't found
            return sSdInfoValue.Trim();
        }

        public string ClientName
        {
            get
            {
                return m_sSdClientName;
            }
        }

        public string ClientRoot
        {
            get
            {
                return m_sSdClientRoot;
            }
        }

        public void Sync(string sPath)
        {
            string[] rgsTexts;
            string[] rgsInfos;
            string[] rgsWarnings;
            string[] rgsErrors;
            int iExit = sd(
                "sync",
                sPath,
                out rgsTexts,
                out rgsInfos,
                out rgsWarnings,
                out rgsErrors);

            if (iExit != 0)
            {
                string sErr = "Xbox.Tools.Framework.CRepository: "
                    + "Unable to sd sync "
                    + sPath;
                m_log.WriteLineV(sErr);
                throw new CSourceDepotException(sErr);
            }
        }

        public void Edit(string sPathAndFileName)
        {
            string[] rgsTexts;
            string[] rgsInfos;
            string[] rgsWarnings;
            string[] rgsErrors;
            int iExit = sd(
                "edit",
                sPathAndFileName,
                out rgsTexts,
                out rgsInfos,
                out rgsWarnings,
                out rgsErrors);

            if (iExit != 0)
            {
                string sErr = "Xbox.Tools.Framework.CRepository: "
                    + "Unable to sd edit "
                    + sPathAndFileName;
                m_log.WriteLineV(sErr);
                throw new CSourceDepotException(sErr);
            }
        }

        public void Add(string sPathAndFileName)
        {
            string[] rgsTexts;
            string[] rgsInfos;
            string[] rgsWarnings;
            string[] rgsErrors;
            int iExit = sd(
                "add",
                sPathAndFileName,
                out rgsTexts,
                out rgsInfos,
                out rgsWarnings,
                out rgsErrors);

            if (iExit != 0)
            {
                string sErr = "Xbox.Tools.Framework.CRepository: "
                    + "Unable to sd add "
                    + sPathAndFileName;
                m_log.WriteLineV(sErr);
                throw new CSourceDepotException(sErr);
            }
        }

        public void Delete(string sPathAndFileName)
        {
            string[] rgsTexts;
            string[] rgsInfos;
            string[] rgsWarnings;
            string[] rgsErrors;
            int iExit = sd(
                "delete",
                sPathAndFileName,
                out rgsTexts,
                out rgsInfos,
                out rgsWarnings,
                out rgsErrors);

            if (iExit != 0)
            {
                string sErr = "Xbox.Tools.Framework.CRepository: "
                    + "Unable to sd delete "
                    + sPathAndFileName;
                m_log.WriteLineV(sErr);
                throw new CSourceDepotException(sErr);
            }
        }

        public void Revert(string sPathAndFileName)
        {
            string[] rgsTexts;
            string[] rgsInfos;
            string[] rgsWarnings;
            string[] rgsErrors;
            int iExit = sd(
                "revert",
                sPathAndFileName,
                out rgsTexts,
                out rgsInfos,
                out rgsWarnings,
                out rgsErrors);

            if (iExit != 0)
            {
                string sErr = "Xbox.Tools.Framework.CRepository: "
                    + "Unable to sd revert "
                    + sPathAndFileName;
                m_log.WriteLineV(sErr);
                throw new CSourceDepotException(sErr);
            }
        }

        public void Submit(string sPathAndFileName, string sComment)
        {
            string[] rgsTexts;
            string[] rgsInfos;
            string[] rgsWarnings;
            string[] rgsErrors;
            int iExit = sd(
                "submit",
                (sComment == null ? "" : "-C \"" + sComment + "\" ") + sPathAndFileName,
                out rgsTexts,
                out rgsInfos,
                out rgsWarnings,
                out rgsErrors);

            if (iExit != 0)
            {
                string sErr = "Xbox.Tools.Framework.CRepository: "
                    + "Unable to sd submit "
                    + sPathAndFileName;
                m_log.WriteLineV(sErr);
                throw new CSourceDepotException(sErr);
            }
        }

        public string[] Files(string sPath, bool bOmitDeleted)
        {
            string[] rgsTexts;
            string[] rgsInfos;
            string[] rgsWarnings;
            string[] rgsErrors;
            int iExit = sd(
                "files" + (bOmitDeleted ? " -d" : ""),
                sPath,
                out rgsTexts,
                out rgsInfos,
                out rgsWarnings,
                out rgsErrors);

            if (iExit != 0)
            {
                string sErr = "Xbox.Tools.Framework.CRepository: "
                    + "Unable to sd files"
                    + sPath;
                m_log.WriteLineV(sErr);
                throw new CSourceDepotException(sErr);
            }

            // each file is output in an info line, like so:
            //
            // info: //depot/xonline/private/tools/Framework/test/CRepositoryTest.cs#1 - add change 85354 (text)
            //
            // The sd method has already stripped off the info: prefix. Everything up to the first '#'
            // character should be the full filename. We can burn through the info lines and
            // trim the strings of everything after the '#'. Any line without a hash, we ignore

            ArrayList alFiles = new ArrayList();
            for (int i = 0; i < rgsInfos.Length; ++i)
            {
                int iHashIndex = rgsInfos[i].IndexOf('#');
                if (iHashIndex != -1)
                {
                    alFiles.Add(rgsInfos[i].Substring(0, iHashIndex).Trim());
                }
            }

            string[] rgsFiles = new string[alFiles.Count];
            alFiles.CopyTo(rgsFiles);

            return rgsFiles;
        }
    }

    public class CSourceDepotException : ApplicationException
    {
        public CSourceDepotException() : base() {}
        public CSourceDepotException(string s) : base(s) {}
        protected CSourceDepotException(
            System.Runtime.Serialization.SerializationInfo si,
            System.Runtime.Serialization.StreamingContext sc
        ) : base(si, sc) {}
        public CSourceDepotException(string s, Exception e) : base(s, e) {}
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\Framework\CStatsSync.cs ===
using System;
using System.Collections;

namespace xonline.tools.framework 
{
    public class CStatsSync
    {
        // defaults to use if nothing specified in repository
        private const int c_iUnitDatabaseDefault = 0;
        private const uint c_uiMaxAvailUnitsDefault = 100;
        private const uint c_uiSizeUnitCacheDefault = 100;

        public static void StatsSync(
            CTitleId tid, 
            CRepository repository, 
            CStats stats,
            int iFrontDoorTimeoutMilliseconds,
            int iSqlTimeoutSeconds,
            int iProgressReportIntervalMilliseconds,
            bool bAllowDelete,
            bool bReportOnly,
            CLog log)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            if (repository == null)
            {
                throw new ArgumentNullException("xmlDocTitle");
            }
            if (stats == null)
            {
                throw new ArgumentNullException("stats");
            }
            if (log == null)
            {
                throw new ArgumentNullException("log");
            }

            log.StackTrace("Xbox.Tools.Framework.CStatsSync.StatsSync("
                + tid.sTitleIdHexNoPrefix + ", "
                + "{repository}, "
                + "{stats}, "
                + iFrontDoorTimeoutMilliseconds + ", "
                + iSqlTimeoutSeconds + ", "
                + iProgressReportIntervalMilliseconds+ ", "
                + bAllowDelete + ", "
                + bReportOnly + ", "
                + "{log})");

            // comps has to go first, because it may have to
            // completely delete all stats information to do its
            // sync, and we want all the leaderboards to be 
            // recreated after being nuked.
            SyncComps(
                tid,
                repository,
                stats,
                iFrontDoorTimeoutMilliseconds,
                iSqlTimeoutSeconds,
                bAllowDelete,
                bReportOnly,
                log);

            SyncLeaderboards(
                tid,
                repository,
                stats,
                iFrontDoorTimeoutMilliseconds,
                iSqlTimeoutSeconds,
                iProgressReportIntervalMilliseconds,
                bAllowDelete,
                bReportOnly,
                log);

            SyncUnits(
                tid,
                repository,
                stats,
                iFrontDoorTimeoutMilliseconds,
                iSqlTimeoutSeconds,
                bAllowDelete,
                bReportOnly,
                log);

            SyncLimits(
                tid,
                repository,
                stats,
                bReportOnly,
                log);

            log.StackTrace("Xbox.Tools.Framework.CStatsSync.StatsSync complete");
        }

        public static void SyncLeaderboards(
            CTitleId tid, 
            CRepository repository, 
            CStats stats,
            int iFrontDoorTimeoutMilliseconds,
            int iSqlTimeoutSeconds,
            int iProgressReportIntervalMilliseconds,
            bool bAllowDelete,
            bool bReportOnly,
            CLog log)
        {
            // this will clean up any leaderboards that are in an invalid
            // state, hopefully preparing the database for a nice 
            // error free sync
            stats.LBMoveFinalize(
                tid,
                iSqlTimeoutSeconds,
                iProgressReportIntervalMilliseconds,
                bReportOnly);

            // get the list of leaderboards from the repository
            uint[] rguiLBsInRepository = repository.TitleLBGetList(tid);
            ArrayList alLBsInRepository = new ArrayList(rguiLBsInRepository);

            // get the database map, which tells us what leaderboards 
            // are on which server
            SortedList slLBDatabaseMap = stats.LBGetDatabaseMap(tid, true);

            // At this point, any leaderboard which had bReadOnly, bCopying
            // or bDelete equal to true has had p_Stats_MoveLbFinalize 
            // called on it. If that proc functioned as expected, there
            // should be no duplicate leaderboards left, and there should 
            // be no leaderboards with those flags set to true.
            // Validate that this assertion is true, and abort the sync
            // if it is not true.
            ValidateLeaderboardStates(
                tid,
                stats,
                slLBDatabaseMap,
                iSqlTimeoutSeconds,
                bReportOnly,
                log);

            // At this point we know the following:
            // 1) each leaderboard is only present on ONE server
            // 2) each leaderboard is in a valid state
            // now we can continue with the sync.

            // first we look for leaderboards to move or delete
            int iCountMoved = 0;
            int iCountDeleted = 0;
            foreach (DictionaryEntry de in slLBDatabaseMap)
            {
                // the key of the DictionaryEntry is the leaderboard number
                uint uiLBNum = (uint)de.Key;

                // the value of the DictionaryEntry is an array of bools that
                // indicate what servers the leaderboard is present on. Each
                // leaderboard SHOULD only be on one server, but if something
                // strange has happened, we might end up with one leaderboard
                // defined on multiple service. In that case we want to delete
                // it from whatever server it is not supposed to be on.
                bool[] rgbServerMap = (bool[])de.Value;

                // does this leaderboard exist in the repository?
                if (alLBsInRepository.Contains(uiLBNum))
                {
                    // The leaderboard is defined in the repository, this call
                    // will move it to it's new home if it exists and is not
                    // currently on the stats db specified in the repository
                    if (MoveLeaderboardIfRequired(
                        tid,
                        stats,
                        repository,
                        uiLBNum,
                        rgbServerMap,
                        iFrontDoorTimeoutMilliseconds,
                        iSqlTimeoutSeconds,
                        iProgressReportIntervalMilliseconds,
                        bAllowDelete,
                        bReportOnly,
                        log))
                    {
                        ++iCountMoved;
                    }
                }
                else
                {
                    // The leaderboard does not exist in the repository,
                    // so we should delete it
                    DeleteLeaderboard(
                        tid,
                        stats,
                        uiLBNum,
                        rgbServerMap,
                        ref iCountDeleted,
                        iSqlTimeoutSeconds,
                        bAllowDelete,
                        bReportOnly,
                        log);
                }
            }

            if (bReportOnly && iCountMoved > 0)
            {
                // in report only mode, if we've moved anything, we have to
                // to stop now, because later validation code will get angry that 
                // leaderboards are in places where they are not expected to be
                //   0        1        2        3        4        5        6        7        8
                log.Console(
                    "Warning: This sync is being run in 'report' mode. Because leaderboards");
                log.Console(
                    "         are not actually being moved, but should have been, the rest");
                log.Console(
                    "         of the individual leaderboard sync must now be skipped to");
                log.Console(
                    "         avoid errors");
                return;
            }

            // we have now moved leaderboards to their new home, or deleted
            // them if they shouldn't be there. Now we can update or add leaderboard
            // definitions.
            int iCountAdded = 0;
            int iCountUpdated = 0;
            foreach (uint uiLBNum in alLBsInRepository)
            {
                CreateOrUpdateLeaderboard(
                    tid,
                    stats,
                    repository,
                    uiLBNum,
                    ref iCountAdded,
                    ref iCountUpdated,
                    iSqlTimeoutSeconds,
                    bAllowDelete,
                    bReportOnly,
                    log);
            }

            //   0        1        2        3        4        5        6        7        8
            log.Console(
                "Individual leaderboard sync successful.");
            log.Console(
                iCountMoved+" individual leaderboards moved");
            log.Console(
                iCountDeleted+" individual leaderboards deleted");
            log.Console(
                iCountAdded+" individual leaderboards added");
            log.Console(
                iCountUpdated+" individual leaderboards updated");
        }

        private static void ValidateLeaderboardStates(
            CTitleId tid,
            CStats stats,
            SortedList slLBDatabaseMap,
            int iSqlTimeoutSeconds,
            bool bReportOnly,
            CLog log)
        {
            // walk through the database map, looking for any duplicate leaderboards
            // or leaderboards in a bad state
            foreach (DictionaryEntry de in slLBDatabaseMap)
            {
                // the key of the DictionaryEntry is the leaderboard number
                uint uiLBNum = (uint)de.Key;

                // the value of the DictionaryEntry is an array of bools that
                // indicate which servers that leaderboard is on
                bool[] rgbServerMap = (bool[])de.Value;

                // get the leaderboard definition from each server it's on
                // and examine it
                for (int i = 0; i < rgbServerMap.Length; ++i)
                {
                    ELBReset leaderboardResetInterval;
                    uint uiAttachmentCount;
                    uint uiMaxAttachmentSize;
                    uint uiDecayDays;
                    uint uiMaxRatingCount;
                    bool bRequireArbitration;
                    bool bIsTeam;
                    CELOConfig eloConfig;
                    Guid guid;
                    long lMinQualifyingRating;
                    DateTime dateTimeCreated;
                    byte bReadOnly;
                    byte bCopying;
                    byte bDelete;

                    int iCount = 0;
                    if (rgbServerMap[i] == true)
                    {
                        if (++iCount > 1)
                        {
                            // this leaderboard is defined on multiple servers, so abort the sync
                            string sErr = "Xbox.Tools.Framework.CStatsSync.StatsSync: "
                                + "Leaderboard "
                                + uiLBNum
                                + " is defined on multiple servers. Aborting stats sync.";
                            log.LogFile(sErr);
                            throw new CStatsSyncException(sErr);
                        }

                        // now make sure that the leaderboard doesn't have flags set
                        if (stats.LBConfigGet(
                            tid,
                            i,
                            uiLBNum, 
                            out leaderboardResetInterval,
                            out uiAttachmentCount,
                            out uiMaxAttachmentSize,
                            out uiDecayDays,
                            out uiMaxRatingCount,
                            out bRequireArbitration,
                            out bIsTeam,
                            out eloConfig,
                            out guid,
                            out lMinQualifyingRating,
                            out dateTimeCreated,
                            out bReadOnly,
                            out bCopying,
                            out bDelete))
                        {
                            // we got the definition, check to see if any of the 
                            // relevant flags are set.
                            if (bReadOnly != 0 || bCopying != 0 || bDelete != 0)
                            {
                                //   0        1        2        3        4        5        6        7        8
                                string sErr = "Xbox.Tools.Framework.CStatsSync.StatsSync: "
                                    + "Error: Leaderboard "
                                    +uiLBNum
                                    +" in stats db "
                                    +i
                                    +" is in an invalid state. Aborting stats sync.";
                                log.LogFile(sErr);
                                throw new CStatsSyncException(sErr);
                            }
                        }
                        else
                        {
                            // this shouldn't happen. The map said the leaderboard was there,
                            // but then we couldn't find it. At this point in the process
                            // we should abort the sync.
                            //   0        1        2        3        4        5        6        7        8
                            string sErr = "Xbox.Tools.Framework.CStatsSync.StatsSync: "
                                + "Error: Unable to retrieve leaderboard "+uiLBNum+" from stats db "+i;
                            log.LogFile(sErr);
                            throw new CStatsSyncException(sErr);
                        }
                    }
                }
            }
            return;
        }

        private static bool MoveLeaderboardIfRequired(
            CTitleId tid,
            CStats stats,
            CRepository repository,
            uint uiLBNum,
            bool[] rgbServerMap,
            int iFrontDoorTimeoutMilliseconds,
            int iSqlTimeoutSeconds,
            int iProgressReportIntervalMilliseconds,
            bool bAllowDelete,
            bool bReportOnly,
            CLog log)
        {
            // get the leaderboard definition from the repository,
            // so we know what stats database it wants to be on...
            int iStatsDatabase = 0;
            ELBReset riLBResetInterval = ELBReset.ResetNever;
            uint uiAttachmentCount = 0;
            uint uiMaxAttachmentSize = 0;
            uint uiDecayDays = 0;
            uint uiMaxRatingCount = 0;
            bool bArbitrationRequired = false;
            bool bIsTeam = false;
            CELOConfig eloConfig = null;
            uint uiEntriesPerCacheLine = 0;
            uint uiExpirationSeconds =-0;
            bool bDontList = false;

            if (!repository.TitleLBGet(
                tid,
                uiLBNum, 
                ref iStatsDatabase,
                ref riLBResetInterval,
                ref uiAttachmentCount,
                ref uiMaxAttachmentSize,
                ref uiDecayDays,
                ref uiMaxRatingCount,
                ref bArbitrationRequired,
                ref bIsTeam,
                ref eloConfig,
                ref uiEntriesPerCacheLine,
                ref uiExpirationSeconds,
                ref bDontList))
            {
                // this should not happen. This function should only be called
                // if the leaderboard exists in the repository
                string sErr = "Xbox.Tools.Framework.CStatsSync.StatsSync: "
                    + "Leaderboard "
                    + uiLBNum
                    + " not found in the repository as expected";
                log.LogFile(sErr);
                throw new CStatsSyncException(sErr);
            }

            // this leaderboard was found in the repository, make sure that
            // it's not configured to be on a non-existant stats server
            if (iStatsDatabase >= rgbServerMap.Length)
            {
                string sErr = "Xbox.Tools.Framework.CStatsSync.StatsSync: "
                    + "Leaderboard "
                    + uiLBNum
                    + " is configured in the repository to be on stats server "
                    + iStatsDatabase
                    + " which is larger than the number of stats servers";
                log.LogFile(sErr);
                throw new CStatsSyncException(sErr);
            }

            // does this leaderboard already exist on the correct server?
            bool bMoved = false;
            if (rgbServerMap[iStatsDatabase] == false)
            {
                // the leaderboard is not where we want it to be.
                // find out where it is (if it currently exists at all), 
                // and move it to it's now home. 
                // By the time we get here, we've ensured that there is
                // at most one copy of this leaderboard around, so we simply
                // move the first one we find.
                for (int i = 0; i < rgbServerMap.Length; ++i)
                {
                    if (rgbServerMap[i] == true)
                    {
                        // Found it, move this leaderboard to it's new home
                        //   0        1        2        3        4        5        6        7        8
                        log.Console(
                            "Note: Moving leaderboard "+uiLBNum+" from stats database "+i+" to");
                        log.Console(
                            "      stats database "+iStatsDatabase+".");
                        log.Console(
                            "      Please note that moving leaderboards may take 30 minutes");
                        log.Console(
                            "      or more depending on how much data needs to be copied.");
                        if (iSqlTimeoutSeconds == 0)
                        {
                            //   0        1        2        3        4        5        6        7        8
                            log.Console(
                                "      No timeout will be specified for SQL commands to move leaderboards");
                        }
                        else
                        {
                            //   0        1        2        3        4        5        6        7        8
                            log.Console(
                                "      A timeout of "+iSqlTimeoutSeconds+" will be specified for SQL commands to ");
                            log.Console(
                                "      move leaderboards");
                        }
                        stats.LBMove(
                            tid,
                            uiLBNum, 
                            i,
                            iStatsDatabase,
                            false,
                            iFrontDoorTimeoutMilliseconds,
                            iSqlTimeoutSeconds,
                            iProgressReportIntervalMilliseconds,
                            bReportOnly);
                        bMoved = true;
                    }
                }
            }
            return bMoved;
        }

        private static void DeleteLeaderboard(
            CTitleId tid,
            CStats stats,
            uint uiLBNum,
            bool[] rgbServerMap,
            ref int iCountDeleted,
            int iSqlTimeoutSeconds,
            bool bAllowDelete,
            bool bReportOnly,
            CLog log)
        {
            for (int i = 0; i < rgbServerMap.Length; ++i)
            {
                if (rgbServerMap[i] == true)
                {
                    // the leaderboard exists on this server, nuke it
                    if (bAllowDelete)
                    {
                        //   0        1        2        3        4        5        6        7        8
                        log.Console(
                            "Note: Deleting leaderboard "+uiLBNum+" from stats database "+i);
                        stats.LBDelete(
                            tid,
                            i,
                            uiLBNum,
                            iSqlTimeoutSeconds,
                            bReportOnly);
                        ++iCountDeleted;
                    }
                    else
                    {
                        //   0        1        2        3        4        5        6        7        8
                        log.Console(
                            "Warning: Leaderboard "+uiLBNum+" is present on stats database "+i);
                        log.Console(
                            "         but is not present in the repository. This leaderboard should");
                        log.Console(
                            "         be deleted. To delete this leaderboard, repeat the current");
                        log.Console(
                            "         operation using the option to allow deletion (often /force)");
                        log.Console(
                            "         The sync operation will continue, but this leaderboard will");
                        log.Console(
                            "         Still be present after the sync is complete.");
                    }
                }
            }
        }

        private static void CreateOrUpdateLeaderboard(
            CTitleId tid,
            CStats stats,
            CRepository repository,
            uint uiLBNum,
            ref int iCountAdded,
            ref int iCountUpdated,
            int iSqlTimeoutSeconds,
            bool bAllowDelete,
            bool bReportOnly,
            CLog log)
        {
            // get the leaderboard definition from the repository
            int iStatsDatabase = 0;
            ELBReset riLBResetInterval = ELBReset.ResetNever;
            uint uiAttachmentCount = 0;
            uint uiMaxAttachmentSize = 0;
            uint uiDecayDays = 0;
            uint uiMaxRatingCount = 0;
            bool bArbitrationRequired = false;
            bool bIsTeam = false;
            CELOConfig eloConfig = null;

            // these don't matter here, not used by stats database.
            uint uiEntriesPerCacheLine = 0;
            uint uiExpirationSeconds = 0;
            bool bDontList = false;

            if (!repository.TitleLBGet(
                tid,
                uiLBNum, 
                ref iStatsDatabase,
                ref riLBResetInterval,
                ref uiAttachmentCount,
                ref uiMaxAttachmentSize,
                ref uiDecayDays,
                ref uiMaxRatingCount,
                ref bArbitrationRequired,
                ref bIsTeam,
                ref eloConfig,
                ref uiEntriesPerCacheLine,
                ref uiExpirationSeconds,
                ref bDontList))
            {
                // this should not happen. This function should only be called
                // if the leaderboard exists in the repository
                string sErr = "Xbox.Tools.Framework.CStatsSync.StatsSync: "
                    + "Leaderboard "
                    + uiLBNum
                    + " not found in the repository as expected";
                log.LogFile(sErr);
                throw new CStatsSyncException(sErr);
            }

            if (uiLBNum < 1)
            {
                // leaderboard ids less than 1 have never been allowed, so throw.
                string sErr = "Xbox.Tools.Framework.CStatsSync.StatsSync: "
                    + "Leaderboard id "
                    + uiLBNum
                    + " is smaller than the minimum allowed value of 1";
                log.LogFile(sErr);
                throw new CStatsSyncException(sErr);
            }

            if (uiLBNum > UInt16.MaxValue)
            {
                // leaderboard ids greater than 16 bit words are not allowed
                string sErr = "Xbox.Tools.Framework.CStatsSync.StatsSync: "
                    + "Leaderboard id "
                    + uiLBNum
                    + " is larger than the maximum allowed value of "
                    + UInt16.MaxValue;
                log.LogFile(sErr);
                throw new CStatsSyncException(sErr);
            }

            // you're not allowed to change the max rating count of an
            // existing leaderboard. Get the current leaderboard definition,
            // if any, on this server.
            ELBReset leaderboardResetIntervalOut;
            uint uiAttachmentCountOut;
            uint uiMaxAttachmentSizeOut;
            uint uiDecayDaysOut;
            uint uiMaxRatingCountOut;
            bool bRequireArbitrationOut;
            bool bIsTeamOut;
            CELOConfig eloConfigOut;
            Guid guidOut;
            long lMinQualifyingRatingOut;
            DateTime dateTimeCreatedOut;
            byte bReadOnlyOut;
            byte bCopyingOut;
            byte bDeleteOut;

            if (stats.LBConfigGet(
                tid,
                iStatsDatabase,
                uiLBNum, 
                out leaderboardResetIntervalOut,
                out uiAttachmentCountOut,
                out uiMaxAttachmentSizeOut,
                out uiDecayDaysOut,
                out uiMaxRatingCountOut,
                out bRequireArbitrationOut,
                out bIsTeamOut,
                out eloConfigOut,
                out guidOut,
                out lMinQualifyingRatingOut,
                out dateTimeCreatedOut,
                out bReadOnlyOut,
                out bCopyingOut,
                out bDeleteOut))
            {
                // the leaderboard already exists, see if we're trying to change
                // the max rating count on it
                if (uiMaxRatingCount != uiMaxRatingCountOut)
                {
                    // We're trying to change the max rating count.
                    // This can only be done if we first delete the leaderboard
                    // If allow delete is specifed, then nuke it and continue
                    // If we're not allowed to nuke it then issue a warning
                    // and skip this leaderboard
                    if (bAllowDelete)
                    {
                        //   0        1        2        3        4        5        6        7        8
                        log.Console(
                            "Note: Deleting leaderboard "+uiLBNum+" from stats database "+iStatsDatabase);
                        log.Console(
                            "      so the max rating count can be updated.");
                        stats.LBDelete(
                            tid,
                            iStatsDatabase,
                            uiLBNum,
                            iSqlTimeoutSeconds,
                            bReportOnly);

                        // count this as an updated leaderboard (it will get readded below)
                        ++iCountUpdated;
                    }
                    else
                    {
                        //   0        1        2        3        4        5        6        7        8
                        log.Console(
                            "Warning: Unable to update leaderboard "+uiLBNum+" in stats database "+iStatsDatabase);
                        log.Console(
                            "         because the max rating count has changed. To update this");
                        log.Console(
                            "         leaderboard it must first be deleted. To delete this");
                        log.Console(
                            "         leaderboard, repeat the current operation using the option to");
                        log.Console(
                            "         allow deletion (often /force)");
                        return;
                    }
                }
                else
                {
                    // we're about to update this leaderboard
                    ++iCountUpdated;
                }
            }
            else
            {
                // leaderboard doesn't exist yet, so this will be added
                ++iCountAdded;
            }

            // apply it to the stats service
            log.FullTrace("Xbox.Tools.Framework.CStatsSync.StatsSync: "
                + "Adding/Updating leaderboard "
                + uiLBNum
                + " on stats database "
                + iStatsDatabase);
            stats.LBConfigSet(
                tid,
                iStatsDatabase,
                uiLBNum, 
                riLBResetInterval,
                uiAttachmentCount,
                uiMaxAttachmentSize,
                uiDecayDays,
                uiMaxRatingCount,
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                bReportOnly);
        }

        public static void SyncUnits(
            CTitleId tid, 
            CRepository repository, 
            CStats stats,
            int iTimeoutMilliseconds,
            int iSqlTimeoutSeconds,
            bool bAllowDelete,
            bool bReportOnly,
            CLog log)
        {
            // get the list of unit leaderboards from the repository
            uint[] rguiUnitsInRepository = repository.TitleUnitGetList(tid);
            ArrayList alUnitsInRepository = new ArrayList(rguiUnitsInRepository);

            // Get the map that tells us which database(s) this title has enabled units on
            // Note that while units are only supposed to be enabled on one database
            // at a time, bad things sometimes happen, and we want to be able to 
            // handle it here.
            SortedList slUnitTitleDbMap = stats.UnitTitleGetDatabaseMap();
            bool[] rgbPresent = (bool[])slUnitTitleDbMap[tid.uiTitleId];

            // if there are no unit leaderboards defined in the repository
            // then we want to disable units on all databases where they
            // are currently enabled.
            if (rguiUnitsInRepository.Length == 0)
            {
                if (rgbPresent != null)
                {
                    // unit leaderboards are present somewhere, seek and destroy (or warn)
                    for (int i = 0; i < rgbPresent.Length; ++i)
                    {
                        if (rgbPresent[i])
                        {
                            // there's a title unit configuration in stats database 'i'
                            if (bAllowDelete)
                            {
                                //   0        1        2        3        4        5        6        7        8
                                log.Console(
                                    "Note: Deleting unit config and unit leaderboards from stats server "+i);
                                stats.UnitTitleDelete(
                                    tid,
                                    i,
                                    iSqlTimeoutSeconds,
                                    bReportOnly);
                            }
                            else
                            {
                                //   0        1        2        3        4        5        6        7        8
                                log.Console(
                                    "Warning: No unit leaderboards are present in the repository, but ");
                                log.Console(
                                    "         unit support is enabled on stats database "+i+". To remove");
                                log.Console(
                                    "         this configuration, repeat the current operation and specify");
                                log.Console(
                                    "         the option to allow deletion (often /force). No changes are");
                                log.Console(
                                    "         being made to the unit configuration on database "+i);
                            }
                        }
                    }
                    // we have deleted unit configuration from every server, or
                    // issued a warning. That's all we need to do if there are no
                    // unit leaderboards in the repository, so we're done.
                    return;
                }
                else
                {
                    // there are no unit leaderboards in the repository, and there's
                    // nothing on any server, so we have nothing to do. Issue a console
                    // message just so the user knows what didn't happen.
                    //   0        1        2        3        4        5        6        7        8
                    log.Console(
                        "Unit leaderboard sync successful.");
                    log.Console(
                        "No unit leaderboards added or updated.");
                    return;
                }
            }

            // if we get here, there's at least one unit leaderboard defined in
            // the repository, so take care of updating the unit configuration stuff

            // get the unit configuration from the repository

            // use these defaults in case a value isn't specified in
            // the repository
            int iUnitDatabase = c_iUnitDatabaseDefault;
            uint uiMaxAvailUnits = c_uiMaxAvailUnitsDefault;
            uint uiSizeUnitCache = c_uiSizeUnitCacheDefault;

            // this value must come from the repository, or it's an error,
            // so set it to an invalid value...
            double dDecayFactor = -1.0;

            if (!repository.TitleUnitConfigGet(
                tid, 
                ref iUnitDatabase,
                ref dDecayFactor,
                ref uiMaxAvailUnits,
                ref uiSizeUnitCache))
            {
                // it's an error to specify unit leaderboards without providing a decay
                // factor, therefore we can't continue.
                //   0        1        2        3        4        5        6        7        8
                log.Console(
                    "Error: No unit config data in repository for titleid "+tid.sTitleIdHexNoPrefix);
                log.Console(
                    "       Unit leaderboards will not be synced, no changes will be made to");
                log.Console(
                    "       the existing unit configuration or any existing unit leaderboards");
                return;
            }

            // did we get a decay factor?
            if (dDecayFactor == -1.0)
            {
                // it's an error to specify unit leaderboards without providing a decay
                // factor, therefore we can't continue.
                //   0        1        2        3        4        5        6        7        8
                log.Console(
                    "Error: No unit decay factor in repository for titleid "+tid.sTitleIdHexNoPrefix);
                log.Console(
                    "       Unit leaderboards will not be synced, no changes will be made to");
                log.Console(
                    "       the existing unit configuration or any existing unit leaderboards");
                return;
            }

            // units should only be configured on one database at a time,
            // but you never know what's going to happen, so loop through
            // the array and nuke it from any database where it appears,
            // unless it's the database it's supposed to be on.
            bool bDatabaseClean = true;
            if (rgbPresent != null)
            {
                // this title is defined on at least one database
                for (int i = 0; i < rgbPresent.Length; ++i)
                {
                    if (rgbPresent[i] && i != iUnitDatabase)
                    {
                        // there's a title unit configuration in stats database 'i'
                        // and it's not supposed to be here
                        if (bAllowDelete)
                        {
                            //   0        1        2        3        4        5        6        7        8
                            log.Console(
                                "Note: Deleting unit config and unit leaderboards from stats server "+i);
                            stats.UnitTitleDelete(
                                tid,
                                i,
                                iSqlTimeoutSeconds,
                                bReportOnly);
                        }
                        else
                        {
                            //   0        1        2        3        4        5        6        7        8
                            log.Console(
                                "Error: Units must be disabled on stats db "+i+" for titleid "+tid.sTitleIdHexNoPrefix);

                            // We don't want to continue sync'ing unit leaderboards while
                            // the database has units in the wrong place, so we set this flag
                            // which will abort the sync once we're done looking at the 
                            // database state.
                            bDatabaseClean = false;
                        }
                    }
                }
            }

            // If the bDatabaseNotClean flag has been set then we want to abort the 
            // sync at this point. It would be a mistake to put unit leaderboards 
            // onto the wrong server, or onto a 2nd server.
            if (!bDatabaseClean)
            {
                //   0        1        2        3        4        5        6        7        8
                log.Console(
                    "Error: Aborting unit leaderboard sync because unit leaderboards are ");
                log.Console(
                    "       configured on the wrong server. To correct this problem, repeat ");
                log.Console(
                    "       the current operation using the option to allow deletion.");
                log.Console(
                    "       (often /force) Note that this will destroy all current unit ");
                log.Console(
                    "       leaderboard data for this title.");
                return;
            }

            // ok, there is one more thing to check before we party on and update the unit
            // leaderboard definitions... We are not able to delete unit leaderboards one at
            // a time. If we need to delete a unit leaderboard, then we have to completely
            // nuke units, then recreate just the unit leaderboards we want. So iterate
            // through the unit leaderboards currently defined on the service and see if
            // any are missing from the repository. At this point we've made sure there's
            // only unit information on one stats server, so we need not worry about that
            // edge case in this loop.
            bool bDeleteRequired = false;
            SortedList slUnitMap = stats.UnitLBGetDatabaseMap(tid);
            foreach (DictionaryEntry de in slUnitMap)
            {
                uint uiUnit = (uint)de.Key;
                bool[] rgbServerMap = (bool[])de.Value;

                // despite the fact that I said not to worry about it, make sure
                // that the unit leaderboard does not appear on any server but the 
                // one where it's supposed to go. If we detect a problem at this point
                // just throw, because it's a bug in this code.
                for (int i = 0; i < rgbServerMap.Length; ++ i)
                {
                    if (rgbServerMap[i] == true && i != iUnitDatabase)
                    {
                        // unit leaderboard where it shouldn't be! throw.
                        string sErr = "Xbox.Tools.Framework.CStatsSync.StatsSync: "
                            + "Unit leaderboard "
                            + uiUnit
                            + " was found on stats server "
                            + i
                            + " unexpectedly. This should not happen.";
                        log.LogFile(sErr);
                        throw new CStatsSyncException(sErr);
                    }
                }

                // Ok now we know this leaderboard is not where it's not supposed
                // to be. Make sure it is where it is supposed to be...
                if (rgbServerMap[iUnitDatabase] == false)
                {
                    // unit leaderboard missing!
                    string sErr = "Xbox.Tools.Framework.CStatsSync.StatsSync: "
                        + "Unit leaderboard "
                        + uiUnit
                        + " was not found on stats server "
                        + iUnitDatabase
                        + " as expected. This should not happen.";
                    log.LogFile(sErr);
                    throw new CStatsSyncException(sErr);
                }

                // now that we know the stats object and this sync code is acting
                // as expected, we can proceed to see if we need to delete this
                // unit leaderboard.
                if (!alUnitsInRepository.Contains(uiUnit))
                {
                    //   0        1        2        3        4        5        6        7        8
                    log.Console(
                        "Warning: Unit leaderboard "+uiUnit+" is present in stats database but");
                    log.Console(
                        "         is not in the repository.");

                    // set this flag so we know that a delete is required...
                    bDeleteRequired = true;
                }
            }

            // check to see if a delete is required to clean up unit leaderboards that
            // are no longer specified in the repository
            if (bDeleteRequired)
            {
                if (bAllowDelete)
                {
                    // nuke it.
                    //   0        1        2        3        4        5        6        7        8
                    log.Console(
                        "Note: Deleting unit config and unit leaderboards from stats server "+iUnitDatabase);
                    stats.UnitTitleDelete(
                        tid,
                        iUnitDatabase,
                        iSqlTimeoutSeconds,
                        bReportOnly);
                }
                else
                {
                    //   0        1        2        3        4        5        6        7        8
                    log.Console(
                        "Warning: Unit leaderboards are present in stats database that are not");
                    log.Console(
                        "         present in the repository. To delete these unit leaderboards");
                    log.Console(
                        "         all unit information for this title must be deleted. To");
                    log.Console(
                        "         perform this operation, repeat the current operation with the");
                    log.Console(
                        "         option to allow deletion (often /force). Note that performing");
                    log.Console(
                        "         this operation allowing deletion will delete all current unit");
                    log.Console(
                        "         leaderboard data for this title. Unit leaderboards will now");
                    log.Console(
                        "         be syncronized, but there will be unit leaderboards present");
                    log.Console(
                        "         on the service that are not present in the repository.");

                    // ok to continue sync from this point
                }
            }

            // any deleting that needed to be done has now been done, we can now safely
            // update the title's unit configuration
            log.FullTrace("Xbox.Tools.Framework.CStatsSync.StatsSync: "
                + "Setting unit config for titleid "
                + tid.sTitleIdHexNoPrefix);
            stats.UnitTitleConfigSet(
                tid,
                iUnitDatabase,
                dDecayFactor,
                uiMaxAvailUnits,
                uiSizeUnitCache,
                bReportOnly);

            // the title's unit config is now up to date, anything that needed
            // deleting has been deleted (or warnings have been issued). So all that's
            // left is updating each unit leaderboard definition.
            int iCount = 0;
            foreach (uint uiUnit in alUnitsInRepository)
            {
                CreateOrUpdateUnit(
                    tid,
                    stats,
                    repository,
                    iUnitDatabase,
                    uiUnit,
                    bReportOnly,
                    log);
                ++iCount;
            }

            //   0        1        2        3        4        5        6        7        8
            log.Console(
                "Unit leaderboard sync successful.");
            log.Console(
                iCount+" unit leaderboards added or updated.");
        }

        private static void CreateOrUpdateUnit(
            CTitleId tid,
            CStats stats,
            CRepository repository,
            int iUnitDatabase,
            uint uiUnit,
            bool bReportOnly,
            CLog log)
        {
            // get the leaderboard definition from the repository
            // the values below are the default if nothing is 
            // specified in the repository
            bool bArbitrationRequired = true;
            bool bIsTeam = false;
            CELOConfig eloConfig = null;

            // these don't matter here, not used by stats database.
            uint uiEntriesPerCacheLine = 0;
            uint uiExpirationSeconds = 0;
            bool bDontList = false;

            if (!repository.TitleUnitGet(
                tid,
                uiUnit, 
                ref bArbitrationRequired,
                ref bIsTeam,
                ref eloConfig,
                ref uiEntriesPerCacheLine,
                ref uiExpirationSeconds,
                ref bDontList))
            {
                // this should not happen. This function should only be called
                // if the unit leaderboard exists in the repository
                string sErr = "Xbox.Tools.Framework.CStatsSync.StatsSync: "
                    + "Unit leaderboard "
                    + uiUnit
                    + " not found in the repository as expected";
                log.LogFile(sErr);
                throw new CStatsSyncException(sErr);
            }

            if (uiUnit < 1)
            {
                // unit leaderboard ids less than 1 are not allowed, so throw.
                string sErr = "Xbox.Tools.Framework.CStatsSync.StatsSync: "
                    + "Unit Leaderboard id "
                    + uiUnit
                    + " is smaller than the minimum allowed value of 1";
                log.LogFile(sErr);
                throw new CStatsSyncException(sErr);
            }

            if (uiUnit > UInt16.MaxValue)
            {
                // unit leaderboard ids greater than a 16 bit word are not allowed
                string sErr = "Xbox.Tools.Framework.CStatsSync.StatsSync: "
                    + "Unit leaderboard "
                    + uiUnit
                    + " is larger than the maximum allowed value of "
                    + UInt16.MaxValue;
                log.LogFile(sErr);
                throw new CStatsSyncException(sErr);
            }

            // apply it to the stats service
            log.FullTrace("Xbox.Tools.Framework.CStatsSync.StatsSync: "
                + "Adding/Updating unit leaderboard "
                + uiUnit
                + " on stats database "
                + iUnitDatabase);
            stats.UnitLBConfigSet(
                tid,
                iUnitDatabase,
                uiUnit,
                bArbitrationRequired,
                bIsTeam,
                eloConfig,
                bReportOnly);
        }

        public static void SyncComps(
            CTitleId tid, 
            CRepository repository, 
            CStats stats,
            int iTimeoutMilliseconds,
            int iSqlTimeoutSeconds,
            bool bAllowDelete,
            bool bReportOnly,
            CLog log)
        {

            // Competitions are tough. Because they are templates for leaderboards
            // that get created at a later time, you can't delete a template without
            // deleting all the leaderboards that were created from that template.
            // For the same reason, you can't change a template. You also can't 
            // delete a competition partition easily. All of this means that there
            // only two things you can do easily with competitions - add a new
            // competition template, and add a new competition partition. That's it.
            // Anything else, and you have to completely nuke everything about that
            // title on the stats service, and recreate it from scratch. Very
            // destructive. Not something you want to do on a regular basis, but
            // may be required on our dev environments, so we want to support it.

            // So our first order of business is to find any of the things that
            // make it necessary to nuke this title's stats configuration.

            // have any competition partitions been moved or removed?

            // get the map of current partitions from the stats databases
            SortedList slCompPartitionMap = stats.CompPartitionGetDatabaseMap(tid);

            // get the partition definitions from the repository. Use -1 to indicate
            // that a partition does not exist.
            int[] rgiPartitionMapInRepository = {-1, -1, -1, -1};
            repository.TitleCompPartitionGet(tid, 0u, ref rgiPartitionMapInRepository[0]);
            repository.TitleCompPartitionGet(tid, 1u, ref rgiPartitionMapInRepository[1]);
            repository.TitleCompPartitionGet(tid, 2u, ref rgiPartitionMapInRepository[2]);
            repository.TitleCompPartitionGet(tid, 3u, ref rgiPartitionMapInRepository[3]);

            // if there are no partitions defined, default to one partition on the
            // default stats db server
            if (rgiPartitionMapInRepository[0] == -1
                && rgiPartitionMapInRepository[1] == -1
                && rgiPartitionMapInRepository[2] == -1
                && rgiPartitionMapInRepository[3] == -1)
            {
                // no partitions defined in the repository, get the default
                // statsdb for this title
                repository.TitleLBDefaultDBGet(tid, ref rgiPartitionMapInRepository[0]);

                // if there's no default statsdb, then use statsdb 0, which we know
                // must exist
                if (rgiPartitionMapInRepository[0] == -1)
                {
                    rgiPartitionMapInRepository[0] = 0;
                }
            }

            // we are looking for four things below
            //
            // 1) does the partition exist on server other than the one the repository calls for
            // 2) does the partition exist when the repository says it shouldn't
            // 3) does the partition exist on more than one server
            // 4) are there any invalid partition numbers on the stats servers
            //
            // it's safe to sync templates without fixing issue 1 or 2
            //
            // issue 3 or 4 means the stats service is in an invalid state, and we 
            // should force them to fix it.
            //
            bool bDeleteRequired = false;
            bool bSafeToContinue = true;
            for (uint ui = 0; ui < rgiPartitionMapInRepository.Length; ++ui)
            {
                // is this partition defined in the repository?
                if (rgiPartitionMapInRepository[ui] == -1)
                {
                    // partition 'ui' is not defined in repository

                    // is partition 'ui' defined in a stats database somewhere?
                    bool[] rgbDBMap = (bool[])slCompPartitionMap[ui];
                    if (rgbDBMap != null)
                    {
                        // the partition exists in at least one stats db
                        int iCount = 0;
                        for (int j = 0; j < rgbDBMap.Length; ++j)
                        {
                            if (rgbDBMap[j] == true)
                            {
                                // partition ui exists on server j
                                //   0        1        2        3        4        5        6        7        8
                                log.Console(
                                    "Warning: Competition partition id "+ui+" is not defined in the repository");
                                log.Console(
                                    "         but is present on stats databsae "+j);
                                bDeleteRequired = true;
                                ++iCount;
                            }
                            // issue a warning and set the flag to abort the sync if more than
                            // one database has this partition
                            if (iCount > 1)
                            {
                                //   0        1        2        3        4        5        6        7        8
                                log.Console(
                                    "Error: Competition partition id "+ui+" is present on multiple servers.");
                                bDeleteRequired = true;
                                bSafeToContinue = false;
                            }
                        }
                    }
                }
                else
                {
                    // partition 'ui' is defined in repository

                    // is partition 'ui' defined in a stats database somewhere?
                    bool[] rgbDBMap = (bool[])slCompPartitionMap[ui];
                    if (rgbDBMap != null)
                    {
                        // the partition exists in at least one stats db
                        int iCount = 0;
                        for (int j = 0; j < rgbDBMap.Length; ++j)
                        {
                            if (rgbDBMap[j] == true)
                            {
                                // partition ui exists on server j

                                // is this where we want it?
                                if (j != rgiPartitionMapInRepository[ui])
                                {
                                    // this is not where we want it, so warn and set the delete flag
                                    //   0        1        2        3        4        5        6        7        8
                                    log.Console(
                                        "Warning: Competition partition id "+ui+" is defined in the repository");
                                    log.Console(
                                        "         to be on stats database "+rgiPartitionMapInRepository[ui]+" but exists on");
                                    log.Console(
                                        "         stats database "+j);
                                    bDeleteRequired = true;
                                }
                                ++iCount;
                            }
                        }
                        // issue a warning and set the flag to abort the sync if more than
                        // one database has this partition
                        if (iCount > 1)
                        {
                            //   0        1        2        3        4        5        6        7        8
                            log.Console(
                                "Error: Competition partition id "+ui+" is present on multiple servers.");
                            bDeleteRequired = true;
                            bSafeToContinue = false;
                        }
                    }
                }
            }

            // final check, zip through the partitions defined on the service
            // and make sure they are all valid partition ids (less than 4)
            foreach (DictionaryEntry de in slCompPartitionMap)
            {
                uint uiPartitionId = (uint)de.Key;
                // is this a valid partition id?
                if (uiPartitionId > 3)
                {
                    //   0        1        2        3        4        5        6        7        8
                    log.Console(
                        "Error: Invalid competition partition id "+uiPartitionId+" detected");
                    bDeleteRequired = true;
                    bSafeToContinue = false;
                }
            }

            // now we check if any competition templates been updated or removed

            // get the list of competition templates from the repository
            uint[] rguiCompsInRepository = repository.TitleCompGetList(tid);
            ArrayList alCompsInRepository = new ArrayList(rguiCompsInRepository);

            // get the map of which templates are defined on which servers
            SortedList slCompTemplateDBMap = stats.CompTemplateGetDatabaseMap(tid);

            // first, look through the list of templates on the service, and see
            // if any are missing from the repository
            foreach (DictionaryEntry de in slCompTemplateDBMap)
            {
                uint uiTemplateId = (uint)de.Key;
                if (!alCompsInRepository.Contains(uiTemplateId))
                {
                    // template uiTemplateId is on the service but not in the repository
                    //   0        1        2        3        4        5        6        7        8
                    log.Console(
                        "Warning: Competition template id "+uiTemplateId+" exists on one or more stats");
                    log.Console(
                        "         database servers, but is not present in the repository.");
                    bDeleteRequired = true;
                }
            }

            // now walk through the list of templates in the repository, and see if any of them
            // don't match the definition on the service.
            foreach (uint uiTemplateId in rguiCompsInRepository)
            {
                ELBReset riLBResetIntervalRepository = ELBReset.ResetNever;
                uint uiAttachmentCountRepository = 0;
                uint uiMaxAttachmentSizeRepository = 0;
                uint uiDecayDaysRepository = 0;
                bool bArbitrationRequiredRepository = false;
                bool bIsTeamRepository = false;
                CELOConfig eloConfigRepository = null;
                uint uiEntriesPerCacheLineRepository = 0;
                uint uiExpirationSecondsRepository = 0;
                bool bDontListRespository = false;
                // get the template definition from the repository
                if (!repository.TitleCompGet(
                    tid,
                    uiTemplateId, 
                    ref riLBResetIntervalRepository,
                    ref uiAttachmentCountRepository,
                    ref uiMaxAttachmentSizeRepository,
                    ref uiDecayDaysRepository,
                    ref bArbitrationRequiredRepository,
                    ref bIsTeamRepository,
                    ref eloConfigRepository,
                    ref uiEntriesPerCacheLineRepository,
                    ref uiExpirationSecondsRepository,
                    ref bDontListRespository))
                {
                    // this shouldn't happpen, get list said it was there..
                    string sErr = "Xbox.Tools.Framework.CStatsSync.StatsSync: "
                        + "Error: Unable to retrieve competition template id "
                        + uiTemplateId
                        + " from repository";
                    log.LogFile(sErr);
                    throw new CStatsSyncException(sErr);
                }

                // is there a definition for this template on one or more
                // servers?
                bool[] rgbDBMap = (bool[])slCompTemplateDBMap[uiTemplateId];
                if (rgbDBMap != null)
                {
                    // there is a template definition on one or more stats db servers
                    // check to see if they match what's in the repository
                    for (int i = 0; i < rgbDBMap.Length; ++i)
                    {
                        if (rgbDBMap[i])
                        {
                            // template is present on database server i, check it
                            ELBReset riLBResetIntervalDB;
                            uint uiAttachmentCountDB;
                            uint uiMaxAttachmentSizeDB;
                            uint uiDecayDaysDB;
                            bool bArbitrationRequiredDB;
                            bool bIsTeamDB;
                            CELOConfig eloConfigDB;
                            if (!stats.CompTemplateConfigGet(
                                tid,
                                i,
                                uiTemplateId, 
                                out riLBResetIntervalDB,
                                out uiAttachmentCountDB,
                                out uiMaxAttachmentSizeDB,
                                out uiDecayDaysDB,
                                out bArbitrationRequiredDB,
                                out bIsTeamDB,
                                out eloConfigDB))
                            {
                                // shouldn't happen
                                string sErr = "Xbox.Tools.Framework.CStatsSync.StatsSync: "
                                    + "Error: Unable to retrieve competition template id "
                                    + uiTemplateId
                                    + " from stats database "
                                    + i;
                                log.LogFile(sErr);
                                throw new CStatsSyncException(sErr);
                            }

                            bool bMatch = true;
                            // ok we have the details from the server and the repository,
                            // see if they match
                            if (riLBResetIntervalDB != riLBResetIntervalRepository
                                || uiAttachmentCountDB != uiAttachmentCountRepository
                                || uiMaxAttachmentSizeDB != uiMaxAttachmentSizeRepository
                                || uiDecayDaysDB != uiDecayDaysRepository
                                || bArbitrationRequiredDB != bArbitrationRequiredRepository
                                || bIsTeamDB != bIsTeamRepository)
                            {
                                bMatch = false;
                            }

                            // check this separately, have to be careful and null check
                            if (eloConfigDB == null || eloConfigRepository == null)
                            {
                                // if one is null, both should be null
                                if (eloConfigDB != null || eloConfigRepository != null)
                                {
                                    bMatch = false;
                                }
                            }
                            else if (eloConfigDB.ToStatsDBString() != eloConfigRepository.ToStatsDBString())
                            {
                                bMatch = false;
                            }

                            if (!bMatch)
                            {
                                // template uiTemplateId is on the service but not in the repository
                                //   0        1        2        3        4        5        6        7        8
                                log.Console(
                                    "Warning: Competition template id "+uiTemplateId+" on stats server "+i);
                                log.Console(
                                    "         does not match the competition template in the repository.");
                                bDeleteRequired = true;
                            }
                        }
                    }
                }
            }

            // Phew! the checking is over... deal with the results, and abort if 
            // we have to
            if (bDeleteRequired && bAllowDelete)
            {
                // a delete is required and we're allowed to do it, so nuke away!
                //   0        1        2        3        4        5        6        7        8
                log.Console(
                    "Note: Deleting all stats data for titleid "+tid.sTitleIdHexNoPrefix+" from all stats");
                log.Console(
                    "      Database servers");
                stats.TitleDelete(tid, iSqlTimeoutSeconds, bReportOnly);

                // reload our view of the database, since we just nuked everything...
                slCompPartitionMap = stats.CompPartitionGetDatabaseMap(tid);
                slCompTemplateDBMap = stats.CompTemplateGetDatabaseMap(tid);
            }
            else if (bDeleteRequired && !bSafeToContinue && !bAllowDelete)
            {
                // a delete is required and it's not safe to continue the sync without doing it
                // but we're not allowed, so issue the error message and bail.
                //   0        1        2        3        4        5        6        7        8
                log.Console(
                    "Error: To safely sync competition templates, all stats data must first");
                log.Console(
                    "       be deleted from all stats database servers. To perform this ");
                log.Console(
                    "       repeat the current operation and specify the option to allow");
                log.Console(
                    "       deletion (often /force). Competition templates will not be");
                log.Console(
                    "       syncronized at this time");
                return;
            }
            else if (bDeleteRequired)
            {
                // a delete is required but it is safe to continue the sync without doing it
                // so issue a warning and continue
                //   0        1        2        3        4        5        6        7        8
                log.Console(
                    "Warning: To address the warnings issued above, all stats data must");
                log.Console(
                    "         be deleted from all stats database servers. To perform this ");
                log.Console(
                    "         repeat the current operation and specify the option to allow");
                log.Console(
                    "         deletion (often /force). New competition templates and ");
                log.Console(
                    "         competition partitions will be added at this time, but");
                log.Console(
                    "         existing competition templates and competition partitions");
                log.Console(
                    "         will not be changed.");
            }

            // ok, now walk through and add any NEW competition partitions, but only if there
            // are competition templates in the repository
            if (rguiCompsInRepository.Length > 0)
            {
                for (uint ui = 0; ui < rgiPartitionMapInRepository.Length; ++ui)
                {
                    if (rgiPartitionMapInRepository[ui] != -1)
                    {
                        // partition exists in repository, does it already exist on a stats server?
                        if (slCompPartitionMap[ui] == null)
                        {
                            // does not exist on any stats server, so add it.
                            //   0        1        2        3        4        5        6        7        8
                            log.Console(
                                "Adding new competition partition "+ui+" to stats database "+rgiPartitionMapInRepository[ui]);
                            stats.CompPartitionCreate(
                                tid,
                                rgiPartitionMapInRepository[ui],
                                ui,
                                bReportOnly);
                        }
                    }
                }
            }

            // now walk through and add any new competition templates
            foreach (uint uiTemplateId in rguiCompsInRepository)
            {
                // does the template already exist on the stats service somewhere?
                if (slCompTemplateDBMap[uiTemplateId] == null)
                {
                    // template doesn't exist on any stats database, so add it
                    ELBReset riLBResetIntervalRepository = ELBReset.ResetNever;
                    uint uiAttachmentCountRepository = 0;
                    uint uiMaxAttachmentSizeRepository = 0;
                    uint uiDecayDaysRepository = 0;
                    bool bArbitrationRequiredRepository = false;
                    bool bIsTeamRepository = false;
                    CELOConfig eloConfigRepository = null;
                    uint uiEntriesPerCacheLineRepository = 0;
                    uint uiExpirationSecondsRepository = 0;
                    bool bDontListRespository = false;
                    // get the template definition from the repository
                    if (!repository.TitleCompGet(
                        tid,
                        uiTemplateId, 
                        ref riLBResetIntervalRepository,
                        ref uiAttachmentCountRepository,
                        ref uiMaxAttachmentSizeRepository,
                        ref uiDecayDaysRepository,
                        ref bArbitrationRequiredRepository,
                        ref bIsTeamRepository,
                        ref eloConfigRepository,
                        ref uiEntriesPerCacheLineRepository,
                        ref uiExpirationSecondsRepository,
                        ref bDontListRespository))
                    {
                        // this shouldn't happpen, get list said it was there..
                        string sErr = "Xbox.Tools.Framework.CStatsSync.StatsSync: "
                            + "Error: Unable to retrieve competition template id "
                            + uiTemplateId
                            + " from repository";
                        log.LogFile(sErr);
                        throw new CStatsSyncException(sErr);
                    }

                    // note, this overload of this method puts the template on
                    // every database server, so we don't need to write that loop
                    // here.
                    //   0        1        2        3        4        5        6        7        8
                    log.Console(
                        "Adding new competition template id "+uiTemplateId+" to all stats databases");
                    stats.CompTemplateConfigSet(
                        tid,
                        uiTemplateId,
                        riLBResetIntervalRepository,
                        uiAttachmentCountRepository,
                        uiMaxAttachmentSizeRepository,
                        uiDecayDaysRepository,
                        bArbitrationRequiredRepository,
                        bIsTeamRepository,
                        eloConfigRepository,
                        bReportOnly);
                }
            }

            // believe it or not, there's one more little chore we need to do here
            // someday, no doubt, someone is going to add a whole new stats database
            // server in production. Then, at some future time, they are going to want
            // to create a new competition partition on that server. In order to make
            // sure we're ready for that day, we want to make sure that the competition
            // templates exist on all the servers. If a server has been added in the
            // time since this title was last sync'd, that server will be missing the
            // competition template. So re-read the template map one last time, and
            // then, for every template that exists, make sure the template is on every
            // server. This loop does not, and cannot, fix the situation where templates
            // on different servers do not match. But that problem would have been
            // caught and a warning issued above.
            slCompTemplateDBMap = stats.CompTemplateGetDatabaseMap(tid);
            foreach(DictionaryEntry de in slCompTemplateDBMap)
            {
                uint uiTemplateId = (uint)de.Key;
                bool[] rgbDBMap = (bool[])de.Value;

                // find a copy of the template and get it
                bool bFound = false;
                ELBReset riLBResetIntervalDB = ELBReset.ResetNever;
                uint uiAttachmentCountDB = 0;
                uint uiMaxAttachmentSizeDB = 0;
                uint uiDecayDaysDB = 0;
                bool bArbitrationRequiredDB = true;
                bool bIsTeamDB = false;
                CELOConfig eloConfigDB = null;
                for (int i = 0; i < rgbDBMap.Length; ++i)
                {
                    if (rgbDBMap[i])
                    {
                        // template exists on this server, so get it.
                        if (!stats.CompTemplateConfigGet(
                            tid,
                            i,
                            uiTemplateId, 
                            out riLBResetIntervalDB,
                            out uiAttachmentCountDB,
                            out uiMaxAttachmentSizeDB,
                            out uiDecayDaysDB,
                            out bArbitrationRequiredDB,
                            out bIsTeamDB,
                            out eloConfigDB))
                        {
                            // shouldn't happen
                            string sErr = "Xbox.Tools.Framework.CStatsSync.StatsSync: "
                                + "Error: Unable to retrieve competition template id "
                                + uiTemplateId
                                + " from stats database "
                                + i;
                            log.LogFile(sErr);
                            throw new CStatsSyncException(sErr);
                        }
                        bFound = true;
                        break;
                    }
                }

                // make sure we got a copy of the template, which we should always
                // be able to do if there's an entry in the map...
                if (!bFound)
                {
                    // shouldn't happen
                    string sErr = "Xbox.Tools.Framework.CStatsSync.StatsSync: "
                        + "Error: Unable to find competition template id "
                        + uiTemplateId
                        + " on any stats database";
                    log.LogFile(sErr);
                    throw new CStatsSyncException(sErr);
                }

                // now loop through and add the template to any server that doesn't
                // have a copy of it.
                for (int i = 0; i < stats.NumStatsDatabases; ++i)
                {
                    if (rgbDBMap[i] == false)
                    {
                        // this server doesn't have a copy, give it one.
                        //   0        1        2        3        4        5        6        7        8
                        log.Console(
                            "Note: Adding copy of existing competition template id "+uiTemplateId+" to stats ");
                        log.Console(
                            "      database "+i);
                        stats.CompTemplateConfigSet(
                            tid,
                            i,
                            uiTemplateId,
                            riLBResetIntervalDB,
                            uiAttachmentCountDB,
                            uiMaxAttachmentSizeDB,
                            uiDecayDaysDB,
                            bArbitrationRequiredDB,
                            bIsTeamDB,
                            eloConfigDB,
                            bReportOnly);
                    }
                }
            }

            // yes, we're finally done!
            return;
        }

        public static void SyncLimits(
            CTitleId tid,
            CRepository repository,
            CStats stats,
            bool bReportOnly,
            CLog log)
        {
            uint uiMaxWrites = 0;
            uint uiMaxReads = 0;

            // get the limits from the repository, if present
            if (repository.TitleLBLimitsGet(
                tid, 
                ref uiMaxWrites,
                ref uiMaxReads))
            {
                //   0        1        2        3        4        5        6        7        8
                log.Console(
                    "Note: Setting maxwrites ("+uiMaxWrites+") and maxreads ("+uiMaxReads+") in all stats databases.");

                // there are limits in the repository. We want to add these limits
                // to every stats db.
                for (int i = 0; i < stats.NumStatsDatabases; ++i)
                {
                    stats.TitleConfigSet(
                        tid,
                        i,
                        uiMaxWrites,
                        uiMaxReads,
                        bReportOnly);
                }
            }
            return;
        }
    }

    public class CStatsSyncException : ApplicationException
    {
        public CStatsSyncException() : base() {}
        public CStatsSyncException(string s) : base(s) {}
        protected CStatsSyncException(
            System.Runtime.Serialization.SerializationInfo si,
            System.Runtime.Serialization.StreamingContext sc
        ) : base(si, sc) {}
        public CStatsSyncException(string s, Exception e) : base(s, e) {}
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\Framework\CWebDBSync.cs ===
using System;
using System.Collections;

namespace xonline.tools.framework 
{
    public class CWebDBSync
    {
        // these are based on what titlemgr has historically used
        // as a default for these values when nothing was in stats.ini
        private const EESRBRating c_esrbRatingDefault = EESRBRating.Unspecified;
        private const uint c_uiClusterIdDefault = 0;
        private static readonly CLocale c_locDefault = new CLocale("en-US");

        // template id's are shifed to generate something that is
        // stored in webdb. This is how many bits to shift
        private const int c_iTemplateShift = 26;

        public static void WebDBSync(
            CTitleId tid, 
            CRepository repository, 
            CWebDB webdb,
            bool bReportOnly,
            CLog log)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }
            if (repository == null)
            {
                throw new ArgumentNullException("repository");
            }
            if (webdb == null)
            {
                throw new ArgumentNullException("webdb");
            }
            if (log == null)
            {
                throw new ArgumentNullException("log");
            }

            log.StackTrace("Xbox.Tools.Framework.CWebDBSync.WebDBSync("
                + tid.sTitleIdHexNoPrefix + ", "
                + "{repository}, "
                + "{webdb}, "
                + bReportOnly+", "
                + "{log})");

            // Get title wide info from the respository
            EESRBRating esrbRating = c_esrbRatingDefault;
            uint uiClusterId = c_uiClusterIdDefault;
            CLocale locDefault = c_locDefault;

            repository.TitleESRBGet(tid, ref esrbRating);
            repository.TitleWebClusterIdGet(tid, ref uiClusterId);
            repository.TitleDefaultLocaleGet(tid, ref locDefault);

            // get the title descriptions from the repository, by locale
            SortedList slDescByLocale = repository.TitleDescGetListByLocale(tid);

            // if there is no title description for the default locale, then this
            // title should not have any information in webdb
            if (!slDescByLocale.ContainsKey(locDefault.ToString()))
            {
                //   0        1        2        3        4        5        6        7        8
                log.Console(
                    "Note: Missing title description for default locale ("+locDefault.ToString()+")");
                log.Console(
                    "      All information for this title will be removed from webdb");
                webdb.TitleDelete(tid, bReportOnly);
                return;
            }

            // First add or update the title definition
            webdb.TitleConfigSet(
                tid,
                esrbRating,
                locDefault,
                uiClusterId,
                bReportOnly);

            // sync the title descriptions
            SyncTitleDesc(
                tid,
                slDescByLocale,
                webdb,
                locDefault,
                bReportOnly,
                log);

            // get the default web cache config values
            uint uiEntriesPerCacheLineDefault;
            uint uiExpirationSecondsDefault;
            repository.ServiceDefaultWebCacheSettingsGet(
                out uiEntriesPerCacheLineDefault,
                out uiExpirationSecondsDefault);

            // now sync the web leaderboards 
            SyncLeaderboards(
                tid,
                repository,
                webdb,
                locDefault,
                uiEntriesPerCacheLineDefault,
                uiExpirationSecondsDefault,
                bReportOnly,
                log);

            log.StackTrace("Xbox.Tools.Framework.CWebDBSync.WebDBSync complete");
        }

        public static void SyncTitleDesc(
            CTitleId tid, 
            SortedList slDescByLocale, 
            CWebDB webdb,
            CLocale locDefault,
            bool bReportOnly,
            CLog log)
        {
            // get the list of title descriptions currently in webdb
            SortedList slDescInWebDB = webdb.TitleDescGetList(tid);

            // see if we need to delete any title descriptions from webdb
            foreach (DictionaryEntry de in slDescInWebDB)
            {
                string sLocale = (string)de.Key;
                string sDesc = (string)de.Value;

                if (!slDescByLocale.ContainsKey(sLocale))
                {
                    // this description is no longer in the repository, so remove
                    // it from webdb
                    //   0        1        2        3        4        5        6        7        8
                    log.Console(
                        "Deleting title description for locale "+sLocale+" from WebDB");
                    webdb.TitleDescDelete(
                        tid,
                        sLocale,
                        bReportOnly);
                }
            }

            // anything that needed to be deleted has been deleted, so add or update
            // whatever descriptions are in the repository
            int iCountUpdate = 0;
            foreach (DictionaryEntry de in slDescByLocale)
            {
                string sLocale = (string)de.Key;
                string sDesc = (string)de.Value;

                //   0        1        2        3        4        5        6        7        8
                log.LogFile(
                    "Updating title description for locale "+sLocale+" in webdb");
                webdb.TitleDescSet(
                    tid,
                    new CLocale(sLocale),
                    sDesc,
                    bReportOnly);
                ++iCountUpdate;
            }

            //   0        1        2        3        4        5        6        7        8
            log.Console(
                iCountUpdate+" title descriptions added/updated in webdb");
        }

        public static void SyncLeaderboards(
            CTitleId tid, 
            CRepository repository, 
            CWebDB webdb,
            CLocale locDefault,
            uint uiEntriesPerCacheLineDefault,
            uint uiExpirationSecondsDefault,
            bool bReportOnly,
            CLog log)
        {
            // get the list of all types of leaderboards from the repository
            // webdb stores the same stuff for all of these regardless of
            // type, except for one column that records the type.
            uint[] rguiLBsInRepository = repository.TitleLBGetList(tid);
            uint[] rguiUnitsInRepository = repository.TitleUnitGetList(tid);
            uint[] rguiCompsInRepository = repository.TitleCompGetList(tid);

            // walk through each of these arrays, and remember the ones
            // that have descriptions for the default locale - these are
            // the only ones we want to put in webdb.

            // first regular leaderboards.
            SortedList slWebLBsInRepository = new SortedList();
            foreach (uint uiLBInRepository in rguiLBsInRepository)
            {
                // get the list of descriptions for this leaderboard
                SortedList slDescs = repository.TitleLBDescGetList(tid, uiLBInRepository);

                // see if the list contains the default locale
                if (slDescs.ContainsKey(locDefault.ToString()))
                {
                    // this leaderboard has a description for the default locale
                    // so save it to the list of web leaderboards in the repository
                    // Save the list of descriptions so we don't have to get it 
                    // again below.
                    slWebLBsInRepository.Add(uiLBInRepository, slDescs);
                }
                else if (slDescs.Count > 0)
                {
                    // should issue a warning here. This leaderboard has descriptions
                    // so they caller probably expects it to be added to webdb, but
                    // we're not going to because it doesn't have a description
                    // for the default locale...
                    //   0        1        2        3        4        5        6        7        8
                    log.Console(
                        "Warning: Leaderboard "+uiLBInRepository+" has no description for "+locDefault.ToString());
                    log.Console(
                        "         This leaderboard will not be added to webdb.");
                }
                else
                {
                    // not a warning - the caller won't expect this leaderboard to
                    // be added to webdb if there are no descriptions at all
                    log.FullTrace("Xbox.Tools.Framework.CWebDBSync.WebDBSync: "
                        + "Leaderboard number "
                        + uiLBInRepository
                        + " has no descriptions and will not be added to webdb.");
                }
            }

            // then unit leaderboards.
            SortedList slWebUnitsInRepository = new SortedList();
            foreach (uint uiUnitInRepository in rguiUnitsInRepository)
            {
                // get the list of descriptions for this unit leaderboard
                SortedList slDescs = repository.TitleUnitDescGetList(tid, uiUnitInRepository);

                // see if the list contains the default locale
                if (slDescs.ContainsKey(locDefault.ToString()))
                {
                    // this leaderboard has a description for the default locale
                    // so save it to the list of web leaderboards in the repository
                    // Save the list of descriptions so we don't have to get it 
                    // again below.
                    slWebUnitsInRepository.Add(uiUnitInRepository, slDescs);
                }
                else if (slDescs.Count > 0)
                {
                    // should issue a warning here. This unit leaderboard has descriptions
                    // so the caller probably expects it to be added to webdb, but
                    // we're not going to because it doesn't have a description
                    // for the default locale...
                    //   0        1        2        3        4        5        6        7        8
                    log.Console(
                        "Warning: Unit leaderboard "+uiUnitInRepository+"has no description for "+locDefault.ToString());
                    log.Console(
                        "         This unit leaderboard will not be added to webdb.");
                }
                else
                {
                    // not a warning - the caller won't expect this unit leaderboard to
                    // be added to webdb if there are no descriptions at all
                    log.FullTrace("Xbox.Tools.Framework.CWebDBSync.WebDBSync: "
                        + "Unit leaderboard number "
                        + uiUnitInRepository
                        + " has no descriptions and will not be added to webdb.");
                }
            }

            // then competition templates
            SortedList slWebCompsInRepository = new SortedList();
            foreach (uint uiCompInRepository in rguiCompsInRepository)
            {
                // get the list of descriptions for this template
                SortedList slDescs = repository.TitleCompDescGetList(tid, uiCompInRepository);

                // see if the list contains the default locale
                if (slDescs.ContainsKey(locDefault.ToString()))
                {
                    // this template has a description for the default locale
                    // so save it to the list of web templates in the repository
                    // Save the list of descriptions so we don't have to get it 
                    // again below.

                    // NOTE: in webdb, competition templates are stored as the
                    // competition id left shifted 26 bits. Perform that 
                    // transform now.
                    uint uiShiftedCompId = uiCompInRepository << c_iTemplateShift;
                    slWebCompsInRepository.Add(uiShiftedCompId, slDescs);
                }
                else if (slDescs.Count > 0)
                {
                    // should issue a warning here. This template has descriptions
                    // so the caller probably expects it to be added to webdb, but
                    // we're not going to because it doesn't have a description
                    // for the default locale...
                    //   0        1        2        3        4        5        6        7        8
                    log.Console(
                        "Warning: Competition template "+uiCompInRepository+"has no description for "+locDefault.ToString());
                    log.Console(
                        "         This competition template will not be added to webdb.");
                }
                else
                {
                    // not a warning - the caller won't expect this template to
                    // be added to webdb if there are no descriptions at all
                    log.FullTrace("Xbox.Tools.Framework.CWebDBSync.WebDBSync: "
                        + "Competition template number "
                        + uiCompInRepository
                        + " has no descriptions and will not be added to webdb.");
                }
            }

            // get a list of leaderboards that are currently configured in webdb
            uint[] rguiLBsInWebDB = webdb.WebLBGetList(tid);
            ArrayList alLBsInWebDB = new ArrayList(rguiLBsInWebDB);

            // first we look for leaderboards to delete from webdb completely
            foreach (uint uiLBInWebDB in rguiLBsInWebDB)
            {
                // does this leaderboard have web information in the repository?
                // note that it could be any of the three types of leaderboard

                // Note: competition template ids are stored left shifted 26 bits
                // This shift was performed before the key was added to the competition
                // sorted list, so this is comparing apples to apples.
                if (!slWebLBsInRepository.ContainsKey(uiLBInWebDB)
                    && !slWebUnitsInRepository.ContainsKey(uiLBInWebDB)
                    && !slWebCompsInRepository.ContainsKey(uiLBInWebDB))
                {
                    // There is no web information for this leaderboard in the repository, 
                    // so we should completely delete it from webdb
                    log.FullTrace("Xbox.Tools.Framework.CWebDBSync.WebDBSync: "
                        + "Removing web leaderboard number "
                        + uiLBInWebDB
                        + " from webdb.");
                    webdb.WebLBDelete(
                        tid,
                        uiLBInWebDB,
                        bReportOnly);
                }
            }

            // we have now removed any leaderboards that shouldn't be there
            // (or issued warnings about them). Walk throught the leaderboards
            // defined in the repository and update webdb
            foreach (DictionaryEntry de in slWebLBsInRepository)
            {
                SyncLeaderboard(
                    tid,
                    webdb,
                    repository,
                    (uint)de.Key,
                    locDefault,
                    (SortedList)de.Value,
                    uiEntriesPerCacheLineDefault,
                    uiExpirationSecondsDefault,
                    bReportOnly,
                    log);
            }

            foreach (DictionaryEntry de in slWebUnitsInRepository)
            {
                SyncUnit(
                    tid,
                    webdb,
                    repository,
                    (uint)de.Key,
                    locDefault,
                    (SortedList)de.Value,
                    uiEntriesPerCacheLineDefault,
                    uiExpirationSecondsDefault,
                    bReportOnly,
                    log);
            }

            foreach (DictionaryEntry de in slWebCompsInRepository)
            {
                SyncComp(
                    tid,
                    webdb,
                    repository,
                    (uint)de.Key,
                    locDefault,
                    (SortedList)de.Value,
                    uiEntriesPerCacheLineDefault,
                    uiExpirationSecondsDefault,
                    bReportOnly,
                    log);
            }
        }

        private static void SyncLeaderboard(
            CTitleId tid,
            CWebDB webdb,
            CRepository repository,
            uint uiLBNum,
            CLocale locDefault,
            SortedList slLBDescInRepository,
            uint uiEntriesPerCacheLineDefault,
            uint uiExpirationSecondsDefault,
            bool bReportOnly,
            CLog log)
        {
            // get the leaderboard definition from the repository
            int iStatsDatabase = 0;
            ELBReset riLBResetInterval = ELBReset.ResetNever;
            uint uiAttachmentCount = 0;
            uint uiMaxAttachmentSize = 0;
            uint uiDecayDays = 0;
            uint uiMaxRatingCount = 0;
            bool bArbitrationRequired = false;
            bool bIsTeam = false;
            CELOConfig eloConfig = null;
            uint uiEntriesPerCacheLine = uiEntriesPerCacheLineDefault;
            uint uiExpirationSeconds = uiExpirationSecondsDefault;
            bool bDontList = false;

            if (!repository.TitleLBGet(
                tid,
                uiLBNum, 
                ref iStatsDatabase,
                ref riLBResetInterval,
                ref uiAttachmentCount,
                ref uiMaxAttachmentSize,
                ref uiDecayDays,
                ref uiMaxRatingCount,
                ref bArbitrationRequired,
                ref bIsTeam,
                ref eloConfig,
                ref uiEntriesPerCacheLine,
                ref uiExpirationSeconds,
                ref bDontList))
            {
                // this should not happen
                string sErr = "Xbox.Tools.Framework.CWebDBSync.WebDBSync: "
                    + "Could not find leaderboard "
                    + uiLBNum
                    + " in repository as expected";
                log.LogFile(sErr);
                throw new CWebDBSyncException(sErr);
            }

            // figure out the webleaderboard type
            EWebLBType webLBType = EWebLBType.Regular;
            if (bIsTeam)
            {
                webLBType = EWebLBType.RegularTeam;
            }

            // create or update the leaderboard definition in webdb
            webdb.WebLBConfigSet(
                tid,
                uiLBNum,
                riLBResetInterval,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                webLBType,
                bDontList,
                bReportOnly);

            // get the list of leaderboard descriptions in webdb
            SortedList slLBDescInWebDB = webdb.WebLBDescGetList(tid, uiLBNum);

            // the list of leaderboard descriptions in the repository was passed in...

            // remove any leaderboard descriptions from webdb that are not in the repository
            foreach (DictionaryEntry de in  slLBDescInWebDB)
            {
                if (!slLBDescInRepository.ContainsKey(de.Key))
                {
                    // this description is not in the repository, remove it from webdb
                    string sLocale = (string)de.Key;
                    log.FullTrace("Xbox.Tools.Framework.CWebDBSync.WebDBSync: "
                        + "Removing leaderboard description for locale "
                        + sLocale
                        + " for leaderboard number "
                        + uiLBNum
                        + "from webdb.");
                    webdb.WebLBDescDelete(
                        tid,
                        uiLBNum,
                        sLocale,
                        bReportOnly);
                }
            }

            // now update the descriptions in webdb with what is in the repository
            foreach (DictionaryEntry de in slLBDescInRepository)
            {
                string sLocale = (string)de.Key;
                string sDesc = (string)de.Value;
                webdb.WebLBDescSet(
                    tid,
                    uiLBNum,
                    new CLocale(sLocale),
                    sDesc,
                    bReportOnly);
            }

            // get the list of leaderboard attributes in webdb
            SortedList slLBAttrInWebDB = webdb.WebLBAttrGetList(tid, uiLBNum);

            // get the list of leaderboard attributes in the repository
            SortedList slLBAttrInRepository = repository.TitleLBAttrGetList(tid, uiLBNum);

            // remove any leaderboard attributes from webdb that are not in the repository
            foreach (DictionaryEntry de in  slLBAttrInWebDB)
            {
                if (!slLBAttrInRepository.ContainsKey(de.Key))
                {
                    // this attribute is not in the repository, remove it from webdb
                    uint uiId = (uint)de.Key;
                    log.FullTrace("Xbox.Tools.Framework.CWebDBSync.WebDBSync: "
                        + "Removing leaderboard attribute id "
                        + uiId
                        + " for leaderboard number "
                        + uiLBNum
                        + "from webdb.");
                    webdb.WebLBAttrDelete(
                        tid,
                        uiLBNum,
                        uiId,
                        bReportOnly);
                }
            }

            // now update the attributes in webdb with what is in the repository
            foreach (DictionaryEntry de in slLBAttrInRepository)
            {
                uint uiId = (uint)de.Key;
                bool bIsPuid = (bool)de.Value;
                webdb.WebLBAttrSet(
                    tid,
                    uiLBNum,
                    uiId,
                    bIsPuid,
                    bReportOnly);
            }

            // get the list of leaderboard formatted values in webdb
            string[] rgsLBValuesInWebDB = webdb.WebLBValueGetList(tid, uiLBNum);

            // get the list of leaderboard formatted values in the repository
            string[] rgsLBValuesInRepository = repository.TitleLBValueGetList(tid, uiLBNum);
            SortedList slLBValuesInRepository = new SortedList();
            foreach (string sName in rgsLBValuesInRepository)
            {
                // if we don't have a description for the default locale for this
                // value then it should not be added to webdb
                SortedList slDescsInRepository
                    = repository.TitleLBValueDescGetList(tid, uiLBNum, sName);
                if (slDescsInRepository.ContainsKey(locDefault.ToString()))
                {
                    // this formatted value has a description for the default locale
                    // so we're ok to add it to webdb
                    slLBValuesInRepository.Add(sName, slDescsInRepository);
                }
            }

            // remove any leaderboard formatted values from webdb that are not in the repository
            foreach (string sName in  rgsLBValuesInWebDB)
            {
                if (!slLBValuesInRepository.ContainsKey(sName))
                {
                    // this formatted value is not in the repository, remove it from webdb
                    log.FullTrace("Xbox.Tools.Framework.CWebDBSync.WebDBSync: "
                        + "Removing leaderboard formatted value named "
                        + sName
                        + " from leaderboard number "
                        + uiLBNum
                        + "from webdb.");
                    webdb.WebLBValueDelete(
                        tid,
                        uiLBNum,
                        sName,
                        bReportOnly);
                }
            }

            // now update the formatted values in webdb with what is in the repository
            foreach (DictionaryEntry deValue in slLBValuesInRepository)
            {
                string sName = (string)deValue.Key;
                EWebValueReturnType returnType = EWebValueReturnType.String;
                string sFormula = null;
                if (repository.TitleLBValueGet(tid, uiLBNum, sName, ref returnType, ref sFormula))
                {
                    webdb.WebLBValueSet(tid, uiLBNum, sName, returnType, sFormula, bReportOnly);

                    // now update the formatted value descriptions

                    // get the descriptions in the repository, saved above.
                    SortedList slDescsInRepository = (SortedList)deValue.Value;

                    // get the descriptions currently in webdb
                    SortedList slDescsInWebDB
                        = webdb.WebLBValueDescGetList(tid, uiLBNum, sName);

                    // delete any descriptions that should no longer be there
                    foreach (DictionaryEntry deDesc in slDescsInWebDB)
                    {
                        string sLocale = (string)deDesc.Key;
                        if (!slDescsInRepository.ContainsKey(sLocale))
                        {
                            webdb.WebLBValueDescDelete(tid, uiLBNum, sName, sLocale, bReportOnly);
                        }
                    }

                    // any descriptions that should be gone are now gone, so update
                    // the ones that we want
                    foreach (DictionaryEntry deDesc in slDescsInRepository)
                    {
                        CLocale locale = new CLocale((string)deDesc.Key);
                        string sDesc = (string)deDesc.Value;
                        webdb.WebLBValueDescSet(tid, uiLBNum, sName, locale, sDesc, bReportOnly);
                    }
                }
                else
                {
                    // this shouldn't happen, the repository said it was in there..
                    log.LogFile("Xbox.Tools.Framework.CWebDBSync.WebDBSync: "
                        + "Unable to retrieve leaderboard formatted value named "
                        + sName
                        + " for leaderboard number "
                        + uiLBNum
                        + "from repository. This formatted value will be ignored.");
                }
            }
        }

        private static void SyncUnit(
            CTitleId tid,
            CWebDB webdb,
            CRepository repository,
            uint uiUnitNum,
            CLocale locDefault,
            SortedList slUnitDescInRepository,
            uint uiEntriesPerCacheLineDefault,
            uint uiExpirationSecondsDefault,
            bool bReportOnly,
            CLog log)
        {
            // get the leaderboard definition from the repository
            bool bArbitrationRequired = false;
            bool bIsTeam = false;
            CELOConfig eloConfig = null;
            uint uiEntriesPerCacheLine = uiEntriesPerCacheLineDefault;
            uint uiExpirationSeconds = uiExpirationSecondsDefault;
            bool bDontList = false;

            if (!repository.TitleUnitGet(
                tid,
                uiUnitNum, 
                ref bArbitrationRequired,
                ref bIsTeam,
                ref eloConfig,
                ref uiEntriesPerCacheLine,
                ref uiExpirationSeconds,
                ref bDontList))
            {
                // this should not happen
                string sErr = "Xbox.Tools.Framework.CWebDBSync.WebDBSync: "
                    + "Could not find unit leaderboard "
                    + uiUnitNum
                    + " in repository as expected";
                log.LogFile(sErr);
                throw new CWebDBSyncException(sErr);
            }

            // figure out the webleaderboard type
            EWebLBType webLBType = EWebLBType.Unit;
            if (bIsTeam)
            {
                webLBType = EWebLBType.UnitTeam;
            }

            // create or update the leaderboard definition in webdb
            webdb.WebLBConfigSet(
                tid,
                uiUnitNum,
                ELBReset.ResetNever, // unit leaderboards don't reset
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                webLBType,
                bDontList,
                bReportOnly);

            // get the list of unit leaderboard descriptions in webdb
            SortedList slUnitDescInWebDB = webdb.WebLBDescGetList(tid, uiUnitNum);

            // the list of unit leaderboard descriptions in the repository was passed in...

            // remove any unit leaderboard descriptions from webdb that are not in the repository
            foreach (DictionaryEntry de in  slUnitDescInWebDB)
            {
                if (!slUnitDescInRepository.ContainsKey(de.Key))
                {
                    // this description is not in the repository, remove it from webdb
                    string sLocale = (string)de.Key;
                    log.FullTrace("Xbox.Tools.Framework.CWebDBSync.WebDBSync: "
                        + "Removing unit leaderboard description for locale "
                        + sLocale
                        + " for unit leaderboard number "
                        + uiUnitNum
                        + "from webdb.");
                    webdb.WebLBDescDelete(
                        tid,
                        uiUnitNum,
                        sLocale,
                        bReportOnly);
                }
            }

            // now update the descriptions in webdb with what is in the repository
            foreach (DictionaryEntry de in slUnitDescInRepository)
            {
                string sLocale = (string)de.Key;
                string sDesc = (string)de.Value;
                webdb.WebLBDescSet(
                    tid,
                    uiUnitNum,
                    new CLocale(sLocale),
                    sDesc,
                    bReportOnly);
            }

            // get the list of leaderboard attributes in webdb
            SortedList slUnitAttrInWebDB = webdb.WebLBAttrGetList(tid, uiUnitNum);

            // get the list of leaderboard attributes in the repository
            SortedList slUnitAttrInRepository = repository.TitleUnitAttrGetList(tid, uiUnitNum);

            // remove any leaderboard attributes from webdb that are not in the repository
            foreach (DictionaryEntry de in  slUnitAttrInWebDB)
            {
                if (!slUnitAttrInRepository.ContainsKey(de.Key))
                {
                    // this attribute is not in the repository, remove it from webdb
                    uint uiId = (uint)de.Key;
                    log.FullTrace("Xbox.Tools.Framework.CWebDBSync.WebDBSync: "
                        + "Removing unit leaderboard attribute id "
                        + uiId
                        + " for unit leaderboard number "
                        + uiUnitNum
                        + "from webdb.");
                    webdb.WebLBAttrDelete(
                        tid,
                        uiUnitNum,
                        uiId,
                        bReportOnly);
                }
            }

            // now update the attributes in webdb with what is in the repository
            foreach (DictionaryEntry de in slUnitAttrInRepository)
            {
                uint uiId = (uint)de.Key;
                bool bIsPuid = (bool)de.Value;
                webdb.WebLBAttrSet(
                    tid,
                    uiUnitNum,
                    uiId,
                    bIsPuid,
                    bReportOnly);
            }

            // get the list of leaderboard formatted values in webdb
            string[] rgsUnitValuesInWebDB = webdb.WebLBValueGetList(tid, uiUnitNum);

            // get the list of leaderboard formatted values in the repository
            string[] rgsUnitValuesInRepository = repository.TitleUnitValueGetList(tid, uiUnitNum);
            SortedList slUnitValuesInRepository = new SortedList();
            foreach (string sName in rgsUnitValuesInRepository)
            {
                // if we don't have a description for the default locale for this
                // value then it should not be added to webdb
                SortedList slDescsInRepository
                    = repository.TitleUnitValueDescGetList(tid, uiUnitNum, sName);
                if (slDescsInRepository.ContainsKey(locDefault.ToString()))
                {
                    // this formatted value has a description for the default locale
                    // so we're ok to add it to webdb
                    slUnitValuesInRepository.Add(sName, slDescsInRepository);
                }
            }

            // remove any leaderboard formatted values from webdb that are not in the repository
            foreach (string sName in  rgsUnitValuesInWebDB)
            {
                if (!slUnitValuesInRepository.ContainsKey(sName))
                {
                    // this formatted value is not in the repository, remove it from webdb
                    log.FullTrace("Xbox.Tools.Framework.CWebDBSync.WebDBSync: "
                        + "Removing unit leaderboard formatted value named "
                        + sName
                        + " from unit leaderboard number "
                        + uiUnitNum
                        + "from webdb.");
                    webdb.WebLBValueDelete(
                        tid,
                        uiUnitNum,
                        sName,
                        bReportOnly);
                }
            }

            // now update the formatted values in webdb with what is in the repository
            foreach (DictionaryEntry deValue in slUnitValuesInRepository)
            {
                string sName = (string)deValue.Key;
                EWebValueReturnType returnType = EWebValueReturnType.String;
                string sFormula = null;
                if (repository.TitleUnitValueGet(tid, uiUnitNum, sName, ref returnType, ref sFormula))
                {
                    webdb.WebLBValueSet(tid, uiUnitNum, sName, returnType, sFormula, bReportOnly);

                    // now update the formatted value descriptions

                    // get the descriptions in the repository, saved above.
                    SortedList slDescsInRepository = (SortedList)deValue.Value;

                    // get the descriptions currently in webdb
                    SortedList slDescsInWebDB
                        = webdb.WebLBValueDescGetList(tid, uiUnitNum, sName);

                    // delete any descriptions that should no longer be there
                    foreach (DictionaryEntry deDesc in slDescsInWebDB)
                    {
                        string sLocale = (string)deDesc.Key;
                        if (!slDescsInRepository.ContainsKey(sLocale))
                        {
                            webdb.WebLBValueDescDelete(tid, uiUnitNum, sName, sLocale, bReportOnly);
                        }
                    }

                    // any descriptions that should be gone are now gone, so update
                    // the ones that we want
                    foreach (DictionaryEntry deDesc in slDescsInRepository)
                    {
                        CLocale locale = new CLocale((string)deDesc.Key);
                        string sDesc = (string)deDesc.Value;
                        webdb.WebLBValueDescSet(tid, uiUnitNum, sName, locale, sDesc, bReportOnly);
                    }
                }
                else
                {
                    // this shouldn't happen, the repository said it was in there..
                    log.LogFile("Xbox.Tools.Framework.CWebDBSync.WebDBSync: "
                        + "Unable to retrieve unit leaderboard formatted value named "
                        + sName
                        + " for unit leaderboard number "
                        + uiUnitNum
                        + "from repository. This formatted value will be ignored.");
                }
            }
        }

        private static void SyncComp(
            CTitleId tid,
            CWebDB webdb,
            CRepository repository,
            uint uiCompNum,
            CLocale locDefault,
            SortedList slCompDescInRepository,
            uint uiEntriesPerCacheLineDefault,
            uint uiExpirationSecondsDefault,
            bool bReportOnly,
            CLog log)
        {
            // get the leaderboard definition from the repository
            ELBReset riLBResetInterval = ELBReset.ResetNever;
            uint uiAttachmentCount = 0;
            uint uiMaxAttachmentSize = 0;
            uint uiDecayDays = 0;
            bool bArbitrationRequired = false;
            bool bIsTeam = false;
            CELOConfig eloConfig = null;
            uint uiEntriesPerCacheLine = uiEntriesPerCacheLineDefault;
            uint uiExpirationSeconds = uiExpirationSecondsDefault;
            bool bDontList = false;

            if (!repository.TitleCompGet(
                tid,
                uiCompNum >> c_iTemplateShift, 
                ref riLBResetInterval,
                ref uiAttachmentCount,
                ref uiMaxAttachmentSize,
                ref uiDecayDays,
                ref bArbitrationRequired,
                ref bIsTeam,
                ref eloConfig,
                ref uiEntriesPerCacheLine,
                ref uiExpirationSeconds,
                ref bDontList))
            {
                // this should not happen
                string sErr = "Xbox.Tools.Framework.CWebDBSync.WebDBSync: "
                    + "Could not find competition template "
                    + uiCompNum
                    + " ("
                    + (uiCompNum >> c_iTemplateShift)
                    + ") in repository as expected";
                log.LogFile(sErr);
                throw new CWebDBSyncException(sErr);
            }

            // figure out the webleaderboard type
            EWebLBType webLBType = EWebLBType.CompetitionTemplate;
            if (bIsTeam)
            {
                webLBType = EWebLBType.CompetitionTemplateTeam;
            }

            // create or update the competition template definition in webdb
            webdb.WebLBConfigSet(
                tid,
                uiCompNum,
                riLBResetInterval,
                uiEntriesPerCacheLine,
                uiExpirationSeconds,
                webLBType,
                bDontList,
                bReportOnly);

            // get the list of competition template descriptions in webdb
            SortedList slCompDescInWebDB = webdb.WebLBDescGetList(tid, uiCompNum);

            // the list of competition template descriptions in the repository was passed in...

            // remove any competition template descriptions from webdb that are not in the repository
            foreach (DictionaryEntry de in  slCompDescInWebDB)
            {
                if (!slCompDescInRepository.ContainsKey(de.Key))
                {
                    // this description is not in the repository, remove it from webdb
                    string sLocale = (string)de.Key;
                    log.FullTrace("Xbox.Tools.Framework.CWebDBSync.WebDBSync: "
                        + "Removing competition template description for locale "
                        + sLocale
                        + " for competition template number "
                        + uiCompNum
                        + " ("
                        + (uiCompNum >> c_iTemplateShift)
                        + ") from webdb.");
                    webdb.WebLBDescDelete(
                        tid,
                        uiCompNum,
                        sLocale,
                        bReportOnly);
                }
            }

            // now update the descriptions in webdb with what is in the repository
            foreach (DictionaryEntry de in slCompDescInRepository)
            {
                string sLocale = (string)de.Key;
                string sDesc = (string)de.Value;
                webdb.WebLBDescSet(
                    tid,
                    uiCompNum,
                    new CLocale(sLocale),
                    sDesc,
                    bReportOnly);
            }

            // get the list of template attributes in webdb
            SortedList slCompAttrInWebDB = webdb.WebLBAttrGetList(tid, uiCompNum);

            // get the list of template attributes in the repository
            SortedList slCompAttrInRepository = repository.TitleCompAttrGetList(tid, uiCompNum >> c_iTemplateShift);

            // remove any template attributes from webdb that are not in the repository
            foreach (DictionaryEntry de in  slCompAttrInWebDB)
            {
                if (!slCompAttrInRepository.ContainsKey(de.Key))
                {
                    // this attribute is not in the repository, remove it from webdb
                    uint uiId = (uint)de.Key;
                    log.FullTrace("Xbox.Tools.Framework.CWebDBSync.WebDBSync: "
                        + "Removing competition template attribute id "
                        + uiId
                        + " for competition template number "
                        + uiCompNum
                        + " ("
                        + (uiCompNum >> c_iTemplateShift)
                        + ") from webdb.");
                    webdb.WebLBAttrDelete(
                        tid,
                        uiCompNum,
                        uiId,
                        bReportOnly);
                }
            }

            // now update the attributes in webdb with what is in the repository
            foreach (DictionaryEntry de in slCompAttrInRepository)
            {
                uint uiId = (uint)de.Key;
                bool bIsPuid = (bool)de.Value;
                webdb.WebLBAttrSet(
                    tid,
                    uiCompNum,
                    uiId,
                    bIsPuid,
                    bReportOnly);
            }

            // get the list of template formatted values in webdb
            string[] rgsCompValuesInWebDB = webdb.WebLBValueGetList(tid, uiCompNum);

            // get the list of template formatted values in the repository
            string[] rgsCompValuesInRepository = repository.TitleCompValueGetList(
                tid, 
                uiCompNum >> c_iTemplateShift);
            SortedList slCompValuesInRepository = new SortedList();
            foreach (string sName in rgsCompValuesInRepository)
            {
                // if we don't have a description for the default locale for this
                // value then it should not be added to webdb
                SortedList slDescsInRepository
                    = repository.TitleCompValueDescGetList(
                    tid, 
                    uiCompNum >> c_iTemplateShift, 
                    sName);
                if (slDescsInRepository.ContainsKey(locDefault.ToString()))
                {
                    // this formatted value has a description for the default locale
                    // so we're ok to add it to webdb
                    slCompValuesInRepository.Add(sName, slDescsInRepository);
                }
            }

            // remove any template formatted values from webdb that are not in the repository
            foreach (string sName in  rgsCompValuesInWebDB)
            {
                if (!slCompValuesInRepository.ContainsKey(sName))
                {
                    // this formatted value is not in the repository, remove it from webdb
                    log.FullTrace("Xbox.Tools.Framework.CWebDBSync.WebDBSync: "
                        + "Removing competition template formatted value named "
                        + sName
                        + " from competition template number "
                        + uiCompNum
                        + " ("
                        + (uiCompNum >> c_iTemplateShift)
                        + "from webdb.");
                    webdb.WebLBValueDelete(
                        tid,
                        uiCompNum,
                        sName,
                        bReportOnly);
                }
            }

            // now update the formatted values in webdb with what is in the repository
            foreach (DictionaryEntry deValue in slCompValuesInRepository)
            {
                string sName = (string)deValue.Key;
                EWebValueReturnType returnType = EWebValueReturnType.String;
                string sFormula = null;
                if (repository.TitleCompValueGet(
                    tid, 
                    uiCompNum >> c_iTemplateShift, 
                    sName, 
                    ref returnType, 
                    ref sFormula))
                {
                    webdb.WebLBValueSet(tid, uiCompNum, sName, returnType, sFormula, bReportOnly);

                    // now update the formatted value descriptions

                    // get the descriptions in the repository, saved above.
                    SortedList slDescsInRepository = (SortedList)deValue.Value;

                    // get the descriptions currently in webdb
                    SortedList slDescsInWebDB
                        = webdb.WebLBValueDescGetList(tid, uiCompNum, sName);

                    // delete any descriptions that should no longer be there
                    foreach (DictionaryEntry deDesc in slDescsInWebDB)
                    {
                        string sLocale = (string)deDesc.Key;
                        if (!slDescsInRepository.ContainsKey(sLocale))
                        {
                            webdb.WebLBValueDescDelete(tid, uiCompNum, sName, sLocale, bReportOnly);
                        }
                    }

                    // any descriptions that should be gone are now gone, so update
                    // the ones that we want
                    foreach (DictionaryEntry deDesc in slDescsInRepository)
                    {
                        CLocale locale = new CLocale((string)deDesc.Key);
                        string sDesc = (string)deDesc.Value;
                        webdb.WebLBValueDescSet(tid, uiCompNum, sName, locale, sDesc, bReportOnly);
                    }
                }
                else
                {
                    // this shouldn't happen, the repository said it was in there..
                    log.LogFile("Xbox.Tools.Framework.CWebDBSync.WebDBSync: "
                        + "Unable to retrieve comptition template formatted value named "
                        + sName
                        + " for competition template number "
                        + uiCompNum
                        + " ("
                        + (uiCompNum >> c_iTemplateShift)
                        + ") from repository. This formatted value will be ignored.");
                }
            }
        }
    }

    public class CWebDBSyncException : ApplicationException
    {
        public CWebDBSyncException() : base() {}
        public CWebDBSyncException(string s) : base(s) {}
        protected CWebDBSyncException(
            System.Runtime.Serialization.SerializationInfo si,
            System.Runtime.Serialization.StreamingContext sc
        ) : base(si, sc) {}
        public CWebDBSyncException(string s, Exception e) : base(s, e) {}
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Framework\Framework\CVoucher.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Runtime.Serialization;
using System.Text;

using xonline.common.config;
using xonline.common.service;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;

namespace xonline.tools.framework
{
    /// <summary>
    /// Information about a single voucher.
    /// </summary>
    public struct VoucherInfo
    {
        public ulong    _offerID;
        public int      _useCount;
        public int      _numVouchers;
        public string   _status;
        public byte     _SCG;
        public byte     _consolever;
    }

    /// <summary>
    /// Information about a single usage of a voucher.
    /// </summary>
    public struct VoucherUseInfo
    {
        public ulong    _puid;
        public DateTime _whenUsed;
    }

    /// <summary>
    /// Exception thrown when trying to add a hash to a nonexistent offer id.
    /// </summary>
    public class InvalidOfferIdException : Exception, ISerializable
    {
        const string message = "Offer Id {0} does not exist.";
        public InvalidOfferIdException(ulong offerId) :  base( string.Format(message, offerId) ) { }
        public InvalidOfferIdException( SerializationInfo info, StreamingContext context ) :  base( info, context ) { }
    }

    /// <summary>
    /// This class encapsulates all voucher-related actions against UODB.
    /// </summary>
    public sealed class CVoucher : IDisposable
    {
        private WSClient _ws;

        public const ulong CVOUCHER_ALL_OFFERS = 0xFFFFFFFFFFFFFFFF;
        public const string VOUCHER_STATUS_ACTIVE = "Active";
        public const string VOUCHER_STATUS_DISABLED = "Disabled";

        /// <summary>
        /// constructor
        /// </summary>
        public CVoucher()
        {
            _ws = new WSClient(ConfigUtil.TokendbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE);
        }

        /// <summary>
        /// Finalizer.  Cleanup webstore connections.
        /// </summary>
        ~CVoucher()
        {
            Dispose(false);
        }


        /// <summary>
        /// Returns the number of UODB logical partitions.
        /// </summary>
        /// <returns>number of UODB partitions</returns>
        public int GetNumPartitions()
        {
            return _ws.LogicalPartitions;
        }


        /// <summary>
        /// Calculates the logical partition for a given hash value.
        /// </summary>
        /// <param name="hash">hash value</param>
        /// <returns>logical partition number</returns>
        public int GetPartition( byte[] hash )
        {
            return _ws.CalcPartition( BitConverter.ToInt64( hash, 0 ) );
        }
        private static void VerifyOfferExistence(ulong offerId)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                // Data is partitioned by offer id
                ws.Partition = WstCommand.AnyPartition;
                ws.StoredProc = "dbo.p_verify_offer_exists";
                ws.AddParameter(ParamType.RETVAL, "@hr", 0);
                ws.AddParameter("@bi_offer_id", offerId);
                uint hr = (uint)ws.GetIntParameter("@hr");
                if (hr == HResult.XOFF_E_INVALID_OFFER_ID)
                {
                    throw new InvalidOfferIdException(offerId);
                }
            }
        }

        /// <summary>
        /// Adds or updates a voucher.
        /// </summary>
        /// <param name="hash">Hash of voucher to add.</param>
        /// <param name="offerId">Offer Id this hash is associated to.</param>
        /// <param name="useCount">Maximum number of uses on this voucher.</param>
        /// <param name="status">0 = Enabled, 1 = Disabled</param>
        /// <param name="SCG">0 = Disabled, 1 = Enabled</param>
        /// <param name="consolever">1 = Xbox, 2 = Xenon</param>
        /// <returns>0 = new voucher inserted, 1 = existing voucher updated</returns>
        public uint SetVoucher( byte[] hash, ulong offerId, int useCount, int status, byte SCG, byte consolever )
        {
            uint hr = 0;
            VerifyOfferExistence(offerId);
            _ws.ClearParameters();
            _ws.StoredProc = "dbo.p_svc_add_voucher";
            _ws.SetHashVal( BitConverter.ToInt64( hash, 0 ) );

            _ws.AddParameter( ParamType.RETVAL, "@RETVAL", hr );
            _ws.AddParameter( "@bin_voucher_hash", hash );
            _ws.AddParameter( "@bi_offer_id", offerId );
            _ws.AddParameter( "@i_use_count", useCount );
            _ws.AddParameter( "@si_hash_bucket", _ws.Partition );
            _ws.AddParameter( "@i_voucher_status_id", status );
            _ws.AddParameter( "@f_in_SCG", SCG );
            _ws.AddParameter( "@f_consolever", consolever );

            _ws.ExecuteNonQuery();

            hr = (uint) _ws.GetIntParameter( "@RETVAL" );
            return hr;
        }


        /// <summary>
        /// Adds or updates multiple vouchers.
        /// </summary>
        /// <param name="hashList">List of voucher hashes to add.</param>
        /// <param name="firstIndex">index of first item to flush</param>
        /// <param name="lastIndex">index of last item to flush</param>
        /// <param name="partition">Logical partition for all hashes.</param>
        /// <param name="offerId">Offer Id this hash is associated to.</param>
        /// <param name="useCount">Maximum number of uses on this voucher.</param>
        /// <param name="status">0 = Enabled, 1 = Disabled</param>
        /// <param name="SCG">0 = Disabled, 1 = Enabled</param>
        /// <param name="consolever">1 = Xbox, 2 = Xenon</param>
        public void SetVouchers( ArrayList hashList, int firstIndex, int lastIndex, int partition,
            ulong offerId, int useCount, int status, byte SCG, byte consolever )
        {
            uint hr = 0;
            VerifyOfferExistence(offerId);
            _ws.ClearParameters();
            _ws.StoredProc = "dbo.p_svc_add_vouchers";
            _ws.Partition = partition;

            _ws.AddParameter( ParamType.RETVAL, "@RETVAL", hr );

            StringBuilder xml = new StringBuilder( 40 * hashList.Count );
            for( int i = firstIndex; i <= lastIndex; ++i ) {
                xml.Append( "<a h=\"" + Convert.ToBase64String( (byte[]) hashList[i] ) + "\"/>" );
            }
            _ws.AddParameter( "@xml_voucher_hashes", xml.ToString() );
            _ws.AddParameter( "@bi_offer_id", offerId );
            _ws.AddParameter( "@i_use_count", useCount );
            _ws.AddParameter( "@si_hash_bucket", _ws.Partition );
            _ws.AddParameter( "@i_voucher_status_id", status );
            _ws.AddParameter( "@f_in_SCG", SCG );
            _ws.AddParameter( "@f_consolever", consolever );

            _ws.ExecuteNonQuery();

            hr = (uint) _ws.GetIntParameter( "@RETVAL" );
        }


        /// <summary>
        /// Delete a voucher.  Note that this will only prevent
        /// subsequent use of a voucher, and will not impact
        /// any user's with active subscriptions created using
        /// the voucher being deleted.
        /// </summary>
        /// <param name="hash"></param>
        /// <param name="ulOfferId">Specify a specific offer id that the
        /// specified hashes will be disassociated from, or CVOUCHER_ALL_OFFERS
        /// to disassociate from all offers.</param>
        public void DeleteVoucher(byte [] hash, ulong ulOfferId)
        {
            _ws.ClearParameters();
            _ws.StoredProc = "dbo.p_svc_delete_voucher";
            _ws.SetHashVal(BitConverter.ToInt64(hash, 0));
            _ws.AddParameter("@bin_voucher_hash", hash);
            _ws.AddParameter("@bi_offer_id", ulOfferId);
            _ws.ExecuteNonQuery();
        }

        /// <summary>
        /// Return usage summaries for all vouchers, grouped by offer id, use count and status.
        /// </summary>
        public void GetVouchersSummary(out ArrayList info)
        {
            info = new ArrayList();

            using (WstConnection c = new WstConnection(ConfigUtil.TokendbWebstoreApp))
            {
                c.Open();

                for (int i=0; i < c.SqlPartitions.Count; i++)
                {
                    WstConnection conn = null;
                    WstDataReader rdr = null;

                    try
                    {
                        conn = new WstConnection(ConfigUtil.TokendbWebstoreApp);
                        conn.Open();

                        WstCommand cmd = conn.CreateCommand();
                        cmd.CommandType = CommandType.StoredProcedure;
                        cmd.CommandText = "dbo.p_svc_get_voucher_summary";
                        cmd.WstFailoverMode = WstFailoverMode.PrimaryOnly;
                        cmd.PartitionType = WstPartitionType.Physical;
                        cmd.Partition = i;

                        rdr = cmd.ExecuteReader();

                        while (rdr.Read())
                        {
                            VoucherInfo v = new VoucherInfo();

                            v._offerID = (ulong)(rdr.GetInt64(0));
                            v._useCount = rdr.GetInt32(1);
                            v._numVouchers = rdr.GetInt32(2);
                            v._status = rdr.GetString(3);

                            info.Add(v);
                        }
                    }
                    finally
                    {
                        if ( rdr != null )
                        {
                            rdr.Close();
                            rdr = null;
                        }
                        if ( conn != null )
                        {
                            conn.Close();
                            conn = null;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Get specific voucher information for the specified voucher.
        /// </summary>
        /// <param name="hash">Voucher hash</param>
        /// <param name="info">List of voucher infos (more than one if
        /// voucher was associated with multiple offers.</param>
        /// <param name="used">List containing all uses of this voucher.</param>
        public void GetVoucherInfo(byte[] hash, out ArrayList info, out ArrayList used)
        {
            uint hr = 0;
            WstDataReader rs = null;
            info = new ArrayList();
            used = new ArrayList();

			_ws.ClearParameters();
            _ws.StoredProc = "dbo.p_svc_get_voucher_info";
            _ws.SetHashVal(BitConverter.ToInt64(hash, 0));

            _ws.AddParameter(ParamType.RETVAL, "@RETVAL", hr);
            _ws.AddParameter("@bin_voucher_hash", hash);

            rs = _ws.Execute();

            while (rs.Read())
            {
                VoucherInfo v = new VoucherInfo();

                v._offerID = (ulong)(rs.GetInt64(0));
                v._useCount = rs.GetInt32(1);
                v._status = rs.GetString(2);
                v._SCG = rs.GetByte(3);
                v._consolever = rs.GetByte(4);
                v._numVouchers = 1;

                info.Add(v);
            }

            if(rs.NextResult())
            {
                while (rs.Read())
                {
                    VoucherUseInfo v = new VoucherUseInfo();

                    v._puid = (ulong)(rs.GetInt64(0));
                    v._whenUsed = rs.GetDateTime(1);

                    used.Add(v);
                }
            }

            rs.Close();
        }

        #region IDisposable Members

 