on, 
                    //      available on http://liveid (http://uebuilds:82/SDKS/Server-61_W4R3/webframe.html?Selecting_the_Authentication_Policy.html)
                    //      We effectively cache for 1/2 of the ticket time window, as WLID documentation.
                    case "lbi":
                        {
                            cacheTime = TimeSpan.FromHours(12);
                            break;
                        }
                    case "mbi":
                        {
                            cacheTime = TimeSpan.FromHours(4);
                            break;
                        }
                    case "hbi":
                        {
                            cacheTime = TimeSpan.FromMinutes(2);
                            break;
                        }
                    default:
                        {
                            cacheTime = TimeSpan.FromMinutes(30);
                            break;
                        }
                }

                string temp = loginTicket + "|" + puid.ToString();
                AddToCache(key, temp, cacheTime);
            }
            else
            {
                string[] parts = cachedValue.Split('|');
                loginTicket = parts[0];
                puid = ulong.Parse(parts[1]);
            }

            return loginTicket;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="username"></param>
        /// <param name="password"></param>
        /// <param name="target"></param>
        /// <param name="policy"></param>
        /// <param name="environment"></param>
        /// <param name="platformType"></param>
        /// <param name="titleId"></param>
        /// <param name="titleVersion"></param>
        /// <param name="clientVersion"></param>
        /// <returns></returns>
        public string GetUserToken(string username, string password, string target, string policy, string environment, string platformType, string titleId, string titleVersion, string clientVersion)
        {
            string loginTicket = GetLoginTicket(username, password, target, policy, environment);
            string key = GetUserTokenKey(username + environment + platformType + titleId + titleVersion + clientVersion);
            string stsToken = AuthCache.Get(key) as string;

            if (stsToken == null)
            {
                stsToken = auth.GetUserToken(
                    loginTicket,
                    platformType,
                    titleId,
                    titleVersion,
                    clientVersion);

                //only cache if the token is a user token.  DON'T cache machine tokens...
                if (Authorization.IsUserSecurityToken(stsToken))
                {
                    TimeSpan timeWindow = Authorization.GetSamlTimeWindow(stsToken);
                    TimeSpan cacheTime = new TimeSpan(timeWindow.Ticks / 2);    //cache for 1/2 the time
                    AddToCache(key, stsToken, cacheTime);
                }
            }

            return stsToken;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="userToken"></param>
        /// <param name="titleId"></param>
        /// <param name="titleVersion"></param>
        /// <param name="audienceUri"></param>
        /// <returns></returns>
        public string GetPartnerToken(string userToken, string titleId, string titleVersion, string audienceUri)
        {
            string xuid = Authorization.GetXuid(userToken);
            string key = GetPartnerTokenKey(xuid + titleId + titleVersion + audienceUri);
            string partnerToken = AuthCache.Get(key) as string;

            if (partnerToken == null)
            {
                partnerToken = auth.GetPartnerToken(userToken, titleId, titleVersion, audienceUri);
                TimeSpan timeWindow = Authorization.GetSamlTimeWindow(partnerToken);
                TimeSpan cacheTime = new TimeSpan(timeWindow.Ticks / 2);    //cache for 1/2 the time
                AddToCache(key, partnerToken, cacheTime);
            }

            return partnerToken;
        }

        /// <summary>
        /// 
        /// </summary>
        public static void ClearCache()
        {
            lock (syncLock)
            {
                foreach (System.Collections.DictionaryEntry entry in AuthCache)
                    AuthCache.Remove(entry.Key as string);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="key"></param>
        /// <param name="item"></param>
        /// <param name="cacheTime"></param>
        public static void AddToCache(string key, object item, TimeSpan cacheTime)
        {
            string existingItem = AuthCache.Get(key) as string;
            if (existingItem == null)
            {
                //take out a lock
                lock (syncLock)
                {
                    existingItem = AuthCache.Get(key) as string;
                    if (existingItem == null)   //see if someone beat us to it
                        AuthCache.Add(key, item, null, DateTime.Now.Add(cacheTime), Cache.NoSlidingExpiration, CacheItemPriority.Normal, null);
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="userName"></param>
        /// <returns></returns>
        private static string GetWlidTicketKey(string userName)
        {
            return userName.ToLower() + "WLID";
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="userName"></param>
        /// <returns></returns>
        private static string GetPartnerTokenKey(string userName)
        {
            return userName.ToLower() + "PartnerToken";
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="userName"></param>
        /// <returns></returns>
        private static string GetUserTokenKey(string userName)
        {
            return userName.ToLower() + "STS";
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\FrameworkLib\Authorization\Authorization.cs ===
﻿using System;
using System.Configuration;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Net.Security;
using System.Net.Sockets;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Xml;
using LiveN.Test.Common;
using LiveN.Test.Common.Web;
using LiveN.Test.Framework;
using LiveN.Test.Framework.Configuration;
using LiveN.Test.Framework.Web;
using RPSTicketCreation;

namespace LiveN.Test.Framework.Authorization
{
    /// <summary>
    /// 
    /// </summary>
    public class Authorization
    {
        public const string MachineTokenIdentifier = "XboxLive Machine security ticket";
        public const string UserTokenIdentifier = "XboxLive User security ticket";
        public const string PartnerTokenIdentifier = "XboxLive Partner security ticket";
        private const string SecurityTicketQuery = "/GetSecurityTicket?platformType={platformId}&titleId={titleId}&titleVersion={titleVersion}&clientVersion={clientVersion}&deviceId={deviceId}";
        private const string PartnerSecurityTicketQuery = "/GetPartnerSecurityTicket?xuid={xuid}&titleId={titleId}&titleVersion={titleVersion}&audience={audienceUri}";

        private static object certHackLock = new object();
        private static object certStoreLock = new object();

        /// <summary>
        /// 
        /// </summary>
        /// <param name="stsUrl"></param>
        /// <param name="clientCertSubject"></param>
        public Authorization(string stsUrl, string clientCertSubject): this(stsUrl, clientCertSubject, 30000)
        {

        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="stsUrl"></param>
        /// <param name="clientCertSubject"></param>
        /// <param name="timeout"></param>
        public Authorization(string stsUrl, string clientCertSubject, int timeout)
        {
            this.StsUrl = stsUrl;
            this.ClientCertSubject = clientCertSubject;
            this.Timeout = timeout;
        }

        /// <summary>
        /// 
        /// </summary>
        public string StsUrl
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string ClientCertSubject
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public int Timeout
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="username"></param>
        /// <param name="password"></param>
        /// <param name="target"></param>
        /// <param name="policy"></param>
        /// <param name="environment"></param>
        /// <returns></returns>
        public string GetLoginTicket(string username, string password, string target, string policy, string environment)
        {
            ulong puid;
            return GetLoginTicket(username, password, target, policy, environment, out puid);
        }

        /// <summary>
        /// Gets a login ticket using IDCRL.
        /// </summary>
        public string GetLoginTicket(string username, string password, string target, string policy, string environment, out ulong puid)
        {
            string loginTicket = null;
            
            try
            {
                TraceEx.TraceVerbose("Attempting to get a Windows LiveID login ticket for {0}/{1}, using IDCRL...", username, password);
                loginTicket = LiveID.GetLoginTicket(
                    username,
                    password,
                    target,
                    policy,
                    environment,
                    out puid);
            }
            catch (Exception e)
            {
               throw new ApplicationException(String.Format("Error getting Windows LiveID login ticket for {0}/{1}, using IDCRL.", username, password), e);
            }
            
            return loginTicket;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="username"></param>
        /// <param name="password"></param>
        /// <param name="target"></param>
        /// <param name="policy"></param>
        /// <param name="environment"></param>
        /// <returns></returns>
        public string GetRpsCompactTicket(string username, string password, string target, string policy, string environment)
        {
            string loginTicket = null;

            try
            {
                TraceEx.TraceVerbose("Attempting to get a Windows LiveID login ticket for {0}/{1}, using RpsTicketGenerator...", username, password);
                RPSTicketGeneratorConfig rpsTicketGenConfig = new RPSTicketGeneratorConfig();
                rpsTicketGenConfig.AuthPolicy = policy;
                rpsTicketGenConfig.SiteURL = String.Format("http://{0}", target);
                rpsTicketGenConfig.PPEnv = environment.Equals("Production", StringComparison.InvariantCultureIgnoreCase) ? PassportEnvironment.Production : PassportEnvironment.INT;

                RPSTicketGenerator rpsTicketGenerator = new RPSTicketGenerator(rpsTicketGenConfig);
                loginTicket = "t=" + rpsTicketGenerator.GetRPSCompactTicket(username, password).Trim(new char[] {'"'});
            }
            catch (Exception e)
            {
                throw new ApplicationException(String.Format("Error getting Windows LiveID login ticket for {0}/{1}, with RpsTicketGenerator.", username, password), e);
            }

            return loginTicket;
        }

        /// <summary>
        /// Gets a user token from XBL platform STS service, given an RPS ticket.
        /// </summary>
        /// <param name="loginTicket"></param>
        /// <param name="platformId"></param>
        /// <param name="titleId"></param>
        /// <param name="titleVersion"></param>
        /// <param name="clientVersion"></param>
        /// <returns></returns>
        public string GetUserToken(string loginTicket, string platformId, string titleId, string titleVersion, string clientVersion)
        {
            X509Certificate2 cert = GetStsClientCertificate();
            string[] parts = cert.Subject.Split(':');
            //this is awesome... sometimes the device id is in the subject, other times the thumb is expected
            string deviceId = (parts.Length == 3) ? parts[2] : cert.Thumbprint;

            string queryString = SecurityTicketQuery;
            queryString = queryString.Replace("{platformId}", platformId);
            queryString = queryString.Replace("{titleId}", titleId);
            queryString = queryString.Replace("{titleVersion}", titleVersion);
            queryString = queryString.Replace("{clientVersion}", clientVersion);
            queryString = queryString.Replace("{deviceId}", deviceId);

            Uri fullUrl = new Uri(this.StsUrl + queryString);
            TraceEx.TraceVerbose("Sending the following STS request: {0}", fullUrl);

            BasicHttpRequest httpRequest = new BasicHttpRequest(fullUrl);
            httpRequest.BaseHttpRequest.Timeout = this.Timeout;
            httpRequest.BaseHttpRequest.Headers.Add("Authorization", "WLID1.0 " + loginTicket);

            if (fullUrl.Scheme.Equals(Uri.UriSchemeHttps, StringComparison.InvariantCultureIgnoreCase))
            {
                CertHack(cert, fullUrl);
                httpRequest.BaseHttpRequest.ClientCertificates.Add(cert);
            }

            string response = httpRequest.GetResponse();

            if (httpRequest.HttpResponse.StatusCode != HttpStatusCode.OK)
            {
                StringBuilder trace = new StringBuilder();
                trace.AppendFormat("Error getting STS token:\r\n\r\nHTTP/1.1 {0} {1}\r\n", (int)httpRequest.HttpResponse.StatusCode, httpRequest.HttpResponse.StatusCode);
                foreach (string key in httpRequest.HttpResponse.Headers.Keys)
                    trace.AppendFormat("{0}: {1}\r\n", key, httpRequest.HttpResponse.Headers[key]);

                if (!String.IsNullOrEmpty(response))
                    trace.AppendFormat("\r\n{0}\r\n", response);

                throw new Exception(trace.ToString());
            }

            string stsToken = GetSamlTokenXml(response);
            return stsToken;
        }

        /// <summary>
        /// Helper method - to get PartnerSecurityTicket using GetPartnerSecurityTicket from STS/sts.asmx.
        /// </summary>
        public string GetPartnerToken(string stsToken, string titleId, string titleVersion, string audienceUri)
        {
            string xuid = Authorization.GetXuid(stsToken);

            string queryString = PartnerSecurityTicketQuery;
            queryString = queryString.Replace("{xuid}", xuid);
            queryString = queryString.Replace("{titleId}", titleId);
            queryString = queryString.Replace("{titleVersion}", titleVersion);
            queryString = queryString.Replace("{audienceUri}", System.Web.HttpUtility.UrlEncode(audienceUri));

            Uri fullUrl = new Uri(this.StsUrl + queryString);
            TraceEx.TraceVerbose("Sending the following Partner Security Token request: {0}", fullUrl);

            BasicHttpRequest httpRequest = new BasicHttpRequest(fullUrl);
            httpRequest.BaseHttpRequest.Timeout = this.Timeout;
            httpRequest.BaseHttpRequest.Headers.Add("X-Authorization", "XBL1.0 x=" + stsToken);

            if (fullUrl.Scheme.Equals(Uri.UriSchemeHttps, StringComparison.InvariantCultureIgnoreCase))
            {
                X509Certificate2 cert = GetStsClientCertificate();
                CertHack(cert, fullUrl);
                httpRequest.BaseHttpRequest.ClientCertificates.Add(cert);
            }

            string response = httpRequest.GetResponse();
            if (httpRequest.HttpResponse.StatusCode != HttpStatusCode.OK)
            {
                StringBuilder trace = new StringBuilder();
                trace.AppendFormat("Error getting Partner Security Token token:\r\n\r\nHTTP/1.1 {0} {1}\r\n", (int)httpRequest.HttpResponse.StatusCode, httpRequest.HttpResponse.StatusCode);
                foreach (string key in httpRequest.HttpResponse.Headers.Keys)
                    trace.AppendFormat("{0}: {1}\r\n", key, httpRequest.HttpResponse.Headers[key]);

                if (!String.IsNullOrEmpty(response))
                    trace.AppendFormat("\r\n{0}\r\n", response);

                throw new Exception(trace.ToString());
            }

            string partnerTicket = GetSamlTokenXml(response);
            return partnerTicket;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        private X509Certificate2 GetStsClientCertificate()
        {
            X509Certificate2 clientCert;
            X509Store localMachineMy = new X509Store(StoreName.My, StoreLocation.LocalMachine);

            try
            {
                localMachineMy.Open(OpenFlags.ReadOnly);
                X509Certificate2Collection certs = localMachineMy.Certificates.Find(
                    X509FindType.FindBySubjectName,
                    this.ClientCertSubject,
                    false);
                if (certs.Count == 0)
                {
                    throw new ApplicationException(String.Format("Unable to find STS client certificate, with subject CN={0}, required for authentication.  Verify that this certificate is installed to LOCAL_MACHINE\\My and that the private key is available.", this.ClientCertSubject));
                }
                else
                {
                    TraceEx.TraceVerbose("Verified that the expected STS client certificate, CN={0}, is installed, with private key, in LOCAL_MACHINE\\My", this.ClientCertSubject);
                    clientCert = certs[0];
                }
            }
            catch (Exception e)
            {
                throw new ApplicationException("Error enumerating or adding required test certificate to LOCAL_MACHINE\\My.", e);
            }
            finally
            {
                if (localMachineMy != null)
                    localMachineMy.Close();
            }

            return clientCert;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="cert"></param>
        /// <param name="stsPath"></param>
        public static void CertHack(X509Certificate cert, Uri stsPath)
        {
            lock (certHackLock)
            {
                RemoteCertificateValidationCallback rcvc = delegate(object sender, System.Security.Cryptography.X509Certificates.X509Certificate certificate,
                                               System.Security.Cryptography.X509Certificates.X509Chain chain,
                                               System.Net.Security.SslPolicyErrors sslPolicyErrors)
                {
                    return true;
                };

                try
                {
                    ServicePointManager.ServerCertificateValidationCallback += rcvc;

                    LocalCertificateSelectionCallback lcsc = delegate(object sender, string targetHost, X509CertificateCollection localCertificates,
                       X509Certificate remoteCertificate, string[] acceptableIssuers)
                    {
                        //reference to the local passed in certificate
                        return cert;
                    };

                    using (TcpClient tcp = new TcpClient(stsPath.Host, stsPath.Port))
                    {
                        using (SslStream ssl = new SslStream(tcp.GetStream(), false, rcvc, lcsc))
                        {
                            ssl.AuthenticateAsClient(stsPath.Host, new X509CertificateCollection(new X509Certificate[] { cert }),
                                System.Security.Authentication.SslProtocols.Default, false);

                            // create a request that we don't care about
                            BasicHttpRequest dummyReq = new BasicHttpRequest("https://" + stsPath.Host + ":" + stsPath.Port + "/sts/sts.asmx");

                            //HttpRequest req = new HttpRequest(serverAndPort, "/sts/sts.asmx");

                            ssl.Write(dummyReq.ToBytes());
                            ssl.Flush();
                            // this read is necessary to force the client certificate
                            ssl.Read(new byte[1], 0, 1);
                            ssl.Close();
                        }
                    }
                }
                finally
                {
                    ServicePointManager.ServerCertificateValidationCallback -= rcvc;
                }
            }
        }
                
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stsToken"></param>
        /// <returns></returns>
        public static string GetXuid(string stsToken)
        {
            try
            {
                XmlDocumentEx xmlDoc = new XmlDocumentEx(stsToken, true);
                XmlNode node = xmlDoc.SelectSingleNode("saml:Assertion/saml:AttributeStatement/saml:Attribute[@AttributeName='Xuid0']/saml:AttributeValue", xmlDoc.NamespaceManager);
                if (node == null)
                    throw new ApplicationException("No xuid claim was found in the STS token! Most likely, this is a machine security token and not a user token. The Windows Live ID ticket used to generate this token most likely does NOT have an Xbox Live account.");
                return node.InnerText;
            }
            catch (XmlException e)
            {
                throw new ApplicationException(String.Format("Invalid STS token: {0}", e.Message), e);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="stsToken"></param>
        /// <returns></returns>
        public static string GetPuid(string stsToken)
        {
            try
            {
                XmlDocumentEx xmlDoc = new XmlDocumentEx(stsToken, true);
                XmlNode node = xmlDoc.SelectSingleNode("saml:Assertion/saml:AttributeStatement/saml:Attribute[@AttributeName='Puid0']/saml:AttributeValue", xmlDoc.NamespaceManager);
                if (node == null)
                    throw new ApplicationException("No Puid claim was found in the STS token! Most likely, this is a user security token and not a machine token.");
                return node.InnerText;
            }
            catch (XmlException e)
            {
                throw new ApplicationException(String.Format("Invalid STS token: {0}", e.Message), e);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="stsToken"></param>
        /// <returns></returns>
        public static string GetMachineId(string stsToken)
        {
            try
            {
                XmlDocumentEx xmlDoc = new XmlDocumentEx(stsToken, true);
                XmlNode node = xmlDoc.SelectSingleNode("saml:Assertion/saml:AttributeStatement/saml:Attribute[@AttributeName='MachineID']/saml:AttributeValue", xmlDoc.NamespaceManager);
                if (node == null)
                    throw new ApplicationException("No machine ID claim was found in the STS token! Most likely, this is a user security token and not a machine token.");
                return node.InnerText;
            }
            catch (XmlException e)
            {
                throw new ApplicationException(String.Format("Invalid STS token: {0}", e.Message), e);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="stsToken"></param>
        /// <returns></returns>
        public static bool IsUserSecurityToken(string stsToken)
        {
            string xuid;
            return IsUserSecurityToken(stsToken, out xuid);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="stsToken"></param>
        /// <param name="xuid"></param>
        /// <returns></returns>
        public static bool IsUserSecurityToken(string stsToken, out string xuid)
        {
            try
            {
                xuid = null;
                XmlDocumentEx xmlDoc = new XmlDocumentEx(stsToken, true);
                XmlNode node = xmlDoc.SelectSingleNode("saml:Assertion/saml:AttributeStatement/saml:Subject/saml:NameIdentifier", xmlDoc.NamespaceManager);

                if (node == null)
                    throw new ApplicationException("No Subject Name Identifier was found in the STS token!");
                if (node.InnerText.Equals(UserTokenIdentifier, StringComparison.InvariantCultureIgnoreCase))
                {
                    xuid = GetXuid(stsToken);
                    return true;
                }
            }
            catch (XmlException e)
            {
                throw new ApplicationException(String.Format("Invalid STS token: {0}", e.Message), e);
            }

            return false;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="stsToken"></param>
        /// <returns></returns>
        public static TimeSpan GetSamlTimeWindow(string stsToken)
        {
            try
            {
                XmlDocumentEx xmlDoc = new XmlDocumentEx(stsToken, true);
                XmlNode node = xmlDoc.SelectSingleNode("saml:Assertion/saml:Conditions/@NotBefore", xmlDoc.NamespaceManager);

                if (node == null)
                    throw new ApplicationException("No NotBefore condition was found in the STS token!");
                DateTime notBefore = DateTime.Parse(node.InnerText);

                node = xmlDoc.SelectSingleNode("saml:Assertion/saml:Conditions/@NotOnOrAfter", xmlDoc.NamespaceManager);

                if (node == null)
                    throw new ApplicationException("No NotOnOrAfter condition was found in the STS token!");
                DateTime notAfter = DateTime.Parse(node.InnerText);

                return notAfter.Subtract(notBefore);
            }
            catch (XmlException e)
            {
                throw new ApplicationException(String.Format("Invalid STS token: {0}", e.Message), e);
            }
        }

        /// <summary>
        /// Helper method - to parse STSServiceResponse from GetSecurityTicket.
        /// </summary>
        private static string GetSamlTokenXml(string stsServiceResponse)
        {
            try
            {
                XmlDocument xmlDoc = new XmlDocument();
                xmlDoc.LoadXml(stsServiceResponse);

                //returning the first child of the root document element
                return xmlDoc.DocumentElement.FirstChild.Value;
            }
            catch (Exception ex)
            {
                throw new ApplicationException("The STS token was invalid: " + ex.Message, ex);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="testCertPath"></param>
        /// <param name="thumbprint"></param>
        /// <param name="password"></param>
        /// <param name="nameOfServiceCertIsUsedFor"></param>
        /// <returns></returns>
        public static X509Certificate2 InstallClientCertificate(string testCertPath, string thumbprint, string password, string nameOfServiceCertIsUsedFor)
        {
            lock (certStoreLock)
            {
                X509Certificate2 clientCert = null;
                X509Store localMachineMy = new X509Store(StoreName.My, StoreLocation.LocalMachine);

                try
                {
                    localMachineMy.Open(OpenFlags.ReadWrite);
                    X509Certificate2Collection certs = localMachineMy.Certificates.Find(X509FindType.FindByThumbprint, thumbprint, false);
                    if (certs.Count == 0)
                    {
                        Trace.TraceInformation("Required {0} client certificate with thumbprint = {1} is not found; installing {2} to LOCAL_MACHINE\\My", nameOfServiceCertIsUsedFor, thumbprint, testCertPath);
                        if (!File.Exists(testCertPath))
                            throw new ApplicationException(String.Format("Unable to find {0} client certificate, required for authentication, at: {1}", nameOfServiceCertIsUsedFor, testCertPath));
                        X509Certificate2 testCert = new X509Certificate2(testCertPath, password, X509KeyStorageFlags.MachineKeySet | X509KeyStorageFlags.PersistKeySet);
                        localMachineMy.Add(testCert);
                        clientCert = testCert;
                        Trace.TraceInformation("Successfully installed " + nameOfServiceCertIsUsedFor + " client certificate.");
                    }
                    else
                    {
                        Trace.TraceInformation("Verified that the expected " + nameOfServiceCertIsUsedFor + " client certificate with thumbprint = {0} is installed, with private key, in LOCAL_MACHINE\\My", ConfigurationManager.AppSettings["PFEClientCertThumbprint"]);
                        clientCert = certs[0];
                    }
                }
                catch (Exception e)
                {
                    throw new ApplicationException("Error enumerating or adding required " + nameOfServiceCertIsUsedFor + " test certificate to LOCAL_MACHINE\\My.", e);
                }
                finally
                {
                    if (localMachineMy != null)
                        localMachineMy.Close();
                }
                return clientCert;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="testCertPath"></param>
        /// <param name="subject"></param>
        /// <param name="password"></param>
        /// <param name="nameOfServiceCertIsUsedFor"></param>
        /// <returns></returns>
        public static X509Certificate2 InstallClientCertificateBySubject(string testCertPath, string subject, string password, string nameOfServiceCertIsUsedFor)
        {
            lock (certStoreLock)
            {
                X509Certificate2 clientCert = null;
                X509Store localMachineMy = new X509Store(StoreName.My, StoreLocation.LocalMachine);

                try
                {
                    localMachineMy.Open(OpenFlags.ReadWrite);
                    X509Certificate2Collection certs = localMachineMy.Certificates.Find(X509FindType.FindBySubjectName, subject, false);
                    if (certs.Count == 0 || !certs[0].HasPrivateKey)
                    {
                        Trace.TraceInformation("Required {0} client certificate with subject = {1} is not found; installing CN={2} to LOCAL_MACHINE\\My", nameOfServiceCertIsUsedFor, subject, testCertPath);
                        if (!File.Exists(testCertPath))
                            throw new ApplicationException(String.Format("Unable to find {0} client certificate, required for authentication, at: {1}", nameOfServiceCertIsUsedFor, testCertPath));
                        X509Certificate2 testCert = new X509Certificate2(testCertPath, password, X509KeyStorageFlags.MachineKeySet | X509KeyStorageFlags.PersistKeySet);
                        localMachineMy.Add(testCert);
                        clientCert = testCert;
                        Trace.TraceInformation("Successfully installed " + nameOfServiceCertIsUsedFor + " client certificate.");
                    }
                    else
                    {
                        if (certs.Count > 1)
                            Trace.TraceWarning("WARNING: more than one client cert was found matching subejct '{0}'; the first found occurance will be used.", subject);

                        if (!certs[0].HasPrivateKey)
                            throw new ApplicationException("No private key is available for the specified client cert and is required for mutual SSL.  Make sure the application is running with administrator rights.");

                        TraceEx.TraceVerbose("Verified that the expected " + nameOfServiceCertIsUsedFor + " client certificate with subject CN={0} is installed, with private key, in LOCAL_MACHINE\\My", subject);
                        clientCert = certs[0];
                    }
                }
                catch (Exception e)
                {
                    throw new ApplicationException(String.Format("Error finding or installing required {0} client certificate to LOCAL_MACHINE\\My; {1}", nameOfServiceCertIsUsedFor, e.Message), e);
                }
                finally
                {
                    if (localMachineMy != null)
                        localMachineMy.Close();
                }
                return clientCert;
            }
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stsToken"></param>
        /// <returns></returns>
        public static string GetGamertag(string stsToken)
        {
            try
            {
                XmlDocumentEx xmlDoc = new XmlDocumentEx(stsToken, true);
                XmlNode node = xmlDoc.SelectSingleNode("saml:Assertion/saml:AttributeStatement/saml:Attribute[@AttributeName='Gamertag0']/saml:AttributeValue", xmlDoc.NamespaceManager);
                if (node == null)
                    throw new ApplicationException("No Gamertag was found in the STS token! Most likely, this is a machine security token and not a user token. The Windows Live ID ticket used to generate this token most likely does NOT have an Xbox Live account.");
                return node.InnerText;
            }
            catch (XmlException e)
            {
                throw new ApplicationException(String.Format("Invalid STS token: {0}", e.Message), e);
            }
        }        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\FrameworkLib\Authorization\StsTokenParameters.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using LiveN.Test.Common;

namespace LiveN.Test.Framework.Authorization
{
    /// <summary>
    /// 
    /// </summary>
    public class StsTokenParameters
    {
        /// <summary>
        /// 
        /// </summary>
        public StsTokenParameters()
        {
            //default to regular STS value of 60 mins for a valid token
            this.MinutesToExpire = 60;
            //only the Authentication interface calls (that use deviceId) need to make sure this value is in sync w/ the test
            this.MachineId = Utility.GenerateRandomUInt64();
        }

        /// <summary>
        /// 
        /// </summary>
        public ulong Xuid
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string AudienceUri
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string Subject
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public uint TitleId
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string TitleVersion
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public ulong MachineId
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string DeviceId
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string ClientVersion
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string PlatformType
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string Puid
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string CID
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string GamerTag
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string Tier
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string Country
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string Privileges
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public int MinutesToExpire
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public OmittedTokenItems OmittedItems
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\FrameworkLib\Authorization\StsToken.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Security.Cryptography;
using System.Security.Cryptography.Xml;
using System.Security.Cryptography.X509Certificates;
using System.Xml;
using System.Diagnostics;

using LiveN.Test.Common;

namespace LiveN.Test.Framework.Authorization
{
    /// <summary>
    /// 
    /// </summary>
    public class StsToken
    {
        public const string SamlNamespace = "urn:oasis:names:tc:SAML:1.0:assertion";
        public const string ConsoleTokenStsIssuer = "http://xboxlive.com";
        public const string UserTokenStsIssuer = "http://sts.xboxlive.com";
        public const string UserTokenSamlSubject = "XboxLive User security ticket";
        public const string PartnerTokenSamlSubject = "XboxLive Partner security ticket";

        // Token Signing Certificate
        //  this is the cert and associated private key that signs the SAML token
        private X509Certificate2 _certificate = null;
        private string certSubject;
        private object certStoreLock = new object();

        /// <summary>
        /// 
        /// </summary>
        /// <param name="certSubject"></param>
        public StsToken(string certSubject)
        {
            this.certSubject = certSubject;
        }

        /// <summary>
        /// 
        /// </summary>
        public string CertificateSubject
        {
            get
            {
                return this.certSubject;
            }
            set
            {
                this.certSubject = value;
                this._certificate = null;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="players"></param>
        /// <param name="audience"></param>
        /// <param name="machinePuid"></param>
        /// <param name="clientVersion"></param>
        /// <param name="title"></param>
        /// <param name="titleVersion"></param>
        /// <param name="minutesToExpire"></param>
        /// <returns></returns>
        public string GenerateConsoleToken(Player[] players, string audience, ulong machinePuid, uint clientVersion, uint title, uint titleVersion, int minutesToExpire)
        {
            DateTime now = DateTime.UtcNow;
            DateTime expires = now.Add(TimeSpan.FromMinutes(minutesToExpire));

            TextWriter textWriter = new StringWriter();
            XmlTextWriter writer = new XmlTextWriter(textWriter);

            string assertionID = WriteAssertionAttributes(writer, now.ToString("o"));
            WriteConditions(writer, now.ToString("o"), expires.ToString("o"), audience);

            writer.WriteStartElement("AttributeStatement", SamlNamespace);

            writer.WriteStartElement("Subject", SamlNamespace);
            writer.WriteElementString("NameIdentifier", SamlNamespace, string.Format("0x{0:X16}", players[0].Xuid)); // primary Subject is player1, in uppercase hex
            writer.WriteEndElement();

            // Write out machineID claim
            WriteClaim(writer, "PlatformType", string.Format("0x{0:X2}", 0x1)); //PlatformType 1 == Xbox360
            WriteClaim(writer, "MachineID", string.Format("0x{0:X16}", machinePuid));
            WriteClaim(writer, "ClientVersion", string.Format("0x{0:X8}", clientVersion));
            WriteClaim(writer, "TitleID", string.Format("0x{0:X8}", title));
            WriteClaim(writer, "TitleVersion", string.Format("0x{0:X8}", titleVersion));

            // Write out player claims
            for (int i = 0; i < players.Length; i++)
            {
                if (players[i] != null)
                {
                    WriteClaim(writer, String.Format("Xuid{0}", i + 1), string.Format("0x{0:X16}", players[i].Xuid)); //always return uppercase hex
                    WriteClaim(writer, String.Format("Tier{0}", i + 1), string.Format("0x{0:X2}", players[i].Tier));
                    WriteClaim(writer, String.Format("Country{0}", i + 1), string.Format("0x{0:X2}", players[i].Country));
                }
            }

            writer.WriteEndElement(); // AttributeStatement
            writer.WriteEndElement(); // Assertion

            textWriter.Flush();

            XmlDocument document = new XmlDocument();
            document.LoadXml(textWriter.ToString());

            SignXmlViaLocalCert(document, assertionID);

            TraceEx.TraceVerbose("Generated STS Token:\r\n{0}", document.OuterXml);
            return document.OuterXml;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="majorVersion"></param>
        /// <param name="minorVersion"></param>
        /// <param name="issuer"></param>
        /// <param name="notBefore"></param>
        /// <param name="notOnOrAfter"></param>
        /// <param name="audience"></param>
        /// <param name="subject"></param>
        /// <param name="omittedItem"></param>
        /// <returns></returns>
        public string GeneratePartnerToken(
            string majorVersion,
            string minorVersion,
            string issuer,
            string notBefore,
            string notOnOrAfter,
            string audience,
            string subject,
            OmittedTokenItems omittedItems)
        {
            return GeneratePartnerToken(majorVersion, minorVersion, issuer, notBefore, notOnOrAfter, audience, subject, omittedItems, null);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="majorVersion"></param>
        /// <param name="minorVersion"></param>
        /// <param name="issuer"></param>
        /// <param name="notBefore"></param>
        /// <param name="notOnOrAfter"></param>
        /// <param name="audience"></param>
        /// <param name="subject"></param>
        /// <param name="omittedItem"></param>
        /// <param name="cert"></param>
        /// <param name="exceptionMessage"></param>
        /// <returns></returns>
        public string GeneratePartnerToken(
            string majorVersion,
            string minorVersion,
            string issuer,
            string notBefore,
            string notOnOrAfter,
            string audience,
            string subject,
            OmittedTokenItems omittedItems,
            X509Certificate2 cert)
        {
            TextWriter textWriter = new StringWriter();
            XmlTextWriter writer = new XmlTextWriter(textWriter);

            string assertionID = WriteAssertionAttributes(writer, majorVersion, minorVersion, issuer, notBefore, omittedItems);
            // write conditions
            WriteConditions(writer, notBefore, notOnOrAfter, audience, omittedItems);

            writer.WriteStartElement("AttributeStatement", SamlNamespace);

            // write subject
            if (omittedItems.IsNotSet(OmittedTokenItems.Subject))
                WriteSubject(writer, subject);

            // write the claims
            WriteClaim(writer, "TitleID", "4D5308E2");
            WriteClaim(writer, "TitleVersion", "1");
            WriteClaim(writer, "PartnerID0", "2600292641993623");
            WriteClaim(writer, "Gamertag0", "mpdev2");

            writer.WriteEndElement(); // AttributeStatement
            writer.WriteEndElement(); // Assertion

            textWriter.Flush();

            XmlDocument document = new XmlDocument();
            document.LoadXml(textWriter.ToString());

            // sign the token
            if (omittedItems.IsNotSet(OmittedTokenItems.Signature))
                SignXmlViaLocalCert(document, assertionID, cert);

            TraceEx.TraceVerbose("Generated Partner STS Token:\r\n{0}", document.OuterXml);
            return document.OuterXml;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="tokenParams"></param>
        /// <returns></returns>
        public string GenerateUserToken(StsTokenParameters tokenParams)
        {
            TraceEx.TraceVerbose("Generating user STS token for xuid0=0x{0}, Title ID=0x{1}, GamerTag={2}, PlatformType={3} good for 4 hours.", tokenParams.Xuid, tokenParams.TitleId.ToString("X8"), tokenParams.GamerTag, tokenParams.PlatformType);
            return GenerateUserToken(
                UserTokenStsIssuer,
                DateTime.Now.ToString("o"),
                DateTime.Now.Add(TimeSpan.FromHours(4)).ToString("o"),
                tokenParams.PlatformType,
                tokenParams.DeviceId,
                tokenParams.ClientVersion,
                tokenParams.TitleId.ToString("X8"),
                tokenParams.TitleVersion,
                tokenParams.Xuid.ToString(),
                tokenParams.GamerTag,
                tokenParams.Tier,
                tokenParams.MachineId.ToString(),
                tokenParams.Puid,
                tokenParams.CID,
                tokenParams.Country,
                tokenParams.Privileges,
                tokenParams.AudienceUri,
                tokenParams.Subject,
                tokenParams.OmittedItems,
                null);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="xuid"></param>
        /// <param name="titleId"></param>
        /// <param name="titleVersion"></param>
        /// <returns></returns>
        public string GenerateUserToken(                        
            string xuid,
            string titleId,
            string titleVersion)
        {
            return GenerateUserToken(UserTokenStsIssuer, DateTime.Now.ToString("o"), DateTime.Now.Add(TimeSpan.FromHours(4)).ToString("o"), "15", String.Empty, "1", titleId, titleVersion, xuid,
                                String.Empty, String.Empty, OmittedTokenItems.None, null);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="issuer"></param>
        /// <param name="notBefore"></param>
        /// <param name="notOnOrAfter"></param>
        /// <param name="platformType"></param>
        /// <param name="deviceId"></param>
        /// <param name="clientVersion"></param>
        /// <param name="titleId"></param>
        /// <param name="titleVersion"></param>
        /// <param name="xuid"></param>
        /// <param name="gamertag"></param>
        /// <param name="tier"></param>
        /// <param name="omittedItem"></param>
        /// <returns></returns>
        public string GenerateUserToken(
            string issuer,
            string notBefore,
            string notOnOrAfter,
            string platformType,
            string deviceId,
            string clientVersion,
            string titleId,
            string titleVersion,
            string xuid,
            string gamertag,
            string tier,
            OmittedTokenItems omittedItems)
        {
            return GenerateUserToken(issuer, notBefore, notOnOrAfter, platformType, deviceId, clientVersion, titleId, titleVersion, xuid,
                                gamertag, tier, omittedItems, null);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="issuer"></param>
        /// <param name="notBefore"></param>
        /// <param name="notOnOrAfter"></param>
        /// <param name="platformType"></param>
        /// <param name="deviceId"></param>
        /// <param name="clientVersion"></param>
        /// <param name="titleId"></param>
        /// <param name="titleVersion"></param>
        /// <param name="xuid"></param>
        /// <param name="gamertag"></param>
        /// <param name="tier"></param>
        /// <param name="omittedItem"></param>
        /// <param name="cert"></param>
        /// <returns></returns>
        public string GenerateUserToken(
            string issuer,
            string notBefore,
            string notOnOrAfter,
            string platformType,
            string deviceId,
            string clientVersion,
            string titleId,
            string titleVersion,
            string xuid,
            string gamertag,
            string tier,
            OmittedTokenItems omittedItem,
            X509Certificate2 cert)
        {
            return GenerateUserToken(issuer, notBefore, notOnOrAfter, platformType, deviceId, clientVersion, titleId, titleVersion, xuid,
                                gamertag, tier, String.Empty, String.Empty, String.Empty, String.Empty, String.Empty, omittedItem, null);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="issuer"></param>
        /// <param name="notBefore"></param>
        /// <param name="notOnOrAfter"></param>
        /// <param name="platformType"></param>
        /// <param name="deviceId"></param>
        /// <param name="clientVersion"></param>
        /// <param name="titleId"></param>
        /// <param name="titleVersion"></param>
        /// <param name="xuid"></param>
        /// <param name="gamertag"></param>
        /// <param name="tier"></param>
        /// <param name="omittedItem"></param>
        /// <param name="cert"></param>
        /// <param name="exceptionMessage"></param>
        /// <returns></returns>
        public string GenerateUserToken(
            string issuer,
            string notBefore,
            string notOnOrAfter,
            string platformType,
            string deviceId,
            string clientVersion,
            string titleId,
            string titleVersion,
            string xuid,
            string gamertag,
            string tier,
            string machineId,
            string puid,
            string cid,
            string country,
            string privledges,
            OmittedTokenItems omittedItems,
            X509Certificate2 cert)
        {
            return GenerateUserToken(issuer, notBefore, notOnOrAfter, platformType, deviceId, clientVersion, titleId, titleVersion,
                                        xuid, gamertag, tier, machineId, puid, cid, country, privledges, String.Empty, String.Empty, omittedItems, cert);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="issuer"></param>
        /// <param name="notBefore"></param>
        /// <param name="notOnOrAfter"></param>
        /// <param name="platformType"></param>
        /// <param name="deviceId"></param>
        /// <param name="clientVersion"></param>
        /// <param name="titleId"></param>
        /// <param name="titleVersion"></param>
        /// <param name="xuid"></param>
        /// <param name="gamertag"></param>
        /// <param name="tier"></param>
        /// <param name="omittedItem"></param>
        /// <param name="cert"></param>
        /// <returns></returns>
        public string GenerateUserToken(
            string issuer,
            string notBefore,
            string notOnOrAfter,
            string platformType,
            string deviceId,
            string clientVersion,
            string titleId,
            string titleVersion,
            string xuid,
            string gamertag,
            string tier,
            string machineId,
            string puid,
            string cid,
            string country,
            string privledges,
            string audienceUri,
            string subject,
            OmittedTokenItems omittedItems, 
            X509Certificate2 cert)
        {
            TextWriter textWriter = new StringWriter();
            XmlTextWriter writer = new XmlTextWriter(textWriter);

            string assertionID = WriteAssertionAttributes(writer, issuer, notBefore, omittedItems);

            // write conditions
            if (String.IsNullOrEmpty(audienceUri))
                audienceUri = UserTokenStsIssuer;
            WriteConditions(writer, notBefore, notOnOrAfter, audienceUri, omittedItems);

            writer.WriteStartElement("AttributeStatement", SamlNamespace);

            // write subject
            if (String.IsNullOrEmpty(subject))
                subject = UserTokenSamlSubject;
            WriteSubject(writer, subject);

            // write claims
            if (omittedItems.IsNotSet(OmittedTokenItems.PlatformType))
                WriteClaim(writer, "PlatformType", platformType);

            if (omittedItems.IsNotSet(OmittedTokenItems.MachineId))
            {
                if (String.IsNullOrEmpty(machineId))
                    machineId = Utility.GenerateRandomUInt64().ToString();
                WriteClaim(writer, "MachineID", machineId);
            }

            if (omittedItems.IsNotSet(OmittedTokenItems.DeviceId))
            {
                if (String.IsNullOrEmpty(deviceId))
                    deviceId = Utility.GenerateRandomUInt64().ToString();
                WriteClaim(writer, "DeviceID", deviceId);
            }

            if (omittedItems.IsNotSet(OmittedTokenItems.ClientVersion))
            {
                if (String.IsNullOrEmpty(clientVersion))
                    clientVersion = "1";
                WriteClaim(writer, "ClientVersion", clientVersion);
            }

            if (omittedItems.IsNotSet(OmittedTokenItems.TitleId))
                WriteClaim(writer, "TitleID", titleId);

            if (omittedItems.IsNotSet(OmittedTokenItems.TitleVersion))
                WriteClaim(writer, "TitleVersion", titleVersion);

            if (omittedItems.IsNotSet(OmittedTokenItems.Puid))
            {
                if (String.IsNullOrEmpty(puid))
                    puid = Utility.GenerateRandomUInt64().ToString();
                WriteClaim(writer, "Puid0", puid);
            }

            if (omittedItems.IsNotSet(OmittedTokenItems.CID))
            {
                if (String.IsNullOrEmpty(cid))
                    cid = Utility.GenerateRandomUInt64().ToString();
                WriteClaim(writer, "CID0", cid);
            }

            if (omittedItems.IsNotSet(OmittedTokenItems.Xuid))
            {
                if (String.IsNullOrEmpty(xuid))
                    xuid = Utility.GenerateRandomUInt64().ToString();
                WriteClaim(writer, "Xuid0", xuid);
            }

            if (omittedItems.IsNotSet(OmittedTokenItems.Gamertag))
            {
                if (String.IsNullOrEmpty(gamertag))
                    gamertag = XboxLiveAccount.GenerateRandomGamerTag();
                WriteClaim(writer, "Gamertag0", gamertag);
            }

            if (omittedItems.IsNotSet(OmittedTokenItems.Tier))
            {
                if (String.IsNullOrEmpty(tier))
                    tier = "3"; //NOTE: not sure this is a 'great' default value; corresponds to silver acct
                WriteClaim(writer, "Tier0", tier);
            }

            if(omittedItems.IsNotSet(OmittedTokenItems.Country))
                WriteClaim(writer, "Country0", "103");  //NOTE: hardcoded for US (103)

            //NOTE: the 'privledge' values were taken from a sample token, for a new, silver XBL account.
            if(omittedItems.IsNotSet(OmittedTokenItems.Privledges))
                WriteClaim(writer, "Privileges0", "212,220,226,227,228,229,230,231,234,235,237,240,241,243,244,245,246,247,248,249,251,252,254,255");

            writer.WriteEndElement(); // AttributeStatement
            writer.WriteEndElement(); // Assertion

            textWriter.Flush();

            XmlDocument document = new XmlDocument();
            document.LoadXml(textWriter.ToString());

            // sign the token
            if (omittedItems.IsNotSet(OmittedTokenItems.Signature))
                SignXmlViaLocalCert(document, assertionID, cert);

            TraceEx.TraceVerbose("Generated User STS Token:\r\n{0}", document.OuterXml);
            return document.OuterXml;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="parameters"></param>
        /// <returns></returns>
        public string GenerateConsoleToken(StsTokenParameters parameters)
        {
            return GenerateConsoleToken(parameters.Xuid, parameters.TitleId, parameters.MachineId, parameters.MinutesToExpire);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="xuid"></param>
        /// <param name="titleId"></param>
        /// <param name="machinePuid"></param>
        /// <param name="minutesToExpire"></param>
        /// <returns></returns>
        public string GenerateConsoleToken(ulong xuid, uint titleId, ulong machinePuid, int minutesToExpire)
        {
            TraceEx.TraceVerbose("Generating console STS token for xuid0=0x{0}, Title ID=0x{1}, MachinePUID={2}, good for {3} minutes.", xuid.ToString("X16"), titleId.ToString("X8"), machinePuid.ToString("X16"), minutesToExpire);
            //103=US, 6=Gold
            Player player1 = new Player() { Xuid = xuid, Country = 103, Tier = 6 };

            //random machine puid, hard-coded client version, random title version
            return GenerateConsoleToken(new Player[] { player1 }, ConsoleTokenStsIssuer, machinePuid, 0x25223C00, titleId, Utility.GenerateRandomUInt32(), minutesToExpire);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="notBefore"></param>
        /// <param name="assertionID"></param>
        private static string WriteAssertionAttributes(XmlTextWriter writer, string notBefore)
        {
            return WriteAssertionAttributes(writer, "1", "1", UserTokenStsIssuer, notBefore, OmittedTokenItems.None);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="issuer"></param>
        /// <param name="notBefore"></param>
        /// <param name="OmittedUserTokenItems"></param>
        /// <param name="assertionID"></param>
        private static string WriteAssertionAttributes(XmlTextWriter writer, string issuer, string notBefore, OmittedTokenItems omittedItems)
        {
            return WriteAssertionAttributes(writer, "1", "1", issuer, notBefore, omittedItems);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="majorVersion"></param>
        /// <param name="minorVersion"></param>
        /// <param name="issuer"></param>
        /// <param name="notBefore"></param>
        /// <param name="OmittedPartnerTokenItems"></param>
        /// <param name="OmittedUserTokenItems"></param>
        /// <param name="assertionID"></param>
        private static string WriteAssertionAttributes(
            XmlTextWriter writer,
            string majorVersion,
            string minorVersion,
            string issuer,
            string notBefore,
            OmittedTokenItems omittedItems)
        {
            string assertionID = string.Format("SamlSecurityToken-{0}", Guid.NewGuid().ToString());

            writer.WriteProcessingInstruction("xml", "version='1.0' encoding='utf-16'");
            writer.WriteStartElement("saml", "Assertion", SamlNamespace);

            if (!omittedItems.IsSet(OmittedTokenItems.MajorVersion))
            //if (omittedPartnerItem != OmittedTokenItems.MajorVersion)
                writer.WriteAttributeString("MajorVersion", majorVersion);

            if (omittedItems.IsNotSet(OmittedTokenItems.MinorVersion))
                writer.WriteAttributeString("MinorVersion", minorVersion);

            writer.WriteAttributeString("AssertionID", assertionID);

            if (omittedItems.IsNotSet(OmittedTokenItems.Issuer))
                writer.WriteAttributeString("Issuer", issuer);

            DateTime dateTimeNotBefore;
            if ((DateTime.TryParse(notBefore, out dateTimeNotBefore)) && (dateTimeNotBefore < DateTime.Now))
            {
                writer.WriteAttributeString("IssueInstant", dateTimeNotBefore.ToUniversalTime().ToString("o"));
            }
            else
                writer.WriteAttributeString("IssueInstant", DateTime.UtcNow.ToString("o"));

            return assertionID;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="notBefore"></param>
        /// <param name="notOnOrAfter"></param>
        /// <param name="audience"></param>
        private static void WriteConditions(XmlTextWriter writer, string notBefore, string notOnOrAfter, string audience)
        {
            WriteConditions(writer, notBefore, notOnOrAfter, audience, OmittedTokenItems.None);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="notBefore"></param>
        /// <param name="notOnOrAfter"></param>
        /// <param name="audience"></param>
        /// <param name="OmittedPartnerTokenItems"></param>
        /// <param name="OmittedUserTokenItems"></param>
        private static void WriteConditions(XmlTextWriter writer, string notBefore, string notOnOrAfter, string audience, OmittedTokenItems omittedItems)
        {
            writer.WriteStartElement("Conditions", SamlNamespace);

            if (omittedItems.IsNotSet(OmittedTokenItems.NotBefore) && omittedItems.IsNotSet(OmittedTokenItems.NotBeforeNotOnOrAfter))
                writer.WriteAttributeString("NotBefore", notBefore);

            if (omittedItems.IsNotSet(OmittedTokenItems.NotOnOrAfter) && omittedItems.IsNotSet(OmittedTokenItems.NotBeforeNotOnOrAfter))
                writer.WriteAttributeString("NotOnOrAfter", notOnOrAfter);

            if (omittedItems.IsNotSet(OmittedTokenItems.Audience))
            {
                writer.WriteStartElement("AudienceRestrictionCondition", SamlNamespace);
                writer.WriteElementString("Audience", SamlNamespace, audience);
                writer.WriteEndElement(); //AudienceRestrictionCondition
            }
            writer.WriteEndElement(); // Conditions
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="subject"></param>
        private static void WriteSubject(XmlTextWriter writer, string subject)
        {
            writer.WriteStartElement("Subject", SamlNamespace);
            writer.WriteStartElement("NameIdentifier", SamlNamespace);
            writer.WriteAttributeString("Format", "/xboxlive/nameFormat");
            writer.WriteAttributeString("NameQualifier", "Microsoft-NameQualifier-domain");
            writer.WriteString(subject);
            writer.WriteEndElement(); // NameIdentifier
            writer.WriteEndElement(); // subject
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="claim"></param>
        /// <param name="value"></param>
        private static void WriteClaim(XmlTextWriter writer, string claim, string value)
        {
            writer.WriteStartElement("Attribute", SamlNamespace);
            writer.WriteAttributeString("AttributeName", claim);
            writer.WriteAttributeString("AttributeNamespace", "http://xboxlive.com/claims");
            if(value.Trim().Length == 0)
                writer.WriteElementString("AttributeValue", SamlNamespace, String.Format("<![CDATA[{0}]]>", value));
            else
                writer.WriteElementString("AttributeValue", SamlNamespace, value);
            writer.WriteEndElement();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="document"></param>
        /// <param name="assertionID"></param>
        private void SignXmlViaLocalCert(XmlDocument document, string assertionID)
        {
            SignXmlViaLocalCert(document, assertionID, null);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="document"></param>
        /// <param name="assertionID"></param>
        /// <param name="cert"></param>
        /// <param name="exceptionMessage"></param>
        private void SignXmlViaLocalCert(XmlDocument document, string assertionID, X509Certificate2 cert)
        {
            // grab the cert so we don't have a race condition with it changing during a reload
            // we need this because we access the cert twice in this function and don't want to take a lock... but need to stay consistant
            X509Certificate2 signingCertificate;

            if (cert == null)
                signingCertificate = GetCertificate();
            else
                signingCertificate = cert;

            try
            {
                // Create a CustomSignedXml object.  
                // The CustomSigendXml object lets us change what attribute is used to find the node to sign.
                // The standard SignedXml signs the node identified by the attribute named 'id'.
                // We need to sign the node identified by the attribute named 'AssertionID'. 
                CustomSignedXml signedXml = new CustomSignedXml(document);
                signedXml.SignedInfo.CanonicalizationMethod = SignedXml.XmlDsigExcC14NTransformUrl;
                signedXml.SigningKey = (RSACryptoServiceProvider)signingCertificate.PrivateKey;

                // Create a reference which tells SignedXml what node to sign
                Reference reference = new Reference();
                reference.Uri = "#" + assertionID;

                // Add an enveloped transformation to the reference.
                XmlDsigEnvelopedSignatureTransform transform1 = new XmlDsigEnvelopedSignatureTransform();
                reference.AddTransform(transform1);

                XmlDsigExcC14NTransform transform2 = new XmlDsigExcC14NTransform();
                reference.AddTransform(transform2);

                // Add the reference to the SignedXml object.
                signedXml.AddReference(reference);

                // add key info
                KeyInfo keyInfo = new KeyInfo();
                keyInfo.AddClause(new KeyInfoX509Data(signingCertificate));
                signedXml.KeyInfo = keyInfo;

                // Compute the signature.
                signedXml.ComputeSignature();

                // Get the XML representation of the signature and save
                // it to an XmlElement object.
                XmlElement xmlDigitalSignature = signedXml.GetXml();

                // Append the element to the XML document.
                document.DocumentElement.AppendChild(document.ImportNode(xmlDigitalSignature, true));
            }
            catch (Exception e)
            {
                throw new ApplicationException(String.Format("Error signing SAML token with certificate '{0}'; {1}", cert.Subject, e.Message), e);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        private X509Certificate2 GetCertificate()
        {
            lock (certStoreLock)
            {
                X509Certificate2 certificate = this._certificate;

                // do I have a cert
                if (certificate != null)
                    return certificate;

                string subject = this.CertificateSubject;
                X509Store store = new X509Store(StoreName.My, StoreLocation.LocalMachine);
                store.Open(OpenFlags.ReadOnly);

                try
                {
                    // Find the certificate that matches the subject
                    X509Certificate2Collection matches = store.Certificates.Find(X509FindType.FindBySubjectName, subject, false);
                    if (matches == null || matches.Count == 0)
                        throw new ApplicationException(String.Format("No certificates with subject {0} were found in the specified store", subject));
                    if (matches.Count > 1)
                        throw new ApplicationException(String.Format("Multiple certificates with subject {0} were found in the specified store", subject));
                    if (!matches[0].HasPrivateKey)
                        throw new ApplicationException(String.Format("Certificate with subject {0} doesn't have a private key", subject));
                    _certificate = certificate = matches[0];
                }
                finally
                {
                    if (store != null)
                        store.Close();
                }
                return certificate;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\FrameworkLib\Configuration\Configuration.cs ===
using System;
using System.Configuration;

namespace LiveN.Test.Framework.Configuration
{
	/// <summary>
	/// Class that encapsulates configuration information, parsed from app.config.
	/// </summary>
	public static class Config
	{
        private static EnvironmentSettingsSection envSettings;

        /// <summary>
        /// 
        /// </summary>
        static Config()
        {
            envSettings = (EnvironmentSettingsSection)ConfigurationManager.GetSection("environmentSettings");            
        }

        /// <summary>
        /// 
        /// </summary>
        public static EnvironmentSettingsSection EnvironmentSettings
        {
            get
            {
                return envSettings;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public static EnvironmentElement Environment
        {
            get
            {
                return envSettings.SelectedEnvironment;
            }
        }        
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\FrameworkLib\Configuration\EnvironmentElementCollection.cs ===
using System;
using System.Configuration;

namespace LiveN.Test.Framework.Configuration
{
    /// <summary>
    /// 
    /// </summary>
    public class EnvironmentElementCollection : ConfigurationElementCollection
    {
        /// <summary>
        /// 
        /// </summary>
        public EnvironmentElementCollection()
        {

        }

        /// <summary>
        /// 
        /// </summary>
        public override ConfigurationElementCollectionType CollectionType
        {
            get
            {
                return ConfigurationElementCollectionType.AddRemoveClearMap;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        protected override ConfigurationElement CreateNewElement()
        {
            return new EnvironmentElement();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="element"></param>
        /// <returns></returns>
        protected override object GetElementKey(ConfigurationElement element)
        {
            return ((EnvironmentElement)element).Name;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public EnvironmentElement this[int index]
        {
            get
            {
                return (EnvironmentElement)BaseGet(index);
            }
            set
            {
                if (BaseGet(index) != null)
                    BaseRemoveAt(index);
                BaseAdd(index, value);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="type"></param>
        /// <returns></returns>
        new public EnvironmentElement this[string name]
        {
            get
            {
                return (EnvironmentElement)BaseGet(name);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\FrameworkLib\Configuration\EnvironmentElement.cs ===
﻿using System;
using System.Configuration;

namespace LiveN.Test.Framework.Configuration
{
    /// <summary>
    /// 
    /// </summary>
    public class EnvironmentElement : ConfigurationElement
    {        
        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("name", IsRequired = false, DefaultValue = "INT2")]
        public string Name
        {
            get
            {
                return (string)this["name"];
            }
            set
            {
                this["name"] = value;
            }
        }

        [ConfigurationProperty("ManifestReadService", IsRequired = false)]
        public Uri ManifestReadService
        {
            get
            {
                return this["ManifestReadService"] as Uri;
            }
            set
            {
                this["ManifestReadService"] = value;
            }
        }

        [ConfigurationProperty("ManifestReadOriginService", IsRequired = false)]
        public Uri ManifestReadOriginService
        {
            get
            {
                return this["ManifestReadOriginService"] as Uri;
            }
            set
            {
                this["ManifestReadOriginService"] = value;
            }
        }       

        [ConfigurationProperty("ManifestReadPartService", IsRequired = false)]
        public Uri ManifestReadPartService
        {
            get
            {
                return this["ManifestReadPartService"] as Uri;
            }
            set
            {
                this["ManifestReadPartService"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("ManifestWritePartService", IsRequired = false)]
        public Uri ManifestWritePartService
        {
            get
            {
                return this["ManifestWritePartService"] as Uri;
            }
            set
            {
                this["ManifestWritePartService"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("ClosetPartService", IsRequired = false)]
        public Uri ClosetPartService
        {
            get
            {
                return this["ClosetPartService"] as Uri;
            }
            set
            {
                this["ClosetPartService"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("GameDataService", IsRequired = false)]
        public Uri GameDataService
        {
            get
            {
                return this["GameDataService"] as Uri;
            }
            set
            {
                this["GameDataService"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("GameSessionService", IsRequired = false)]
        public Uri GameSessionService
        {
            get
            {
                return this["GameSessionService"] as Uri;
            }
            set
            {
                this["GameSessionService"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("GameStateService", IsRequired = false)]
        public Uri GameStateService
        {
            get
            {
                return this["GameStateService"] as Uri;
            }
            set
            {
                this["GameStateService"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("NotificationsService", IsRequired = false)]
        public Uri NotificationsService
        {
            get
            {
                return this["NotificationsService"] as Uri;
            }
            set
            {
                this["NotificationsService"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("NotificationsServicePrivate", IsRequired = false)]
        public Uri NotificationsServicePrivate
        {
            get
            {
                return this["NotificationsServicePrivate"] as Uri;
            }
            set
            {
                this["NotificationsServicePrivate"] = value;
            }
        }


        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("NotificationSubscriptionService", IsRequired = false)]
        public Uri NotificationSubscriptionService
        {
            get
            {
                return this["NotificationSubscriptionService"] as Uri;
            }
            set
            {
                this["NotificationSubscriptionService"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("PartnerService", IsRequired = false)]
        public Uri PartnerService
        {
            get
            {
                return this["PartnerService"] as Uri;
            }
            set
            {
                this["PartnerService"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("RewardsService", IsRequired = false)]
        public Uri RewardsService
        {
            get
            {
                return this["RewardsService"] as Uri;
            }
            set
            {
                this["RewardsService"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("UDSProfileService", IsRequired = false)]
        public Uri UDSProfileService
        {
            get
            {
                return this["UDSProfileService"] as Uri;
            }
            set
            {
                this["UDSProfileService"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("UDSGameDataService", IsRequired = false)]
        public Uri UDSGameDataService
        {
            get
            {
                return this["UDSGameDataService"] as Uri;
            }
            set
            {
                this["UDSGameDataService"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("UDSPartnerMessageService", IsRequired = false)]
        public Uri UDSPartnerMessageService
        {
            get
            {
                return this["UDSPartnerMessageService"] as Uri;
            }
            set
            {
                this["UDSPartnerMessageService"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("UDSPartnerProfileService", IsRequired = false)]
        public Uri UDSPartnerProfileService
        {
            get
            {
                return this["UDSPartnerProfileService"] as Uri;
            }
            set
            {
                this["UDSPartnerProfileService"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("UDSPartnerGameDataService", IsRequired = false)]
        public Uri UDSPartnerGameDataService
        {
            get
            {
                return this["UDSPartnerGameDataService"] as Uri;
            }
            set
            {
                this["UDSPartnerGameDataService"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("UDSPartnerPresenceService", IsRequired = false)]
        public Uri UDSPartnerPresenceService
        {
            get
            {
                return this["UDSPartnerPresenceService"] as Uri;
            }
            set
            {
                this["UDSPartnerPresenceService"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("UDSPartnerFriendService", IsRequired = false)]
        public Uri UDSPartnerFriendService
        {
            get
            {
                return this["UDSPartnerFriendService"] as Uri;
            }
            set
            {
                this["UDSPartnerFriendService"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("MPTestHooksService", IsRequired = false)]
        public Uri MPTestHooksService
        {
            get
            {
                return this["MPTestHooksService"] as Uri;
            }
            set
            {
                this["MPTestHooksService"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("ConnectionString", IsRequired = false)]
        public string ConnectionString
        {
            get
            {
                return (string)this["ConnectionString"];
            }
            set
            {
                this["ConnectionString"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("SsrUseTestService", IsRequired = false, DefaultValue = false)]
        public bool SsrUseTestService
        {
            get
            {
                return (bool)this["SsrUseTestService"];
            }
            set
            {
                this["SsrUseTestService"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("SsrDevServiceAccount", IsRequired = false)]
        public string SsrDevServiceAccount
        {
            get
            {
                return (string)this["SsrDevServiceAccount"];
            }
            set
            {
                this["SsrDevServiceAccount"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("SsrMachineName", IsRequired = false)]
        public string SsrMachineName
        {
            get
            {
                return (string)this["SsrMachineName"];
            }
            set
            {
                this["SsrMachineName"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("CoreTestServiceBaseUrl", IsRequired = false)]
        public Uri CoreTestServiceBaseUrl
        {
            get
            {
                return this["CoreTestServiceBaseUrl"] as Uri;
            }
            set
            {
                this["CoreTestServiceBaseUrl"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("LiveLibEnvironment", IsRequired = false)]
        public string LiveLibEnvironment
        {
            get
            {
                return (string)this["LiveLibEnvironment"];
            }
            set
            {
                this["LiveLibEnvironment"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("UseStf", IsRequired = false, DefaultValue = "true")]
        public bool UseStf
        {
            get
            {
                return (bool)this["UseStf"];
            }
            set
            {
                this["UseStf"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("preExistingUsers", IsRequired = false)]
        public PreExistingUserElementCollection UserSettings
        {
            get
            {
                return (PreExistingUserElementCollection)this["preExistingUsers"];
            }
            set
            {
                this["preExistingUsers"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("WindowsLiveIDSettings", IsRequired = true)]
        public WindowsLiveIDSettingsElement WindowsLiveIDSettings
        {
            get
            {
                return (WindowsLiveIDSettingsElement)this["WindowsLiveIDSettings"];
            }
            set
            {
                this["WindowsLiveIDSettings"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("StsSettings", IsRequired = true)]
        public StsSettingsElement StsSettings
        {
            get
            {
                return (StsSettingsElement)this["StsSettings"];
            }
            set
            {
                this["StsSettings"] = value;
            }
        }

        [ConfigurationProperty("Titles", IsRequired = false)]
        public TitleElementCollection Titles
        {
            get
            {
                return (TitleElementCollection)this["Titles"];
            }
            set
            {
                this["Titles"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("CosmosCacheTimeoutInMinutes", IsRequired = false)]
        public int CosmosCacheTimeoutInMinutes
        {
            get
            {
                return (int)this["CosmosCacheTimeoutInMinutes"];
            }
            set
            {
                this["CosmosCacheTimeoutInMinutes"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("IsTestOnlyEnvironment", IsRequired = false, DefaultValue = false)]
        public bool IsTestOnlyEnvironment
        {
            get
            {
                return (bool)this["IsTestOnlyEnvironment"];
            }
            set
            {
                this["IsTestOnlyEnvironment"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("Locale", IsRequired = false, DefaultValue = "en-US")]
        public string Locale
        {
            get
            {
                return (string)this["Locale"];
            }
            set
            {
                this["Locale"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("XuacsSettings", IsRequired = false)]
        public XuacsSettingsElement XuacsSettings
        {
            get
            {
                return (XuacsSettingsElement)this["XuacsSettings"];
            }
            set
            {
                this["XuacsSettings"] = value;
            }
        }

        /// <summary>
        /// Url pointing to an Avatar's publicly facing location
        /// </summary>
        [ConfigurationProperty("AvatarImage_GamerPicSmall", IsRequired = false)]
        public Uri AvatarImage_GamerPicSmall
        {
            get
            {
                return (Uri)this["AvatarImage_GamerPicSmall"];
            }
            set
            {
                this["AvatarImage_GamerPicSmall"] = value;
            }
        }

        /// <summary>
        /// Url pointing to an Avatar's publicly facing location
        /// </summary>
        [ConfigurationProperty("AvatarImage_GamerPicLarge", IsRequired = false)]
        public Uri AvatarImage_GamerPicLarge
        {
            get
            {
                return (Uri)this["AvatarImage_GamerPicLarge"];
            }
            set
            {
                this["AvatarImage_GamerPicLarge"] = value;
            }
        }

        /// <summary>
        /// Url pointing to an Avatar's publicly facing location
        /// </summary>
        [ConfigurationProperty("AvatarImage_GamerPicBody", IsRequired = false)]
        public Uri AvatarImage_GamerPicBody
        {
            get
            {
                return (Uri)this["AvatarImage_GamerPicBody"];
            }
            set
            {
                this["AvatarImage_GamerPicBody"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("LiveConnectSettings", IsRequired = false)]
        public LiveConnectSettingsElement LiveConnectSettings
        {
            get
            {
                return (LiveConnectSettingsElement)this["LiveConnectSettings"];
            }
            set
            {
                this["LiveConnectSettings"] = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\FrameworkLib\Configuration\PreExistingUserElementCollection.cs ===
using System;
using System.Configuration;

namespace LiveN.Test.Framework.Configuration
{
    /// <summary>
    /// 
    /// </summary>
    public class PreExistingUserElementCollection : ConfigurationElementCollection
    {
        /// <summary>
        /// 
        /// </summary>
        public PreExistingUserElementCollection()
        {

        }

        /// <summary>
        /// 
        /// </summary>
        public override ConfigurationElementCollectionType CollectionType
        {
            get
            {
                return ConfigurationElementCollectionType.AddRemoveClearMap;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        protected override ConfigurationElement CreateNewElement()
        {
            return new PreExistingUserElement();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="element"></param>
        /// <returns></returns>
        protected override object GetElementKey(ConfigurationElement element)
        {
            return ((PreExistingUserElement)element).Membername;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public PreExistingUserElement this[int index]
        {
            get
            {
                return (PreExistingUserElement)BaseGet(index);
            }
            set
            {
                if (BaseGet(index) != null)
                    BaseRemoveAt(index);
                BaseAdd(index, value);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="type"></param>
        /// <returns></returns>
        new public PreExistingUserElement this[string membername]
        {
            get
            {
                return (PreExistingUserElement)BaseGet(membername);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\FrameworkLib\Configuration\LiveLibSettingsElement.cs ===
﻿using System;
using System.Configuration;

namespace LiveN.Test.Framework.Configuration
{
    /// <summary>
    /// 
    /// </summary>
    public class LiveLibSettingsElement : ConfigurationElement
    {
        /// <summary>
        /// 
        /// </summary>
        public LiveLibSettingsElement()
        {

        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="liveLibEnvironment"></param>
        /// <param name="userStf"></param>
        public LiveLibSettingsElement(
            string liveLibEnvironment,
            bool userStf)
        {
            this.LiveLibEnvironment = liveLibEnvironment;
            this.UseStf = userStf;
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("LiveLibEnvironment", DefaultValue = "le-xblob-test02")]
        public string LiveLibEnvironment
        {
            get
            {
                return (string)this["LiveLibEnvironment"];
            }
            set
            {
                this["LiveLibEnvironment"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("UseStf", DefaultValue = true)]
        public bool UseStf
        {
            get
            {
                return (bool)this["UseStf"];
            }
            set
            {
                this["UseStf"] = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\FrameworkLib\Configuration\LiveConnectSettingsElement.cs ===
﻿using System;
using System.Configuration;

namespace LiveN.Test.Framework.Configuration
{
    /// <summary>
    /// 
    /// </summary>
    public class LiveConnectSettingsElement : ConfigurationElement
    {
        /// <summary>
        /// 
        /// </summary>
        public LiveConnectSettingsElement()
        {

        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("StsEndpoint", IsRequired = true)]
        public Uri StsEndpoint
        {
            get
            {
                return this["StsEndpoint"] as Uri;
            }
            set
            {
                this["StsEndpoint"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("CertEndpoint", IsRequired=true)]
        public Uri CertEndpoint
        {
            get
            {
                return this["CertEndpoint"] as Uri;
            }
            set
            {
                this["CertEndpoint"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("SmokePageUrl", IsRequired=true)]
        public Uri SmokePageUrl
        {
            get
            {
                return this["SmokePageUrl"] as Uri;
            }
            set
            {
                this["SmokePageUrl"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("CertificateSubject", IsRequired = true)]
        public string CertificateSubject
        {
            get
            {
                return (string)this["CertificateSubject"];
            }
            set
            {
                this["CertificateSubject"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("CertificatePath", IsRequired = true)]
        public string CertificatePath
        {
            get
            {
                return (string)this["CertificatePath"];
            }
            set
            {
                this["CertificatePath"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("CertificatePassword", IsRequired = true)]
        public string CertificatePassword
        {
            get
            {
                return (string)this["CertificatePassword"];
            }
            set
            {
                this["CertificatePassword"] = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\FrameworkLib\Configuration\EnvironmentSettingsSection.cs ===
﻿using System;
using System.Configuration;

namespace LiveN.Test.Framework.Configuration
{
    /// <summary>
    /// 
    /// </summary>
    public class EnvironmentSettingsSection : ConfigurationSection
    {
        private static ConfigurationPropertyCollection properties;
        private static readonly ConfigurationProperty selected = new ConfigurationProperty("selected", typeof(string));
        private static readonly ConfigurationProperty customSettings = new ConfigurationProperty("environments", typeof(EnvironmentElementCollection));
        private static EnvironmentElement selectedEnvironment;

        /// <summary>
        /// 
        /// </summary>
        public EnvironmentSettingsSection()
        {
            properties = new ConfigurationPropertyCollection();
            properties.Add(customSettings);
            properties.Add(selected);
        }

        /// <summary>
        /// 
        /// </summary>
        protected override ConfigurationPropertyCollection Properties
        {
            get
            {
                return properties;
            }
        }

        ///
        [ConfigurationProperty("selected",
            DefaultValue = "Storax",
            IsRequired = true,
            IsKey = false)]
        [StringValidator(InvalidCharacters =
            " ~!@#$%^&*()[]{}/;'\"|\\",
            MinLength = 1, MaxLength = 60)]
        public string Selected
        {
            get
            {
                return (string)this["selected"];
            }
            set
            {
                this["selected"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("environments", IsRequired = true)]
        public EnvironmentElementCollection Environments
        {
            get
            {
                return (EnvironmentElementCollection)this["environments"];
            }
            set
            {
                this["environments"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public EnvironmentElement SelectedEnvironment
        {
            get
            {
                if (selectedEnvironment == null)
                {
                    foreach (EnvironmentElement env in this.Environments)
                    {
                        if (string.Equals(this.Selected, env.Name, StringComparison.OrdinalIgnoreCase))
                        {
                            selectedEnvironment = env;
                            break;
                        }
                    }

                    if (selectedEnvironment == null)
                    {
                        throw new ConfigurationErrorsException("No enviornment marked as selected.");
                    }
                }
                return selectedEnvironment;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\FrameworkLib\Configuration\PreExistingUserElement.cs ===
using System;
using System.Configuration;

namespace LiveN.Test.Framework.Configuration
{
    /// <summary>
    /// 
    /// </summary>
    public class PreExistingUserElement : ConfigurationElement
    {
        /// <summary>
        /// 
        /// </summary>
        public PreExistingUserElement()
        {

        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="usePreExisting"></param>
        /// <param name="msnTouVersion"></param>
        /// <param name="winLiveTouVersion"></param>
        public PreExistingUserElement(string membername, string password)
        {
            this.Membername = membername;
            this.Password = password;
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("membername", IsRequired = true)]
        public string Membername
        {
            get
            {
                return (string)this["membername"];
            }
            set
            {
                this["membername"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("password", IsRequired = true)]
        public string Password
        {
            get
            {
                return (string)this["password"];
            }
            set
            {
                this["password"] = value;
            }
        }

        [ConfigurationProperty("gamertag", IsRequired = false)]
        public string GamerTag
        {
            get
            {
                return (string)this["gamertag"];
            }
            set
            {
                this["gamertag"] = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\FrameworkLib\Configuration\TitleElementCollection.cs ===
using System;
using System.Configuration;

namespace LiveN.Test.Framework.Configuration
{
    /// <summary>
    /// 
    /// </summary>
    public class TitleElementCollection : ConfigurationElementCollection
    {
        /// <summary>
        /// 
        /// </summary>
        public TitleElementCollection()
        {

        }

        /// <summary>
        /// 
        /// </summary>
        public override ConfigurationElementCollectionType CollectionType
        {
            get
            {
                return ConfigurationElementCollectionType.AddRemoveClearMap;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        protected override ConfigurationElement CreateNewElement()
        {
            return new TitleElement();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="element"></param>
        /// <returns></returns>
        protected override object GetElementKey(ConfigurationElement element)
        {
            TitleElement title = element as TitleElement;
            return title.Id + title.Version + title.ConsoleType.ToString();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public TitleElement this[int index]
        {
            get
            {
                return (TitleElement)BaseGet(index);
            }
            set
            {
                if (BaseGet(index) != null)
                    BaseRemoveAt(index);
                BaseAdd(index, value);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="type"></param>
        /// <returns></returns>
        new public TitleElement this[string name]
        {
            get
            {
                return (TitleElement)BaseGet(name);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\FrameworkLib\Configuration\StsSettingsElement.cs ===
﻿using System;
using System.Configuration;

namespace LiveN.Test.Framework.Configuration
{
    public class StsSettingsElement : ConfigurationElement
    {
        public StsSettingsElement()
        {
        }

        public StsSettingsElement(
            string platformType,
            string titleId,
            string titleVersion,
            string clientVersion,
            string audienceUri_UserData,
            string audienceUri_MultiPlayer,
            string audienceUri_AvatarServices,
            string clientCertSubject,
            string clientCertPath,
            string clientCertPassword,
            string stsUrl)
        {
            this.PlatformType = platformType;
            this.TitleId = titleId;
            this.TitleVersion = titleVersion;
            this.ClientVersion = clientVersion;
            this.AudienceUri_UserData = audienceUri_UserData;
            this.AudienceUri_MultiPlayer = audienceUri_MultiPlayer;
            this.AudienceUri_AvatarServices = audienceUri_AvatarServices;
            this.ClientCertSubject = clientCertSubject;
            this.ClientCertPath = clientCertPath;
            this.ClientCertPassword = clientCertPassword;
            this.StsUrl = stsUrl;
        }

        [ConfigurationProperty("WebStsUrl", IsRequired = false)]
        public string WebStsUrl
        {
            get
            {
                return (string)this["WebStsUrl"];
            }
            set
            {
                this["WebStsUrl"] = value;
            }
        }

        [ConfigurationProperty("WebStsLiveIdUrl", IsRequired = false)]
        public string WebStsLiveIdUrl
        {
            get
            {
                return (string)this["WebStsLiveIdUrl"];
            }
            set
            {
                this["WebStsLiveIdUrl"] = value;
            }
        }

        [ConfigurationProperty("StsUrl", IsRequired = true)]
        public string StsUrl
        {
            get
            {
                return (string)this["StsUrl"];
            }
            set
            {
                this["StsUrl"] = value;
            }
        }

        [ConfigurationProperty("PlatformType", IsRequired = true)]
        public string PlatformType
        {
            get
            {
                return (string)this["PlatformType"];
            }
            set
            {
                this["PlatformType"] = value;
            }
        }

        [ConfigurationProperty("TitleId", IsRequired = true)]
        public string TitleId
        {
            get
            {
                return (string)this["TitleId"];
            }
            set
            {
                this["TitleId"] = value;
            }
        }

        [ConfigurationProperty("TitleId2", IsRequired = false)]
        public string TitleId2
        {
            get
            {
                return (string)this["TitleId2"];
            }
            set
            {
                this["TitleId2"] = value;
            }
        }

        [ConfigurationProperty("TitleId3", IsRequired = false)]
        public string TitleId3
        {
            get
            {
                return (string)this["TitleId3"];
            }
            set
            {
                this["TitleId3"] = value;
            }
        }

        [ConfigurationProperty("TitleVersion", IsRequired = true)]
        public string TitleVersion
        {
            get
            {
                return (string)this["TitleVersion"];
            }
            set
            {
                this["TitleVersion"] = value;
            }
        }

        [ConfigurationProperty("TitleVersion2", IsRequired = false)]
        public string TitleVersion2
        {
            get
            {
                return (string)this["TitleVersion2"];
            }
            set
            {
                this["TitleVersion2"] = value;
            }
        }

        [ConfigurationProperty("TitleVersion3", IsRequired = false)]
        public string TitleVersion3
        {
            get
            {
                return (string)this["TitleVersion3"];
            }
            set
            {
                this["TitleVersion3"] = value;
            }
        }

        [ConfigurationProperty("ClientVersion", IsRequired = true)]
        public string ClientVersion
        {
            get
            {
                return (string)this["ClientVersion"];
            }
            set
            {
                this["ClientVersion"] = value;
            }
        }

        [ConfigurationProperty("AudienceUri_MultiPlayer", IsRequired = false)]
        public string AudienceUri_MultiPlayer
        {
            get
            {
                return (string)this["AudienceUri_MultiPlayer"];
            }
            set
            {
                this["AudienceUri_MultiPlayer"] = value;
            }
        }

        [ConfigurationProperty("AudienceUri_AvatarServices", IsRequired = false)]
        public string AudienceUri_AvatarServices
        {
            get
            {
                return (string)this["AudienceUri_AvatarServices"];
            }
            set
            {
                this["AudienceUri_AvatarServices"] = value;
            }
        }       

        [ConfigurationProperty("AudienceUri_UserData", IsRequired = false)]
        public string AudienceUri_UserData
        {
            get
            {
                return (string)this["AudienceUri_UserData"];
            }
            set
            {
                this["AudienceUri_UserData"] = value;
            }
        }

        [ConfigurationProperty("ClientCertSubject", IsRequired = false)]
        public string ClientCertSubject
        {
            get
            {
                return (string)this["ClientCertSubject"];
            }
            set
            {
                this["ClientCertSubject"] = value;
            }
        }

        [ConfigurationProperty("ClientCertPath", IsRequired = false)]
        public string ClientCertPath
        {
            get
            {
                return (string)this["ClientCertPath"];
            }
            set
            {
                this["ClientCertPath"] = value;
            }
        }

        [ConfigurationProperty("ClientCertPassword", IsRequired = false)]
        public string ClientCertPassword
        {
            get
            {
                return (string)this["ClientCertPassword"];
            }
            set
            {
                this["ClientCertPassword"] = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\FrameworkLib\Configuration\WindowsLiveIDSettingsElement.cs ===
﻿using System;
using System.Configuration;

namespace LiveN.Test.Framework.Configuration
{
    /// <summary>
    /// 
    /// </summary>
    public class WindowsLiveIDSettingsElement : ConfigurationElement
    {
        /// <summary>
        /// 
        /// </summary>
        public WindowsLiveIDSettingsElement()
        {

        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="usePreExisting"></param>
        /// <param name="msnTouVersion"></param>
        /// <param name="winLiveTouVersion"></param>
        public WindowsLiveIDSettingsElement(
            string environment,
            string liveIdServiceTarget,
            string policy)
        {
            this.Environment = environment;
            this.LiveIdServiceTarget = liveIdServiceTarget;
            this.Policy = policy;
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("Environment", DefaultValue = "INT")]
        public string Environment
        {
            get
            {
                return (string)this["Environment"];
            }
            set
            {
                this["Environment"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("LiveIdServiceTarget", IsRequired = true)]
        public string LiveIdServiceTarget
        {
            get
            {
                return (string)this["LiveIdServiceTarget"];
            }
            set
            {
                this["LiveIdServiceTarget"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("Policy", DefaultValue="LBI")]
        public string Policy
        {
            get
            {
                return (string)this["Policy"];
            }
            set
            {
                this["Policy"] = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\FrameworkLib\Configuration\TitleElement.cs ===
﻿using System;
using System.Configuration;
using LiveN.Test.Framework;

namespace LiveN.Test.Framework.Configuration
{
    /// <summary>
    /// 
    /// </summary>
    public class TitleElement : ConfigurationElement
    {
        /// <summary>
        /// 
        /// </summary>
        public TitleElement()
        {

        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="usePreExisting"></param>
        /// <param name="msnTouVersion"></param>
        /// <param name="winLiveTouVersion"></param>
        public TitleElement(
            string name,
            string titleId,
            string titleVersion,
            ConsoleType type,
            string area)
        {
            this.Name = name;
            this.Id = titleId;
            this.Version = titleVersion;
            this.ConsoleType = type;
            this.Area = area;
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("Name", IsRequired = true)]
        public string Name
        {
            get
            {
                return (string)this["Name"];
            }
            set
            {
                this["Name"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("Id", IsRequired=true)]
        public string Id
        {
            get
            {
                return (string)this["Id"];
            }
            set
            {
                this["Id"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("Version", DefaultValue="1", IsRequired=true)]
        public string Version
        {
            get
            {
                return (string)this["Version"];
            }
            set
            {
                this["Version"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("ConsoleType", DefaultValue=ConsoleType.WindowsPhone)]
        public ConsoleType ConsoleType
        {
            get
            {
                return (ConsoleType)this["ConsoleType"];
            }
            set
            {
                this["ConsoleType"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("Area", IsRequired = false)]
        public string Area
        {
            get
            {
                return (string)this["Area"];
            }
            set
            {
                this["Area"] = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\FrameworkLib\Configuration\XuacsSettingsElement.cs ===
﻿using System;
using System.Configuration;

namespace LiveN.Test.Framework.Configuration
{
    /// <summary>
    /// 
    /// </summary>
    public class XuacsSettingsElement : ConfigurationElement
    {
        /// <summary>
        /// 
        /// </summary>
        public XuacsSettingsElement()
        {

        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="usePreExisting"></param>
        /// <param name="msnTouVersion"></param>
        /// <param name="winLiveTouVersion"></param>
        public XuacsSettingsElement(string xuacsUrl, string clientCertSubject, int timeout)
        {
            this.XuacsUrl = xuacsUrl;
            this.ClientCertSubject = clientCertSubject;
            this.Timeout = timeout;
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("XuacsUrl", IsRequired = false)]
        public string XuacsUrl
        {
            get
            {
                return (string)this["XuacsUrl"];
            }
            set
            {
                this["XuacsUrl"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("ClientCertSubject", IsRequired = false)]
        public string ClientCertSubject
        {
            get
            {
                return (string)this["ClientCertSubject"];
            }
            set
            {
                this["ClientCertSubject"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("Timeout", IsRequired = false)]
        public int Timeout
        {
            get
            {
                return (int)this["Timeout"];
            }
            set
            {
                this["Timeout"] = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\FrameworkLib\CurrentEnvironmentSettings\EnvironmentElementCollection.cs ===
using System;
using System.Configuration;

namespace LiveNew.Test
{
    public class EnvironmentElementCollection : ConfigurationElementCollection
    {
        public EnvironmentElementCollection()
        {
        }

        public override ConfigurationElementCollectionType CollectionType
        {
            get
            {
                return ConfigurationElementCollectionType.AddRemoveClearMap;
            }
        }

        protected override ConfigurationElement CreateNewElement()
        {
            return new EnvironmentElement();
        }

        protected override object GetElementKey(ConfigurationElement element)
        {
            return ((EnvironmentElement)element).Name;
        }

        public EnvironmentElement this[int index]
        {
            get
            {
                return (EnvironmentElement)BaseGet(index);
            }
            set
            {
                if (BaseGet(index) != null)
                {
                    BaseRemoveAt(index);
                }

                BaseAdd(index, value);
            }
        }

        public new EnvironmentElement this[string name]
        {
            get
            {
                return (EnvironmentElement)BaseGet(name);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\FrameworkLib\CurrentEnvironmentSettings\CurrentEnvironmentSettings.cs ===
﻿using System;
using System.IO;
using System.Configuration;
using System.Reflection;

namespace LiveNew.Test
{
    /// <summary>
    /// Class that encapsulates LiveN Test Default configuration information.
    /// </summary>
    /// <remarks>Wraps the configuration values within the embedded file: LiveN.EnvironmentSettings.config</remarks>
    public static class CurrentEnvironmentSettings 
    {
        private const string CurrentEnvironmentSettingsConfigFilename = "CurrentEnvironmentSettings.config";

        static CurrentEnvironmentSettings()
        {
            Configuration config;
            StreamWriter streamWriter;
            Stream assemblyFileStream;
            ExeConfigurationFileMap fileMap = new ExeConfigurationFileMap();

            if (!File.Exists(CurrentEnvironmentSettingsConfigFilename))
            {
                // Create Config file by extract the file from the resouce location and place it within the current folder. This will ensure that if there has been any updated, they will get outputed.
                using (assemblyFileStream = Assembly.GetExecutingAssembly().GetManifestResourceStream("LiveN.Test.Framework.CurrentEnvironmentSettings." + CurrentEnvironmentSettingsConfigFilename))
                {
                    if (assemblyFileStream == null)
                    {
                        throw new Exception("Could not find Configuration File '" + CurrentEnvironmentSettingsConfigFilename + "'. Verify the file's Property->Build Action = Embedded Resource");
                    }

                    using (StreamReader streamReader = new StreamReader(assemblyFileStream))
                    {
                        using (streamWriter = new StreamWriter(File.Create(CurrentEnvironmentSettingsConfigFilename)))
                        {
                            streamWriter.Write(streamReader.ReadToEnd());
                        }
                    }
                }
            }

            fileMap.ExeConfigFilename = CurrentEnvironmentSettingsConfigFilename;
            config = ConfigurationManager.OpenMappedExeConfiguration(fileMap, ConfigurationUserLevel.None);

            try
            {
                AllEnvironmentSettings = (LiveNew.Test.EnvironmentSettings)config.GetSection("environmentSettings");
            }
            catch(Exception exc)
            {
                throw new Exception("Had trouble loading config file '" + config.FilePath + "' and parsing it for the Environment Settings. \r\nPOSSBALE ISSUE: Config file is not setup correctly.\r\n\r\nException: \r\n" + exc.ToString());
            }
        }

        /// <summary>
        ///  Sets the base EnvironmentSettings which contains all environement(s) settings
        /// </summary>
        /// <param name="EnvironmentSettings">Udpated Environment Settings Section</param>
        public static void SetEnvironmentSettings(EnvironmentSettings environmentSettings)
        {
            AllEnvironmentSettings = environmentSettings;
        }

        /// <summary>
        /// Get the Environment setting for the passing in Environment Name
        /// </summary>
        /// <param name="environmentName">Environment name of the desired Environment</param>
        public static EnvironmentElement GetEnvironmentSettings(string environmentName)
        {
            return AllEnvironmentSettings.Environments[environmentName];
        }

        /// <summary>
        /// Stores all the environment(s) information
        /// </summary>
        public static EnvironmentSettings AllEnvironmentSettings
        {
            get;
            private set;
        }

        /// <summary>
        /// Gets or sets the name of the currently selected environment
        /// </summary>
        public static string SelectedEnvironmentName
        {
            get
            {
                return AllEnvironmentSettings.SelectedEnvironmentName;
            }
            set
            {
                AllEnvironmentSettings.SelectedEnvironmentName = value;
            }
        }

        /// <summary>
        /// Gets the currently selected EnvironmentElement. Which contains all subsection of the environment
        /// </summary>
        public static EnvironmentElement SelectedEnvironment
        {
            get
            {
                return AllEnvironmentSettings.SelectedEnvironment;
            }
        }

        public static StsSettingsElement StsSettings
        {
            get
            {
                return SelectedEnvironment.StsSettings;
            }
        }

        /// <summary>
        /// Collection of all the Pre Existing Users contained within the currently selected environment configurtation file
        /// </summary>
        public static PreExistingUserElementCollection UserSettings
        {
            get
            {
                return SelectedEnvironment.UserSettings;
            }
        }

        /// <summary>
        /// Collection of all the titles contained within the currently selected environment configurtation file
        /// </summary>
        public static TitleElementCollection Titles
        {
            get
            {
                return SelectedEnvironment.Titles;
            }
        }

        public static LiveN.Test.Framework.Configuration.XuacsSettingsElement XuacsSettings
        {
            get
            {
                return SelectedEnvironment.XuacsSettings;
            }
        }

        public static LiveN.Test.Framework.Configuration.WindowsLiveIDSettingsElement WindowsLiveIDSettings
        {
            get
            {
                return SelectedEnvironment.WindowsLiveIDSettings;
            }
        }

        public static LiveN.Test.Framework.Configuration.LiveConnectSettingsElement LiveConnectSettings
        {
            get
            {
                return SelectedEnvironment.LiveConnectSettings;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\FrameworkLib\CurrentEnvironmentSettings\PreExistingUserElement.cs ===
using System;
using System.Configuration;

namespace LiveNew.Test
{
    public class PreExistingUserElement : ConfigurationElement
    {
        public PreExistingUserElement()
        {
        }

        public PreExistingUserElement(string membername, string password)
        {
            this.UserEmail = membername;
            this.Password = password;
        }

        [ConfigurationProperty("UserEmail", IsRequired = true)]
        public string UserEmail
        {
            get
            {
                return (string)this["UserEmail"];
            }
            set
            {
                this["UserEmail"] = value;
            }
        }

        [ConfigurationProperty("Password", IsRequired = true)]
        public string Password
        {
            get
            {
                return (string)this["Password"];
            }
            set
            {
                this["Password"] = value;
            }
        }

        [ConfigurationProperty("GamerTag", IsRequired = false)]
        public string GamerTag
        {
            get
            {
                return (string)this["GamerTag"];
            }
            set
            {
                this["GamerTag"] = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\FrameworkLib\CurrentEnvironmentSettings\EnvironmentSettings.cs ===
﻿using System;
using System.Configuration;

namespace LiveNew.Test
{
    public class EnvironmentSettings : ConfigurationSection
    {
        /// <summary>
        /// Name of the App Config setting used to pull the Selected Environment from the applications configuration file
        /// </summary>
        public const string SELECTED_ENVIRONMENT_CONFIG_NAME = "SelectedEnvironment";

        private ConfigurationPropertyCollection properties;
        private readonly ConfigurationProperty customSettings = new ConfigurationProperty("environments", typeof(EnvironmentElementCollection));

        /// <summary>
        /// Exception used to explain that the Selected Environment Name has nto been set and how to fix it
        /// </summary>
        public Exception SelectedEnvironmentNameException = new Exception("SelectedEnvironmentName has not been set. There are two ways to set this value: \r\n" +
                                        "    1. Create an App.config for your solution. Then add the application setting '" + SELECTED_ENVIRONMENT_CONFIG_NAME + "'. with the value of the desired Environment. (Optimal) \r\n" +
                                        "         Example:   <appSettings> \r\n" +
                                        "                       <add key=\"" + SELECTED_ENVIRONMENT_CONFIG_NAME + "\" value=\"TestNet\"/>\r\n" +
                                        "    2. Before calling anything that uses this, be sure to set it's SelectedEnvironmentName. See EnvironmentSettings.Environments Name='', within the specified config file, for all possable environments.\r\n" +
                                        "         Example:   CurrentEnvironmentSettings.SelectedEnvironmentName = \"Production\""
                                       );

        public EnvironmentSettings()
        {
            properties = new ConfigurationPropertyCollection();
            properties.Add(customSettings);
        }

        protected override ConfigurationPropertyCollection Properties
        {
            get
            {
                return properties;
            }
        }

        /// <summary>
        /// Name of the environment that is currently selected
        /// </summary>
        public string SelectedEnvironmentName
        {
            get
            {
                if (member_selectedEnvironment == null)
                {
                    // Set the Selected Environment based off the App.Config
                    member_selectedEnvironment = ConfigurationManager.AppSettings[SELECTED_ENVIRONMENT_CONFIG_NAME];
                }

                if (string.IsNullOrEmpty(member_selectedEnvironment))
                {
                    // SelectedEnvironmentName is not set. Tell the caller how they can set it
                    throw SelectedEnvironmentNameException;
                }

                return member_selectedEnvironment;
            }
            set
            {
                // Set this to null so the new environment will be selected
                memberSelectedEnvironment = null;

                member_selectedEnvironment = value;
            }
        }
        private string member_selectedEnvironment;

        [ConfigurationProperty("environments", IsRequired = true)]
        public EnvironmentElementCollection Environments
        {
            get
            {
                return (EnvironmentElementCollection)this["environments"];
            }
            set
            {
                this["environments"] = value;
            }
        }

        /// <summary>
        /// Get the currently selected Environment
        /// </summary>
        public EnvironmentElement SelectedEnvironment
        {
            get
            {
                if (memberSelectedEnvironment == null)
                {
                    string selectedEnvironmentName = this.SelectedEnvironmentName;

                    foreach (EnvironmentElement env in this.Environments)
                    {
                        if (string.Equals(selectedEnvironmentName, env.Name, StringComparison.OrdinalIgnoreCase))
                        {
                            memberSelectedEnvironment = env;

                            break;
                        }
                    }

                    if (memberSelectedEnvironment == null)
                    {
                        throw new ConfigurationErrorsException("Selected Environment '" + this.SelectedEnvironmentName + "' could not be found. Make sure it exists within the list of <environments> within config file: '" + this.ElementInformation.Source + "'");
                    }
                }

                return memberSelectedEnvironment;
            }
        }
        private EnvironmentElement memberSelectedEnvironment;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\FrameworkLib\CurrentEnvironmentSettings\PreExistingUserElementCollection.cs ===
using System;
using System.Configuration;

namespace LiveNew.Test
{
    public class PreExistingUserElementCollection : ConfigurationElementCollection
    {
        public PreExistingUserElementCollection()
        {
        }

        public override ConfigurationElementCollectionType CollectionType
        {
            get
            {
                return ConfigurationElementCollectionType.AddRemoveClearMap;
            }
        }

        protected override ConfigurationElement CreateNewElement()
        {
            return new PreExistingUserElement();
        }

        protected override object GetElementKey(ConfigurationElement element)
        {
            return ((PreExistingUserElement)element).UserEmail;
        }

        public PreExistingUserElement this[int index]
        {
            get
            {
                return (PreExistingUserElement)BaseGet(index);
            }
            set
            {
                if (BaseGet(index) != null)
                {
                    BaseRemoveAt(index);
                }

                BaseAdd(index, value);
            }
        }

        public new PreExistingUserElement this[string membername]
        {
            get
            {
                return (PreExistingUserElement)BaseGet(membername);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\FrameworkLib\CurrentEnvironmentSettings\EnvironmentElement.cs ===
﻿using System;
using System.Configuration;

namespace LiveNew.Test
{
    public class EnvironmentElement : ConfigurationElement
    {        
        [ConfigurationProperty("name", IsRequired = true)]
        public string Name
        {
            get
            {
                return (string)this["name"];
            }
            set
            {
                this["name"] = value;
            }
        }

        [ConfigurationProperty("ManifestReadService", IsRequired = true)]
        public Uri ManifestReadService
        {
            get
            {
                return this["ManifestReadService"] as Uri;
            }
            set
            {
                this["ManifestReadService"] = value;
            }
        }

        [ConfigurationProperty("ManifestReadOriginService", IsRequired = true)]
        public Uri ManifestReadOriginService
        {
            get
            {
                return this["ManifestReadOriginService"] as Uri;
            }
            set
            {
                this["ManifestReadOriginService"] = value;
            }
        }       

        [ConfigurationProperty("ManifestReadPartService", IsRequired = true)]
        public Uri ManifestReadPartService
        {
            get
            {
                return this["ManifestReadPartService"] as Uri;
            }
            set
            {
                this["ManifestReadPartService"] = value;
            }
        }

        [ConfigurationProperty("ManifestWritePartService", IsRequired = true)]
        public Uri ManifestWritePartService
        {
            get
            {
                return this["ManifestWritePartService"] as Uri;
            }
            set
            {
                this["ManifestWritePartService"] = value;
            }
        }

        [ConfigurationProperty("GamerPicPartService", IsRequired = true)]
        public Uri GamerPicPartService
        {
            get
            {
                return this["GamerPicPartService"] as Uri;
            }
            set
            {
                this["GamerPicPartService"] = value;
            }
        }

        [ConfigurationProperty("ClosetPartService", IsRequired = true)]
        public Uri ClosetPartService
        {
            get
            {
                return this["ClosetPartService"] as Uri;
            }
            set
            {
                this["ClosetPartService"] = value;
            }
        }

        [ConfigurationProperty("PDLCServices", IsRequired = true)]
        public Uri PDLCServices
        {
            get
            {
                return this["PDLCServices"] as Uri;
            }
            set
            {
                this["PDLCServices"] = value;
            }
        }

        [ConfigurationProperty("GameSessionService", IsRequired = true)]
        public Uri GameSessionService
        {
            get
            {
                return this["GameSessionService"] as Uri;
            }
            set
            {
                this["GameSessionService"] = value;
            }
        }

        [ConfigurationProperty("GameStateService", IsRequired = true)]
        public Uri GameStateService
        {
            get
            {
                return this["GameStateService"] as Uri;
            }
            set
            {
                this["GameStateService"] = value;
            }
        }

        [ConfigurationProperty("MessagingService", IsRequired = false)]
        public Uri MessagingService
        {
            get
            {
                return this["MessagingService"] as Uri;
            }
            set
            {
                this["MessagingService"] = value;
            }
        }

        [ConfigurationProperty("PartnerService", IsRequired = true)]
        public Uri PartnerService
        {
            get
            {
                return this["PartnerService"] as Uri;
            }
            set
            {
                this["PartnerService"] = value;
            }
        }

        [ConfigurationProperty("RewardsService", IsRequired = true)]
        public Uri RewardsService
        {
            get
            {
                return this["RewardsService"] as Uri;
            }
            set
            {
                this["RewardsService"] = value;
            }
        }

        [ConfigurationProperty("UDSProfileService", IsRequired = true)]
        public Uri UDSProfileService
        {
            get
            {
                return this["UDSProfileService"] as Uri;
            }
            set
            {
                this["UDSProfileService"] = value;
            }
        }

        [ConfigurationProperty("UDSGameDataService", IsRequired = true)]
        public Uri UDSGameDataService
        {
            get
            {
                return this["UDSGameDataService"] as Uri;
            }
            set
            {
                this["UDSGameDataService"] = value;
            }
        }

        [ConfigurationProperty("UDSPartnerMessageService", IsRequired = true)]
        public Uri UDSPartnerMessageService
        {
            get
            {
                return this["UDSPartnerMessageService"] as Uri;
            }
            set
            {
                this["UDSPartnerMessageService"] = value;
            }
        }

        [ConfigurationProperty("UDSPartnerProfileService", IsRequired = true)]
        public Uri UDSPartnerProfileService
        {
            get
            {
                return this["UDSPartnerProfileService"] as Uri;
            }
            set
            {
                this["UDSPartnerProfileService"] = value;
            }
        }

        [ConfigurationProperty("UDSPartnerGameDataService", IsRequired = true)]
        public Uri UDSPartnerGameDataService
        {
            get
            {
                return this["UDSPartnerGameDataService"] as Uri;
            }
            set
            {
                this["UDSPartnerGameDataService"] = value;
            }
        }

        [ConfigurationProperty("UDSPartnerPresenceService", IsRequired = true)]
        public Uri UDSPartnerPresenceService
        {
            get
            {
                return this["UDSPartnerPresenceService"] as Uri;
            }
            set
            {
                this["UDSPartnerPresenceService"] = value;
            }
        }

        [ConfigurationProperty("UDSPartnerFriendService", IsRequired = true)]
        public Uri UDSPartnerFriendService
        {
            get
            {
                return this["UDSPartnerFriendService"] as Uri;
            }
            set
            {
                this["UDSPartnerFriendService"] = value;
            }
        }

        /// <summary>
        /// Url pointing to an Avatar's publicly facing location
        /// </summary>
        [ConfigurationProperty("AvatarImage_GamerPicSmall", IsRequired = false)]
        public Uri AvatarImage_GamerPicSmall
        {
            get
            {
                return (Uri)this["AvatarImage_GamerPicSmall"];
            }
            set
            {
                this["AvatarImage_GamerPicSmall"] = value;
            }
        }

        /// <summary>
        /// Url pointing to an Avatar's publicly facing location
        /// </summary>
        [ConfigurationProperty("AvatarImage_GamerPicLarge", IsRequired = false)]
        public Uri AvatarImage_GamerPicLarge
        {
            get
            {
                return (Uri)this["AvatarImage_GamerPicLarge"];
            }
            set
            {
                this["AvatarImage_GamerPicLarge"] = value;
            }
        }

        /// <summary>
        /// Url pointing to an Avatar's publicly facing location
        /// </summary>
        [ConfigurationProperty("AvatarImage_GamerPicBody", IsRequired = false)]
        public Uri AvatarImage_GamerPicBody
        {
            get
            {
                return (Uri)this["AvatarImage_GamerPicBody"];
            }
            set
            {
                this["AvatarImage_GamerPicBody"] = value;
            }
        }

        [ConfigurationProperty("StsSettings", IsRequired = true)]
        public StsSettingsElement StsSettings
        {
            get
            {
                return (StsSettingsElement)this["StsSettings"];
            }
            set
            {
                this["StsSettings"] = value;
            }
        }

        [ConfigurationProperty("preExistingUsers", IsRequired = true)]
        public PreExistingUserElementCollection UserSettings
        {
            get
            {
                return (PreExistingUserElementCollection)this["preExistingUsers"];
            }
            set
            {
                this["preExistingUsers"] = value;
            }
        }

        [ConfigurationProperty("Titles", IsRequired = true)]
        public TitleElementCollection Titles
        {
            get
            {
                return (TitleElementCollection)this["Titles"];
            }
            set
            {
                this["Titles"] = value;
            }
        }

        [ConfigurationProperty("XuacsSettings", IsRequired = false)]
        public LiveN.Test.Framework.Configuration.XuacsSettingsElement XuacsSettings
        {
            get
            {
                return (LiveN.Test.Framework.Configuration.XuacsSettingsElement)this["XuacsSettings"];
            }
            set
            {
                this["XuacsSettings"] = value;
            }
        }

        [ConfigurationProperty("WindowsLiveIDSettings", IsRequired = true)]
        public LiveN.Test.Framework.Configuration.WindowsLiveIDSettingsElement WindowsLiveIDSettings
        {
            get
            {
                return (LiveN.Test.Framework.Configuration.WindowsLiveIDSettingsElement)this["WindowsLiveIDSettings"];
            }
            set
            {
                this["WindowsLiveIDSettings"] = value;
            }
        }

        [ConfigurationProperty("LiveLibSettings", IsRequired = false)]
        public LiveN.Test.Framework.Configuration.LiveLibSettingsElement LiveLibSettings
        {
            get
            {
                return (LiveN.Test.Framework.Configuration.LiveLibSettingsElement)this["LiveLibSettings"];
            }
            set
            {
                this["LiveLibSettings"] = value;
            }
        }

        [ConfigurationProperty("LiveConnectSettings", IsRequired = false)]
        public LiveN.Test.Framework.Configuration.LiveConnectSettingsElement LiveConnectSettings
        {
            get
            {
                return (LiveN.Test.Framework.Configuration.LiveConnectSettingsElement)this["LiveConnectSettings"];
            }
            set
            {
                this["LiveConnectSettings"] = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\FrameworkLib\CurrentEnvironmentSettings\TitleElementCollection.cs ===
using System;
using System.Configuration;

namespace LiveNew.Test
{
    public class TitleElementCollection : ConfigurationElementCollection
    {
        public TitleElementCollection()
        {
        }

        public override ConfigurationElementCollectionType CollectionType
        {
            get
            {
                return ConfigurationElementCollectionType.AddRemoveClearMap;
            }
        }

        protected override ConfigurationElement CreateNewElement()
        {
            return new TitleElement();
        }

        protected override object GetElementKey(ConfigurationElement element)
        {
            TitleElement title = element as TitleElement;

            return title.Id + title.Version + title.ConsoleType.ToString();
        }

        public TitleElement this[int index]
        {
            get
            {
                return (TitleElement)BaseGet(index);
            }
            set
            {
                if (BaseGet(index) != null)
                {
                    BaseRemoveAt(index);
                }

                BaseAdd(index, value);
            }
        }

        /// <summary>
        /// Get a Title element that fits the passed in requirements
        /// </summary>
        /// <param name="name">Name of the title</param>
        /// <param name="consoleType">Conole Type the title is valid on</param>
        /// <returns>Title element that machine the criteria. Else and exception is thrown</returns>
        /// <exception cref="System.Exception">Thrown if Title is not found</exception>
        public TitleElement Get(string name, LiveN.Test.ConsoleType consoleType)
        {
            TitleElement title;

            for (int i = 0; i < this.Count; i++)
            {
                title = this[i];

                if ((title.Name == name) && (title.ConsoleType == consoleType))
                {
                    return title;
                }
            }

            throw new Exception("Could not find a Title with the Name '" + name + "' and ConsoleType of '" + consoleType + "'. Values are case sensitive. Make sure this Title is propped to this environment and that the Title gets added to the list of available Titles.");
        }

        /// <summary>
        /// Get a random Title element
        /// </summary>
        public TitleElement GetRandom()
        {
            TitleElement title;
            Random rnd = new Random();

            title = this[rnd.Next(0, this.Count)];

            return title;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\FrameworkLib\CurrentEnvironmentSettings\StsSettingsElement.cs ===
﻿using System;
using System.Configuration;

namespace LiveNew.Test
{
    public class StsSettingsElement : ConfigurationElement
    {
        public StsSettingsElement()
        {
        }

        [ConfigurationProperty("WebStsUrl", IsRequired = false)]
        public string WebStsUrl
        {
            get
            {
                return (string)this["WebStsUrl"];
            }
            set
            {
                this["WebStsUrl"] = value;
            }
        }

        [ConfigurationProperty("WebStsLiveIdUrl", IsRequired = false)]
        public string WebStsLiveIdUrl
        {
            get
            {
                return (string)this["WebStsLiveIdUrl"];
            }
            set
            {
                this["WebStsLiveIdUrl"] = value;
            }
        }

        [ConfigurationProperty("StsUrl", IsRequired = true)]
        public string StsUrl
        {
            get
            {
                return (string)this["StsUrl"];
            }
            set
            {
                this["StsUrl"] = value;
            }
        }

        [ConfigurationProperty("PlatformType", IsRequired = true)]
        public string PlatformType
        {
            get
            {
                return (string)this["PlatformType"];
            }
            set
            {
                this["PlatformType"] = value;
            }
        }

        [ConfigurationProperty("ClientCertSubject", IsRequired = false)]
        public string ClientCertSubject
        {
            get
            {
                return (string)this["ClientCertSubject"];
            }
            set
            {
                this["ClientCertSubject"] = value;
            }
        }

        [ConfigurationProperty("ClientCertPath", IsRequired = false)]
        public string ClientCertPath
        {
            get
            {
                return (string)this["ClientCertPath"];
            }
            set
            {
                this["ClientCertPath"] = value;
            }
        }

        [ConfigurationProperty("ClientCertPassword", IsRequired = false)]
        public string ClientCertPassword
        {
            get
            {
                return (string)this["ClientCertPassword"];
            }
            set
            {
                this["ClientCertPassword"] = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\FrameworkLib\CurrentEnvironmentSettings\TitleElement.cs ===
﻿using System;
using System.Configuration;

using LiveN.Test;
using LiveN.Test.Framework;

namespace LiveNew.Test
{
    public class TitleElement : ConfigurationElement
    {
        public TitleElement()
        {
        }

        [ConfigurationProperty("Name", IsRequired = true)]
        public string Name
        {
            get
            {
                return (string)this["Name"];
            }
            set
            {
                this["Name"] = value;
            }
        }

        [ConfigurationProperty("ConsoleType", IsRequired = true)]
        public ConsoleType ConsoleType
        {
            get
            {
                return (ConsoleType)this["ConsoleType"];
            }
            set
            {
                this["ConsoleType"] = value;
            }
        }

        [ConfigurationProperty("Id", IsRequired = true)]
        public string Id
        {
            get
            {
                return (string)this["Id"];
            }
            set
            {
                this["Id"] = value;
            }
        }

        [ConfigurationProperty("Version", IsRequired = true)]
        public string Version
        {
            get
            {
                return (string)this["Version"];
            }
            set
            {
                this["Version"] = value;
            }
        }

        [ConfigurationProperty("ClientVersion", IsRequired = true)]
        public string ClientVersion
        {
            get
            {
                return (string)this["ClientVersion"];
            }
            set
            {
                this["ClientVersion"] = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\FrameworkLib\LiveN_NPDB\LiveN_NPDB.designer.cs ===
﻿#pragma warning disable 1591
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4952
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace LiveN.Test.Framework.LiveN_NPDB
{
	using System.Data.Linq;
	using System.Data.Linq.Mapping;
	using System.Data;
	using System.Collections.Generic;
	using System.Reflection;
	using System.Linq;
	using System.Linq.Expressions;
	using System.ComponentModel;
	using System;
	
	
	[System.Data.Linq.Mapping.DatabaseAttribute(Name="LIVEN_NPDB")]
	public partial class LiveN_NPDBDataContext : System.Data.Linq.DataContext
	{
		
		private static System.Data.Linq.Mapping.MappingSource mappingSource = new AttributeMappingSource();
		
    #region Extensibility Method Definitions
    partial void OnCreated();
    partial void Insertt_setting(t_setting instance);
    partial void Updatet_setting(t_setting instance);
    partial void Deletet_setting(t_setting instance);
    partial void Insertt_setting_override(t_setting_override instance);
    partial void Updatet_setting_override(t_setting_override instance);
    partial void Deletet_setting_override(t_setting_override instance);
    #endregion
		
		public LiveN_NPDBDataContext() : 
				base(global::LiveN.Test.Framework.Properties.Settings.Default.LIVEN_NPDBConnectionString, mappingSource)
		{
			OnCreated();
		}
		
		public LiveN_NPDBDataContext(string connection) : 
				base(connection, mappingSource)
		{
			OnCreated();
		}
		
		public LiveN_NPDBDataContext(System.Data.IDbConnection connection) : 
				base(connection, mappingSource)
		{
			OnCreated();
		}
		
		public LiveN_NPDBDataContext(string connection, System.Data.Linq.Mapping.MappingSource mappingSource) : 
				base(connection, mappingSource)
		{
			OnCreated();
		}
		
		public LiveN_NPDBDataContext(System.Data.IDbConnection connection, System.Data.Linq.Mapping.MappingSource mappingSource) : 
				base(connection, mappingSource)
		{
			OnCreated();
		}
		
		public System.Data.Linq.Table<t_setting> t_settings
		{
			get
			{
				return this.GetTable<t_setting>();
			}
		}
		
		public System.Data.Linq.Table<t_setting_override> t_setting_overrides
		{
			get
			{
				return this.GetTable<t_setting_override>();
			}
		}
	}
	
	[Table(Name="dbo.t_settings")]
	public partial class t_setting : INotifyPropertyChanging, INotifyPropertyChanged
	{
		
		private static PropertyChangingEventArgs emptyChangingEventArgs = new PropertyChangingEventArgs(String.Empty);
		
		private string _vc_setting;
		
		private string _vc_value;
		
		private EntitySet<t_setting_override> _t_setting_overrides;
		
    #region Extensibility Method Definitions
    partial void OnLoaded();
    partial void OnValidate(System.Data.Linq.ChangeAction action);
    partial void OnCreated();
    partial void Onvc_settingChanging(string value);
    partial void Onvc_settingChanged();
    partial void Onvc_valueChanging(string value);
    partial void Onvc_valueChanged();
    #endregion
		
		public t_setting()
		{
			this._t_setting_overrides = new EntitySet<t_setting_override>(new Action<t_setting_override>(this.attach_t_setting_overrides), new Action<t_setting_override>(this.detach_t_setting_overrides));
			OnCreated();
		}
		
		[Column(Storage="_vc_setting", DbType="NVarChar(64) NOT NULL", CanBeNull=false, IsPrimaryKey=true)]
		public string vc_setting
		{
			get
			{
				return this._vc_setting;
			}
			set
			{
				if ((this._vc_setting != value))
				{
					this.Onvc_settingChanging(value);
					this.SendPropertyChanging();
					this._vc_setting = value;
					this.SendPropertyChanged("vc_setting");
					this.Onvc_settingChanged();
				}
			}
		}
		
		[Column(Storage="_vc_value", DbType="NVarChar(3700) NOT NULL", CanBeNull=false)]
		public string vc_value
		{
			get
			{
				return this._vc_value;
			}
			set
			{
				if ((this._vc_value != value))
				{
					this.Onvc_valueChanging(value);
					this.SendPropertyChanging();
					this._vc_value = value;
					this.SendPropertyChanged("vc_value");
					this.Onvc_valueChanged();
				}
			}
		}
		
		[Association(Name="t_setting_t_setting_override", Storage="_t_setting_overrides", ThisKey="vc_setting", OtherKey="vc_setting")]
		public EntitySet<t_setting_override> t_setting_overrides
		{
			get
			{
				return this._t_setting_overrides;
			}
			set
			{
				this._t_setting_overrides.Assign(value);
			}
		}
		
		public event PropertyChangingEventHandler PropertyChanging;
		
		public event PropertyChangedEventHandler PropertyChanged;
		
		protected virtual void SendPropertyChanging()
		{
			if ((this.PropertyChanging != null))
			{
				this.PropertyChanging(this, emptyChangingEventArgs);
			}
		}
		
		protected virtual void SendPropertyChanged(String propertyName)
		{
			if ((this.PropertyChanged != null))
			{
				this.PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
			}
		}
		
		private void attach_t_setting_overrides(t_setting_override entity)
		{
			this.SendPropertyChanging();
			entity.t_setting = this;
		}
		
		private void detach_t_setting_overrides(t_setting_override entity)
		{
			this.SendPropertyChanging();
			entity.t_setting = null;
		}
	}
	
	[Table(Name="dbo.t_setting_overrides")]
	public partial class t_setting_override : INotifyPropertyChanging, INotifyPropertyChanged
	{
		
		private static PropertyChangingEventArgs emptyChangingEventArgs = new PropertyChangingEventArgs(String.Empty);
		
		private string _vc_environment;
		
		private string _vc_component;
		
		private int _i_site_id;
		
		private string _vc_server;
		
		private string _vc_setting;
		
		private string _vc_value;
		
		private EntityRef<t_setting> _t_setting;
		
    #region Extensibility Method Definitions
    partial void OnLoaded();
    partial void OnValidate(System.Data.Linq.ChangeAction action);
    partial void OnCreated();
    partial void Onvc_environmentChanging(string value);
    partial void Onvc_environmentChanged();
    partial void Onvc_componentChanging(string value);
    partial void Onvc_componentChanged();
    partial void Oni_site_idChanging(int value);
    partial void Oni_site_idChanged();
    partial void Onvc_serverChanging(string value);
    partial void Onvc_serverChanged();
    partial void Onvc_settingChanging(string value);
    partial void Onvc_settingChanged();
    partial void Onvc_valueChanging(string value);
    partial void Onvc_valueChanged();
    #endregion
		
		public t_setting_override()
		{
			this._t_setting = default(EntityRef<t_setting>);
			OnCreated();
		}
		
		[Column(Storage="_vc_environment", DbType="NVarChar(64) NOT NULL", CanBeNull=false, IsPrimaryKey=true)]
		public string vc_environment
		{
			get
			{
				return this._vc_environment;
			}
			set
			{
				if ((this._vc_environment != value))
				{
					this.Onvc_environmentChanging(value);
					this.SendPropertyChanging();
					this._vc_environment = value;
					this.SendPropertyChanged("vc_environment");
					this.Onvc_environmentChanged();
				}
			}
		}
		
		[Column(Storage="_vc_component", DbType="NVarChar(64) NOT NULL", CanBeNull=false, IsPrimaryKey=true)]
		public string vc_component
		{
			get
			{
				return this._vc_component;
			}
			set
			{
				if ((this._vc_component != value))
				{
					this.Onvc_componentChanging(value);
					this.SendPropertyChanging();
					this._vc_component = value;
					this.SendPropertyChanged("vc_component");
					this.Onvc_componentChanged();
				}
			}
		}
		
		[Column(Storage="_i_site_id", DbType="Int NOT NULL", IsPrimaryKey=true)]
		public int i_site_id
		{
			get
			{
				return this._i_site_id;
			}
			set
			{
				if ((this._i_site_id != value))
				{
					this.Oni_site_idChanging(value);
					this.SendPropertyChanging();
					this._i_site_id = value;
					this.SendPropertyChanged("i_site_id");
					this.Oni_site_idChanged();
				}
			}
		}
		
		[Column(Storage="_vc_server", DbType="NVarChar(64) NOT NULL", CanBeNull=false, IsPrimaryKey=true)]
		public string vc_server
		{
			get
			{
				return this._vc_server;
			}
			set
			{
				if ((this._vc_server != value))
				{
					this.Onvc_serverChanging(value);
					this.SendPropertyChanging();
					this._vc_server = value;
					this.SendPropertyChanged("vc_server");
					this.Onvc_serverChanged();
				}
			}
		}
		
		[Column(Storage="_vc_setting", DbType="NVarChar(64) NOT NULL", CanBeNull=false, IsPrimaryKey=true)]
		public string vc_setting
		{
			get
			{
				return this._vc_setting;
			}
			set
			{
				if ((this._vc_setting != value))
				{
					if (this._t_setting.HasLoadedOrAssignedValue)
					{
						throw new System.Data.Linq.ForeignKeyReferenceAlreadyHasValueException();
					}
					this.Onvc_settingChanging(value);
					this.SendPropertyChanging();
					this._vc_setting = value;
					this.SendPropertyChanged("vc_setting");
					this.Onvc_settingChanged();
				}
			}
		}
		
		[Column(Storage="_vc_value", DbType="NVarChar(3700) NOT NULL", CanBeNull=false)]
		public string vc_value
		{
			get
			{
				return this._vc_value;
			}
			set
			{
				if ((this._vc_value != value))
				{
					this.Onvc_valueChanging(value);
					this.SendPropertyChanging();
					this._vc_value = value;
					this.SendPropertyChanged("vc_value");
					this.Onvc_valueChanged();
				}
			}
		}
		
		[Association(Name="t_setting_t_setting_override", Storage="_t_setting", ThisKey="vc_setting", OtherKey="vc_setting", IsForeignKey=true)]
		public t_setting t_setting
		{
			get
			{
				return this._t_setting.Entity;
			}
			set
			{
				t_setting previousValue = this._t_setting.Entity;
				if (((previousValue != value) 
							|| (this._t_setting.HasLoadedOrAssignedValue == false)))
				{
					this.SendPropertyChanging();
					if ((previousValue != null))
					{
						this._t_setting.Entity = null;
						previousValue.t_setting_overrides.Remove(this);
					}
					this._t_setting.Entity = value;
					if ((value != null))
					{
						value.t_setting_overrides.Add(this);
						this._vc_setting = value.vc_setting;
					}
					else
					{
						this._vc_setting = default(string);
					}
					this.SendPropertyChanged("t_setting");
				}
			}
		}
		
		public event PropertyChangingEventHandler PropertyChanging;
		
		public event PropertyChangedEventHandler PropertyChanged;
		
		protected virtual void SendPropertyChanging()
		{
			if ((this.PropertyChanging != null))
			{
				this.PropertyChanging(this, emptyChangingEventArgs);
			}
		}
		
		protected virtual void SendPropertyChanged(String propertyName)
		{
			if ((this.PropertyChanged != null))
			{
				this.PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
			}
		}
	}
}
#pragma warning restore 1591
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\FrameworkLib\LiveN.Test.Authorization\AuthorizationCache.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Web;
using System.Web.Caching;
using System.Diagnostics;

using LiveN.Test.Common;
using LiveN.Test.Framework;

namespace LiveNew.Test
{
    /// <summary>
    /// Caches authorization information, on a per credential basis, to avoid repeat/superfluous authentications.
    /// Currently hardcoded to cache authorization data for 30 mins.
    /// </summary>
    public class AuthorizationCache
    {
        /// <summary>
        /// Authorization module used to perform all Authorization
        /// </summary>
        public readonly Authorization auth;

        private static HttpRuntime httpRuntime;
        private static object syncLock = new object();

        static AuthorizationCache()
        {
            // This ensures that the HttpRuntime cache is available,
            // irrespective of environment (console, web app, winform, etc.)
            if (httpRuntime == null)
            {
                lock (syncLock)
                {
                    if (httpRuntime == null)
                    {
                        httpRuntime = new HttpRuntime();
                    }
                }
            }

            try
            {
                // Attempting to import IDCRL environment registry keys...
                LiveID.ImportEnvironmentRegistryKeys();
            }
            catch 
            { 
            }

            try
            {
                // Attempting to clear IDCRL cache...
                LiveID.ClearIDCRLCache();
            }
            catch 
            { 
            }
        }

        public AuthorizationCache(string stsUrl, string clientCertSubject)
            : this(stsUrl, clientCertSubject, 30000)
        {
        }

        public AuthorizationCache(string stsUrl, string clientCertSubject, int timeout)
        {
            this.auth = new Authorization(stsUrl, clientCertSubject, timeout);
        }

        public string StsUrl
        {
            get
            {
                return auth.StsUrl;
            }
            set
            {
                auth.StsUrl = value;
            }
        }

        public string ClientCertificateSubject
        {
            get
            {
                return auth.ClientCertSubject;
            }
            set
            {
                auth.ClientCertSubject = value;
            }
        }

        public int Timeout
        {
            get
            {
                return auth.Timeout;
            }
            set
            {
                auth.Timeout = value;
            }
        }

        public static Cache AuthCache
        {
            get
            {
                return HttpRuntime.Cache;
            }
        }

        public string GetLoginTicket(string username, string password, string target, string policy, string environment)
        {
            ulong puid;

            return GetLoginTicket(username, password, target, policy, environment, out puid);
        }

        public string GetLoginTicket(string username, string password, string target, string policy, string environment, out ulong puid)
        {
            string key = GetWlidTicketKey(username, target, policy);
            string cachedValue = AuthCache.Get(key) as string;
            string loginTicket;

            puid = 0;   // NOTE: no way that I know of to get puid from WLID cookies (RPSTicketGenerator)...

            if (cachedValue == null)
            {
                try
                {
                    loginTicket = auth.GetLoginTicket(
                        username,
                        password,
                        target,
                        policy,
                        environment,
                        out puid);
                }
                catch
                {
                    Trace.TraceWarning("Unable to get RPS ticket with IDCRL; retrying using RpsTicketGenerator...");
                    
                    loginTicket = auth.GetRpsCompactTicket(username, password, target, policy, environment);
                }

                TimeSpan cacheTime;
                switch (policy.ToLower())
                {
                    // NOTE: these values were taken from the WLID RPS Server documentation, 
                    //       available on http://liveid (http://uebuilds:82/SDKS/Server-61_W4R3/webframe.html?Selecting_the_Authentication_Policy.html)
                    //       We effectively cache for 1/2 of the ticket time window, as WLID documentation.
                    case "lbi":

                        cacheTime = TimeSpan.FromHours(12);

                        break;

                    case "mbi":

                        cacheTime = TimeSpan.FromHours(4);
                        
                        break;

                    case "hbi":
                        
                        cacheTime = TimeSpan.FromMinutes(2);
                        
                        break;

                    default:
                        
                        cacheTime = TimeSpan.FromMinutes(30);

                        break;
                }

                string temp = loginTicket + "|" + puid.ToString();

                AddToCache(key, temp, cacheTime);
            }
            else
            {
                string[] parts = cachedValue.Split('|');

                loginTicket = parts[0];
                
                puid = ulong.Parse(parts[1]);
            }

            return loginTicket;
        }

        public string GetUserToken(string username, string password, string target, string policy, string environment, string platformType, string titleId, string titleVersion, string clientVersion)
        {
            string stsToken;
            ////string loginTicket = GetLoginTicket(username, password, target, policy, environment);
            string key; // = GetUserTokenKey(username, environment, platformType, titleId, titleVersion, clientVersion);

            string stdOut;
            string strErr;

            LiveN.Test.Common.FileIO.RedirectProcessOutput("./RPSGenerator/RPSGenerator.exe", new string[]{username, password}, out strErr, out stdOut);

            string loginTicket = stdOut.Substring(8, stdOut.Length -10); // GetLoginTicket(username, password, target, policy, environment);
            key = GetUserTokenKey(username, environment, platformType, titleId, titleVersion, clientVersion);


            stsToken = AuthCache.Get(key) as string;
            if (stsToken == null)
            {
                stsToken = auth.GetUserToken(
                    loginTicket,
                    platformType,
                    titleId,
                    titleVersion,
                    clientVersion);
               
                // Only cache if the token is a user token.  DON'T cache machine tokens...
                if (Authorization.IsUserSecurityToken(stsToken))
                {
                    TimeSpan timeWindow = Authorization.GetSamlTimeWindow(stsToken);
                    TimeSpan cacheTime = new TimeSpan(timeWindow.Ticks / 2);    //cache for 1/2 the time

                    AddToCache(key, stsToken, cacheTime);
                }
            }

            return stsToken;
        }

        /// <summary>
        /// Gets partner token by also getting the user token
        /// </summary>
        public string GetPartnerToken(string UserEmail, string password, string target, string policy, string environment, string platformType, string titleId, string titleVersion, string clientVersion, string audienceUri)
        {
            string userToken = string.Empty;
            string partnerToken = string.Empty;

            userToken = this.GetUserToken(
                                        UserEmail,
                                        password,
                                        target,
                                        policy,
                                        environment,
                                        platformType,
                                        titleId,
                                        titleVersion,
                                        clientVersion);

            partnerToken = this.GetPartnerToken(
                                        userToken,
                                        titleId,
                                        titleVersion,
                                        audienceUri);

            return partnerToken;
        }

        public string GetPartnerToken(string userToken, string titleId, string titleVersion, string audienceUri)
        {
            string partnerToken;
            string xuid = Authorization.GetXuid(userToken);
            string key = GetPartnerTokenKey(xuid, titleId, titleVersion, audienceUri);
            
            partnerToken = AuthCache.Get(key) as string;
            if (partnerToken == null)
            {
                partnerToken = auth.GetPartnerToken(userToken, titleId, titleVersion, audienceUri);
                TimeSpan timeWindow = Authorization.GetSamlTimeWindow(partnerToken);
                TimeSpan cacheTime = new TimeSpan(timeWindow.Ticks / 2);    //cache for 1/2 the time
                AddToCache(key, partnerToken, cacheTime);
            }

            return partnerToken;
        }

        public static void ClearCache()
        {
            lock (syncLock)
            {
                foreach (System.Collections.DictionaryEntry entry in AuthCache)
                {
                    AuthCache.Remove(entry.Key as string);
                }
            }
        }

        public static void AddToCache(string key, object item, TimeSpan cacheTime)
        {
            string existingItem = AuthCache.Get(key) as string;

            if (existingItem == null)
            {
                //take out a lock
                lock (syncLock)
                {
                    existingItem = AuthCache.Get(key) as string;

                    if (existingItem == null)   //see if someone beat us to it
                    {
                        AuthCache.Add(key, item, null, DateTime.Now.Add(cacheTime), Cache.NoSlidingExpiration, CacheItemPriority.Normal, null);
                    }
                }
            }
        }

        private static string GetWlidTicketKey(string userName, string target, string policy)
        {
            return (userName + target + policy).ToLower() + "WLID";
        }

        private static string GetPartnerTokenKey(string xuid, string titleId, string titleVersion, string audienceUri)
        {
            return (xuid + titleId + titleVersion + audienceUri).ToLower() + "PartnerToken";
        }

        private static string GetUserTokenKey(string username, string environment, string platformType, string titleId, string titleVersion, string clientVersion)
        {
            return (username + environment + platformType + titleId + titleVersion + clientVersion).ToLower() + "STS";
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\FrameworkLib\Web\UserAccountProxy.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Web.Services;
using System.Web.Services.Protocols;
using System.Xml.Serialization;

namespace LiveN.Test.Framework.Web
{

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("WsdlPlus", "1.0.0.0")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name = "UserAccountSoap", Namespace = "urn:schemas-xbox-com:user-account-data")]
    public partial class UserAccountProxy : System.Web.Services.Protocols.SoapHttpClientProtocol
    {

        /// <remarks/>
        public UserAccountProxy()
        {
            this.Url = "http://localhost:10050/xuacs/useraccount.asmx";
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/AcceptTermsOfService", RequestNamespace = "urn:schemas-xbox-com:user-account-data", ResponseNamespace = "urn:schemas-xbox-com:user-account-data", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public uint AcceptTermsOfService(ulong userPuid, [System.Xml.Serialization.XmlElementAttribute(DataType = "base64Binary")] byte[] signedOwnerPassportPuid, ServiceTypeEnum serviceType)
        {
            object[] results = this.Invoke("AcceptTermsOfService", new object[] {
                    userPuid,
                    signedOwnerPassportPuid,
                    serviceType});
            return ((uint)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/AddCreditCard", RequestNamespace = "urn:schemas-xbox-com:user-account-data", ResponseNamespace = "urn:schemas-xbox-com:user-account-data", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public AddCreditCardResults AddCreditCard(
                    ulong userPuid,
                    ulong machinePuid,
                    string addressStreet1,
                    string addressStreet2,
                    string addressCity,
                    string addressDistrict,
                    string addressState,
                    string addressPostalCode,
                    string phonePrefix,
                    string phoneNumber,
                    string phoneExtension,
                    byte cardType,
                    string accountHolderName,
                    string accountNumber,
                    string cardVerificationNumber,
                    string expirationDate)
        {
            object[] results = this.Invoke("AddCreditCard", new object[] {
                    userPuid,
                    machinePuid,
                    addressStreet1,
                    addressStreet2,
                    addressCity,
                    addressDistrict,
                    addressState,
                    addressPostalCode,
                    phonePrefix,
                    phoneNumber,
                    phoneExtension,
                    cardType,
                    accountHolderName,
                    accountNumber,
                    cardVerificationNumber,
                    expirationDate});
            return ((AddCreditCardResults)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/GetPointsBalance", RequestNamespace = "urn:schemas-xbox-com:user-account-data", ResponseNamespace = "urn:schemas-xbox-com:user-account-data", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public GetPointsBalanceResults GetPointsBalance(ulong userPuid)
        {
            object[] results = this.Invoke("GetPointsBalance", new object[] {
                    userPuid});
            return ((GetPointsBalanceResults)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/SignIn", RequestNamespace = "urn:schemas-xbox-com:user-account-data", ResponseNamespace = "urn:schemas-xbox-com:user-account-data", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public SignInResults SignIn()
        {
            object[] results = this.Invoke("SignIn", new object[0]);
            return ((SignInResults)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/CreateMobileAccount", RequestNamespace = "urn:schemas-xbox-com:user-account-data", ResponseNamespace = "urn:schemas-xbox-com:user-account-data", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public uint CreateMobileAccount(ulong userPuid, [System.Xml.Serialization.XmlElementAttribute(DataType = "base64Binary")] byte[] ownerPassportTicket, ulong machinePuid, string gamertag, byte countryId, ushort languageId, System.DateTime birthDate)
        {
            object[] results = this.Invoke("CreateMobileAccount", new object[] {
                    userPuid,
                    ownerPassportTicket,
                    machinePuid,
                    gamertag,
                    countryId,
                    languageId,
                    birthDate});
            return ((uint)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/GenerateGamertag", RequestNamespace = "urn:schemas-xbox-com:user-account-data", ResponseNamespace = "urn:schemas-xbox-com:user-account-data", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string GenerateGamertag(string seed, ulong machinePuid, GamertagSuggestionType gamertagSuggestionType)
        {
            object[] results = this.Invoke("GenerateGamertag", new object[] {
                    seed,
                    machinePuid,
                    gamertagSuggestionType});
            return ((string)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/GetPaymentInstruments", RequestNamespace = "urn:schemas-xbox-com:user-account-data", ResponseNamespace = "urn:schemas-xbox-com:user-account-data", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public GetPaymentInstrumentResults GetPaymentInstruments(ulong userPuid, ulong machinePuid)
        {
            object[] results = this.Invoke("GetPaymentInstruments", new object[] {
                    userPuid,
                    machinePuid});
            return ((GetPaymentInstrumentResults)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/GetSupportedCountries", RequestNamespace = "urn:schemas-xbox-com:user-account-data", ResponseNamespace = "urn:schemas-xbox-com:user-account-data", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public CountryInfo[] GetSupportedCountries(byte serviceType, byte clientType)
        {
            object[] results = this.Invoke("GetSupportedCountries", new object[] {
                    serviceType,
                    clientType});
            return ((CountryInfo[])(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/GetUserAuthorization", RequestNamespace = "urn:schemas-xbox-com:user-account-data", ResponseNamespace = "urn:schemas-xbox-com:user-account-data", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("GetUserAuthorizationInfo", IsNullable = true)]
        public GetUserAuthorizationInfo GetUserAuthorization(int serviceType, uint titleId)
        {
            object[] results = this.Invoke("GetUserAuthorization", new object[] {
                    serviceType,
                    titleId});
            return ((GetUserAuthorizationInfo)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/TestConnection", RequestNamespace = "urn:schemas-xbox-com:user-account-data", ResponseNamespace = "urn:schemas-xbox-com:user-account-data", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string TestConnection(string inputMessage)
        {
            object[] results = this.Invoke("TestConnection", new object[] {
                    inputMessage});
            return ((string)(results[0]));
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("WsdlPlus", "1.0.0.0")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "urn:schemas-xbox-com:user-account-data")]
    public enum ServiceTypeEnum
    {

        /// <remarks/>
        Unknown,

        /// <remarks/>
        XboxLive,

        /// <remarks/>
        Zune,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("WsdlPlus", "1.0.0.0")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "urn:schemas-xbox-com:user-account-data")]
    public partial class AddCreditCardResults
    {

        /// <remarks/>
        public string PaymentInstrumentId;
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("WsdlPlus", "1.0.0.0")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "urn:schemas-xbox-com:user-account-data")]
    public partial class SessionInfo
    {

        /// <remarks/>
        public string MusicNetAuthToken;

        /// <remarks/>
        public string GeoCountryCode;
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("WsdlPlus", "1.0.0.0")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "urn:schemas-xbox-com:user-account-data")]
    public partial class SubscriptionInfo
    {

        /// <remarks/>
        public ulong OfferId;

        /// <remarks/>
        public string BillingInstanceId;

        /// <remarks/>
        public string Status;

        /// <remarks/>
        public bool HasBillingViolation;

        /// <remarks/>
        public bool HasPendingCancel;

        /// <remarks/>
        public bool HasLapsed;

        /// <remarks/>
        public System.DateTime StartDate;

        /// <remarks/>
        public System.DateTime EndDate;

        /// <remarks/>
        public string RenewalOfferId;
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("WsdlPlus", "1.0.0.0")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "urn:schemas-xbox-com:user-account-data")]
    public partial class AccountInfo
    {

        /// <remarks/>
        public ulong XboxPuid;

        /// <remarks/>
        public ulong LivePuid;

        /// <remarks/>
        public string Tag;

        /// <remarks/>
        public string CountryCode;

        /// <remarks/>
        public string PostalCode;

        /// <remarks/>
        public bool ParentallyControlled;

        /// <remarks/>
        [System.Xml.Serialization.XmlArrayAttribute()]
        [System.Xml.Serialization.XmlArrayItemAttribute("Privilege", IsNullable = false)]
        public byte[] Privileges;

        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute("Service", IsNullable = false)]
        public uint[] Services;

        /// <remarks/>
        public uint PointsBalance;

        /// <remarks/>
        public bool IsLightweight;

        /// <remarks/>
        public uint CultureId;

        /// <remarks/>
        public uint ParentalControlGroupId;
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("WsdlPlus", "1.0.0.0")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "urn:schemas-xbox-com:user-account-data")]
    public partial class ErrorInfo
    {

        /// <remarks/>
        public uint HResult;

        /// <remarks/>
        public string Message;

        /// <remarks/>
        public bool TagChangeRequired;

        /// <remarks/>
        public bool AcceptedTermsOfService;

        /// <remarks/>
        public bool AccountSuspended;

        /// <remarks/>
        public bool BillingUnavailable;
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("WsdlPlus", "1.0.0.0")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "urn:schemas-xbox-com:user-account-data")]
    public partial class GetUserAuthorizationInfo
    {

        /// <remarks/>
        public ErrorInfo ErrorInfo;

        /// <remarks/>
        public AccountInfo AccountInfo;

        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute("Subscription")]
        public SubscriptionInfo[] SubscriptionInfo;

        /// <remarks/>
        public SessionInfo SessionInfo;
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("WsdlPlus", "1.0.0.0")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "urn:schemas-xbox-com:user-account-data")]
    public partial class CountryInfo
    {

        /// <remarks/>
        public byte CountryId;

        /// <remarks/>
        public string CountryCode;

        /// <remarks/>
        public byte User;

        /// <remarks/>
        public byte Billing;

        /// <remarks/>
        public bool AllowDirectDebit;

        /// <remarks/>
        public bool AllowPayPal;

        /// <remarks/>
        public bool RequireCCAgeVerification;
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("WsdlPlus", "1.0.0.0")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "urn:schemas-xbox-com:user-account-data")]
    public partial class BillingAgreementDetails
    {

        /// <remarks/>
        public string PayerEmail;

        /// <remarks/>
        public string BillingAgreementId;

        /// <remarks/>
        public string FirstName;

        /// <remarks/>
        public string LastName;

        /// <remarks/>
        public string MiddleName;

        /// <remarks/>
        public string PayerBusiness;

        /// <remarks/>
        public string PayerCountry;

        /// <remarks/>
        public string BillingAgreementDescription;
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("WsdlPlus", "1.0.0.0")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "urn:schemas-xbox-com:user-account-data")]
    public partial class PayPalPayinInfo
    {

        /// <remarks/>
        public BillingAgreementDetails BillingAgreementDetails;
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("WsdlPlus", "1.0.0.0")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "urn:schemas-xbox-com:user-account-data")]
    public partial class WholesaleInfo
    {

        /// <remarks/>
        public string AccountHolderName;

        /// <remarks/>
        public string ExternalReferenceId;

        /// <remarks/>
        public string WholesalePartner;

        /// <remarks/>
        public string EncryptedPassword;
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("WsdlPlus", "1.0.0.0")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "urn:schemas-xbox-com:user-account-data")]
    public partial class DirectDebitInfo
    {

        /// <remarks/>
        public string AccountHolderName;

        /// <remarks/>
        public string AccountNumber;

        /// <remarks/>
        public string BankCode;

        /// <remarks/>
        public string BranchCode;

        /// <remarks/>
        public string CheckDigits;
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("WsdlPlus", "1.0.0.0")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "urn:schemas-xbox-com:user-account-data")]
    public partial class CreditCardInfo
    {

        /// <remarks/>
        public byte CardType;

        /// <remarks/>
        public string AccountHolderName;

        /// <remarks/>
        public string AccountNumber;

        /// <remarks/>
        public string CcvNumber;

        /// <remarks/>
        public System.DateTime ExpirationDate;
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("WsdlPlus", "1.0.0.0")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "urn:schemas-xbox-com:user-account-data")]
    public partial class PhoneInfo
    {

        /// <remarks/>
        public string PhonePrefix;

        /// <remarks/>
        public string PhoneNumber;

        /// <remarks/>
        public string PhoneExtension;
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("WsdlPlus", "1.0.0.0")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "urn:schemas-xbox-com:user-account-data")]
    public partial class AddressInfo
    {

        /// <remarks/>
        public string Street1;

        /// <remarks/>
        public string Street2;

        /// <remarks/>
        public string City;

        /// <remarks/>
        public string District;

        /// <remarks/>
        public string State;

        /// <remarks/>
        public string PostalCode;
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("WsdlPlus", "1.0.0.0")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "urn:schemas-xbox-com:user-account-data")]
    public partial class PaymentInstrumentInfo
    {

        /// <remarks/>
        public string PaymentInstrumentId;

        /// <remarks/>
        public byte PaymentInstrumentType;

        /// <remarks/>
        public AddressInfo AddressInfo;

        /// <remarks/>
        public PhoneInfo PhoneInfo;

        /// <remarks/>
        public CreditCardInfo CreditCardInfo;

        /// <remarks/>
        public DirectDebitInfo DirectDebitInfo;

        /// <remarks/>
        public WholesaleInfo WholesaleInfo;

        /// <remarks/>
        public PayPalPayinInfo PayPalPayinInfo;
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("WsdlPlus", "1.0.0.0")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "urn:schemas-xbox-com:user-account-data")]
    public partial class GetPaymentInstrumentResults
    {

        /// <remarks/>
        public PaymentInstrumentInfo[] PaymentInstrumentInfos;
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("WsdlPlus", "1.0.0.0")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "urn:schemas-xbox-com:user-account-data")]
    public partial class SessionDetails
    {

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType = "base64Binary")]
        public byte[] SessionKey;

        /// <remarks/>
        public string MusicNetAuthToken;

        /// <remarks/>
        public string GeoCountryCode;
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("WsdlPlus", "1.0.0.0")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "urn:schemas-xbox-com:user-account-data")]
    public partial class SubscriptionDetails
    {

        /// <remarks/>
        public ulong XboxOfferId;

        /// <remarks/>
        public string BillingInstanceId;

        /// <remarks/>
        public string Status;

        /// <remarks/>
        public bool HasBillingViolation;

        /// <remarks/>
        public bool HasPendingCancel;

        /// <remarks/>
        public string MusicNetSku;

        /// <remarks/>
        public System.DateTime StartDate;

        /// <remarks/>
        public System.DateTime EndDate;

        /// <remarks/>
        public string RenewalXboxOfferId;
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("WsdlPlus", "1.0.0.0")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "urn:schemas-xbox-com:user-account-data")]
    public partial class AccountDetails
    {

        /// <remarks/>
        public ulong XboxPuid;

        /// <remarks/>
        public ulong LivePuid;

        /// <remarks/>
        public string Tag;

        /// <remarks/>
        public string PostalCode;

        /// <remarks/>
        public string CountryCode;

        /// <remarks/>
        public bool ParentallyControlled;

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType = "base64Binary")]
        public byte[] Privileges;

        /// <remarks/>
        public uint PointsBalance;

        /// <remarks/>
        public bool IsLightweight;
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("WsdlPlus", "1.0.0.0")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "urn:schemas-xbox-com:user-account-data")]
    public partial class ErrorDetails
    {

        /// <remarks/>
        public uint HResult;

        /// <remarks/>
        public string Message;

        /// <remarks/>
        public bool TagChangeRequired;

        /// <remarks/>
        public bool AcceptedTermsOfService;

        /// <remarks/>
        public bool AccountSuspended;

        /// <remarks/>
        public bool SubscriptionLapsed;

        /// <remarks/>
        public bool BillingUnavailable;
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("WsdlPlus", "1.0.0.0")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "urn:schemas-xbox-com:user-account-data")]
    public partial class SignInResults
    {

        /// <remarks/>
        public ErrorDetails ErrorInfo;

        /// <remarks/>
        public AccountDetails AccountInfo;

        /// <remarks/>
        public SubscriptionDetails SubscriptionInfo;

        /// <remarks/>
        public SessionDetails SessionInfo;
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("WsdlPlus", "1.0.0.0")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "urn:schemas-xbox-com:user-account-data")]
    public partial class GetPointsBalanceResults
    {

        /// <remarks/>
        public int PointsBalance;

        /// <remarks/>
        public bool AboveLowBalance;

        /// <remarks/>
        public byte DmpAccountStatus;
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("WsdlPlus", "1.0.0.0")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "urn:schemas-xbox-com:user-account-data")]
    public enum GamertagSuggestionType
    {

        /// <remarks/>
        NounAdjectiveSuggestion,

        /// <remarks/>
        SeedSuggestion,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\FrameworkLib\Properties\Settings.Designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4952
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace LiveN.Test.Framework.Properties {
    
    
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "9.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase {
        
        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
        
        public static Settings Default {
            get {
                return defaultInstance;
            }
        }
        
        [global::System.Configuration.ApplicationScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.SpecialSettingAttribute(global::System.Configuration.SpecialSetting.ConnectionString)]
        [global::System.Configuration.DefaultSettingValueAttribute("Data Source=srkalyan-test1;Initial Catalog=LIVEN_NPDB;Integrated Security=True")]
        public string LIVEN_NPDBConnectionString {
            get {
                return ((string)(this["LIVEN_NPDBConnectionString"]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\FrameworkLib\LiveN_NPDB\LiveN_NPDB.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace LiveN.Test.Framework.LiveN_NPDB
{
    /// <summary>
    /// LiveN_NPDB is the wrapper class for accessing the LiveN_NPDB
    /// </summary>
    public class LiveN_NPDB
    {
        /// <summary>
        /// Variable used for setting Linq database context per class
        /// </summary>
        private static LiveN_NPDBDataContext database;

        /// <summary>
        /// Constructor takes the target database server name as the parameter and initializes the Linq databse context to 'LIVEN_NPDB'.
        /// It uses default windows integrated aithentication to establish connection to the target database
        /// </summary>
        /// <param name="database_server">Target databse server to connect</param>

        public LiveN_NPDB(string database_server)
        {
           LiveN_NPDB.database = new LiveN_NPDBDataContext(String.Format("Data Source={0};Initial Catalog=LIVEN_NPDB;Integrated Security=True", database_server));
        }

        /**************************************************************************************************************************
        * We create a class for each table we want to access. Blow are the examples for tables - t_settings and t_settin_overrides.
        * NOTE: Make sure that the each table is mapped into LiveN_NPDB.dbml file before creating a wrapper class
         *  Example: For each table following 3 components should be defined/declared 
         *  For t_settings table we have following defined and declared
         *  - <t_settings_class> which is the wrapper class
         *  - <private t_settings_class pvt_t_settings> used by the public property
         *  - <public t_settings_class t_settings> is the public property
        **************************************************************************************************************************/

        /// <summary>       
        /// t_settings_class - is the class mapped for t_settings table and used for configuring services in production environment        
        /// </summary>
        public class t_settings_class
        {
            /// <summary>
            /// Returns the row that match the given input vc_setting name in table t_settings
            /// </summary>
            /// <param name="vc_setting_var"> vc_setting name</param>
            /// <returns>row that match the vc_setting name</returns>
            public row Generic(string vc_setting_var)
            {
                return new row(vc_setting_var);
            }

            /// <summary>
            /// Returns the row that match the given input vc_setting name in table t_settings
            /// </summary>
            /// <param name="vc_setting_var"> vc_setting name</param>
            /// <returns>row that match the vc_setting name</returns>
            public row this[string vc_setting_var]
            {
                get
                {
                    return new row(vc_setting_var);
                }
            }

            /// <summary>
            /// lest_LIVEnTraceLevel is used to configure the global trace levels that all services use.
            /// It can be one of the value that System.Diagnostic.TraceEventType can take
            /// </summary>
            public row lest_LIVEnTraceLevel
            {
                get
                {
                    return new row("lest_LIVEnTraceLevel");
                }
                set
                {
                    lest_LIVEnTraceLevel.vc_setting = "lest_LIVEnTraceLevel";
                    lest_LIVEnTraceLevel.vc_value = value.vc_value;
                }
            }

            /// <summary>
            /// lest_AvatarAssetFilterFileFullPath is used for setting the location of BlackListedAssets.xml for Avatar service
            /// </summary>
            public row lest_AvatarAssetFilterFileFullPath
            {
                get
                {
                    return new row("lest_AvatarAssetFilterFileFullPath");
                }
                set
                {
                    lest_AvatarAssetFilterFileFullPath.vc_setting = "lest_AvatarAssetFilterFileFullPath";
                    lest_AvatarAssetFilterFileFullPath.vc_value = value.vc_value;
                }
            }            
            
            /// <summary>
            /// row - This is the class that encapsulates each row in t_settings table
            /// </summary>            
            public class row
            {
                public row(string var_vc_setting)
                {
                    vc_setting = var_vc_setting;                       
                }

                private string pvt_vc_setting;
                public string vc_setting
                {
                    get { return pvt_vc_setting; }
                    set
                    {
                        IQueryable<t_setting> query =
                           from rec in LiveN_NPDB.database.t_settings
                           where rec.vc_setting == value
                           select rec;

                        if (query.Count() > 0)
                            pvt_vc_setting = value;
                        else
                            throw new Exception(String.Format("<vc_setting> value set <{0}> is invalid and verify the field name in the database", value));
                    }
                }

                public string vc_value
                {
                    get
                    {
                        if (string.IsNullOrEmpty(vc_setting))
                            throw new Exception("<vc_setting> should be set before getting value from <vc_value>");

                        IQueryable<t_setting> query =
                            from rec in LiveN_NPDB.database.t_settings
                            where rec.vc_setting == vc_setting
                            select rec;

                        return query.Single().vc_value;
                    }
                    set
                    {
                        if (string.IsNullOrEmpty(vc_setting))
                            throw new Exception("<vc_setting> should be set before setting value for <vc_value>");

                        IQueryable<t_setting> query =
                            from rec in LiveN_NPDB.database.t_settings
                            where rec.vc_setting == vc_setting
                            select rec;

                        query.Single().vc_value = value;

                        LiveN_NPDB.database.SubmitChanges();
                    }

                }
            }

           /// <summary>
           /// Insert give vc_settings, vc_value to t_settings table in LIVEN_NPDB
           /// </summary>
           /// <param name="vc_setting_arg">vc_setting</param>
           /// <param name="vc_value">vc_value</param>
           /// <returns>bool - true if Insert was successful or false if unsuccessful</returns>
           public bool Insert(string vc_setting_arg, string vc_value_str)
           {
               if(!string.IsNullOrEmpty(vc_setting_arg) && !string.IsNullOrEmpty(vc_value_str))
               {
                    t_setting var = new t_setting();
                    var.vc_setting= vc_setting_arg;
                    var.vc_value= vc_value_str;

                    database.t_settings.InsertOnSubmit(var);
                    database.SubmitChanges();

                    return true;
               }

               return false;
           }

           /// <summary>
           /// Delete row that match the given vc_settings in t_settings table in LIVEN_NPDB
           /// </summary>
           /// <param name="vc_setting_arg">vc_setting</param>
           /// <returns>bool - true if Delete was successful or false if unsuccessful</returns>
           public bool Delete(string vc_setting_arg)
           {
               if (!string.IsNullOrEmpty(vc_setting_arg))
               {                
                   // Query the database for the rows to be deleted.
                   var deleteRows =
                       from rec in LiveN_NPDB.database.t_settings
                       where rec.vc_setting == vc_setting_arg 
                       select rec;


                   foreach (var rec in deleteRows)
                   {
                       database.t_settings.DeleteOnSubmit(rec);
                   }

                   database.SubmitChanges();

                   return true;
               }

               return false;
           }
        }

        private t_settings_class pvt_t_settings;
        /// <summary>
        /// t_settings - Used for configuring the services in production environment
        /// </summary>
        /// <remarks> t_settings_class - is the class used for mapping t_settings table in LIVEN_NPDB </remarks>
        public t_settings_class t_settings
        {
           set
           {
               pvt_t_settings = value;
           }
           get
           {
               if (pvt_t_settings == null)
                   pvt_t_settings = new t_settings_class(); 
               return pvt_t_settings;
           }
        }       

        /// <summary>        
        /// t_setting_overrides_class - is the class mapped for t_setting_overdires table and used for configuring services in all test environments     
        /// </summary>
        public class t_setting_overrides_class
        {
            /// <summary>
            /// Returns the row that match the given input vc_setting name in table t_settings
            /// </summary>
            /// <param name="vc_setting_var"> vc_setting name</param>
            /// <returns>row that match the vc_setting name</returns>
            public row Generic(string vc_setting_var)
            {
                return new row(vc_setting_var);
            }

            /// <summary>
            /// Returns the row that match the given input vc_setting name in table t_settings
            /// </summary>
            /// <param name="vc_setting_var"> vc_setting name</param>
            /// <returns>row that match the vc_setting name</returns>
            public row this[string vc_setting_var]
            {
                get
                {
                    return new row(vc_setting_var);
                }
            }

            /// <summary>
            /// lest_LIVEnTraceLevel is used to configure the global trace levels that all services use.
            /// It can be one of the value that System.Diagnostic.TraceEventType can take
            /// </summary>
            public row lest_LIVEnTraceLevel
            {
                get
                {
                    return new row("lest_LIVEnTraceLevel");
                }
                set
                {
                    lest_LIVEnTraceLevel.vc_setting = "lest_LIVEnTraceLevel";
                    lest_LIVEnTraceLevel.vc_value = value.vc_value;
                }
            }
           
            /// <summary>
            /// lest_AvatarAssetFilterFileFullPath is used for setting the location of BlackListedAssets.xml for Avatar service
            /// </summary>
            public row lest_AvatarAssetFilterFileFullPath
            {
                get
                {
                    return new row("lest_AvatarAssetFilterFileFullPath");
                }
                set
                {
                    lest_AvatarAssetFilterFileFullPath.vc_setting = "lest_AvatarAssetFilterFileFullPath";
                    lest_AvatarAssetFilterFileFullPath.vc_value = value.vc_value;
                }
            }

            /// <summary>
            /// row - This is the class that encapsulates each row in t_setting_overrides table - we have mapped only 2 columns (vc_settings, vc_value) out of 4 here.
            /// </summary>            
            public class row
            {
                public row(string var_vc_setting)
                {
                    vc_setting = var_vc_setting;
                }

                private string pvt_vc_setting;
                public string vc_setting
                {
                    get { return pvt_vc_setting; }
                    set
                    {
                        IQueryable<t_setting_override> query =
                           from rec in LiveN_NPDB.database.t_setting_overrides
                           where rec.vc_setting == value
                           select rec;

                        if (query.Count() > 0)
                            pvt_vc_setting = value;
                        else
                            throw new Exception(String.Format("<vc_setting> value set <{0}> is invalid and verify the field name in the database", value));
                    }
                }

                public string vc_value
                {
                    get
                    {
                        if (string.IsNullOrEmpty(vc_setting))
                            throw new Exception("<vc_setting> should be set before getting value from <vc_value>");

                        IQueryable<t_setting_override> query =
                            from rec in LiveN_NPDB.database.t_setting_overrides
                            where rec.vc_setting == vc_setting
                            select rec;

                        return query.Single().vc_value;

                    }
                    set
                    {
                        if (string.IsNullOrEmpty(vc_setting))
                            throw new Exception("<vc_setting> should be set before setting value for <vc_value>");

                        IQueryable<t_setting_override> query =
                            from rec in LiveN_NPDB.database.t_setting_overrides
                            where rec.vc_setting == vc_setting
                            select rec;

                        query.Single().vc_value = value;

                        LiveN_NPDB.database.SubmitChanges();
                    }
                }
            }
        }

        private t_setting_overrides_class pvt_t_setting_overrides;
        /// <summary>
        /// t_setting_overrides - Used for configuring the services in all test environments
        /// </summary>
        /// <remarks> t_settings_class - is the class used for mapping t_settings table in LIVEN_NPDB </remarks>
        public t_setting_overrides_class t_setting_overrides
        {
           set
           {
               pvt_t_setting_overrides = value;
           }
           get
           {
               if (pvt_t_setting_overrides == null)
                   pvt_t_setting_overrides = new t_setting_overrides_class();
               return pvt_t_setting_overrides;
           }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\FrameworkLib\LiveN.Test.Authorization\Authorization.cs ===
﻿using System;
using System.Configuration;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Net.Security;
using System.Net.Sockets;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Xml;
using LiveN.Test.Common;
using LiveN.Test.Common.Web;
using LiveN.Test.Framework;
using LiveN.Test.Framework.Web;
using RPSTicketCreation;

namespace LiveNew.Test
{
    public class Authorization
    {
        public const string MachineTokenIdentifier = "XboxLive Machine security ticket";
        public const string UserTokenIdentifier = "XboxLive User security ticket";
        public const string PartnerTokenIdentifier = "XboxLive Partner security ticket";
        private const string SecurityTicketQuery = "/GetSecurityTicket?platformType={platformId}&titleId={titleId}&titleVersion={titleVersion}&clientVersion={clientVersion}&deviceId={deviceId}";
        private const string PartnerSecurityTicketQuery = "/GetPartnerSecurityTicket?xuid={xuid}&titleId={titleId}&titleVersion={titleVersion}&audience={audienceUri}";

        private static object certHackLock = new object();

        public Authorization(string stsUrl, string clientCertSubject)
            : this(stsUrl, clientCertSubject, 30000)
        {
        }

        public Authorization(string stsUrl, string clientCertSubject, int timeout)
        {
            this.StsUrl = stsUrl;
            this.ClientCertSubject = clientCertSubject;
            this.Timeout = timeout;
        }

        public string StsUrl
        {
            get;
            set;
        }

        public string ClientCertSubject
        {
            get;
            set;
        }

        public int Timeout
        {
            get;
            set;
        }

        public string GetLoginTicket(string username, string password, string target, string policy, string environment)
        {
            ulong puid;

            return GetLoginTicket(username, password, target, policy, environment, out puid);
        }

        /// <summary>
        /// Gets a login ticket using IDCRL.
        /// </summary>
        public string GetLoginTicket(string username, string password, string target, string policy, string environment, out ulong puid)
        {
            string loginTicket = null;

            try
            {
                TraceEx.TraceVerbose("Attempting to get a Windows LiveID login ticket for {0}/{1}, using IDCRL...", username, password);
                loginTicket = LiveID.GetLoginTicket(
                    username,
                    password,
                    target,
                    policy,
                    environment,
                    out puid);
            }
            catch (Exception e)
            {
                throw new ApplicationException(String.Format("Error getting Windows LiveID login ticket for {0}/{1}, using IDCRL.", username, password), e);
            }

            return loginTicket;
        }

        public string GetRpsCompactTicket(string username, string password, string target, string policy, string environment)
        {
            string loginTicket = null;

            try
            {
                TraceEx.TraceVerbose("Attempting to get a Windows LiveID login ticket for {0}/{1}, using RpsTicketGenerator...", username, password);
                RPSTicketGeneratorConfig rpsTicketGenConfig = new RPSTicketGeneratorConfig();
                rpsTicketGenConfig.AuthPolicy = policy;
                rpsTicketGenConfig.SiteURL = String.Format("http://{0}", target);
                rpsTicketGenConfig.PPEnv = environment.Equals("Production", StringComparison.InvariantCultureIgnoreCase) ? PassportEnvironment.Production : PassportEnvironment.INT;

                RPSTicketGenerator rpsTicketGenerator = new RPSTicketGenerator(rpsTicketGenConfig);
                loginTicket = "t=" + rpsTicketGenerator.GetRPSCompactTicket(username, password).Trim(new char[] { '"' });
            }
            catch (Exception e)
            {
                throw new ApplicationException(String.Format("Error getting Windows LiveID login ticket for {0}/{1}, with RpsTicketGenerator.", username, password), e);
            }

            return loginTicket;
        }

        /// <summary>
        /// Gets a user token from XBL platform STS service, given an RPS ticket.
        /// </summary>
        public string GetUserToken(string loginTicket, string platformId, string titleId, string titleVersion, string clientVersion)
        {
            X509Certificate2 cert = GetStsClientCertificate();
            string[] parts = cert.Subject.Split(':');
            //this is awesome... sometimes the device id is in the subject, other times the thumb is expected
            string deviceId = (parts.Length == 3) ? parts[2] : cert.Thumbprint;

            string queryString = SecurityTicketQuery;
            queryString = queryString.Replace("{platformId}", platformId);
            queryString = queryString.Replace("{titleId}", titleId);
            queryString = queryString.Replace("{titleVersion}", titleVersion);
            queryString = queryString.Replace("{clientVersion}", clientVersion);
            queryString = queryString.Replace("{deviceId}", deviceId);

            Uri fullUrl = new Uri(this.StsUrl + queryString);
            TraceEx.TraceVerbose("Sending the following STS request: {0}", fullUrl);

            BasicHttpRequest httpRequest = new BasicHttpRequest(fullUrl);
            httpRequest.BaseHttpRequest.Timeout = this.Timeout;
            httpRequest.BaseHttpRequest.Headers.Add("Authorization", "WLID1.0 " + loginTicket);

            if (fullUrl.Scheme.Equals(Uri.UriSchemeHttps, StringComparison.InvariantCultureIgnoreCase))
            {
                CertHack(cert, fullUrl);
                httpRequest.BaseHttpRequest.ClientCertificates.Add(cert);
            }

            string response = httpRequest.GetResponse();

            if (httpRequest.HttpResponse.StatusCode != HttpStatusCode.OK)
            {
                StringBuilder trace = new StringBuilder();

                if ((httpRequest.HttpResponse.StatusCode == HttpStatusCode.InternalServerError) &&
                    (response.Contains(".PolicyCheckTitleId("))
                   )
                {
                    // The passed in TitleId is not regestered
                    trace.Append("POSSBALE ISSUE: Invalid TitleId='" + titleId + "'. Make sure it's correct or register it on the appropriate enviernment.\r\n"); 
                }

                trace.AppendFormat("Error getting STS token:\r\n\r\nREQUEST:\r\n" + httpRequest.BaseHttpRequest.Method + "  " + httpRequest.BaseHttpRequest.Address.ToString() + " HTTP/" + httpRequest.BaseHttpRequest.ProtocolVersion.ToString());

                trace.AppendFormat("\r\n\r\nRESPONSE:\r\nHTTP/1.1 {0} {1}\r\n", (int)httpRequest.HttpResponse.StatusCode, httpRequest.HttpResponse.StatusCode);

                foreach (string key in httpRequest.HttpResponse.Headers.Keys)
                {
                    trace.AppendFormat("{0}: {1}\r\n", key, httpRequest.HttpResponse.Headers[key]);
                }

                if (!String.IsNullOrEmpty(response))
                {
                    trace.AppendFormat("\r\n{0}\r\n", response);
                }

                throw new Exception(trace.ToString());
            }

            string stsToken = GetSamlTokenXml(response);

            return stsToken;
        }

        /// <summary>
        /// Helper method - to get PartnerSecurityTicket using GetPartnerSecurityTicket from STS/sts.asmx.
        /// </summary>
        public string GetPartnerToken(string stsToken, string titleId, string titleVersion, string audienceUri)
        {
            string xuid = Authorization.GetXuid(stsToken);

            string queryString = PartnerSecurityTicketQuery;
            queryString = queryString.Replace("{xuid}", xuid);
            queryString = queryString.Replace("{titleId}", titleId);
            queryString = queryString.Replace("{titleVersion}", titleVersion);
            queryString = queryString.Replace("{audienceUri}", System.Web.HttpUtility.UrlEncode(audienceUri));

            Uri fullUrl = new Uri(this.StsUrl + queryString);
            TraceEx.TraceVerbose("Sending the following Partner Security Token request: {0}", fullUrl);

            BasicHttpRequest httpRequest = new BasicHttpRequest(fullUrl);
            httpRequest.BaseHttpRequest.Timeout = this.Timeout;
            httpRequest.BaseHttpRequest.Headers.Add("X-Authorization", "XBL1.0 x=" + stsToken);

            if (fullUrl.Scheme.Equals(Uri.UriSchemeHttps, StringComparison.InvariantCultureIgnoreCase))
            {
                X509Certificate2 cert = GetStsClientCertificate();
                CertHack(cert, fullUrl);
                httpRequest.BaseHttpRequest.ClientCertificates.Add(cert);
            }

            string response = httpRequest.GetResponse();
            if (httpRequest.HttpResponse.StatusCode != HttpStatusCode.OK)
            {
                StringBuilder trace = new StringBuilder();
                trace.AppendFormat("Error getting Partner Security Token token:\r\n\r\nHTTP/1.1 {0} {1}\r\n", (int)httpRequest.HttpResponse.StatusCode, httpRequest.HttpResponse.StatusCode);
                foreach (string key in httpRequest.HttpResponse.Headers.Keys)
                    trace.AppendFormat("{0}: {1}\r\n", key, httpRequest.HttpResponse.Headers[key]);

                if (!String.IsNullOrEmpty(response))
                    trace.AppendFormat("\r\n{0}\r\n", response);

                throw new Exception(trace.ToString());
            }

            string partnerTicket = GetSamlTokenXml(response);

            return partnerTicket;
        }

        private X509Certificate2 GetStsClientCertificate()
        {
            X509Certificate2 clientCert;
            X509Store localMachineMy = new X509Store(StoreName.My, StoreLocation.LocalMachine);

            try
            {
                localMachineMy.Open(OpenFlags.ReadOnly);
                X509Certificate2Collection certs = localMachineMy.Certificates.Find(
                    X509FindType.FindBySubjectName,
                    this.ClientCertSubject,
                    false);
                if (certs.Count == 0)
                {
                    throw new ApplicationException(String.Format("Unable to find STS client certificate, with subject CN={0}, required for authentication.  Verify that this certificate is installed to LOCAL_MACHINE\\My and that the private key is available.", this.ClientCertSubject));
                }
                else
                {
                    TraceEx.TraceVerbose("Verified that the expected STS client certificate is installed, CN={0}, with private key, in LOCAL_MACHINE\\My", this.ClientCertSubject);
                    clientCert = certs[0];
                }
            }
            catch (Exception e)
            {
                throw new ApplicationException("Error enumerating or adding required test certificate to LOCAL_MACHINE\\My.", e);
            }
            finally
            {
                if (localMachineMy != null)
                {
                    localMachineMy.Close();
                }
            }

            return clientCert;
        }

        public static void CertHack(X509Certificate cert, Uri stsPath)
        {
            lock (certHackLock)
            {
                RemoteCertificateValidationCallback rcvc = delegate(object sender, System.Security.Cryptography.X509Certificates.X509Certificate certificate,
                                               System.Security.Cryptography.X509Certificates.X509Chain chain,
                                               System.Net.Security.SslPolicyErrors sslPolicyErrors)
                {
                    return true;
                };

                try
                {
                    ServicePointManager.ServerCertificateValidationCallback += rcvc;

                    LocalCertificateSelectionCallback lcsc = delegate(object sender, string targetHost, X509CertificateCollection localCertificates,
                       X509Certificate remoteCertificate, string[] acceptableIssuers)
                    {
                        //reference to the local passed in certificate
                        return cert;
                    };

                    using (TcpClient tcp = new TcpClient(stsPath.Host, stsPath.Port))
                    {
                        using (SslStream ssl = new SslStream(tcp.GetStream(), false, rcvc, lcsc))
                        {
                            ssl.AuthenticateAsClient(stsPath.Host, new X509CertificateCollection(new X509Certificate[] { cert }),
                                System.Security.Authentication.SslProtocols.Default, false);

                            // create a request that we don't care about
                            BasicHttpRequest dummyReq = new BasicHttpRequest("https://" + stsPath.Host + ":" + stsPath.Port + "/sts/sts.asmx");

                            ssl.Write(dummyReq.ToBytes());
                            ssl.Flush();

                            // this read is necessary to force the client certificate
                            ssl.Read(new byte[1], 0, 1);
                            ssl.Close();
                        }
                    }
                }
                finally
                {
                    ServicePointManager.ServerCertificateValidationCallback -= rcvc;
                }
            }
        }

        public static string GetXuid(string stsToken)
        {
            try
            {
                XmlNode node;
                XmlDocumentEx xmlDoc = new XmlDocumentEx(stsToken, true);
                
                node = xmlDoc.SelectSingleNode("saml:Assertion/saml:AttributeStatement/saml:Attribute[@AttributeName='Xuid0']/saml:AttributeValue", xmlDoc.NamespaceManager);
                if (node == null)
                {
                    throw new ApplicationException("No xuid claim was found in the STS token! Most likely, this is a machine security token and not a user token. The Windows Live ID ticket used to generate this token most likely does NOT have an Xbox Live account. POSSABLE ISSUE: Make sure your tests and the services are pointing to the same Xblob.");
                }

                return node.InnerText;
            }
            catch (XmlException e)
            {
                throw new ApplicationException(String.Format("Invalid STS token: {0}", e.Message), e);
            }
        }

        public static string GetPuid(string stsToken)
        {
            try
            {
                XmlNode node;
                XmlDocumentEx xmlDoc = new XmlDocumentEx(stsToken, true);
                
                node = xmlDoc.SelectSingleNode("saml:Assertion/saml:AttributeStatement/saml:Attribute[@AttributeName='Puid0']/saml:AttributeValue", xmlDoc.NamespaceManager);
                if (node == null)
                {
                    throw new ApplicationException("No Puid claim was found in the STS token! Most likely, this is a user security token and not a machine token.");
                }

                return node.InnerText;
            }
            catch (XmlException e)
            {
                throw new ApplicationException(String.Format("Invalid STS token: {0}", e.Message), e);
            }
        }

        public static string GetMachineId(string stsToken)
        {
            try
            {
                XmlNode node;
                XmlDocumentEx xmlDoc = new XmlDocumentEx(stsToken, true);
                                    
                node = xmlDoc.SelectSingleNode("saml:Assertion/saml:AttributeStatement/saml:Attribute[@AttributeName='MachineID']/saml:AttributeValue", xmlDoc.NamespaceManager);
                if (node == null)
                {
                    throw new ApplicationException("No machine ID claim was found in the STS token! Most likely, this is a user security token and not a machine token.");
                }

                return node.InnerText;
            }
            catch (XmlException e)
            {
                throw new ApplicationException(String.Format("Invalid STS token: {0}", e.Message), e);
            }
        }

        public static bool IsUserSecurityToken(string stsToken)
        {
            string xuid;

            return IsUserSecurityToken(stsToken, out xuid);
        }

        public static bool IsUserSecurityToken(string stsToken, out string xuid)
        {
            try
            {
                XmlNode node;
                XmlDocumentEx xmlDoc = new XmlDocumentEx(stsToken, true);

                xuid = null;

                node = xmlDoc.SelectSingleNode("saml:Assertion/saml:AttributeStatement/saml:Subject/saml:NameIdentifier", xmlDoc.NamespaceManager);
                if (node == null)
                {
                    throw new ApplicationException("No Subject Name Identifier was found in the STS token!");
                }

                if (node.InnerText.Equals(UserTokenIdentifier, StringComparison.InvariantCultureIgnoreCase))
                {
                    xuid = GetXuid(stsToken);
                    return true;
                }
            }
            catch (XmlException e)
            {
                throw new ApplicationException(String.Format("Invalid STS token: {0}", e.Message), e);
            }

            return false;
        }

        public static TimeSpan GetSamlTimeWindow(string stsToken)
        {
            try
            {
                XmlNode node;
                XmlDocumentEx xmlDoc = new XmlDocumentEx(stsToken, true);
                
                node = xmlDoc.SelectSingleNode("saml:Assertion/saml:Conditions/@NotBefore", xmlDoc.NamespaceManager);
                if (node == null)
                {
                    throw new ApplicationException("No NotBefore condition was found in the STS token!");
                }

                DateTime notBefore = DateTime.Parse(node.InnerText);

                node = xmlDoc.SelectSingleNode("saml:Assertion/saml:Conditions/@NotOnOrAfter", xmlDoc.NamespaceManager);
                if (node == null)
                {
                    throw new ApplicationException("No NotOnOrAfter condition was found in the STS token!");
                }

                DateTime notAfter = DateTime.Parse(node.InnerText);

                return notAfter.Subtract(notBefore);
            }
            catch (XmlException e)
            {
                throw new ApplicationException(String.Format("Invalid STS token: {0}", e.Message), e);
            }
        }

        /// <summary>
        /// Helper method - to parse STSServiceResponse from GetSecurityTicket.
        /// </summary>
        private static string GetSamlTokenXml(string stsServiceResponse)
        {
            try
            {
                XmlDocument xmlDoc = new XmlDocument();
                xmlDoc.LoadXml(stsServiceResponse);

                //returning the first child of the root document element
                return xmlDoc.DocumentElement.FirstChild.Value;
            }
            catch (Exception ex)
            {
                throw new ApplicationException("The STS token was invalid: " + ex.Message, ex);
            }
        }

        public static X509Certificate2 InstallClientCertificate(string testCertPath, string thumbprint, string password, string nameOfServiceCertIsUsedFor)
        {
            X509Certificate2Collection certs;
            X509Certificate2 clientCert = null;
            X509Store localMachineMy = new X509Store(StoreName.My, StoreLocation.LocalMachine);

            try
            {
                localMachineMy.Open(OpenFlags.ReadWrite);
                
                certs = localMachineMy.Certificates.Find(X509FindType.FindByThumbprint, thumbprint, false);
                if (certs.Count == 0)
                {
                    Trace.TraceInformation("Required {0} client certificate with thumbprint = {1} is not found; installing {2} to LOCAL_MACHINE\\My", nameOfServiceCertIsUsedFor, thumbprint, testCertPath);
                    if (!File.Exists(testCertPath))
                    {
                        throw new ApplicationException(String.Format("Unable to find {0} client certificate, required for authentication, at: {1}", nameOfServiceCertIsUsedFor, testCertPath));
                    }

                    X509Certificate2 testCert = new X509Certificate2(testCertPath, password, X509KeyStorageFlags.MachineKeySet | X509KeyStorageFlags.PersistKeySet);
                    localMachineMy.Add(testCert);
                    clientCert = testCert;

                    Trace.TraceInformation("Successfully installed " + nameOfServiceCertIsUsedFor + " client certificate.");
                }
                else
                {
                    Trace.TraceInformation("Verified that the expected " + nameOfServiceCertIsUsedFor + " client certificate with thumbprint = {0} is installed, with private key, in LOCAL_MACHINE\\My", ConfigurationManager.AppSettings["PFEClientCertThumbprint"]);
                    clientCert = certs[0];
                }
            }
            catch (Exception e)
            {
                throw new ApplicationException("Error enumerating or adding required " + nameOfServiceCertIsUsedFor + " test certificate to LOCAL_MACHINE\\My.", e);
            }
            finally
            {
                if (localMachineMy != null)
                {
                    localMachineMy.Close();
                }
            }

            return clientCert;
        }

        public static X509Certificate2 InstallClientCertificateBySubject(string testCertPath, string subject, string password, string nameOfServiceCertIsUsedFor)
        {
            X509Certificate2Collection certs;
            X509Certificate2 clientCert = null;
            X509Store localMachineMy = new X509Store(StoreName.My, StoreLocation.LocalMachine);

            try
            {
                localMachineMy.Open(OpenFlags.ReadWrite);
                
                certs = localMachineMy.Certificates.Find(X509FindType.FindBySubjectName, subject, false);
                if (certs.Count == 0 || !certs[0].HasPrivateKey)
                {
                    Trace.TraceInformation("Required {0} client certificate with subject = {1} is not found; installing CN={2} to LOCAL_MACHINE\\My", nameOfServiceCertIsUsedFor, subject, testCertPath);
                    if (!File.Exists(testCertPath))
                    {
                        throw new ApplicationException(String.Format("Unable to find {0} client certificate, required for authentication, at: {1}", nameOfServiceCertIsUsedFor, testCertPath));
                    }

                    X509Certificate2 testCert = new X509Certificate2(testCertPath, password, X509KeyStorageFlags.MachineKeySet | X509KeyStorageFlags.PersistKeySet);
                    localMachineMy.Add(testCert);
                    clientCert = testCert;

                    Trace.TraceInformation("Successfully installed " + nameOfServiceCertIsUsedFor + " client certificate.");
                }
                else
                {
                    if (certs.Count > 1)
                    {
                        Trace.TraceWarning("WARNING: more than one client cert was found matching subejct '{0}'; the first found occurance will be used.", subject);
                    }

                    if (!certs[0].HasPrivateKey)
                    {
                        throw new ApplicationException("No private key is available for the specified client cert and is required for mutual SSL.  Make sure the application is running with administrator rights.");
                    }

                    TraceEx.TraceVerbose("Verified that the expected " + nameOfServiceCertIsUsedFor + " client certificate with subject CN={0} is installed, with private key, in LOCAL_MACHINE\\My", subject);
                    clientCert = certs[0];
                }
            }
            catch (Exception e)
            {
                throw new ApplicationException(String.Format("Error finding or installing required {0} client certificate to LOCAL_MACHINE\\My; {1}", nameOfServiceCertIsUsedFor, e.Message), e);
            }
            finally
            {
                if (localMachineMy != null)
                {
                    localMachineMy.Close();
                }
            }

            return clientCert;
        }

        public static string GetGamertag(string stsToken)
        {
            try
            {
                XmlNode node;
                XmlDocumentEx xmlDoc = new XmlDocumentEx(stsToken, true);
                
                node = xmlDoc.SelectSingleNode("saml:Assertion/saml:AttributeStatement/saml:Attribute[@AttributeName='Gamertag0']/saml:AttributeValue", xmlDoc.NamespaceManager);
                if (node == null)
                {
                    throw new ApplicationException("No Gamertag was found in the STS token! Most likely, this is a machine security token and not a user token. The Windows Live ID ticket used to generate this token most likely does NOT have an Xbox Live account.");
                }

                return node.InnerText;
            }
            catch (XmlException e)
            {
                throw new ApplicationException(String.Format("Invalid STS token: {0}", e.Message), e);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\FrameworkLib\Web\UserAccountProxyEx.cs ===
﻿using System;
using System.Net;
using System.Security.Cryptography.X509Certificates;
using System.Net.Sockets;
using System.Net.Security;
using System.Diagnostics;
using System.IO;

using LiveN.Test.Common;
using LiveN.Test.Framework.Configuration;

namespace LiveN.Test.Framework.Web
{
    /// <summary>
    /// 
    /// </summary>
    public partial class UserAccountProxy : System.Web.Services.Protocols.SoapHttpClientProtocol
    {
        /// <summary>
        /// Xbox Auth header
        /// </summary>
        public const string AuthHeader = "X-Authorization";

        /// <summary>
        /// WLID Auth header
        /// </summary>
        public const string AuthHeaderWindowsLive = "Authorization";

        /// <summary>
        /// XBL header
        /// </summary>
        public const string XblHeader = "XBL1.0 x=";

        /// <summary>
        /// Live ID header
        /// </summary>
        public const string LiveIDHeader = "WLID1.0 ";

        /// <summary>
        /// Sets STS Token.
        /// </summary>
        public string StsToken
        {
            get;
            set;
        }

        /// <summary>
        /// Sets RPS ticket
        /// </summary>
        public string RpsTicket
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string ClientCertificateSubject
        {
            get;
            set;
        }

        /// <summary>
        /// This method overrides the default GetWebRequest and adds the LiveID
        /// token to the HTTP request.
        /// </summary>
        /// <param name="uri">Uri of the request.</param>
        /// <returns>A Web request.</returns>
        protected override WebRequest GetWebRequest(Uri uri)
        {
            HttpWebRequest request = (HttpWebRequest)base.GetWebRequest(uri);

            // Set the right request based on HTTP or HTTPS                
            if (uri.Scheme == Uri.UriSchemeHttps)
            {
                X509Certificate2 clientCert = GetXuacsClientCertificate();
                request.ClientCertificates.Add(clientCert);
                LiveN.Test.Framework.Authorization.Authorization.CertHack(clientCert, uri);
            }

            if (!String.IsNullOrEmpty(this.RpsTicket))
            {
                // Add authorization header as Authorization: WLID1.0 t=”<RPS Token>”
                request.Headers[AuthHeaderWindowsLive] = LiveIDHeader + this.RpsTicket;
            }

            // Add authorization header as Authorization: XBL1.0 t=”<STS Token>”
            if (!String.IsNullOrEmpty(this.StsToken))
            {
                request.Headers[AuthHeader] = XblHeader + this.StsToken;
            }

            return request;
        }

        /// <summary>
        /// 
        /// </summary>
        private X509Certificate2 GetXuacsClientCertificate()
        {
            if (String.IsNullOrEmpty(this.ClientCertificateSubject))
                throw new ApplicationException("UserAccountProxy.ClientCertificateSubject is empty or null; a valid x509 certificate subject is required to attach to the request.");

            X509Certificate2 clientCert;
            X509Store localMachineMy = new X509Store(StoreName.My, StoreLocation.LocalMachine);

            try
            {
                localMachineMy.Open(OpenFlags.ReadOnly);
                X509Certificate2Collection certs = localMachineMy.Certificates.Find(
                    X509FindType.FindBySubjectName,
                    this.ClientCertificateSubject,
                    false);
                if (certs.Count == 0)
                {
                    throw new ApplicationException(String.Format("Unable to find Xuacs client certificate, with subject CN={0}, required for authentication.  Verify that this certificate is installed to LOCAL_MACHINE\\My and that the private key is available.", this.ClientCertificateSubject));
                }
                else
                {
                    TraceEx.TraceVerbose("Verified that the expected Xuacs client certificate, CN={0}, is installed, with private key, in LOCAL_MACHINE\\My", this.ClientCertificateSubject);
                    clientCert = certs[0];
                }
            }
            catch (Exception e)
            {
                throw new ApplicationException("Error enumerating or adding required test certificate to LOCAL_MACHINE\\My.", e);
            }
            finally
            {
                if (localMachineMy != null)
                    localMachineMy.Close();
            }

            return clientCert;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\FrameworkLib\Web\XboxWcfService.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using LiveN.Test.Common.Web;

namespace LiveN.Test.Framework.Web
{
    /// <summary>
    /// 
    /// </summary>
    public class XboxWcfService: RestRequest
    {
        public const string LocaleHeader = "X-Locale";
        public const string AuthorizationHeader = "X-Authorization";
        public const string PartnerAuthorizationHeader = "X-PartnerAuthorization";
        public const string PlatformTypeHeader = "X-Platform-Type";
        public const string StsTokenPreamble = "XBL1.0 x=";

        /// <summary>
        /// 
        /// </summary>
        /// <param name="baseUri"></param>
        public XboxWcfService(string baseUri)
        {
            this.BaseUri = baseUri;
        }

        /// <summary>
        /// 
        /// </summary>
        public string BaseUri
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string Locale
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string PlatformType
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string UserAuthorizationToken
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string PartnerAuthorizationToken
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="locale"></param>
        /// <returns></returns>
        public override Dictionary<string, string> GetHttpHeaders()
        {
            Dictionary<string, string> httpHeaders = base.GetHttpHeaders();
            if (!String.IsNullOrEmpty(this.Locale))
                httpHeaders.Add(LocaleHeader, this.Locale);
            if (!String.IsNullOrEmpty(this.PlatformType))
                httpHeaders.Add(PlatformTypeHeader, this.PlatformType);
            if (!String.IsNullOrEmpty(this.UserAuthorizationToken))
                httpHeaders.Add(AuthorizationHeader, StsTokenPreamble + this.UserAuthorizationToken);
            if (!String.IsNullOrEmpty(this.PartnerAuthorizationToken))
                httpHeaders.Add(PartnerAuthorizationHeader, StsTokenPreamble + this.PartnerAuthorizationToken);
            return httpHeaders;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient\HttpClientCommon.cs ===
﻿namespace LiveN.Test
{
    /// <summary>
    /// Supported Http Methods
    /// </summary>
    public enum HttpMethods
    {
        GET,
        POST
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient\HttpClientHeaders.cs ===
﻿//---------------------------------------------------------------------
//
// Description:
//  Generic class to handle url request
//
//
// Copyright (C) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------
namespace LiveN.Test
{
    using System;
    using System.Net;

    /// <summary>
    /// Contains all the headers that are contained within a standard http request
    /// </summary>
    public class HttpClientHeaders : WebHeaderCollection
    {
        /// <summary>
        /// Header Collection to add or pull the header information from
        /// </summary>
        internal WebHeaderCollection headers
        {
            get
            {
                return (WebHeaderCollection)this;
            }
        }

        /// <summary>
        /// Create a HttpClientHeaders
        /// </summary>
        public HttpClientHeaders()
        {
        }

        /// <summary>
        /// Create a HttpClientHeaders
        /// </summary>
        /// <param name="headers">Header Collection to add or pull the header information from</param>
        public HttpClientHeaders(WebHeaderCollection headers)
        {
            if (headers == null)
            {
                throw new ArgumentNullException("headers");
            }

            foreach (string key in headers.Keys)
            {
                this.Add(key, headers[key]);
            }
        }

        /// <summary>
        /// Gets or sets the header value used to determine what kind of responses type you accept. Example: */*
        /// </summary>
        public string Accept
        {
            get
            {
                return this.headers[HttpRequestHeader.Accept];
            }

            set
            {
                this.headers[HttpRequestHeader.Accept] = value;
            }
        }

        /// <summary>
        /// Gets or sets the header value used to determine how to treat the Connection
        /// </summary>
        public string Connection
        {
            get
            {
                return this.headers[HttpRequestHeader.Connection];
            }

            set
            {
                this.headers[HttpRequestHeader.Connection] = value;
            }
        }

        /// <summary>
        /// Gets or sets the header value used to determine what the Content Type that's contained within the request
        /// </summary>
        public string ContentType
        {
            get
            {
                return this.headers[HttpRequestHeader.ContentType];
            }

            set
            {
                this.headers[HttpRequestHeader.ContentType] = value;
            }
        }

        /// <summary>
        /// Gets or sets the header value used to determine what kind of responses encoding you accept. Example: gzip, deflate
        /// </summary>
        public string AcceptEncoding
        {
            get
            {
                return this.headers["Accept-Encoding"];
            }

            set
            {
                this.headers["Accept-Encoding"] = value;
            }
        }

        /// <summary>
        /// Gets or sets the header value used to determine what kind of responses language you accept. Example: en-US
        /// </summary>
        public string AcceptLanguage
        {
            get
            {
                return this.headers["Accept-Language"];
            }

            set
            {
                this.headers["Accept-Language"] = value;
            }
        }

        /// <summary>
        /// Gets or sets the header value used to determine what kind of browser you are. Example: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; InfoPath.3; MS-RTC LM 8)
        /// </summary>
        public string UserAgent
        {
            get
            {
                return this.headers[HttpRequestHeader.UserAgent];
            }

            set
            {
                this.headers[HttpRequestHeader.UserAgent] = value;
            }
        }

        /// <summary>
        /// Gets or sets the header value used to determine where the requesting page came from. Example: http://www.bing.com
        /// </summary>
        public string Referer
        {
            get
            {
                return this.headers[HttpRequestHeader.Referer];
            }

            set
            {
                this.headers[HttpRequestHeader.Referer] = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient\HttpClientRequest.cs ===
﻿//---------------------------------------------------------------------
// Description:
//  Generic class to handle url request
//
// Copyright (C) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------
namespace LiveN.Test
{
    using System;
    using System.IO;
    using System.Net;

    /// <summary>
    /// Class within HttpClientRequest that holds all the code to make a generic request
    /// </summary>
    public class HttpClientRequest
    {
        /// <summary>
        /// Constructor for HttpClientRequest
        /// </summary>
        public HttpClientRequest()
        {
            QueryBuilder = new QueryStringBuilder();
            RequestUriBuilderBase = new UriBuilder();

            Headers = new HttpClientHeaders();
            Headers.Connection = "Keep-Alive";
            Headers.ContentType = "application/x-www-form-urlencoded";

            // Required in order to have the headers added to the request
            HeaderCollection = Headers.headers; 

            Cookies = new CookieCollection();

            Method = HttpMethods.GET;
            Content = null;
        }

        /// <summary>
        /// Uri Builder
        /// </summary>
        protected UriBuilder RequestUriBuilderBase 
        { 
            get; 
            set; 
        }
        /// <summary>
        /// Gets or set the query string parameter and values that may or  
        /// may not be exposed in the request object.
        /// </summary>
        public virtual QueryStringBuilder QueryBuilder
        {
            get;
            protected set;
        }

        /// <summary>
        /// Get or set the header content
        /// </summary>
        public virtual WebHeaderCollection HeaderCollection
        {
            get;
            protected set;
        }

        /// <summary>
        /// Http Header collection
        /// </summary>
        /// <remarks>This should be override using the 'new' in order to create a custom exposed headers. But if you do, be sure to set this.HeaderCollection with your instance of the </remarks>
        public HttpClientHeaders Headers 
        { 
            get; 
            set; 
        }

        /// <summary>
        /// Http method
        /// </summary>
        public HttpMethods Method 
        { 
            get; 
            set; 
        }

        /// <summary>
        /// Get or set the cook content
        /// </summary>
        /// <remarks>This should be override in order to create a custom exposed headers. </remarks>
        public virtual CookieCollection Cookies 
        { 
            get; 
            set; 
        }

        /// <summary>
        /// Content object storing the body of the http post body
        /// </summary>
        public virtual byte[] Content 
        { 
            get; 
            set; 
        }

        /// <summary>
        /// Gets or sets the Domain Name System (DNS) host name or IP address of a server. Example: localhost
        /// </summary>
        public string Host
        {
            get
            {
                return RequestUriBuilder.Host;
            }
            set
            {
                RequestUriBuilder.Host = value;
            }
        }

        /// <summary>
        /// Gets or sets any query information included in the URI. Example: parm1=value1&parm2=value2
        /// </summary>
        public string Query
        {
            get
            {
                return this.QueryBuilder.Value;
            }
            set
            {
                this.QueryBuilder.Value = value;
            }
        }

        /// <summary>
        /// Gets or sets the path to the resource referenced by the URI. Example: /v1/service/
        /// </summary>
        public string Path
        {
            get
            {
                return RequestUriBuilder.Path;
            }
            set
            {
                RequestUriBuilder.Path = value;
            }
        }

        /// <summary>
        /// Gets or sets the port number of the URI.. Example: 8080
        /// </summary>
        public int Port
        {
            get
            {
                return RequestUriBuilder.Port;
            }
            set
            {
                RequestUriBuilder.Port = value;

                if (RequestUriBuilder.Port == 443)
                {
                    RequestUriBuilder.Scheme = "https";
                }
                else
                {
                    RequestUriBuilder.Scheme = "http";
                }
            }
        }

        /// <summary>
        /// Returns the url builder use to compose the rest of the url
        /// </summary>
        public UriBuilder RequestUriBuilder
        {
            get
            {
                return RequestUriBuilderBase;
            }
            set
            {
                if (value == null)
                {
                    QueryBuilder.Clear();
                    RequestUriBuilderBase = null;

                    return;
                }

                QueryBuilder.Clear();
                QueryBuilder.Value = value.Query;

                RequestUriBuilderBase = value;
            }
        }

        /// <summary>
        /// Get or set the URL of the request
        /// </summary>
        public virtual string RequestURL
        {
            get
            {
                // Set the Query string based off the Query String Builder
                RequestUriBuilder.Query = this.QueryBuilder.Value;

                // Don't use the to string method of the Uri property in UriBuilder
                // it doesn't preserver the escap charaters.
                return RequestUriBuilder.ToString();
            }
            set
            {
                if (value != null)
                {
                    RequestUriBuilder = new UriBuilder(value);
                }
                else
                {
                    RequestUriBuilder = null;
                }
            }
        }

        /// <summary>
        /// Get the Http Web Request that would be generated via the current properties
        /// </summary>
        /// <remarks>Dynamically generated. So calling sparingly.</remarks>
        public virtual HttpWebRequest Request
        {
            get
            {
                HttpWebRequest request;

                request = (HttpWebRequest)WebRequest.Create(this.RequestURL);

                request.Method = this.Method.ToString();

                foreach (string key in this.HeaderCollection.Keys)
                {
                    if (this.HeaderCollection[key] == null)
                    {
                        // Key value is null, don't add the header value 
                        continue;
                    }

                    switch (key)
                    {
                        case "Accept":

                            request.Accept = this.HeaderCollection[HttpRequestHeader.Accept];

                            break;                        

                        case "Content-Type":

                            request.ContentType = this.HeaderCollection[HttpRequestHeader.ContentType];

                            break;

                        case "Referer":

                            request.Referer = this.HeaderCollection[HttpRequestHeader.Referer];

                            break;

                        case "User-Agent":

                            request.UserAgent = this.HeaderCollection[HttpRequestHeader.UserAgent];

                            break;

                        case "Connection":

                            // Keep-Alive and Close are special cases and can not be set via this property
                            if (string.Compare(this.HeaderCollection[HttpRequestHeader.Connection], "Keep-Alive", true) != 0)
                            {
                                request.KeepAlive = true;

                                break;
                            }
                            else if (string.Compare(this.HeaderCollection[HttpRequestHeader.Connection], "Close", true) != 0)
                            {
                                request.KeepAlive = false;

                                break;
                            }

                            request.Connection = this.HeaderCollection[HttpRequestHeader.Connection];

                            break;
                            
                        default:

                            request.Headers.Add(key, this.HeaderCollection[key]);

                            break;
                    }
                }

                // Add cookies to request
                if ( (this.Cookies != null) &&
                     (this.Cookies.Count > 0))
                {
                    // Adding a Cookie Container as it's required if you want the HttpWebRequest.Cookies to actaully contain the cookies.
                    request.CookieContainer = new CookieContainer();

                    // Ensure the all the values within the cookies are set. If they 
                    // are not, then set to there defaults so the user does not have to do this for all cookies.
                    foreach (Cookie cookie in this.Cookies)
                    {
                        if (string.IsNullOrEmpty(cookie.Domain))
                        {
                            // Domain can't be empty. Fill it in with the site you are about to call
                            cookie.Domain = request.RequestUri.Host;
                        }
                    }

                    request.CookieContainer.Add(this.Cookies);
                }

                // Set the method and write the post last as we are closing the request stream
                if (request.Method == HttpMethods.POST.ToString())
                {
                    Stream stream;
                    byte[] content = this.Content;

                    if (content == null)
                    {
                        // Content is empty
                        content = new byte[0];
                    }

                    request.ContentLength = content.Length;

                    using (stream = request.GetRequestStream())
                    {
                        stream.Write(content, 0, content.Length);
                        stream.Close();
                    }
                }

                return request;
            }
        }

        /// <summary>
        /// Output print friendly string displaying all properties
        /// </summary>
        /// <returns>String containing all predominant properties</returns>
        public override string ToString()
        {
            HttpWebRequest request;
            string output = string.Empty;

            // Using this as the request is generated dynamically when the property is called
            request = this.Request;

            output += request.Method + " " + request.RequestUri;

            // TODO output all of the properties and not just the url. 
            return output;
        }

        /// <summary>
        /// Generate and make a request given current properties
        /// </summary>
        /// <returns>HttpResponse containing the response from the request</returns>
        public virtual HttpClientResponse MakeARequest()
        {
            // Using this as the request is generated dynamically when the property is called
            return new HttpClientResponse(this.Request);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient\QueryStringBuilder\QueryStringBuilder.cs ===
﻿
// Description:
//  Used to build the url query string
//
// <Copyright> Copyright (C) Microsoft Corporation.  All rights reserved. </Copyright>
//------------------------------------------------------------------------------------
namespace LiveN.Test
{
    using System;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;
    using System.Text;
    using System.Web;

    /// <summary>
    /// Generate and minipulate a query string that can contain constant parameters
    /// </summary>
    public class QueryStringBuilder
    {
        /// <summary>
        /// Character that starts query strings
        /// </summary>
        private const char QueryStartChar = '?';

        /// <summary>
        /// Character that separates key/value pairs
        /// </summary>
        private const char ParameterDelimiterChar = '&';

        /// <summary>
        /// Character that separates keys from values
        /// </summary>
        private const char KeyValueDelimiterChar = '=';

        /// <summary>
        /// Random used to randomly select a Value 
        /// </summary>
        private Random rnd = new Random();

        /// <summary>
        /// Conatains all the Query Parameters
        /// </summary>
        private Dictionary<string, QueryParameter> queryParms = new Dictionary<string, QueryParameter>();

        /// <summary>
        /// Custom string to append to the end of the query
        /// </summary>
        private string customEnding;

        /// <summary>
        /// Initializes a new instance of the QueryStringBuilder class.
        /// </summary>
        public QueryStringBuilder()
        {
        }

        /// <summary>
        /// Initializes a new instance of the QueryStringBuilder class by parsing the provided query string
        /// </summary>
        /// <param name="queryString">query string</param>
        /// <exception cref="System.ArgumentNullException">The query string is null.</exception>
        public QueryStringBuilder(string queryString)
        {
            this.FromString(queryString);
        }

        /// <summary>
        /// Get the last QueryString that was generated. 
        /// Useful when and error occurs because of a request and you want to report on the last url as the returns may be randomly generated.
        /// </summary>
        public string LastQueryString { get; set; }

        /// <summary>
        /// Gets or sets the query string
        /// </summary>
        public string Value
        {
            get
            {
                return this.ToString();
            }

            set
            {
                this.FromString(value);
            }
        }

        /// <summary>
        /// Gets or sets the custom string to append to the end of the query
        /// </summary>
        public string CustomEnding
        {
            get
            {
                return this.customEnding;
            }

            set
            {
                this.customEnding = value;
            }
        }

        /// <summary>
        /// Gets the number of key/value pairs contained in the System.Collections.Specialized.NameObjectCollectionBase instance.
        /// </summary>
        public int Count
        {
            get
            {
                return this.queryParms.Count;
            }
        }

        /// <summary>
        /// Gets the collection of keys
        /// </summary>
        public Collection<string> Keys
        {
            get
            {
                Collection<string> keys = new Collection<string>();

                foreach (string key in this.queryParms.Keys)
                {
                    keys.Add(key);
                }

                return keys;
            }
        }

        /// <summary>
        /// Gets the collection of Query Parameter
        /// </summary>
        public Collection<QueryParameter> Values
        {
            get
            {
                Collection<QueryParameter> parms = new Collection<QueryParameter>();

                foreach (QueryParameter parm in this.queryParms.Values)
                {
                    parms.Add(parm);
                }

                return parms;
            }
        }



        /// <summary>
        /// Get or set the Query Parameter
        /// </summary>
        /// <param name="name">Name of the parameter</param>
        /// <returns>Returns the QueryParameter if it exists</returns>
        public QueryParameter this[string name]
        {
            get
            {
                try
                {
                    return queryParms[name];
                }
                catch (Exception exc)
                {
                    throw new Exception("Could not find Query Parameter with the Key Name of '" + name + "'. \r\nException:\r\n" + exc.ToString());
                }
            }

            set
            {
                try
                {
                    queryParms[name] = value;
                }
                catch (Exception exc)
                {
                    throw new Exception("Could not find Query Parameter with the Key Name of '" + name + "'. \r\nException:\r\n" + exc.ToString());
                }
            }
        }

        /// <summary>
        /// Determines whether the QueryStringBuilder contains the specified parameter name.
        /// </summary>
        /// <param name="name">Name of the parameter</param>
        /// <returns>True is the QueryStringBuilder contains the paramater name. Else False is returned.</returns>
        public bool ContainsKey(string name)
        {
            return queryParms.ContainsKey(name);
        }

        /// <summary>
        /// Override of ToString() that outputs a query string
        /// </summary>
        /// <returns>Query string containing the UrlEncoded key/value pairs</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();

            foreach (string key in queryParms.Keys)
            {
                string[] values;

                if ((queryParms[key] == null) || 
                    (queryParms[key].Value == null)) // Setting any parameter value to null means to ignore this parameter
                {
                    continue;
                }

                // If this is not the first parameter added to the query, add the delimiter
                if (sb.Length > 0)
                {
                    sb.Append(ParameterDelimiterChar);
                }

                sb.Append(HttpUtility.UrlEncode(key));
                sb.Append(KeyValueDelimiterChar);

                // Encode each value in the value string seperated by a comma
                values = queryParms[key].Value.Split(',');
                for (int i = 0; i < values.Length; i++)
                {
                    if (i > 0)
                    {
                        sb.Append(',');
                    }

                    sb.Append(HttpUtility.UrlEncode((values[i] != null) ? values[i] : String.Empty));
                }
            }

            sb.Append(this.CustomEnding);

            // Set the last query string so it can be referenced later
            this.LastQueryString = sb.ToString();

            return this.LastQueryString;
        }

        /// <summary>
        /// Clear the current values and re-populate by parsing the provided query string
        /// </summary>
        /// <param name="queryString">query string</param>
        /// <exception cref="System.ArgumentNullException">The query string is null.</exception>
        protected void FromString(string queryString)
        {
            queryParms.Clear();

            if (queryString == null)
            {
                throw new ArgumentNullException("queryString");
            }

            int keyValueDelimiterIndex;
            int parameterDelimiterIndex = queryString.IndexOf(QueryStartChar);
            if (parameterDelimiterIndex < 0)
            {
                throw new ArgumentException("Invalid query string: Leading '" + QueryStartChar + "' not found");
            }

            while (0 <= (keyValueDelimiterIndex = queryString.IndexOf(KeyValueDelimiterChar, parameterDelimiterIndex)))
            {
                string key = null;
                string value = null;
                int keyLength = keyValueDelimiterIndex - parameterDelimiterIndex - 1;
                if (keyLength > 0)
                {
                    key = queryString.Substring(parameterDelimiterIndex + 1, keyLength);
                }

                parameterDelimiterIndex = queryString.IndexOf(ParameterDelimiterChar, parameterDelimiterIndex + 1);

                if (parameterDelimiterIndex < 0)
                {
                    parameterDelimiterIndex = queryString.Length;
                }

                int valueLength = parameterDelimiterIndex - keyValueDelimiterIndex - 1;

                if (valueLength > 0)
                {
                    value = queryString.Substring(keyValueDelimiterIndex + 1, valueLength);
                }

                if (key != null)
                {
                    Add(HttpUtility.UrlDecode(key), HttpUtility.UrlDecode(value));
                }
            }
        }

        /// <summary>
        /// Clears all the query parameter values
        /// </summary>
        public virtual void Clear()
        {
            foreach (string key in queryParms.Keys)
            {
                queryParms[key].Value = null;
            }
        }

        /// <summary>
        /// Add the query parameter to the list of query parameters
        /// </summary>
        /// <param name="name">Name of the query parameter</param>
        public void Add(string name)
        {
            Add(name, null);
        }

        /// <summary>
        /// Add the query parameter to the list of query parameters
        /// </summary>
        /// <param name="name">Name of the query parameter</param>
        /// <param name="value">Value of the parameter</param>
        public void Add(string name, string value)
        {
            QueryParameter parm = new QueryParameter(name);

            parm.Value = value;

            Add(parm);
        }

        /// <summary>
        /// Add the query parameter to the list of query parameters
        /// </summary>
        /// <param name="parm">Query Parameter to be added</param>
        public void Add(QueryParameter parm)
        {
            if (queryParms.ContainsKey(parm.ParameterName))
            {
                // Parameter with this name already exists. Append to the end of the string.
                queryParms[parm.ParameterName].Value += "," + parm.Value;

                return;
            }

            queryParms.Add(parm.ParameterName, parm);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient\QueryStringBuilder\QueryParametercs.cs ===
﻿//------------------------------------------------------------------------------------
// Description:
//  Represents a query parameter in a url string
//
// <Copyright> Copyright (C) Microsoft Corporation.  All rights reserved. </Copyright>
//------------------------------------------------------------------------------------
namespace LiveN.Test
{
    using System;
    using System.Collections.ObjectModel;

    /// <summary>
    /// Constant parameter stored within the query string
    /// </summary>
    public class QueryParameter
    {
        /// <summary>
        /// Name of the parameter
        /// </summary>
        public readonly string ParameterName;

        /// <summary>
        /// Member for Value
        /// </summary>
        private string memberValue = null;

        /// <summary>
        /// Initializes a new instance of the QueryParameter class.
        /// </summary>
        /// <param name="parameterName">Name of the parameter that is constant</param>
        public QueryParameter(string parameterName)
        {
            if (string.IsNullOrEmpty(parameterName))
            {
                throw new Exception("parameterName");
            }

            this.ParameterName = parameterName;
        }

        /// <summary>
        /// Gets or sets the value to be set within the QueryString
        /// </summary>
        public virtual string Value
        {
            get
            {
                return this.memberValue;
            }

            set
            {
                this.memberValue = value;   
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient\HttpClientResponse.cs ===
﻿//---------------------------------------------------------------------
//
// Description:
//  Generic class to handle url request
//
//
// Copyright (C) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------
namespace LiveN.Test
{
    using System;
    using System.Diagnostics;
    using System.IO;
    using System.Net;

    /// <summary>
    /// Base class used to store an http response
    /// </summary>
    public class HttpClientResponse
    {
        /// <summary>
        /// Request used that generated this response
        /// </summary>
        public readonly HttpWebRequest Request;

        /// <summary>
        /// Response returned by the passed in request
        /// </summary>
        public readonly HttpWebResponse Response;

        /// <summary>
        /// Create an HttpResponse object
        /// </summary>
        /// <param name="request">Http web request that will be used to populate this response object</param>
        public HttpClientResponse(HttpWebRequest request)
        {
            TimeSpan start;
            StreamReader streamReader = null;

            Response = null;

            this.Request = request;

            start = new TimeSpan(DateTime.Now.Ticks);

            Trace.TraceInformation("Making a request to: " + request.RequestUri.ToString());

            try
            {
                this.Response = (HttpWebResponse)request.GetResponse();

                this.StatusCode = this.Response.StatusCode;

                streamReader = new StreamReader(this.Response.GetResponseStream(), true);

                this.Body = streamReader.ReadToEnd();
            }
            catch (WebException webExc)
            {
                this.Response = (HttpWebResponse)webExc.Response;
                if (this.Response == null)
                {
                    // There was an issue with the connection. Not the service itself. 
                    throw webExc;
                }

                this.StatusCode = this.Response.StatusCode;

                streamReader = new StreamReader(this.Response.GetResponseStream(), true);

                this.Body = streamReader.ReadToEnd();
            }
            finally
            {
                if (streamReader != null)
                {
                    streamReader.Close();
                }

                if (this.Response != null)
                {
                    this.Response.Close();
                }
            }
            Trace.WriteLine("Response Body: ");
            Trace.WriteLine("\r\n" + this.Body + "\r\n");
        }

        /// <summary>
        /// Get or set the http response status code
        /// </summary>
        public HttpStatusCode StatusCode
        {
            get;
            set;
        }

        /// <summary>
        /// Body of the response
        /// </summary>
        public string Body
        {
            get;
            set;
        }

        /// <summary>
        /// Output print friendly string displaying all properties
        /// </summary>
        /// <returns>String containing all predominant properties</returns>
        public override string ToString()
        {
            string output = string.Empty;

            output += this.Response.StatusCode.ToString() + "\r\n" +
                      "Content-Type: " + this.Response.ContentType.ToString() + "\r\n" +
                      "Content-Lenght: " + this.Response.ContentLength.ToString() + "\r\n" +
                      "\r\n" + this.Body; 

            // TODO output all of the properties and not just the url. 
            return output;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient\UnitTests\QueryStringBuilderTests.cs ===
//------------------------------------------------------------------------------------
// Description:
//  Unit tests for the QueryStringBuilder class
//
// <Copyright> Copyright (C) Microsoft Corporation.  All rights reserved. </Copyright>
//------------------------------------------------------------------------------------
namespace LiveN.Test
{
    using System;
    using System.Text;

    using Microsoft.VisualStudio.TestTools.UnitTesting;

    /// <summary>
    /// Used to test QueryStringBuilder
    /// </summary>
    [TestClass]
    public class QueryStringBuilderTests
    {
        /// <summary>
        /// See Unit Test Description
        /// </summary>
        [TestMethod]
        [Owner("rsnyder")]
        [Description("ToString() Test")]
        public void ToStringTest()
        {
            string resultQueryString;
            QueryStringBuilder qsb = new QueryStringBuilder();

            qsb.Add(TestEnum.Foo, TestEnum.Bar);
            qsb.Add(TestEnum.Oop, TestEnum.Ack);
            qsb.Add("IdenticalParm", "1");
            qsb.Add("IdenticalParm", "2");
            qsb.Add("that", "other");
            qsb.Add("null", null); // Should show up
            qsb.Add("empty", string.Empty); // Should also show up
            qsb.Add("encoded", "string containing\tcharacters like\n\"?\" and '&' as well as `%`");

            resultQueryString = qsb.ToString();

            Assert.AreEqual(7, qsb.Count, "Count should be equal to the number of parameters that you put in. Not the number of values. As a single parametere can have multi values.");

            // As this class uses a hash table, output order is not guarantied. Ensure that the values are within the query string.
            Assert.IsTrue(resultQueryString.Contains("foo=bar"));
            Assert.IsTrue(resultQueryString.Contains("oop=ack"));
            Assert.IsTrue(resultQueryString.Contains("IdenticalParm=1,2"));
            Assert.IsTrue(resultQueryString.Contains("that=other"));
            Assert.IsFalse(resultQueryString.Contains("null="));
            Assert.IsTrue(resultQueryString.Contains("empty=&") || resultQueryString.EndsWith("empty="), "Values that are blank, will show up on the line");
            Assert.IsTrue(resultQueryString.Contains("encoded=string+containing%09characters+like%0a%22%3f%22+and+'%26'+as+well+as+%60%25%60"));
        }

        /// <summary>
        /// See Unit Test Description
        /// </summary>
        [TestMethod]
        [Owner("rsnyder")]
        [Description("Constructr Null Test")]
        [ExpectedException(typeof(ArgumentNullException))]
        public void ConstructorNullStringTest()
        {
            new QueryStringBuilder(null);
        }

        /// <summary>
        /// See Unit Test Description
        /// </summary>
        [TestMethod]
        [Owner("rsnyder")]
        [Description("Well-formed string Test")]
        public void FromGoodStringTest()
        {
            string queryString = "?foo=this&bar=other&encoded=something%20encoded";
            QueryStringBuilder qsb = new QueryStringBuilder(queryString);

            // Ensure that all the parameters where parsed
            Assert.IsNotNull(qsb["foo"]);
            Assert.IsNotNull(qsb["bar"]);
            Assert.IsNotNull(qsb["encoded"]);
        }

        /// <summary>
        /// See Unit Test Description
        /// </summary>
        [TestMethod]
        [Owner("rsnyder")]
        [Description("Malformed FromString() Tests")]
        public void FromBadStringsTest()
        {
            QueryStringTestData[] queryStringTestData = new QueryStringTestData[]
            {
                new QueryStringTestData("?foo=this", 1, null),
                new QueryStringTestData("?foo=this&bar=other&encoded=something%20encoded", 3, null),
                new QueryStringTestData("?foo=this&bar=other&encoded=something%20encoded&", 3, null),
                new QueryStringTestData("?foo=this&bar=other&encodedsomething%20encoded", 2, null),
                new QueryStringTestData("?foo=this&bar=other&encodedsomething%20encoded=", 3, null),
                new QueryStringTestData("?foo=this&bar=otherencoded=something%20encoded", 2, null),
                new QueryStringTestData("foo=this&bar=other&encoded=something%20encoded", 0, typeof(ArgumentException)),
                new QueryStringTestData("foo=this", 0, typeof(ArgumentException))
            };

            foreach (QueryStringTestData testData in queryStringTestData)
            {
                QueryStringBuilder qsb = null;

                try
                {
                    qsb = new QueryStringBuilder(testData.QueryString);
                }
                catch (Exception e)
                {
                    Assert.IsTrue((e.GetType() == testData.ExpectedExceptionType), "Unexpected exception thrown: " + e.ToString() + "\r\n\r\nqueryString = \"" + testData.QueryString + "\"");
                }

                if (qsb != null)
                {
                    Assert.IsTrue(qsb.Count == testData.NumberOfElements, "Expected number of elements were not found.\r\n\r\nqueryString = \"" + testData.QueryString + "\"");
                    Assert.IsNotNull(qsb["foo"], "Expected key 'foo' was not found.\r\n\r\nqueryString = \"" + testData.QueryString + "\"");
                }
            }
        }

        /// <summary>
        /// Test values
        /// </summary>
        private struct TestEnum
        {
            /// <summary>
            /// Test Value
            /// </summary>
           public const string Foo = "foo";

            /// <summary>
            /// Test Value
            /// </summary>
            public const string Bar = "bar";

            /// <summary>
            /// Test Value
            /// </summary>
            public const string Oop = "oop";

            /// <summary>
            /// Test Value
            /// </summary>
            public const string Ack = "ack";
        }

        /// <summary>
        /// Structure used to test QueryStringBuilder
        /// </summary>
        private struct QueryStringTestData
        {
            /// <summary>
            /// Query String
            /// </summary>
            public string QueryString;

            /// <summary>
            /// Expected number of elements
            /// </summary>
            public int NumberOfElements;

            /// <summary>
            /// Expected Exception
            /// </summary>
            public Type ExpectedExceptionType;

            /// <summary>
            /// Initializes a new instance of the QueryStringTestData struct.
            /// </summary>
            /// <param name="queryString">Query String</param>
            /// <param name="numberOfElements">Expected Exception</param>
            /// <param name="expectedExceptionType">Expected number of elements</param>
            public QueryStringTestData(string queryString, int numberOfElements, Type expectedExceptionType)
            {
                this.QueryString = queryString;
                this.NumberOfElements = numberOfElements;
                this.ExpectedExceptionType = expectedExceptionType;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.AvatarServices\Closet_Partner\ClosetClientPartnerResponse.cs ===
﻿//---------------------------------------------------------------------
// Copyright (C) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------
using System.Net;

namespace LiveN.Test
{
    /// <summary>
    /// Client used to interact with the Manifest Read Origin Response
    /// </summary>
    public class ClosetPartnerClientResponse : HttpClientResponse
    {
        public ClosetPartnerClientResponse(HttpWebRequest request)
            : base(request)
        {
        }

        /// <summary>
        /// Serilizes the response body into a response object
        /// </summary>
        public ClosetResponseBody BodyWrapper
        {
            get
            {
                return ClosetResponseBody.DeserializeXml<ClosetResponseBody>(this.Body);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.AvatarServices\AvatarServicesCommon.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace LiveN.Test
{
    /// <summary>
    /// Contains any information that can be used by any / all the Avatar Services
    /// </summary>
    public static class AvatarServicesCommon
    {
        /// <summary>
        /// Header name used for the platform the request is coming from
        /// </summary>
        public const string PLATFORM_TYPE = "X-Platform-Type";

        /// <summary>
        /// Partner Authorization Token
        /// </summary>
        public const string PARTNER_AUTHORIZATION = "X-PartnerAuthorization";

        /// <summary>
        /// User Authorization Token
        /// </summary>
        public const string USER_AUTHORIZATION = "X-Authorization";

        /// <summary>
        /// Used to prefix the partner token
        /// </summary>
        public const string AUTH_PREFIX = "XBL1.0 x=";

        /// <summary>
        /// Audience used to sign an partner token against 
        /// </summary>
        public const string AUDIENCE_URI = "http://xboxlive.com/avatar";
    }

    /// <summary>
    /// Used to determine what type of Token to send within the request
    /// </summary>
    public enum RequestedTokenEnum
    {
        PartnerToken,
        UserToken
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.AvatarServices\Closet_Partner\ClosetClientPartnerRequest.cs ===
﻿//---------------------------------------------------------------------
// Copyright (C) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------
using System;
using System.Net;

using LiveNew.Test;

namespace LiveN.Test
{    
    /// <summary>
    /// Client used to interact with the API
    /// </summary>
    public class ClosetPartnerClientRequest : HttpClientRequest
    {
        /// <summary>
        /// All Header Values that will accompany the request within the header
        /// </summary>
        public new readonly ClosetPartnerHeaders Headers;

        /// <summary>
        /// Get or set the Environment this object uses to do it's communications
        /// </summary>
        private EnvironmentElement CurrentEnvironment
        {
            get
            {
                if (memberCurrentEnvironment != null)
                {
                    return memberCurrentEnvironment;
                }

                // Environment has not been specified, use the common one.
                return CurrentEnvironmentSettings.SelectedEnvironment;
            }
            set
            {
                // Set auth to null so it gets updated
                memberAuth = null;

                memberCurrentEnvironment = value;
            }
        }
        private EnvironmentElement memberCurrentEnvironment = null;

        /// <summary>
        /// Get the Authentication Cache used to cache user data
        /// </summary>
        private EnvironmentAwareAuthCache Auth
        {
            get
            {
                if (memberAuth == null)
                {
                    memberAuth = new EnvironmentAwareAuthCache(CurrentEnvironment);
                }

                return memberAuth;
            }
        }
        private EnvironmentAwareAuthCache memberAuth = null;

        /// <summary>
        /// Create a default instance with all default properties based off the global LiveN configuration settings
        /// </summary>
        public ClosetPartnerClientRequest(string userEmail, string password)
            : this(CurrentEnvironmentSettings.SelectedEnvironment, userEmail, password)
        {
        }

        /// <summary>
        /// Create a default instance with all default properties to
        /// </summary>
        /// <param name="runEnvironment">Environment used to control where this instance will call</param>
        public ClosetPartnerClientRequest(EnvironmentElement runEnvironment, string userEmail, string password)
            : this(runEnvironment, runEnvironment.ClosetPartService.OriginalString, userEmail, password)
        {            
        }

        /// <summary>
        /// Create a default instance with all default properties to
        /// </summary>
        /// <param name="url">Closet url used to call the service</param>
        public ClosetPartnerClientRequest(string url, string userEmail, string password)
            : this(null, url, userEmail, password)
        {
        }

        /// <summary>
        /// Create a default instance with all default properties to
        /// </summary>
        /// <param name="runEnvironment">Environment used to control where this instance will call</param>
        /// <param name="url">Closet url used to call the service</param>
        public ClosetPartnerClientRequest(EnvironmentElement runEnvironment, string url, string userEmail, string password)
        {
            UriBuilder uri = new UriBuilder(url);

            CurrentEnvironment = runEnvironment;

            this.UserEmail = userEmail;
            this.Password = password;

            // Set title to the first one. As for default test cases, the specific title does not matter.
            this.Title = CurrentEnvironment.Titles[0];

            this.Host = uri.Host;
            this.Port = uri.Port;
            this.Path = "Closet.svc/GetClosetAssets";

            this.Method = HttpMethods.GET;
            this.SetAuthenticationToken = true;
            this.RequestedToken = RequestedTokenEnum.PartnerToken;

            this.Headers = new ClosetPartnerHeaders();
            this.Headers.Add("Pragma", "no-cache"); // Ensure you don't get any cached values

            // Set the Header Collection so the base class uses our custom Headers
            this.HeaderCollection = this.Headers.headers;
            
            // Set all the default values
            this.Headers.PlatformType = "15";
            this.Headers.ContentType = "application/xml";
            this.Headers.UserAgent = "LiveN Test Request";
        }

        /// <summary>
        /// Gets or sets the value indicating that the request should be authenticated or not.
        /// </summary>
        public bool SetAuthenticationToken
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the Token that will be sent within the request
        /// </summary>
        public RequestedTokenEnum RequestedToken
        {
            get;
            set;
        }

        /// <summary>
        /// Get the Http Web Request that would be generated via the current properties
        /// </summary>
        /// <remarks>Dynamically generated. So calling sparingly.</remarks>
        public override HttpWebRequest Request
        {
            get
            {
                if (this.SetAuthenticationToken)
                {
                    if (this.RequestedToken == RequestedTokenEnum.PartnerToken)
                    {
                        // Partner Authorization is not Overriden. So get one before constructing the request. 
                        this.Headers.PartnerAuthorization = AvatarServicesCommon.AUTH_PREFIX + Auth.GetPartnerToken(this.UserEmail, this.Password, this.Title, AvatarServicesCommon.AUDIENCE_URI);
                    }
                    else if (this.RequestedToken == RequestedTokenEnum.UserToken)
                    {
                        // User Authorization is not Overriden. So get one before constructing the request. 
                        this.Headers.UserAuthorization = AvatarServicesCommon.AUTH_PREFIX + Auth.GetUserToken(this.UserEmail, this.Password, this.Title);
                    }
                    else
                    {
                        throw new Exception("Newly added Token type " + this.RequestedToken.ToString() + " needs to be supported here.");
                    }
                }

                return base.Request;
            }
        }

        /// <summary>
        /// Email address of the user that will be used for partner token authentication
        /// </summary>
        public string UserEmail
        {
            get;
            set;
        }

        /// <summary>
        /// Password of the user that will be used for partner token authentication
        /// </summary>
        public string Password
        {
            get;
            set;
        }

        /// <summary>
        /// Title of the user that will be used for partner token authentication
        /// </summary>
        public TitleElement Title
        {
            get;
            set;
        }

        /// <summary>
        /// Make a request to the Closet Partner API using the given properties
        /// </summary>
        /// <returns>Returns an Closet Partner Client Response</returns>
        public new ClosetPartnerClientResponse MakeARequest()
        {
            return new ClosetPartnerClientResponse(this.Request);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.AvatarServices\GamerPic_Partner\GamerPicResponseBody.cs ===
﻿//---------------------------------------------------------------------
// Copyright (C) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------
namespace LiveN.Test
{
    using System.Xml;
    using System.Xml.Serialization;

    using Infrastructure.Test;

    /// <summary>
    /// Models the GamerPic Response XML that the service will return to the client 
    /// </summary>
    [XmlRoot(ElementName = "UpdateGamerPicResponse", Namespace = "http://schemas.datacontract.org/2004/07/Avatar.Services.ManifestWrite.Library")]
    public class GamerPicResponseBody : SerializerExtension
    {
        /// <summary>
        /// Status code
        /// </summary>
        public int SuccessCode;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.AvatarServices\GamerPic_Partner\GamerPicClientPartnerResponse.cs ===
﻿//---------------------------------------------------------------------
// Copyright (C) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------
using System.Net;

namespace LiveN.Test
{
    /// <summary>
    /// Client used to interact with the response
    /// </summary>
    public class GamerPicClientPartnerResponse : HttpClientResponse
    {
        public GamerPicClientPartnerResponse(HttpWebRequest request)
            : base(request)
        {
        }

        /// <summary>
        /// Serilizes the response body into a response object
        /// </summary>
        public GamerPicResponseBody BodyWrapper
        {
            get
            {
                return GamerPicResponseBody.DeserializeXml<GamerPicResponseBody>(this.Body);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.AvatarServices\Closet_Partner\ClosetResponseBody.cs ===
﻿//---------------------------------------------------------------------
// Copyright (C) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------
namespace LiveN.Test
{
    using System.Xml;
    using System.Xml.Serialization;

    using Infrastructure.Test;

    /// <summary>
    /// Models the Closet Assets XML that the service will return to the client 
    /// </summary>
    [XmlRoot(ElementName="ClosetAssets", Namespace="http://schemas.datacontract.org/2004/07/Avatar.Services.Closet")]
    public class ClosetResponseBody  : SerializerExtension
    {
        /// <summary>
        /// Collection of Assets
        /// </summary>
        public AssetElement[] assets;

        /// <summary>
        /// If true then some of the assets have been filtered out
        /// </summary>
        public bool Filtered;
    }

    public class AssetElement
    {
        /// <summary>
        /// Asset id
        /// </summary>
        public string id;

        /// <summary>
        /// Asset title
        /// </summary>
        public string title;

        /// <summary>
        /// Localized description of the asset
        /// </summary>
        public string description;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.AvatarServices\GamerPic_Partner\GamerPicPartnerHeaders.cs ===
﻿//---------------------------------------------------------------------
// Copyright (C) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------
namespace LiveN.Test
{
    using System;
    using System.Net;

    /// <summary>
    /// Headers for the Request
    /// </summary>
    public class GamerPicPartnerHeaders : WebHeaderCollection
    {
        /// <summary>
        /// Header Collection to add or pull the header information from
        /// </summary>
        internal WebHeaderCollection headers;

        /// <summary>
        /// Create a collection of Headers
        /// </summary>
        public GamerPicPartnerHeaders()
        {
            headers = new WebHeaderCollection();
        }

        /// <summary>
        /// Create a collection of Headers based off the passed in collection
        /// </summary>
        /// <param name="headers">Header Collection to add or pull the header information from</param>
        public GamerPicPartnerHeaders(WebHeaderCollection headers)
        {
            if (headers == null)
            {
                throw new ArgumentNullException("headers");
            }

            this.headers = headers;
        }

        /// <summary>
        /// Gets or sets the Partner Authorization Token. 
        /// Setting to Null will cause the Partner Token not to be sent
        /// </summary>
        public string PartnerAuthorization
        {
            get
            {
                return this.headers[AvatarServicesCommon.PARTNER_AUTHORIZATION];
            }
            set
            {
                if (value == null)
                {
                    // After a header is set, setting to null nolonger sets the value to null. It sets it to empty string.
                    this.headers.Remove(AvatarServicesCommon.PARTNER_AUTHORIZATION);

                    return;
                }

                this.headers[AvatarServicesCommon.PARTNER_AUTHORIZATION] = value;
            }
        }

        /// <summary>
        /// Gets or sets the User Authorization Token. 
        /// Setting to Null will cause the User Token not to be sent
        /// </summary>
        public string UserAuthorization
        {
            get
            {
                return this.headers[AvatarServicesCommon.USER_AUTHORIZATION];
            }
            set
            {
                if (value == null)
                {
                    // After a header is set, setting to null nolonger sets the value to null. It sets it to empty string.
                    this.headers.Remove(AvatarServicesCommon.USER_AUTHORIZATION);

                    return;
                }

                this.headers[AvatarServicesCommon.USER_AUTHORIZATION] = value;
            }
        }

        /// <summary>
        /// Gets or sets the header value used to determine what the Content Type that's contained within the request
        /// </summary>
        public string ContentType
        {
            get
            {
                return this.headers[HttpRequestHeader.ContentType];
            }

            set
            {
                this.headers[HttpRequestHeader.ContentType] = value;
            }
        }

        /// <summary>
        /// Gets or sets the header value used to determine what kind of browser you are. Example: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; InfoPath.3; MS-RTC LM 8)
        /// </summary>
        public string UserAgent
        {
            get
            {
                return this.headers[HttpRequestHeader.UserAgent];
            }

            set
            {
                this.headers[HttpRequestHeader.UserAgent] = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.AvatarServices\Closet_Partner\ClosetPartnerHeaders.cs ===
﻿//---------------------------------------------------------------------
// Copyright (C) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------
namespace LiveN.Test
{
    using System;
    using System.Net;

    /// <summary>
    /// Headers for the Request
    /// </summary>
    public class ClosetPartnerHeaders : WebHeaderCollection
    {
        /// <summary>
        /// Header Collection to add or pull the header information from
        /// </summary>
        internal WebHeaderCollection headers;

        /// <summary>
        /// Create a collection of Headers
        /// </summary>
        public ClosetPartnerHeaders()
        {
            headers = new WebHeaderCollection();
        }

        /// <summary>
        /// Create a collection of Headers based off the passed in collection
        /// </summary>
        /// <param name="headers">Header Collection to add or pull the header information from</param>
        public ClosetPartnerHeaders(WebHeaderCollection headers)
        {
            if (headers == null)
            {
                throw new ArgumentNullException("headers");
            }

            this.headers = headers;
        }

        /// <summary>
        /// Gets or sets the Platform Type that's making the request
        /// </summary>
        public string PlatformType
        {
            get
            {
                return this.headers[AvatarServicesCommon.PLATFORM_TYPE];
            }
            set
            {
                this.headers[AvatarServicesCommon.PLATFORM_TYPE] = value;
            }
        }

        /// <summary>
        /// Gets or sets the Partner Authorization Token. 
        /// Setting to Null will cause the Partner Token not to be sent
        /// </summary>
        public string PartnerAuthorization
        {
            get
            {
                return this.headers[AvatarServicesCommon.PARTNER_AUTHORIZATION];
            }
            set
            {
                if (value == null)
                {
                    // After a header is set, setting to null nolonger sets the value to null. It sets it to empty string.
                    this.headers.Remove(AvatarServicesCommon.PARTNER_AUTHORIZATION);

                    return;
                }

                this.headers[AvatarServicesCommon.PARTNER_AUTHORIZATION] = value;
            }
        }

        /// <summary>
        /// Gets or sets the User Authorization Token. 
        /// Setting to Null will cause the User Token not to be sent
        /// </summary>
        public string UserAuthorization
        {
            get
            {
                return this.headers[AvatarServicesCommon.USER_AUTHORIZATION];
            }
            set
            {
                if (value == null)
                {
                    // After a header is set, setting to null nolonger sets the value to null. It sets it to empty string.
                    this.headers.Remove(AvatarServicesCommon.USER_AUTHORIZATION);

                    return;
                }

                this.headers[AvatarServicesCommon.USER_AUTHORIZATION] = value;
            }
        }

        /// <summary>
        /// Gets or sets the header value used to determine what the Content Type that's contained within the request
        /// </summary>
        public string ContentType
        {
            get
            {
                return this.headers[HttpRequestHeader.ContentType];
            }

            set
            {
                this.headers[HttpRequestHeader.ContentType] = value;
            }
        }

        /// <summary>
        /// Gets or sets the header value used to determine what kind of browser you are. Example: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; InfoPath.3; MS-RTC LM 8)
        /// </summary>
        public string UserAgent
        {
            get
            {
                return this.headers[HttpRequestHeader.UserAgent];
            }

            set
            {
                this.headers[HttpRequestHeader.UserAgent] = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.AvatarServices\GamerPic_Partner\GamerPicClientPartnerRequest.cs ===
﻿//---------------------------------------------------------------------
// Copyright (C) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------
using System;
using System.Net;
using System.Text;

using LiveNew.Test;

using Infrastructure.Test;

namespace LiveN.Test
{
    /// <summary>
    /// Client used to interact with the API
    /// </summary>
    public class GamerPicClientPartnerRequest : HttpClientRequest
    {
        /// <summary>
        /// All Header Values that will accompany the request within the header
        /// </summary>
        public new readonly GamerPicPartnerHeaders Headers;

        /// <summary>
        /// Get or set the Environment this object uses to do it's communications
        /// </summary>
        private EnvironmentElement CurrentEnvironment
        {
            get
            {
                if (memberCurrentEnvironment != null)
                {
                    return memberCurrentEnvironment;
                }

                // Environment has not been specified, use the common one.
                return CurrentEnvironmentSettings.SelectedEnvironment;
            }
            set
            {
                // Set auth to null so it gets updated
                memberAuth = null;

                memberCurrentEnvironment = value;
            }
        }
        private EnvironmentElement memberCurrentEnvironment = null;

        /// <summary>
        /// Get the Authentication Cache used to cache user data
        /// </summary>
        private EnvironmentAwareAuthCache Auth
        {
            get
            {
                if (memberAuth == null)
                {
                    memberAuth = new EnvironmentAwareAuthCache(CurrentEnvironment);
                }

                return memberAuth;
            }
        }
        private EnvironmentAwareAuthCache memberAuth = null;

        /// <summary>
        /// Create a default instance with all default properties based off the global LiveN configuration settings
        /// </summary>
        public GamerPicClientPartnerRequest(string userEmail, string password)
            : this(CurrentEnvironmentSettings.SelectedEnvironment, userEmail, password)
        {
        }

        /// <summary>
        /// Create a default instance with all default properties to
        /// </summary>
        /// <param name="runEnvironment">Environment used to control where this instance will call</param>
        public GamerPicClientPartnerRequest(EnvironmentElement runEnvironment, string userEmail, string password)
            : this(runEnvironment, runEnvironment.GamerPicPartService.OriginalString, userEmail, password)
        {  
        }

        /// <summary>
        /// Create a default instance with all default properties to
        /// </summary>
        /// <param name="url">GamerPic url used to call the service</param>
        public GamerPicClientPartnerRequest(string url, string userEmail, string password)
            : this(null, url, userEmail, password)
        {
        }

        /// <summary>
        /// Create a default instance with all default properties to
        /// </summary>
        /// <param name="runEnvironment">Environment used to control where this instance will call</param>
        /// <param name="url">GamerPic url used to call the service</param>
        public GamerPicClientPartnerRequest(EnvironmentElement runEnvironment, string url, string userEmail, string password)
        {
            UriBuilder uri = new UriBuilder(url);

            CurrentEnvironment = runEnvironment;

            this.UserEmail = userEmail;
            this.Password = password;

            // Set title to the first one. As for default test cases, the specific title does not matter.
            this.Title = CurrentEnvironment.Titles[0];

            this.Host = uri.Host;
            this.Port = uri.Port;
            this.Path = "GamerPic.svc/Update";

            this.Method = HttpMethods.POST;
            this.SetAuthenticationToken = true;
            this.RequestedToken = RequestedTokenEnum.PartnerToken;

            this.Headers = new GamerPicPartnerHeaders();
            this.Headers.Add("Pragma", "no-cache"); // Ensure you don't get any cached values

            this.ContentWrapper = new GamerPicRequestContent();

            // Set the Header Collection so the base class uses our custom Headers
            this.HeaderCollection = this.Headers.headers;
            
            // Set all the default values
            this.Headers.ContentType = "application/xml";
            this.Headers.UserAgent = "LiveN Test Request";

            SetRequestToCenteredPic();
        }

        /// <summary>
        /// Gets or sets the value indicating that the request should be authenticated or not.
        /// </summary>
        public bool SetAuthenticationToken
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the Token that will be sent within the request
        /// </summary>
        public RequestedTokenEnum RequestedToken
        {
            get;
            set;
        }

        /// <summary>
        /// Get the Http Web Request that would be generated via the current properties
        /// </summary>
        /// <remarks>Dynamically generated. So calling sparingly.</remarks>
        public override HttpWebRequest Request
        {
            get
            {
                if (this.SetAuthenticationToken)
                {
                    if (this.RequestedToken == RequestedTokenEnum.PartnerToken)
                    {
                        // Partner Authorization is not Overriden. So get one before constructing the request. 
                        this.Headers.PartnerAuthorization = AvatarServicesCommon.AUTH_PREFIX + Auth.GetPartnerToken(this.UserEmail, this.Password, this.Title, AvatarServicesCommon.AUDIENCE_URI);
                    }
                    else if (this.RequestedToken == RequestedTokenEnum.UserToken)
                    {
                        // User Authorization is not Overriden. So get one before constructing the request. 
                        this.Headers.UserAuthorization = AvatarServicesCommon.AUTH_PREFIX + Auth.GetUserToken(this.UserEmail, this.Password, this.Title);
                    }
                    else
                    {
                        throw new Exception("Newly added Token type " + this.RequestedToken.ToString() + " needs to be supported here.");
                    }
                }

                return base.Request;
            }
        }

        /// <summary>
        /// Email address of the user that will be used for partner token authentication
        /// </summary>
        public string UserEmail
        {
            get;
            set;
        }

        /// <summary>
        /// Password of the user that will be used for partner token authentication
        /// </summary>
        public string Password
        {
            get;
            set;
        }

        /// <summary>
        /// Title of the user that will be used for partner token authentication
        /// </summary>
        public TitleElement Title
        {
            get;
            set;
        }

        /// <summary>
        /// Post Content Data wrapped with a serilizable object
        /// </summary>
        public GamerPicRequestContent ContentWrapper
        {
            get;
            set;
        }

        #region IHttpClientPostDataAbstract Members

            /// <summary>
            /// Content contained within the the post
            /// </summary>
            public override byte[] Content
            {
                get
                {
                    if (this.ContentWrapper == null)
                    {
                        return null;
                    }

                    return Encoding.UTF8.GetBytes(this.ContentWrapper.SerializeToXmlString());
                }

                set
                {
                    if (value == null)
                    {
                        this.ContentWrapper = null;

                        return;
                    }

                    SetPostContentXml(Encoding.UTF8.GetString(value));
                }
            }
        #endregion

        /// <summary>
        /// Sets the request parameters to gamer pic where the avatart is centered within the frame.
        /// </summary>
        public void SetRequestToCenteredPic()
        {
            this.ContentWrapper.Frame = 0;
            this.ContentWrapper.UseProp = false;
            this.ContentWrapper.AnimationId = new Guid("00400000-0003-0003-c1c8-f109a19cb2e0");  // the basic standing pose

            this.ContentWrapper.Background = 0;

            // Center the gamerpic on the nose for a basic head shot
            this.ContentWrapper.OffsetX = 0;
            this.ContentWrapper.OffsetY = -0.06f;
            this.ContentWrapper.OffsetZ = 2.4f;
            this.ContentWrapper.RotationY = 0.03f;
            this.ContentWrapper.FieldOfView = 0.155f;
            this.ContentWrapper.FocalJoint = 19;
        }

        /// <summary>
        /// Make a request to the GamerPic Partner API using the given properties
        /// </summary>
        /// <returns>Returns an GamerPic Partner Client Response</returns>
        public new GamerPicClientPartnerResponse MakeARequest()
        {
            return new GamerPicClientPartnerResponse(this.Request);
        }

        /// <summary>
        /// Set the Gamer Pic xml into the Post Content Data object
        /// </summary>
        /// <param name="postContentData">Xml to be serilized into the Post Data Structure</param>
        public void SetPostContentXml(string postContentData)
        {
            if (string.IsNullOrEmpty(postContentData))
            {
                throw new ArgumentException("postContentData");
            }

            this.ContentWrapper = (GamerPicRequestContent)SerializerExtension.DeserializeXml<GamerPicRequestContent>(postContentData);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.AvatarServices\GamerPic_Partner\GamerPicRequestContent.cs ===
﻿namespace LiveN.Test
{
    using System;
    using System.Xml;
    using System.Xml.Serialization;

    using Infrastructure.Test;

    /// <summary>
    /// Request Content
    /// </summary>
    [XmlRoot("UpdateGamerPicRequest")]
    public class GamerPicRequestContent : SerializerExtensionOrdered
    {
        public GamerPicRequestContent()
        {
            // Set the default namespace
            this.Xmlns = new System.Xml.Serialization.XmlSerializerNamespaces
                        (
                            new XmlQualifiedName[] 
                                { 
                                    new XmlQualifiedName(string.Empty, "http://schemas.datacontract.org/2004/07/Avatar.Services.ManifestWrite.Library")
                                }
                        );
        }

        /// <summary>
        /// Animation used of the Avatar while taking the GamerPic
        /// </summary>
        [XmlElement(ElementName = "AnimationId", Order = 1)]
        public Guid AnimationId
        {
            get;
            set;
        }

        [XmlElement(ElementName = "Background", Order = 2)]
        public int Background
        {
            get;
            set;
        }

        [XmlElement(ElementName = "FieldOfView", Order = 3)]
        public float FieldOfView
        {
            get;
            set;
        }

        [XmlElement(ElementName = "FocalJoint", Order = 4)]
        public int FocalJoint
        {
            get;
            set;
        }

        /// <summary>
        /// Number of the frame within the animation that you want the animation at
        /// </summary>
        [XmlElement(ElementName = "Frame", Order = 5)]
        public float Frame
        {
            get;
            set;
        }

        [XmlElement(ElementName = "OffsetX", Order = 6)]
        public float OffsetX
        {
            get;
            set;
        }

        [XmlElement(ElementName = "OffsetY", Order = 7)]
        public float OffsetY
        {
            get;
            set;
        }

        [XmlElement(ElementName = "OffsetZ", Order = 8)]
        public float OffsetZ
        {
            get;
            set;
        }

        [XmlElement(ElementName = "RotationY", Order = 9)]
        public float RotationY
        {
            get;
            set;
        }

        [XmlElement(ElementName = "UseProp", Order = 10)]
        public bool UseProp
        {
            get;
            set;
        }

        /// <summary>
        /// Converts object to xml string representation
        /// </summary>
        /// <returns>Serialized object as an XML string</returns>
        public override string SerializeToXmlString()
        {
            string output = string.Empty;

            output = base.SerializeToXmlString(false);

            // Remove side affect of using the xml Serilizer
            output = output.Remove(0, ((string)"<?xml version=\"1.0\" encoding=\"utf-8\"?>").Length);
 
            // Hack, but it's better then using the DataContractSerializer, DataContractSerializeToXmlString, as it requires a specific namespace and class naming.
            output = output.Replace("xmlns=\"", "xmlns:i=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"");
            
            return output;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.AvatarServices\ManifestReadClient\ManifestReadClientRequest.cs ===
﻿//---------------------------------------------------------------------
// Copyright (C) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------
using System;

using LiveNew.Test;

namespace LiveN.Test
{
    /// <summary>
    /// Client used to interact with the Manifest Read CDN API
    /// </summary>
    public class ManifestReadClientRequest : ManifestReadOriginClientRequest
    {
        /// <summary>
        /// Create a default instance with all default properties to
        /// </summary>
        public ManifestReadClientRequest()
            : base(CurrentEnvironmentSettings.SelectedEnvironment.ManifestReadService.OriginalString)
        {
        }

        /// <summary>
        /// Create a default instance with all default properties to
        /// </summary>
        public ManifestReadClientRequest(string url)
            : base(url)
        {
        }

        /// <summary>
        /// Make a request to the Manifest Read Origin API using the given properties
        /// </summary>
        /// <returns>Returns an Manifest Read Origin Client Response</returns>
        public new ManifestReadClientResponse MakeARequest()
        {
            return new ManifestReadClientResponse(this.Request);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.AvatarServices\ManifestReadClient_Origin\ManifestReadOriginClientResponse.cs ===
﻿//---------------------------------------------------------------------
// Copyright (C) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------
using System.Net;

namespace LiveN.Test
{
    /// <summary>
    /// Client used to interact with the Manifest Read Origin Response
    /// </summary>
    public class ManifestReadOriginClientResponse : HttpClientResponse
    {
        public ManifestReadOriginClientResponse(HttpWebRequest request)
            : base(request)
        {
        }

        /// <summary>
        /// Serilizes the response body into a response object
        /// </summary>
        public ManifestReadResponseBody BodyWrapper
        {
            get
            {
                return ManifestReadResponseBody.DeserializeXml<ManifestReadResponseBody>(this.Body);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.AvatarServices\ManifestReadClient_Partner\ManifestReadPartnerClientResponse.cs ===
﻿//---------------------------------------------------------------------
// Copyright (C) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------
using System.Net;

namespace LiveN.Test
{
    /// <summary>
    /// Client used to interact with the Manifest Read Origin Response
    /// </summary>
    public class ManifestReadPartnerClientResponse : HttpClientResponse
    {
        public ManifestReadPartnerClientResponse(HttpWebRequest request)
            : base(request)
        {
        }

        /// <summary>
        /// Serilizes the response body into a response object
        /// </summary>
        public ManifestReadResponseBody BodyWrapper
        {
            get
            {
                return ManifestReadResponseBody.DeserializeXml<ManifestReadResponseBody>(this.Body);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.AvatarServices\ManifestReadClient\ManifestReadClientResponse.cs ===
﻿//---------------------------------------------------------------------
// Copyright (C) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------
using System.Net;

namespace LiveN.Test
{
    /// <summary>
    /// Client used to interact with the Manifest Read CDN Response
    /// </summary>
    public class ManifestReadClientResponse : ManifestReadOriginClientResponse
    {
        public ManifestReadClientResponse(HttpWebRequest request)
            : base(request)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.AvatarServices\ManifestReadClient_Origin\ManifestReadOriginClientRequest.cs ===
﻿//---------------------------------------------------------------------
// Copyright (C) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------
using System;

using LiveNew.Test;

namespace LiveN.Test
{
    /// <summary>
    /// Client used to interact with the Manifest Read Origin API
    /// </summary>
    public class ManifestReadOriginClientRequest : HttpClientRequest
    {
        /// <summary>
        /// All paramaters used for this API
        /// </summary>
        public readonly QueryParametersStruct QueryParameters;

        /// <summary>
        /// Create a default instance with all default properties to
        /// </summary>
        public ManifestReadOriginClientRequest()
            : this(CurrentEnvironmentSettings.SelectedEnvironment.ManifestReadOriginService.OriginalString)
        {
        }        

        /// <summary>
        /// Create a default instance with all default properties to
        /// </summary>
        public ManifestReadOriginClientRequest(string url)
        {
            UriBuilder uri = new UriBuilder(url);

            this.Host = uri.Host;
            this.Port = uri.Port;
            this.Path = "/Manifest.svc/"; // Added the last '/' becuase without it, it causes a url redirect 307 to happen on every request

            this.Method = HttpMethods.GET;

            this.QueryParameters = new QueryParametersStruct();

            // Set the Query Builder so the base class uses our custom QueryBuilder
            this.QueryBuilder = this.QueryParameters.QueryBuilder;

            this.Headers.UserAgent = "LiveN Test Request";
            this.Headers.Add("Pragma", "no-cache"); // Ensure you don't get any cached values
        }

        /// <summary>
        /// Make a request to the Manifest Read Origin API using the given properties
        /// </summary>
        /// <returns>Returns an Manifest Read Origin Client Response</returns>
        public new ManifestReadOriginClientResponse MakeARequest()
        {
            return new ManifestReadOriginClientResponse(this.Request);
        }

        /// <summary>
        /// Structure used to store all the Query Parameters for this API
        /// </summary>
        public class QueryParametersStruct
        {
            public readonly QueryStringBuilder QueryBuilder;

            public QueryParametersStruct()
            {
                this.QueryBuilder = new QueryStringBuilder();

                // Add all the Query Parameters to the QueryBuilder array of parms
                this.QueryBuilder.Add(new Parameter_GamerTag());
                this.QueryBuilder.Add(new Parameter_TitleID());
                this.QueryBuilder.Add(new Parameter_PlatformType());
            }

            /// <summary>
            /// User Id parameter used to Distinguish one caller from another (Parm name: uid)
            /// </summary>
            public Parameter_GamerTag GamerTag
            {
                get
                {
                    return (Parameter_GamerTag)QueryBuilder[Parameter_GamerTag.ParameterName];
                }
            }

            /// <summary>
            /// User Id parameter used to Distinguish one caller from another (Parm name: TitleID)
            /// </summary>
            public Parameter_TitleID TitleID
            {
                get
                {
                    return (Parameter_TitleID)QueryBuilder[Parameter_TitleID.ParameterName];
                }
            }

            /// <summary>
            /// User Id parameter used to Distinguish one caller from another (Parm name: PlatformType)
            /// </summary>
            public Parameter_PlatformType PlatformID
            {
                get
                {
                    return (Parameter_PlatformType)QueryBuilder[Parameter_PlatformType.ParameterName];
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.AvatarServices\ManifestReadClient_Partner\ManifestReadPartnerClientRequest.cs ===
﻿//---------------------------------------------------------------------
// Copyright (C) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------
using System;
using System.Net;

using LiveNew.Test;

namespace LiveN.Test
{   
    /// <summary>
    /// Client used to interact with the Manifest Read Partner API
    /// </summary>
    public class ManifestReadPartnerClientRequest : HttpClientRequest
    {
        /// <summary>
        /// All Header Values that will accompany the request within the header
        /// </summary>
        public new readonly ManifestReadPartnerHeaders Headers;

        /// <summary>
        /// Get or set the Environment this object uses to do it's communications
        /// </summary>
        private EnvironmentElement CurrentEnvironment
        {
            get
            {
                if (memberCurrentEnvironment != null)
                {
                    return memberCurrentEnvironment;
                }

                // Environment has not been specified, use the common one.
                return CurrentEnvironmentSettings.SelectedEnvironment;
            }
            set
            {
                // Set auth to null so it gets updated
                memberAuth = null;

                memberCurrentEnvironment = value;
            }
        }
        private EnvironmentElement memberCurrentEnvironment = null;

        /// <summary>
        /// Get the Authentication Cache used to cache user data
        /// </summary>
        private EnvironmentAwareAuthCache Auth
        {
            get
            {
                if (memberAuth == null)
                {
                    memberAuth = new EnvironmentAwareAuthCache(CurrentEnvironment);
                }

                return memberAuth;
            }
        }
        private EnvironmentAwareAuthCache memberAuth = null;

        /// <summary>
        /// Create a default instance with all default properties based off the global LiveN configuration settings
        /// </summary>
        public ManifestReadPartnerClientRequest(string userEmail, string password)
            : this(CurrentEnvironmentSettings.SelectedEnvironment, userEmail, password)
        {
        }

        /// <summary>
        /// Create a default instance with all default properties to
        /// </summary>
        /// <param name="runEnvironment">Environment used to control where this instance will call</param>
        public ManifestReadPartnerClientRequest(EnvironmentElement runEnvironment, string userEmail, string password)
            : this(runEnvironment, runEnvironment.ManifestReadPartService.OriginalString, userEmail, password)
        {
        }

        /// <summary>
        /// Create a default instance with all default properties
        /// </summary>
        /// <param name="url">ManifestRead's Partner url used to call the service</param>
        /// <param name="userEmail">Email of the user to be emulated</param>
        /// <param name="password">Password of the user to be emulated</param>
        public ManifestReadPartnerClientRequest(string url, string userEmail, string password)
            : this(null, url, userEmail, password)
        {
        }

        /// <summary>
        /// Create a default instance with all default properties
        /// </summary>
        /// <param name="url">ManifestRead's Partner url used to call the service</param>
        /// <param name="userEmail">Email of the user to be emulated</param>
        /// <param name="password">Password of the user to be emulated</param>
        public ManifestReadPartnerClientRequest(EnvironmentElement runEnvironment, string url, string userEmail, string password)
        {
            UriBuilder uri = new UriBuilder(url);

            CurrentEnvironment = runEnvironment;

            this.UserEmail = userEmail;
            this.Password = password;

            // Set title to the first one. As for default test cases, the specific title does not matter.
            this.Title = CurrentEnvironment.Titles[0];

            this.Host = uri.Host;
            this.Port = uri.Port;
            this.Path = "Manifest.svc/GetManifest";

            this.Method = HttpMethods.GET;
            this.SetAuthenticationToken = true;
            this.RequestedToken = RequestedTokenEnum.PartnerToken;

            this.Headers = new ManifestReadPartnerHeaders();
            this.Headers.Add("Pragma", "no-cache"); // Ensure you don't get any cached values

            // Set the Header Collection so the base class uses our custom Headers
            this.HeaderCollection = this.Headers.headers;

            // Set all the default values
            this.Headers.PlatformType = "15";
            this.Headers.ContentType = "application/xml";
            this.Headers.UserAgent = "LiveN Test Request";
        }

        /// <summary>
        /// Gets or sets the value indicating that the request should be authenticated or not.
        /// </summary>
        public bool SetAuthenticationToken
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the Token that will be sent within the request
        /// </summary>
        public RequestedTokenEnum RequestedToken
        {
            get;
            set;
        }

        /// <summary>
        /// Get the Http Web Request that would be generated via the current properties
        /// </summary>
        /// <remarks>Dynamically generated. So calling sparingly.</remarks>
        public override HttpWebRequest Request
        {
            get
            {
                if (this.SetAuthenticationToken)
                {
                    if (this.RequestedToken == RequestedTokenEnum.PartnerToken)
                    {
                        // Partner Authorization is not Overriden. So get one before constructing the request. 
                        this.Headers.PartnerAuthorization = AvatarServicesCommon.AUTH_PREFIX + Auth.GetPartnerToken(this.UserEmail, this.Password, this.Title, AvatarServicesCommon.AUDIENCE_URI);
                    }
                    else if (this.RequestedToken == RequestedTokenEnum.UserToken)
                    {
                        // User Authorization is not Overriden. So get one before constructing the request. 
                        this.Headers.UserAuthorization = AvatarServicesCommon.AUTH_PREFIX + Auth.GetUserToken(this.UserEmail, this.Password, this.Title);
                    }
                    else
                    {
                        throw new Exception("Newly added Token type " + this.RequestedToken.ToString() + " needs to be supported here.");
                    }
                }

                return base.Request;
            }
        }

        /// <summary>
        /// Email address of the user that will be used for partner token authentication
        /// </summary>
        public string UserEmail
        {
            get;
            set;
        }

        /// <summary>
        /// Password of the user that will be used for partner token authentication
        /// </summary>
        public string Password
        {
            get;
            set;
        }

        /// <summary>
        /// Title of the user that will be used for partner token authentication
        /// </summary>
        public TitleElement Title
        {
            get;
            set;
        }

        /// <summary>
        /// Make a request to the Manifest Read Partner API using the given properties
        /// </summary>
        /// <returns>Returns an Manifest Read Partner Client Response</returns>
        public new ManifestReadPartnerClientResponse MakeARequest()
        {
            return new ManifestReadPartnerClientResponse(this.Request);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.AvatarServices\ManifestReadClient_Origin\ManifestReadResponseBody.cs ===
﻿//---------------------------------------------------------------------
// Copyright (C) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------
namespace LiveN.Test
{
    using System.Xml;
    using System.Xml.Serialization;

    using Infrastructure.Test;

    /// <summary>
    /// Models the Closet Assets XML that the service will return to the client 
    /// </summary>
    [XmlRoot(ElementName = "AvatarManifests", Namespace = "http://schemas.datacontract.org/2004/07/Avatar.Services.ManifestRead.Library")]
    public class ManifestReadResponseBody : SerializerExtension
    {
        /// <summary>
        /// Collection of Manifests
        /// </summary>
        [XmlElement("Manifests")]
        public ManifestsElement[] Manifests;
    }

    /// <summary>
    /// Collection of Avatar Manifests
    /// </summary>
    public class ManifestsElement
    {
        /// <summary>
        /// Collection of Avatar Manifests
        /// </summary>
        [XmlElement("AvatarManifest")]
        public AvatarManifestElement AvatarManifest;
    }

    /// <summary>
    /// Avatar Manifest Response
    /// </summary>
    public class AvatarManifestElement
    {
        /// <summary>
        /// Gamertag
        /// </summary>
        public string Gamertag 
        { 
            get; 
            set; 
        }

        /// <summary>
        /// Raw manifest encoded as a string
        /// </summary>
        public string Manifest 
        { 
            get; 
            set; 
        }

        /// <summary>
        /// If true then the manifest has been filtered of at least one block listed assets
        /// </summary>
        public bool Filtered 
        { 
            get; 
            set; 
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.AvatarServices\ManifestReadClient_Partner\ManifestReadPartnerHeaders.cs ===
﻿//---------------------------------------------------------------------
// Copyright (C) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------
namespace LiveN.Test
{
    using System;
    using System.Net;

    /// <summary>
    /// Headers for the Manifest Read Partner Request
    /// </summary>
    public class ManifestReadPartnerHeaders : WebHeaderCollection
    {
         /// <summary>
        /// Header Collection to add or pull the header information from
        /// </summary>
        internal WebHeaderCollection headers;

        /// <summary>
        /// Create a collection of Headers
        /// </summary>
        public ManifestReadPartnerHeaders()
        {
            headers = new WebHeaderCollection();
        }

        /// <summary>
        /// Create a collection of Headers based off the passed in collection
        /// </summary>
        /// <param name="headers">Header Collection to add or pull the header information from</param>
        public ManifestReadPartnerHeaders(WebHeaderCollection headers)
        {
            if (headers == null)
            {
                throw new ArgumentNullException("headers");
            }

            this.headers = headers;
        }

        /// <summary>
        /// Gets or sets the Platform Type that's making the request
        /// </summary>
        public string PlatformType
        {
            get
            {
                return this.headers[AvatarServicesCommon.PLATFORM_TYPE];
            }
            set
            {
                this.headers[AvatarServicesCommon.PLATFORM_TYPE] = value;
            }
        }

        /// <summary>
        /// Gets or sets the Partner Authorization Token. 
        /// Setting to Null will cause the Partner Token not to be sent
        /// </summary>
        public string PartnerAuthorization
        {
            get
            {
                return this.headers[AvatarServicesCommon.PARTNER_AUTHORIZATION];
            }
            set
            {
                if (value == null)
                {
                    // After a header is set, setting to null nolonger sets the value to null. It sets it to empty string.
                    this.headers.Remove(AvatarServicesCommon.PARTNER_AUTHORIZATION);

                    return;
                }

                this.headers[AvatarServicesCommon.PARTNER_AUTHORIZATION] = value;
            }
        }

        /// <summary>
        /// Gets or sets the User Authorization Token. 
        /// Setting to Null will cause the User Token not to be sent
        /// </summary>
        public string UserAuthorization
        {
            get
            {
                return this.headers[AvatarServicesCommon.USER_AUTHORIZATION];
            }
            set
            {
                if (value == null)
                {
                    // After a header is set, setting to null nolonger sets the value to null. It sets it to empty string.
                    this.headers.Remove(AvatarServicesCommon.USER_AUTHORIZATION);

                    return;
                }

                this.headers[AvatarServicesCommon.USER_AUTHORIZATION] = value;
            }
        }

        /// <summary>
        /// Gets or sets the header value used to determine what the Content Type that's contained within the request
        /// </summary>
        public string ContentType
        {
            get
            {
                return this.headers[HttpRequestHeader.ContentType];
            }
            set
            {
                this.headers[HttpRequestHeader.ContentType] = value;
            }
        }

        /// <summary>
        /// Gets or sets the header value used to determine what kind of browser you are. Example: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; InfoPath.3; MS-RTC LM 8)
        /// </summary>
        public string UserAgent
        {
            get
            {
                return this.headers[HttpRequestHeader.UserAgent];
            }
            set
            {
                this.headers[HttpRequestHeader.UserAgent] = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.AvatarServices\ManifestWriteClient_Partner\ManifestWritePartnerClientResponse.cs ===
﻿//---------------------------------------------------------------------
// Copyright (C) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------
namespace LiveN.Test
{
    using System.Net;

    /// <summary>
    /// Client used to interact with the Manifest Write Origin Response
    /// </summary>
    public class ManifestWritePartnerClientResponse : HttpClientResponse
    {
        public ManifestWritePartnerClientResponse(HttpWebRequest request)
            : base(request)
        {
        }

        /// <summary>
        /// Serilizes the response body into a response object
        /// </summary>
        public ManifestWriteResponseBody BodyWrapper
        {
            get
            {
                return ManifestWriteResponseBody.DeserializeXml<ManifestWriteResponseBody>(this.Body);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.AvatarServices\ManifestWriteClient_Partner\ManifestWritePartnerHeaders.cs ===
﻿//---------------------------------------------------------------------
// Copyright (C) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------
namespace LiveN.Test
{
    using System;
    using System.Net;

    /// <summary>
    /// Headers for the Manifest Write Partner Request
    /// </summary>
    public class ManifestWritePartnerHeaders : WebHeaderCollection
    {
        /// <summary>
        /// Header Collection to add or pull the header information from
        /// </summary>
        internal WebHeaderCollection headers;

        /// <summary>
        /// Create a collection of Headers
        /// </summary>
        public ManifestWritePartnerHeaders()
        {
            headers = new WebHeaderCollection();
        }

        /// <summary>
        /// Create a collection of Headers based off the passed in collection
        /// </summary>
        /// <param name="headers">Header Collection to add or pull the header information from</param>
        public ManifestWritePartnerHeaders(WebHeaderCollection headers)
        {
            if (headers == null)
            {
                throw new ArgumentNullException("headers");
            }

            this.headers = headers;
        }

        /// <summary>
        /// Gets or sets the Platform Type that's making the request
        /// </summary>
        public string PlatformType
        {
            get
            {
                return this.headers[AvatarServicesCommon.PLATFORM_TYPE];
            }
            set
            {
                this.headers[AvatarServicesCommon.PLATFORM_TYPE] = value;
            }
        }

        /// <summary>
        /// Gets or sets the Partner Authorization Token. 
        /// Setting to Null will cause the Partner Token not to be sent
        /// </summary>
        public string PartnerAuthorization
        {
            get
            {
                return this.headers[AvatarServicesCommon.PARTNER_AUTHORIZATION];
            }
            set
            {
                if (value == null)
                {
                    // After a header is set, setting to null nolonger sets the value to null. It sets it to empty string.
                    this.headers.Remove(AvatarServicesCommon.PARTNER_AUTHORIZATION);

                    return;
                }

                this.headers[AvatarServicesCommon.PARTNER_AUTHORIZATION] = value;
            }
        }

        /// <summary>
        /// Gets or sets the User Authorization Token. 
        /// Setting to Null will cause the User Token not to be sent
        /// </summary>
        public string UserAuthorization
        {
            get
            {
                return this.headers[AvatarServicesCommon.USER_AUTHORIZATION];
            }
            set
            {
                if (value == null)
                {
                    // After a header is set, setting to null nolonger sets the value to null. It sets it to empty string.
                    this.headers.Remove(AvatarServicesCommon.USER_AUTHORIZATION);

                    return;
                }

                this.headers[AvatarServicesCommon.USER_AUTHORIZATION] = value;
            }
        }

        /// <summary>
        /// Gets or sets the header value used to determine what the Content Type that's contained within the request
        /// </summary>
        public string ContentType
        {
            get
            {
                return this.headers[HttpRequestHeader.ContentType];
            }

            set
            {
                this.headers[HttpRequestHeader.ContentType] = value;
            }
        }

        /// <summary>
        /// Gets or sets the header value used to determine what kind of browser you are. Example: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; InfoPath.3; MS-RTC LM 8)
        /// </summary>
        public string UserAgent
        {
            get
            {
                return this.headers[HttpRequestHeader.UserAgent];
            }

            set
            {
                this.headers[HttpRequestHeader.UserAgent] = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.AvatarServices\ManifestWriteClient_Partner\ManifestWritePartnerClientRequest.cs ===
﻿//---------------------------------------------------------------------
// Copyright (C) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------
using System;
using System.Net;
using System.Text;

using LiveNew.Test;

using Infrastructure.Test;

namespace LiveN.Test
{
    /// <summary>
    /// Client used to interact with the Manifest Write Partner API
    /// </summary>
    public class ManifestWritePartnerClientRequest : HttpClientRequest
    {
        /// <summary>
        /// All Header Values that will accompany the request within the header
        /// </summary>
        public new readonly ManifestReadPartnerHeaders Headers;

        /// <summary>
        /// Get or set the Environment this object uses to do it's communications
        /// </summary>
        private EnvironmentElement CurrentEnvironment
        {
            get
            {
                if (memberCurrentEnvironment != null)
                {
                    return memberCurrentEnvironment;
                }

                // Environment has not been specified, use the common one.
                return CurrentEnvironmentSettings.SelectedEnvironment;
            }
            set
            {
                // Set auth to null so it gets updated
                memberAuth = null;

                memberCurrentEnvironment = value;
            }
        }
        private EnvironmentElement memberCurrentEnvironment = null;

        /// <summary>
        /// Get the Authentication Cache used to cache user data
        /// </summary>
        private EnvironmentAwareAuthCache Auth
        {
            get
            {
                if (memberAuth == null)
                {
                    memberAuth = new EnvironmentAwareAuthCache(CurrentEnvironment);
                }

                return memberAuth;
            }
        }
        private EnvironmentAwareAuthCache memberAuth = null;

        /// <summary>
        /// Create a default instance with all default properties based off the global LiveN configuration settings
        /// </summary>
        public ManifestWritePartnerClientRequest(string userEmail, string password)
            : this(CurrentEnvironmentSettings.SelectedEnvironment, userEmail, password)
        {
        }

        /// <summary>
        /// Create a default instance with all default properties to
        /// </summary>
        /// <param name="runEnvironment">Environment used to control where this instance will call</param>
        public ManifestWritePartnerClientRequest(EnvironmentElement runEnvironment, string userEmail, string password)
            : this(runEnvironment, runEnvironment.ManifestWritePartService.OriginalString, userEmail, password)
        {
        }

        /// <summary>
        /// Create a default instance with all default properties to
        /// </summary>
        /// <param name="url">ManifestRead's Partner url used to call the service</param>
        public ManifestWritePartnerClientRequest(string url, string userEmail, string password)
            : this(null, CurrentEnvironmentSettings.SelectedEnvironment.ManifestWritePartService.OriginalString, userEmail, password)
        {
        }

        /// <summary>
        /// Create a default instance with all default properties to
        /// </summary>
        /// <param name="runEnvironment">Environment used to control where this instance will call</param>
        /// <param name="url">ManifestRead's Partner url used to call the service</param>
        public ManifestWritePartnerClientRequest(EnvironmentElement runEnvironment, string url, string userEmail, string password)
        {
            UriBuilder uri = new UriBuilder(url);

            CurrentEnvironment = runEnvironment;

            this.UserEmail = userEmail;
            this.Password = password;

            // Set title to the first one. As for default test cases, the specific title does not matter.
            this.Title = CurrentEnvironment.Titles[0];

            this.Host = uri.Host;
            this.Port = uri.Port;
            this.Path = "Manifest.svc/Update";

            this.Method = HttpMethods.POST;
            this.SetAuthenticationToken = true;
            this.RequestedToken = RequestedTokenEnum.PartnerToken;

            this.Headers = new ManifestReadPartnerHeaders();

            this.ContentWrapper = new ManifestWriteRequestContent();

            // Set the Header Collection so the base class uses our custom Headers
            this.HeaderCollection = this.Headers.headers;

            // Set all the default values
            this.Headers.PlatformType = "15";
            this.Headers.ContentType = "application/xml";
            this.Headers.UserAgent = "LiveN Test Request";
        }

        /// <summary>
        /// Gets or sets the value indicating that the request should be authenticated or not.
        /// </summary>
        public bool SetAuthenticationToken
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the Token that will be sent within the request
        /// </summary>
        public RequestedTokenEnum RequestedToken
        {
            get;
            set;
        }

        /// <summary>
        /// Get the Http Web Request that would be generated via the current properties
        /// </summary>
        /// <remarks>Dynamically generated. So calling sparingly.</remarks>
        public override HttpWebRequest Request
        {
            get
            {
                if (this.SetAuthenticationToken)
                {
                    if (this.RequestedToken == RequestedTokenEnum.PartnerToken)
                    {
                        // Partner Authorization is not Overriden. So get one before constructing the request. 
                        this.Headers.PartnerAuthorization = AvatarServicesCommon.AUTH_PREFIX + Auth.GetPartnerToken(this.UserEmail, this.Password, this.Title, AvatarServicesCommon.AUDIENCE_URI);
                    }
                    else if (this.RequestedToken == RequestedTokenEnum.UserToken)
                    {
                        // User Authorization is not Overriden. So get one before constructing the request. 
                        this.Headers.UserAuthorization = AvatarServicesCommon.AUTH_PREFIX + Auth.GetUserToken(this.UserEmail, this.Password, this.Title);
                    }
                    else
                    {
                        throw new Exception("Newly added Token type " + this.RequestedToken.ToString() + " needs to be supported here.");
                    }
                }

                return base.Request;
            }
        }

        /// <summary>
        /// Email address of the user that will be used for partner token authentication
        /// </summary>
        public string UserEmail
        {
            get;
            set;
        }

        /// <summary>
        /// Password of the user that will be used for partner token authentication
        /// </summary>
        public string Password
        {
            get;
            set;
        }

        /// <summary>
        /// Title of the user that will be used for partner token authentication
        /// </summary>
        public TitleElement Title
        {
            get;
            set;
        }

        #region IHttpClientPostDataAbstract Members

            /// <summary>
            /// Content contained within the the post
            /// </summary>
            public override byte[] Content
            {
                get
                {
                    if (this.ContentWrapper == null)
                    {
                        return null;
                    }

                    return Encoding.UTF8.GetBytes(this.ContentWrapper.SerializeToXmlString());
                }

                set
                {
                    if (value == null)
                    {
                        this.ContentWrapper = null;

                        return;
                    }

                    SetPostContentXml(Encoding.UTF8.GetString(value));
                }
            }
        #endregion

        /// <summary>
        /// Post Content Data wrapped with a serilizable object
        /// </summary>
        public ManifestWriteRequestContent ContentWrapper
        {
            get;
            set;
        }

        /// <summary>
        /// Make a request to the Manifest Write Partner API using the given properties
        /// </summary>
        /// <returns>Returns an Manifest Write Client Response</returns>
        public new ManifestWritePartnerClientResponse MakeARequest()
        {
            return new ManifestWritePartnerClientResponse(this.Request);
        }

        /// <summary>
        /// Set the Manifest Write xml into the Post Content Data object
        /// </summary>
        /// <param name="postContentData">Xml to be serilized into the Post Data Structure</param>
        public void SetPostContentXml(string postContentData)
        {
            if (string.IsNullOrEmpty(postContentData))
            {
                throw new ArgumentException("postContentData");
            }

            this.ContentWrapper = (ManifestWriteRequestContent)SerializerExtension.DeserializeXml<ManifestWriteRequestContent>(postContentData);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.AvatarServices\QueryBuilders\Parameters\Parameter_GamerTag.cs ===
﻿//---------------------------------------------------------------------
// Copyright (C) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------
namespace LiveN.Test
{
    using System;

    /// <summary>
    /// Definition for the a query parameter
    /// </summary>
    public class Parameter_GamerTag : QueryParameter
    {
        /// <summary>
        /// Name of the parameter
        /// </summary>
        public new const string ParameterName = "gt";

        /// <summary>
        /// Create an instance
        /// </summary>
        public Parameter_GamerTag()
            : base(ParameterName)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.AvatarServices\ManifestWriteClient_Partner\ManifestWriteResponseBody.cs ===
﻿//---------------------------------------------------------------------
// Copyright (C) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------
namespace LiveN.Test
{
    using System.Xml;
    using System.Xml.Serialization;

    using Infrastructure.Test;

    /// <summary>
    /// Models the ManifestWrite Response XML that the service will return to the client 
    /// </summary>
    [XmlRoot(ElementName = "UpdateManifestResponse", Namespace = "http://schemas.datacontract.org/2004/07/Avatar.Services.ManifestWrite.Library")]
    public class ManifestWriteResponseBody : SerializerExtension
    {
        /// <summary>
        /// Status code
        /// </summary>
        public int SuccessCode;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.AvatarServices\QueryBuilders\Parameters\Parameter_PlatformID.cs ===
﻿//---------------------------------------------------------------------
// Copyright (C) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------
namespace LiveN.Test
{
    using System;

    /// <summary>
    /// Definition for the a query parameter
    /// </summary>
    public class Parameter_PlatformType : QueryParameter
    {
        /// <summary>
        /// Name of the parameter
        /// </summary>
        public new const string ParameterName = "PlatformType";

        /// <summary>
        /// Create an instance
        /// </summary>
        public Parameter_PlatformType()
            : base(ParameterName)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.AvatarServices\ManifestWriteClient_Partner\ManifestWriteRequestContent.cs ===
﻿namespace LiveN.Test
{
    using System.Xml;
    using System.Xml.Serialization;

    using Infrastructure.Test;

    /// <summary>
    /// Instance of Manifest Write Request Content.
    /// </summary>
    [XmlRoot("UpdateManifestRequest")]
    public class ManifestWriteRequestContent : SerializerExtension
    {
        public ManifestWriteRequestContent()
        {
            // Set the default namespace
            this.Xmlns = new System.Xml.Serialization.XmlSerializerNamespaces
                        (
                            new XmlQualifiedName[] 
                                { 
                                    new XmlQualifiedName(string.Empty, "http://schemas.datacontract.org/2004/07/Avatar.Services.ManifestWrite.Library")
                                }
                        );
        }

        /// <summary>
        /// Manifest to be writen to user profile
        /// </summary>
        public string Manifest 
        { 
            get;
            set; 
        }

        /// <summary>
        /// Converts object to xml string representation
        /// </summary>
        /// <returns>Serialized object as an XML string</returns>
        public override string SerializeToXmlString()
        {
            string output = string.Empty;

            output = base.SerializeToXmlString(false);

            // Remove side affect of using the xml Serilizer
            output = output.Remove(0, ((string)"<?xml version=\"1.0\" encoding=\"utf-8\"?>").Length);

            // Hack, but it's better then using the DataContractSerializer, DataContractSerializeToXmlString, as it requires a specific namespace and class naming.
            output = output.Replace("xmlns=\"", "xmlns:i=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"");
            
            return output;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.AvatarServices\QueryBuilders\Parameters\Parameter_TitleID.cs ===
﻿//---------------------------------------------------------------------
// Copyright (C) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------
namespace LiveN.Test
{
    using System;

    /// <summary>
    /// Definition for the a query parameter
    /// </summary>
    public class Parameter_TitleID : QueryParameter
    {
        /// <summary>
        /// Name of the parameter
        /// </summary>
        public new const string ParameterName = "TitleID";

        /// <summary>
        /// Create an instance
        /// </summary>
        public Parameter_TitleID()
            : base(ParameterName)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.PDLCServices\ConsumeAssets\ConsumeAssetsClientResponse.cs ===
﻿//---------------------------------------------------------------------
// Copyright (C) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------
using System;
using System.Net;
using System.Xml;

namespace LiveN.Test
{
    /// <summary>
    /// Client used to interact with the Response
    /// </summary>
    public class ConsumeAssetsClientResponse : PDLCBaseResponse
    {
        public ConsumeAssetsClientResponse(HttpWebRequest request)
            : base(request)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.PDLCServices\ServiceErrorMessage.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Infrastructure.Test;
using System.Xml.Serialization;

namespace LiveN.Test
{
    /// <summary>
    /// Custom Error Message for LIVEnServices
    /// </summary>
    [XmlRoot(ElementName = "PdlcServiceErrorMessage", Namespace = "http://schemas.datacontract.org/2010/12/PDLC.Contracts")]
    public class PdlcServiceErrorMessage : SerializerExtension
    {
        /// <summary>
        /// Gets or sets the Error Code Bucket used for messaging to the customer
        /// </summary>
        public string Bucket { get; set; }

        /// <summary>
        /// Gets or sets LIVEn OR XBL Error code
        /// </summary>
        public uint ErrorCode { get; set; }

        /// <summary>
        /// Gets or sets detailed Error Message
        /// </summary>
        public string ErrorMessage { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.PDLCServices\PDLCServices.Common.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace LiveN.Test
{
    /// <summary>
    /// Contains any information that can be used by any / all the PDLC Services
    /// </summary>
    public static partial class PDLCServicesCommon
    {
        /// <summary>
        /// Header name used for the profile locale of the Gamer
        /// </summary>
        public const string LOCALE = "X-Locale";

        /// <summary>
        /// Header name used for the platform the request is coming from
        /// </summary>
        public const string PLATFORM_TYPE = "X-Platform-Type";

        /// <summary>
        /// Partner Authorization Token
        /// </summary>
        public const string PARTNER_AUTHORIZATION = "X-PartnerAuthorization";

        /// <summary>
        /// Used to prefix the partner token
        /// </summary>
        public const string AUTH_PREFIX = "XBL1.0 x=";

        /// <summary>
        /// Audience used to sign an partner token against 
        /// </summary>
        public const string AUDIENCE_URI = "http://xboxlive.com/pdlc";

        /// <summary>
        /// HBI Audience used to sign an partner token against 
        /// </summary>
        public const string AUDIENCE_URI_HBI = "http://xboxlive.com/pdlc/purchase";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.PDLCServices\ConsumeAssets\ConsumeAssetsClientRequest.cs ===
﻿//---------------------------------------------------------------------
// Copyright (C) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------
using System;
using System.Net;
using System.Text;
using LiveNew.Test;
using Infrastructure.Test;

namespace LiveN.Test
{
    /// <summary>
    /// Client used to interact with the ConsumeAssets API
    /// </summary>
    public class ConsumeAssetsClientRequest : PDLCBaseRequest
    {
        /// <summary>
        /// Create a default instance with all default properties based off the global LiveN configuration settings
        /// </summary>
        public ConsumeAssetsClientRequest(string userEmail, string password)
            : this(CurrentEnvironmentSettings.SelectedEnvironment, userEmail, password)
        {           
        }

        /// <summary>
        /// Create a default instance with all default properties to
        /// </summary>
        /// <param name="runEnvironment">Environment to pull configuration settings based off of</param>
        public ConsumeAssetsClientRequest(EnvironmentElement runEnvironment, string userEmail, string password)
            : base(runEnvironment, userEmail, password)
        {
            this.Method = HttpMethods.POST;
            this.Path = "pdlc.svc/v1/assets";

            this.RequestContent = new ConsumeAssetsRequestContent();
        }

        /// <summary>
        /// Make a request to the ConsumeAssets API using the given properties
        /// </summary>
        /// <returns>Returns an response object</returns>
        public new ConsumeAssetsClientResponse MakeARequest()
        {
            return new ConsumeAssetsClientResponse(this.Request);
        }

        public ConsumeAssetsRequestContent RequestContent
        {
            get;
            set;
        }

        public override byte[] Content
        {
            get
            {
                if (this.RequestContent == null)
                {                    
                    return base.Content;
                }

                return Encoding.UTF8.GetBytes(this.RequestContent.SerializeToXmlString());
            }
            set
            {
                if (value == null)
                {
                    this.RequestContent = null;
                    return;
                }

                string contentString = Encoding.UTF8.GetString(value);
                if (string.IsNullOrEmpty(contentString))
                {
                    this.RequestContent = null;
                    return;
                }

                this.RequestContent = (ConsumeAssetsRequestContent)SerializerExtension.DeserializeXml<ConsumeAssetsRequestContent>(contentString);
            }
        }

        /// <summary>
        /// Overrrides default content that gets sent
        /// </summary>
        /// <param name="content">Content to be put into the request</param>
        public void SetContent(string content)
        {
            this.RequestContent = null;

            base.Content = System.Text.ASCIIEncoding.ASCII.GetBytes(content);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.PDLCServices\GamerContext\GamerContextClientResponse.cs ===
﻿//---------------------------------------------------------------------
// Copyright (C) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------
using System;
using System.Net;

namespace LiveN.Test
{
    /// <summary>
    /// Client used to interact with the response
    /// </summary>
    public class GamerContextClientResponse : PDLCBaseResponse
    {
        public GamerContextClientResponse(HttpWebRequest request)
            : base(request)
        {
        }

        /// <summary>
        /// Serilizes the response body into a response object
        /// </summary>
        public GamerContextResponseBody BodyWrapper
        {
            get
            {
                try
                {
                    return GamerContextResponseBody.DeserializeXml<GamerContextResponseBody>(this.Body);
                }
                catch (Exception exc)
                {
                    throw new Exception("Had a problem deserializing the response body. \r\nRESPONSE BODY:\r\n" + this.Body + "\r\nEXCEPTION:\r\n" + exc);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.PDLCServices\ConsumeAssets\ConsumeAssetsRequestContent.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml.Serialization;
using System.Runtime.Serialization;
using System.IO;

using Infrastructure.Test;

namespace LiveN.Test
{
     /// <summary>
    /// Request to Consume Assets
    /// </summary>
    [XmlRoot(ElementName = "ConsumeRequest")]
    public class ConsumeAssetsRequestContent : SerializerExtension
    {
        public ConsumeAssetsRequestContent()
        {
            this.Xmlns = new XmlSerializerNamespaces();
            this.Xmlns.Add("", "http://schemas.datacontract.org/2010/12/PDLC.Contracts");
            this.Xmlns.Add("i", "http://www.w3.org/2001/XMLSchema-instance");

            Clear();
        }

        /// <summary>
        /// Gets or sets the TitleId to get receipts for. 
        /// </summary>
        [XmlElement(ElementName = "TitleId")]
        public string TitleId { get; set; }

        /// <summary>
        /// Gets or sets the TransactionId of the request. 
        /// </summary>
        [XmlElement(ElementName = "TransactionId")]
        public string TransactionId { get; set; }

        /// <summary>
        /// Gets or sets the list of Assets to consume. 
        /// </summary>
        [XmlArray(ElementName = "AssetsToConsume"), XmlArrayItem(ElementName = "Asset", Namespace = "http://schemas.datacontract.org/2010/12/PDLC.Contracts")]
        public Asset[] AssetsToConsume { get; set; }

        /// <summary>
        /// Clears the request object with the default values
        /// </summary>
        public void Clear()
        {
            this.TitleId = string.Empty;
            this.TransactionId = string.Empty;
            this.AssetsToConsume = null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.PDLCServices\GamerContext\GamerContextClientRequest.cs ===
﻿//---------------------------------------------------------------------
// Copyright (C) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------
namespace LiveN.Test
{
    using System;
    using System.Net;
    using System.Text;

    using LiveNew.Test;

    using Infrastructure.Test;
    
    /// <summary>
    /// Client used to interact with the API
    /// </summary>
    public class GamerContextClientRequest : PDLCBaseRequest
    {
        /// <summary>
        /// Create a default instance with all default properties based off the global LiveN configuration settings
        /// </summary>
        public GamerContextClientRequest(string userEmail, string password)
            : this(CurrentEnvironmentSettings.SelectedEnvironment, userEmail, password)
        {
        }

        /// <summary>
        /// Create a default instance with all default properties to
        /// </summary>
        /// <param name="runEnvironment">Environment to pull configuration settings based off of</param>
        public GamerContextClientRequest(EnvironmentElement runEnvironment, string userEmail, string password)
            : base(runEnvironment, userEmail, password)
        {
            this.Method = HttpMethods.GET;
            this.Path = "Pdlc.svc/v1/context";
        }

        /// <summary>
        /// Make a request to the GamerContext API using the given properties
        /// </summary>
        /// <returns>Returns an GamerContext Response</returns>
        public new GamerContextClientResponse MakeARequest()
        {
            return new GamerContextClientResponse(this.Request);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.PDLCServices\GamerContext\GamerContextResponseBody.cs ===
﻿//---------------------------------------------------------------------
// Copyright (C) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------
using System;
using System.Xml.Serialization;

using Infrastructure.Test;

namespace LiveN.Test
{
    /// <summary>
    /// Models the GetContext XML that the service will return to the client. 
    /// GamerContext for enumerating offers from XBL marketplace catalog.
    /// </summary>
    [XmlRoot(ElementName = "GamerContext", Namespace = "http://schemas.datacontract.org/2010/12/PDLC.Contracts")]
    public class GamerContextResponseBody : SerializerExtension
    {
        /// <summary>
        /// Gets or sets the time when the context expires.
        /// </summary>
        public DateTime Expires
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the XBL Marketplace Catalog URL. 
        /// </summary>
        public string XblMarketplaceCatalogUrl
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the Avatar Marketplace Url (Old XBL Marketplace). 
        /// </summary>
        public string AvatarMarketplaceUrl
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the URL to Mobile Optimized page for adding points. 
        /// </summary>
        public string MOPageAddPointsUrl
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the URL to Mobile Optimized page for setting up account billing info.
        /// </summary>
        public string MOPageSetupBillingUrl
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the URL to Mobile Optimized page for Terms Of Use (TOU).
        /// </summary>
        public string MOPageTouUrl
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the legal locale of the user. 
        /// </summary>
        public string LegalLocale
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the UserType of the user
        /// </summary>
        public int UserType
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the current balance of Microsoft Points.
        /// </summary>
        public uint PointsBalance
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the AvatarBodyType of the user. 
        /// </summary>
        public int AvatarBodyType
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the permission for purchasing PDLC.
        /// </summary>
        public bool CanPurchasePDLC
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets if the gamer's account is lightweight.
        /// </summary>
        public bool IsLightweightAccount
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.PDLCServices\GetAssets\GetAssetsClientRequest.cs ===
﻿//---------------------------------------------------------------------
// Copyright (C) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------
using System;
using System.Net;

using LiveNew.Test;

namespace LiveN.Test
{
    /// <summary>
    /// Client used to interact with the GetAssets API
    /// </summary>
    public class GetAssetsClientRequest : PDLCBaseRequest
    {
        /// <summary>
        /// Query string parameters 
        /// </summary>
        public readonly GetAssetsQueryParmeters QueryParameters;

        /// <summary>
        /// Create a default instance with all default properties based off the global LiveN configuration settings
        /// </summary>
        public GetAssetsClientRequest(string userEmail, string password)
            : this(CurrentEnvironmentSettings.SelectedEnvironment, userEmail, password)
        {
        }

        /// <summary>
        /// Create a default instance with all default properties to
        /// </summary>
        /// <param name="runEnvironment">Environment to pull configuration settings based off of</param>
        public GetAssetsClientRequest(EnvironmentElement runEnvironment, string userEmail, string password)
            : base(runEnvironment, userEmail, password)
        {
            this.Method = HttpMethods.GET;
            this.Path = "pdlc.svc/v1/assets";

            QueryParameters = new GetAssetsQueryParmeters();

            // Set the Query Builder to use the same structure 
            this.QueryBuilder = this.QueryParameters.QueryBuilder;
        }

        /// <summary>
        /// Make a request to the GetAssets API using the given properties
        /// </summary>
        /// <returns>Returns an response object</returns>
        public new GetAssetsClientResponse MakeARequest()
        {
            return new GetAssetsClientResponse(this.Request);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.PDLCServices\GetAssets\GetAssetsQueryParmeters.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace LiveN.Test
{
    /// <summary>
    /// Structure used to store all the Query Parameters for this API
    /// </summary>
    public class GetAssetsQueryParmeters
    {
        public readonly QueryStringBuilder QueryBuilder;

        public const string TitleIdParm = "titleId";
        public const string SignAssetsParm = "signAssets";

        public GetAssetsQueryParmeters()
        {
            this.QueryBuilder = new QueryStringBuilder();
        }

        /// <summary>
        /// TitleId of where the Assets you want returend
        /// </summary>
        /// <remarks>Setting to null will cause this parameter to not be passed</remarks>
        public string TitleId
        {
            get
            {
                return this.QueryBuilder[TitleIdParm].Value;
            }
            set
            {
                if (!this.QueryBuilder.ContainsKey(TitleIdParm))
                {
                    this.QueryBuilder[TitleIdParm] = new QueryParameter(TitleIdParm);
                }

                this.QueryBuilder[TitleIdParm].Value = value;
            }
        }

        /// <summary>
        /// (Optional) Gets or sets a value indicating whether the requested response should be signed. 
        /// </summary>
        /// <remarks>Setting to null will cause this parameter to not be passed</remarks>
        public string SignAssets
        {
            get
            {
                return this.QueryBuilder[SignAssetsParm].Value;
            }
            set
            {
                if (!this.QueryBuilder.ContainsKey(SignAssetsParm))
                {
                    this.QueryBuilder[SignAssetsParm] = new QueryParameter(SignAssetsParm);
                }

                this.QueryBuilder[SignAssetsParm].Value = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.PDLCServices\GetAssets\GetAssetsClientResponse.cs ===
﻿//---------------------------------------------------------------------
// Copyright (C) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------
using System;
using System.Net;
using System.Security.Cryptography.Xml;
using System.Xml;
using System.IO;
using Infrastructure.Test;
using System.Runtime.Serialization;

namespace LiveN.Test
{
    /// <summary>
    /// Client used to interact with the Response
    /// </summary>
    public class GetAssetsClientResponse : PDLCBaseResponse
    {
        public GetAssetsClientResponse(HttpWebRequest request)
            : base(request)
        {
        }

        /// <summary>
        /// Parses the response body into a response object
        /// </summary>
        public GetAssetsResponseBody BodyWrapper
        {
            get
            {
                try
                {
                    GetAssetsResponseBody wrapper = SerializerExtension.DeserializeDataContract<GetAssetsResponseBody>(this.Body);
                    wrapper.XMLInput = this.Body;
                    return wrapper;
                }
                catch (Exception exc)
                {
                    throw new Exception("Had a problem parsing the response body. \r\nRESPONSE BODY:\r\n" + this.Body + "\r\nEXCEPTION:\r\n" + exc);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.PDLCServices\GetPointsBalance\GetPointsBalanceClientRequest.cs ===
﻿//---------------------------------------------------------------------
// Copyright (C) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------
using System;
using System.Net;

using LiveNew.Test;

namespace LiveN.Test
{
    /// <summary>
    /// Client used to interact with the GetPointsBalance API
    /// </summary>
    public class GetPointsBalanceClientRequest : PDLCBaseRequest
    {
        /// <summary>
        /// Create a default instance with all default properties based off the global LiveN configuration settings
        /// </summary>
        public GetPointsBalanceClientRequest(string userEmail, string password)
            : this(CurrentEnvironmentSettings.SelectedEnvironment, userEmail, password)
        {
        }

        /// <summary>
        /// Create a default instance with all default properties to
        /// </summary>
        /// <param name="runEnvironment">Environment to pull configuration settings based off of</param>
        public GetPointsBalanceClientRequest(EnvironmentElement runEnvironment, string userEmail, string password)
            : base(runEnvironment, userEmail, password)
        {
            this.Method = HttpMethods.GET;
            this.Path = "pdlc.svc/v1/pointsbalance";   
        }

        /// <summary>
        /// Make a request to the GetPointsBalance API using the given properties
        /// </summary>
        /// <returns>Returns an response object</returns>
        public new GetPointsBalanceClientResponse MakeARequest()
        {
            return new GetPointsBalanceClientResponse(this.Request);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.PDLCServices\GetPointsBalance\GetPointsBalanceClientResponse.cs ===
﻿//---------------------------------------------------------------------
// Copyright (C) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------
using System;
using System.Net;
using System.Xml;

namespace LiveN.Test
{
    /// <summary>
    /// Client used to interact with the Response
    /// </summary>
    public class GetPointsBalanceClientResponse : PDLCBaseResponse
    {
        public GetPointsBalanceClientResponse(HttpWebRequest request)
            : base(request)
        { 
        }

        /// <summary>
        /// Parses the response body into a response object
        /// </summary>
        public GetPointsBalanceResponseBody BodyWrapper
        {
            get
            {
                try
                {
                    XmlDocument doc = new XmlDocument();
                    GetPointsBalanceResponseBody responseBody = new GetPointsBalanceResponseBody();
                    
                    doc.LoadXml(this.Body);

                    if (doc.FirstChild.Name != "unsignedInt")
                    {
                        throw new Exception("First element should be unsignedInt. Make sure the response object did not change.");
                    }

                    responseBody.PointsBalance = uint.Parse(doc.FirstChild.InnerText);

                    return responseBody;
                }
                catch (Exception exc)
                {
                    throw new Exception("Had a problem parsing the response body. \r\nRESPONSE BODY:\r\n" + this.Body + "\r\nEXCEPTION:\r\n" + exc);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.PDLCServices\GetPointsBalance\GetPointsBalanceResponseBody.cs ===
﻿//---------------------------------------------------------------------
// Copyright (C) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------
namespace LiveN.Test
{
    /// <summary>
    /// Response body for Get Points Balance
    /// </summary>
    public class GetPointsBalanceResponseBody
    {
        /// <summary>
        /// Gamers Microsoft points balance
        /// </summary>
        public uint PointsBalance;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.PDLCServices\GetReceipts\GetReceiptsClientResponse.cs ===
﻿//---------------------------------------------------------------------
// Copyright (C) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------
using System.Net;
using System.Security.Cryptography.Xml;
using System.Xml;
using System.IO;
using System;
using Infrastructure.Test;
using System.Runtime.Serialization;

namespace LiveN.Test
{
    /// <summary>
    /// Client used to interact with the Response
    /// </summary>
    public class GetReceiptsClientResponse : PDLCBaseResponse
    {
        public GetReceiptsClientResponse(HttpWebRequest request)
            : base(request)
        { 
        }

        /// <summary>
        /// Serilizes the response body into a response object
        /// </summary>
        public GetReceiptsResponseBody BodyWrapper
        {
            get
            {
                try
                {
                    int index = 0;
                    GetReceiptsResponseBody wrapper;

                    wrapper = SerializerExtension.DeserializeDataContract<GetReceiptsResponseBody>(this.Body);

                    wrapper.XMLInput = this.Body;

                    for(int i = 0; i < wrapper.ReceiptsPage.Length; i++)
                    {
                        index = this.Body.IndexOf("<PurchaseReceipt>", index);
 
                        wrapper.ReceiptsPage[i].XMLInput = LiveN.Test.Common.Utility.GetBetween(index, this.Body, "<PurchaseReceipt>", "</PurchaseReceipt>");

                        // Move forward the length of the Receipt in order to move to the next one
                        index += wrapper.ReceiptsPage[i].XMLInput.Length;
                    }

                    return wrapper;
                }
                catch (Exception exc)
                {
                    throw new Exception("Had a problem deserializing the response body. \r\nRESPONSE BODY:\r\n" + this.Body + "\r\nEXCEPTION:\r\n" + exc);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.PDLCServices\GetReceipts\GetReceiptsClientRequest.cs ===
﻿//---------------------------------------------------------------------
// Copyright (C) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------
using System;
using System.Net;
using System.Text;

using LiveNew.Test;

using Infrastructure.Test;

namespace LiveN.Test
{
    /// <summary>
    /// Client used to interact with the PDLC GetReceipts API
    /// </summary>
    public class GetReceiptsClientRequest : PDLCBaseRequest
    {
        /// <summary>
        /// Create a default instance with all default properties based off the global LiveN configuration settings
        /// </summary>
        public GetReceiptsClientRequest(string userEmail, string password)
            : this (CurrentEnvironmentSettings.SelectedEnvironment, userEmail, password)
        { 
        }

        /// <summary>
        /// Create a default instance with all default properties to
        /// </summary>
        /// <param name="runEnvironment">Environment to pull configuration settings based off of</param>
        public GetReceiptsClientRequest(EnvironmentElement runEnvironment, string userEmail, string password)
            : base(runEnvironment, userEmail, password)
        {
            this.Path = "pdlc.svc/v1/receipts";

            this.SetDefaultRequestContent();
        }

        /// <summary>
        /// Post content data wrapped with a serializable object
        /// </summary>
        public GetReceiptsRequestContent RequestContent
        {
            get;
            set;
        }

        public override byte[] Content
        {
            get
            {
                if (this.RequestContent == null)
                {
                    return base.Content;
                }

                return Encoding.UTF8.GetBytes(this.RequestContent.SerializeToXmlString());
            }
            set
            {
                if (value == null)
                {
                    this.RequestContent = null;
                    return;
                }

                string contentString = Encoding.UTF8.GetString(value);
                if (string.IsNullOrEmpty(contentString))
                {
                    this.RequestContent = null;
                    return;
                }

                this.RequestContent = (GetReceiptsRequestContent)SerializerExtension.DeserializeXml<GetReceiptsRequestContent>(contentString);
            }
        }

        /// <summary>
        /// Sets default, valid request content
        /// </summary>
        public void SetDefaultRequestContent()
        {
            this.RequestContent = new GetReceiptsRequestContent();

            this.RequestContent.PageNumber = "1";
            this.RequestContent.PageSize = "10";

            this.RequestContent.TitleId = Convert.ToUInt32(this.Title.Id).ToString();
        }

        /// <summary>
        /// Make a request to the GetReceipts API using the given properties
        /// </summary>
        /// <returns>Returns an response object</returns>
        public new GetReceiptsClientResponse MakeARequest()
        {
            return new GetReceiptsClientResponse(this.Request);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.PDLCServices\GetAssets\GetAssetsResponseBody.cs ===
﻿//---------------------------------------------------------------------
// Copyright (C) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------
using System;
using System.Xml;
using System.Collections.Generic;
using System.Runtime.Serialization;
using System.Security.Cryptography.Xml;
using System.Security.Cryptography.X509Certificates;

namespace LiveN.Test
{
    /// <summary>
    /// MediaAsset in response body for GetAssets
    /// </summary>
    [DataContract(Name = "MediaAsset", Namespace = "http://schemas.datacontract.org/2010/12/PDLC.Contracts")]
    public class MediaAsset:Asset, IEquatable<MediaAsset>
    {
        [DataMember(Name = "MediaInstanceURLs")]
        public List<string> MediaInstanceURLs { get; set; }

        public bool Equals(MediaAsset other)
        {
            if (this.AssetId == other.AssetId && this.MediaInstanceURLs.Count == other.MediaInstanceURLs.Count)
            {
                foreach (string str in other.MediaInstanceURLs)
                {
                    if (this.MediaInstanceURLs.Contains(str))
                    {
                        continue;
                    }
                    else
                    {
                        return false;
                    }
                }
                return true;
            }
            else
            {
                return false;
            }
        }

    }

    /// <summary>
    /// Response body for Get Assets
    /// </summary>
    [DataContract(Name = "MediaAssets", Namespace = "http://schemas.datacontract.org/2010/12/PDLC.Contracts")]
    public class GetAssetsResponseBody
    {
        [DataMember(Name = "MediaAssetsList")]
        public List<MediaAsset> mediaAssets { get; set; }

        #region Code not contained within the actual response. Used to centralize common code
        /// <summary>
        /// Stores the XML that created this object
        /// </summary>
        public string XMLInput;

        /// <summary>
        /// Holds the certificate used to verify the signature
        /// </summary>
        private X509Certificate2 SigningCert
        {
            get
            {
                if (_signingCert == null)
                {
                    _signingCert = new X509Certificate2();
                    _signingCert.Import("dev.xbox.com_SAN.cer");
                }

                return _signingCert;
            }
        }
        private X509Certificate2 _signingCert = null;

        /// <summary>
        /// Gets the value indicating that the signature is valid
        /// </summary>
        public bool IsSignatureValid
        {
            get
            {
                bool ret;
                XmlNodeList nodeList;
                SignedXml signedNode;
                XmlDocument doc = new XmlDocument();

                doc.PreserveWhitespace = true;
                doc.LoadXml(this.XMLInput);

                signedNode = new SignedXml(doc);

                nodeList = doc.GetElementsByTagName("Signature");
                if ((nodeList == null) || (nodeList.Count != 1))
                {
                    return false;
                }

                signedNode.LoadXml((XmlElement)nodeList[0]);

                ret = signedNode.CheckSignature(this.SigningCert, true);

                return ret;
            }
        }
        #endregion Code not contained within the actual response. Used to centralize common code

        public MediaAsset this[uint asset_id]
        {
            get
            {
                foreach (MediaAsset a in mediaAssets)
                {
                    if (a.AssetId == asset_id)
                    {
                        return a;
                    }
                }

                return null;
            }            
        }

        public bool verifyAssetUrls(int _AssetID, List<string> _urls)
        {
            foreach (MediaAsset a in mediaAssets)
            {
                if (a.AssetId == _AssetID)
                {
                    if (a.MediaInstanceURLs.Count == _urls.Count)
                    {
                        foreach (string str in a.MediaInstanceURLs)
                        {

                            if (_urls.Contains(str))
                            {
                                continue;
                            }
                            else
                            {
                                return false;
                            }
                        }
                        return true;
                    }
                }
            }
            return false;
        }        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.PDLCServices\GetReceipts\GetReceiptsHeaders.cs ===
﻿//---------------------------------------------------------------------
// Copyright (C) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------
namespace LiveN.Test
{
    using System;
    using System.Net;

    /// <summary>
    /// Headers for the Request
    /// </summary>
    public class GetReceiptsHeaders : WebHeaderCollection
    {
        /// <summary>
        /// Header Collection to add or pull the header information from
        /// </summary>
        internal WebHeaderCollection headers;

        /// <summary>
        /// Create a collection of Headers
        /// </summary>
        public GetReceiptsHeaders()
        {
            headers = new WebHeaderCollection();
        }

        /// <summary>
        /// Create a collection of Headers based off the passed in collection
        /// </summary>
        /// <param name="headers">Header Collection to add or pull the header information from</param>
        public GetReceiptsHeaders(WebHeaderCollection headers)
        {
            if (headers == null)
            {
                throw new ArgumentNullException("headers");
            }

            this.headers = headers;
        }

        /// <summary>
        /// Gets or sets the gamer's profile locale
        /// </summary>
        public string Locale
        {
            get
            {
                return this.headers[PDLCServicesCommon.LOCALE];
            }

            set
            {
                this.headers[PDLCServicesCommon.LOCALE] = value;
            }
        }

        /// <summary>
        /// Gets or sets the Platform Type that's making the request
        /// </summary>
        public string PlatformType
        {
            get
            {
                return this.headers[PDLCServicesCommon.PLATFORM_TYPE];
            }
            set
            {
                this.headers[PDLCServicesCommon.PLATFORM_TYPE] = value;
            }
        }

        /// <summary>
        /// Gets or sets the Partner Authorization token. 
        /// Setting to Null will cause the default behavior where a partner token will be requested
        /// </summary>
        public string PartnerAuthorization
        {
            get
            {
                return this.headers[PDLCServicesCommon.PARTNER_AUTHORIZATION];
            }
            set
            {
                this.headers[PDLCServicesCommon.PARTNER_AUTHORIZATION] = value;
            }
        }

        /// <summary>
        /// Gets or sets the header value used to determine what the Content Type that's contained within the request
        /// </summary>
        public string ContentType
        {
            get
            {
                return this.headers[HttpRequestHeader.ContentType];
            }

            set
            {
                this.headers[HttpRequestHeader.ContentType] = value;
            }
        }

        /// <summary>
        /// Gets or sets the header value used to determine what kind of browser you are. Example: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; InfoPath.3; MS-RTC LM 8)
        /// </summary>
        public string UserAgent
        {
            get
            {
                return this.headers[HttpRequestHeader.UserAgent];
            }

            set
            {
                this.headers[HttpRequestHeader.UserAgent] = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.PDLCServices\GetReceipts\GetReceiptsResponseBody.cs ===
﻿//---------------------------------------------------------------------
// Copyright (C) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------

using System;
using System.Xml;
using System.Runtime.Serialization;
using System.Security.Cryptography.Xml;
using System.Security.Cryptography.X509Certificates;

namespace LiveN.Test
{
    /// <summary>
    /// Receipt for the purchased item.
    /// </summary>
    [DataContract(Name = "PurchaseReceipts", Namespace = "http://schemas.datacontract.org/2010/12/PDLC.Contracts")]
    public class GetReceiptsResponseBody
    {
        /// <summary>
        /// Gets or sets the Total number of items this User owns
        /// </summary>
        [DataMember(Name = "TotalItems", Order = 1, IsRequired = true)]
        public uint TotalItems { get; set; }

        /// <summary>
        /// Gets or sets the collection of Receipts
        /// </summary>
        [DataMember(Name = "ReceiptsPage", Order = 2, IsRequired = true)]
        public PurchaseReceiptResponseBody[] ReceiptsPage { get; set; }

        #region Code not contained within the actual response. Used to centralize common code
            /// <summary>
            /// Stores the XML that created this object
            /// </summary>
            public string XMLInput;

            /// <summary>
            /// Holds the certificate used to verify the signature
            /// </summary>
            private X509Certificate2 SigningCert
            {
                get
                {
                    if (_signingCert == null)
                    {
                        _signingCert = new X509Certificate2();
                        _signingCert.Import("dev.xbox.com_SAN.cer");
                    }

                    return _signingCert;
                }
            }
            private X509Certificate2 _signingCert = null;

            /// <summary>
            /// Gets the value indicating that the signature is valid
            /// </summary>
            public bool IsSignatureValid
            {
                get
                {
                    bool ret;
                    XmlNodeList nodeList;
                    SignedXml signedNode;
                    XmlDocument doc = new XmlDocument();
                    
                    doc.PreserveWhitespace = true;
                    doc.LoadXml(this.XMLInput);

                    signedNode = new SignedXml(doc);

                    nodeList = doc.GetElementsByTagName("Signature");
                    if ( (nodeList == null) || (nodeList.Count != 1) )
                    {
                        return false;
                    }

                    signedNode.LoadXml((XmlElement)nodeList[0]);

                    ret = signedNode.CheckSignature(this.SigningCert, true);
                   
                    return ret;
                }
            }
        #endregion Code not contained within the actual response. Used to centralize common code
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.PDLCServices\PDLCBase\PDLCBaseResponse.cs ===
﻿//---------------------------------------------------------------------
// Copyright (C) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------
using System;
using System.Net;

namespace LiveN.Test
{
    /// <summary>
    /// Base PDLC Response which takes care of the common response objects
    /// </summary>
    public class PDLCBaseResponse : HttpClientResponse
    {
        /// <summary>
        /// All Header Values that are contained within the header response
        /// </summary>
        public readonly PDLCBaseResponseHeaders Headers;

        public PDLCBaseResponse(HttpWebRequest request)
            : base(request)
        {
            Headers = new PDLCBaseResponseHeaders(this.Response);
        }

        /// <summary>
        /// Gets is the response contained a ServiceErrorMessage. 
        /// </summary>
        public bool IsServiceErrorMessage
        {
            get
            {
                if (!this.Body.Contains("<PdlcServiceErrorMessage "))
                {
                    return false;
                }

                return true;
            }
        }

        /// <summary>
        /// Service Error Message contianing information about the error
        /// </summary>
        public PdlcServiceErrorMessage ServiceErrorMessageWrapper
        {
            get
            {
                PdlcServiceErrorMessage errorMsg = null;

                try
                {
                    errorMsg = PdlcServiceErrorMessage.DeserializeXml<PdlcServiceErrorMessage>(this.Body);
                }
                catch (Exception ex)
                {
                    throw new Exception("There was an error deserializing the response body into ServiceErrorMessage. \r\nResponse Body: \r\n" + this.Body + "\r\nException:\r\n" + ex.ToString());
                }

                return errorMsg;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.PDLCServices\Purchase\Asset.cs ===
﻿using System.Runtime.Serialization;

namespace LiveN.Test
{
    /// <summary>
    /// Asset representing consumables.
    /// </summary>
    [DataContract(Name = "Asset", Namespace = "http://schemas.datacontract.org/2010/12/PDLC.Contracts")]
    public class Asset
    {
        /// <summary>
        /// Gets or sets the AssetId.
        /// </summary>
        [DataMember(Name = "AssetId", Order = 1, IsRequired = true)]
        public uint AssetId { get; set; }

        /// <summary>
        /// Gets or sets the Quantity.
        /// </summary>
        [DataMember(Name = "Quantity", Order = 2, IsRequired = true)]
        public uint Quantity { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.PDLCServices\PDLCBase\PDLCBaseResponseHeader.cs ===
﻿//---------------------------------------------------------------------
// Copyright (C) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------
namespace LiveN.Test
{
    using System;
    using System.Net;

    /// <summary>
    /// Headers for the Request
    /// </summary>
    public class PDLCBaseResponseHeaders : WebHeaderCollection
    {
        /// <summary>
        /// Create a collection of Headers
        /// </summary>
        /// <param name="response"></param>
        public PDLCBaseResponseHeaders(HttpWebResponse response)
        {
            // Make a copy of all the header values into this collection
            foreach (string key in response.Headers.Keys)
            {
                base.Add(key, response.Headers[key]);
            }
        }

        /// <summary>
        /// Gets the cache time limit
        /// </summary>
        public string CacheControl
        {
            get
            {
                return this["Cache-Control"];
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.PDLCServices\GetReceipts\GetReceiptsRequestContent.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml.Serialization;
using Infrastructure.Test;

namespace LiveN.Test
{
    /// <summary>
    /// Request to get receipts for the specified purchases. 
    /// </summary>
    [XmlRoot("ReceiptRequest")]
    public class GetReceiptsRequestContent : SerializerExtension
    {
        public GetReceiptsRequestContent()
        {
            this.Xmlns = new XmlSerializerNamespaces();
            this.Xmlns.Add("", "http://schemas.datacontract.org/2010/12/PDLC.Contracts");
            this.Xmlns.Add("i", "http://www.w3.org/2001/XMLSchema-instance");
        }

        /// <summary>
        /// PageNumber
        /// </summary>
        [XmlElement(ElementName = "PageNumber")]
        public string PageNumber { get; set; }

        /// <summary>
        /// PageSize
        /// </summary>
        [XmlElement(ElementName = "PageSize")]
        public string PageSize { get; set; }

        /// <summary>
        /// Gets or sets the TitleId to get receipts for. 
        /// </summary>
        [XmlElement(ElementName = "TitleId")]
        public string TitleId 
        { 
            get
            {
                if (_titleId == null)
                {

                }

                return _titleId;
            }
            set
            {
                _titleId = value;
            }
        }
        [XmlIgnore]
        private string _titleId = null;

        /// <summary>
        /// (Optional) Gets or sets a value indicating what store the Offers where purchased from.
        /// </summary>
        [XmlElement(ElementName = "StoreId")]
        public string StoreId { get; set; }

        /// <summary>
        /// (Optional) Gets or sets the TransactionIds to get receipts for. 
        /// </summary>
        [XmlArray(ElementName = "TransactionIds"), XmlArrayItem(ElementName = "guid", Namespace = "http://schemas.microsoft.com/2003/10/Serialization/Arrays")]
        public string[] TransactionIds { get; set; }

        /// <summary>
        /// (Optional) Gets or sets the MediaTypeId of the item. 
        /// </summary>
        [XmlElement(ElementName = "MediaTypeId")]
        public string MediaTypeId { get; set; }

        /// <summary>
        /// (Optional) Gets or sets the start date since which receipts are requested. 
        /// </summary>
        [XmlElement(ElementName = "StartDate")]
        public string StartDate { get; set; }

        /// <summary>
        /// (Optional) Gets or sets a value indicating whether the requested receipts should be signed. 
        /// </summary>
        [XmlElement(ElementName = "SignReceipts")]
        public string SignReceipts { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.PDLCServices\PDLCBase\PDLCBaseRequestHeaders.cs ===
﻿//---------------------------------------------------------------------
// Copyright (C) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------
namespace LiveN.Test
{
    using System;
    using System.Net;

    /// <summary>
    /// Headers for the Request
    /// </summary>
    public class PDLCBaseRequestHeaders : WebHeaderCollection
    {
        /// <summary>
        /// Header Collection to add or pull the header information from
        /// </summary>
        internal WebHeaderCollection headers;

        /// <summary>
        /// Create a collection of Headers
        /// </summary>
        public PDLCBaseRequestHeaders()
        {
            headers = new WebHeaderCollection();
        }

        /// <summary>
        /// Create a collection of Headers based off the passed in collection
        /// </summary>
        /// <param name="headers">Header Collection to add or pull the header information from</param>
        public PDLCBaseRequestHeaders(WebHeaderCollection headers)
        {
            if (headers == null)
            {
                throw new ArgumentNullException("headers");
            }

            this.headers = headers;
        }

        /// <summary>
        /// Gets or sets the Platform Type that's making the request
        /// </summary>
        public string PlatformType
        {
            get
            {
                return this.headers[PDLCServicesCommon.PLATFORM_TYPE];
            }
            set
            {
                if (value == null)
                {
                    // After a header is set, setting to null nolonger sets the value to null. It sets it to empty string.
                    this.headers.Remove(PDLCServicesCommon.PLATFORM_TYPE);

                    return;
                }

                this.headers[PDLCServicesCommon.PLATFORM_TYPE] = value;
            }
        }

        /// <summary>
        /// Gets or sets the Partner Authorization token. 
        /// Setting to Null will cause the default behavior where a partner token will be requested
        /// </summary>
        public string PartnerAuthorization
        {
            get
            {
                return this.headers[PDLCServicesCommon.PARTNER_AUTHORIZATION];
            }
            set
            {
                if (value == null)
                {
                    // After a header is set, setting to null nolonger sets the value to null. It sets it to empty string.
                    this.headers.Remove(PDLCServicesCommon.PARTNER_AUTHORIZATION);

                    return;
                }

                this.headers[PDLCServicesCommon.PARTNER_AUTHORIZATION] = value;
            }
        }

        /// <summary>
        /// Gets or sets the header value used to determine what the Content Type that's contained within the request
        /// </summary>
        public string ContentType
        {
            get
            {
                return this.headers[HttpRequestHeader.ContentType];
            }

            set
            {
                if (value == null)
                {
                    // After a header is set, setting to null nolonger sets the value to null. It sets it to empty string.
                    this.headers.Remove(HttpRequestHeader.ContentType);

                    return;
                }

                this.headers[HttpRequestHeader.ContentType] = value;
            }
        }

        /// <summary>
        /// Gets or sets the header value used to determine what kind of browser you are. Example: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; InfoPath.3; MS-RTC LM 8)
        /// </summary>
        public string UserAgent
        {
            get
            {
                return this.headers[HttpRequestHeader.UserAgent];
            }

            set
            {
                if (value == null)
                {
                    // After a header is set, setting to null nolonger sets the value to null. It sets it to empty string.
                    this.headers.Remove(HttpRequestHeader.UserAgent);

                    return;
                }

                this.headers[HttpRequestHeader.UserAgent] = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.PDLCServices\PDLCBase\PDLCBaseRequest.cs ===
﻿using System;
using System.Net;

using LiveNew.Test;

namespace LiveN.Test
{
    /// <summary>
    /// Class describing the basic Pdlc request object
    /// </summary>
    public class PDLCBaseRequest : HttpClientRequest
    {
        /// <summary>
        /// All Header Values that will accompany the request within the header
        /// </summary>
        public new readonly PDLCBaseRequestHeaders Headers;

        /// <summary>
        /// Get or set the environment this class should point to
        /// </summary>
        public EnvironmentElement SelectedEnvironment
        {
            get
            {
                if (_selectedEnvironment == null)
                {
                    return CurrentEnvironmentSettings.SelectedEnvironment;
                }

                return _selectedEnvironment;
            }
            set
            {
                _selectedEnvironment = value;
            }
        }
        private EnvironmentElement _selectedEnvironment = null;

        /// <summary>
        /// Get the Authentication Cache used to cache user data
        /// </summary>
        public EnvironmentAwareAuthCache Auth
        {
            get
            {
                if (memberAuth == null)
                {
                    memberAuth = new EnvironmentAwareAuthCache(this.SelectedEnvironment);
                }

                return memberAuth;
            }
        }
        private EnvironmentAwareAuthCache memberAuth = null;

        /// <summary>
        /// Title ID's id for 61000000
        /// </summary>
        public TitleElement Title61TitleId
        {
            get
            {
                return this.SelectedEnvironment.Titles.Get("Mobile Game 61000000", ConsoleType.WindowsPhone);
            }
        }

        /// <summary>
        /// Title ID's id for 62000000
        /// </summary>
        public TitleElement Title62TitleId
        {
            get
            {
                return this.SelectedEnvironment.Titles.Get("Mobile Game 62000000", ConsoleType.WindowsPhone);
            }
        }

        /// <summary>
        /// Create a default instance with all default properties based off the global LiveN configuration settings
        /// </summary>
        public PDLCBaseRequest(string userEmail, string password)
            : this (CurrentEnvironmentSettings.SelectedEnvironment, userEmail, password)
        { 
        }

        /// <summary>
        /// Create a default instance with all default properties to
        /// </summary>
        /// <param name="runEnvironment">Environment to pull configuration settings based off of</param>
        public PDLCBaseRequest(EnvironmentElement runEnvironment, string userEmail, string password)
        {
            UriBuilder uri;

            this.SelectedEnvironment = runEnvironment;

            uri = new UriBuilder(this.SelectedEnvironment.PDLCServices.OriginalString);

            this.UserEmail = userEmail;
            this.Password = password;

            this.Host = uri.Host;
            this.Port = uri.Port;

            this.Method = HttpMethods.POST;
            this.SetAuthenticationToken = true;

            this.Headers = new PDLCBaseRequestHeaders();

            // Set the Header Collection so the base class uses our custom Headers
            this.HeaderCollection = this.Headers.headers;

            // Set all the default values
            this.SetDefaultHeaderValues();
        }

        /// <summary>
        /// Get the Http Web Request that would be generated via the current properties
        /// </summary>
        /// <remarks>Dynamically generated. So calling sparingly.</remarks>
        public override HttpWebRequest Request
        {
            get
            {
                if (this.SetAuthenticationToken)
                {
                    // Partner Authorization is not Overriden. So get one before constructing the request. 
                    this.Headers.PartnerAuthorization = PDLCServicesCommon.AUTH_PREFIX + Auth.GetPartnerToken(this.UserEmail, this.Password, this.Title, this.AudienceUri);
                }

                return base.Request;
            }
        }

        /// <summary>
        /// Audience uri used for creating a partner token
        /// </summary>
        public virtual string AudienceUri
        {
            get { return PDLCServicesCommon.AUDIENCE_URI; }
        }

        /// <summary>
        /// Email address of the user that will be used for partner token authentication
        /// </summary>
        public string UserEmail
        {
            get;
            set;
        }

        /// <summary>
        /// Password of the user that will be used for partner token authentication
        /// </summary>
        public string Password
        {
            get;
            set;
        }

        /// <summary>
        /// Title of the user that will be used for partner token authentication
        /// </summary>
        public TitleElement Title
        {
            get
            {
                if (_title == null)
                {
                    if (this.SelectedEnvironment.Name.ToLower().Contains("xblob"))
                    {
                        // Title has not been set. Use the default. As this is the game that has all the Offers Associated with it within our Dev environment
                        return this.Title61TitleId;
                    }
                    else
                    {
                        // For all other environment, just use the firs title
                        return this.SelectedEnvironment.Titles[0];
                    }
                }

                return _title;
            }
            set
            {
                _title = value;
            }
        }
        private TitleElement _title = null;

        /// <summary>
        /// Gets or sets the value indicating that the request should be authenticated or not.
        /// </summary>
        public bool SetAuthenticationToken
        {
            get;
            set;
        }

        /// <summary>
        /// Set the default header values
        /// </summary>
        public virtual void SetDefaultHeaderValues()
        {
            this.Headers.PlatformType = ((int)PlatformType.Mobile).ToString();
            this.Headers.ContentType = "application/xml";
            this.Headers.UserAgent = "LiveN Test Request";
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.PDLCServices\VerifyToken\VerifyTokenClientResponse.cs ===
﻿//---------------------------------------------------------------------
// Copyright (C) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------
using System;
using System.Net;

namespace LiveN.Test
{
    /// <summary>
    /// Client used to interact with the response
    /// </summary>
    public class VerifyTokenClientResponse : PDLCBaseResponse
    {
        public VerifyTokenClientResponse(HttpWebRequest request)
            : base(request)
        {
        }

        /// <summary>
        /// Serilizes the response body into a response object
        /// </summary>
        public VerifyTokenResponseBody BodyWrapper
        {
            get
            {
                try
                {
                    VerifyTokenResponseBody wrapper;

                    wrapper = VerifyTokenResponseBody.DeserializeXml<VerifyTokenResponseBody>(this.Body);

                    wrapper.XMLInput = this.Body;

                    return wrapper;
                }
                catch (Exception exc)
                {
                    throw new Exception("Had a problem deserializing the response body. \r\nRESPONSE BODY:\r\n" + this.Body + "\r\nEXCEPTION:\r\n" + exc);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.PDLCServices\Purchase\PurchaseReceiptResponseBody.cs ===
﻿//---------------------------------------------------------------------
// Copyright (C) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace LiveN.Test
{
    /// <summary>
    /// Receipt for the purchased item.
    /// </summary>
    [DataContract(Name = "PurchaseReceipt", Namespace = "http://schemas.datacontract.org/2010/12/PDLC.Contracts")]
    public class PurchaseReceiptResponseBody
    {
        /// <summary>
        /// Gets or sets the TransactionId of the matching purchase.
        /// </summary>
        [DataMember(Name = "TransactionId", Order = 1, IsRequired = true)]
        public Guid TransactionId { get; set; }

        /// <summary>
        /// Gets or sets the OfferId of the purchased item.
        /// </summary>
        [DataMember(Name = "OfferId", Order = 2, IsRequired = true)]
        public Guid OfferId { get; set; }

        /// <summary>
        /// Gets or sets the PurchasingPartnerId.
        /// </summary>
        [DataMember(Name = "PurchasingPartnerId", Order = 3, IsRequired = true)]
        public ulong PurchasingPartnerId { get; set; }

        /// <summary>
        /// Gets or sets the Title of the purchased item.
        /// </summary>
        [DataMember(Name = "Title", Order = 4, IsRequired = true)]
        public string Title { get; set; }

        /// <summary>
        /// Gets or sets the PurchaseDate of the purchased item.
        /// </summary>
        [DataMember(Name = "PurchaseDate", Order = 5, IsRequired = true)]
        public DateTime PurchaseDate { get; set; }

        /// <summary>
        /// Gets or sets the MediaInstances of the offer.
        /// </summary>
        [DataMember(Name = "MediaInstanceURLs", Order = 6, IsRequired = false)]
        public IList<string> MediaInstanceURLs { get; set; }

        /// <summary>
        /// (Optional) Gets or sets the balance of the Asset purchased (Consumables only).
        /// </summary>
        [DataMember(Name = "AssetBalance", Order = 7, IsRequired = false)]
        public Asset AssetBalance { get; set; }

        #region Code not contained within the actual response. Used to centralize common code
            /// <summary>
            /// Stores the XML that created this object
            /// </summary>
            public string XMLInput;

            /// <summary>
            /// Get if this XmlElement was set to i:nil="true"
            /// </summary>
            public bool isNullAssetBalance
            {
                get
                {
                    string xml = this.XMLInput;

                    if (!xml.Contains("<AssetBalance i:nil=\"true\"/>"))
                    {
                        return false;
                    }

                    return true;
                }
            }
        #endregion Code not contained within the actual response. Used to centralize common code
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.PDLCServices\VerifyToken\VerifyTokenClientRequest.cs ===
﻿//---------------------------------------------------------------------
// Copyright (C) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------
namespace LiveN.Test
{
    using System;
    using System.Net;
    using System.Text;

    using LiveNew.Test;

    using Infrastructure.Test;
    
    /// <summary>
    /// Client used to interact with the API
    /// </summary>
    public class VerifyTokenClientRequest : PDLCBaseRequest
    {
        /// <summary>
        /// Query string parameters 
        /// </summary>
        public readonly VerifyTokenQueryParmeters QueryParameters;

        /// <summary>
        /// Create a default instance with all default properties based off the global LiveN configuration settings
        /// </summary>
        public VerifyTokenClientRequest(string userEmail, string password)
            : this(CurrentEnvironmentSettings.SelectedEnvironment, userEmail, password)
        {
        }

        /// <summary>
        /// Create a default instance with all default properties to
        /// </summary>
        /// <param name="runEnvironment">Environment to pull configuration settings based off of</param>
        public VerifyTokenClientRequest(EnvironmentElement runEnvironment, string userEmail, string password)
            : base(runEnvironment, userEmail, password)
        {
            this.Method = HttpMethods.GET;
            this.Path = "Pdlc.svc/v1/verifytoken";

            QueryParameters = new VerifyTokenQueryParmeters();

            // Set the Query Builder to use the same structure 
            this.QueryBuilder = this.QueryParameters.QueryBuilder;
        }

        /// <summary>
        /// Make a request to the Verify Token API using the given properties
        /// </summary>
        /// <returns>Returns an Verify Token Response</returns>
        public new VerifyTokenClientResponse MakeARequest()
        {
            return new VerifyTokenClientResponse(this.Request);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.PDLCServices\Purchase\MediaInstance.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Runtime.Serialization;
using System.Xml.Serialization;
using Infrastructure.Test;

namespace LiveN.Test
{
    /// <summary>
    /// MediaInstance representing Durables.
    /// </summary>
    [XmlRoot(ElementName = "MediaInstance", Namespace = "http://schemas.datacontract.org/2004/07/XboxLive.PDLC.Service.Contracts")]
    public class MediaInstance : SerializerExtension
    {
        public MediaInstance()
        {
            this.Xmlns = new XmlSerializerNamespaces();
            this.Xmlns.Add("", "http://schemas.datacontract.org/2004/07/XboxLive.PDLC.Service.Contracts");
            this.Xmlns.Add("i", "http://www.w3.org/2001/XMLSchema-instance");
            this.Xmlns.Add("a", "http://schemas.microsoft.com/2003/10/Serialization/Arrays");
        }

        /// <summary>
        /// Gets or sets the MediaInstanceId.
        /// </summary>
        [XmlElement(ElementName = "MediaInstanceId", Order = 1)]
        public string MediaInstanceId { get; set; }

        /// <summary>
        /// Gets or sets the DownloadUrls.
        /// </summary>
        [XmlElement(ElementName = "DownloadUrls", Order = 2)]
        public string[] DownloadUrls { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.PDLCServices\Purchase\PurchaseRequestContent.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml.Serialization;
using System.Runtime.Serialization;
using System.IO;

using Infrastructure.Test;

namespace LiveN.Test
{
    /// <summary>
    /// Request to purchase an offer(acquired from XBL marketplace catalog).
    /// </summary>
    [XmlRoot(ElementName = "PurchaseRequest")]
    public class PurchaseRequestContent : SerializerExtension
    {
        public PurchaseRequestContent()
        {
            this.Xmlns = new XmlSerializerNamespaces();
            this.Xmlns.Add("", "http://schemas.datacontract.org/2010/12/PDLC.Contracts");
            this.Xmlns.Add("i", "http://www.w3.org/2001/XMLSchema-instance");

            Clear();
        }
        /// <summary>
        /// Gets or sets the TransactionId of the purchase.
        /// </summary>
        [XmlElement(ElementName = "TransactionId")]
        public string TransactionId { get; set; }

        /// <summary>
        /// Gets or sets the OfferId of the item.
        /// </summary>
        [XmlElement(ElementName = "OfferId")]
        public string OfferId { get; set; }

        /// <summary>
        /// Gets or sets the Price of the item, in Microsoft Points.
        /// </summary>
        [XmlElement(ElementName = "PointsPrice")]
        public string PointsPrice { get; set; }

        /// <summary>
        /// Gets or sets the MediaTypeId of the item.
        /// MediaTypeId is based off the GameContentTypeId within a propped Offer
        /// </summary>
        [XmlElement(ElementName = "MediaTypeId")]
        public string MediaTypeId { get; set; }

        /// <summary>
        /// Gets or sets the StoreId of the item.
        /// </summary>
        [XmlElement(ElementName = "StoreId")]
        public string StoreId { get; set; }

        /// <summary>
        /// Gets or sets the payment type. 
        /// </summary>
        [XmlElement(ElementName = "PaymentType")]
        public string PaymentType { get; set; }

        /// <summary>
        /// (Optional) Gets or sets the AssetId of the item (Consumables Only).
        /// </summary>
        [XmlElement(ElementName = "AssetId")]
        public string AssetId { get; set; }

        /// <summary>
        /// (Optional) Gets or sets the 5x5 billing Token.
        /// </summary>
        [XmlElement(ElementName = "BillingToken")]
        public string BillingToken { get; set; }

        /// <summary>
        /// Clears the request object with the default values
        /// </summary>
        public void Clear()
        {
            this.MediaTypeId = string.Empty;
            this.OfferId = string.Empty;
            this.PaymentType = string.Empty;
            this.PointsPrice = string.Empty;
            this.StoreId = string.Empty;
            this.TransactionId = string.Empty;
            
            this.AssetId = null;
            this.BillingToken = null;
        }

        /// <summary>
        /// Create a purchase based off the passed in Offer
        /// </summary>
        /// <param name="offerToPurchase">Offer to be purchased</param>
        /// <param name="paymentType">Payment Type</param>
        /// <returns>TransactionID associated with this request</returns>
        public Guid CreatePurchaseRequest(OfferContext offerToPurchase, PurchasePaymentType paymentType)
        {
            Guid transactionId = Guid.NewGuid();

            Clear();

            this.TransactionId = transactionId.ToString();
            this.PaymentType = ((uint)paymentType).ToString();
            this.StoreId = ((uint)MarketplaceStore.Mobile).ToString();

            switch (paymentType)
            {
                case PurchasePaymentType.Points:

                    this.PointsPrice = ((uint)offerToPurchase.PointsPricePoints).ToString();

                    break;

                case PurchasePaymentType.Token:

                    this.PointsPrice = ((uint)offerToPurchase.PointsPriceToken).ToString();
                    this.BillingToken = offerToPurchase.BillingToken;

                    break;

                default:

                    throw new Exception("Unsupported payment type '" + paymentType.ToString() + "'");
            }

            this.MediaTypeId = offerToPurchase.GameContentTypeId.ToString();
            switch (offerToPurchase.GameContentTypeId)
            {
                case ((int)MediaType.GameConsumable):
                case ((int)MediaType.MobileConsumable):

                    this.AssetId = offerToPurchase.AssetId.ToString();
                    this.OfferId = offerToPurchase.OfferId.ToString();

                    break;

                case ((int)MediaType.AvatarItems):
                case ((int)MediaType.GameContent):
                case ((int)MediaType.ArcadeGame):
                case ((int)MediaType.MobileGame):
                case ((int)MediaType.MobilePDLC):
                case ((int)MediaType.PointsBundle):
                    
                    this.OfferId = offerToPurchase.OfferId.ToString();

                    break;

                default:

                    throw new Exception("Unhandled MediaTypeId. '" + this.MediaTypeId + "'");
            }

            return transactionId;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HyperVcl\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.PDLCServices\Purchase\PurchaseClientResponse.cs ===
﻿//---------------------------------------------------------------------
// Copyright (C) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------
using System.Net;
using System;
using Infrastructure.Test;

namespace LiveN.Test
{
    /// <summary>
    /// Client used to interact with the Response
    /// </summary>
    public class PurchaseClientResponse : PDLCBaseResponse
    {
        /// <summary>
        /// Date and time this request was processed
        /// </summary>
        public readonly DateTime TransactionTime;

        public PurchaseClientResponse(HttpWebRequest request)
            : base(request)
        {
            this.TransactionTime = DateTime.Now;
        }

        /// <summary>
        /// Serilizes the response body into a response object
        /// </summary>
        public PurchaseReceiptResponseBody BodyWrapper
        {
            get
            {
                try
                {
                    PurchaseReceiptResponseBody wrapper;

                    wrapper = SerializerExtension.DeserializeDataContract<PurchaseReceiptResponseBody>(this.Body);

                    wrapper.XMLInput = this.Body;

                    return wrapper;
                }
                catch (Exception exc)
                {
                    throw new Exception("Had a problem deserializing the response body. \r\nRESPONSE BODY:\r\n" + this.Body + "\r\nEXCEPTION:\r\n" + exc);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.PDLCServices\Purchase\PurchaseClientRequest.cs ===
﻿//---------------------------------------------------------------------
// Copyright (C) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------
using System;
using System.Net;
using System.Text;

using LiveNew.Test;

using Infrastructure.Test;

namespace LiveN.Test
{   
    /// <summary>
    /// Client used to interact with the PDLC Purchase API
    /// </summary>
    public class PurchaseClientRequest : PDLCBaseRequest
    {
        /// <summary>
        /// Create a default instance with all default properties based off the global LiveN configuration settings
        /// </summary>
        public PurchaseClientRequest(string userEmail, string password)
            : this (CurrentEnvironmentSettings.SelectedEnvironment, userEmail, password)
        { 
        }

        /// <summary>
        /// Create a default instance with all default properties to
        /// </summary>
        /// <param name="runEnvironment">Environment to pull configuration settings based off of</param>
        public PurchaseClientRequest(EnvironmentElement runEnvironment, string userEmail, string password)
            : base(runEnvironment, userEmail, password)
        {
            this.Path = "pdlc.svc/v1/purchase";

            this.RequestContent = new PurchaseRequestContent();
        }

        public override string AudienceUri
        {
            get
            {
                return PDLCServicesCommon.AUDIENCE_URI_HBI;
            }
        }

        public PurchaseRequestContent RequestContent
        {
            get;
            set;
        }

        public override byte[] Content
        {
            get
            {
                if (this.RequestContent == null)
                {
                    // TODO see 'public void SetContent(string content)'
                    return base.Content;
                }

                return Encoding.UTF8.GetBytes(this.RequestContent.SerializeToXmlString());
            }
            set
            {
                if (value == null)
                {
                    this.RequestContent = null;
                    return;
                }

                string contentString = Encoding.UTF8.GetString(value);
                if (string.IsNullOrEmpty(contentString))
                {
                    this.RequestContent = null;
                    return;
                }

                this.RequestContent = (PurchaseRequestContent)SerializerExtension.DeserializeXml<PurchaseRequestContent>(contentString);
            }
        }

        /// <summary>
        /// Overrrides default content that gets sent
        /// </summary>
        /// <param name="content">Content to be put into the request</param>
        public void SetContent(string content)
        {
            // TODO there is got to be a more generic way to override the content instead of this. Testers need to pass in whatever they want within the request. Look at other examples to see if you already did this somewhere.
            this.RequestContent = null;

            base.Content = System.Text.ASCIIEncoding.ASCII.GetBytes(content);
        }

        /// <summary>
        /// Make a request to the Purchase API using the given properties
        /// </summary>
        /// <returns>Returns an response object</returns>
        public new PurchaseClientResponse MakeARequest()
        {
            return new PurchaseClientResponse(this.Request);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\CreateFakeNotifications\FakeNotificationsLib\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.PDLCServices\VerifyToken\VerifyTokenQueryParmeters.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace LiveN.Test
{
    /// <summary>
    /// Structure used to store all the Query Parameters for this API
    /// </summary>
    public class VerifyTokenQueryParmeters
    {
        public readonly QueryStringBuilder QueryBuilder;

        public const string StoreIdParm = "storeId";
        public const string BillingTokenParm = "billingToken";
        
        public VerifyTokenQueryParmeters()
        {
            this.QueryBuilder = new QueryStringBuilder();
        }

        /// <summary>
        /// A string representing the 5x5 token
        /// </summary>
        /// <remarks>Setting to null will cause this parameter to not be passed</remarks>
        public string BillingToken
        {
            get
            {
                return this.QueryBuilder[BillingTokenParm].Value;
            }
            set
            {
                if (!this.QueryBuilder.ContainsKey(BillingTokenParm))
                {
                    this.QueryBuilder[BillingTokenParm] = new QueryParameter(BillingTokenParm);
                }

                this.QueryBuilder[BillingTokenParm].Value = value;
            }
        }

        /// <summary>
        /// The store (in uint) with which the token is associated 
        /// </summary>
        /// <remarks>Setting to null will cause this parameter to not be passed</remarks>
        public string StoreId
        {
            get
            {
                return this.QueryBuilder[StoreIdParm].Value;
            }
            set
            {
                if (!this.QueryBuilder.ContainsKey(StoreIdParm))
                {
                    this.QueryBuilder[StoreIdParm] = new QueryParameter(StoreIdParm);
                }

                this.QueryBuilder[StoreIdParm].Value = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\CreateHosts\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HyperVcl\HyperVCli.cs ===
﻿using System;
using System.Text;
using System.Collections.Generic;
using HyperVManagementLib;
using System.Threading;

namespace HyperVcli
{
    class HyperVCli
    {
        static string vmhost = string.Empty;
        static string vmbox = string.Empty;
        static string operation = string.Empty;
        static string snapshot = string.Empty;

        static void Main(string[] args)
        {
            if (ParseArguments(args))
            {
                try
                {
                    HyperVCliLibrary hyperv = new HyperVCliLibrary(vmhost);
                    if (null == hyperv)
                    {
                        throw new ApplicationException(string.Format("Unable to connect to HyperV host '{0}'", vmhost));
                    }
                    else
                    {
                        Console.WriteLine("  Successful connection to HyperV host '{0}'", vmhost);
                    }

                    switch (operation)
                    {
                        case "create":
                            if (string.Empty == HyperVCli.snapshot)
                            {
                                throw new ApplicationException("You must specify a snapshot name to create a snapshot");
                            }
                            hyperv.CreateSnapshot(HyperVCli.vmbox, HyperVCli.snapshot);
                            break;
                        case "restore":
                            if (HyperVCli.snapshot == "last" || snapshot == String.Empty)
                            {
                                hyperv.RestoreLastSnapshot(HyperVCli.vmbox);
                            }
                            else
                            {
                                hyperv.RestoreSnapshot(HyperVCli.vmbox, HyperVCli.snapshot);
                            }
                            break;
                        default:
                            ShowUsage();
                            break;
                    }
                }
                catch (Exception e)
                {
                    System.Console.WriteLine(ExceptionHelper.ExceptionWriter(e));
                }
            }
            else
            {
                // parse returned false
                ShowUsage();
            }
        }

        private static void ShowUsage()
        {
            Console.WriteLine("\n\tUsage: hypervcli.exe -host <vmhost> -vm <vm name> -oper <operation> -snap <snapshot name>");
            Console.WriteLine("\t\tValid operations: 'create' and 'restore' ");
            Console.WriteLine("\t\tTo restore the latest snapshot use 'last' for -snap");
        }

        private static bool ParseArguments(string[] args)
        {
            bool ret = false;
            bool invalidArgFound = false;
            int i = 0;

            while ((i < args.Length) && !invalidArgFound)
            {
                switch (args[i].ToLower())
                {
                    case "-host":
                    case "/host":
                        if (i + 1 < args.Length)
                        {
                            vmhost = args[++i].ToLower();
                        }
                        break;
                    case "-vm":
                    case "/vm":
                        if (i + 1 < args.Length)
                        {
                            vmbox = args[++i].ToLower();
                        }
                        break;
                    case "-oper":
                    case "/oper":
                        if (i + 1 < args.Length)
                        {
                            operation = args[++i].ToLower();
                        }
                        break;
                    case "-snap":
                    case "/snap":
                        if (i + 1 < args.Length)
                        {
                            snapshot = args[++i].ToLower();
                        }
                        break;
                    case "-?":
                    case "/?":
                        invalidArgFound = true;
                        break;
                    default:
                        Console.WriteLine("Unknown parameter '{0}' received.", args[i]);
                        invalidArgFound = true;
                        break;
                }
                i++;
            }

            if (!invalidArgFound) //Or question mark argument
            {
                ret = true;
            }

            #region Verify needed values are set
            if ((null == vmhost) | (string.Empty == vmhost))
            {
                Console.WriteLine("The -vmhost switch did not set a value");
                ret = false;
            }
            if ((null == vmbox) | (string.Empty == vmbox))
            {
                Console.WriteLine("The -vmbox switch did not set a value");
                ret = false;
            }

            if ((null == operation) | (string.Empty == operation))
            {
                Console.WriteLine("The -oper switch did not set a value");
                ret = false;
            }
            else if ((operation != "create") & (operation != "restore"))
            {
                Console.WriteLine("ERROR: The -oper switch must have 'create' or 'restore' as the value");
                ret = false;
            }

            // Snapshot is sometimes valid as blank.. no test here.

            #endregion

            return ret;
        }
    }  // end of class HyperVCli


    class HyperVCliLibrary
    {
        VirtualMachineManager vmgr;

        public HyperVCliLibrary(string vmlhost)
        {
            Console.WriteLine("Initiating vmhost...");

            vmgr = new VirtualMachineManager(vmlhost);
            if (null == vmgr)
            {
                throw new ApplicationException(string.Format("Unable to connect to VM host '{0}'", vmlhost));
            }
            Console.WriteLine("Vmhost initiated");
        }

        /// <summary>
        /// Creates a new snapshot with the specified name
        /// </summary>
        /// <param name="vmbox">Name of the virtual machine in the host</param>
        /// <param name="snapshotName">Name of the snapshot to be created</param>
        /// <returns>bool value based on status</returns>
        public bool CreateSnapshot(string vmbox, string snapshotName)
        {
            bool ret = false;
            VirtualMachine vm = GetVM(vmbox);

            Console.WriteLine("Creating Snapshot...");
            vm.CreateNewSnapshot(snapshotName);
            Console.WriteLine("Verifying");

            if (vm.GetSnapShotFromName(snapshotName).Name == snapshotName)
            {
                ret = true;
                Console.WriteLine("Snapshot successfully created ");
            }
            return ret;
        }

        private VirtualMachine GetVM(string vmbox)
        {
            Console.WriteLine("Searching for vm...");
            VirtualMachine vm = vmgr.OpenMachine(vmbox);
            if (null == vm)
            {
                throw new ApplicationException(string.Format("Unable to open HyperV machine '{0}'", vmbox));
            }
            else
            {
                Console.WriteLine("  Virtual machine '" + vm.Name + "' was found");
            }
            return vm;
        }

        /// <summary>
        /// Restore a snapshot of the specified name
        /// </summary>
        /// <param name="vmbox">Name of the virtual machine in the host</param>
        /// <param name="snapshotName">Name of the snapshot to be restored</param>
        /// <returns>bool value based on status</returns>
        public bool RestoreSnapshot(string vmbox, string snapshot)
        {
            bool ret = false;
            VirtualMachine vm = GetVM(vmbox);

            Console.WriteLine("Retreiving snapshot ...");
            VirtualSnapshot vshot = vm.GetSnapShotFromName(snapshot);
            if (null == vshot)
            {
                throw new ApplicationException(string.Format("Unable to open HyperV snapshot '{0}'", snapshot));
            }
            else
            {
                Console.WriteLine("  Snapshot '{0}' found", snapshot);
            }

            Console.WriteLine("Applying Snapshot to vm");
            vshot.Apply();
            Thread.Sleep(5000);

            Console.WriteLine("Verifying..");
            if (vm.State == VirtualMachineEnabledState.Enabled)
            {
                ret = true;
                Console.WriteLine("VM restoration complete");
            }
            else
            {
                Thread.Sleep(10000);
                Console.WriteLine("Verifying.. Second attempt");
                if (vm.State == VirtualMachineEnabledState.Enabled)
                {
                    ret = true;
                    Console.WriteLine("VM restoration complete");
                }
            }
            return ret;
        }

        /// <summary>
        /// Restores the last snapshot of a specific vm
        /// </summary>
        /// <param name="vmbox">Virtual machine name</param>
        /// <returns>Success status</returns>
        public bool RestoreLastSnapshot(string vmbox)
        {
            bool ret = false;
            VirtualMachine vm = GetVM(vmbox);

            Console.WriteLine("Retreiving snapshot ...");
            ItemCollection<VirtualSnapshot> snapshots = this.GetAllSnapshots(vmbox);

            VirtualSnapshot vs = snapshots[snapshots.Count - 1];
            Console.WriteLine("Applying Snapshot");
            vs.Apply();

            Thread.Sleep(5000);

            Console.WriteLine("Verifying..");
            if (vm.State == VirtualMachineEnabledState.Enabled)
            {
                ret = true;
                Console.WriteLine("VM restoration complete");
            }
            else
            {
                Thread.Sleep(10000);
                Console.WriteLine("Verifying.. Second attempt");
                if (vm.State == VirtualMachineEnabledState.Enabled)
                {
                    ret = true;
                    Console.WriteLine("VM restoration complete");
                }
            }
            return ret;
        }

        /// <summary>
        /// Gets the list of virtual machines in the host
        /// </summary>
        /// <returns>List of Virtual Machines</returns>
        public List<VirtualMachine> GetAllVMs()
        {
            return vmgr.GetAllVirtualMachines();
        }

        /// <summary>
        /// Returns all snapshots of a given vm
        /// </summary>
        /// <param name="vmbox"></param>
        /// <returns>ItemCollection of VirtualSnapshots</returns>
        public ItemCollection<VirtualSnapshot> GetAllSnapshots(string vmbox)
        {
            VirtualMachine vm = GetVM(vmbox);
            return vm.GetAllSnapShots();

        }

    }
    class ExceptionHelper
    {
        static public string ExceptionWriter(Exception e)
        {
            StringBuilder sb = new StringBuilder();
            sb.AppendLine(string.Format("Message: '{0}'", e.Message));
            sb.AppendLine(string.Format("Message: '{0}'", e.StackTrace.ToString()));
            if (null != e.InnerException)
            {
                sb.AppendLine(ExceptionWriter(e.InnerException));
            }
            return sb.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HyperVcl\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("hypervcli")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
//[assembly: AssemblyCompany("Microsoft")]
//[assembly: AssemblyProduct("HyperVcli")]
//[assembly: AssemblyCopyright("Copyright © Microsoft 2009")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("a4badc03-61b8-4dd1-bd19-6de1d39bd58e")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
//[assembly: AssemblyVersion("1.0.0.0")]
//[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\CreateFakeNotifications\FakeNotificationsLib\FakeNotificationsLib\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("FakeNotificationsLib")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
//[assembly: AssemblyCompany("Microsoft Corp.")]
//[assembly: AssemblyProduct("FakeNotificationsLib")]
//[assembly: AssemblyCopyright("Copyright © Microsoft Corp. 2009")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("d238d4e8-712b-41d4-b9f1-b0832ceaf8ea")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
//[assembly: AssemblyVersion("1.0.0.0")]
//[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\CreateFakeNotifications\FakeNotificationsLib\FakeNotificationsLib\Notifications.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Net;
using System.IO;
using System.Configuration;
using System.Xml;

using AsyncMultiplayer.NotificationService;
using Leet.Core;

namespace Test.Common.Library.FakeNotificationsLib
{
    public class Notifications
    {
    
        #region Member Variables
        private string m_guid = string.Empty;
        private string newGUID = string.Empty;
        private string m_NotificationId = string.Empty;
        private uint m_gameId = 7777;
        private int m_platform = 6;
        private string m_xuid = "50";
        private uint m_gamevarient = 100;
        private string m_From = "Manoj";
        NotificationType m_type = NotificationType.Invitation;
        Notification newNotification = null;
        private static string m_token = ConfigurationSettings.AppSettings["Token"];
        private static string m_account = ConfigurationSettings.AppSettings["Account"];
        private static string m_endPoint = ConfigurationSettings.AppSettings["EndPoint"];
        private static string m_Proxy = ConfigurationSettings.AppSettings["Proxy"];
    
        private static INotificationStorage m_notificationStorage = new NotificationAzureStorage(m_endPoint, m_account, m_token,m_Proxy);
        #endregion

        #region Properties
        /// <summary>
        /// GUID of the recent Notification created.
        /// Default value is empty string.
        /// </summary>
        public string GUID
        {
            get
            {
                return m_guid;
            }
        }

        /// <summary>
        /// NotificationID of the recent Notification created.
        /// Default value is empty string.
        /// </summary>
        public string NotificationID
        {
            get
            {
                return m_NotificationId;
            }
        }

        /// <summary>
        /// Game ID of the Game 
        /// </summary>
        public uint GameID
        {
            set
            {
                m_gameId = value;
            }
            get
            {
                return m_gameId;
            }
        }

        /// <summary>
        /// PlatForm ID. It can be 1 ,2 ,4 and 6.
        /// Generally it is 6 which means Notification is for Web and Mobile both.
        /// </summary>
        public int PlatForm
        {
            set
            {
                m_platform = value;
            }
            get
            {
                return m_platform;
            }
        }

        /// <summary>
        /// XUID of the User you wanted to create Notification for
        /// </summary>
        public string XUID
        {
            set
            {
                m_xuid = value;
            }
            get
            {
                return m_xuid;
            }
        }

        /// <summary>
        /// Game Varient of the Game. It can be between 0 to 100.
        /// </summary>
        public uint GameVarient
        {
            set
            {
                m_gamevarient = value;
            }
            get
            {
                return m_gamevarient;
            }
        }

        /// <summary>
        /// Represents the User name who is the originator of the Notification.
        /// </summary>
        public string From
        {
            set 
            {
                m_From = value;
            }
            get
            {
                return m_From;
            }
        }

        /// <summary>
        /// Type of the Notification.
        /// </summary>
        public NotificationType TypeOfNotification
        {
            set
            {
                m_type = value;
            }
            get
            {
                return m_type;
            }
        }
        #endregion
      
        /// <summary>
        /// Enum containing all the different types of the Notification.
        /// </summary>
        public enum NotificationType
        {
            /// <summary>
            /// GameOver -> Game is over
            /// </summary>
            GameOver,

            /// <summary>
            /// GameTie -> Game ended up in a tie
            /// </summary>
            GameTie,

            /// <summary>
            /// YouWin -> You won a game
            /// </summary>
            YouWin,

            /// <summary>
            /// YouLose -> You lost a game
            /// </summary>
            YouLose,

            /// <summary>
            /// Nudge -> User-initiated nudge to remind a player to make a move
            /// </summary>
            Nudge,

            /// <summary>
            /// Warning -> Warning when session is going to be removed soon
            /// </summary>
            Warning,

            /// <summary>
            /// YourTurn -> This is your turn
            /// </summary>
            YourTurn,

            /// <summary>
            /// MessageWaiting -> There are game-specific messages waiting for user to take actions on
            /// </summary>
            MessageWaiting,

            /// <summary>
            /// Invitation -> A game invitation
            /// </summary>
            Invitation 
        }

        private void AssignNotificationType()
        {
            switch (m_type)
            {
                case NotificationType.Invitation:
                    newNotification = new InvitationNotification();
                    break;
                case NotificationType.GameOver:
                    newNotification = new GameOverNotification();
                    break;
                case NotificationType.GameTie:
                    newNotification = new GameTieNotification();
                    break;
                case NotificationType.MessageWaiting:
                    newNotification = new MessageWaitingNotification();
                    break;
                case NotificationType.Nudge:
                    newNotification = new NudgeNotification();
                    break;
                case NotificationType.Warning:
                    newNotification = new WarningNotification();
                    break;
                case NotificationType.YouLose:
                    newNotification = new YouLoseNotification();
                    break;
                case NotificationType.YourTurn:
                    newNotification = new YourTurnNotification();
                    break;
                case NotificationType.YouWin:
                    newNotification = new YouWinNotification();
                    break;
                default:
                    newNotification = new InvitationNotification();
                    break;

            }
 
        }

        #region Create Notification
        private void CreateNotification()
        {
            try
            {
                if (newGUID == "")
                {
                    newGUID = Guid.NewGuid().ToString();
                }
            
                AssignNotificationType();
                newNotification.From = m_From;
                newNotification.ExpirationTime = DateTime.MaxValue;
                newNotification.UserId = m_xuid;
                newNotification.GameId = m_gameId;
                newNotification.Variant = m_gamevarient;
                newNotification.SessionId = newGUID;
                m_notificationStorage.SaveNotification(m_xuid, m_gameId, newGUID, newNotification);
                //assing the GUID values to the m_guid so that it can be accesed using the property.
                m_guid = newGUID;
                m_NotificationId = newNotification.Id;

            }
            catch (Exception Error)
            {
                throw Error;
            }

        }

        /// <summary>
        /// It creates the Notification for the given XUID.
        /// </summary>
        /// <param name="XUID">XUID of the user for which you are generating Notification.</param>
        /// <param name="From">Name of the generator.</param>
        public void CreateNotification(string XUID, string From)
        {
            m_xuid = XUID;
            m_From = From;
            CreateNotification();

        }

        /// <summary>
        /// It creates the Notification of the specified type for the given XUID.
        /// </summary>
        /// <param name="NotificaitonType">Type of the Notification</param>
        /// <param name="XUID">XUID of the user for which you are generating Notification.</param>
        /// <param name="From">Name of the generator.</param>
        public void CreateNotification(NotificationType NotificaitonType, string XUID, string From)
        {
            m_type = NotificaitonType;
            m_xuid = XUID;
            m_From = From;
            CreateNotification();
        }

        /// <summary>
        /// It creates the Notification of the specified type for the given XUID and Platform.
        /// </summary>
        /// <param name="NotificaitonType">Type of the Notification.</param>
        /// <param name="XUID">XUID of the user for which you are generating Notification.</param>
        /// <param name="From">Name of the generator.</param>
        /// <param name="Platform">Platform for which we are</param>
        public void CreateNotification(NotificationType NotificaitonType, string XUID,string From, int Platform)
        {
            m_type = NotificaitonType;
            m_xuid = XUID;
            m_From = From;
            m_platform = Platform;
            CreateNotification();
        }

        /// <summary>
        /// It creates the Notification of the specified type for the given XUID ,Platform and GameID.
        /// </summary>
        /// <param name="NotificaitonType">Type of the Notification.</param>
        /// <param name="XUID">XUID of the user for which you are generating Notification.</param>
        /// <param name="From">Name of the generator.</param>
        /// <param name="Platform"> /// PlatForm ID. It can be 1 ,2 ,4 and 6.
        /// Generally it is 6 which means Notification is for Web and Mobile both.</param>
        /// <param name="GameID">GameID.</param>
        /// <param name="GameVarient">It can be anything between 0 to 100.</param>
        ///  <param name="SessionID">It cab be any GUID</param>
        public void CreateNotification(NotificationType NotificaitonType, string XUID,string From, int Platform, uint GameID, uint GameVarient,string SessionId)
        {
            m_type = NotificaitonType;
            m_xuid = XUID;
            m_From = From;
            m_platform = Platform;
            m_gameId = GameID;
            m_gamevarient = GameVarient;
            newGUID = SessionId;
            CreateNotification();
        }

        #endregion

        #region Delete Notification

        /// <summary>
        /// Deletes the Notification for the given XUID.
        /// </summary>
        /// <param name="Xuid"></param>
        public void DeleteNotificaiton(string Xuid)
        {
            m_notificationStorage.DeleteNotification(Xuid);
        }

        /// <summary>
        /// Delete the Notification for the given XUID and NotificaitonID.
        /// </summary>
        /// <param name="Xuid"></param>
        /// <param name="NotificationID"></param>
        public void DeleteNotificaiton(string Xuid, string NotificationID)
        {
            m_notificationStorage.DeleteNotification(Xuid, NotificationID);
        }

        /// <summary>
        /// Delete the Notification for the given XUID, GameID and SessionID(GUID).
        /// </summary>
        /// <param name="Xuid"></param>
        /// <param name="GameID"></param>
        /// <param name="SessionID"></param>
        public void DeleteNotificaiton(string Xuid,uint GameID, string SessionID )
        {
            m_notificationStorage.DeleteNotificationBySession(Xuid,GameID, SessionID);
        } 

        #endregion
               
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\CreateXboxLiveAccount\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\HttpClient.PDLCServices\VerifyToken\VerifyTokenResponseBody.cs ===
﻿//---------------------------------------------------------------------
// Copyright (C) Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------
using System;
using System.Xml.Serialization;

using Infrastructure.Test;

namespace LiveN.Test
{
    /// <summary>
    /// The offer behind a 5x5 token could be an XBox Offer or EMS Offer.
    /// </summary>
    [XmlRoot(ElementName = "TokenOffer", Namespace = "http://schemas.datacontract.org/2010/12/PDLC.Contracts")]
    public class VerifyTokenResponseBody : SerializerExtension
    {
        /// <summary>
        /// Gets or sets the XboxOffer behind the token.
        /// </summary>
        public XboxOfferInfo XboxOffer { get; set; }

        /// <summary>
        /// Get if this XmlElement was set to i:nil="true"
        /// </summary>
        [XmlIgnore]
        public bool isNullXboxOffer
        {
            get
            {
                string xml = this.XMLInput;

                if (!xml.Contains("<XboxOffer i:nil=\"true\"/>"))
                {
                    return false;
                }

                return true;
            }
        }

        /// <summary>
        /// Gets or sets the EmsOffer of the offer behind the token.
        /// </summary>
        public EmsOfferInfo EmsOffer { get; set; }

        /// <summary>
        /// Get if this XmlElement was set to i:nil="true"
        /// </summary>
        [XmlIgnore]
        public bool isNullEmsOffer
        {
            get
            {
                string xml = this.XMLInput;

                if (!xml.Contains("<EmsOffer i:nil=\"true\"/>"))
                {
                    return false;
                }

                return true;
            }
        }
    }

    /// <summary>
    /// The XBOX offer behind a 5x5 token.
    /// </summary>
    public class XboxOfferInfo : SerializerExtension
    {
        /// <summary>
        /// Gets or sets the Xbox Offer id.
        /// </summary>
        [XmlElement(ElementName = "offerId")]
        public ulong OfferId { get; set; }

        /// <summary>
        /// Gets or sets the Xbox Offer type. - This is a direct mapping from the backed. Bug 11839
        /// </summary>
        [XmlElement(ElementName = "offerTypeId")]
        public int OfferTypeId { get; set; }
    }

    /// <summary>
    /// The EMS offer behind a 5x5 token.
    /// </summary>
    public class EmsOfferInfo : SerializerExtension
    {
        /// <summary>
        /// Gets or sets the Xbox Offer id.
        /// </summary>
        [XmlElement(ElementName = "offerId")]
        public Guid OfferId { get; set; }

        /// <summary>
        /// Gets or sets the Xbox Offer id.
        /// </summary>
        [XmlElement(ElementName = "mediaId")]
        public Guid MediaId { get; set; }

        /// <summary>
        /// Gets or sets the Xbox Offer id.
        /// </summary>
        [XmlElement(ElementName = "mediaType")]
        public int MediaType { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\CreateHosts\Exceptions.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Runtime.Serialization;

namespace CreateHosts
{
    [Serializable()]
    public class CreateHostsException : Exception
    {
        //Set the constructors and allow message and innerexception to be overriden
        public CreateHostsException()
            : base() {
        }

        public CreateHostsException(string message) : base(message) {
            Console.WriteLine();
            Console.WriteLine("...ERROR...");
            Console.WriteLine(message.ToString());
            Environment.Exit(-1);
        }

        public CreateHostsException(string message, Exception innerException) : base(message, innerException) {
            Console.WriteLine();
            Console.WriteLine("...ERROR...");
            Console.WriteLine(message.ToString());
            Console.WriteLine(innerException.ToString());
            Environment.Exit(-1);        
        }

        protected CreateHostsException(SerializationInfo info, StreamingContext context) : base(info, context) { }

        public override string Message
        {
            get
            {
                return base.Message;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\DOMInspector\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\CreateHosts\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("CreateHosts")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("f17ff325-bb7b-48c9-b03f-7d76d4862b88")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\CreateXboxLiveAccount\CreateXboxLiveAccount\UserSettings.cs ===
﻿using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Text;
using UserLib;
using live.common;

namespace Test.Common.Library.CreateXboxLiveAccount
{
    /// <summary>
    /// UserSettings class exposes all the possible properties a user can have.
    /// </summary>
    public class UserSettings
    {
        #region Private Members
        // community
        //-FPI and -PPI has to be implemented.
        ////static readonly string FRIEND_PASSPORT = "-fpi";
        ////static readonly string PLAYER_PASSPORT = "-ppi";
        private int _numberOfFriends = 0;
        private int _numberOfMessages = 0;
        private int _numberOfPlayers = 0;
        private Collection<PassportInfo> _friendPIs = new Collection<PassportInfo>();
        private Collection<PassportInfo> _playerPIs = new Collection<PassportInfo>();
        private Collection<CreditCardType> _creditCards = new Collection<CreditCardType>();

        //Environment and Accounts
        private string _env = "test";
        private int _microsoftPoints = 0;
        private live.common.PassportType _passportType = PassportType.Real;
        private string _memberName = string.Empty;
        private string _password = string.Empty;
        private CountryId _countryId = CountryId.US;
        private LanguageId _languageId = LanguageId.en;
        private ParentalControl _parentalControl = ParentalControl.None;

        // gamer profile        
        private string _bio = string.Empty;
        private string _loc = string.Empty;
        private string _name = string.Empty;
        private string _motto = string.Empty;
        private string _rep = string.Empty;
        private GamerZone _zone = GamerZone.None;
        private string _gamerTag = string.Empty;

        // Achievements 
        private int _numberOfGamesPlayed = 0;
        private PlayerSkill _playerSkill = PlayerSkill.None;
        //static readonly string TITLE_ID = "-t";
        //We can add the Title functionality on demand.


        //Privacy and Family Options.
        private PrivacyOption _privacy = PrivacyOption.Everyone;
        private FamilyOption _FamilyOptions = FamilyOption.Allow;



        //Mis

        private bool _wantToModifyExistingAccount = false;

        private UserLib.AccountTier _userTier = UserLib.AccountTier.Gold;

        #endregion

        #region Community
        /// <summary>
        /// Get and Set the numbers of friends a user has of can have.
        /// Number of friends should be in the range of 1 to 100. Default number of friends are 0;
        /// 
        /// </summary>
        public int NumberOfFriends
        {
            set
            {
                _numberOfFriends = value;
            }
            get
            {
                return _numberOfFriends;
            }

        }

        //public Collection<string,string> PassportInfoOfFriendsToAdd
        //{


        //}

        /// <summary>
        /// Get and Set the number of messages a user has or can have.
        /// Number of Messages should be in the range of 1 to 100. Default number of messages are 0.
        /// </summary>
        public int NumberOfMessages
        {
            set
            {
                _numberOfMessages = value;
            }
            get
            {
                return _numberOfMessages;
            }
        }

        /// <summary>
        /// Get and Set the number of recent Players. Default value is 0.
        /// </summary>
        public int NumberOfPlayers
        {
            set
            {
                _numberOfPlayers = value;
            }
            get
            {
                return _numberOfPlayers;
            }
        }

        #endregion Community

        #region Gamer Profile
        /// <summary>
        /// Get and Set some information about the user.
        /// It should not be more than 499
        /// </summary>
        public string Bio
        {
            set
            {
                _bio = value;
            }
            get
            {
                return _bio;
            }
        }


        /// <summary>
        /// Get and Set the users Location.
        /// It should not be more than 40 char.
        /// </summary>
        public string Loc
        {
            set
            {
                _loc = value;
            }
            get
            {
                return _loc;
            }
        }


        /// <summary>
        /// Get and Set the user Name.
        /// It should not be more than 129 char.
        /// </summary>
        public string Name
        {
            set
            {
                _name = value;
            }
            get
            {
                return _name;
            }
        }


        /// <summary>
        /// Get and Set the user's Motto.
        /// It should not be more than 21 char.
        /// </summary>
        public string Motto
        {
            set
            {
                _motto = value;
            }
            get
            {
                return _motto;
            }
        }


        /// <summary>
        /// Get and Set the user's Reptation.
        /// </summary>
        public string Reputaion
        {
            set
            {
                _rep = value;
            }
            get
            {
                return _rep;
            }
        }

        /// <summary>
        /// Get and Set the user's Zone. Default value is none.
        /// </summary>
        public GamerZone Zone
        {
            set
            {
                _zone = value;
            }
            get
            {
                return _zone;
            }
        }

        /// <summary>
        /// Get and Set the GamerTag for the user.
        /// It should not be more than 15 char.
        /// </summary>
        public string GamerTag
        {
            set
            {
                _gamerTag = value;
            }
            get
            {
                return _gamerTag;
            }
        }
        #endregion Gamer Profile.

        #region Achievements
        /// <summary>
        /// Get and Set the number of games played by the user. Keep its values from 1 to 8.
        /// It's default value is 0.
        /// </summary>
        public int NumberOfGamesPlayed
        {
            set
            {
                _numberOfGamesPlayed = value;
            }
            get
            {
                return _numberOfGamesPlayed;

            }
        }

        /// <summary>
        /// Get and Set the PlayerSkill. On this basis achievements will be awarded to the Player.
        /// Player skill can be None,Casual,Novice and Hardcore. Default value is None.
        /// </summary>
        public PlayerSkill PlayerSkill
        {
            set
            {
                _playerSkill = value;
               
            }
            get
            {
                return _playerSkill;
            }
        }
        #endregion

        #region Privacy and Family options.

        /// <summary>
        /// Get and Set the Privacy settings of the User.
        /// It can be Blocked,Everyone or FriendsOnly. Default value is Everyone.
        /// </summary>
        public PrivacyOption Privacy
        {
            set
            {
                _privacy = value;
                
            }
            get
            {
                return _privacy;
            }
        }

        /// <summary>
        /// Get and Set the FamilyOptions for the User.
        /// It can be Allow or Restrict. Default value is Allow.
        /// </summary>
        public FamilyOption FamilyOptions
        {
            set
            {
                _FamilyOptions = value;
               
            }
            get
            {
                return _FamilyOptions;
            }
        }
        #endregion

        #region UserName, Password, Type of Passport,user Tier, Microsoft Points
        /// <summary>
        /// Get and Set the PassportType of the User it can be Real or Fake.
        /// Default vaues is Real.
        /// Use live.common.PassportType enum for more option.
        /// </summary>
        public live.common.PassportType PassPortType
        {
            set
            {
                _passportType = value;
            }

            get
            {
                return _passportType;
            }
        }


        /// <summary>
        /// Get and Set the user Tier. It can be Gold or silver. Default value is Gold.
        /// Use UserLib.AccountTier to select the Tier.
        /// </summary>
        public UserLib.AccountTier UserTier
        {
            set
            {
                _userTier = value;
            }
            get
            {
                return _userTier;
            }

        }


        /// <summary>
        /// Get and Set the MicrosoftPoints for the user.
        /// Points can be either 500,1000,2000 or 5000.
        /// </summary>
        public int MicrosoftPoints
        {

            set
            {
                _microsoftPoints = value;
            }
            get
            {
                return _microsoftPoints;
            }
        }

        /// <summary>
        /// Get and Set the Email id of the user you wanted to create or retrieve the information.If you wanted to retrieve the user then make sure you set the property WantToModifyExisitingAccout to TRUE.
        /// If you want to retrieve the user then make sure you provide the Password too.
        /// </summary>
        public string MemberName
        {
            set
            {
                _memberName = value;
            }

            get
            {
                return _memberName;
            }
        }

        /// <summary>
        /// Password of the user you wanted to create or retrieve.
        /// If you wanted to modify the existing user then this field is mendatory.
        /// If you wanted to create a user then it is optional.The default Password will be created whichi is supersecret.
        /// </summary>
        public string Password
        {
            set
            {
                _password = value;
            }
            get
            {
                return _password;
            }
        }
        #endregion

        #region Environment and Accounts
        /// <summary>
        /// Get and Set the Current Environment value. It can be either "Test", "Stress" or "Stress2".
        /// </summary>
        public string ENV
        {
            set
            {
                _env = value;
            }
            get
            {
                return _env;
            }
        }

        /// <summary>
        /// Get and Set the Country for the user. Default value is US.
        /// </summary>
        public CountryId CountryId
        {
            set
            {
                _countryId = value;
            }
            get
            {
                return _countryId;
            }
        }

        /// <summary>
        /// Get and Set the Lanugage for the user. Default value is EN.
        /// </summary>
        public LanguageId LanguageID
        {
            set
            {
                _languageId = value;
            }
            get
            {
                return _languageId;
            }
        }

        /// <summary>
        /// Get and Set the ParentalControl on the user. It can be None, Partial or Strict. Default value is None.
        /// </summary>
        public ParentalControl ParentalControl
        {
            set
            {
                _parentalControl = value;
               
            }
            get
            {
                return _parentalControl;
            }
        }
        #endregion

        #region Misc
        /// <summary>
        /// This property specify whether to modify the existing account or not. It can either True or False.
        /// </summary>
        public bool WantToModifyExisitingAccout
        {
            set
            {
                _wantToModifyExistingAccount = value;
            }
            get
            {
                return _wantToModifyExistingAccount;
            }
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\DOMInspector\DOMInspector\HTMLAttribute.cs ===
﻿using System;
using System.Web;

namespace Test.Common.Library.DOMInspector
{
    /// <summary>
    /// Represents an attribute name-value pair of an HTML DOM Element.
    /// </summary>
    public class HTMLAttribute
    {
        /// <summary>
        /// String containing the attribute name.
        /// </summary>
        private string g_AttributeName;
        /// <summary>
        /// String containing the attribute value.
        /// </summary>
        private string g_AttributeValue;

        /// <summary>
        /// Initialize a new instance of an HTMLAttribute class.
        /// </summary>
        public HTMLAttribute()
        {
            g_AttributeName = "Noname";
            g_AttributeValue = string.Empty;
        }

        /// <summary>
        /// Initialize a new instance of an HTMLAttribute class with the specified
        /// Attribute name and value.
        /// </summary>
        /// <param name="AttributeName">The name of the HTML DOM Element Attribute.</param>
        /// <param name="AttributeValue">The value associated with this attribute.</param>
        public HTMLAttribute(string AttributeName, string AttributeValue)
        {
            g_AttributeName = AttributeName;
            g_AttributeValue = AttributeValue;
        }

        /// <summary>
        /// Gets or sets the Name of the HTML DOM Element Attribute.
        /// </summary>
        public string Name
        {
            get { return g_AttributeName; }

            set { g_AttributeName = value; }
        }

        /// <summary>
        /// Gets or sets the Value associated with this HTML DOM Element Attribute.
        /// </summary>
        public string Value
        {
            get { return g_AttributeValue; }

            set { g_AttributeValue = value; }
        }

        /// <summary>
        /// Gets the Raw Text representation of this attribute name-value pair.
        /// </summary>
        /// <returns>An object of type System.String.</returns>
        public override string ToString()
        {
            if (g_AttributeValue == null)
                return g_AttributeName;
            else
                return g_AttributeName + "=\"" + g_AttributeValue + "\"";
        }

        /// <summary>
        /// Gets the HTML DOM representation of this attribute name-value pair.
        /// </summary>
        /// <returns>A string representing the attribute name-value pair as a HTML DOM.</returns>
        public string ToHTMLDOM()
        {
            if (g_AttributeValue == null)
                return g_AttributeName;
            else
                return g_AttributeName + "=\"" + HttpUtility.HtmlEncode(g_AttributeValue) + "\"";
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\CreateXboxLiveAccount\CreateXboxLiveAccount\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("CreateXboxLiveAccount")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
//[assembly: AssemblyCompany("Microsoft Corp.")]
//[assembly: AssemblyProduct("CreateXboxLiveAccount")]
//[assembly: AssemblyCopyright("Copyright © Microsoft Corp. 2009")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("680eb68e-a9ab-4158-8509-7d32c98c2a59")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
//[assembly: AssemblyVersion("1.0.0.0")]
//[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\CreateHosts\Program.cs ===
﻿using System;
using System.Text;
using System.IO;
using System.Net;
using System.Globalization;

using Microsoft.Win32;

/*
 * Created By: bradking
 * Owner: a-jamoro  (thanks to the 'you touch it.. you own it' rule)
 * Description: This console application will replace your current hosts file with a hosts file
 *  that will enable users to access all necessary servers for Xbox.com test environments. There is also
 *  an option that will allow you to overwrite proxy settings in IE so that you can access all the necessary servers
 *  through the corporate proxy.
 */
namespace CreateHosts
{
    class Program
    {
        //Declare string variables
        public static string responseStatus, responseData = "";

        public static string sharepointUrl = @"http://sharepoint/sites/LIVEn%20Community/test/Shared%20Documents/Test%20Content/";
        public static string sharepointUrl2 = @"file://livenfile01/Lab/Deployments/Storax/";
        public static string sharepointUrl_Hosts = sharepointUrl2 + "hosts";
        public static string sharepointUrl_ProxyExceptions = sharepointUrl2 + "proxyExceptions.txt";
        public static string sharepointUrl_UserPreferences = sharepointUrl + "userPreferences.txt";
        public static string strProxyServer = "itgproxy.redmond.corp.microsoft.com:80";

        //http://sharepoint/sites/LIVEn%20Community/test/Shared%20Documents/Test%20Content/proxyExceptions.txt

        #region Parse Input state variables
        public static bool bParseError = false;
        public static bool bCreateHosts = false;
        public static bool bUpdateIEProxy = false;
        public static bool bUpdateFFProxy = false;
        public static bool bMergeHosts = false;
        #endregion

        /// <summary>
        /// Launches the main console window and handles user inputs
        /// </summary>
        static void Main(string[] args)
        {
            //Declare an app error handler to catch all exceptions and deliver the message in a formatted manner
            AppDomain currentDomain = AppDomain.CurrentDomain;
            currentDomain.UnhandledException += new UnhandledExceptionEventHandler(CreateHostsHandler);

            if (args.Length > 0)
            {
                foreach (string arg in args)
                {
                    //Depending on the argument we update
                    #region Walk thru Switches.
                    switch (arg.ToLower(CultureInfo.CurrentCulture))
                    {
                        case "/all":
                        case "-all":
                        case "/a":
                        case "-a":
                            //Call the change hosts function passing in the URI to the hosts.exe on the sharepoint
                            bCreateHosts = true;
                            bUpdateIEProxy = true;
                            bUpdateFFProxy = true;
                            break;
                        case "/hosts":
                        case "-hosts":
                        case "/h":
                        case "-h":
                            bCreateHosts = true;
                            break;
                        case "/ie":
                        case "-ie":
                            bUpdateIEProxy = true;
                            break;
                        case "/ff":
                        case "-ff":
                            bUpdateFFProxy = true;
                            break;
                        case "/merge":
                        case "-merge":
                        case "/m":
                        case "-m":
                            bMergeHosts = true;
                            break;
                        case "/help":
                        case "-help":
                        case "/?":
                        case "-?":
                            Console.WriteLine("This is the version checked in under product/TestSource/Common/Utilities/CreateHosts");
                            Console.WriteLine();
                            bParseError = true;
                            break;
                        default:
                            Console.WriteLine("Unknown parameter: '{0}'", arg);
                            bParseError = true;
                            break;
                    } //Switch
                    #endregion 
                } //Foreach

                if (bParseError)
                    DisplayHelp();
                else
                {
                    if (bMergeHosts)
                    {
                        MergeHosts();
                    }
                    else if (bCreateHosts)
                    {
                        CreateHosts();
                    }
                    else
                    {
                        Console.WriteLine("--Not create hosts file.--");
                        //No-op, did not want merge OR create.
                    }

                    if (bUpdateIEProxy)
                    {
                        UpdateIEProxy();
                    }
                    else
                    {
                        Console.WriteLine("--No IE update--");
                    }

                    if (bUpdateFFProxy)
                    {
                        UpdateFFProxy();
                    }
                    else
                    {
                        Console.WriteLine("--No FF update--");
                    }

                }
            }
            else
            {
                //Call the change hosts function and proxy exception function
                CreateHosts();
                SetProxyExceptions();

                //Wait for user input before closing the console app
                Console.WriteLine();
            }
        }

        private static void DisplayHelp()
        {
            Console.WriteLine(
@"Description: This console application will replace your current hosts file with 
   a hosts file that will enable users to access all necessary servers for Xbox.com
   test environments. There is also an option that will allow you to overwrite proxy
   settings in IE so that you can access all the necessary servers through the
   corporate proxy.  A new feature will allow you to merge your existing Hosts file 
   with the one maintained by our server team.

  Note: this will throw exceptions if IE has never run, or Firefox is not installed.

Usage: CreateHosts.exe [/all | /a][/hosts | /h] [/merge | /m] [/ie] [/ff] [/? | /help]
  /hosts or /h     Create hosts file (which replaces existing hosts file)
  /ie              Configure Internet Explorer web exceptions and IEProxy
  /ff              Configure Firefox web exceptions and Proxy
  /all   or /a     Same as /hosts /ie /ff together)
  /merge or /m     Create hosts file only (merged with existing hots file)
  /?               Display this help screen

Note that you can use 1 or more parameters at a time.
  You can replace ' / '  with ' - ' on switches
  If you specify /m and /h it will do a merge with hosts file 
  If you call this exec without parameters, set the hosts file
    and then query the user for what additional work to do.

");
            Console.WriteLine("Note: the following file is used as the template for the hosts file:");
            Console.WriteLine("  \"{0}\\hostsEntries.txt\" ", sharepointUrl);
            Console.WriteLine("  \"{0}\\proxyExceptions.txt\" ", sharepointUrl);
            Console.WriteLine("  \"{0}\\userPreferences.txt\" ", sharepointUrl);
            Console.WriteLine();
        }

        /// <summary>
        /// This method prompts the user to set their proxy exceptions for a variety of browser types
        /// </summary>
        /// <param name="arg">And argument that will skip the questions and just enable proxy exceptions for all browsers</param>
        public static void SetProxyExceptions()
        {
            //Ask the user if they want to overwrite their IE settings
            StringBuilder chooseBrowserUpdates = new StringBuilder();
            chooseBrowserUpdates.AppendLine();
            chooseBrowserUpdates.AppendLine("What browser(s) would you like to set proxy exceptions for?");
            chooseBrowserUpdates.AppendLine("  1. Internet Explorer");
            chooseBrowserUpdates.AppendLine("  2. Firefox");
            chooseBrowserUpdates.AppendLine("  3. All Browsers");
            chooseBrowserUpdates.Append("Please enter a number from the list: ");
            Console.Write(chooseBrowserUpdates);

            //Read the number and perform proxy exceptions updates for the appropriate browser(s)
            switch (Console.ReadLine().ToLower(CultureInfo.CurrentCulture).Trim().ToString())
            {
                case "1":
                    UpdateIEProxy();
                    return;
                case "2":
                    UpdateFFProxy();
                    return;
                case "3":
                case "all":
                    UpdateIEProxy();
                    UpdateFFProxy();
                    return;
                default:
                    throw new CreateHostsException("Your proxy settings have NOT been updated because you entered an invalid option!");
            }
        }

        /// <summary>
        /// This method grabs the latest hosts.txt entries from the sharepoint site and replaces
        /// the local users hosts with the new data.
        /// </summary>
        public static void CreateHosts()
        {
            Console.WriteLine("Give me a moment to update your hosts file...");

            //Set a URI to a global HOSTS configuration stored on the Xbox.com sharepoint site
            //TODO: Configure this app so that the URI isn't hardcoded
            Uri hostsUri = new Uri(sharepointUrl_Hosts);

            //Set the paths to the files we want to manipulate as streams
            string oldHosts = Environment.ExpandEnvironmentVariables("%windir%") + "\\system32\\drivers\\etc\\hosts";
            string newHosts = Path.GetTempFileName();

            //Create a stream and stream writer for the temp file that we use to copy hosts data into
            FileStream newHostsFile = new FileStream(newHosts, FileMode.Create, FileAccess.ReadWrite);
            StreamWriter newHostsStream = new StreamWriter(newHostsFile);
            /*
             * If we receive a 200 code from the sharepoint URI where we get the hosts information then we continue
             * and write the information from the hosts file to our newHosts file stream. We then replace the old hosts
             * file with the new one.
             */
            try
            {
                string resultCode;
                if (hostsUri.IsFile)
                {
                    resultCode = GetFileResponse(hostsUri);
                }
                else
                {
                    resultCode = GetURIResponse(hostsUri);
                }

                if (resultCode == HttpStatusCode.OK.ToString())
                {
                    newHostsStream.Write(Program.responseData);
                    newHostsStream.Close();

                    //Replace the hosts file with the temp file
                    if (!CreateHostsFile(newHosts, oldHosts))
                        throw new CreateHostsException("The old hosts file could not be replaced!");
                }
                else
                {
                    throw new CreateHostsException("The URI used returned the following status " + Program.responseStatus.ToString());
                }
            }
            catch (Exception e)
            {
                System.Console.WriteLine("URL: {0}", sharepointUrl_Hosts);
                System.Console.WriteLine("Unable to download Hosts file: '{0}'", e.ToString());
            }
        
        }
        /// <summary>
        /// This method grabs the latest hosts.txt entries from the sharepoint site and merges
        /// the local users hosts with the new data.
        /// </summary>
        private static void MergeHosts()
        {
            Console.WriteLine("Give me a moment to merge your hosts file...");

            //Set a URI to a global HOSTS configuration stored on the Xbox.com sharepoint site
            //TODO: Configure this app so that the URI isn't hardcoded
            Uri hostsUri = new Uri(sharepointUrl_Hosts);

            //Set the paths to the files we want to manipulate as streams
            string oldHosts = Environment.ExpandEnvironmentVariables("%windir%") + "\\system32\\drivers\\etc\\hosts";
            string newHosts = Path.GetTempFileName();

            //Create a stream and stream writer for the temp file that we use to copy hosts data into
            FileStream newHostsFile = new FileStream(newHosts, FileMode.Create, FileAccess.ReadWrite);
            StreamWriter newHostsStream = new StreamWriter(newHostsFile);

            /*
             * If we receive a 200 code from the sharepoint URI where we get the hosts information then we continue
             * and write the information from the hosts file to our newHosts file stream. We then replace the old hosts
             * file with the new one.
             */
            if (GetFileResponse(hostsUri) == HttpStatusCode.OK.ToString())
            {
                //Copy Existing file to a new file with date/time based name.
                DateTime now = DateTime.Now;
                string TimeAsString = string.Format("{0:0000}.{1:00}.{2:00}_{3:00}.{4:00}.{5:00}", now.Year, now.Month, now.Day, now.Hour, now.Minute, now.Second);
                string BackupHostsName = string.Format("{0}.{1}", oldHosts, TimeAsString);
                File.Copy(oldHosts, BackupHostsName);

                newHostsStream.Write(Program.responseData);
                newHostsStream.Close();

                //Replace the hosts file with the temp file
                //TODO - Do the merge here..
                //throw new System.NotImplementedException();

                if (!CreateHostsFile(newHosts, oldHosts))
                    throw new CreateHostsException("The backup hosts file could not be created!");
            }
            else
            {
                throw new CreateHostsException("The URI used returned the following status " + Program.responseStatus.ToString());
            }
        }
        /// <summary>
        /// This method takes a URI parameter and returns the status and data from the URI.
        /// The status is placed in the global variable rsStatus and the data is returned in rsFromServer.
        /// Both of these variables can be accessed from any method inside of this project.
        /// </summary>
        /// <param name="hURI">A valid URI to any location</param>
        /// <returns>The return status of the URI called</returns>
        public static string GetURIResponse(Uri Uri)
        {
            //Declare variables
            HttpWebResponse response;
            Stream dataStream;

            //Create a request for the URI
            WebRequest request = WebRequest.Create(Uri.ToString());

            //Set the credentials to the current network level
            request.Credentials = CredentialCache.DefaultNetworkCredentials;

            //Capture the response from the request
            try
            {
                response = (HttpWebResponse)request.GetResponse();
                
                //Get the stream returned from the server
                dataStream = response.GetResponseStream();
                Program.responseStatus = response.StatusDescription;

                //Since we succeeded in getting data we scrape it into text
                StreamReader reader = new StreamReader(dataStream);
                Program.responseData = reader.ReadToEnd();

                //Close out all objects
                reader.Close();
                dataStream.Close();
                response.Close();

                //Return the stream containing the hosts file information
                return Program.responseStatus;
            }
            catch (WebException e)
            {
                throw new CreateHostsException("There was a problem reaching the requested Uri: " + request.RequestUri.AbsoluteUri, e);
            }
        }
        /// <summary>
        /// This method takes a URI parameter and returns the status and data from the URI.
        /// The status is placed in the global variable rsStatus and the data is returned in rsFromServer.
        /// Both of these variables can be accessed from any method inside of this project.
        /// </summary>
        /// <param name="hURI">A valid URI to any location</param>
        /// <returns>The return status of the URI called</returns>
        public static string GetFileResponse(Uri Uri)
        {
            //Declare variables
            FileWebResponse response;
            Stream dataStream;

            //Create a request for the URI
            WebRequest request = WebRequest.Create(Uri);

            //Set the credentials to the current network level
            request.Credentials = CredentialCache.DefaultNetworkCredentials;

            //Capture the response from the request
            try
            {
                WebResponse TempObject = request.GetResponse();
                response = (FileWebResponse)TempObject;


                //Get the stream returned from the server
                dataStream = response.GetResponseStream();
                //Program.responseStatus = response.StatusDescription;

                //Since we succeeded in getting data we scrape it into text
                StreamReader reader = new StreamReader(dataStream);
                Program.responseData = reader.ReadToEnd();

                //Close out all objects
                reader.Close();
                dataStream.Close();
                response.Close();

                //Return the stream containing the hosts file information
                //return Program.responseStatus;
                if (Program.responseData.Length > 0)
                    return HttpStatusCode.OK.ToString();
                else
                    return HttpStatusCode.BadRequest.ToString();

            }
            catch (WebException e)
            {
                throw new CreateHostsException("There was a problem reaching the requested Uri: " + request.RequestUri.AbsoluteUri, e);
            }
        }
        /// <summary>
        /// Performs a file replacement of an old file with a new one
        /// </summary>
        /// <param name="newFile">The new file you want to replace the old one with.</param>
        /// <param name="oldFile">The old file that you no longer care about and just want to be friends with.</param>
        public static bool CreateHostsFile(string newFile, string oldFile)
        {
            //Set a boolean to track the success of the replace method (default to false)
            bool fileReplaced = false;

            //Overwrite the hosts file with the new one we've generated
            FileInfo fileInfo = new FileInfo(newFile);

            //Remove the .txt file extension from the temporary hosts file as the default hosts file has no extension.
            fileInfo.CopyTo(Path.ChangeExtension(oldFile, ""), true);
            fileInfo.Delete(); //Delete the temporary file we created

            //Write out to the console to inform the user that the replacement succeeded.
            Console.WriteLine();
            Console.WriteLine("...SUCCESS...");
            Console.WriteLine("Hosts file successfully updated!");

            //Set the file replaced status to true.
            fileReplaced = true;

            //Return the boolean status
            return fileReplaced;
        }
        /// <summary>
        /// Replaces or copies a new user.js file into a Firefox users profile directory
        /// </summary>
        /// <param name="file">The name of the file you want to insert</param>
        /// <returns></returns>
        public static bool CreateUserFile(string filePath, string fileContents)
        {
            //Set a boolean to track the success of the replace method (default to false)
            bool fileCreated = false;

            //Create the new user.js file
            try
            {
                FileInfo fileInfo = new FileInfo(filePath + @"\user.js");
                StreamWriter fileStream = fileInfo.CreateText();

                //Write the string contents to the file and close the stream
                fileStream.Write(fileContents);
                fileStream.Close();

                //Set the file replaced status to true.
                fileCreated = true;
            }
            catch
            {
                throw;
            }

            //Return the boolean status
            return fileCreated;
        }
        /// <summary>
        /// Performs an update of the Internet Explorer proxy settings
        /// </summary>
        public static void UpdateIEProxy()
        {
            //Set static registry path entries for the Internet Explorer settings we want to change
            string IEPath = @"Software\Microsoft\Windows\CurrentVersion\Internet Settings\";
            string IEPathConnections = @"Software\Microsoft\Windows\CurrentVersion\Internet Settings\Connections\";
            //Set a URI to a global PROXY configuration stored on the Xbox.com sharepoint site
            //TODO: Configure this app so that the URI isn't hardcoded
            Uri proxyExceptionsURI = new Uri(sharepointUrl_ProxyExceptions);

            //Open the keys that we want to edit in the registry
            RegistryKey regKeyIEProxy = Registry.CurrentUser.OpenSubKey(IEPath, true);
            RegistryKey regKeyIEConnections = Registry.CurrentUser.OpenSubKey(IEPathConnections, true);

            //Enable the Proxy
            regKeyIEProxy.SetValue("ProxyEnable", "1", RegistryValueKind.DWord);

            //Set the ProxyServer value
            regKeyIEProxy.SetValue("ProxyServer", strProxyServer);

            //Get the current proxy exception list from the web
            string HttpStatus;
            if (proxyExceptionsURI.IsFile)
            {
                HttpStatus = GetFileResponse(proxyExceptionsURI);
            }
            else
            {
                HttpStatus = GetURIResponse(proxyExceptionsURI);
            }

            if (HttpStatus != HttpStatusCode.OK.ToString())
            {
                throw new CreateHostsException("The Uri for proxy exceptions returned the following HTTP status: " + HttpStatus);
            }

            //Set the ProxyException value with the value we got from the proxy table on the Xbox.com sharepoint site
            // Set the "Bypass proxy server for local addresses" checkbox by adding it to the ProxyExceptions string
            string proxyOverrideString = Program.responseData;
            if (!proxyOverrideString.Contains("<local>"))
            {
                proxyOverrideString += ";<local>"; //"Bypass proxy server for local addresses" 
            }

            regKeyIEProxy.SetValue("ProxyOverride", proxyOverrideString);

            /*
            * Determine if the Automatcially Detect Settings checkbox is enabled in IE.
            * If so, we change the byte value to 2E which will uncheck the box.
            * Otherwise we just leave the setting alone
            */
            byte[] disableAutoDetect = regKeyIEConnections.GetValue("DefaultConnectionSettings") as byte[];

            try
            {
                //The value for this checkbox is different by OS (XP or Vista/Server)
                switch (Environment.OSVersion.Version.Major)
                {
                    case 5:
                        disableAutoDetect[8] = 1; //Windows XP
                        break;
                    case 6:
                    case 7:
                        disableAutoDetect[8] = 3; //Windows Vista/Server
                        break;
                }
            }
            catch (System.NullReferenceException e)
            {
                Console.WriteLine("NullReference exception caught - the browser must be opened at least once by this user:{0}", e);
                throw new System.NullReferenceException("System.NullReferenceException - The browser wasn't opened at least once by this user.", e);
            }

            //Set the Default Connection Settings
            regKeyIEConnections.SetValue("DefaultConnectionSettings", disableAutoDetect);

            //Display a message that the settings were updated
            Console.WriteLine();
            Console.WriteLine("...SUCCESS...");
            Console.WriteLine("IE settings successfully updated!");
        }
        /// <summary>
        /// Performs an update of the Firefox proxy settings
        /// </summary>
        public static void UpdateFFProxy()
        {
            /*
             * ---- From http://www.mozilla.org/unix/customizing.html#prefs ----
             * Normal prefs are kept in prefs.js in the user's profile directory 
             * (which is overwritten by Mozilla every time a pref is changed), 
             * but here's a tip: prefs or other JavaScript that you don't want overwritten (e.g. comments) 
             * can be put in a file called user.js in the same directory, which is under the user's control 
             * and is read but never written by Mozilla.
             * 
             * One caution with using user.js: prefs set to non-default values in user.js are also 
             * written to prefs.js, so removing or commenting out pref settings in user.js doesn't 
             * necessarily cause Mozilla to stop using your previous pref setting. If you change user.js 
             * and aren't getting the results you expect, be sure to check prefs.js to make sure it 
             * isn't setting a conflicting value.
             */

            //Set a URI to a global users file that we will copy to all FF profiles. We append this data with the current exception list as well
            //TODO: Configure this app so that the URI isn't hardcoded
            Uri userUri = new Uri(sharepointUrl_UserPreferences);
            Uri proxyExceptionsUri = new Uri(sharepointUrl_ProxyExceptions);

            //Create a string to hold the contents of the user file
            StringBuilder userContents = new StringBuilder(String.Empty);

            //Get the current user.js file data from the sharepoint site
            string UserStatus;
            if (userUri.IsFile)
            {
                UserStatus = GetFileResponse(userUri);
            }
            else
            {
                UserStatus = GetURIResponse(userUri);
            }


            if (UserStatus == HttpStatusCode.OK.ToString())
            {
                //Write the default user.js file data to our string
                userContents.AppendLine(Program.responseData.ToString());
            }
            else
            {
                throw new CreateHostsException("The Uri for the user file returned the following HTTP status: " + Program.responseStatus);
            }

            string ProxyExceptionStatus;
            if (proxyExceptionsUri.IsFile)
            {
                ProxyExceptionStatus = GetFileResponse(proxyExceptionsUri);
            }
            else
            {
                ProxyExceptionStatus = GetURIResponse(proxyExceptionsUri);
            }

            //Get the latest proxy exception data from the sharepoint site
            if (ProxyExceptionStatus == HttpStatusCode.OK.ToString())
            {
                //Write the current proxy exceptions to our string
                userContents.AppendLine("user_pref(\"network.proxy.no_proxies_on\", \""
                    + Program.responseData + "\");");
            }
            else
            {
                throw new CreateHostsException("The Uri for the user file returned the following HTTP status: " + Program.responseStatus);
            }

            #region Update the users.js file with the information from the userPreferences file on sharepoint
            //Ensure that the Firefox profiles directory exists
            try
            {
                //Get a list of all directories within the Firefox Profiles path
                string[] subdirEntries = Directory.GetDirectories(Environment.ExpandEnvironmentVariables("%appdata%")
                    + @"\Mozilla\Firefox\Profiles");

                //For each directory in the directory we want to scan for the proxy exceptions file
                foreach (string subdir in subdirEntries)
                {
                    //Replace the old users.js file with our new one
                    if (!CreateUserFile(subdir, userContents.ToString()))
                    {
                        throw new CreateHostsException("The user file could not be added or replace for the following directory: " + subdir.ToString());
                    }
                }
            }
            catch (System.IO.DirectoryNotFoundException)
            {
                throw new CreateHostsException("The necessary Firefox profile directory does not exist. Make sure Firefox is installed.");
            }
            #endregion

            //Display a message that the settings were updated
            Console.WriteLine();
            Console.WriteLine("...SUCCESS...");
            Console.WriteLine("Firefox settings successfully updated!");
        }
        /// <summary>
        /// A general exception handler called whenever any function in the app generates an error in code
        /// </summary>
        /// <param name="sender">The sender object information</param>
        /// <param name="args">Any arguments passed to the unhandled acception</param>
        static void CreateHostsHandler(object sender, UnhandledExceptionEventArgs args)
        {
            Exception e = (Exception)args.ExceptionObject;
            Console.WriteLine("The following exception occured: " + e.Message);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\CreateXboxLiveAccount\CreateXboxLiveAccount\XboxAccount.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UserLib;
using live.common;


namespace Test.Common.Library.CreateXboxLiveAccount
{
    /// <summary>
    /// Class which contains the funtions to create the Xboxlive accounts.
    /// </summary>
    public class XboxAccount
    {
        #region Create The User Account

        #region CreateAccount overload

        #region Create a default user.

        /// <summary>
        /// It creates default XBL user with all the default settings.
        /// An Adult, EN-US,Gold user with 0 Frineds,0 messages and 0 Players.
        /// Default password will be supersecret 
        /// </summary>
        /// <returns>It returns UserLib.Account which represents a user.</returns>
        public UserLib.Account CreateAccount()
        {
            UserLib.Account user = new Account();
            return user;

        }
        #endregion

        #region Create a Silver user.
        /// <summary>
        /// Creates a user with specified accountTier type(which is also know as Account type). It can be either Silver or Gold.
        /// </summary>
        /// <param name="tier">It defines the Tier type of the user you are creating.UserLib.AccountTier enum is used to select the different Tiers.</param>
        /// <returns>It returns UserLib.Account which represents a user.</returns>
        public UserLib.Account CreateAccount(UserLib.AccountTier tier)
        {
            UserLib.Account user;
            UserSettings _userSettings = new UserSettings();
            _userSettings.UserTier = tier;
            ValidateUserSetting(_userSettings);
            user = CreateAccount(_userSettings);
            return user;
        } 

        #endregion

        #region Create user with Achievements and Gamer score
        /// <summary>
        /// Create a user with the 0, 1 or more achievements.
        /// </summary>
        /// <param name="numberOfGamesPlayed">Specifies the number of games played.</param>
        /// <param name="playerSkill">Specifies the Player skill which will decide the no. of achievements to be awarded.Player skill can be None,Casual,Novice and Hardcore. Default value is None.</param>
        /// <returns>It returns UserLib.Account which represents a user.</returns>
        public UserLib.Account CreateAccount(int numberOfGamesPlayed, PlayerSkill playerSkill)
        {
            UserLib.Account user;

            //Creating the UserSettings using the passed parameters.
            UserSettings _userSetting = new UserSettings();
            _userSetting.NumberOfGamesPlayed = numberOfGamesPlayed;
            _userSetting.PlayerSkill = playerSkill;
            //Validating the usersettings.
            ValidateUserSetting(_userSetting);
            user = CreateAccount(_userSetting);

            return user;

        }

        #endregion

        #region Create user with specified friends,players and messages

        /// <summary>
        /// Creates an XBL account with specified number of Friends,Messages and RecentPlayers.
        /// </summary>
        /// <param name="numberOfFriends">Specifies the number of Friends.</param>
        /// <param name="numberOfMessages">Specifies the number of Messages.</param>
        /// <param name="numberOfRecentPlayers">Specifies the number of RecentPlayers.</param>
        /// <returns>It returns UserLib.Account which represents a user.</returns>
        public UserLib.Account CreateAccount(int numberOfFriends, int numberOfMessages, int numberOfRecentPlayers)
        {
            UserLib.Account user;

            //Creating the UserSettings using the passed parameters.
            UserSettings _userSetting = new UserSettings();
            _userSetting.NumberOfFriends = numberOfFriends;
            _userSetting.NumberOfMessages = numberOfMessages;
            _userSetting.NumberOfPlayers = numberOfRecentPlayers;
            //Validating the usersettings.
            ValidateUserSetting(_userSetting);
            user = CreateAccount(_userSetting);

            return user;

        }

        #endregion

        #region Create user with specified Microsoft points
        /// <summary>
        /// Creates a XBL account and allocate the specified Microsoft points to it.
        /// </summary>
        /// <param name="microsoftPoints">Number of Microsoft points needs to be assign to the user. It will allocate the MS points in the chunks of 500,1000,2000 and 5000</param>
        /// <returns>It returns UserLib.Account which represents a user.</returns>
        public UserLib.Account CreateAccount(int microsoftPoints)
        {
            UserLib.Account user;
            UserSettings _userSettings = new UserSettings();
            _userSettings.MicrosoftPoints = microsoftPoints;
            ValidateUserSetting(_userSettings);
            user = CreateAccount(_userSettings);
            return user;

        }
        #endregion

        #region Create user with Specified Username and Password
        /// <summary>
        /// Creats a XBL account with the specified Username and password
        /// </summary>
        /// <param name="memberName">Contains the MemberName.In case of Null or empty string a random member name will be generated.</param>
        /// <param name="password">Contains the Password. In case of Null or empty string a default password will be generated which is 'supersecret'.</param>
        /// <returns>It returns UserLib.Account which represents a user.</returns>
        public UserLib.Account CreateAccount(string memberName, string password)
        {
            UserLib.Account user;
            UserSettings _userSettings = new UserSettings();
            _userSettings.MemberName = memberName;
            _userSettings.Password = password;
            ValidateUserSetting(_userSettings);
            user = CreateAccount(_userSettings);
            return user;

        }

        #endregion

        #region Create user with specified Username, Password and Gamertag
        /// <summary>
        /// Creates a XBL account with the specified Username,Password and Gamertag.
        /// </summary>
        /// <param name="memberName">Contains the MemberName.In case of Null or empty string a random member name will be generated.</param>
        /// <param name="password">Contains the Password. In case of Null or empty string a default password will be generated which is 'supersecret'.</param>
        /// <param name="gamertag">Gamertag of the user you are creating.It should not be more than 15 char.</param>
        /// <returns>It returns UserLib.Account which represents a user.</returns>
        public UserLib.Account CreateAccount(string memberName, string password, string gamertag)
        {
            UserLib.Account user;
            UserSettings _userSettings = new UserSettings();
            _userSettings.MemberName = memberName;
            _userSettings.Password = password;
            _userSettings.GamerTag = gamertag;
            ValidateUserSetting(_userSettings);
            user = CreateAccount(_userSettings);
            return user;
        }

        #endregion

        #region Create custom user
        /// <summary>
        /// Creats a XBL user for specified settings.
        /// </summary>
        /// <param name="memberName">The membername name user want to create. In case of Null or empty string a random member name will be generated.</param>
        /// <param name="password">Password for the user which you are creating. In case of Null or empty string a default password 'supersecret' will be generated.</param>
        /// <param name="gamerTag">Gamertag for the user.</param>
        /// <param name="numberOfFriends">The number of friends a created user should have. In case of Null or empty string a random Gamertag will be generated</param>
        /// <param name="numberOfMessages">The number of messages a created user should have.</param>
        /// <param name="numberOfPlayers">The number of recent players a created user should have. </param>
        /// <param name="numberOfGamesPlayed">Numbers of games played by the user.</param>
        /// <param name="playerSkill">Skill of the player. This decide how many achievements user will how.Player skill can be None,Casual,Novice and Hardcore. Default value is None.</param>
        /// <param name="microsoftPoint">Microsoft points a created user should have.</param>
        /// <param name="environment"> Environment value. It can be either "Test", "Stress" or "Stress2". In case of Null or empty string 'Test' ENV will be used as default ENV.</param>
        /// <returns>It returns UserLib.Account which represents a user.</returns>
        public UserLib.Account CreateAccount(string memberName, string password,
                                             string gamerTag, int numberOfFriends,
                                             int numberOfMessages, int numberOfPlayers,
                                             int numberOfGamesPlayed, PlayerSkill playerSkill,
                                             int microsoftPoint, string environment)
        {
            UserLib.Account user;
            UserSettings _userSettings = new UserSettings();

            if (!string.IsNullOrEmpty(memberName))
            {
                _userSettings.MemberName = memberName;
                if (!String.IsNullOrEmpty(password))
                {
                    _userSettings.Password = password;
                }
            }

            if (!string.IsNullOrEmpty(gamerTag))
            {
                _userSettings.GamerTag = gamerTag;
            }

            if (!string.IsNullOrEmpty(environment))
            {
                if (environment.ToLower() == "test" || environment.ToLower() == "stress" || environment.ToLower() == "stress2")
                {
                    _userSettings.ENV = environment;

                }

            }

            _userSettings.NumberOfFriends = numberOfFriends;
            _userSettings.NumberOfMessages = numberOfMessages;
            _userSettings.NumberOfPlayers = numberOfPlayers;
            _userSettings.NumberOfGamesPlayed = numberOfGamesPlayed;
            _userSettings.PlayerSkill = playerSkill;
            _userSettings.MicrosoftPoints = microsoftPoint;   
            ValidateUserSetting(_userSettings);
            user = CreateAccount(_userSettings);

            return user;

        }

        #endregion


        #endregion


        #region Create Account Main Function
        /// <summary>
        /// Creates a XBL user with the specified userSettings.
        /// </summary>
        /// <param name="userSettings">Store the usersettings.</param>
        /// <returns>It returns UserLib.Account which represents a user.</returns>
        public UserLib.Account CreateAccount(UserSettings userSettings)
        {
            try
            {
                ValidateUserSetting(userSettings);

                UserLib.Account user = null;
                XblUserTier _tier = XblUserTier.Gold;
                TargetEnvironment.SetEnvironment(userSettings.ENV);
                bool _needPoints = false;
                Offers.PointsOffers _points = Offers.PointsOffers.CC500US;

                #region Assign correct user Tier.

                //Assigning the correct Tier.
                if (userSettings.UserTier == AccountTier.Silver)
                {
                    _tier = XblUserTier.Silver;
                }
                else
                {
                    _tier = XblUserTier.Gold;
                }

                #endregion

                #region Assigning the correct Microsoft Points
                //Assigning the Correct points

                if (userSettings.MicrosoftPoints >= 500 && userSettings.MicrosoftPoints < 1000)
                {
                    _points = Offers.PointsOffers.CC500US;
                    _needPoints = true;
                    userSettings.MicrosoftPoints = 500;

                }
                if (userSettings.MicrosoftPoints >= 1000 && userSettings.MicrosoftPoints < 2000)
                {
                    _points = Offers.PointsOffers.CC1000US;
                    _needPoints = true;
                    userSettings.MicrosoftPoints = 1000;

                }
                if (userSettings.MicrosoftPoints >= 2000 && userSettings.MicrosoftPoints < 5000)
                {
                    _points = Offers.PointsOffers.CC2000US;
                    _needPoints = true;
                    userSettings.MicrosoftPoints = 2000;

                }
                if (userSettings.MicrosoftPoints >= 5000)
                {
                    _points = Offers.PointsOffers.CC5000US;
                    _needPoints = true;
                    userSettings.MicrosoftPoints = 5000;

                }

                #endregion

                #region Create a new user or retrieve an existing user.

                if (userSettings.WantToModifyExisitingAccout)
                {
                    if ((userSettings.MemberName != string.Empty || userSettings.MemberName != null) && (userSettings.Password != string.Empty || userSettings.Password != null))
                    {
                        user = new Account(userSettings.MemberName, userSettings.Password);

                    }
                }

                else
                {

                    //Creating the account settings for the new user.
                    UserLib.AccountSettings accountSettings = new UserLib.AccountSettings(_tier, (PassportType)userSettings.PassPortType,
                                                                                          (userSettings.MemberName != string.Empty) ? userSettings.MemberName : null,
                                                                                          (userSettings.Password != string.Empty) ? userSettings.Password : null,
                                                                                          (userSettings.GamerTag != string.Empty) ? userSettings.GamerTag : null,
                                                                                          userSettings.CountryId, userSettings.LanguageID, userSettings.ParentalControl, true);


                    user = new Account(accountSettings);

                }
                #endregion

                #region Edit Gamer Profile
                //Edit gamer profile

                user.GamerProfile.WriteProfileSettings((userSettings.Motto != string.Empty) ? userSettings.Motto : null,
                    (userSettings.Name != string.Empty) ? userSettings.Name : null,
                    (userSettings.Loc != string.Empty) ? userSettings.Loc : null,
                    (userSettings.Bio != string.Empty) ? userSettings.Bio : null,
                    null, null, null, userSettings.CountryId);

                #endregion

                #region Adding Friends, Messages and Players

                user.CreateCommunity(userSettings.NumberOfMessages, userSettings.NumberOfFriends, userSettings.NumberOfPlayers);

                #endregion

                #region Adding Microsoft Points
                //Adding Microsoft Points.
                if (_needPoints)
                {
                    user.AddCreditCard(live.common.CreditCardType.Visa, true);
                    uint pointsPurchased = 0;
                    pointsPurchased = user.PurchasePointsWithCreditCard(_points);
                }
                #endregion

                #region Adding Achievements
                if (userSettings.NumberOfGamesPlayed > 0)
                {
                    user.CreateGameHistory(userSettings.NumberOfGamesPlayed, userSettings.PlayerSkill);
                }
                //Adding achievements 
                #endregion

                #region Adding Privacy Settings
                //Adding Privacy settings
                //if (user.XblUser.Settings.UserPassportInfo.MemberName.Equals(user.XblUser.Settings.OwnerPassportInfo.MemberName)) //It is an Adult account.
                //{
                //    PrivacySettings _privacySettings = new PrivacySettings(userSettings.Privacy, userSettings.Privacy, userSettings.Privacy,
                //                                                           userSettings.Privacy, userSettings.Privacy,
                //                                                           userSettings.Privacy, userSettings.Privacy);
                //    user.ResetPrivacySettings(_privacySettings);


                //}
                //else
                //{
                //    FamilySettings _familySettings = new FamilySettings(userSettings.Privacy, userSettings.Privacy, userSettings.Privacy,
                //                                                           userSettings.Privacy, userSettings.Privacy,
                //                                                           userSettings.Privacy, userSettings.Privacy,
                //                                                           userSettings.FamilyOptions, userSettings.FamilyOptions,
                //                                                           userSettings.FamilyOptions, userSettings.FamilyOptions);
                //    user.ResetFamilySettings(_familySettings);

                //}

                #endregion

                return user;
            }
            catch (Exception)
            {
                throw;
            }

        }

        #endregion


        #endregion Create The User Account.


        #region Validate the UserSettings
        /// <summary>
        /// Validate all the properties of UserSettings object.
        /// </summary>
        /// <param name="userSet">It is a UserSettings object</param>
        public void ValidateUserSetting(UserSettings userSet)
        {
            try
            {

                #region Gamer Profile.
                //Validate Bio
                if (userSet.Bio != string.Empty)
                {
                    if (userSet.Bio.Length > GamerProfile.MaxBio)
                    {
                        throw new ArgumentOutOfRangeException("Bio is too long, max characters allowed = " + GamerProfile.MaxBio);
                    }
                }

                //Validate Motto
                if (userSet.Motto != string.Empty)
                {
                    if (userSet.Motto.Length > GamerProfile.MaxMotto)
                    {
                        throw new ArgumentOutOfRangeException("Motto is too long, max characters allowed = " + GamerProfile.MaxMotto);
                    }
                }

                //Validate Name
                if (userSet.Name != string.Empty)
                {
                    if (userSet.Name.Length > GamerProfile.MaxName)
                    {
                        throw new ArgumentOutOfRangeException("Name is too long, max characters allowed = " + GamerProfile.MaxName);
                    }

                }

                //Validate Loc
                if (userSet.Loc != string.Empty)
                {
                    if (userSet.Loc.Length > GamerProfile.MaxLocation)
                    {
                        throw new ArgumentOutOfRangeException("Location is too long, max characters allowed = " + GamerProfile.MaxLocation);
                    }
                }
                #endregion

                #region Community Parameters Validation.

                if (userSet.NumberOfFriends > Community.MaxFriends)
                {
                    throw new ArgumentOutOfRangeException(String.Format("{0} (cannot create more than {1} friends)", userSet.NumberOfFriends, Community.MaxFriends.ToString()));
                }
                if (userSet.NumberOfMessages > Community.MaxMessages)
                {
                    throw new ArgumentOutOfRangeException(String.Format("{0} (cannot create more than {1} messages)", userSet.NumberOfMessages, Community.MaxMessages.ToString()));
                }

                if (userSet.NumberOfPlayers > Community.MaxPlayers)
                {
                    throw new ArgumentOutOfRangeException(String.Format("{0} (cannot create more than {1} player)", userSet.NumberOfPlayers, Community.MaxPlayers.ToString()));
                }
                #endregion
                
            }
            catch (Exception)
            {
                throw;
            }
        }

        #endregion Validate the UserSettings

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\DOMInspector\DOMInspector\HTMLAttributeCollection.cs ===
﻿using System;
using System.Collections;
using System.Text;

namespace Test.Common.Library.DOMInspector
{
    /// <summary>
    /// Represents a collection of HTML DOM Element Attributes.
    /// </summary>
    public class HTMLAttributeCollection : CollectionBase
    {
        private HTMLElement g_ParentElement;

        /// <summary>
        /// Creates an empty collection of HTMLAttribute.
        /// </summary>
        public HTMLAttributeCollection()
		{
			g_ParentElement = null;
		}

		/// <summary>
		/// Creates an empty collection of HTMLAttribute with the specified HTML DOM Element.
		/// </summary>
        /// <param name="HTMLDOMElement">The parent HTML DOM Element.</param>
        public HTMLAttributeCollection(HTMLElement HTMLDOMElement)
		{
            g_ParentElement = HTMLDOMElement;
		}

        /// <summary>
        /// Gets or sets the value of a pre existing element in the Attribute Collection.
        /// </summary>
        /// <param name="index">The index of the element.</param>
        /// <returns></returns>
        public HTMLAttribute this[int index]
        {
            get { return (HTMLAttribute)this.List[index]; }

            set
            {
                try
                {
                    this.List[index] = value;
                }
                catch (Exception)
                {
                    throw;
                }
            }
        }
        
        /// <summary>
        /// Adds the HTML DOM Element Attribute to the collection.
        /// </summary>
        /// <param name="HTMLElementAttribute">The HTML DOM Element Attribute name-value pair.</param>
        /// <returns>An object of System.Int32 indicating the index where the attribute was added.</returns>
        public int Add(HTMLAttribute HTMLElementAttribute)
        {
            return this.List.Add(HTMLElementAttribute);
        }

        /// <summary>
        /// Gets the index of the specified HTML DOM Element Attribute within the collection.
        /// </summary>
        /// <param name="AttributeName">The name of the HTML DOM Element Attribute.</param>
        /// <returns>An object of System.Int32 specifying the zero-based index. -1 if not found.</returns>
        public int IndexOf(string AttributeName)
        {
            for (int m_AttributeIndex = 0; m_AttributeIndex < this.List.Count; m_AttributeIndex++)
            {
                if (String.Compare(this[m_AttributeIndex].Name, AttributeName, true) == 0)
                    return m_AttributeIndex;
            }
            return -1;
        }

        /// <summary>
        /// Finds the specified HTML DOM Element Attribute within the collection.
        /// </summary>
        /// <param name="AttributeName">The name of the HTML DOM Element Attribute.</param>
        /// <returns>An object of HTMLAttribute, or null if not found.</returns>
        public HTMLAttribute FindByName(string AttributeName)
        {
            int m_AttributeIndex = IndexOf(AttributeName);

            if (m_AttributeIndex == -1)
                return null;
            else
                return this[IndexOf(AttributeName)];
        }

        /// <summary>
        /// Gets the HTMLAttribute with the specified HTML DOM Element Attribute name.
        /// </summary>
        public HTMLAttribute this[string AttributeName]
        {
            get { return FindByName(AttributeName); }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\DOMInspector\DOMInspector\HTMLBaseNode.cs ===
﻿using System;
using System.Collections;
using System.Text;

namespace Test.Common.Library.DOMInspector
{
    /// <summary>
    /// Represents a base HTML node object.
    /// </summary>
    public abstract class HTMLBaseNode
    {
        /// <summary>
        /// HTMLElement representing the parent element of this node.
        /// </summary>
        private HTMLElement g_ParentElement;

        /// <summary>
        /// Initialize the HTMLBaseNode class.
        /// </summary>
        protected HTMLBaseNode()
        {
            g_ParentElement = null;
        }

        /// <summary>
        /// Gets the HTML rendering of this node.
        /// </summary>
        /// <returns>A string representing the HTML.</returns>
        public abstract override string ToString();

        /// <summary>
        /// Gets the HTML DOM representation of this node and all its child nodes.
        /// </summary>
        public abstract string ToHTMLDOM();

        /// <summary>
        /// Gets the Parent HTMLElement of this node.
        /// </summary>
        public HTMLElement Parent
        {
            get { return g_ParentElement; }
        }

        /// <summary>
        /// Gets the index of this node within the Parent's.
        /// -1 if this node does not exists in Parent's node collection.
        /// </summary>
        public int Index
        {
            get
            {
                if (g_ParentElement == null)
                    return -1;
                else
                    return g_ParentElement.ChildNodes.IndexOf(this);
            }
        }

        /// <summary>
        /// Gets a flag to indicate if this node is the Root node in the HTML DOM Tree.
        /// </summary>
        public bool IsRootNode
        {
            get { return g_ParentElement == null; }
        }

        /// <summary>
        /// Gets a flag to indicate if this node is a Child node in the HTML DOM Tree.
        /// </summary>
        public bool IsChildNode
        {
            get { return g_ParentElement != null; }
        }

        /// <summary>
        /// Gets a flag to indicate if this node is Parent node in the HTML DOM Tree.
        /// </summary>
        public bool IsParentNode
        {
            get
            {
                if (this is HTMLElement)
                    return ((HTMLElement)this).ChildNodes.Count > 0;
                else
                    return false;
            }
        }

        /// <summary>
        /// Checks if this node is a descendent of the specified node in the HTML DOM Tree.
        /// </summary>
        /// <param name="Node">The node whose descendent this node might be.</param>
        /// <returns>An object of System.Boolean.</returns>
        public bool IsDescendentOf(HTMLBaseNode Node)
        {
            HTMLBaseNode m_ParentNode = g_ParentElement;

            while (m_ParentNode != null)
            {
                if (m_ParentNode == Node)
                    return true;

                m_ParentNode = m_ParentNode.Parent;
            }

            return false;
        }

        /// <summary>
        /// Checks if this node is an ancestor of the specified node in the HTML DOM Tree.
        /// </summary>
        /// <param name="Node">The node to check if it is a child of this node.</param>
        /// <returns>An object of System.Boolean.</returns>
        public bool IsAncestorOf(HTMLBaseNode Node)
        {
            return Node.IsDescendentOf(this);
        }

        /// <summary>
        /// Gets the ancestor common to this node and the specified node.
        /// </summary>
        /// <param name="Node">The node to find the common ancestor with.</param>
        /// <returns>An object of HTMLBaseNode which is the common ancestor. Null if there aren't any.</returns>
        public HTMLBaseNode GetCommonAncestor(HTMLBaseNode Node)
        {
            HTMLBaseNode m_ThisNodeParent = this;

            while (m_ThisNodeParent != null)
            {
                HTMLBaseNode m_SpecifiedNodeParent = Node;
                while (m_SpecifiedNodeParent != null)
                {
                    if (m_ThisNodeParent == m_SpecifiedNodeParent)
                        return m_ThisNodeParent;

                    m_SpecifiedNodeParent = m_SpecifiedNodeParent.Parent;
                }
                m_ThisNodeParent = m_ThisNodeParent.Parent;
            }

            return null;
        }

        /// <summary>
        /// Gets the next sibling node of this node.
        /// </summary>
        public HTMLBaseNode NextSibling
        {
            get
            {
                if (Index == -1)
                    return null;
                else
                {
                    if (Parent.ChildNodes.Count > Index + 1)
                        return Parent.ChildNodes[Index + 1];
                    else
                        return null;
                }
            }
        }

        /// <summary>
        /// Gets the previous sibling node of this node.
        /// </summary>
        public HTMLBaseNode PreviousSibling
        {
            get
            {
                if (Index == -1)
                    return null;
                else
                {
                    if (Index > 0)
                        return Parent.ChildNodes[Index - 1];
                    else
                        return null;
                }
            }
        }

        /// <summary>
        /// Gets the first Child node of this node.
        /// </summary>
        public HTMLBaseNode FirstChild
        {
            get
            {
                if (this is HTMLElement)
                {
                    if (((HTMLElement)this).ChildNodes.Count == 0)
                        return null;
                    else
                        return ((HTMLElement)this).ChildNodes[0];
                }
                else
                    return null;
            }
        }

        /// <summary>
        /// Gets the last Child node of this node.
        /// </summary>
        public HTMLBaseNode LastChild
        {
            get
            {
                if (this is HTMLElement)
                {
                    if (((HTMLElement)this).ChildNodes.Count == 0)
                        return null;
                    else
                        return ((HTMLElement)this).ChildNodes[((HTMLElement)this).ChildNodes.Count - 1];
                }
                else
                    return null;
            }
        }

		/// <summary>
		/// Gets a flag to indicate if this node is an HTML Element node.
		/// </summary>
		/// <returns></returns>
        public bool IsHTMLElement()
		{
            return this is HTMLElement;
		}

        /// <summary>
        /// Gets a flag to indicate if this node is an HTML Text node.
        /// </summary>
        /// <returns></returns>
        public bool IsHTMLText()
        {
            return this is HTMLText;
        }

        /// <summary>
        /// Removes this node and all its child nodes from the HTML DOM Tree.
        /// </summary>
        public void Remove()
        {
            if (g_ParentElement != null)
                g_ParentElement.ChildNodes.RemoveAt(this.Index);
        }

        /// <summary>
        /// Sets the parent node of this node.
        /// </summary>
        /// <param name="ParentNode">The parent node of this node.</param>
        internal void SetParent(HTMLElement ParentNode)
        {
            g_ParentElement = ParentNode;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\DOMInspector\DOMInspector\HTMLBaseNodeCollection.cs ===
﻿using System;
using System.Collections;
using System.Text;

namespace Test.Common.Library.DOMInspector
{
    /// <summary>
    /// Represents a collection of HTML Base nodes.
    /// The order of nodes in the collection represents that of the original HTML document.
    /// </summary>
    public class HTMLBaseNodeCollection : CollectionBase
    {
        private HTMLElement g_HTMLParentElement;

        /// <summary>
        /// Creates an empty collection of HTMLBaseNode.
        /// </summary>
        public HTMLBaseNodeCollection()
        {
            g_HTMLParentElement = null;
        }

        /// <summary>
        /// Gets or sets the value of a pre existing HTMLBaseNode element at the specified index.
        /// collection.
        /// </summary>
        public HTMLBaseNode this[int index]
        {
            get { return (HTMLBaseNode)this.InnerList[index]; }

            set
            {
                if (g_HTMLParentElement != null)
                    value.SetParent(g_HTMLParentElement);

                this.InnerList[index] = value;
            }
        }

        /// <summary>
        /// Creates an empty collection of HTMLBaseNode with the specified HTML Parent Element.
        /// </summary>
        /// <param name="HTMLParentElement">The HTML Parent Element.</param>
        public HTMLBaseNodeCollection(HTMLElement HTMLParentElement)
        {
            g_HTMLParentElement = HTMLParentElement;
        }

        /// <summary>
        /// Adds the HTMLBaseNode object to the collection.
        /// </summary>
        /// <param name="HTMLNode">The HTML node to add to the collection.</param>
        /// <returns>An object of System.Int32 indicating the index where the node was added.</returns>
        public int Add(HTMLBaseNode HTMLNode)
        {
            if (g_HTMLParentElement != null)
                HTMLNode.SetParent(g_HTMLParentElement);

            return this.List.Add(HTMLNode);
        }

        /// <summary>
        /// Gets the index of the specified HTMLBaseNode in the collection.
        /// -1 if the node doe not exist.
        /// </summary>
        /// <param name="HTMLNode">The HTMLBaseNode whose index is to be found.</param>
        /// <returns>An object of System.Int32 indicating the index of the node in the collection. -1 if node does not exist.</returns>
        public int IndexOf(HTMLBaseNode HTMLNode)
        {
            return this.List.IndexOf(HTMLNode);
        }

        /// <summary>
        /// Inserts a HTMLBaseNode into the collection at the specified index.
        /// </summary>
        /// <param name="Index">The position at which to insert the node.</param>
        /// <param name="HTMLNode">The HTMLBaseNode to insert in the collection.</param>
        public void InsertNode(int Index, HTMLBaseNode HTMLNode)
        {
            if (g_HTMLParentElement != null)
                HTMLNode.SetParent(g_HTMLParentElement);

            this.InnerList.Insert(Index, HTMLNode);
        }

        /// <summary>
        /// Search though this collection of nodes for all elements with the
        /// specified name. 
        /// Nodes will be returned in the order as they appear in the HTML document.
        /// </summary>
        /// <param name="HTMLElementName">The name of the HTML element to find.</param>
        /// <param name="WillSearchChildren">Indicates whether the Child nodes will also be searched.</param>
        /// <returns>An object of HTMLBaseNodeCollection containing all the nodes that match.</returns>
        public HTMLBaseNodeCollection FindByName(string HTMLElementName, bool WillSearchChildren)
        {
            HTMLBaseNodeCollection m_ResultNodes = new HTMLBaseNodeCollection();

            foreach (HTMLBaseNode m_HTMLNode in this.List)
            {
                if (m_HTMLNode is HTMLElement)
                {
                    if (String.Compare(((HTMLElement)m_HTMLNode).TagName, HTMLElementName, true) == 0)
                        m_ResultNodes.Add(m_HTMLNode);

                    //Now search for children
                    if (WillSearchChildren)
                    {
                        foreach (HTMLBaseNode m_ChildNode in ((HTMLElement)m_HTMLNode).ChildNodes.FindByName(HTMLElementName, WillSearchChildren))
                            m_ResultNodes.Add(m_ChildNode);
                    }
                }
            }
            return m_ResultNodes;
        }

        /// <summary>
        /// Search though this collection of nodes and its children for all elements with the
        /// specified name. 
        /// Nodes will be returned in the order as they appear in the HTML document.
        /// </summary>
        /// <param name="HTMLElementName">The name of the HTML element to find.</param>
        /// <returns>An object of HTMLBaseNodeCollection containing all the nodes that match.</returns>
        public HTMLBaseNodeCollection FindByName(string HTMLElementName)
        {
            return FindByName(HTMLElementName, true);
        }

        /// <summary>
        /// Search through this collection of nodes for all elements with the 
        /// specified attribute name.
        /// </summary>
        /// <param name="HTMLAttributeName">The name of the attribute to search on.</param>
        /// <param name="WillSearchChildren">Indicates whether the Child nodes will also be searched.</param>
        /// <returns>An object of HTMLBaseNodeCollection containing all the nodes that match.</returns>
        public HTMLBaseNodeCollection FindByAttributeName(string HTMLAttributeName, bool WillSearchChildren)
        {
            HTMLBaseNodeCollection m_ResultNodes = new HTMLBaseNodeCollection();

            foreach (HTMLBaseNode m_HTMLNode in this.List)
            {
                if (m_HTMLNode is HTMLElement)
                {
                    foreach (HTMLAttribute m_HTMLAttribute in ((HTMLElement)m_HTMLNode).Attributes)
                    {
                        if (String.Compare(m_HTMLAttribute.Name, HTMLAttributeName, true) == 0)
                        {
                            m_ResultNodes.Add(m_HTMLNode);
                            break;
                        }
                    }
                    if (WillSearchChildren)
                    {
                        foreach (HTMLBaseNode m_ChildNode in ((HTMLElement)m_HTMLNode).ChildNodes.FindByAttributeName(HTMLAttributeName, WillSearchChildren))
                            m_ResultNodes.Add(m_ChildNode);
                    }
                }
            }

            return m_ResultNodes;
        }

        /// <summary>
        /// Search through this collection of nodes and its children for all elements with the 
        /// specified attribute name.
        /// </summary>
        /// <param name="HTMLAttributeName">The name of the attribute to search on.</param>
        /// <returns>An object of HTMLBaseNodeCollection containing all the nodes that match.</returns>
        public HTMLBaseNodeCollection FindByAttributeName(string HTMLAttributeName)
        {
            return FindByAttributeName(HTMLAttributeName, true);
        }

        /// <summary>
        /// Search through this collection of nodes for all elements with the
        /// specified attribute name value pair.
        /// </summary>
        /// <param name="HTMLAttributeName">The name of the attribute to search on.</param>
        /// <param name="HTMLAttributeValue">The value of the attribute to search on.</param>
        /// <param name="WillSearchChildren">Indicates whether the Child nodes will also be searched.</param>
        /// <returns>An object of HTMLBaseNodeCollection containing all the nodes that match.</returns>
        public HTMLBaseNodeCollection FindByAttributeNameValue(string HTMLAttributeName, string HTMLAttributeValue, bool WillSearchChildren)
        {
            HTMLBaseNodeCollection m_ResultNodes = new HTMLBaseNodeCollection();

            foreach (HTMLBaseNode m_HTMLNode in this.List)
            {
                if (m_HTMLNode is HTMLElement)
                {
                    foreach (HTMLAttribute m_HTMLAttribute in ((HTMLElement)m_HTMLNode).Attributes)
                    {
                        if ((String.Compare(m_HTMLAttribute.Name, HTMLAttributeName, true) == 0) &&
                            (String.Compare(m_HTMLAttribute.Value, HTMLAttributeValue, true) == 0))
                        {
                            m_ResultNodes.Add(m_HTMLNode);
                            break;
                        }
                    }
                    if (WillSearchChildren)
                    {
                        foreach (HTMLBaseNode m_ChildNode in ((HTMLElement)m_HTMLNode).ChildNodes.FindByAttributeNameValue(HTMLAttributeName, HTMLAttributeValue, WillSearchChildren))
                            m_ResultNodes.Add(m_ChildNode);
                    }
                }
            }

            return m_ResultNodes;
        }

        /// <summary>
        /// Search through this collection of nodes and its children for all elements with the
        /// specified attribute name value pair.
        /// </summary>
        /// <param name="HTMLAttributeName">The name of the attribute to search on.</param>
        /// <param name="HTMLAttributeValue">The value of the attribute to search on.</param>
        /// <returns>An object of HTMLBaseNodeCollection containing all the nodes that match.</returns>
        public HTMLBaseNodeCollection FindByAttributeNameValue(string HTMLAttributeName, string HTMLAttributeValue)
        {
            return FindByAttributeNameValue(HTMLAttributeName, HTMLAttributeValue, true);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\DOMInspector\DOMInspector\HTMLDocument.cs ===
﻿using System;
using System.Collections;
using System.Text;

namespace Test.Common.Library.DOMInspector
{
    /// <summary>
    /// Represents the basic HTML document.
    /// </summary>
    public class HTMLDocument
    {
        private HTMLBaseNodeCollection g_HTMLDocumentNodes = new HTMLBaseNodeCollection();

        /// <summary>
        /// Initialize a new instance of HTMLDocument object with
        /// the specified HTMLText.
        /// </summary>
        /// <param name="HTMLText">The HTML Text that will be represented by this object.</param>
        /// <param name="RemoveSpaces">Flag indicating if White Space is to be removed from the HTMLText.</param>
        public HTMLDocument(string HTMLText, bool RemoveSpaces)
        {
            HTMLParser m_Parser = new HTMLParser();
            m_Parser.IsRemoveEmptyElementText = RemoveSpaces;
            try
            {
                g_HTMLDocumentNodes = m_Parser.Parse(HTMLText);
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Gets the HTML DOM node tree represented by this object.
        /// </summary>
        /// <returns>An object of type HTMLBaseNodeCollection.</returns>
        public HTMLBaseNodeCollection GetHTMLDOMTree()
        {
            return g_HTMLDocumentNodes;
        }

        /// <summary>
        /// This will return the HTML used to represent this document.
        /// </summary>
        public string ToHTML()
        {
            StringBuilder m_HTML = new StringBuilder();
            foreach (HTMLBaseNode HTMLNode in g_HTMLDocumentNodes)
                m_HTML.Append(HTMLNode.ToHTMLDOM());

            return m_HTML.ToString();
        }

        /// <summary>
        /// Gets the Node collection representing this HTML Document.
        /// </summary>
        public HTMLBaseNodeCollection Nodes
        {
            get { return g_HTMLDocumentNodes; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\DOMInspector\DOMInspector\HTMLElement.cs ===
﻿using System;
using System.Text;

namespace Test.Common.Library.DOMInspector
{
    /// <summary>
    /// Represents an HTML DOM Element node.
    /// </summary>
    public class HTMLElement : HTMLBaseNode
    {
        private string g_HTMLElementName;
        private bool g_Terminated;
        private bool g_ExplicitTermination;
        private HTMLAttributeCollection g_HTMLElementAttributes;
        private HTMLBaseNodeCollection g_HTMLElementNodes;

        /// <summary>
        /// Construct a new HTML DOM Element with the specified HTML Tag name.
        /// </summary>
        /// <param name="ElementName">The Tag name of the HTML DOM Element.</param>
        public HTMLElement(string ElementName)
        {
            g_HTMLElementName = ElementName;
            g_Terminated = false;
            g_HTMLElementAttributes = new HTMLAttributeCollection(this);
            g_HTMLElementNodes = new HTMLBaseNodeCollection(this);
        }

        /// <summary>
        /// Gets or sets the Tag name for the HTML DOM Element.
        /// </summary>
        public string TagName
        {
            get { return g_HTMLElementName; }

            set { g_HTMLElementName = value; }
        }

        /// <summary>
        /// Gets or sets a value to indicate if the HTML DOM Element has been
        /// terminated either by '<![CDATA[<Tagname/>]]>' or '<![CDATA[</Tagname>]]>' method.
        /// </summary>
        internal bool IsTerminated
        {
            get
            {
                if (ChildNodes.Count > 0)
                    return false;
                else
                    return g_Terminated | g_ExplicitTermination;
            }

            set { g_Terminated = value; }
        }

        /// <summary>
        /// Gets or sets a value to indicate if the HTML DOM Element has been
        /// terminated explictly by '<![CDATA[</Tagname>]]>' method.
        /// </summary>
        internal bool IsExplicitlyTerminated
        {
            get { return g_ExplicitTermination; }

            set { g_ExplicitTermination = value; }
        }

        /// <summary>
        /// Gets all the child nodes of this node.
        /// </summary>
        public HTMLBaseNodeCollection ChildNodes
        {
            get
            {
                if(IsHTMLText())
                    throw new InvalidOperationException("An HtmlText node does not have child nodes.");

                return g_HTMLElementNodes;
            }
        }

        /// <summary>
        /// Gets the attributes associated with this node.
        /// </summary>
        public HTMLAttributeCollection Attributes
        {
            get { return g_HTMLElementAttributes; }
        }

        /// <summary>
        /// Gets the Text assciated with this node.
        /// </summary>
        public string Text
        {
            get
            {
                StringBuilder m_HTMLText = new StringBuilder();

                foreach (HTMLBaseNode m_ChildNode in ChildNodes)
                {
                    if (m_ChildNode is HTMLText)
                        m_HTMLText.Append(((HTMLText)m_ChildNode).NodeText);
                }

                return m_HTMLText.ToString();
            }
        }

        /// <summary>
        /// Gets the HTML rendering of this node.
        /// </summary>
        /// <returns>An object of System.String.</returns>
        public override string ToString()
        {
            string m_HTMLString = string.Empty;

            m_HTMLString = "<" + g_HTMLElementName;
            foreach (HTMLAttribute m_HTMLAttribute in Attributes)
                m_HTMLString += " " + m_HTMLAttribute.ToString();

            m_HTMLString += ">";

            return m_HTMLString;
        }

        /// <summary>
        /// Gets the HTML DOM representation of this node and all its child nodes.
        /// </summary>
        public override string ToHTMLDOM()
        {
            StringBuilder m_InnerHTML = new StringBuilder();

            m_InnerHTML.Append("<" + g_HTMLElementName);
            foreach (HTMLAttribute m_HTMLAttribute in Attributes)
                m_InnerHTML.Append(" " + m_HTMLAttribute.ToHTMLDOM());

            if (ChildNodes.Count > 0)
            {
                m_InnerHTML.Append(">");
                //Append Child Nodes
                foreach (HTMLBaseNode m_ChildNodes in ChildNodes)
                    m_InnerHTML.Append(m_ChildNodes.ToHTMLDOM());

                m_InnerHTML.Append("</" + g_HTMLElementName + ">");
            }
            else
            {
                if (IsExplicitlyTerminated)
                    m_InnerHTML.Append("></" + g_HTMLElementName + ">");
                else
                {
                    if (IsTerminated)
                        m_InnerHTML.Append("/>");
                    else
                        m_InnerHTML.Append(">");
                }
            }

            return m_InnerHTML.ToString();
        }

        /// <summary>
        /// Indicates if character escaping has to be skipped.
        /// </summary>
        internal bool SkipEscaping
        {
            get
            {
                return "script".Equals(TagName.ToLower()) || "style".Equals(TagName.ToLower());
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\FiddlerHandler\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\DOMInspector\DOMInspector\HTMLText.cs ===
﻿using System;
using System.Text;
using System.Web;

namespace Test.Common.Library.DOMInspector
{
    /// <summary>
    /// Represents a HTML Text.
    /// </summary>
    public class HTMLText : HTMLBaseNode
    {
        private String g_NodeText;

        /// <summary>
        /// Initializes a new HTML Text node with the specified Text.
        /// </summary>
        /// <param name="TextString">The Text content of the node.</param>
        public HTMLText(string TextString)
        {
            g_NodeText = TextString;
        }

        /// <summary>
        /// Gets or sets the text content associated with this HTML Text node.
        /// </summary>
        public string NodeText
        {
            get { return g_NodeText; }

            set { g_NodeText = value; }
        }

        /// <summary>
        /// Gets the HTML rendering of this node.
        /// </summary>
        /// <returns>An object of type System.String.</returns>
        public override string ToString()
        {
            return g_NodeText;
        }

        /// <summary>
        /// Gets the HTML DOM representation of this node and all its child nodes.
        /// </summary>
        public override string ToHTMLDOM()
        {
            if (SkipEscaping)
                return g_NodeText;
            else
                return HttpUtility.HtmlEncode(g_NodeText);
        }

        /// <summary>
        /// Indicates if character escaping has to be skipped.
        /// </summary>
        internal bool SkipEscaping
        {
            get
            {
                if (Parent == null)
                    return false;
                else
                    return ((HTMLElement)Parent).SkipEscaping;
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\DOMInspector\DOMInspector\HTMLParser.cs ===
﻿using System;
using System.IO;
using System.Collections;
using System.Collections.Specialized;
using System.Text;
using System.Web;

namespace Test.Common.Library.DOMInspector
{
    internal class HTMLParser
    {
        private static char[] G_WHITESPACECHAR = " \t\r\n".ToCharArray();
        private bool g_IsRemoveEmptyElementText = false;

        /// <summary>
        /// The Status of the HTML Parser.
        /// </summary>
        private enum HTMLParseStatus
        {
            TextRead = 0,
            EndTagRead = 1,
            StartTagRead = 2,
            AttributeNameRead = 3,
            AttributeValueRead = 4
        }

        /// <summary>
        /// Initialize a new instance of the the HTMLParser class.
        /// </summary>
        public HTMLParser()
        {
            //Do Nothing
        }


        /// <summary>
        /// Parse the specified HTML Text string and produce a HTML DOM Tree.
        /// </summary>
        /// <param name="HTMLTextString">The HTML Text string to be parsed.</param>
        /// <returns>An object of HTMLBaseNodeCollection, which represents the HTML DOM Tree.</returns>
        public HTMLBaseNodeCollection Parse(string HTMLTextString)
        {
            HTMLBaseNodeCollection m_HTMLDOMTree = new HTMLBaseNodeCollection();
            StringCollection m_Tokens;
            HTMLElement m_HTMLElement = null;
            int m_Index = 0;

            //Pre-Process
            HTMLTextString = PreprocessScript(HTMLTextString, "script");
            HTMLTextString = PreprocessScript(HTMLTextString, "style");

            HTMLTextString = RemoveHTMLComments(HTMLTextString);
            HTMLTextString = RemoveSGMLComments(HTMLTextString);
            m_Tokens = GetTokens(HTMLTextString);

            while (m_Index < m_Tokens.Count)
            {
                if ("<".Equals(m_Tokens[m_Index]))
                {
                    string m_TagName = string.Empty;

                    // Read open tag
                    m_Index++;
                    if (m_Index >= m_Tokens.Count)
                        break;

                    m_TagName = m_Tokens[m_Index];
                    m_Index++;
                    m_HTMLElement = new HTMLElement(m_TagName);

                    // read the attributes and values
                    while (m_Index < m_Tokens.Count && !">".Equals(m_Tokens[m_Index]) && !"/>".Equals(m_Tokens[m_Index]))
                    {
                        string m_AttributeName = m_Tokens[m_Index];
                        m_Index++;
                        if (m_Index < m_Tokens.Count && "=".Equals(m_Tokens[m_Index]))
                        {
                            string m_AttributeValue = string.Empty;

                            m_Index++;
                            if (m_Index < m_Tokens.Count)
                                m_AttributeValue = m_Tokens[m_Index];
                            else
                                m_AttributeValue = null;

                            m_Index++;
                            m_HTMLElement.Attributes.Add(new HTMLAttribute(m_AttributeName, HttpUtility.HtmlDecode(m_AttributeValue)));
                        }
                        else
                        {
                            if (m_Index < m_Tokens.Count)
                            {
                                // Null-value attribute
                                m_HTMLElement.Attributes.Add(new HTMLAttribute(m_AttributeName, null));
                            }
                        }
                    }

                    m_HTMLDOMTree.Add(m_HTMLElement);
                    if (m_Index < m_Tokens.Count && "/>".Equals(m_Tokens[m_Index]))
                    {
                        m_HTMLElement.IsTerminated = true;
                        m_Index++;
                        m_HTMLElement = null;
                    }
                    else
                    {
                        if (m_Index < m_Tokens.Count && ">".Equals(m_Tokens[m_Index]))
                            m_Index++;
                    }
                }
                else
                {
                    if (">".Equals(m_Tokens[m_Index]))
                        m_Index++;
                    else
                    {
                        if ("</".Equals(m_Tokens[m_Index]))
                        {
                            // Read close tag
                            m_Index++;
                            if (m_Index >= m_Tokens.Count) break;
                            string m_TagName = m_Tokens[m_Index];
                            m_Index++;

                            int m_OpenIndex = FindTagOpenNodeIndex(m_HTMLDOMTree, m_TagName);
                            if (m_OpenIndex != -1)
                                MoveNodesDown(ref m_HTMLDOMTree, m_OpenIndex + 1, (HTMLElement)m_HTMLDOMTree[m_OpenIndex]);
                            else
                            {
                                // Er, there is a close tag without an opening tag!!
                                // Do Nothing
                            }

                            // Skip to the end of this tag
                            while (m_Index < m_Tokens.Count && !">".Equals(m_Tokens[m_Index]))
                                m_Index++;
                            
                            if (m_Index < m_Tokens.Count && ">".Equals(m_Tokens[m_Index]))
                                m_Index++;
                            

                            m_HTMLElement = null;
                        }
                        else
                        {
                            // Read text
                            string m_TokenValue = m_Tokens[m_Index];
                            if (g_IsRemoveEmptyElementText)
                                m_TokenValue = RemoveWhitespace(m_TokenValue);
                            
                            m_TokenValue = DecodeScript(m_TokenValue);

                            if (g_IsRemoveEmptyElementText && m_TokenValue.Length == 0)
                            {
                                // Do nothing
                            }
                            else
                            {
                                if (!(m_HTMLElement != null && m_HTMLElement.SkipEscaping))
                                    m_TokenValue = HttpUtility.HtmlDecode(m_TokenValue);
                                
                                m_HTMLDOMTree.Add(new HTMLText(m_TokenValue));
                            }
                            m_Index++;
                        }
                    }
                }
            }
            return m_HTMLDOMTree;
        }

        /// <summary>
        /// Remove redundant whitespaces.
        /// </summary>
        /// <param name="InputString">The string from which the whitespaces will be removed.</param>
        /// <returns>An object of type System.String.</returns>
        private string RemoveWhitespace(string InputString)
        {
            string m_ProcessedString = string.Empty;

            m_ProcessedString = InputString.Replace("\r", "");
            m_ProcessedString = m_ProcessedString.Replace("\n", "");
            m_ProcessedString = m_ProcessedString.Replace("\t", " ");
            m_ProcessedString = m_ProcessedString.Trim();

            return m_ProcessedString;
        }

        /// <summary>
        /// Remove all HTML comments from the input string.
        /// </summary>
        /// <param name="InputString">The input HTML string.</param>
        /// <returns>An object of type System.String.</returns>
        private string RemoveHTMLComments(string InputString)
        {
            StringBuilder m_ProcessedString = new StringBuilder();
            int m_Counter = 0;
            bool m_InTag = false;

            while (m_Counter < InputString.Length)
            {
                if ((m_Counter + 4) < InputString.Length && InputString.Substring(m_Counter, 4).Equals("<!--"))
                {
                    //m_Counter += 4;
                    m_Counter = InputString.IndexOf("-->", m_Counter + 4);
                    if (m_Counter == -1)
                        break;

                    m_Counter += 3;
                }
                else
                {
                    if (InputString.Substring(m_Counter, 1).Equals("<"))
                    {
                        m_InTag = true;
                        m_ProcessedString.Append("<");
                        m_Counter++;
                    }
                    else
                    {
                        if (InputString.Substring(m_Counter, 1).Equals(">"))
                        {
                            m_InTag = false;
                            m_ProcessedString.Append(">");
                            m_Counter++;
                        }
                        else
                        {
                            if (InputString.Substring(m_Counter, 1).Equals("\"") && m_InTag)
                            {
                                int m_StartIndex = m_Counter;
                                m_Counter = InputString.IndexOf("\"", m_Counter + 1);
                                if (m_Counter == -1)
                                    break;

                                m_Counter++;
                                m_ProcessedString.Append(InputString.Substring(m_StartIndex, m_Counter - m_StartIndex));
                            }
                            else
                            {
                                if (InputString.Substring(m_Counter, 1).Equals("\'") && m_InTag)
                                {
                                    int m_StartIndex = m_Counter;
                                    m_Counter = InputString.IndexOf("\'", m_Counter + 1);
                                    if (m_Counter == -1)
                                        break;

                                    m_Counter++;
                                    m_ProcessedString.Append(InputString.Substring(m_StartIndex, m_Counter - m_StartIndex));
                                }
                                else
                                {
                                    m_ProcessedString.Append(InputString.Substring(m_Counter, 1));
                                    m_Counter++;
                                }
                            }
                        }
                    }
                }

            }

            return m_ProcessedString.ToString();
        }

        /// <summary>
        /// Remove all SGML comments from the input string.
        /// </summary>
        /// <param name="InputString">The input HTML string.</param>
        /// <returns>An object of type System.String.</returns>
        private string RemoveSGMLComments(string InputString)
        {
            StringBuilder m_ProcessedString = new StringBuilder();
            int m_Counter = 0;
            bool m_InTag = false;

            while (m_Counter < InputString.Length)
            {
                if (m_Counter + 2 < InputString.Length && InputString.Substring(m_Counter, 2).Equals("<!"))
                {
                    m_Counter = InputString.IndexOf(">", m_Counter + 2);
                    if (m_Counter == -1)
                        break;

                    m_Counter += 3;
                }
                else
                {
                    if (InputString.Substring(m_Counter, 1).Equals("<"))
                    {
                        m_InTag = true;
                        m_ProcessedString.Append("<");
                        m_Counter++;
                    }
                    else
                    {
                        if (InputString.Substring(m_Counter, 1).Equals(">"))
                        {
                            m_InTag = false;
                            m_ProcessedString.Append(">");
                            m_Counter++;
                        }
                        else
                        {
                            if (InputString.Substring(m_Counter, 1).Equals("\"") && m_InTag)
                            {
                                int m_StartIndex = m_Counter;
                                m_Counter = InputString.IndexOf("\"", m_Counter + 1);
                                if (m_Counter == -1)
                                    break;

                                m_Counter++;

                                m_ProcessedString.Append(InputString.Substring(m_StartIndex, m_Counter - m_StartIndex));
                            }
                            else
                            {
                                if (InputString.Substring(m_Counter, 1).Equals("\'") && m_InTag)
                                {
                                    int m_StartIndex = m_Counter;
                                    m_Counter = InputString.IndexOf("\'", m_Counter + 1);
                                    if (m_Counter == -1)
                                        break;

                                    m_Counter++;

                                    m_ProcessedString.Append(InputString.Substring(m_StartIndex, m_Counter - m_StartIndex));
                                }
                                else
                                {
                                    m_ProcessedString.Append(InputString.Substring(m_Counter, 1));
                                    m_Counter++;
                                }
                            }
                        }
                    }
                }
            }

            return m_ProcessedString.ToString();
        }

        /// <summary>
        /// Encode styles and scripts with custom markups.
        /// </summary>
        /// <param name="InputString">The HTML to examine</param>
        /// <param name="TagName"></param>
        /// <returns>An object of type System.String.</returns>
        private string PreprocessScript(string InputString, string TagName)
        {
            StringBuilder m_ProcessedString = new StringBuilder();
            int m_Counter = 0;
            int m_TagLength = TagName.Length;

            while (m_Counter < InputString.Length)
            {
                bool m_SkipBody = false;

                if (m_Counter + m_TagLength + 1 < InputString.Length && InputString.Substring(m_Counter, m_TagLength + 1).ToLower().Equals("<" + TagName))
                {
                    // Look for the end of the tag (we pass the attributes through as normal)
                    do
                    {
                        if (m_Counter >= InputString.Length)
                            break;
                        else
                        {
                            if (InputString.Substring(m_Counter, 1).Equals(">"))
                            {
                                m_ProcessedString.Append(">");
                                m_Counter++;
                                break;
                            }
                            else
                            {
                                if (m_Counter + 1 < InputString.Length && InputString.Substring(m_Counter, 2).Equals("/>"))
                                {
                                    m_ProcessedString.Append("/>");
                                    m_Counter += 2;
                                    m_SkipBody = true;
                                    break;
                                }
                                else
                                {
                                    if (InputString.Substring(m_Counter, 1).Equals("\""))
                                    {
                                        m_ProcessedString.Append("\"");
                                        m_Counter++;
                                        while (m_Counter < InputString.Length && !InputString.Substring(m_Counter, 1).Equals("\""))
                                        {
                                            m_ProcessedString.Append(InputString.Substring(m_Counter, 1));
                                            m_Counter++;
                                        }
                                        if (m_Counter < InputString.Length)
                                        {
                                            m_Counter++;
                                            m_ProcessedString.Append("\"");
                                        }
                                    }
                                    else
                                    {
                                        if (InputString.Substring(m_Counter, 1).Equals("\'"))
                                        {
                                            m_ProcessedString.Append("\'");
                                            m_Counter++;
                                            while (m_Counter < InputString.Length && !InputString.Substring(m_Counter, 1).Equals("\'"))
                                            {
                                                m_ProcessedString.Append(InputString.Substring(m_Counter, 1));
                                                m_Counter++;
                                            }
                                            if (m_Counter < InputString.Length)
                                            {
                                                m_Counter++;
                                                m_ProcessedString.Append("\'");
                                            }
                                        }
                                        else
                                        {
                                            m_ProcessedString.Append(InputString.Substring(m_Counter, 1));
                                            m_Counter++;
                                        }
                                    }
                                }
                            }
                        }
                    } while (true);
                    if (m_Counter >= InputString.Length)
                        break;

                    // Read in script body
                    if (!m_SkipBody)
                    {
                        StringBuilder m_ScriptBody = new StringBuilder();
                        while (m_Counter + m_TagLength + 3 < InputString.Length && !InputString.Substring(m_Counter, m_TagLength + 3).ToLower().Equals("</" + TagName + ">"))
                        {
                            m_ScriptBody.Append(InputString.Substring(m_Counter, 1));
                            m_Counter++;
                        }

                        // Done - now encode the script
                        m_ProcessedString.Append(EncodeScript(m_ScriptBody.ToString()));
                        m_ProcessedString.Append("</" + TagName + ">");
                        if (m_Counter + m_TagLength + 3 < InputString.Length)
                            m_Counter += m_TagLength + 3;
                    }
                }
                else
                {
                    m_ProcessedString.Append(InputString.Substring(m_Counter, 1));
                    m_Counter++;
                }
            }

            return m_ProcessedString.ToString();
        }

        /// <summary>
        /// Encodes the specified script text with custom tags.
        /// </summary>
        /// <param name="ScriptText">The Script Text to encode.</param>
        /// <returns></returns>
        private static string EncodeScript(string ScriptText)
        {
            string m_ProcessedScript = string.Empty;

            m_ProcessedScript = ScriptText.Replace("<", "[TAG-SCRIPT-LT]");
            m_ProcessedScript = m_ProcessedScript.Replace(">", "[TAG-SCRIPT-GT]");
            m_ProcessedScript = m_ProcessedScript.Replace("\r", "[TAG-SCRIPT-CR]");
            m_ProcessedScript = m_ProcessedScript.Replace("\n", "[TAG-SCRIPT-LF]");

            return m_ProcessedScript;
        }

        /// <summary>
        /// Decodes the specified script text.
        /// </summary>
        /// <param name="ScriptText">The Script Text to decode.</param>
        /// <returns></returns>
        private static string DecodeScript(string ScriptText)
        {
            string m_ProcessedScript = string.Empty;

            m_ProcessedScript = ScriptText.Replace("[TAG-SCRIPT-LT]", "<");
            m_ProcessedScript = m_ProcessedScript.Replace("[TAG-SCRIPT-GT]", ">");
            m_ProcessedScript = m_ProcessedScript.Replace("[TAG-SCRIPT-CR]", "\r");
            m_ProcessedScript = m_ProcessedScript.Replace("[TAG-SCRIPT-LF]", "\n");

            return m_ProcessedScript;
        }

        /// <summary>
        /// Gets or sets the flag to indicate if empty text nodes will be removed from the 
        /// final DOM Tree.
        /// To create a pure DOM Tree, set this to false.
        /// </summary>
        public bool IsRemoveEmptyElementText
        {
            get { return g_IsRemoveEmptyElementText; }

            set { g_IsRemoveEmptyElementText = value; }
        }

        /// <summary>
        /// Move all nodes from specified index to new parent.
        /// </summary>
        /// <param name="TargetNodes">The nodes to move.</param>
        /// <param name="Index">The index of the first node in the specified collection to move.</param>
        /// <param name="NewParent">The new parent node.</param>
        private void MoveNodesDown(ref HTMLBaseNodeCollection TargetNodes, int Index, HTMLElement NewParent)
        {
            for (int i = Index; i < TargetNodes.Count; i++)
            {
                ((HTMLElement)NewParent).ChildNodes.Add(TargetNodes[i]);
                TargetNodes[i].SetParent(NewParent);
            }

            int c = TargetNodes.Count;
            for (int i = Index; i < c; i++)
                TargetNodes.RemoveAt(Index);

            NewParent.IsExplicitlyTerminated = true;
        }

        /// <summary>
        /// Find the corresponding opening tag for the named one. This is identified as
        /// the most recently read node with the same name, but with no child nodes.
        /// </summary>
        /// <param name="TargetNodes">The collection of nodes.</param>
        /// <param name="TagName">The name of the tag.</param>
        /// <returns>The index of the opening tag, or -1 if it was not found</returns>
        private int FindTagOpenNodeIndex(HTMLBaseNodeCollection TargetNodes, string TagName)
        {
            for (int index = TargetNodes.Count - 1; index >= 0; index--)
            {
                if (TargetNodes[index] is HTMLElement)
                {
                    if (((HTMLElement)TargetNodes[index]).TagName.ToLower().Equals(TagName.ToLower()) &&
                        ((HTMLElement)TargetNodes[index]).ChildNodes.Count == 0 && ((HTMLElement)TargetNodes[index]).IsTerminated == false)
                        return index;
                }
            }

            return -1;
        }

        /// <summary>
        /// This will tokenise the HTML input string.
        /// </summary>
        /// <param name="HTMLInputString">The HTML Input string.</param>
        /// <returns></returns>
        private StringCollection GetTokens(string HTMLInputString)
        {
            StringCollection tokens = new StringCollection();

            int i = 0;
            HTMLParseStatus status = HTMLParseStatus.TextRead;

            while (i < HTMLInputString.Length)
            {
                if (status == HTMLParseStatus.TextRead)
                {
                    if (i + 2 < HTMLInputString.Length && HTMLInputString.Substring(i, 2).Equals("</"))
                    {
                        i += 2;
                        tokens.Add("</");
                        status = HTMLParseStatus.EndTagRead;
                    }
                    else if (HTMLInputString.Substring(i, 1).Equals("<"))
                    {
                        i++;
                        tokens.Add("<");
                        status = HTMLParseStatus.StartTagRead;
                    }
                    else
                    {
                        int next_index = HTMLInputString.IndexOf("<", i);
                        if (next_index == -1)
                        {
                            tokens.Add(HTMLInputString.Substring(i));
                            break;
                        }
                        else
                        {
                            tokens.Add(HTMLInputString.Substring(i, next_index - i));
                            i = next_index;
                        }
                    }
                }
                else if (status == HTMLParseStatus.StartTagRead)
                {
                    // Skip leading whitespace in tag
                    while (i < HTMLInputString.Length && HTMLInputString.Substring(i, 1).IndexOfAny(G_WHITESPACECHAR) != -1)
                    {
                        i++;
                    }
                    // Read tag name
                    int tag_name_start = i;
                    while (i < HTMLInputString.Length && HTMLInputString.Substring(i, 1).IndexOfAny(" \r\n\t/>".ToCharArray()) == -1)
                    {
                        i++;
                    }
                    tokens.Add(HTMLInputString.Substring(tag_name_start, i - tag_name_start));
                    // Skip trailing whitespace in tag
                    while (i < HTMLInputString.Length && HTMLInputString.Substring(i, 1).IndexOfAny(G_WHITESPACECHAR) != -1)
                    {
                        i++;
                    }
                    if (i + 1 < HTMLInputString.Length && HTMLInputString.Substring(i, 1).Equals("/>"))
                    {
                        tokens.Add("/>");
                        status = HTMLParseStatus.TextRead;
                        i += 2;
                    }
                    else if (i < HTMLInputString.Length && HTMLInputString.Substring(i, 1).Equals(">"))
                    {
                        tokens.Add(">");
                        status = HTMLParseStatus.TextRead;
                        i++;
                    }
                    else
                    {
                        status = HTMLParseStatus.AttributeNameRead;
                    }
                }
                else if (status == HTMLParseStatus.EndTagRead)
                {
                    // Skip leading whitespace in tag
                    while (i < HTMLInputString.Length && HTMLInputString.Substring(i, 1).IndexOfAny(G_WHITESPACECHAR) != -1)
                    {
                        i++;
                    }
                    // Read tag name
                    int tag_name_start = i;
                    while (i < HTMLInputString.Length && HTMLInputString.Substring(i, 1).IndexOfAny(" \r\n\t>".ToCharArray()) == -1)
                    {
                        i++;
                    }
                    tokens.Add(HTMLInputString.Substring(tag_name_start, i - tag_name_start));
                    // Skip trailing whitespace in tag
                    while (i < HTMLInputString.Length && HTMLInputString.Substring(i, 1).IndexOfAny(G_WHITESPACECHAR) != -1)
                    {
                        i++;
                    }
                    if (i < HTMLInputString.Length && HTMLInputString.Substring(i, 1).Equals(">"))
                    {
                        tokens.Add(">");
                        status = HTMLParseStatus.TextRead;
                        i++;
                    }
                }
                else if (status == HTMLParseStatus.AttributeNameRead)
                {
                    // Read attribute name
                    while (i < HTMLInputString.Length && HTMLInputString.Substring(i, 1).IndexOfAny(G_WHITESPACECHAR) != -1)
                    {
                        i++;
                    }
                    int attribute_name_start = i;
                    while (i < HTMLInputString.Length && HTMLInputString.Substring(i, 1).IndexOfAny(" \r\n\t/>=".ToCharArray()) == -1)
                    {
                        i++;
                    }
                    tokens.Add(HTMLInputString.Substring(attribute_name_start, i - attribute_name_start));
                    while (i < HTMLInputString.Length && HTMLInputString.Substring(i, 1).IndexOfAny(G_WHITESPACECHAR) != -1)
                    {
                        i++;
                    }
                    if (i + 1 < HTMLInputString.Length && HTMLInputString.Substring(i, 2).Equals("/>"))
                    {
                        tokens.Add("/>");
                        status = HTMLParseStatus.TextRead;
                        i += 2;
                    }
                    else if (i < HTMLInputString.Length && HTMLInputString.Substring(i, 1).Equals(">"))
                    {
                        tokens.Add(">");
                        status = HTMLParseStatus.TextRead;
                        i++;
                    }
                    else if (i < HTMLInputString.Length && HTMLInputString.Substring(i, 1).Equals("="))
                    {
                        tokens.Add("=");
                        i++;
                        status = HTMLParseStatus.AttributeValueRead;
                    }
                    else if (i < HTMLInputString.Length && HTMLInputString.Substring(i, 1).Equals("/"))
                    {
                        i++;
                    }
                }
                else if (status == HTMLParseStatus.AttributeValueRead)
                {
                    // Read the attribute value
                    while (i < HTMLInputString.Length && HTMLInputString.Substring(i, 1).IndexOfAny(G_WHITESPACECHAR) != -1)
                    {
                        i++;
                    }
                    if (i < HTMLInputString.Length && HTMLInputString.Substring(i, 1).Equals("\""))
                    {
                        int value_start = i;
                        i++;
                        while (i < HTMLInputString.Length && !HTMLInputString.Substring(i, 1).Equals("\""))
                        {
                            i++;
                        }
                        if (i < HTMLInputString.Length && HTMLInputString.Substring(i, 1).Equals("\""))
                        {
                            i++;
                        }
                        tokens.Add(HTMLInputString.Substring(value_start + 1, i - value_start - 2));
                        status = HTMLParseStatus.AttributeNameRead;
                    }
                    else if (i < HTMLInputString.Length && HTMLInputString.Substring(i, 1).Equals("\'"))
                    {
                        int value_start = i;
                        i++;
                        while (i < HTMLInputString.Length && !HTMLInputString.Substring(i, 1).Equals("\'"))
                        {
                            i++;
                        }
                        if (i < HTMLInputString.Length && HTMLInputString.Substring(i, 1).Equals("\'"))
                        {
                            i++;
                        }
                        tokens.Add(HTMLInputString.Substring(value_start + 1, i - value_start - 2));
                        status = HTMLParseStatus.AttributeNameRead;
                    }
                    else
                    {
                        int value_start = i;
                        while (i < HTMLInputString.Length && HTMLInputString.Substring(i, 1).IndexOfAny(" \r\n\t/>".ToCharArray()) == -1)
                        {
                            i++;
                        }
                        tokens.Add(HTMLInputString.Substring(value_start, i - value_start));
                        while (i < HTMLInputString.Length && HTMLInputString.Substring(i, 1).IndexOfAny(G_WHITESPACECHAR) != -1)
                        {
                            i++;
                        }
                        status = HTMLParseStatus.AttributeNameRead;
                    }
                    if (i + 1 < HTMLInputString.Length && HTMLInputString.Substring(i, 2).Equals("/>"))
                    {
                        tokens.Add("/>");
                        status = HTMLParseStatus.TextRead;
                        i += 2;
                    }
                    else if (i < HTMLInputString.Length && HTMLInputString.Substring(i, 1).Equals(">"))
                    {
                        tokens.Add(">");
                        i++;
                        status = HTMLParseStatus.TextRead;
                    }
                }
            }

            return tokens;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\FiddlerHandler\FiddlerHandler\Program.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using Fiddler;
using System.Data;
using System.Diagnostics;
using System.Threading;
using Fiddler.WebTesting;
using System.IO;
using System.Text.RegularExpressions;
using System.IO.Compression;
using java.util.zip;
using java.util;
using java.io;
using System.Web;
using System.Collections.Specialized;

namespace Test.Common.Library.FiddlerHandler
{

    public class FiddlerInstance
    {
        public string Dumpfile;
        public string file_path;
        public string dump_path;
        public StreamReader HTMLStream;

        /// <summary>
        /// Opens a new Fiddler instance
        /// </summary>
        public FiddlerInstance()
        {
           string _fiddlerpath = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles);

           System.Diagnostics.Process _process;
           System.Diagnostics.ProcessStartInfo _processStartInfo;

           _process = new System.Diagnostics.Process();
           _processStartInfo = new System.Diagnostics.ProcessStartInfo(_fiddlerpath + "\\Fiddler2\\" + "Fiddler.exe");

           _processStartInfo.CreateNoWindow = true;
           _processStartInfo.UseShellExecute = false;
          
           System.Diagnostics.Process process = System.Diagnostics.Process.Start(_processStartInfo);
           //Stop();
        }

        /// <summary>
        /// Opens a Fidder instance and starts a session capture
        /// </summary>
        public void Start()
        {
            System.Diagnostics.Process process;
            process = new System.Diagnostics.Process();
            process.EnableRaisingEvents = false;
            string _execaction_path = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles);
            process.StartInfo.FileName = _execaction_path + "\\Fiddler2\\ExecAction.exe";
            process.StartInfo.Arguments = "start";
            process.Start();
            process.Close();
                        
            string script_path = Fiddler.CONFIG.GetPath("Scripts");
            do
            {
                System.Threading.Thread.Sleep(1000);
            } while (!System.IO.File.Exists(script_path + "\\CustomRules.js"));

            //if (System.IO.File.Exists(script_path + "\\CustomRules.js"))
            //{
                string rules = System.IO.File.ReadAllText(script_path + "\\CustomRules.js");
                System.IO.File.WriteAllText(script_path + "\\CustomRules.js", rules.Replace("dump.saz", "dump.zip"));

            //}
            
        }

        /// <summary>
        /// Closes the Fidder instance
        /// </summary>
        public void Exit()
        {
           System.Diagnostics.Process _process = new System.Diagnostics.Process();
           string _execaction_path = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles);
           _process.StartInfo.FileName = _execaction_path + "\\Fiddler2\\ExecAction.exe";
           _process.StartInfo.Arguments = "quit";
           _process.Start();
           _process.Close();
           HTMLStream = null;
        }

        /// <summary>
        /// Stops a session capture
        /// </summary>
        public void Stop()
        {
            //Console.WriteLine("Stopping ..");

            try
            {
                System.Diagnostics.Process _process;
                //System.Diagnostics.ProcessStartInfo _processStartInfo;
             
                _process = new System.Diagnostics.Process();
                _process.EnableRaisingEvents = false;
                string _execaction_path = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles);
                _process.StartInfo.FileName = _execaction_path + "\\Fiddler2\\ExecAction.exe";
                _process.StartInfo.Arguments = "stop";
                _process.Start();
                _process.Close();
            }
            catch (Exception e)
            {
                Console.WriteLine("Fiddler Session Not Available");
                Console.WriteLine("Exception :" + e.Message + e.StackTrace);
            }
            
        }

        /// <summary>
        /// Dumps the session and return the dump path
        /// </summary>
        public string Dump()
        {
            System.Diagnostics.Process _process= new System.Diagnostics.Process();;
            string _execaction_path = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles);
            string capture_path = Fiddler.CONFIG.GetPath("Captures");
             
            try
            {
                _process.EnableRaisingEvents = false;
                _process.StartInfo.FileName = _execaction_path + "\\Fiddler2\\ExecAction.exe";
                _process.StartInfo.Arguments = "dump";
                _process.StartInfo.CreateNoWindow = true;
                _process.Start();
                _process.Dispose();
                _process.Close();
                    
                              
                //Sleep required to dump the session
                System.Threading.Thread.Sleep(20000);

                //Require reference java.util.zip ,java.util and java.io from vjslib
                string ticks=DateTime.Now.Ticks.ToString();
                dump_path = capture_path + ticks+"\\dump" ;
                string dump_zip = capture_path + "dump.zip";
                string new_dump_zip = capture_path + "dump-" + ticks + ".zip";
                System.IO.File.Move(dump_zip, new_dump_zip);                               
                System.IO.Directory.CreateDirectory(dump_path);
                
                if (System.IO.Directory.Exists(dump_path))
                {
                    //Extract(capture_path + "dump.zip", dump_path);
                    Extract(new_dump_zip, dump_path);
                    file_path = dump_path + "\\_index.htm";
                    while (!System.IO.File.Exists(file_path))
                    {
                        System.Threading.Thread.Sleep(1000);
                    }
                    
                    //Console.Out.WriteLine("filepath:"+file_path);
                    return dump_path;
                    
                }
                else
                {
                    //Console.Out.WriteLine("filepath:"+file_path);
                    return string.Empty;
                }      
                
            }
            catch (Exception e)
            {
                Console.WriteLine("Exception :" + e.Message + e.StackTrace);
                return string.Empty;
            }
           
            
        }

        private void Extract(string zipFileName, string destinationPath)
        {
            try
            {
                ZipFile zipfile = new ZipFile(zipFileName);
                List<ZipEntry> zipFiles = GetZipFiles(zipfile);
                InputStream s = null;
                foreach (ZipEntry zipFile in zipFiles)
                {
                    if (!zipFile.isDirectory())
                    {

                        try
                        {

                            s = zipfile.getInputStream(zipFile);
                            try
                            {
                                Directory.CreateDirectory(destinationPath + "\\" +
                                    Path.GetDirectoryName(zipFile.getName()));
                                FileOutputStream dest = new
                                    FileOutputStream(Path.Combine(destinationPath + "\\" +
                                    Path.GetDirectoryName(zipFile.getName()),
                                    Path.GetFileName(zipFile.getName())));
                                try
                                {
                                    int len = 0;
                                    sbyte[] buffer = new sbyte[7168];
                                    while ((len = s.read(buffer)) >= 0)
                                    {
                                        dest.write(buffer, 0, len);
                                    }
                                }
                                finally
                                {
                                    dest.close();
                                }
                            }
                            finally
                            {
                                s.close();
                            }
                        }
                        catch (Exception e)
                        {
                            Console.WriteLine("Exception :" + e.Message + e.StackTrace);
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Console.WriteLine("Exception :" + e.Message + e.StackTrace);
            }
        }
        private List<ZipEntry> GetZipFiles(ZipFile zipfil)
        {
            List<ZipEntry> lstZip = new List<ZipEntry>();
            Enumeration zipEnum = zipfil.entries();
            while (zipEnum.hasMoreElements())
            {
                ZipEntry zip = (ZipEntry)zipEnum.nextElement();
                lstZip.Add(zip);
            }
            return lstZip;
        }

        /// <summary>
        /// Returns all the urls and their status
        /// </summary>
        /// <param name="hosturl"></param>
        /// <returns></returns>
        public System.Collections.ArrayList GetAllUrls()
        {

            HTMLDriver hd = new HTMLDriver();
            DataSet ds = hd.TraverseHTML(dump_path);

            return hd.GetAllUrls(ds);
        }

        /// <summary>
        /// Returns all the urls and their status
        /// </summary>
        /// <param name="hosturl"></param>
        /// <returns></returns>
        public System.Collections.ArrayList FindAllURLs(string hosturl)
        {

            HTMLDriver hd = new HTMLDriver();
            DataSet ds = hd.TraverseHTML(dump_path);

            return hd.SearchAllURLs(ds, hosturl);

        }

              
        /// <summary>
        /// Opens an IE window with the URL
        /// </summary>
        public void OpenURL(string url)
        {

            System.Diagnostics.Process procIEInstance = new System.Diagnostics.Process();
            procIEInstance.StartInfo.FileName = "iexplore";
            procIEInstance.StartInfo.Arguments = url;
            procIEInstance.StartInfo.WindowStyle = System.Diagnostics.ProcessWindowStyle.Maximized;
            procIEInstance.Start();
            procIEInstance.WaitForInputIdle();
        }

        /// <summary>
        /// Returns the Row if found and null if not found
        /// </summary>
        public DataRow FindURL(string hosturl)
        {

           HTMLDriver hd = new HTMLDriver();
           DataSet ds = hd.TraverseHTML(dump_path);

           return hd.SearchURL(ds, hosturl);
          
        }

        /// <summary>
        /// Returns the complete Row if found and null if not found in the row
        /// </summary>
        public DataRow FindURL(string hosturl, int rowno)
        {

           HTMLDriver hd = new HTMLDriver();
           DataSet ds = hd.TraverseHTML(dump_path);

           return hd.SearchURL(ds, hosturl,rowno);

        }

        /// <summary>
        /// Returns the RowNo if found and -1 if not found
        /// </summary>
        public int FindRow(string hosturl)
        {
           //Console.Out.WriteLine("hosturl:" + hosturl);
           //Console.Out.WriteLine("filepath:" + file_path);
           HTMLDriver hd = new HTMLDriver();
           DataSet ds = hd.TraverseHTML(dump_path);
           return hd.SearchRow(ds, hosturl);
           

        }

        /// <summary>
        /// Returns the next matching RowNo if found and -1 if not found
        /// </summary>
        public int FindNextRow(string hosturl, int rowno)
        {

           HTMLDriver hd = new HTMLDriver();
           DataSet ds = hd.TraverseHTML(dump_path);

           return hd.SearchRow(ds, hosturl, rowno);

        }

        /// <summary>
        /// Returns the Request XML of the row
        /// </summary>
        public Stream GetRequestXML(int rowno)
        {
           HTMLDriver hd = new HTMLDriver();
           DataSet ds = hd.TraverseHTML(dump_path);

           return hd.GetReqXml(ds, rowno, dump_path);
        }

        /// <summary>
        /// Returns the Response of the row
        /// </summary>
        public Stream GetResponse(int rowno, string dump_path)
        {

           HTMLDriver hd = new HTMLDriver();
           DataSet ds = hd.TraverseHTML(dump_path);

           return hd.GetResponse(ds, rowno,dump_path);
        }

        /// <summary>
        /// Returns the Request of the row
        /// </summary>
        public Stream GetRequestHeader(int rowno, string dump_path)
        {

          HTMLDriver hd = new HTMLDriver();
          DataSet ds = hd.TraverseHTML(dump_path);
          return hd.GetRequest(ds, rowno,dump_path);
        }

        /// <summary>
        /// Returns 1 if found 
        /// </summary>
        public int FindHdr(int rowno,string pattern)
        {
           HTMLDriver hd = new HTMLDriver();
           DataSet ds = hd.TraverseHTML(dump_path);

           return hd.SearchHdr(ds, rowno, pattern, dump_path);

        }

        /// <summary>
        /// Returns the List of Cookies
        /// </summary>
       public string[] GetCookieList(int rowno, string dump_path)
        {
            HTMLDriver hd = new HTMLDriver();
            DataSet ds = hd.TraverseHTML(dump_path);
            StreamReader sr =new StreamReader(hd.GetRequest(ds, rowno, dump_path));
            string cookie;
            string[] list;
           
            char[] seperators = ";:".ToCharArray();
            
            do
            {
                cookie = sr.ReadLine();
                if (cookie.Contains("Cookie:"))
                {
                    list = cookie.Split(';');
                   // list = cookie.Split(seperators);
                    sr.Close();
                    return list;
                    
                }

            } while (!cookie.Equals("null"));
            sr.Close();
            return null;
            
        }

        /// <summary>
        /// Returns the Status Code
        /// </summary>
        public int CheckError(string Url)
        {
            HTMLDriver hd = new HTMLDriver();
            DataSet ds = hd.TraverseHTML(dump_path);
            int rowno=hd.SearchRow(ds, Url);
            Stream stream=hd.GetResponse(ds,rowno,dump_path);
            StreamReader sr = new StreamReader(stream);
            string response = sr.ReadToEnd();
            //Console.Out.WriteLine("response:"+response);
            if (response.Contains("ServerError500"))
            {
                //Console.Out.WriteLine(Url + " redirected to ServerError500.htm.");
                return 500;
            }
            else if (response.Contains("handler404"))
            {
                //Console.Out.WriteLine(Url + " redirected to Error.htm.");
                return 404;
            }
            else
            {
                //Console.Out.WriteLine(Url + " not redirected to any Error page.");
                return 200;
            }
        }

        /// <summary>
        /// Returns NameValueCollection
        /// </summary>
        public NameValueCollection GetQParams(string Url)
        {
            NameValueCollection collection = HttpUtility.ParseQueryString(Url);
            if (collection.Count == 0)
                return null;
            else
                return collection;
            
            
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\FakeNotification\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("FakeNotification")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("aae1dfc5-d65d-49af-ab20-920dc0456e9a")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\DOMInspector\DOMInspector\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("WGXDOMInspector")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
//[assembly: AssemblyCompany("")]
//[assembly: AssemblyProduct("")]
//[assembly: AssemblyCopyright("")]
//[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("35bf5a74-5373-4f74-a724-d28ec4c181ff")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
//[assembly: AssemblyVersion("1.0.0.0")]
//[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\FiddlerHandler\FiddlerHandler\HTMLDriver.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using Fiddler;
using System.Data;
using System.Diagnostics;
using System.Threading;
using System.IO;
using System.Text.RegularExpressions;
using System.Windows.Forms;

namespace Test.Common.Library.FiddlerHandler
{

    class HTMLDriver
    {
        DataSet _dataset;
        Stream _filestream;

        public HTMLDriver()
        {
            _dataset = new DataSet("DataSet");
            _filestream = null;
        }

        ~HTMLDriver()
        {
            _dataset = null;
            _filestream = null;
        }

        /// <summary>
        ///  Returns all the urls and their http status
        /// </summary>
        /// <param name="_dataset"></param>
        /// <returns></returns>
        public System.Collections.ArrayList GetAllUrls(DataSet _dataset)
        {
            int i;
            int rowcount = _dataset.Tables["DataTable"].Rows.Count;
            System.Collections.ArrayList urls = new System.Collections.ArrayList();

            for (i = 1; i < rowcount; i++)
            {
                string col = ((_dataset.Tables["DataTable"].Rows[i].ItemArray.GetValue(3).ToString().Trim()) + "://" + (_dataset.Tables["DataTable"].Rows[i].ItemArray.GetValue(4).ToString().Trim()) +
                       (_dataset.Tables["DataTable"].Rows[i].ItemArray.GetValue(5).ToString().Trim()));
                string status = _dataset.Tables["DataTable"].Rows[i].ItemArray.GetValue(2).ToString().Trim();
                urls.Add(col + "httpStatus:" + status);

            }
            return urls;
        }

        /// <summary>
        /// Returns an ArrayList containing all the matching rows
        /// </summary>
        public System.Collections.ArrayList SearchAllURLs(DataSet _dataset, string url)
        {
            int i;
            int rowcount = _dataset.Tables["DataTable"].Rows.Count;
            System.Collections.ArrayList Urls = new System.Collections.ArrayList();
            //Console.WriteLine("Searching..");
            for (i = 1; i < rowcount; i++)
            {
                if (((_dataset.Tables["DataTable"].Rows[i].ItemArray.GetValue(4).ToString()) + "://" + (_dataset.Tables["DataTable"].Rows[i].ItemArray.GetValue(4).ToString()) +
                       (_dataset.Tables["DataTable"].Rows[i].ItemArray.GetValue(5).ToString())).Contains(url))
                {
                    Urls.Add(_dataset.Tables["DataTable"].Rows[i].ItemArray.GetValue(4).ToString());
                }
            }

            return Urls;
        }

        /// <summary>
        /// Returns rowno if found and -1 if not found
        /// </summary>
        public int SearchRow(DataSet _dataset, string url)
        {
            int i;
            int rowcount = _dataset.Tables["DataTable"].Rows.Count;
            Boolean found = false;
            string col = null;
            string urlToCheck = url.ToLower().Trim();
            //Console.WriteLine("Searching..");
            for (i = 1; i < rowcount; i++)
            {
                col = ((_dataset.Tables["DataTable"].Rows[i].ItemArray.GetValue(3).ToString().Trim()) + "://" + (_dataset.Tables["DataTable"].Rows[i].ItemArray.GetValue(4).ToString().Trim()) +
                       (_dataset.Tables["DataTable"].Rows[i].ItemArray.GetValue(5).ToString().Trim()));
                //Console.Out.WriteLine(col);
                //Console.Out.WriteLine(url);
                if (col.ToLower().Contains(urlToCheck))
                {
                    found = true;
                    break;
                }

            }

            if (found == false)
            {
                //Console.WriteLine(url + " Url not found");
                return -1;
            }
            else
            {
                //Console.WriteLine("Found url :" + url + " in row " + (i));
                //DisplayRow(_dataset,i);
                return i;
            }
        }

        /// <summary>
        /// Returns the next matching rowno if found and -1 if not found
        /// </summary>
        public int SearchRow(DataSet _dataset, string url, int rowno)
        {
            int i;
            int rowcount = _dataset.Tables["DataTable"].Rows.Count;
            Boolean found = false;
            string col = null;
            string urlToCheck = url.ToLower().Trim();
            //Console.WriteLine("Searching for next row..");
            for (i = rowno + 1; i < rowcount; i++)
            {
                col = ((_dataset.Tables["DataTable"].Rows[i].ItemArray.GetValue(3).ToString()) + "://" + (_dataset.Tables["DataTable"].Rows[i].ItemArray.GetValue(4).ToString()) +
                     (_dataset.Tables["DataTable"].Rows[i].ItemArray.GetValue(5).ToString()));
                //Console.Out.WriteLine(col);
                if (col.ToLower().Contains(urlToCheck))
                {
                    found = true;
                    break;
                }

            }

            if (found == false)
            {
                //Console.WriteLine(url + " Url not found");
                return -1;
            }
            else
            {
                //Console.WriteLine("Found url :" + url + " in row " + (i));
                //DisplayRow(_dataset,i);
                return i;
            }
        }

        /// <summary>
        /// Returns the Row if found and null if not found
        /// </summary>
        public DataRow SearchURL(DataSet _dataset, string url)
        {
            int i;
            int rowcount = _dataset.Tables["DataTable"].Rows.Count;
            Boolean found = false;
            string col = null;
            string urlToCheck = url.ToLower().Trim();
            //Console.WriteLine("Searching..");
            for (i = 1; i < rowcount; i++)
            {
                col = ((_dataset.Tables["DataTable"].Rows[i].ItemArray.GetValue(3).ToString()) + "://" + (_dataset.Tables["DataTable"].Rows[i].ItemArray.GetValue(4).ToString()) +
                      (_dataset.Tables["DataTable"].Rows[i].ItemArray.GetValue(5).ToString()));
                //Console.Out.WriteLine(col);
                if (col.ToLower().Contains(urlToCheck))
                {
                    found = true;
                    break;
                }

            }

            if (found == false)
            {
                //Console.WriteLine(url + " Url not found");
                return null;
            }
            else
            {
                //Console.WriteLine("Found url :" + url + " in row " + (i));
                //DisplayRow(_dataset,i);
                return _dataset.Tables["DataTable"].Rows[i];
            }
        }

        /// <summary>
        /// Returns the complete Row of the URL in that Row
        /// </summary>
        public DataRow SearchURL(DataSet _dataset,string url,int rowno)
        {
            int i;
            int rowcount = _dataset.Tables["DataTable"].Rows.Count;
            Boolean found = false;
            //Console.WriteLine("Searching for next row..");
            for (i = rowno+1; i < rowcount; i++)
            {
                if (((_dataset.Tables["DataTable"].Rows[i].ItemArray.GetValue(3).ToString()) + "://" + (_dataset.Tables["DataTable"].Rows[i].ItemArray.GetValue(4).ToString()) +
                       (_dataset.Tables["DataTable"].Rows[i].ItemArray.GetValue(5).ToString())).Contains(url))
                {
                    found = true;
                    break;
                }

            }

            if (found == false)
            {
                //Console.WriteLine(url + " Url not found");
                return null;
            }
            else
            {
                //Console.WriteLine("Found url :" + url + " in row " + (i));
                //DisplayRow(_dataset,i);
                return _dataset.Tables["DataTable"].Rows[i];
            }
        }

        /// <summary>
        /// Returns a DataSet containing all the matching rows
        /// </summary>
        public DataSet SearchAllURL(DataSet _dataset, string url)
        {
            int i;
            int rowcount = _dataset.Tables["DataTable"].Rows.Count;
            DataSet dsSelectedRows = new DataSet();
            dsSelectedRows = _dataset.Clone();
            //Console.WriteLine("Searching..");
            for (i = 1; i < rowcount; i++)
            {
                if (((_dataset.Tables["DataTable"].Rows[i].ItemArray.GetValue(4).ToString()) + "://" + (_dataset.Tables["DataTable"].Rows[i].ItemArray.GetValue(4).ToString()) +
                       (_dataset.Tables["DataTable"].Rows[i].ItemArray.GetValue(5).ToString())).Contains(url))
                {
                    dsSelectedRows.Tables["DataTable"].Rows.Add(_dataset.Tables["DataTable"].Rows[i]);
                }
            }

            return dsSelectedRows;
        }

        /// <summary>
        /// Returns the Request Stream of the Row
        /// </summary>
        public Stream GetRequest(DataSet _dataset, int rowno, string dump_path)
        {
            
            if (rowno > 0 && rowno <= _dataset.Tables["DataTable"].Rows.Count)
            {

                string file_path = dump_path + "\\raw\\";

                int fileno = Convert.ToInt32(_dataset.Tables["DataTable"].Rows[rowno].ItemArray.GetValue(1));

                string filename;

                if (fileno < 10)
                {
                    filename = "000" + fileno.ToString();
                }
                else if (fileno < 100)
                {
                    filename = "00" + fileno.ToString();
                }
                else if (fileno < 1000)
                {
                    filename = "0" + fileno.ToString();
                }
                else
                {
                    filename = fileno.ToString();
                }

                try
                {
                    _filestream = new FileStream(file_path + filename + "_c.txt", FileMode.Open);
                    
                }
                catch (Exception e)
                {
                    Console.WriteLine("Exception:" + e.Message);
                }
            }
            else
            {
                Console.WriteLine(rowno + " Row does not exist in the DataTable");
            }

            

            return _filestream;
        }

        /// <summary>
        /// Returns the Response Stream of the Row
        /// </summary>
        public Stream GetResponse(DataSet _dataset, int rowno, string dump_path)
        {
            if (rowno > 0 && rowno <= _dataset.Tables["DataTable"].Rows.Count)
            {

                string file_path = dump_path + "\\raw\\";

                int fileno = Convert.ToInt32(_dataset.Tables["DataTable"].Rows[rowno].ItemArray.GetValue(1));

                string filename;

                if (fileno < 10)
                {
                    filename = "000" + fileno.ToString();
                }
                else if (fileno < 100)
                {
                    filename = "00" + fileno.ToString();
                }
                else if (fileno < 1000)
                {
                    filename = "0" + fileno.ToString();
                }
                else
                {
                    filename = fileno.ToString();
                }

                try
                {
                    _filestream = new FileStream(file_path + filename + "_s.txt", FileMode.Open);
                }
                catch (Exception e)
                {
                    Console.WriteLine("Exception:" + e.Message);
                }
            }
            else
            {
                Console.WriteLine(rowno + " Row does not exist in the DataTable");
            }

            return _filestream;
        }

        /// <summary>
        /// Returns the Xml
        /// </summary>
        public Stream GetReqXml(DataSet _dataset, int rowno, string dump_path)
        {
            if (rowno > 0 && rowno <= _dataset.Tables["DataTable"].Rows.Count)
            {

                string file_path = dump_path + "\\raw\\";

                int fileno = Convert.ToInt32(_dataset.Tables["DataTable"].Rows[rowno].ItemArray.GetValue(1));

                string filename;

                if (fileno < 10)
                {
                    filename = "000" + fileno.ToString();
                }
                else if (fileno < 100)
                {
                    filename = "00" + fileno.ToString();
                }
                else if (fileno < 1000)
                {
                    filename = "0" + fileno.ToString();
                }
                else
                {
                    filename = fileno.ToString();
                }

                try
                {
                    _filestream = new FileStream(file_path + filename + "_m.txt", FileMode.Open);
                }
                catch (Exception e)
                {
                    Console.WriteLine("Exception:" + e.Message);
                }
            }
            else
            {
                Console.WriteLine(rowno + " Row does not exist in the DataTable");
            }

            return _filestream;
        }

        /// <summary>
        /// Returns 1 if pattern found in Header else -1
        /// </summary>
        public int SearchHdr(DataSet _dataset, int rowno, string pattern,string dump_path)
        {

            if (rowno > 0 && rowno <= _dataset.Tables["DataTable"].Rows.Count)
            {
                StreamReader sr = new StreamReader(GetRequest(_dataset, rowno, dump_path));

                string header = sr.ReadToEnd();

                if (header.Contains(pattern))
                {
                    //Console.WriteLine("Pattern Available");
                    return 1;
                }

                else
                {
                    //Console.WriteLine("Pattern Available");
                    return -1;
                }
            }
            else
            {   
                return -1;
            }

        }

        /// <summary>
        /// Builds the DataSet of the dump available
        /// </summary>
        /// 
        [STAThread]
        public DataSet TraverseHTML(string path)
        {
            try
            {
                path = path + "\\_index.htm";
                
                WebBrowser webControl = new WebBrowser();
                webControl.DocumentText = "HTMLDocument";
                //HTMLDocument hdoc = LoadHtml(path);
                webControl.Navigate(path);
                do
                {
                    Application.DoEvents();
                } while (webControl.ReadyState != WebBrowserReadyState.Complete);

                               
                string[] ColumnName ={ "href", "sno", "result", "protocol", "host", "url", "body", "caching", "content-type", "process", "comments", "custom" };
                _dataset.EnforceConstraints = false;
                //create data table
                DataTable table;
                table = new DataTable("DataTable");


                //create a cloumn
                DataColumn column1 = new DataColumn();
                column1.DataType = System.Type.GetType("System.String");
                column1.ColumnName = "href";
                column1.ReadOnly = true;
                column1.Unique = false;
                table.Columns.Add(column1);


                //create a cloumn
                DataColumn column2 = new DataColumn();
                column2.DataType = System.Type.GetType("System.String");
                column2.ColumnName = "sno";
                column2.ReadOnly = true;
                column2.Unique = false;
                table.Columns.Add(column2);

                //create a cloumn
                DataColumn column3 = new DataColumn();
                column3.DataType = System.Type.GetType("System.String");
                column3.ColumnName = "result";
                column3.ReadOnly = true;
                column3.Unique = false;
                table.Columns.Add(column3);

                //create a cloumn
                DataColumn column4 = new DataColumn();
                column4.DataType = System.Type.GetType("System.String");
                column4.ColumnName = "protocol";
                column4.ReadOnly = true;
                column4.Unique = false;
                table.Columns.Add(column4);

                //create a cloumn
                DataColumn column5 = new DataColumn();
                column5.DataType = System.Type.GetType("System.String");
                column5.ColumnName = "host";
                column5.ReadOnly = true;
                column5.Unique = false;
                table.Columns.Add(column5);

                //create a cloumn
                DataColumn column6 = new DataColumn();
                column6.DataType = System.Type.GetType("System.String");
                column6.ColumnName = "url";
                column6.ReadOnly = true;
                column6.Unique = false;
                table.Columns.Add(column6);

                //create a cloumn
                DataColumn column7 = new DataColumn();
                column7.DataType = System.Type.GetType("System.String");
                column7.ColumnName = "body";
                column7.ReadOnly = true;
                column7.Unique = false;
                table.Columns.Add(column7);

                //create a cloumn
                DataColumn column8 = new DataColumn();
                column8.DataType = System.Type.GetType("System.String");
                column8.ColumnName = "caching";
                column8.ReadOnly = true;
                column8.Unique = false;
                table.Columns.Add(column8);

                //create a cloumn
                DataColumn column9 = new DataColumn();
                column9.DataType = System.Type.GetType("System.String");
                column9.ColumnName = "content-type";
                column9.ReadOnly = true;
                column9.Unique = false;
                table.Columns.Add(column9);

                //create a cloumn
                DataColumn column10 = new DataColumn();
                column10.DataType = System.Type.GetType("System.String");
                column10.ColumnName = "process";
                column10.ReadOnly = true;
                column10.Unique = false;
                table.Columns.Add(column10);

                //create a cloumn
                DataColumn column11 = new DataColumn();
                column11.DataType = System.Type.GetType("System.String");
                column11.ColumnName = "comments";
                column11.ReadOnly = true;
                column11.Unique = false;
                table.Columns.Add(column11);

                //create a cloumn
                DataColumn column12 = new DataColumn();
                column12.DataType = System.Type.GetType("System.String");
                column12.ColumnName = "custom";
                column12.ReadOnly = true;
                column12.Unique = false;
                table.Columns.Add(column12);
                
                HtmlElementCollection tablecollection = webControl.Document.GetElementsByTagName("TABLE");

                // Loop through table elements in the document  
                foreach (HtmlElement tCol in tablecollection)
                {
                    // Loop through table rows 
                    int outerindex = 0;

                    foreach (HtmlElement tablerow in tCol.GetElementsByTagName("TR"))
                    {
                        DataRow row = table.NewRow();
                        string[] data = new string[tablerow.GetElementsByTagName("TD").Count];
                        //Console.WriteLine(data.Length);
                        int index = 0;

                        //Loop through the elements, and get the innertext, then add it to the string array 
                        foreach (HtmlElement cell in tablerow.GetElementsByTagName("TD"))
                        {
                            data[index] = cell.InnerText;
                            //Console.Write(data[index]+" ");
                            row[ColumnName[index]] = data[index];
                            index++;
                        }
                        //Console.WriteLine();
                        table.Rows.Add(row);
                        outerindex++;
                    }
                    _dataset.Tables.Add(table);
                }
             return _dataset;
            }
            
            catch (System.Runtime.InteropServices.COMException myE)
            {
                Console.Error.Write(myE.Data + "\n" + myE.Message + "\n");
                DataSet dataset = new DataSet("Null");
                return dataset;
                
            }

        }

        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HtmlAgilityPack\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\FiddlerHandler\FiddlerTest\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("FiddlerTest")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("c8c69bfe-256e-495a-b0bb-503a415a4524")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\FiddlerHandler\FiddlerHandler\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("FiddlerHandler")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("a0ce29ea-db73-47cf-ae16-f943644bbaa9")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\FakeNotification\FakeNotification.cs ===
﻿using System;
using AsyncMultiplayer.NotificationService;
using System.Xml.Serialization;
using System.IO;

namespace Test.Common.Library
{
    public class FakeNotification
    {
        private INotificationStorage _notificationStorage = null;
        private Notification _notification = null;
        private UserDataAzureStorage _userDataStorage = null;
        
        private const uint DEFAULT_GAME_VARIENT = 0; // Anything between 0 and 100, default is 0
        private const int DEFAULT_PLATFORM = 6;      // 6 is for web and mobile
        private const string DEFAULT_ENDPOINT = "http://table.core.windows.net";
        private const string DEFAULT_GAMERTAG = "MyXbox";
        private const string DEFAULT_DISPLAYNAME = "My Xbox";
        private const string DEFAULT_GAMEDISPLAYNAME = "MyXbox Game";
        private const string DEFAULT_PROXY = "http://itgproxy:80";

        private const string TEST_ACCOUNT = "livenservicetest";
        private const string TEST_TOKEN = "XAVr+wY/iBjbivZ8MKI+O+oL9D1TNgLpdEJ8RpZsBWcLz8UNvHJQVD/8U8yJ7/9HooSkIQSbOzCCF1Zw3ETKZQ==";

        private const string DEV_ACCOUNT = "livenservicedev";
        private const string DEV_TOKEN = "4rCmJ6S0RtOhPkBc4qxE0TFkOD43baIRhY5GuPMg6B0IErx7E3MHKFggRTUX2nEYOC4C1ECBPTLDC57nbMV5Bg==";

        public enum Environment
        {
            Dev, 
            Test,
        }

        public enum GameId
        {
            FlowerzRush = 1297287394,
            Backgammon = 1297287394,
            Beehive = 1297287400,
            Reversi = 1297287401,
            TicTacToe = 1297287408, 
            GooSplat = 1297287422,
            Heros = 1297287429, 
            Test = 7777,
        }

        /// <summary>
        /// Initialize notification storage
        /// </summary>
        public FakeNotification(Environment environment)
        {
            if (environment == Environment.Dev)
            {
                _notificationStorage = new NotificationAzureStorage(DEFAULT_ENDPOINT, DEV_ACCOUNT, DEV_TOKEN, DEFAULT_PROXY);
                _userDataStorage = new UserDataAzureStorage(DEFAULT_ENDPOINT, DEV_ACCOUNT, DEV_TOKEN, DEFAULT_PROXY);

            }
            else if (environment == Environment.Test)
            {
                _notificationStorage = new NotificationAzureStorage(DEFAULT_ENDPOINT, TEST_ACCOUNT, TEST_TOKEN, DEFAULT_PROXY);
                _userDataStorage = new UserDataAzureStorage(DEFAULT_ENDPOINT, TEST_ACCOUNT, TEST_TOKEN, DEFAULT_PROXY);
            }
        }

        /// <summary>
        /// Creates a single notification of the specified type for the given XUID, Platform, and GameID.
        /// </summary>
        /// <param name="type">Type of notification</param>
        /// <param name="xuid">Xbox Live identification number</param>
        public void Send(Notification.NotificationType type,string xuid, Notification.NotificationStatus status)
        {
            Send(type, xuid, status, GameId.Test);
        }

        /// <summary>
        /// Creates a single notification of the specified type for the given XUID, Platform, and GameID.
        /// </summary>
        /// <param name="type">Type of notification</param>
        /// <param name="xuid">Xbox Live identification number</param>
        public void Send(Notification.NotificationType type, string xuid, Notification.NotificationStatus status, GameId gameId, Guid sessionId)
        {
            //string guid = Guid.NewGuid().ToString();
            Create(type);
            _notification.ExpirationTime = DateTime.MaxValue;
            _notification.From = From;
            _notification.UserId = xuid;
            _notification.GameId = (uint) gameId;
            _notification.Variant = DEFAULT_GAME_VARIENT;
            _notification.SessionId = sessionId.ToString();
            _notification.SupportedPlatform = DEFAULT_PLATFORM;
            _notification.GameDisplayName = Enum.GetName(typeof(GameId), gameId);
            _notification.Status = status;
            _notificationStorage.SaveNotification(xuid, (uint)GameId.Test, sessionId.ToString(), _notification);
            _userDataStorage.UpdateUserDataTimeStamp(xuid);
        }

        /// <summary>
        /// Send notification with no desired sessionId
        /// </summary>
        /// <param name="type"></param>
        /// <param name="xuid"></param>
        /// <param name="status"></param>
        /// <param name="gameId"></param>
        public void Send(Notification.NotificationType type, string xuid, Notification.NotificationStatus status, GameId gameId)
        {
            Guid guid = Guid.NewGuid();
            Send(type, xuid, status, gameId, guid);
        }

        public void Send(Notification.NotificationType type, string xuid, int howManyNotifications, Notification.NotificationStatus status, GameId gameId)
        {
            Send(type, xuid, howManyNotifications, status, gameId, Guid.NewGuid());
        }

        /// <summary>
        /// Send a fixed number of notifications of the same type
        /// </summary>
        public void Send(Notification.NotificationType type, string xuid, int howManyNotifications, Notification.NotificationStatus status, GameId gameId, Guid sessionId)
        {
            for (int i = 0; i < howManyNotifications; i++)
            {
                Send(type, xuid, status, gameId, sessionId);
            }
        }

        /// <summary>
        /// Returns a list of notifications for a given user XUID
        /// </summary>
        public NotificationList Receive(string xuid, int count)
        {
            return _notificationStorage.QueryNotifications(new NotificationQueryParameter {UserId = xuid, Count = count});
        }

        /// <summary>
        /// Deletes all notifcations for a given user
        /// </summary>
        /// <param name="xuid"></param>
        public void Delete(string xuid)
        {
            _notificationStorage.DeleteNotification(xuid);
        }

        /// <summary>
        /// Displays all notificaitons to the console
        /// </summary>
        /// <param name="notificationList"></param>
        public void Display(NotificationList notificationList)
        {
            int count = notificationList.Count;
            foreach (Notification note in notificationList)
            {
                Console.WriteLine("Number: \t\t" + count);
                Console.WriteLine("UserId: \t\t" + note.UserId);
                Console.WriteLine("Platform: \t\t" + note.SupportedPlatform);
                Console.WriteLine("Status: \t\t" + note.Status);
                Console.WriteLine("Sent: \t\t" + note.SentTime);
                Console.WriteLine("Game: \t\t" + note.GameDisplayName);
                Console.WriteLine("Id: \t\t" + note.Id);
                Console.WriteLine("Id: \t\t" + note.SessionId);
                Console.WriteLine("GameId: \t\t" + note.GameId);
                Console.WriteLine("Type: \t\t" + note.TypeDisplayName);
                Console.WriteLine("Url: \t\t" + note.Url);
                Console.WriteLine();
                count--;
            }
        }

        /// <summary>
        /// Gets the current notification
        /// </summary>
        public Notification Notification
        {
            get
            {
                return _notification;
            }
        }

        /// <summary>
        /// Displays all notifcations for a given user
        /// </summary>
        /// <param name="xuid"></param>
        public void Display(string xuid)
        {
            NotificationList notifications = Receive(xuid, 100000000);
            Display(notifications);
        }

        // This is what you are supposed to pass in for From
        private string From
        {
            get
            {
                UserInfo userInfo = new UserInfo();
                userInfo.DisplayName = DEFAULT_DISPLAYNAME;
                userInfo.GamerTag = DEFAULT_GAMERTAG;

                XmlSerializer serializer = new XmlSerializer(typeof(UserInfo));
                StringWriter writer = new StringWriter();
                serializer.Serialize(writer, userInfo);
                return writer.ToString();
            }
        }

        // Create new notification
        private void Create(Notification.NotificationType type)
        {
            switch (type)
            {
                case Notification.NotificationType.BadgeAwarded:
                    _notification = new BadgeAwardedNotification();
                    break;
                case Notification.NotificationType.BestScore:
                    _notification = new BestScoreNotification();
                    break;
                case Notification.NotificationType.BestTime:
                    _notification = new BestTimeNotification();
                    break;
                case Notification.NotificationType.FriendRequest:
                    _notification = new FriendRequestNotification();
                    break;
                case Notification.NotificationType.GameOver:
                    _notification = new GameOverNotification();
                    break;
                case Notification.NotificationType.GameSpecific:
                    _notification = new GameSpecificNotification();
                    break;
                case Notification.NotificationType.GameTie:
                    _notification = new GameTieNotification();
                    break;
                case Notification.NotificationType.Invitation:
                    _notification = new InvitationNotification();
                    _notification.Url = @"http://www.xbox.com";
                    break;
                case Notification.NotificationType.MessageWaiting:
                    _notification = new MessageWaitingNotification();
                    break;
                case Notification.NotificationType.Nudge:
                    _notification = new MessageWaitingNotification();
                    break;
                case Notification.NotificationType.PlayerJoined:
                    _notification = new PlayerJoinedNotification();
                    break;
                case Notification.NotificationType.PlayerLeft:
                    _notification = new PlayerLeftNotification();
                    break;
                case Notification.NotificationType.SessionRemoved:
                    _notification = new SessionRemovedNotification();
                    break;
                case Notification.NotificationType.StateChanged:
                    _notification = new StateChangedNotification();
                    break;
                case Notification.NotificationType.Warning:
                    _notification = new WarningNotification();
                    break;
                case Notification.NotificationType.YouLose:
                    _notification = new YouLoseNotification();
                    break;
                case Notification.NotificationType.YourTurn:
                    _notification = new YourTurnNotification();
                    break;
                case Notification.NotificationType.YouWin:
                    _notification = new YouWinNotification();
                    break;
                default:
                    throw new Exception("Cannot create notification because notification type " + type + " is not supported");
            }

            _notification.TypeDisplayName = type.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HtmlAgilityPack\HtmlAgilityPack\crc32.cs ===
// HtmlAgilityPack V1.0 - Simon Mourier <simon underscore mourier at hotmail dot com>
using System;
using System.IO;

namespace Test.Common.Library.HtmlAgilityPack
{
	/// <summary>
	/// A utility class to compute CRC32.
	/// </summary>
	public class Crc32
	{
		private uint _crc32 = 0;
		static private uint[] crc_32_tab =  // CRC polynomial 0xedb88320 
			{
				0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,
				0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
				0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
				0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
				0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
				0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
				0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,
				0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
				0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
				0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
				0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,
				0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
				0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,
				0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
				0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
				0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
				0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,
				0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
				0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,
				0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
				0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
				0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
				0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,
				0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
				0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
				0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
				0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
				0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
				0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,
				0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
				0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,
				0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
				0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
				0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
				0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
				0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
				0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,
				0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
				0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
				0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
				0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,
				0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
				0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d 
			};			

		static private uint UPDC32(byte octet, uint crc)
		{
			return (crc_32_tab[((crc)^((byte)octet)) & 0xff] ^ ((crc) >> 8));
		}

		internal uint CheckSum
		{
			get
			{
				return _crc32;
			}
			set
			{
				_crc32 = value;
			}
		}

		internal uint AddToCRC32(int c)
		{
			return AddToCRC32((ushort)c);
		}

		internal uint AddToCRC32(ushort c)
		{
			byte lowByte, hiByte;
			lowByte = (byte)(c & 0x00ff);
			hiByte = (byte)(c >> 8);
			_crc32 = UPDC32(hiByte, _crc32);
			_crc32 = UPDC32(lowByte, _crc32);
			return ~_crc32;
		}

		/// <summary>
		/// Compute a checksum for a given string.
		/// </summary>
		/// <param name="text">The string to compute the checksum for.</param>
		/// <returns>The computed checksum.</returns>
		static public uint CRC32String(string text)
		{
			uint oldcrc32;
			oldcrc32 = 0xFFFFFFFF;				
			int len = text.Length;
			ushort uCharVal;
			byte lowByte, hiByte;
				
			for ( int i=0; len>0; i++)
			{
				--len;
				uCharVal = text[len];
				unchecked
				{
					lowByte = (byte)(uCharVal & 0x00ff);
					hiByte = (byte)(uCharVal >> 8);
				}
				oldcrc32 = UPDC32(hiByte, oldcrc32);
				oldcrc32 = UPDC32(lowByte, oldcrc32);
			}

			return ~oldcrc32;
		}

		/// <summary>
		/// Compute a checksum for a given array of bytes.
		/// </summary>
		/// <param name="bytes">The array of bytes to compute the checksum for.</param>
		/// <returns>The computed checksum.</returns>
		static public uint CRC32Bytes(byte[] bytes)
		{
			uint oldcrc32;
			oldcrc32 = 0xFFFFFFFF;				
			int len = bytes.Length;
				
			for ( int i=0; len>0; i++)
			{
				--len;
				oldcrc32 = UPDC32(bytes[len], oldcrc32);
			}
			return ~oldcrc32;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HtmlAgilityPack\HtmlAgilityPack\EncodingFoundException.cs ===
// HtmlAgilityPack V1.0 - Simon Mourier <simon underscore mourier at hotmail dot com>
using System;
using System.Text;

namespace Test.Common.Library.HtmlAgilityPack
{
    internal class EncodingFoundException : Exception
    {
        private Encoding _encoding;

        internal EncodingFoundException(Encoding encoding)
        {
            _encoding = encoding;
        }

        internal Encoding Encoding
        {
            get
            {
                return _encoding;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\FiddlerHandler\FiddlerTest\Program.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using Test.Common.Library.FiddlerHandler;

namespace FiddlerTest
{
    class Program
    {
        [STAThread]
        static void Main(string[] args)
        {
            FiddlerInstance fiZone = new FiddlerInstance();

            fiZone.Start();
            fiZone.OpenURL("http://zonenxt.msn-int.com/en/zuma/game.htm");
            System.Threading.Thread.Sleep(20000);
            fiZone.Stop();
            string path = fiZone.Dump();
            fiZone.Exit();
            //Console.WriteLine(path);
            //"href", "sno", "result", "protocol", "host", "url", "body", "caching", "content-type", "user-defined" 
            //Console.Write(fiZone.FindURL("zone.msn.com")["result"].ToString());

            //string[] s = fiZone.GetCookieList(3, @"C:\Documents and Settings\cgtest\My Documents\Fiddler2\Captures\633402246241649942\dump");
            //Console.WriteLine(s[1]);
            //Console.WriteLine(s[2]);
            //Console.WriteLine(s[3]);
            fiZone.FindRow("http://zonenxt.msn-int.com/en/zuma/game.htm");
            //fiZone.Exit();
            Console.ReadKey();

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HtmlAgilityPack\HtmlAgilityPack\HtmlAttribute.cs ===
// HtmlAgilityPack V1.0 - Simon Mourier <simon underscore mourier at hotmail dot com>
using System;
using System.Collections;

namespace Test.Common.Library.HtmlAgilityPack
{
	/// <summary>
	/// Represents an HTML attribute.
	/// </summary>
	public class HtmlAttribute: IComparable
	{
		internal int _line = 0;
		internal int _lineposition = 0;
		internal int _streamposition = 0;
		internal int _namestartindex = 0;
		internal int _namelength = 0;
		internal int _valuestartindex = 0;
		internal int _valuelength = 0;
		internal HtmlDocument _ownerdocument; // attribute can exists without a node
		internal HtmlNode _ownernode;
		internal string _name;
		internal string _value;

		internal HtmlAttribute(HtmlDocument ownerdocument)
		{
			_ownerdocument = ownerdocument;
		}

		/// <summary>
		/// Creates a duplicate of this attribute.
		/// </summary>
		/// <returns>The cloned attribute.</returns>
		public HtmlAttribute Clone()
		{
			HtmlAttribute att = new HtmlAttribute(_ownerdocument);
			att.Name = Name;
			att.Value = Value;
			return att;
		}

		/// <summary>
		/// Compares the current instance with another attribute. Comparison is based on attributes' name.
		/// </summary>
		/// <param name="obj">An attribute to compare with this instance.</param>
		/// <returns>A 32-bit signed integer that indicates the relative order of the names comparison.</returns>
		public int CompareTo(object obj)
		{
			HtmlAttribute att = obj as HtmlAttribute;
			if (att == null)
			{
				throw new ArgumentException("obj");
			}
			return Name.CompareTo(att.Name);
		}

		internal string XmlName
		{
			get
			{
				return HtmlDocument.GetXmlName(Name);
			}
		}

		internal string XmlValue
		{
			get
			{
				return Value;
			}
		}

		/// <summary>
		/// Gets the qualified name of the attribute.
		/// </summary>
		public string Name
		{
			get
			{
				if (_name == null)
				{
					_name = _ownerdocument._text.Substring(_namestartindex, _namelength).ToLower();
				}
				return _name;
			}
			set
			{
				if (value == null)
				{
					throw new ArgumentNullException("value");
				}
				_name = value.ToLower();
				if (_ownernode != null)
				{
					_ownernode._innerchanged = true;
					_ownernode._outerchanged = true;
				}
			}
		}

		/// <summary>
		/// Gets or sets the value of the attribute.
		/// </summary>
		public string Value
		{
			get
			{
				if (_value == null)
				{
					_value = _ownerdocument._text.Substring(_valuestartindex, _valuelength);
				}
				return _value;
			}
			set
			{
				_value = value;
				if (_ownernode != null)
				{
					_ownernode._innerchanged = true;
					_ownernode._outerchanged = true;
				}
			}
		}

		/// <summary>
		/// Gets the line number of this attribute in the document.
		/// </summary>
		public int Line
		{
			get
			{
				return _line;
			}
		}

		/// <summary>
		/// Gets the column number of this attribute in the document.
		/// </summary>
		public int LinePosition
		{
			get
			{
				return _lineposition;
			}
		}

		/// <summary>
		/// Gets the stream position of this attribute in the document, relative to the start of the document.
		/// </summary>
		public int StreamPosition
		{
			get
			{
				return _streamposition;
			}
		}

		/// <summary>
		/// Gets the HTML node to which this attribute belongs.
		/// </summary>
		public HtmlNode OwnerNode
		{
			get
			{
				return _ownernode;
			}
		}

		/// <summary>
		/// Gets the HTML document to which this attribute belongs.
		/// </summary>
		public HtmlDocument OwnerDocument
		{
			get
			{
				return _ownerdocument;
			}
		}

	}


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HtmlAgilityPack\HtmlAgilityPack\HtmlAttributeCollection.cs ===
// HtmlAgilityPack V1.0 - Simon Mourier <simon underscore mourier at hotmail dot com>
using System;
using System.Collections;

namespace Test.Common.Library.HtmlAgilityPack
{
    /// <summary>
    /// Represents a combined list and collection of HTML nodes.
    /// </summary>
    public class HtmlAttributeCollection : IEnumerable
    {
        internal Hashtable _hashitems = new Hashtable();
        private ArrayList _items = new ArrayList();
        private HtmlNode _ownernode;

        internal HtmlAttributeCollection(HtmlNode ownernode)
        {
            _ownernode = ownernode;
        }

        /// <summary>
        /// Inserts the specified attribute as the last attribute in the collection.
        /// </summary>
        /// <param name="newAttribute">The attribute to insert. May not be null.</param>
        /// <returns>The appended attribute.</returns>
        public HtmlAttribute Append(HtmlAttribute newAttribute)
        {
            if (newAttribute == null)
            {
                throw new ArgumentNullException("newAttribute");
            }

            _hashitems[newAttribute.Name] = newAttribute;
            newAttribute._ownernode = _ownernode;
            _items.Add(newAttribute);

            _ownernode._innerchanged = true;
            _ownernode._outerchanged = true;
            return newAttribute;
        }

        /// <summary>
        /// Creates and inserts a new attribute as the last attribute in the collection.
        /// </summary>
        /// <param name="name">The name of the attribute to insert.</param>
        /// <returns>The appended attribute.</returns>
        public HtmlAttribute Append(string name)
        {
            HtmlAttribute att = _ownernode._ownerdocument.CreateAttribute(name);
            return Append(att);
        }

        /// <summary>
        /// Creates and inserts a new attribute as the last attribute in the collection.
        /// </summary>
        /// <param name="name">The name of the attribute to insert.</param>
        /// <param name="value">The value of the attribute to insert.</param>
        /// <returns>The appended attribute.</returns>
        public HtmlAttribute Append(string name, string value)
        {
            HtmlAttribute att = _ownernode._ownerdocument.CreateAttribute(name, value);
            return Append(att);
        }

        /// <summary>
        /// Inserts the specified attribute as the first node in the collection.
        /// </summary>
        /// <param name="newAttribute">The attribute to insert. May not be null.</param>
        /// <returns>The prepended attribute.</returns>
        public HtmlAttribute Prepend(HtmlAttribute newAttribute)
        {
            if (newAttribute == null)
            {
                throw new ArgumentNullException("newAttribute");
            }

            _hashitems[newAttribute.Name] = newAttribute;
            newAttribute._ownernode = _ownernode;
            _items.Insert(0, newAttribute);

            _ownernode._innerchanged = true;
            _ownernode._outerchanged = true;
            return newAttribute;
        }

        /// <summary>
        /// Removes the attribute at the specified index.
        /// </summary>
        /// <param name="index">The index of the attribute to remove.</param>
        public void RemoveAt(int index)
        {
            HtmlAttribute att = (HtmlAttribute)_items[index];
            _hashitems.Remove(att.Name);
            _items.RemoveAt(index);

            _ownernode._innerchanged = true;
            _ownernode._outerchanged = true;
        }

        /// <summary>
        /// Removes a given attribute from the list.
        /// </summary>
        /// <param name="attribute">The attribute to remove. May not be null.</param>
        public void Remove(HtmlAttribute attribute)
        {
            if (attribute == null)
            {
                throw new ArgumentNullException("attribute");
            }
            int index = GetAttributeIndex(attribute);
            if (index == -1)
            {
                throw new IndexOutOfRangeException();
            }
            RemoveAt(index);
        }

        /// <summary>
        /// Removes an attribute from the list, using its name. If there are more than one attributes with this name, they will all be removed.
        /// </summary>
        /// <param name="name">The attribute's name. May not be null.</param>
        public void Remove(string name)
        {
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            string lname = name.ToLower();
            for (int i = 0; i < _items.Count; i++)
            {
                HtmlAttribute att = (HtmlAttribute)_items[i];
                if (att.Name == lname)
                {
                    RemoveAt(i);
                }
            }
        }

        /// <summary>
        /// Remove all attributes in the list.
        /// </summary>
        public void RemoveAll()
        {
            _hashitems.Clear();
            _items.Clear();

            _ownernode._innerchanged = true;
            _ownernode._outerchanged = true;
        }

        /// <summary>
        /// Gets the number of elements actually contained in the list.
        /// </summary>
        public int Count
        {
            get
            {
                return _items.Count;
            }
        }

        internal int GetAttributeIndex(HtmlAttribute attribute)
        {
            if (attribute == null)
            {
                throw new ArgumentNullException("attribute");
            }
            for (int i = 0; i < _items.Count; i++)
            {
                if (((HtmlAttribute)_items[i]) == attribute)
                    return i;
            }
            return -1;
        }

        internal int GetAttributeIndex(string name)
        {
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            string lname = name.ToLower();
            for (int i = 0; i < _items.Count; i++)
            {
                if (((HtmlAttribute)_items[i]).Name == lname)
                    return i;
            }
            return -1;
        }

        /// <summary>
        /// Gets a given attribute from the list using its name.
        /// </summary>
        public HtmlAttribute this[string name]
        {
            get
            {
                if (name == null)
                {
                    throw new ArgumentNullException("name");
                }
                return _hashitems[name.ToLower()] as HtmlAttribute;
            }
        }

        /// <summary>
        /// Gets the attribute at the specified index.
        /// </summary>
        public HtmlAttribute this[int index]
        {
            get
            {
                return _items[index] as HtmlAttribute;
            }
        }

        internal void Clear()
        {
            _hashitems.Clear();
            _items.Clear();
        }

        /// <summary>
        /// Returns an enumerator that can iterate through the list.
        /// </summary>
        /// <returns>An IEnumerator for the entire list.</returns>
        public HtmlAttributeEnumerator GetEnumerator()
        {
            return new HtmlAttributeEnumerator(_items);
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        /// <summary>
        /// Represents an enumerator that can iterate through the list.
        /// </summary>
        public class HtmlAttributeEnumerator : IEnumerator
        {
            int _index;
            ArrayList _items;

            internal HtmlAttributeEnumerator(ArrayList items)
            {
                _items = items;
                _index = -1;
            }

            /// <summary>
            /// Sets the enumerator to its initial position, which is before the first element in the collection.
            /// </summary>
            public void Reset()
            {
                _index = -1;
            }

            /// <summary>
            /// Advances the enumerator to the next element of the collection.
            /// </summary>
            /// <returns>true if the enumerator was successfully advanced to the next element, false if the enumerator has passed the end of the collection.</returns>
            public bool MoveNext()
            {
                _index++;
                return (_index < _items.Count);
            }

            /// <summary>
            /// Gets the current element in the collection.
            /// </summary>
            public HtmlAttribute Current
            {
                get
                {
                    return (HtmlAttribute)(_items[_index]);
                }
            }

            /// <summary>
            /// Gets the current element in the collection.
            /// </summary>
            object IEnumerator.Current
            {
                get
                {
                    return (Current);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HtmlAgilityPack\HtmlAgilityPack\HtmlElementFlag.cs ===
// HtmlAgilityPack V1.0 - Simon Mourier <simon underscore mourier at hotmail dot com>
using System;

namespace Test.Common.Library.HtmlAgilityPack
{
    /// <summary>
    /// Flags that describe the behavior of an Element node.
    /// </summary>
    public enum HtmlElementFlag
    {
        /// <summary>
        /// The node is a CDATA node.
        /// </summary>
        CData = 1,

        /// <summary>
        /// The node is empty. META or IMG are example of such nodes.
        /// </summary>
        Empty = 2,

        /// <summary>
        /// The node will automatically be closed during parsing.
        /// </summary>
        Closed = 4,

        /// <summary>
        /// The node can overlap.
        /// </summary>
        CanOverlap = 8
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HtmlAgilityPack\HtmlAgilityPack\HtmlConsoleListener.cs ===
// HtmlAgilityPack V1.0 - Simon Mourier <simon underscore mourier at hotmail dot com>
using System;
using System.Diagnostics;

namespace Test.Common.Library.HtmlAgilityPack
{
    internal class HtmlConsoleListener : System.Diagnostics.TraceListener
    {
        public override void WriteLine(string Message)
        {
            Write(Message + "\n");
        }

        public override void Write(string Message)
        {
            Write(Message, "");
        }

        public override void Write(string Message, string Category)
        {
            Console.Write("T:" + Category + ": " + Message);
        }

        public override void WriteLine(string Message, string Category)
        {
            Write(Message + "\n", Category);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HtmlAgilityPack\HtmlAgilityPack\HtmlCmdLine.cs ===
// HtmlAgilityPack V1.0 - Simon Mourier <simon underscore mourier at hotmail dot com>
using System;

namespace Test.Common.Library.HtmlAgilityPack
{
	internal class HtmlCmdLine
	{
		static internal bool Help;

		static HtmlCmdLine()
		{
			Help = false;
			ParseArgs();
		}

		internal static string GetOption(string name, string def)
		{
			string p = def;
			string[] args = Environment.GetCommandLineArgs();
			for (int i=1;i<args.Length;i++)
			{
				GetStringArg(args[i], name, ref p);
			}
			return p;
		}

		internal static string GetOption(int index, string def)
		{
			string p = def;
			string[] args = Environment.GetCommandLineArgs();
			int j = 0;
			for (int i=1;i<args.Length;i++)
			{
				if (GetStringArg(args[i], ref p))
				{
					if (index==j)
						return p;
					else
						p = def;
					j++;
				}
			}
			return p;
		}

		internal static bool GetOption(string name, bool def)
		{
			bool p = def;
			string[] args = Environment.GetCommandLineArgs();
			for (int i=1;i<args.Length;i++)
			{
				GetBoolArg(args[i], name, ref p);
			}
			return p;
		}

		internal static int GetOption(string name, int def)
		{
			int p = def;
			string[] args = Environment.GetCommandLineArgs();
			for (int i=1;i<args.Length;i++)
			{
				GetIntArg(args[i], name, ref p);
			}
			return p;
		}

		private static void ParseArgs()
		{
			string[] args = Environment.GetCommandLineArgs();
			for (int i=1;i<args.Length;i++)
			{
				// help
				GetBoolArg(args[i], "?", ref Help);
				GetBoolArg(args[i], "h", ref Help);
				GetBoolArg(args[i], "help", ref Help);
			}
		}

		private static bool GetStringArg(string Arg, ref string ArgValue)
		{
			if (('/'==Arg[0]) || ('-'==Arg[0]))
				return false;
			ArgValue = Arg;
			return true;
		}

		private static void GetStringArg(string Arg, string Name, ref string ArgValue)
		{
			if (Arg.Length<(Name.Length+3)) // -name:x is 3 more than name
				return;
			if (('/'!=Arg[0]) && ('-'!=Arg[0]))	// not a param
				return;
			if (Arg.Substring(1, Name.Length).ToLower()==Name.ToLower())
				ArgValue = Arg.Substring(Name.Length+2, Arg.Length-Name.Length-2);
		}

		private static void GetBoolArg(string Arg, string Name, ref bool ArgValue)
		{
			if (Arg.Length<(Name.Length+1)) // -name is 1 more than name
				return;
			if (('/'!=Arg[0]) && ('-'!=Arg[0]))	// not a param
				return;
			if (Arg.Substring(1, Name.Length).ToLower()==Name.ToLower())
				ArgValue = true;
		}

		private static void GetIntArg(string Arg, string Name, ref int ArgValue)
		{
			if (Arg.Length<(Name.Length+3)) // -name:12 is 3 more than name
				return;
			if (('/'!=Arg[0]) && ('-'!=Arg[0]))	// not a param
				return;
			if (Arg.Substring(1, Name.Length).ToLower()==Name.ToLower())
			{
				try
				{
					ArgValue = Convert.ToInt32(Arg.Substring(Name.Length+2, Arg.Length-Name.Length-2));
				}
				catch
				{
				}
				
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HtmlAgilityPack\HtmlAgilityPack\HtmlCommentNode.cs ===
// HtmlAgilityPack V1.0 - Simon Mourier <simon underscore mourier at hotmail dot com>
using System;

namespace Test.Common.Library.HtmlAgilityPack
{
    /// <summary>
    /// Represents an HTML comment.
    /// </summary>
    public class HtmlCommentNode : HtmlNode
    {
        private string _comment;

        internal HtmlCommentNode(HtmlDocument ownerdocument, int index)
            :
            base(HtmlNodeType.Comment, ownerdocument, index)
        {
        }

        /// <summary>
        /// Gets or Sets the HTML between the start and end tags of the object. In the case of a text node, it is equals to OuterHtml.
        /// </summary>
        public override string InnerHtml
        {
            get
            {
                if (_comment == null)
                {
                    return base.InnerHtml;
                }
                return _comment;
            }
            set
            {
                _comment = value;
            }
        }

        /// <summary>
        /// Gets or Sets the object and its content in HTML.
        /// </summary>
        public override string OuterHtml
        {
            get
            {
                if (_comment == null)
                {
                    return base.OuterHtml;
                }
                return "<!--" + _comment + "-->";
            }
        }

        /// <summary>
        /// Gets or Sets the comment text of the node.
        /// </summary>
        public string Comment
        {
            get
            {
                if (_comment == null)
                {
                    return base.InnerHtml;
                }
                return _comment;
            }
            set
            {
                _comment = value;
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HtmlAgilityPack\HtmlAgilityPack\HtmlNameTable.cs ===
// HtmlAgilityPack V1.0 - Simon Mourier <simon underscore mourier at hotmail dot com>
using System;
using System.Xml;

namespace Test.Common.Library.HtmlAgilityPack
{
    internal class HtmlNameTable : XmlNameTable
    {
        private NameTable _nametable = new NameTable();

        internal HtmlNameTable()
        {
        }

        internal string GetOrAdd(string array)
        {
            string s = Get(array);
            if (s == null)
            {
                return Add(array);
            }
            return s;
        }

        public override string Add(string array)
        {
            return _nametable.Add(array);
        }

        public override string Get(string array)
        {
            return _nametable.Get(array);
        }

        public override string Get(char[] array, int offset, int length)
        {
            return _nametable.Get(array, offset, length);
        }

        public override string Add(char[] array, int offset, int length)
        {
            return _nametable.Add(array, offset, length);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HtmlAgilityPack\HtmlAgilityPack\HtmlNodeCollection.cs ===
// HtmlAgilityPack V1.0 - Simon Mourier <simon underscore mourier at hotmail dot com>
using System;
using System.Collections;

namespace Test.Common.Library.HtmlAgilityPack
{
    /// <summary>
    /// Represents a combined list and collection of HTML nodes.
    /// </summary>
    public class HtmlNodeCollection : IEnumerable
    {
        private ArrayList _items = new ArrayList();
        private HtmlNode _parentnode;

        internal HtmlNodeCollection(HtmlNode parentnode)
        {
            _parentnode = parentnode; // may be null
        }

        /// <summary>
        /// Gets the number of elements actually contained in the list.
        /// </summary>
        public int Count
        {
            get
            {
                return _items.Count;
            }
        }

        internal void Clear()
        {
            foreach (HtmlNode node in _items)
            {
                node._parentnode = null;
                node._nextnode = null;
                node._prevnode = null;
            }
            _items.Clear();
        }

        internal void Remove(int index)
        {
            HtmlNode next = null;
            HtmlNode prev = null;
            HtmlNode oldnode = (HtmlNode)_items[index];

            if (index > 0)
            {
                prev = (HtmlNode)_items[index - 1];
            }

            if (index < (_items.Count - 1))
            {
                next = (HtmlNode)_items[index + 1];
            }

            _items.RemoveAt(index);

            if (prev != null)
            {
                if (next == prev)
                {
                    throw new InvalidProgramException("Unexpected error.");
                }
                prev._nextnode = next;
            }

            if (next != null)
            {
                next._prevnode = prev;
            }

            oldnode._prevnode = null;
            oldnode._nextnode = null;
            oldnode._parentnode = null;
        }

        internal void Replace(int index, HtmlNode node)
        {
            HtmlNode next = null;
            HtmlNode prev = null;
            HtmlNode oldnode = (HtmlNode)_items[index];

            if (index > 0)
            {
                prev = (HtmlNode)_items[index - 1];
            }

            if (index < (_items.Count - 1))
            {
                next = (HtmlNode)_items[index + 1];
            }

            _items[index] = node;

            if (prev != null)
            {
                if (node == prev)
                {
                    throw new InvalidProgramException("Unexpected error.");
                }
                prev._nextnode = node;
            }

            if (next != null)
            {
                next._prevnode = node;
            }

            node._prevnode = prev;
            if (next == node)
            {
                throw new InvalidProgramException("Unexpected error.");
            }
            node._nextnode = next;
            node._parentnode = _parentnode;

            oldnode._prevnode = null;
            oldnode._nextnode = null;
            oldnode._parentnode = null;
        }

        internal void Insert(int index, HtmlNode node)
        {
            HtmlNode next = null;
            HtmlNode prev = null;

            if (index > 0)
            {
                prev = (HtmlNode)_items[index - 1];
            }

            if (index < _items.Count)
            {
                next = (HtmlNode)_items[index];
            }

            _items.Insert(index, node);

            if (prev != null)
            {
                if (node == prev)
                {
                    throw new InvalidProgramException("Unexpected error.");
                }
                prev._nextnode = node;
            }

            if (next != null)
            {
                next._prevnode = node;
            }

            node._prevnode = prev;

            if (next == node)
            {
                throw new InvalidProgramException("Unexpected error.");
            }

            node._nextnode = next;
            node._parentnode = _parentnode;
        }

        internal void Append(HtmlNode node)
        {
            HtmlNode last = null;
            if (_items.Count > 0)
            {
                last = (HtmlNode)_items[_items.Count - 1];
            }

            _items.Add(node);
            node._prevnode = last;
            node._nextnode = null;
            node._parentnode = _parentnode;
            if (last != null)
            {
                if (last == node)
                {
                    throw new InvalidProgramException("Unexpected error.");
                }
                last._nextnode = node;
            }
        }

        internal void Prepend(HtmlNode node)
        {
            HtmlNode first = null;
            if (_items.Count > 0)
            {
                first = (HtmlNode)_items[0];
            }

            _items.Insert(0, node);

            if (node == first)
            {
                throw new InvalidProgramException("Unexpected error.");
            }
            node._nextnode = first;
            node._prevnode = null;
            node._parentnode = _parentnode;
            if (first != null)
            {
                first._prevnode = node;
            }
        }

        internal void Add(HtmlNode node)
        {
            _items.Add(node);
        }

        /// <summary>
        /// Gets the node at the specified index.
        /// </summary>
        public HtmlNode this[int index]
        {
            get
            {
                return _items[index] as HtmlNode;
            }
        }

        internal int GetNodeIndex(HtmlNode node)
        {
            // TODO: should we rewrite this? what would be the key of a node?
            for (int i = 0; i < _items.Count; i++)
            {
                if (node == ((HtmlNode)_items[i]))
                {
                    return i;
                }
            }
            return -1;
        }

        /// <summary>
        /// Gets a given node from the list.
        /// </summary>
        public int this[HtmlNode node]
        {
            get
            {
                int index = GetNodeIndex(node);
                if (index == -1)
                {
                    throw new ArgumentOutOfRangeException("node", "Node \"" + node.CloneNode(false).OuterHtml + "\" was not found in the collection");
                }
                return index;
            }
        }

        /// <summary>
        /// Returns an enumerator that can iterate through the list.
        /// </summary>
        /// <returns>An IEnumerator for the entire list.</returns>
        public HtmlNodeEnumerator GetEnumerator()
        {
            return new HtmlNodeEnumerator(_items);
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        /// <summary>
        /// Represents an enumerator that can iterate through the list.
        /// </summary>
        public class HtmlNodeEnumerator : IEnumerator
        {
            int _index;
            ArrayList _items;

            internal HtmlNodeEnumerator(ArrayList items)
            {
                _items = items;
                _index = -1;
            }

            /// <summary>
            /// Sets the enumerator to its initial position, which is before the first element in the collection.
            /// </summary>
            public void Reset()
            {
                _index = -1;
            }

            /// <summary>
            /// Advances the enumerator to the next element of the collection.
            /// </summary>
            /// <returns>true if the enumerator was successfully advanced to the next element, false if the enumerator has passed the end of the collection.</returns>
            public bool MoveNext()
            {
                _index++;
                return (_index < _items.Count);
            }

            /// <summary>
            /// Gets the current element in the collection.
            /// </summary>
            public HtmlNode Current
            {
                get
                {
                    return (HtmlNode)(_items[_index]);
                }
            }

            /// <summary>
            /// Gets the current element in the collection.
            /// </summary>
            object IEnumerator.Current
            {
                get
                {
                    return (Current);
                }
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HtmlAgilityPack\HtmlAgilityPack\HtmlParseError.cs ===
// HtmlAgilityPack V1.0 - Simon Mourier <simon underscore mourier at hotmail dot com>
using System;

namespace Test.Common.Library.HtmlAgilityPack
{

    /// <summary>
    /// Represents a parsing error found during document parsing.
    /// </summary>
    public class HtmlParseError
    {
        private HtmlParseErrorCode _code;
        private int _line;
        private int _linePosition;
        private int _streamPosition;
        private string _sourceText;
        private string _reason;

        internal HtmlParseError(
            HtmlParseErrorCode code,
            int line,
            int linePosition,
            int streamPosition,
            string sourceText,
            string reason)
        {
            _code = code;
            _line = line;
            _linePosition = linePosition;
            _streamPosition = streamPosition;
            _sourceText = sourceText;
            _reason = reason;
        }

        /// <summary>
        /// Gets the type of error.
        /// </summary>
        public HtmlParseErrorCode Code
        {
            get
            {
                return _code;
            }
        }

        /// <summary>
        /// Gets the line number of this error in the document.
        /// </summary>
        public int Line
        {
            get
            {
                return _line;
            }
        }

        /// <summary>
        /// Gets the column number of this error in the document.
        /// </summary>
        public int LinePosition
        {
            get
            {
                return _linePosition;
            }
        }

        /// <summary>
        /// Gets the absolute stream position of this error in the document, relative to the start of the document.
        /// </summary>
        public int StreamPosition
        {
            get
            {
                return _streamPosition;
            }
        }

        /// <summary>
        /// Gets the the full text of the line containing the error.
        /// </summary>
        public string SourceText
        {
            get
            {
                return _sourceText;
            }
        }

        /// <summary>
        /// Gets a description for the error.
        /// </summary>
        public string Reason
        {
            get
            {
                return _reason;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HtmlAgilityPack\HtmlAgilityPack\HtmlNode.cs ===
// HtmlAgilityPack V1.0 - Simon Mourier <simon underscore mourier at hotmail dot com>
using System;
using System.Collections;
using System.IO;
using System.Xml;
using System.Xml.XPath;

namespace Test.Common.Library.HtmlAgilityPack
{
	/// <summary>
	/// Represents an HTML node.
	/// </summary>
	public class HtmlNode: IXPathNavigable
	{
		/// <summary>
		/// Gets the name of a comment node. It is actually defined as '#comment'.
		/// </summary>
		public static readonly string HtmlNodeTypeNameComment = "#comment";

		/// <summary>
		/// Gets the name of the document node. It is actually defined as '#document'.
		/// </summary>
		public static readonly string HtmlNodeTypeNameDocument = "#document";

		/// <summary>
		/// Gets the name of a text node. It is actually defined as '#text'.
		/// </summary>
		public static readonly string HtmlNodeTypeNameText = "#text";

		/// <summary>
		/// Gets a collection of flags that define specific behaviors for specific element nodes.
		/// The table contains a DictionaryEntry list with the lowercase tag name as the Key, and a combination of HtmlElementFlags as the Value.
		/// </summary>
		public static Hashtable ElementsFlags;

		internal HtmlNodeType _nodetype;
		internal HtmlNode _nextnode;
		internal HtmlNode _prevnode;
		internal HtmlNode _parentnode;
		internal HtmlDocument _ownerdocument;
		internal HtmlNodeCollection _childnodes;
		internal HtmlAttributeCollection _attributes;
		internal int _line = 0;
		internal int _lineposition = 0;
		internal int _streamposition = 0;
		internal int _innerstartindex = 0;
		internal int _innerlength = 0;
		internal int _outerstartindex = 0;
		internal int _outerlength = 0;
		internal int _namestartindex = 0;
		internal int _namelength = 0;
		internal bool _starttag = false;
		internal string _name;
		internal HtmlNode _prevwithsamename = null;
		internal HtmlNode _endnode;

		internal bool _innerchanged = false;
		internal bool _outerchanged = false;
		internal string _innerhtml;
		internal string _outerhtml;

		static HtmlNode()
		{
			// tags whose content may be anything
			ElementsFlags = new Hashtable();
			ElementsFlags.Add("script", HtmlElementFlag.CData);
			ElementsFlags.Add("style", HtmlElementFlag.CData);
			ElementsFlags.Add("noxhtml", HtmlElementFlag.CData);

			// tags that can not contain other tags
			ElementsFlags.Add("base", HtmlElementFlag.Empty);
			ElementsFlags.Add("link", HtmlElementFlag.Empty);
			ElementsFlags.Add("meta", HtmlElementFlag.Empty);
			ElementsFlags.Add("isindex", HtmlElementFlag.Empty);
			ElementsFlags.Add("hr", HtmlElementFlag.Empty);
			ElementsFlags.Add("col", HtmlElementFlag.Empty);
			ElementsFlags.Add("img", HtmlElementFlag.Empty);
			ElementsFlags.Add("param", HtmlElementFlag.Empty);
			ElementsFlags.Add("embed", HtmlElementFlag.Empty);
			ElementsFlags.Add("frame", HtmlElementFlag.Empty);
			ElementsFlags.Add("wbr", HtmlElementFlag.Empty);
			ElementsFlags.Add("bgsound", HtmlElementFlag.Empty);
			ElementsFlags.Add("spacer", HtmlElementFlag.Empty);
			ElementsFlags.Add("keygen", HtmlElementFlag.Empty);
			ElementsFlags.Add("area", HtmlElementFlag.Empty);
			ElementsFlags.Add("input", HtmlElementFlag.Empty);
			ElementsFlags.Add("basefont", HtmlElementFlag.Empty);

			ElementsFlags.Add("form", HtmlElementFlag.CanOverlap | HtmlElementFlag.Empty);

			// they sometimes contain, and sometimes they don 't...
			ElementsFlags.Add("option", HtmlElementFlag.Empty);

			// tag whose closing tag is equivalent to open tag:
			// <p>bla</p>bla will be transformed into <p>bla</p>bla
			// <p>bla<p>bla will be transformed into <p>bla<p>bla and not <p>bla></p><p>bla</p> or <p>bla<p>bla</p></p>
			//<br> see above
			ElementsFlags.Add("br", HtmlElementFlag.Empty | HtmlElementFlag.Closed);
			ElementsFlags.Add("p", HtmlElementFlag.Empty | HtmlElementFlag.Closed);
		}

		/// <summary>
		/// Determines if an element node is closed.
		/// </summary>
		/// <param name="name">The name of the element node to check. May not be null.</param>
		/// <returns>true if the name is the name of a closed element node, false otherwise.</returns>
		public static bool IsClosedElement(string name)
		{
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}

			object flag = ElementsFlags[name.ToLower()];
			if (flag == null)
			{
				return false;
			}
			return (((HtmlElementFlag)flag)&HtmlElementFlag.Closed) != 0;
		}

		/// <summary>
		/// Determines if an element node can be kept overlapped.
		/// </summary>
		/// <param name="name">The name of the element node to check. May not be null.</param>
		/// <returns>true if the name is the name of an element node that can be kept overlapped, false otherwise.</returns>
		public static bool CanOverlapElement(string name)
		{
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}

			object flag = ElementsFlags[name.ToLower()];
			if (flag == null)
			{
				return false;
			}
			return (((HtmlElementFlag)flag)&HtmlElementFlag.CanOverlap) != 0;
		}

		/// <summary>
		/// Determines if a text corresponds to the closing tag of an node that can be kept overlapped.
		/// </summary>
		/// <param name="text">The text to check. May not be null.</param>
		/// <returns>true or false.</returns>
		public static bool IsOverlappedClosingElement(string text)
		{
			if (text == null)
			{
				throw new ArgumentNullException("text");
			}
			// min is </x>: 4
			if (text.Length <= 4)
				return false;

			if ((text[0] != '<') ||
				(text[text.Length - 1] != '>') ||
				(text[1] != '/'))
				return false;

			string name = text.Substring(2, text.Length - 3);
			return CanOverlapElement(name);
		}

		/// <summary>
		/// Determines if an element node is a CDATA element node.
		/// </summary>
		/// <param name="name">The name of the element node to check. May not be null.</param>
		/// <returns>true if the name is the name of a CDATA element node, false otherwise.</returns>
		public static bool IsCDataElement(string name)
		{
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}

			object flag = ElementsFlags[name.ToLower()];
			if (flag == null)
			{
				return false;
			}
			return (((HtmlElementFlag)flag)&HtmlElementFlag.CData) != 0;
		}

		/// <summary>
		/// Determines if an element node is defined as empty.
		/// </summary>
		/// <param name="name">The name of the element node to check. May not be null.</param>
		/// <returns>true if the name is the name of an empty element node, false otherwise.</returns>
		public static bool IsEmptyElement(string name)
		{
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}

			if (name.Length == 0)
			{
				return true;
			}

			// <!DOCTYPE ...
			if ('!' == name[0])
			{
				return true;
			}
			
			// <?xml ...
			if ('?' == name[0])
			{
				return true;
			}
			
			object flag = ElementsFlags[name.ToLower()];
			if (flag == null)
			{
				return false;
			}
			return (((HtmlElementFlag)flag)&HtmlElementFlag.Empty) != 0;
		}

		/// <summary>
		/// Creates an HTML node from a string representing literal HTML.
		/// </summary>
		/// <param name="html">The HTML text.</param>
		/// <returns>The newly created node instance.</returns>
		public static HtmlNode CreateNode(string html)
		{
			// REVIEW: this is *not* optimum...
			HtmlDocument doc = new HtmlDocument();
			doc.LoadHtml(html);
			return doc.DocumentNode.FirstChild;
		}

		/// <summary>
		/// Creates a duplicate of the node and the subtree under it.
		/// </summary>
		/// <param name="node">The node to duplicate. May not be null.</param>
		public void CopyFrom(HtmlNode node)
		{
			CopyFrom(node, true);
		}

		/// <summary>
		/// Creates a duplicate of the node.
		/// </summary>
		/// <param name="node">The node to duplicate. May not be null.</param>
		/// <param name="deep">true to recursively clone the subtree under the specified node, false to clone only the node itself.</param>
		public void CopyFrom(HtmlNode node, bool deep)
		{
			if (node == null)
			{
				throw new ArgumentNullException("node");
			}

			Attributes.RemoveAll();
			if (node.HasAttributes)
			{
				foreach(HtmlAttribute att in node.Attributes)
				{
					SetAttributeValue(att.Name, att.Value);
				}
			}

			if (!deep)
			{
				RemoveAllChildren();
				if (node.HasChildNodes)
				{
					foreach(HtmlNode child in node.ChildNodes)
					{
						AppendChild(child.CloneNode(true));
					}
				}
			}
		}

		internal HtmlNode(HtmlNodeType type, HtmlDocument ownerdocument, int index)
		{
			_nodetype = type;
			_ownerdocument = ownerdocument;
			_outerstartindex = index;

			switch(type)
			{
				case HtmlNodeType.Comment:
					_name = HtmlNodeTypeNameComment;
					_endnode = this;
					break;

				case HtmlNodeType.Document:
					_name = HtmlNodeTypeNameDocument;
					_endnode = this;
					break;

				case HtmlNodeType.Text:
					_name = HtmlNodeTypeNameText;
					_endnode = this;
					break;
			}

			if (_ownerdocument._openednodes != null)
			{
				if (!Closed)
				{
					// we use the index as the key

					// -1 means the node comes from public
					if (-1 != index)
					{
						_ownerdocument._openednodes.Add(index, this);
					}
				}
			}
			
			if ((-1 == index) && (type != HtmlNodeType.Comment) && (type != HtmlNodeType.Text))
			{
				// innerhtml and outerhtml must be calculated
				_outerchanged = true;
				_innerchanged = true;
			}
		}

		internal void CloseNode(HtmlNode endnode)
		{
			if (!_ownerdocument.OptionAutoCloseOnEnd)
			{
				// close all children
				if (_childnodes != null)
				{
					foreach(HtmlNode child in _childnodes)
					{
						if (child.Closed)
							continue;

						// create a fake closer node
						HtmlNode close = new HtmlNode(NodeType, _ownerdocument, -1);
						close._endnode = close;
						child.CloseNode(close);
					}
				}
			}

			if (!Closed)
			{
				_endnode = endnode;

				if (_ownerdocument._openednodes != null)
				{
					_ownerdocument._openednodes.Remove(_outerstartindex);
				}

				HtmlNode self = _ownerdocument._lastnodes[Name] as HtmlNode;
				if (self == this)
				{
					_ownerdocument._lastnodes.Remove(Name);
					_ownerdocument.UpdateLastParentNode();
				}

				if (endnode == this)
					return;

				// create an inner section
				_innerstartindex = _outerstartindex + _outerlength;
				_innerlength = endnode._outerstartindex - _innerstartindex;

				// update full length
				_outerlength = (endnode._outerstartindex + endnode._outerlength) - _outerstartindex;
			}
		}

		internal HtmlNode EndNode
		{
			get
			{
				return _endnode;
			}
		}

		internal string GetId()
		{
			HtmlAttribute att = Attributes["id"];
			if (att == null)
			{
				return null;
			}
			return att.Value;
		}

		internal void SetId(string id)
		{
			HtmlAttribute att = Attributes["id"];
			if (att == null)
			{
				att = _ownerdocument.CreateAttribute("id");
			}
			att.Value = id;
			_ownerdocument.SetIdForNode(this, att.Value);
			_outerchanged = true;
		}

		/// <summary>
		/// Creates a new XPathNavigator object for navigating this HTML node.
		/// </summary>
		/// <returns>An XPathNavigator object. The XPathNavigator is positioned on the node from which the method was called. It is not positioned on the root of the document.</returns>
		public XPathNavigator CreateNavigator()
		{
			return new HtmlNodeNavigator(_ownerdocument, this);
		}

		/// <summary>
		/// Selects the first XmlNode that matches the XPath expression.
		/// </summary>
		/// <param name="xpath">The XPath expression. May not be null.</param>
		/// <returns>The first HtmlNode that matches the XPath query or a null reference if no matching node was found.</returns>
		public HtmlNode SelectSingleNode(string xpath)
		{
			if (xpath == null)
			{
				throw new ArgumentNullException("xpath");
			}

			HtmlNodeNavigator nav = new HtmlNodeNavigator(_ownerdocument, this);
			XPathNodeIterator it = nav.Select(xpath);
			if (!it.MoveNext())
			{
				return null;
			}

			HtmlNodeNavigator node = (HtmlNodeNavigator)it.Current;
			return node.CurrentNode;
		}

		/// <summary>
		/// Selects a list of nodes matching the XPath expression.
		/// </summary>
		/// <param name="xpath">The XPath expression.</param>
		/// <returns>An HtmlNodeCollection containing a collection of nodes matching the XPath query, or null if no node matched the XPath expression.</returns>
		public HtmlNodeCollection SelectNodes(string xpath)
		{
			HtmlNodeCollection list = new HtmlNodeCollection(null);

			HtmlNodeNavigator nav = new HtmlNodeNavigator(_ownerdocument, this);
			XPathNodeIterator it = nav.Select(xpath);
			while (it.MoveNext())
			{
				HtmlNodeNavigator n = (HtmlNodeNavigator)it.Current;
				list.Add(n.CurrentNode);
			}
			if (list.Count == 0)
			{
				return null;
			}
			return list;
		}

		/// <summary>
		/// Gets or sets the value of the 'id' HTML attribute. The document must have been parsed using the OptionUseIdAttribute set to true.
		/// </summary>
		public string Id
		{
			get
			{
				if (_ownerdocument._nodesid == null)
				{
					throw new Exception(HtmlDocument.HtmlExceptionUseIdAttributeFalse);
				}
				return GetId();
			}
			set
			{
				if (_ownerdocument._nodesid == null)
				{
					throw new Exception(HtmlDocument.HtmlExceptionUseIdAttributeFalse);
				}
				
				if (value == null)
				{
					throw new ArgumentNullException("value");
				}
				SetId(value);
			}
		}

		/// <summary>
		/// Gets the line number of this node in the document.
		/// </summary>
		public int Line
		{
			get
			{
				return _line;
			}
		}

		/// <summary>
		/// Gets the column number of this node in the document.
		/// </summary>
		public int LinePosition
		{
			get
			{
				return _lineposition;
			}
		}

		/// <summary>
		/// Gets the stream position of this node in the document, relative to the start of the document.
		/// </summary>
		public int StreamPosition
		{
			get
			{
				return _streamposition;
			}
		}

		/// <summary>
		/// Gets a value indicating if this node has been closed or not.
		/// </summary>
		public bool Closed
		{
			get
			{
				return (_endnode != null);
			}
		}

		/// <summary>
		/// Gets or sets this node's name.
		/// </summary>
		public string Name
		{
			get
			{
				if (_name == null)
				{
					_name = _ownerdocument._text.Substring(_namestartindex, _namelength).ToLower();
				}
				return _name;
			}
			set
			{
				_name = value;
			}
		}

		/// <summary>
		/// Gets or Sets the text between the start and end tags of the object.
		/// </summary>
		public virtual string InnerText
		{
			get
			{
				if (_nodetype == HtmlNodeType.Text)
				{
					return ((HtmlTextNode)this).Text;
				}

				if (_nodetype == HtmlNodeType.Comment)
				{
					return ((HtmlCommentNode)this).Comment;
				}

				// note: right now, this method is *slow*, because we recompute everything.
				// it could be optimised like innerhtml
				if (!HasChildNodes)
				{
					return string.Empty;
				}

				string s = null;
				foreach(HtmlNode node in ChildNodes)
				{
					s += node.InnerText;
				}
				return s;
			}
		}

		/// <summary>
		/// Gets or Sets the HTML between the start and end tags of the object.
		/// </summary>
		public virtual string InnerHtml
		{
			get
			{
				if (_innerchanged)
				{
					_innerhtml = WriteContentTo();
					_innerchanged = false;
					return _innerhtml;
				}
				if (_innerhtml != null)
				{
					return _innerhtml;
				}

				if (_innerstartindex < 0)
				{
					return string.Empty;
				}

				return _ownerdocument._text.Substring(_innerstartindex, _innerlength);
			}
			set
			{
				HtmlDocument doc = new HtmlDocument();
				doc.LoadHtml(value);

				RemoveAllChildren();
				AppendChildren(doc.DocumentNode.ChildNodes);
			}
		}

		/// <summary>
		/// Gets or Sets the object and its content in HTML.
		/// </summary>
		public virtual string OuterHtml
		{
			get
			{
				if (_outerchanged)
				{
					_outerhtml = WriteTo();
					_outerchanged = false;
					return _outerhtml;
				}

				if (_outerhtml != null)
				{
					return _outerhtml;
				}

				if (_outerstartindex < 0)
				{
					return string.Empty;
				}

				return _ownerdocument._text.Substring(_outerstartindex, _outerlength);
			}
		}

		/// <summary>
		/// Creates a duplicate of the node
		/// </summary>
		/// <returns></returns>
		public HtmlNode Clone()
		{
			return CloneNode(true);
		}

		/// <summary>
		/// Creates a duplicate of the node and changes its name at the same time.
		/// </summary>
		/// <param name="newName">The new name of the cloned node. May not be null.</param>
		/// <returns>The cloned node.</returns>
		public HtmlNode CloneNode(string newName)
		{
			return CloneNode(newName, true);
		}

		/// <summary>
		/// Creates a duplicate of the node and changes its name at the same time.
		/// </summary>
		/// <param name="newName">The new name of the cloned node. May not be null.</param>
		/// <param name="deep">true to recursively clone the subtree under the specified node; false to clone only the node itself.</param>
		/// <returns>The cloned node.</returns>
		public HtmlNode CloneNode(string newName, bool deep)
		{
			if (newName == null)
			{
				throw new ArgumentNullException("newName");
			}

			HtmlNode node = CloneNode(deep);
			node._name = newName;
			return node;
		}

		/// <summary>
		/// Creates a duplicate of the node.
		/// </summary>
		/// <param name="deep">true to recursively clone the subtree under the specified node; false to clone only the node itself.</param>
		/// <returns>The cloned node.</returns>
		public HtmlNode CloneNode(bool deep)
		{
			HtmlNode node = _ownerdocument.CreateNode(_nodetype);
			node._name = Name;

			switch(_nodetype)
			{
				case HtmlNodeType.Comment:
					((HtmlCommentNode)node).Comment = ((HtmlCommentNode)this).Comment;
					return node;
		
				case HtmlNodeType.Text:
					((HtmlTextNode)node).Text = ((HtmlTextNode)this).Text;
					return node;
			}

			// attributes
			if (HasAttributes)
			{
				foreach(HtmlAttribute att in _attributes)
				{
					HtmlAttribute newatt = att.Clone();
					node.Attributes.Append(newatt);
				}
			}

			// closing attributes
			if (HasClosingAttributes)
			{
				node._endnode = _endnode.CloneNode(false);
				foreach(HtmlAttribute att in _endnode._attributes)
				{
					HtmlAttribute newatt = att.Clone();
					node._endnode._attributes.Append(newatt);
				}
			}
			if (!deep)
			{
				return node;
			}

			if (!HasChildNodes)
			{
				return node;
			}

			// child nodes
			foreach(HtmlNode child in _childnodes)
			{
				HtmlNode newchild = child.Clone();
				node.AppendChild(newchild);
			}
			return node;
		}

		/// <summary>
		/// Gets the HTML node immediately following this element.
		/// </summary>
		public HtmlNode NextSibling
		{
			get
			{
				return _nextnode;
			}
		}

		/// <summary>
		/// Gets the node immediately preceding this node.
		/// </summary>
		public HtmlNode PreviousSibling
		{
			get
			{
				return _prevnode;
			}
		}

		/// <summary>
		/// Removes all the children and/or attributes of the current node.
		/// </summary>
		public void RemoveAll()
		{
			RemoveAllChildren();

			if (HasAttributes)
			{
				_attributes.Clear();
			}

			if ((_endnode != null) && (_endnode != this))
			{
				if (_endnode._attributes != null)
				{
					_endnode._attributes.Clear();
				}
			}
			_outerchanged = true;
			_innerchanged = true;
		}

		/// <summary>
		/// Removes all the children of the current node.
		/// </summary>
		public void RemoveAllChildren()
		{
			if (!HasChildNodes)
			{
				return;
			}

			if (_ownerdocument.OptionUseIdAttribute)
			{
				// remove nodes from id list
				foreach(HtmlNode node in _childnodes)
				{
					_ownerdocument.SetIdForNode(null, node.GetId());
				}
			}
			_childnodes.Clear();
			_outerchanged = true;
			_innerchanged = true;
		}

		/// <summary>
		/// Removes the specified child node.
		/// </summary>
		/// <param name="oldChild">The node being removed. May not be null.</param>
		/// <returns>The node removed.</returns>
		public HtmlNode RemoveChild(HtmlNode oldChild)
		{
			if (oldChild == null)
			{
				throw new ArgumentNullException("oldChild");
			}

			int index = -1;

			if (_childnodes != null)
			{
				index = _childnodes[oldChild];
			}

			if (index == -1)
			{
				throw new ArgumentException(HtmlDocument.HtmlExceptionRefNotChild);
			}

			_childnodes.Remove(index);

			_ownerdocument.SetIdForNode(null, oldChild.GetId());
			_outerchanged = true;
			_innerchanged = true;
			return oldChild;
		}

		/// <summary>
		/// Removes the specified child node.
		/// </summary>
		/// <param name="oldChild">The node being removed. May not be null.</param>
		/// <param name="keepGrandChildren">true to keep grand children of the node, false otherwise.</param>
		/// <returns>The node removed.</returns>
		public HtmlNode RemoveChild(HtmlNode oldChild, bool keepGrandChildren)
		{
			if (oldChild == null)
			{
				throw new ArgumentNullException("oldChild");
			}

			if ((oldChild._childnodes != null) && keepGrandChildren)
			{
				// get prev sibling
				HtmlNode prev = oldChild.PreviousSibling;

				// reroute grand children to ourselves
				foreach(HtmlNode grandchild in oldChild._childnodes)
				{
					InsertAfter(grandchild, prev);
				}
			}
			RemoveChild(oldChild);
			_outerchanged = true;
			_innerchanged = true;
			return oldChild;
		}

		/// <summary>
		/// Replaces the child node oldChild with newChild node.
		/// </summary>
		/// <param name="newChild">The new node to put in the child list.</param>
		/// <param name="oldChild">The node being replaced in the list.</param>
		/// <returns>The node replaced.</returns>
		public HtmlNode ReplaceChild(HtmlNode newChild, HtmlNode oldChild)
		{
			if (newChild == null)
			{
				return RemoveChild(oldChild);
			}

			if (oldChild == null)
			{
				return AppendChild(newChild);
			}

			int index = -1;

			if (_childnodes != null)
			{
				index = _childnodes[oldChild];
			}

			if (index == -1)
			{
				throw new ArgumentException(HtmlDocument.HtmlExceptionRefNotChild);
			}

			_childnodes.Replace(index, newChild);

			_ownerdocument.SetIdForNode(null, oldChild.GetId());
			_ownerdocument.SetIdForNode(newChild, newChild.GetId());
			_outerchanged = true;
			_innerchanged = true;
			return newChild;
		}

		/// <summary>
		/// Inserts the specified node immediately before the specified reference node.
		/// </summary>
		/// <param name="newChild">The node to insert. May not be null.</param>
		/// <param name="refChild">The node that is the reference node. The newChild is placed before this node.</param>
		/// <returns>The node being inserted.</returns>
		public HtmlNode InsertBefore(HtmlNode newChild, HtmlNode refChild)
		{
			if (newChild == null)
			{
				throw new ArgumentNullException("newChild");
			}

			if (refChild == null)
			{
				return AppendChild(newChild);
			}

			if (newChild == refChild)
			{
				return newChild;
			}

			int index = -1;

			if (_childnodes != null)
			{
				index = _childnodes[refChild];
			}

			if (index == -1)
			{
				throw new ArgumentException(HtmlDocument.HtmlExceptionRefNotChild);
			}

			_childnodes.Insert(index, newChild);

			_ownerdocument.SetIdForNode(newChild, newChild.GetId());
			_outerchanged = true;
			_innerchanged = true;
			return newChild;
		}

		/// <summary>
		/// Inserts the specified node immediately after the specified reference node.
		/// </summary>
		/// <param name="newChild">The node to insert. May not be null.</param>
		/// <param name="refChild">The node that is the reference node. The newNode is placed after the refNode.</param>
		/// <returns>The node being inserted.</returns>
		public HtmlNode InsertAfter(HtmlNode newChild, HtmlNode refChild)
		{
			if (newChild == null)
			{
				throw new ArgumentNullException("newChild");
			}

			if (refChild == null)
			{
				return PrependChild(newChild);
			}

			if (newChild == refChild)
			{
				return newChild;
			}

			int index = -1;

			if (_childnodes != null)
			{
				index = _childnodes[refChild];
			}
			if (index == -1)
			{
				throw new ArgumentException(HtmlDocument.HtmlExceptionRefNotChild);
			}

			_childnodes.Insert(index + 1, newChild);

			_ownerdocument.SetIdForNode(newChild, newChild.GetId());
			_outerchanged = true;
			_innerchanged = true;
			return newChild;
		}

		/// <summary>
		/// Gets the first child of the node.
		/// </summary>
		public HtmlNode FirstChild
		{
			get
			{
				if (!HasChildNodes)
				{
					return null;
				}
				return _childnodes[0];
			}
		}

		/// <summary>
		/// Gets the last child of the node.
		/// </summary>
		public HtmlNode LastChild
		{
			get
			{
				if (!HasChildNodes)
				{
					return null;
				}
				return _childnodes[_childnodes.Count-1];
			}
		}

		/// <summary>
		/// Gets the type of this node.
		/// </summary>
		public HtmlNodeType NodeType
		{
			get
			{
				return _nodetype;
			}
		}

		/// <summary>
		/// Gets the parent of this node (for nodes that can have parents).
		/// </summary>
		public HtmlNode ParentNode
		{
			get
			{
				return _parentnode;
			}
		}

		/// <summary>
		/// Gets the HtmlDocument to which this node belongs.
		/// </summary>
		public HtmlDocument OwnerDocument
		{
			get
			{
				return _ownerdocument;
			}
		}

		/// <summary>
		/// Gets all the children of the node.
		/// </summary>
		public HtmlNodeCollection ChildNodes
		{
			get
			{
				if (_childnodes == null)
				{
					_childnodes = new HtmlNodeCollection(this);
				}
				return _childnodes;
			}
		}

		/// <summary>
		/// Adds the specified node to the beginning of the list of children of this node.
		/// </summary>
		/// <param name="newChild">The node to add. May not be null.</param>
		/// <returns>The node added.</returns>
		public HtmlNode PrependChild(HtmlNode newChild)
		{
			if (newChild == null)
			{
				throw new ArgumentNullException("newChild");
			}
			ChildNodes.Prepend(newChild);
			_ownerdocument.SetIdForNode(newChild, newChild.GetId());
			_outerchanged = true;
			_innerchanged = true;
			return newChild;
		}

		/// <summary>
		/// Adds the specified node list to the beginning of the list of children of this node.
		/// </summary>
		/// <param name="newChildren">The node list to add. May not be null.</param>
		public void PrependChildren(HtmlNodeCollection newChildren)
		{
			if (newChildren == null)
			{
				throw new ArgumentNullException("newChildren");
			}

			foreach(HtmlNode newChild in newChildren)
			{
				PrependChild(newChild);
			}
		}

		/// <summary>
		/// Adds the specified node to the end of the list of children of this node.
		/// </summary>
		/// <param name="newChild">The node to add. May not be null.</param>
		/// <returns>The node added.</returns>
		public HtmlNode AppendChild(HtmlNode newChild)
		{
			if (newChild == null)
			{
				throw new ArgumentNullException("newChild");
			}

			ChildNodes.Append(newChild);
			_ownerdocument.SetIdForNode(newChild, newChild.GetId());
			_outerchanged = true;
			_innerchanged = true;
			return newChild;
		}

		/// <summary>
		/// Adds the specified node to the end of the list of children of this node.
		/// </summary>
		/// <param name="newChildren">The node list to add. May not be null.</param>
		public void AppendChildren(HtmlNodeCollection newChildren)
		{
			if (newChildren == null)
				throw new ArgumentNullException("newChildrend");

			foreach(HtmlNode newChild in newChildren)
			{
				AppendChild(newChild);
			}
		}

		/// <summary>
		/// Gets a value indicating whether the current node has any attributes.
		/// </summary>
		public bool HasAttributes
		{
			get
			{
				if (_attributes == null)
				{
					return false;
				}

				if (_attributes.Count <= 0)
				{
					return false;
				}
				return true;
			}
		}

		/// <summary>
		/// Gets a value indicating whether the current node has any attributes on the closing tag.
		/// </summary>
		public bool HasClosingAttributes
		{
			get
			{
				if ((_endnode == null) || (_endnode == this))
				{
					return false;
				}

				if (_endnode._attributes == null)
				{
					return false;
				}

				if (_endnode._attributes.Count <= 0)
				{
					return false;
				}
				return true;
			}
		}

		/// <summary>
		/// Gets a value indicating whether this node has any child nodes.
		/// </summary>
		public bool HasChildNodes
		{
			get
			{
				if (_childnodes == null)
				{
					return false;
				}

				if (_childnodes.Count <= 0)
				{
					return false;
				}
				return true;
			}
		}

		/// <summary>
		/// Helper method to get the value of an attribute of this node. If the attribute is not found, the default value will be returned.
		/// </summary>
		/// <param name="name">The name of the attribute to get. May not be null.</param>
		/// <param name="def">The default value to return if not found.</param>
		/// <returns>The value of the attribute if found, the default value if not found.</returns>
		public string GetAttributeValue(string name, string def)
		{
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}

			if (!HasAttributes)
			{
				return def;
			}
			HtmlAttribute att = Attributes[name];
			if (att == null)
			{
				return def;
			}
			return att.Value;
		}

		/// <summary>
		/// Helper method to get the value of an attribute of this node. If the attribute is not found, the default value will be returned.
		/// </summary>
		/// <param name="name">The name of the attribute to get. May not be null.</param>
		/// <param name="def">The default value to return if not found.</param>
		/// <returns>The value of the attribute if found, the default value if not found.</returns>
		public int GetAttributeValue(string name, int def)
		{
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}

			if (!HasAttributes)
			{
				return def;
			}
			HtmlAttribute att = Attributes[name];
			if (att == null)
			{
				return def;
			}
			try
			{
				return Convert.ToInt32(att.Value);
			}
			catch
			{
				return def;
			}
		}

		/// <summary>
		/// Helper method to get the value of an attribute of this node. If the attribute is not found, the default value will be returned.
		/// </summary>
		/// <param name="name">The name of the attribute to get. May not be null.</param>
		/// <param name="def">The default value to return if not found.</param>
		/// <returns>The value of the attribute if found, the default value if not found.</returns>
		public bool GetAttributeValue(string name, bool def)
		{
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}

			if (!HasAttributes)
			{
				return def;
			}
			HtmlAttribute att = Attributes[name];
			if (att == null)
			{
				return def;
			}
			try
			{
				return Convert.ToBoolean(att.Value);
			}
			catch
			{
				return def;
			}
		}

		/// <summary>
		/// Helper method to set the value of an attribute of this node. If the attribute is not found, it will be created automatically.
		/// </summary>
		/// <param name="name">The name of the attribute to set. May not be null.</param>
		/// <param name="value">The value for the attribute.</param>
		/// <returns>The corresponding attribute instance.</returns>
		public HtmlAttribute SetAttributeValue(string name, string value)
		{
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			HtmlAttribute att = Attributes[name];
			if (att == null)
			{
				return Attributes.Append(_ownerdocument.CreateAttribute(name, value));
			}
			att.Value = value;
			return att;
		}

		/// <summary>
		/// Gets the collection of HTML attributes for this node. May not be null.
		/// </summary>
		public HtmlAttributeCollection Attributes
		{
			get
			{
				if (!HasAttributes)
				{
					_attributes = new HtmlAttributeCollection(this);
				}
				return _attributes;
			}
		}

		/// <summary>
		/// Gets the collection of HTML attributes for the closing tag. May not be null.
		/// </summary>
		public HtmlAttributeCollection ClosingAttributes
		{
			get
			{
				if (!HasClosingAttributes)
				{
					return new HtmlAttributeCollection(this);
				}
				return _endnode.Attributes;
			}
		}

		internal void WriteAttribute(TextWriter outText, HtmlAttribute att)
		{
			string name;

			if (_ownerdocument.OptionOutputAsXml)
			{
				if (_ownerdocument.OptionOutputUpperCase)
				{
					name = att.XmlName.ToUpper();
				}
				else
				{
					name = att.XmlName;
				}

				outText.Write(" " + name + "=\"" + HtmlDocument.HtmlEncode(att.XmlValue) + "\"");
			}
			else
			{
				if (_ownerdocument.OptionOutputUpperCase)
				{
					name = att.Name.ToUpper();
				}
				else
				{
					name = att.Name;
				}

				if (att.Name.Length >= 4)
				{
					if ((att.Name[0] == '<') && (att.Name[1] == '%') &&
						(att.Name[att.Name.Length-1] == '>') && (att.Name[att.Name.Length-2] == '%'))
					{
						outText.Write(" " + name);
						return;
					}
				}
				if (_ownerdocument.OptionOutputOptimizeAttributeValues)
				{
					if (att.Value.IndexOfAny(new Char[]{(char)10, (char)13, (char)9, ' '}) < 0)
					{
						outText.Write(" " + name + "=" + att.Value);
					}
					else
					{
						outText.Write(" " + name + "=\"" + att.Value + "\"");
					}
				}
				else
				{
					outText.Write(" " + name + "=\"" + att.Value + "\"");
				}
			}
		}

		internal static void WriteAttributes(XmlWriter writer, HtmlNode node)
		{
			if (!node.HasAttributes)
			{
				return;
			}
			// we use _hashitems to make sure attributes are written only once
			foreach(HtmlAttribute att in node.Attributes._hashitems.Values)
			{
				writer.WriteAttributeString(att.XmlName, att.Value);
			}
		}

		internal void WriteAttributes(TextWriter outText, bool closing)
		{
			if (_ownerdocument.OptionOutputAsXml)
			{
				if (_attributes == null)
				{
					return;
				}
				// we use _hashitems to make sure attributes are written only once
				foreach(HtmlAttribute att in _attributes._hashitems.Values)
				{
					WriteAttribute(outText, att);
				}
				return;
			}

			if (!closing)
			{
				if (_attributes != null)
				{

					foreach(HtmlAttribute att in _attributes)
					{
						WriteAttribute(outText, att);
					}
				}
				if (_ownerdocument.OptionAddDebuggingAttributes)
				{
					WriteAttribute(outText, _ownerdocument.CreateAttribute("_closed", Closed.ToString()));
					WriteAttribute(outText, _ownerdocument.CreateAttribute("_children", ChildNodes.Count.ToString()));

					int i = 0;
					foreach(HtmlNode n in ChildNodes)
					{
						WriteAttribute(outText, _ownerdocument.CreateAttribute("_child_" + i,
							n.Name));
						i++;
					}
				}
			}
			else
			{
				if (_endnode == null)
				{
					return;
				}

				if (_endnode._attributes == null)
				{
					return;
				}

				if (_endnode == this)
				{
					return;
				}

				foreach(HtmlAttribute att in _endnode._attributes)
				{
					WriteAttribute(outText, att);
				}
				if (_ownerdocument.OptionAddDebuggingAttributes)
				{
					WriteAttribute(outText, _ownerdocument.CreateAttribute("_closed", Closed.ToString()));
					WriteAttribute(outText, _ownerdocument.CreateAttribute("_children", ChildNodes.Count.ToString()));
				}
			}
		}

		internal static string GetXmlComment(HtmlCommentNode comment)
		{
			string s = comment.Comment;
			return s.Substring(4, s.Length-7).Replace("--", " - -");
		}

		/// <summary>
		/// Saves the current node to the specified TextWriter.
		/// </summary>
		/// <param name="outText">The TextWriter to which you want to save.</param>
		public void WriteTo(TextWriter outText)
		{
			string html;
			switch(_nodetype)
			{
				case HtmlNodeType.Comment:
					html = ((HtmlCommentNode)this).Comment;
					if (_ownerdocument.OptionOutputAsXml)
					{
						outText.Write("<!--" + GetXmlComment((HtmlCommentNode)this) + " -->");
					}
					else
					{
						outText.Write(html);
					}
					break;

				case HtmlNodeType.Document:
					if (_ownerdocument.OptionOutputAsXml)
					{
						outText.Write("<?xml version=\"1.0\" encoding=\"" + _ownerdocument.GetOutEncoding().BodyName + "\"?>");

						// check there is a root element
						if (_ownerdocument.DocumentNode.HasChildNodes)
						{
							int rootnodes = _ownerdocument.DocumentNode._childnodes.Count;
							if (rootnodes > 0)
							{
								HtmlNode xml = _ownerdocument.GetXmlDeclaration();
								if (xml != null)
								{
									rootnodes --;
								}

								if (rootnodes > 1)
								{
									if (_ownerdocument.OptionOutputUpperCase)
									{
										outText.Write("<SPAN>");
										WriteContentTo(outText);
										outText.Write("</SPAN>");
									}
									else
									{
										outText.Write("<span>");
										WriteContentTo(outText);
										outText.Write("</span>");
									}
									break;
								}
							}
						}
					}
					WriteContentTo(outText);
					break;

				case HtmlNodeType.Text:
					html = ((HtmlTextNode)this).Text;
					if (_ownerdocument.OptionOutputAsXml)
					{
						outText.Write(HtmlDocument.HtmlEncode(html));
					}
					else
					{
						outText.Write(html);
					}
					break;

				case HtmlNodeType.Element:
					string name;
					if (_ownerdocument.OptionOutputUpperCase)
					{
						name = Name.ToUpper();
					}
					else
					{
						name = Name;
					}

					if (_ownerdocument.OptionOutputAsXml)
					{
						if (name.Length > 0)
						{
							if (name[0] == '?')
							{
								// forget this one, it's been done at the document level
								break;
							}

							if (name.Trim().Length == 0)
							{
								break;
							}
							name = HtmlDocument.GetXmlName(name);
						}
						else
						{
							break;
						}
					}

					outText.Write("<" + name);
					WriteAttributes(outText, false);

					if (!HasChildNodes)
					{
						if (HtmlNode.IsEmptyElement(Name))
						{
							if ((_ownerdocument.OptionWriteEmptyNodes) || (_ownerdocument.OptionOutputAsXml))
							{
								outText.Write(" />");
							}
							else
							{
								if (Name.Length > 0)
								{
									if (Name[0] == '?')
									{
										outText.Write("?");
									}
								}

								outText.Write(">");
							}
						}
						else
						{
							outText.Write("></" + name + ">");
						}
					}
					else
					{
						outText.Write(">");
						bool cdata = false;
						if (_ownerdocument.OptionOutputAsXml)
						{
							if (HtmlNode.IsCDataElement(Name))
							{
								// this code and the following tries to output things as nicely as possible for old browsers.
								cdata = true;
								outText.Write("\r\n//<![CDATA[\r\n");
							}
						}

						if (cdata)
						{
							if (HasChildNodes)
							{
								// child must be a text
								ChildNodes[0].WriteTo(outText);
							}
							outText.Write("\r\n//]]>//\r\n");
						}
						else
						{
							WriteContentTo(outText);
						}

						outText.Write("</" + name);
						if (!_ownerdocument.OptionOutputAsXml)
						{
							WriteAttributes(outText, true);
						}
						outText.Write(">");
					}
					break;
			}
		}

		/// <summary>
		/// Saves the current node to the specified XmlWriter.
		/// </summary>
		/// <param name="writer">The XmlWriter to which you want to save.</param>
		public void WriteTo(XmlWriter writer)
		{
			string html;
			switch(_nodetype)
			{
				case HtmlNodeType.Comment:
					writer.WriteComment(GetXmlComment((HtmlCommentNode)this));
					break;

				case HtmlNodeType.Document:
					writer.WriteProcessingInstruction("xml", "version=\"1.0\" encoding=\"" + _ownerdocument.GetOutEncoding().BodyName + "\"");
					if (HasChildNodes)
					{
						foreach(HtmlNode subnode in ChildNodes)
						{
							subnode.WriteTo(writer);
						}
					}
					break;

				case HtmlNodeType.Text:
					html = ((HtmlTextNode)this).Text;
					writer.WriteString(html);
					break;

				case HtmlNodeType.Element:
					string name;
					if (_ownerdocument.OptionOutputUpperCase)
					{
						name = Name.ToUpper();
					}
					else
					{
						name = Name;
					}
					writer.WriteStartElement(name);
					WriteAttributes(writer, this);

					if (HasChildNodes)
					{
						foreach(HtmlNode subnode in ChildNodes)
						{
							subnode.WriteTo(writer);
						}
					}
					writer.WriteEndElement();
					break;
			}
		}

		/// <summary>
		/// Saves all the children of the node to the specified TextWriter.
		/// </summary>
		/// <param name="outText">The TextWriter to which you want to save.</param>
		public void WriteContentTo(TextWriter outText)
		{
			if (_childnodes == null)
			{
				return;
			}

			foreach(HtmlNode node in _childnodes)
			{
				node.WriteTo(outText);
			}
		}

		/// <summary>
		/// Saves the current node to a string.
		/// </summary>
		/// <returns>The saved string.</returns>
		public string WriteTo()
		{
			StringWriter sw = new StringWriter();
			WriteTo(sw);
			sw.Flush();
			return sw.ToString();
		}

		/// <summary>
		/// Saves all the children of the node to a string.
		/// </summary>
		/// <returns>The saved string.</returns>
		public string WriteContentTo()
		{
			StringWriter sw = new StringWriter();
			WriteContentTo(sw);
			sw.Flush();
			return sw.ToString();
		}
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HtmlAgilityPack\HtmlAgilityPack\HtmlNodeNavigator.cs ===
// HtmlAgilityPack V1.0 - Simon Mourier <simon underscore mourier at hotmail dot com>
using System;
using System.Diagnostics;
using System.Collections.Specialized;
using System.IO;
using System.Text;
using System.Xml;
using System.Xml.XPath;

namespace Test.Common.Library.HtmlAgilityPack
{
	/// <summary>
	/// Represents an HTML navigator on an HTML document seen as a data store.
	/// </summary>
    public class HtmlNodeNavigator : XPathNavigator, IXPathNavigable
	{
		private HtmlDocument _doc = new HtmlDocument();
		private HtmlNode _currentnode;
		private int _attindex;
		private HtmlNameTable _nametable = new HtmlNameTable();

		internal bool Trace = false;

		internal HtmlNodeNavigator()
		{
			Reset();
		}

		private void Reset()
		{
			InternalTrace(null);
			_currentnode = _doc.DocumentNode;
			_attindex = -1;
		}

		[Conditional("TRACE")]
		internal void InternalTrace(object Value)
		{
			if (!Trace)
			{
				return;
			}
			string name = null;
			StackFrame sf = new StackFrame(1, true);
			name = sf.GetMethod().Name;
			string nodename;
			if (_currentnode == null)
			{
				nodename = "(null)";
			}
			else
			{
				nodename = _currentnode.Name;
			}
			string nodevalue;
			if (_currentnode == null)
			{
				nodevalue = "(null)";
			}
			else
			{
				switch(_currentnode.NodeType)
				{
					case HtmlNodeType.Comment:
						nodevalue = ((HtmlCommentNode)_currentnode).Comment;
						break;

					case HtmlNodeType.Document:
						nodevalue = "";
						break;

					case HtmlNodeType.Text:
						nodevalue = ((HtmlTextNode)_currentnode).Text;
						break;

					default:
						nodevalue = _currentnode.CloneNode(false).OuterHtml;
						break;

				}
			}
			System.Diagnostics.Trace.WriteLine("oid=" + GetHashCode()
				+ ",n=" + nodename
				+ ",a=" + _attindex + ","
				+ ",v=" + nodevalue + ","
				+ Value, "N!"+ name);
		}

		internal HtmlNodeNavigator(HtmlDocument doc, HtmlNode currentNode)
		{
			if (currentNode == null)
			{
				throw new ArgumentNullException("currentNode");
			}
			if (currentNode.OwnerDocument != doc)
			{
				throw new ArgumentException(HtmlDocument.HtmlExceptionRefNotChild);
			}
			InternalTrace(null);

			_doc = doc;
			Reset();
			_currentnode = currentNode;
		}

		private HtmlNodeNavigator(HtmlNodeNavigator nav)
		{
			if (nav == null)
			{
				throw new ArgumentNullException("nav");
			}
			InternalTrace(null);
			
			_doc = nav._doc;
			_currentnode = nav._currentnode;
			_attindex = nav._attindex;
			_nametable = nav._nametable; // REVIEW: should we do this?
		}

		/// <summary>
		/// Initializes a new instance of the HtmlNavigator and loads an HTML document from a stream.
		/// </summary>
		/// <param name="stream">The input stream.</param>
		public HtmlNodeNavigator(Stream stream)
		{
			_doc.Load(stream);
			Reset();
		}

		/// <summary>
		/// Initializes a new instance of the HtmlNavigator and loads an HTML document from a stream.
		/// </summary>
		/// <param name="stream">The input stream.</param>
		/// <param name="detectEncodingFromByteOrderMarks">Indicates whether to look for byte order marks at the beginning of the stream.</param>
		public HtmlNodeNavigator(Stream stream, bool detectEncodingFromByteOrderMarks)
		{
			_doc.Load(stream, detectEncodingFromByteOrderMarks);
			Reset();
		}

		/// <summary>
		/// Initializes a new instance of the HtmlNavigator and loads an HTML document from a stream.
		/// </summary>
		/// <param name="stream">The input stream.</param>
		/// <param name="encoding">The character encoding to use.</param>
		public HtmlNodeNavigator(Stream stream, Encoding encoding)
		{
			_doc.Load(stream, encoding);
			Reset();
		}

		/// <summary>
		/// Initializes a new instance of the HtmlNavigator and loads an HTML document from a stream.
		/// </summary>
		/// <param name="stream">The input stream.</param>
		/// <param name="encoding">The character encoding to use.</param>
		/// <param name="detectEncodingFromByteOrderMarks">Indicates whether to look for byte order marks at the beginning of the stream.</param>
		public HtmlNodeNavigator(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks)
		{
			_doc.Load(stream, encoding, detectEncodingFromByteOrderMarks);
			Reset();
		}

		/// <summary>
		/// Initializes a new instance of the HtmlNavigator and loads an HTML document from a stream.
		/// </summary>
		/// <param name="stream">The input stream.</param>
		/// <param name="encoding">The character encoding to use.</param>
		/// <param name="detectEncodingFromByteOrderMarks">Indicates whether to look for byte order marks at the beginning of the stream.</param>
		/// <param name="buffersize">The minimum buffer size.</param>
		public HtmlNodeNavigator(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks, int buffersize)
		{
			_doc.Load(stream, encoding, detectEncodingFromByteOrderMarks, buffersize);
			Reset();
		}

		/// <summary>
		/// Initializes a new instance of the HtmlNavigator and loads an HTML document from a TextReader.
		/// </summary>
		/// <param name="reader">The TextReader used to feed the HTML data into the document.</param>
		public HtmlNodeNavigator(TextReader reader)
		{
			_doc.Load(reader);
			Reset();
		}

		/// <summary>
		/// Initializes a new instance of the HtmlNavigator and loads an HTML document from a file.
		/// </summary>
		/// <param name="path">The complete file path to be read.</param>
		public HtmlNodeNavigator(string path)
		{
			_doc.Load(path);
			Reset();
		}

		/// <summary>
		/// Initializes a new instance of the HtmlNavigator and loads an HTML document from a file.
		/// </summary>
		/// <param name="path">The complete file path to be read.</param>
		/// <param name="detectEncodingFromByteOrderMarks">Indicates whether to look for byte order marks at the beginning of the file.</param>
		public HtmlNodeNavigator(string path, bool detectEncodingFromByteOrderMarks)
		{
			_doc.Load(path, detectEncodingFromByteOrderMarks);
			Reset();
		}

		/// <summary>
		/// Initializes a new instance of the HtmlNavigator and loads an HTML document from a file.
		/// </summary>
		/// <param name="path">The complete file path to be read.</param>
		/// <param name="encoding">The character encoding to use.</param>
		public HtmlNodeNavigator(string path, Encoding encoding)
		{
			_doc.Load(path, encoding);
			Reset();
		}

		/// <summary>
		/// Initializes a new instance of the HtmlNavigator and loads an HTML document from a file.
		/// </summary>
		/// <param name="path">The complete file path to be read.</param>
		/// <param name="encoding">The character encoding to use.</param>
		/// <param name="detectEncodingFromByteOrderMarks">Indicates whether to look for byte order marks at the beginning of the file.</param>
		public HtmlNodeNavigator(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks)
		{
			_doc.Load(path, encoding, detectEncodingFromByteOrderMarks);
			Reset();
		}

		/// <summary>
		/// Initializes a new instance of the HtmlNavigator and loads an HTML document from a file.
		/// </summary>
		/// <param name="path">The complete file path to be read.</param>
		/// <param name="encoding">The character encoding to use.</param>
		/// <param name="detectEncodingFromByteOrderMarks">Indicates whether to look for byte order marks at the beginning of the file.</param>
		/// <param name="buffersize">The minimum buffer size.</param>
		public HtmlNodeNavigator(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks, int buffersize)
		{
			_doc.Load(path, encoding, detectEncodingFromByteOrderMarks, buffersize);
			Reset();
		}

		/// <summary>
		/// Gets the name of the current HTML node without the namespace prefix.
		/// </summary>
		public override string LocalName
		{
			get
			{
				if (_attindex != -1)
				{
					InternalTrace("att>" + _currentnode.Attributes[_attindex].Name);
					return _nametable.GetOrAdd(_currentnode.Attributes[_attindex].Name);
				}
				else
				{
					InternalTrace("node>" + _currentnode.Name);
					return _nametable.GetOrAdd(_currentnode.Name);
				}
			} 
		}

		/// <summary>
		/// Gets the namespace URI (as defined in the W3C Namespace Specification) of the current node.
		/// Always returns string.Empty in the case of HtmlNavigator implementation.
		/// </summary>
		public override string NamespaceURI
		{
			get
			{
				InternalTrace(">");
				return _nametable.GetOrAdd(string.Empty);
			} 
		}

		/// <summary>
		/// Gets the qualified name of the current node.
		/// </summary>
		public override string Name
		{
			get
			{
				InternalTrace(">" + _currentnode.Name);
				return _nametable.GetOrAdd(_currentnode.Name);
			} 
		}

		/// <summary>
		/// Gets the prefix associated with the current node.
		/// Always returns string.Empty in the case of HtmlNavigator implementation.
		/// </summary>
		public override string Prefix
		{
			get
			{
				InternalTrace(null);
				return _nametable.GetOrAdd(string.Empty);
			} 
		}

		/// <summary>
		/// Gets the type of the current node.
		/// </summary>
		public override XPathNodeType NodeType
		{
			get
			{
				switch(_currentnode.NodeType)
				{
					case HtmlNodeType.Comment:
						InternalTrace(">" + XPathNodeType.Comment);
						return XPathNodeType.Comment;

					case HtmlNodeType.Document:
						InternalTrace(">" + XPathNodeType.Root);
						return XPathNodeType.Root;

					case HtmlNodeType.Text:
						InternalTrace(">" + XPathNodeType.Text);
						return XPathNodeType.Text;

					case HtmlNodeType.Element:
					{
						if (_attindex != -1)
						{
							InternalTrace(">" + XPathNodeType.Attribute);
							return XPathNodeType.Attribute;
						}
						InternalTrace(">" + XPathNodeType.Element);
						return XPathNodeType.Element;
					}

					default:
						throw new NotImplementedException("Internal error: Unhandled HtmlNodeType: " + _currentnode.NodeType);
				}
			} 
		}

		/// <summary>
		/// Gets the text value of the current node.
		/// </summary>
		public override string Value
		{
			get
			{
				InternalTrace("nt=" + _currentnode.NodeType);
				switch(_currentnode.NodeType)
				{
					case HtmlNodeType.Comment:
						InternalTrace(">" + ((HtmlCommentNode)_currentnode).Comment);
						return ((HtmlCommentNode)_currentnode).Comment;

					case HtmlNodeType.Document:
						InternalTrace(">");
						return "";

					case HtmlNodeType.Text:
						InternalTrace(">" + ((HtmlTextNode)_currentnode).Text);
						return ((HtmlTextNode)_currentnode).Text;

					case HtmlNodeType.Element:
					{
						if (_attindex != -1)
						{
							InternalTrace(">" + _currentnode.Attributes[_attindex].Value);
							return _currentnode.Attributes[_attindex].Value;
						}
						return _currentnode.InnerText;
					}

					default:
						throw new NotImplementedException("Internal error: Unhandled HtmlNodeType: " + _currentnode.NodeType);
				}
			} 
		}

		/// <summary>
		/// Gets the base URI for the current node.
		/// Always returns string.Empty in the case of HtmlNavigator implementation.
		/// </summary>
		public override string BaseURI
		{
			get
			{
				InternalTrace(">");
				return _nametable.GetOrAdd(string.Empty);
			} 
		}

		/// <summary>
		/// Gets the xml:lang scope for the current node.
		/// Always returns string.Empty in the case of HtmlNavigator implementation.
		/// </summary>
		public override string XmlLang
		{
			get
			{
				InternalTrace(null);
				return _nametable.GetOrAdd(string.Empty);
			} 
		}

		/// <summary>
		/// Gets a value indicating whether the current node is an empty element.
		/// </summary>
		public override bool IsEmptyElement
		{
			get
			{
				InternalTrace(">" + !HasChildren);
				// REVIEW: is this ok?
				return !HasChildren;
			} 
		}

		/// <summary>
		/// Gets the XmlNameTable associated with this implementation.
		/// </summary>
		public override XmlNameTable NameTable
		{
			get
			{
				InternalTrace(null);
				return _nametable;
			} 
		}

		/// <summary>
		/// Gets a value indicating whether the current node has child nodes.
		/// </summary>
		public override bool HasAttributes
		{
			get
			{
				InternalTrace(">" + (_currentnode.Attributes.Count>0));
				return (_currentnode.Attributes.Count>0);
			} 
		}

		/// <summary>
		/// Gets a value indicating whether the current node has child nodes.
		/// </summary>
		public override bool HasChildren
		{
			get
			{
				InternalTrace(">" + (_currentnode.ChildNodes.Count>0));
				return (_currentnode.ChildNodes.Count>0);
			} 
		}

		/// <summary>
		/// Moves to the next sibling of the current node.
		/// </summary>
		/// <returns>true if the navigator is successful moving to the next sibling node, false if there are no more siblings or if the navigator is currently positioned on an attribute node. If false, the position of the navigator is unchanged.</returns>
		public override bool MoveToNext()
		{
			if (_currentnode.NextSibling == null)
			{
				InternalTrace(">false");
				return false;
			}
			InternalTrace("_c=" + _currentnode.CloneNode(false).OuterHtml);
			InternalTrace("_n=" + _currentnode.NextSibling.CloneNode(false).OuterHtml);
			_currentnode = _currentnode.NextSibling;
			InternalTrace(">true");
			return true;
		}

		/// <summary>
		/// Moves to the previous sibling of the current node.
		/// </summary>
		/// <returns>true if the navigator is successful moving to the previous sibling node, false if there is no previous sibling or if the navigator is currently positioned on an attribute node.</returns>
		public override bool MoveToPrevious()
		{
			if (_currentnode.PreviousSibling == null)
			{
				InternalTrace(">false");
				return false;
			}
			_currentnode = _currentnode.PreviousSibling;
			InternalTrace(">true");
			return true;
		}

		/// <summary>
		/// Moves to the first sibling of the current node.
		/// </summary>
		/// <returns>true if the navigator is successful moving to the first sibling node, false if there is no first sibling or if the navigator is currently positioned on an attribute node.</returns>
		public override bool MoveToFirst()
		{
			if (_currentnode.ParentNode == null)
			{
				InternalTrace(">false");
				return false;
			}
			if (_currentnode.ParentNode.FirstChild == null)
			{
				InternalTrace(">false");
				return false;
			}
			_currentnode = _currentnode.ParentNode.FirstChild;
			InternalTrace(">true");
			return true;
		}

		/// <summary>
		/// Moves to the first child of the current node.
		/// </summary>
		/// <returns>true if there is a first child node, otherwise false.</returns>
		public override bool MoveToFirstChild()
		{
			if (!_currentnode.HasChildNodes)
			{
				InternalTrace(">false");
				return false;
			}
			_currentnode = _currentnode.ChildNodes[0];
			InternalTrace(">true");
			return true;
		}

		/// <summary>
		/// Moves to the parent of the current node.
		/// </summary>
		/// <returns>true if there is a parent node, otherwise false.</returns>
		public override bool MoveToParent()
		{
			if (_currentnode.ParentNode == null)
			{
				InternalTrace(">false");
				return false;
			}
			_currentnode = _currentnode.ParentNode;
			InternalTrace(">true");
			return true;
		}

		/// <summary>
		/// Moves to the root node to which the current node belongs.
		/// </summary>
		public override void MoveToRoot()
		{
			_currentnode = _doc.DocumentNode;
			InternalTrace(null);
		}

		/// <summary>
		/// Moves to the same position as the specified HtmlNavigator.
		/// </summary>
		/// <param name="other">The HtmlNavigator positioned on the node that you want to move to.</param>
		/// <returns>true if successful, otherwise false. If false, the position of the navigator is unchanged.</returns>
		public override bool MoveTo(XPathNavigator other)
		{
			HtmlNodeNavigator nav = other as HtmlNodeNavigator;
			if (nav == null)
			{
				InternalTrace(">false (nav is not an HtmlNodeNavigator)");
				return false;
			}
			InternalTrace("moveto oid=" + nav.GetHashCode()
				+ ", n:" + nav._currentnode.Name
				+ ", a:" + nav._attindex);

			if (nav._doc == _doc)
			{
				_currentnode = nav._currentnode;
				_attindex = nav._attindex;
				InternalTrace(">true");
				return true;
			}
			// we don't know how to handle that
			InternalTrace(">false (???)");
			return false;
		}

		/// <summary>
		/// Moves to the node that has an attribute of type ID whose value matches the specified string.
		/// </summary>
		/// <param name="id">A string representing the ID value of the node to which you want to move. This argument does not need to be atomized.</param>
		/// <returns>true if the move was successful, otherwise false. If false, the position of the navigator is unchanged.</returns>
		public override bool MoveToId(string id)
		{
			InternalTrace("id=" + id);
			HtmlNode node = _doc.GetElementbyId(id);
			if (node == null)
			{
				InternalTrace(">false");
				return false;
			}
			_currentnode = node;
			InternalTrace(">true");
			return true;
		}

		/// <summary>
		/// Determines whether the current HtmlNavigator is at the same position as the specified HtmlNavigator.
		/// </summary>
		/// <param name="other">The HtmlNavigator that you want to compare against.</param>
		/// <returns>true if the two navigators have the same position, otherwise, false.</returns>
		public override bool IsSamePosition(XPathNavigator other)
		{
			HtmlNodeNavigator nav = other as HtmlNodeNavigator;
			if (nav == null)
			{
				InternalTrace(">false");
				return false;
			}
			InternalTrace(">" + (nav._currentnode == _currentnode));
			return (nav._currentnode == _currentnode);
		}

		/// <summary>
		/// Creates a new HtmlNavigator positioned at the same node as this HtmlNavigator.
		/// </summary>
		/// <returns>A new HtmlNavigator object positioned at the same node as the original HtmlNavigator.</returns>
		public override XPathNavigator Clone()
		{
			InternalTrace(null);
			return new HtmlNodeNavigator(this);
		}

		/// <summary>
		/// Gets the value of the HTML attribute with the specified LocalName and NamespaceURI.
		/// </summary>
		/// <param name="localName">The local name of the HTML attribute.</param>
		/// <param name="namespaceURI">The namespace URI of the attribute. Unsupported with the HtmlNavigator implementation.</param>
		/// <returns>The value of the specified HTML attribute. String.Empty or null if a matching attribute is not found or if the navigator is not positioned on an element node.</returns>
		public override string GetAttribute(string localName, string namespaceURI)
		{
			InternalTrace("localName=" + localName + ", namespaceURI=" + namespaceURI);
			HtmlAttribute att = _currentnode.Attributes[localName];
			if (att == null)
			{
				InternalTrace(">null");
				return null;
			}
			InternalTrace(">" + att.Value);
			return att.Value;
		}

		/// <summary>
		/// Moves to the HTML attribute with matching LocalName and NamespaceURI.
		/// </summary>
		/// <param name="localName">The local name of the HTML attribute.</param>
		/// <param name="namespaceURI">The namespace URI of the attribute. Unsupported with the HtmlNavigator implementation.</param>
		/// <returns>true if the HTML attribute is found, otherwise, false. If false, the position of the navigator does not change.</returns>
		public override bool MoveToAttribute(string localName, string namespaceURI)
		{
			InternalTrace("localName=" + localName + ", namespaceURI=" + namespaceURI);
			int index = _currentnode.Attributes.GetAttributeIndex(localName);
			if (index == -1)
			{
				InternalTrace(">false");
				return false;
			}
			_attindex = index;
			InternalTrace(">true");
			return true;
		}

		/// <summary>
		/// Moves to the first HTML attribute.
		/// </summary>
		/// <returns>true if the navigator is successful moving to the first HTML attribute, otherwise, false.</returns>
		public override bool MoveToFirstAttribute()
		{
			if (!HasAttributes)
			{
				InternalTrace(">false");
				return false;
			}
			_attindex = 0;
			InternalTrace(">true");
			return true;
		}
	
		/// <summary>
		/// Moves to the next HTML attribute.
		/// </summary>
		/// <returns></returns>
		public override bool MoveToNextAttribute()		
		{
			InternalTrace(null);
			if (_attindex>=(_currentnode.Attributes.Count-1))
			{
				InternalTrace(">false");
				return false;
			}
			_attindex++;
			InternalTrace(">true");
			return true;
		}

		/// <summary>
		/// Returns the value of the namespace node corresponding to the specified local name.
		/// Always returns string.Empty for the HtmlNavigator implementation.
		/// </summary>
		/// <param name="name">The local name of the namespace node.</param>
		/// <returns>Always returns string.Empty for the HtmlNavigator implementation.</returns>
		public override string GetNamespace(string name)		
		{
			InternalTrace("name=" + name);
			return string.Empty;
		}

		/// <summary>
		/// Moves the XPathNavigator to the namespace node with the specified local name. 
		/// Always returns false for the HtmlNavigator implementation.
		/// </summary>
		/// <param name="name">The local name of the namespace node.</param>
		/// <returns>Always returns false for the HtmlNavigator implementation.</returns>
		public override bool MoveToNamespace(string name)		
		{
			InternalTrace("name=" + name);
			return false;
		}

		/// <summary>
		/// Moves the XPathNavigator to the first namespace node of the current element.
		/// Always returns false for the HtmlNavigator implementation.
		/// </summary>
		/// <param name="scope">An XPathNamespaceScope value describing the namespace scope.</param>
		/// <returns>Always returns false for the HtmlNavigator implementation.</returns>
		public override bool MoveToFirstNamespace(XPathNamespaceScope scope)		
		{
			InternalTrace(null);
			return false;
		}

		/// <summary>
		/// Moves the XPathNavigator to the next namespace node.
		/// Always returns falsefor the HtmlNavigator implementation.
		/// </summary>
		/// <param name="scope">An XPathNamespaceScope value describing the namespace scope.</param>
		/// <returns>Always returns false for the HtmlNavigator implementation.</returns>
		public override bool MoveToNextNamespace(XPathNamespaceScope scope)		
		{
			InternalTrace(null);
			return false;
		}

		/// <summary>
		/// Gets the current HTML node.
		/// </summary>
		public HtmlNode CurrentNode
		{
			get
			{
				return _currentnode;
			}
		}

		/// <summary>
		/// Gets the current HTML document.
		/// </summary>
		public HtmlDocument CurrentDocument
		{
			get
			{
				return _doc;
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HtmlAgilityPack\HtmlAgilityPack\HtmlNodeType.cs ===
// HtmlAgilityPack V1.0 - Simon Mourier <simon underscore mourier at hotmail dot com>
using System;

namespace Test.Common.Library.HtmlAgilityPack
{
    /// <summary>
    /// Represents the type of a node.
    /// </summary>
    public enum HtmlNodeType
    {
        /// <summary>
        /// The root of a document.
        /// </summary>
        Document,

        /// <summary>
        /// An HTML element.
        /// </summary>
        Element,

        /// <summary>
        /// An HTML comment.
        /// </summary>
        Comment,

        /// <summary>
        /// A text node is always the child of an element or a document node.
        /// </summary>
        Text,
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HtmlAgilityPack\HtmlAgilityPack\HtmlParseErrorCode.cs ===
// HtmlAgilityPack V1.0 - Simon Mourier <simon underscore mourier at hotmail dot com>
using System;
using System.Collections.Generic;
using System.Text;

namespace Test.Common.Library.HtmlAgilityPack
{
    /// <summary>
    /// Represents the type of parsing error.
    /// </summary>
    public enum HtmlParseErrorCode
    {
        /// <summary>
        /// A tag was not closed.
        /// </summary>
        TagNotClosed,

        /// <summary>
        /// A tag was not opened.
        /// </summary>
        TagNotOpened,

        /// <summary>
        /// There is a charset mismatch between stream and declared (META) encoding.
        /// </summary>
        CharsetMismatch,

        /// <summary>
        /// An end tag was not required.
        /// </summary>
        EndTagNotRequired,

        /// <summary>
        /// An end tag is invalid at this position.
        /// </summary>
        EndTagInvalidHere
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HtmlAgilityPack\HtmlAgilityPack\HtmlEntity.cs ===
// HtmlAgilityPack V1.0 - Simon Mourier <simon underscore mourier at hotmail dot com>
using System;
using System.Collections;
using System.Text;

namespace Test.Common.Library.HtmlAgilityPack
{
	/// <summary>
	/// A utility class to replace special characters by entities and vice-versa.
	/// Follows HTML 4.0 specification found at http://www.w3.org/TR/html4/sgml/entities.html
	/// </summary>
	public class HtmlEntity
	{
		private static Hashtable _entityName;
		private static Hashtable _entityValue;
		private static readonly int _maxEntitySize;

		private HtmlEntity()
		{
		}

		static HtmlEntity()
		{
			_entityName = new Hashtable();
			_entityValue = new Hashtable();

			#region Entities Definition
			_entityValue.Add("nbsp", 160);	// no-break space = non-breaking space, U+00A0 ISOnum 
			_entityName.Add(160, "nbsp");
			_entityValue.Add("iexcl", 161);	// inverted exclamation mark, U+00A1 ISOnum 
			_entityName.Add(161, "iexcl");
			_entityValue.Add("cent", 162);	// cent sign, U+00A2 ISOnum 
			_entityName.Add(162, "cent");
			_entityValue.Add("pound", 163);	// pound sign, U+00A3 ISOnum 
			_entityName.Add(163, "pound");
			_entityValue.Add("curren", 164);	// currency sign, U+00A4 ISOnum 
			_entityName.Add(164, "curren");
			_entityValue.Add("yen", 165);	// yen sign = yuan sign, U+00A5 ISOnum 
			_entityName.Add(165, "yen");
			_entityValue.Add("brvbar", 166);	// broken bar = broken vertical bar, U+00A6 ISOnum 
			_entityName.Add(166, "brvbar");
			_entityValue.Add("sect", 167);	// section sign, U+00A7 ISOnum 
			_entityName.Add(167, "sect");
			_entityValue.Add("uml", 168);	// diaeresis = spacing diaeresis, U+00A8 ISOdia 
			_entityName.Add(168, "uml");
			_entityValue.Add("copy", 169);	// copyright sign, U+00A9 ISOnum 
			_entityName.Add(169, "copy");
			_entityValue.Add("ordf", 170);	// feminine ordinal indicator, U+00AA ISOnum 
			_entityName.Add(170, "ordf");
			_entityValue.Add("laquo", 171);	// left-pointing double angle quotation mark = left pointing guillemet, U+00AB ISOnum 
			_entityName.Add(171, "laquo");
			_entityValue.Add("not", 172);	// not sign, U+00AC ISOnum 
			_entityName.Add(172, "not");
			_entityValue.Add("shy", 173);	// soft hyphen = discretionary hyphen, U+00AD ISOnum 
			_entityName.Add(173, "shy");
			_entityValue.Add("reg", 174);	// registered sign = registered trade mark sign, U+00AE ISOnum 
			_entityName.Add(174, "reg");
			_entityValue.Add("macr", 175);	// macron = spacing macron = overline = APL overbar, U+00AF ISOdia 
			_entityName.Add(175, "macr");
			_entityValue.Add("deg", 176);	// degree sign, U+00B0 ISOnum 
			_entityName.Add(176, "deg");
			_entityValue.Add("plusmn", 177);	// plus-minus sign = plus-or-minus sign, U+00B1 ISOnum 
			_entityName.Add(177, "plusmn");
			_entityValue.Add("sup2", 178);	// superscript two = superscript digit two = squared, U+00B2 ISOnum 
			_entityName.Add(178, "sup2");
			_entityValue.Add("sup3", 179);	// superscript three = superscript digit three = cubed, U+00B3 ISOnum 
			_entityName.Add(179, "sup3");
			_entityValue.Add("acute", 180);	// acute accent = spacing acute, U+00B4 ISOdia 
			_entityName.Add(180, "acute");
			_entityValue.Add("micro", 181);	// micro sign, U+00B5 ISOnum 
			_entityName.Add(181, "micro");
			_entityValue.Add("para", 182);	// pilcrow sign = paragraph sign, U+00B6 ISOnum 
			_entityName.Add(182, "para");
			_entityValue.Add("middot", 183);	// middle dot = Georgian comma = Greek middle dot, U+00B7 ISOnum 
			_entityName.Add(183, "middot");
			_entityValue.Add("cedil", 184);	// cedilla = spacing cedilla, U+00B8 ISOdia 
			_entityName.Add(184, "cedil");
			_entityValue.Add("sup1", 185);	// superscript one = superscript digit one, U+00B9 ISOnum 
			_entityName.Add(185, "sup1");
			_entityValue.Add("ordm", 186);	// masculine ordinal indicator, U+00BA ISOnum 
			_entityName.Add(186, "ordm");
			_entityValue.Add("raquo", 187);	// right-pointing double angle quotation mark = right pointing guillemet, U+00BB ISOnum 
			_entityName.Add(187, "raquo");
			_entityValue.Add("frac14", 188);	// vulgar fraction one quarter = fraction one quarter, U+00BC ISOnum 
			_entityName.Add(188, "frac14");
			_entityValue.Add("frac12", 189);	// vulgar fraction one half = fraction one half, U+00BD ISOnum 
			_entityName.Add(189, "frac12");
			_entityValue.Add("frac34", 190);	// vulgar fraction three quarters = fraction three quarters, U+00BE ISOnum 
			_entityName.Add(190, "frac34");
			_entityValue.Add("iquest", 191);	// inverted question mark = turned question mark, U+00BF ISOnum 
			_entityName.Add(191, "iquest");
			_entityValue.Add("Agrave", 192);	// latin capital letter A with grave = latin capital letter A grave, U+00C0 ISOlat1 
			_entityName.Add(192, "Agrave");
			_entityValue.Add("Aacute", 193);	// latin capital letter A with acute, U+00C1 ISOlat1 
			_entityName.Add(193, "Aacute");
			_entityValue.Add("Acirc", 194);	// latin capital letter A with circumflex, U+00C2 ISOlat1 
			_entityName.Add(194, "Acirc");
			_entityValue.Add("Atilde", 195);	// latin capital letter A with tilde, U+00C3 ISOlat1 
			_entityName.Add(195, "Atilde");
			_entityValue.Add("Auml", 196);	// latin capital letter A with diaeresis, U+00C4 ISOlat1 
			_entityName.Add(196, "Auml");
			_entityValue.Add("Aring", 197);	// latin capital letter A with ring above = latin capital letter A ring, U+00C5 ISOlat1 
			_entityName.Add(197, "Aring");
			_entityValue.Add("AElig", 198);	// latin capital letter AE = latin capital ligature AE, U+00C6 ISOlat1 
			_entityName.Add(198, "AElig");
			_entityValue.Add("Ccedil", 199);	// latin capital letter C with cedilla, U+00C7 ISOlat1 
			_entityName.Add(199, "Ccedil");
			_entityValue.Add("Egrave", 200);	// latin capital letter E with grave, U+00C8 ISOlat1 
			_entityName.Add(200, "Egrave");
			_entityValue.Add("Eacute", 201);	// latin capital letter E with acute, U+00C9 ISOlat1 
			_entityName.Add(201, "Eacute");
			_entityValue.Add("Ecirc", 202);	// latin capital letter E with circumflex, U+00CA ISOlat1 
			_entityName.Add(202, "Ecirc");
			_entityValue.Add("Euml", 203);	// latin capital letter E with diaeresis, U+00CB ISOlat1 
			_entityName.Add(203, "Euml");
			_entityValue.Add("Igrave", 204);	// latin capital letter I with grave, U+00CC ISOlat1 
			_entityName.Add(204, "Igrave");
			_entityValue.Add("Iacute", 205);	// latin capital letter I with acute, U+00CD ISOlat1 
			_entityName.Add(205, "Iacute");
			_entityValue.Add("Icirc", 206);	// latin capital letter I with circumflex, U+00CE ISOlat1 
			_entityName.Add(206, "Icirc");
			_entityValue.Add("Iuml", 207);	// latin capital letter I with diaeresis, U+00CF ISOlat1 
			_entityName.Add(207, "Iuml");
			_entityValue.Add("ETH", 208);	// latin capital letter ETH, U+00D0 ISOlat1 
			_entityName.Add(208, "ETH");
			_entityValue.Add("Ntilde", 209);	// latin capital letter N with tilde, U+00D1 ISOlat1 
			_entityName.Add(209, "Ntilde");
			_entityValue.Add("Ograve", 210);	// latin capital letter O with grave, U+00D2 ISOlat1 
			_entityName.Add(210, "Ograve");
			_entityValue.Add("Oacute", 211);	// latin capital letter O with acute, U+00D3 ISOlat1 
			_entityName.Add(211, "Oacute");
			_entityValue.Add("Ocirc", 212);	// latin capital letter O with circumflex, U+00D4 ISOlat1 
			_entityName.Add(212, "Ocirc");
			_entityValue.Add("Otilde", 213);	// latin capital letter O with tilde, U+00D5 ISOlat1 
			_entityName.Add(213, "Otilde");
			_entityValue.Add("Ouml", 214);	// latin capital letter O with diaeresis, U+00D6 ISOlat1 
			_entityName.Add(214, "Ouml");
			_entityValue.Add("times", 215);	// multiplication sign, U+00D7 ISOnum 
			_entityName.Add(215, "times");
			_entityValue.Add("Oslash", 216);	// latin capital letter O with stroke = latin capital letter O slash, U+00D8 ISOlat1 
			_entityName.Add(216, "Oslash");
			_entityValue.Add("Ugrave", 217);	// latin capital letter U with grave, U+00D9 ISOlat1 
			_entityName.Add(217, "Ugrave");
			_entityValue.Add("Uacute", 218);	// latin capital letter U with acute, U+00DA ISOlat1 
			_entityName.Add(218, "Uacute");
			_entityValue.Add("Ucirc", 219);	// latin capital letter U with circumflex, U+00DB ISOlat1 
			_entityName.Add(219, "Ucirc");
			_entityValue.Add("Uuml", 220);	// latin capital letter U with diaeresis, U+00DC ISOlat1 
			_entityName.Add(220, "Uuml");
			_entityValue.Add("Yacute", 221);	// latin capital letter Y with acute, U+00DD ISOlat1 
			_entityName.Add(221, "Yacute");
			_entityValue.Add("THORN", 222);	// latin capital letter THORN, U+00DE ISOlat1 
			_entityName.Add(222, "THORN");
			_entityValue.Add("szlig", 223);	// latin small letter sharp s = ess-zed, U+00DF ISOlat1 
			_entityName.Add(223, "szlig");
			_entityValue.Add("agrave", 224);	// latin small letter a with grave = latin small letter a grave, U+00E0 ISOlat1 
			_entityName.Add(224, "agrave");
			_entityValue.Add("aacute", 225);	// latin small letter a with acute, U+00E1 ISOlat1 
			_entityName.Add(225, "aacute");
			_entityValue.Add("acirc", 226);	// latin small letter a with circumflex, U+00E2 ISOlat1 
			_entityName.Add(226, "acirc");
			_entityValue.Add("atilde", 227);	// latin small letter a with tilde, U+00E3 ISOlat1 
			_entityName.Add(227, "atilde");
			_entityValue.Add("auml", 228);	// latin small letter a with diaeresis, U+00E4 ISOlat1 
			_entityName.Add(228, "auml");
			_entityValue.Add("aring", 229);	// latin small letter a with ring above = latin small letter a ring, U+00E5 ISOlat1 
			_entityName.Add(229, "aring");
			_entityValue.Add("aelig", 230);	// latin small letter ae = latin small ligature ae, U+00E6 ISOlat1 
			_entityName.Add(230, "aelig");
			_entityValue.Add("ccedil", 231);	// latin small letter c with cedilla, U+00E7 ISOlat1 
			_entityName.Add(231, "ccedil");
			_entityValue.Add("egrave", 232);	// latin small letter e with grave, U+00E8 ISOlat1 
			_entityName.Add(232, "egrave");
			_entityValue.Add("eacute", 233);	// latin small letter e with acute, U+00E9 ISOlat1 
			_entityName.Add(233, "eacute");
			_entityValue.Add("ecirc", 234);	// latin small letter e with circumflex, U+00EA ISOlat1 
			_entityName.Add(234, "ecirc");
			_entityValue.Add("euml", 235);	// latin small letter e with diaeresis, U+00EB ISOlat1 
			_entityName.Add(235, "euml");
			_entityValue.Add("igrave", 236);	// latin small letter i with grave, U+00EC ISOlat1 
			_entityName.Add(236, "igrave");
			_entityValue.Add("iacute", 237);	// latin small letter i with acute, U+00ED ISOlat1 
			_entityName.Add(237, "iacute");
			_entityValue.Add("icirc", 238);	// latin small letter i with circumflex, U+00EE ISOlat1 
			_entityName.Add(238, "icirc");
			_entityValue.Add("iuml", 239);	// latin small letter i with diaeresis, U+00EF ISOlat1 
			_entityName.Add(239, "iuml");
			_entityValue.Add("eth", 240);	// latin small letter eth, U+00F0 ISOlat1 
			_entityName.Add(240, "eth");
			_entityValue.Add("ntilde", 241);	// latin small letter n with tilde, U+00F1 ISOlat1 
			_entityName.Add(241, "ntilde");
			_entityValue.Add("ograve", 242);	// latin small letter o with grave, U+00F2 ISOlat1 
			_entityName.Add(242, "ograve");
			_entityValue.Add("oacute", 243);	// latin small letter o with acute, U+00F3 ISOlat1 
			_entityName.Add(243, "oacute");
			_entityValue.Add("ocirc", 244);	// latin small letter o with circumflex, U+00F4 ISOlat1 
			_entityName.Add(244, "ocirc");
			_entityValue.Add("otilde", 245);	// latin small letter o with tilde, U+00F5 ISOlat1 
			_entityName.Add(245, "otilde");
			_entityValue.Add("ouml", 246);	// latin small letter o with diaeresis, U+00F6 ISOlat1 
			_entityName.Add(246, "ouml");
			_entityValue.Add("divide", 247);	// division sign, U+00F7 ISOnum 
			_entityName.Add(247, "divide");
			_entityValue.Add("oslash", 248);	// latin small letter o with stroke, = latin small letter o slash, U+00F8 ISOlat1 
			_entityName.Add(248, "oslash");
			_entityValue.Add("ugrave", 249);	// latin small letter u with grave, U+00F9 ISOlat1 
			_entityName.Add(249, "ugrave");
			_entityValue.Add("uacute", 250);	// latin small letter u with acute, U+00FA ISOlat1 
			_entityName.Add(250, "uacute");
			_entityValue.Add("ucirc", 251);	// latin small letter u with circumflex, U+00FB ISOlat1 
			_entityName.Add(251, "ucirc");
			_entityValue.Add("uuml", 252);	// latin small letter u with diaeresis, U+00FC ISOlat1 
			_entityName.Add(252, "uuml");
			_entityValue.Add("yacute", 253);	// latin small letter y with acute, U+00FD ISOlat1 
			_entityName.Add(253, "yacute");
			_entityValue.Add("thorn", 254);	// latin small letter thorn, U+00FE ISOlat1 
			_entityName.Add(254, "thorn");
			_entityValue.Add("yuml", 255);	// latin small letter y with diaeresis, U+00FF ISOlat1 
			_entityName.Add(255, "yuml");
			_entityValue.Add("fnof", 402);	// latin small f with hook = function = florin, U+0192 ISOtech 
			_entityName.Add(402, "fnof");
			_entityValue.Add("Alpha", 913);	// greek capital letter alpha, U+0391 
			_entityName.Add(913, "Alpha");
			_entityValue.Add("Beta", 914);	// greek capital letter beta, U+0392 
			_entityName.Add(914, "Beta");
			_entityValue.Add("Gamma", 915);	// greek capital letter gamma, U+0393 ISOgrk3 
			_entityName.Add(915, "Gamma");
			_entityValue.Add("Delta", 916);	// greek capital letter delta, U+0394 ISOgrk3 
			_entityName.Add(916, "Delta");
			_entityValue.Add("Epsilon", 917);	// greek capital letter epsilon, U+0395 
			_entityName.Add(917, "Epsilon");
			_entityValue.Add("Zeta", 918);	// greek capital letter zeta, U+0396 
			_entityName.Add(918, "Zeta");
			_entityValue.Add("Eta", 919);	// greek capital letter eta, U+0397 
			_entityName.Add(919, "Eta");
			_entityValue.Add("Theta", 920);	// greek capital letter theta, U+0398 ISOgrk3 
			_entityName.Add(920, "Theta");
			_entityValue.Add("Iota", 921);	// greek capital letter iota, U+0399 
			_entityName.Add(921, "Iota");
			_entityValue.Add("Kappa", 922);	// greek capital letter kappa, U+039A 
			_entityName.Add(922, "Kappa");
			_entityValue.Add("Lambda", 923);	// greek capital letter lambda, U+039B ISOgrk3 
			_entityName.Add(923, "Lambda");
			_entityValue.Add("Mu", 924);	// greek capital letter mu, U+039C 
			_entityName.Add(924, "Mu");
			_entityValue.Add("Nu", 925);	// greek capital letter nu, U+039D 
			_entityName.Add(925, "Nu");
			_entityValue.Add("Xi", 926);	// greek capital letter xi, U+039E ISOgrk3 
			_entityName.Add(926, "Xi");
			_entityValue.Add("Omicron", 927);	// greek capital letter omicron, U+039F 
			_entityName.Add(927, "Omicron");
			_entityValue.Add("Pi", 928);	// greek capital letter pi, U+03A0 ISOgrk3 
			_entityName.Add(928, "Pi");
			_entityValue.Add("Rho", 929);	// greek capital letter rho, U+03A1 
			_entityName.Add(929, "Rho");
			_entityValue.Add("Sigma", 931);	// greek capital letter sigma, U+03A3 ISOgrk3 
			_entityName.Add(931, "Sigma");
			_entityValue.Add("Tau", 932);	// greek capital letter tau, U+03A4 
			_entityName.Add(932, "Tau");
			_entityValue.Add("Upsilon", 933);	// greek capital letter upsilon, U+03A5 ISOgrk3 
			_entityName.Add(933, "Upsilon");
			_entityValue.Add("Phi", 934);	// greek capital letter phi, U+03A6 ISOgrk3 
			_entityName.Add(934, "Phi");
			_entityValue.Add("Chi", 935);	// greek capital letter chi, U+03A7 
			_entityName.Add(935, "Chi");
			_entityValue.Add("Psi", 936);	// greek capital letter psi, U+03A8 ISOgrk3 
			_entityName.Add(936, "Psi");
			_entityValue.Add("Omega", 937);	// greek capital letter omega, U+03A9 ISOgrk3 
			_entityName.Add(937, "Omega");
			_entityValue.Add("alpha", 945);	// greek small letter alpha, U+03B1 ISOgrk3 
			_entityName.Add(945, "alpha");
			_entityValue.Add("beta", 946);	// greek small letter beta, U+03B2 ISOgrk3 
			_entityName.Add(946, "beta");
			_entityValue.Add("gamma", 947);	// greek small letter gamma, U+03B3 ISOgrk3 
			_entityName.Add(947, "gamma");
			_entityValue.Add("delta", 948);	// greek small letter delta, U+03B4 ISOgrk3 
			_entityName.Add(948, "delta");
			_entityValue.Add("epsilon", 949);	// greek small letter epsilon, U+03B5 ISOgrk3 
			_entityName.Add(949, "epsilon");
			_entityValue.Add("zeta", 950);	// greek small letter zeta, U+03B6 ISOgrk3 
			_entityName.Add(950, "zeta");
			_entityValue.Add("eta", 951);	// greek small letter eta, U+03B7 ISOgrk3 
			_entityName.Add(951, "eta");
			_entityValue.Add("theta", 952);	// greek small letter theta, U+03B8 ISOgrk3 
			_entityName.Add(952, "theta");
			_entityValue.Add("iota", 953);	// greek small letter iota, U+03B9 ISOgrk3 
			_entityName.Add(953, "iota");
			_entityValue.Add("kappa", 954);	// greek small letter kappa, U+03BA ISOgrk3 
			_entityName.Add(954, "kappa");
			_entityValue.Add("lambda", 955);	// greek small letter lambda, U+03BB ISOgrk3 
			_entityName.Add(955, "lambda");
			_entityValue.Add("mu", 956);	// greek small letter mu, U+03BC ISOgrk3 
			_entityName.Add(956, "mu");
			_entityValue.Add("nu", 957);	// greek small letter nu, U+03BD ISOgrk3 
			_entityName.Add(957, "nu");
			_entityValue.Add("xi", 958);	// greek small letter xi, U+03BE ISOgrk3 
			_entityName.Add(958, "xi");
			_entityValue.Add("omicron", 959);	// greek small letter omicron, U+03BF NEW 
			_entityName.Add(959, "omicron");
			_entityValue.Add("pi", 960);	// greek small letter pi, U+03C0 ISOgrk3 
			_entityName.Add(960, "pi");
			_entityValue.Add("rho", 961);	// greek small letter rho, U+03C1 ISOgrk3 
			_entityName.Add(961, "rho");
			_entityValue.Add("sigmaf", 962);	// greek small letter final sigma, U+03C2 ISOgrk3 
			_entityName.Add(962, "sigmaf");
			_entityValue.Add("sigma", 963);	// greek small letter sigma, U+03C3 ISOgrk3 
			_entityName.Add(963, "sigma");
			_entityValue.Add("tau", 964);	// greek small letter tau, U+03C4 ISOgrk3 
			_entityName.Add(964, "tau");
			_entityValue.Add("upsilon", 965);	// greek small letter upsilon, U+03C5 ISOgrk3 
			_entityName.Add(965, "upsilon");
			_entityValue.Add("phi", 966);	// greek small letter phi, U+03C6 ISOgrk3 
			_entityName.Add(966, "phi");
			_entityValue.Add("chi", 967);	// greek small letter chi, U+03C7 ISOgrk3 
			_entityName.Add(967, "chi");
			_entityValue.Add("psi", 968);	// greek small letter psi, U+03C8 ISOgrk3 
			_entityName.Add(968, "psi");
			_entityValue.Add("omega", 969);	// greek small letter omega, U+03C9 ISOgrk3 
			_entityName.Add(969, "omega");
			_entityValue.Add("thetasym", 977);	// greek small letter theta symbol, U+03D1 NEW 
			_entityName.Add(977, "thetasym");
			_entityValue.Add("upsih", 978);	// greek upsilon with hook symbol, U+03D2 NEW 
			_entityName.Add(978, "upsih");
			_entityValue.Add("piv", 982);	// greek pi symbol, U+03D6 ISOgrk3 
			_entityName.Add(982, "piv");
			_entityValue.Add("bull", 8226);	// bullet = black small circle, U+2022 ISOpub 
			_entityName.Add(8226, "bull");
			_entityValue.Add("hellip", 8230);	// horizontal ellipsis = three dot leader, U+2026 ISOpub 
			_entityName.Add(8230, "hellip");
			_entityValue.Add("prime", 8242);	// prime = minutes = feet, U+2032 ISOtech 
			_entityName.Add(8242, "prime");
			_entityValue.Add("Prime", 8243);	// double prime = seconds = inches, U+2033 ISOtech 
			_entityName.Add(8243, "Prime");
			_entityValue.Add("oline", 8254);	// overline = spacing overscore, U+203E NEW 
			_entityName.Add(8254, "oline");
			_entityValue.Add("frasl", 8260);	// fraction slash, U+2044 NEW 
			_entityName.Add(8260, "frasl");
			_entityValue.Add("weierp", 8472);	// script capital P = power set = Weierstrass p, U+2118 ISOamso 
			_entityName.Add(8472, "weierp");
			_entityValue.Add("image", 8465);	// blackletter capital I = imaginary part, U+2111 ISOamso 
			_entityName.Add(8465, "image");
			_entityValue.Add("real", 8476);	// blackletter capital R = real part symbol, U+211C ISOamso 
			_entityName.Add(8476, "real");
			_entityValue.Add("trade", 8482);	// trade mark sign, U+2122 ISOnum 
			_entityName.Add(8482, "trade");
			_entityValue.Add("alefsym", 8501);	// alef symbol = first transfinite cardinal, U+2135 NEW 
			_entityName.Add(8501, "alefsym");
			_entityValue.Add("larr", 8592);	// leftwards arrow, U+2190 ISOnum 
			_entityName.Add(8592, "larr");
			_entityValue.Add("uarr", 8593);	// upwards arrow, U+2191 ISOnum
			_entityName.Add(8593, "uarr");
			_entityValue.Add("rarr", 8594);	// rightwards arrow, U+2192 ISOnum 
			_entityName.Add(8594, "rarr");
			_entityValue.Add("darr", 8595);	// downwards arrow, U+2193 ISOnum 
			_entityName.Add(8595, "darr");
			_entityValue.Add("harr", 8596);	// left right arrow, U+2194 ISOamsa 
			_entityName.Add(8596, "harr");
			_entityValue.Add("crarr", 8629);	// downwards arrow with corner leftwards = carriage return, U+21B5 NEW 
			_entityName.Add(8629, "crarr");
			_entityValue.Add("lArr", 8656);	// leftwards double arrow, U+21D0 ISOtech 
			_entityName.Add(8656, "lArr");
			_entityValue.Add("uArr", 8657);	// upwards double arrow, U+21D1 ISOamsa 
			_entityName.Add(8657, "uArr");
			_entityValue.Add("rArr", 8658);	// rightwards double arrow, U+21D2 ISOtech 
			_entityName.Add(8658, "rArr");
			_entityValue.Add("dArr", 8659);	// downwards double arrow, U+21D3 ISOamsa 
			_entityName.Add(8659, "dArr");
			_entityValue.Add("hArr", 8660);	// left right double arrow, U+21D4 ISOamsa 
			_entityName.Add(8660, "hArr");
			_entityValue.Add("forall", 8704);	// for all, U+2200 ISOtech 
			_entityName.Add(8704, "forall");
			_entityValue.Add("part", 8706);	// partial differential, U+2202 ISOtech 
			_entityName.Add(8706, "part");
			_entityValue.Add("exist", 8707);	// there exists, U+2203 ISOtech 
			_entityName.Add(8707, "exist");
			_entityValue.Add("empty", 8709);	// empty set = null set = diameter, U+2205 ISOamso 
			_entityName.Add(8709, "empty");
			_entityValue.Add("nabla", 8711);	// nabla = backward difference, U+2207 ISOtech 
			_entityName.Add(8711, "nabla");
			_entityValue.Add("isin", 8712);	// element of, U+2208 ISOtech 
			_entityName.Add(8712, "isin");
			_entityValue.Add("notin", 8713);	// not an element of, U+2209 ISOtech 
			_entityName.Add(8713, "notin");
			_entityValue.Add("ni", 8715);	// contains as member, U+220B ISOtech 
			_entityName.Add(8715, "ni");
			_entityValue.Add("prod", 8719);	// n-ary product = product sign, U+220F ISOamsb 
			_entityName.Add(8719, "prod");
			_entityValue.Add("sum", 8721);	// n-ary sumation, U+2211 ISOamsb 
			_entityName.Add(8721, "sum");
			_entityValue.Add("minus", 8722);	// minus sign, U+2212 ISOtech 
			_entityName.Add(8722, "minus");
			_entityValue.Add("lowast", 8727);	// asterisk operator, U+2217 ISOtech 
			_entityName.Add(8727, "lowast");
			_entityValue.Add("radic", 8730);	// square root = radical sign, U+221A ISOtech 
			_entityName.Add(8730, "radic");
			_entityValue.Add("prop", 8733);	// proportional to, U+221D ISOtech 
			_entityName.Add(8733, "prop");
			_entityValue.Add("infin", 8734);	// infinity, U+221E ISOtech 
			_entityName.Add(8734, "infin");
			_entityValue.Add("ang", 8736);	// angle, U+2220 ISOamso 
			_entityName.Add(8736, "ang");
			_entityValue.Add("and", 8743);	// logical and = wedge, U+2227 ISOtech 
			_entityName.Add(8743, "and");
			_entityValue.Add("or", 8744);	// logical or = vee, U+2228 ISOtech 
			_entityName.Add(8744, "or");
			_entityValue.Add("cap", 8745);	// intersection = cap, U+2229 ISOtech 
			_entityName.Add(8745, "cap");
			_entityValue.Add("cup", 8746);	// union = cup, U+222A ISOtech 
			_entityName.Add(8746, "cup");
			_entityValue.Add("int", 8747);	// integral, U+222B ISOtech 
			_entityName.Add(8747, "int");
			_entityValue.Add("there4", 8756);	// therefore, U+2234 ISOtech 
			_entityName.Add(8756, "there4");
			_entityValue.Add("sim", 8764);	// tilde operator = varies with = similar to, U+223C ISOtech 
			_entityName.Add(8764, "sim");
			_entityValue.Add("cong", 8773);	// approximately equal to, U+2245 ISOtech 
			_entityName.Add(8773, "cong");
			_entityValue.Add("asymp", 8776);	// almost equal to = asymptotic to, U+2248 ISOamsr 
			_entityName.Add(8776, "asymp");
			_entityValue.Add("ne", 8800);	// not equal to, U+2260 ISOtech 
			_entityName.Add(8800, "ne");
			_entityValue.Add("equiv", 8801);	// identical to, U+2261 ISOtech 
			_entityName.Add(8801, "equiv");
			_entityValue.Add("le", 8804);	// less-than or equal to, U+2264 ISOtech 
			_entityName.Add(8804, "le");
			_entityValue.Add("ge", 8805);	// greater-than or equal to, U+2265 ISOtech 
			_entityName.Add(8805, "ge");
			_entityValue.Add("sub", 8834);	// subset of, U+2282 ISOtech 
			_entityName.Add(8834, "sub");
			_entityValue.Add("sup", 8835);	// superset of, U+2283 ISOtech 
			_entityName.Add(8835, "sup");
			_entityValue.Add("nsub", 8836);	// not a subset of, U+2284 ISOamsn 
			_entityName.Add(8836, "nsub");
			_entityValue.Add("sube", 8838);	// subset of or equal to, U+2286 ISOtech 
			_entityName.Add(8838, "sube");
			_entityValue.Add("supe", 8839);	// superset of or equal to, U+2287 ISOtech 
			_entityName.Add(8839, "supe");
			_entityValue.Add("oplus", 8853);	// circled plus = direct sum, U+2295 ISOamsb 
			_entityName.Add(8853, "oplus");
			_entityValue.Add("otimes", 8855);	// circled times = vector product, U+2297 ISOamsb 
			_entityName.Add(8855, "otimes");
			_entityValue.Add("perp", 8869);	// up tack = orthogonal to = perpendicular, U+22A5 ISOtech 
			_entityName.Add(8869, "perp");
			_entityValue.Add("sdot", 8901);	// dot operator, U+22C5 ISOamsb 
			_entityName.Add(8901, "sdot");
			_entityValue.Add("lceil", 8968);	// left ceiling = apl upstile, U+2308 ISOamsc 
			_entityName.Add(8968, "lceil");
			_entityValue.Add("rceil", 8969);	// right ceiling, U+2309 ISOamsc 
			_entityName.Add(8969, "rceil");
			_entityValue.Add("lfloor", 8970);	// left floor = apl downstile, U+230A ISOamsc 
			_entityName.Add(8970, "lfloor");
			_entityValue.Add("rfloor", 8971);	// right floor, U+230B ISOamsc 
			_entityName.Add(8971, "rfloor");
			_entityValue.Add("lang", 9001);	// left-pointing angle bracket = bra, U+2329 ISOtech 
			_entityName.Add(9001, "lang");
			_entityValue.Add("rang", 9002);	// right-pointing angle bracket = ket, U+232A ISOtech 
			_entityName.Add(9002, "rang");
			_entityValue.Add("loz", 9674);	// lozenge, U+25CA ISOpub 
			_entityName.Add(9674, "loz");
			_entityValue.Add("spades", 9824);	// black spade suit, U+2660 ISOpub 
			_entityName.Add(9824, "spades");
			_entityValue.Add("clubs", 9827);	// black club suit = shamrock, U+2663 ISOpub 
			_entityName.Add(9827, "clubs");
			_entityValue.Add("hearts", 9829);	// black heart suit = valentine, U+2665 ISOpub 
			_entityName.Add(9829, "hearts");
			_entityValue.Add("diams", 9830);	// black diamond suit, U+2666 ISOpub 
			_entityName.Add(9830, "diams");
			_entityValue.Add("quot", 34);	// quotation mark = APL quote, U+0022 ISOnum 
			_entityName.Add(34, "quot");
			_entityValue.Add("amp", 38);	// ampersand, U+0026 ISOnum 
			_entityName.Add(38, "amp");
			_entityValue.Add("lt", 60);	// less-than sign, U+003C ISOnum 
			_entityName.Add(60, "lt");
			_entityValue.Add("gt", 62);	// greater-than sign, U+003E ISOnum 
			_entityName.Add(62, "gt");
			_entityValue.Add("OElig", 338);	// latin capital ligature OE, U+0152 ISOlat2 
			_entityName.Add(338, "OElig");
			_entityValue.Add("oelig", 339);	// latin small ligature oe, U+0153 ISOlat2 
			_entityName.Add(339, "oelig");
			_entityValue.Add("Scaron", 352);	// latin capital letter S with caron, U+0160 ISOlat2 
			_entityName.Add(352, "Scaron");
			_entityValue.Add("scaron", 353);	// latin small letter s with caron, U+0161 ISOlat2 
			_entityName.Add(353, "scaron");
			_entityValue.Add("Yuml", 376);	// latin capital letter Y with diaeresis, U+0178 ISOlat2 
			_entityName.Add(376, "Yuml");
			_entityValue.Add("circ", 710);	// modifier letter circumflex accent, U+02C6 ISOpub 
			_entityName.Add(710, "circ");
			_entityValue.Add("tilde", 732);	// small tilde, U+02DC ISOdia 
			_entityName.Add(732, "tilde");
			_entityValue.Add("ensp", 8194);	// en space, U+2002 ISOpub 
			_entityName.Add(8194, "ensp");
			_entityValue.Add("emsp", 8195);	// em space, U+2003 ISOpub 
			_entityName.Add(8195, "emsp");
			_entityValue.Add("thinsp", 8201);	// thin space, U+2009 ISOpub 
			_entityName.Add(8201, "thinsp");
			_entityValue.Add("zwnj", 8204);	// zero width non-joiner, U+200C NEW RFC 2070 
			_entityName.Add(8204, "zwnj");
			_entityValue.Add("zwj", 8205);	// zero width joiner, U+200D NEW RFC 2070 
			_entityName.Add(8205, "zwj");
			_entityValue.Add("lrm", 8206);	// left-to-right mark, U+200E NEW RFC 2070 
			_entityName.Add(8206, "lrm");
			_entityValue.Add("rlm", 8207);	// right-to-left mark, U+200F NEW RFC 2070 
			_entityName.Add(8207, "rlm");
			_entityValue.Add("ndash", 8211);	// en dash, U+2013 ISOpub 
			_entityName.Add(8211, "ndash");
			_entityValue.Add("mdash", 8212);	// em dash, U+2014 ISOpub 
			_entityName.Add(8212, "mdash");
			_entityValue.Add("lsquo", 8216);	// left single quotation mark, U+2018 ISOnum 
			_entityName.Add(8216, "lsquo");
			_entityValue.Add("rsquo", 8217);	// right single quotation mark, U+2019 ISOnum 
			_entityName.Add(8217, "rsquo");
			_entityValue.Add("sbquo", 8218);	// single low-9 quotation mark, U+201A NEW 
			_entityName.Add(8218, "sbquo");
			_entityValue.Add("ldquo", 8220);	// left double quotation mark, U+201C ISOnum 
			_entityName.Add(8220, "ldquo");
			_entityValue.Add("rdquo", 8221);	// right double quotation mark, U+201D ISOnum 
			_entityName.Add(8221, "rdquo");
			_entityValue.Add("bdquo", 8222);	// double low-9 quotation mark, U+201E NEW 
			_entityName.Add(8222, "bdquo");
			_entityValue.Add("dagger", 8224);	// dagger, U+2020 ISOpub 
			_entityName.Add(8224, "dagger");
			_entityValue.Add("Dagger", 8225);	// double dagger, U+2021 ISOpub 
			_entityName.Add(8225, "Dagger");
			_entityValue.Add("permil", 8240);	// per mille sign, U+2030 ISOtech 
			_entityName.Add(8240, "permil");
			_entityValue.Add("lsaquo", 8249);	// single left-pointing angle quotation mark, U+2039 ISO proposed 
			_entityName.Add(8249, "lsaquo");
			_entityValue.Add("rsaquo", 8250);	// single right-pointing angle quotation mark, U+203A ISO proposed 
			_entityName.Add(8250, "rsaquo");
			_entityValue.Add("euro", 8364);	// euro sign, U+20AC NEW 
			_entityName.Add(8364, "euro");

			_maxEntitySize = 8 + 1; // we add the # char
			#endregion
		}

		/// <summary>
		/// A collection of entities indexed by name.
		/// </summary>
		public static Hashtable EntityName
		{
			get
			{
				return _entityName;
			}
		}

		/// <summary>
		/// A collection of entities indexed by value.
		/// </summary>
		public static Hashtable EntityValue
		{
			get
			{
				return _entityValue;
			}
		}

		/// <summary>
		/// Clone and entitize an HtmlNode. This will affect attribute values and nodes' text. It will also entitize all child nodes.
		/// </summary>
		/// <param name="node">The node to entitize.</param>
		/// <returns>An entitized cloned node.</returns>
		public static HtmlNode Entitize(HtmlNode node)
		{
			if (node == null)
			{
				throw new ArgumentNullException("node");
			}
			HtmlNode result = node.CloneNode(true);
			if (result.HasAttributes)
				Entitize(result.Attributes);

			if (result.HasChildNodes)
			{
				Entitize(result.ChildNodes);
			}
			else
			{
				if (result.NodeType == HtmlNodeType.Text)
				{
					((HtmlTextNode)result).Text = Entitize(((HtmlTextNode)result).Text, true, true);
				}
			}
			return result;
		}

		private static void Entitize(HtmlAttributeCollection collection)
		{
			foreach(HtmlAttribute at in collection)
			{
				at.Value = Entitize(at.Value);
			}
		}

		private static void Entitize(HtmlNodeCollection collection)
		{
			foreach(HtmlNode node in collection)
			{
				if (node.HasAttributes)
					Entitize(node.Attributes);

				if (node.HasChildNodes)
				{
					Entitize(node.ChildNodes);
				}
				else
				{
					if (node.NodeType == HtmlNodeType.Text)
					{
						((HtmlTextNode)node).Text = Entitize(((HtmlTextNode)node).Text, true, true);
					}
				}
			}
		}


		/// <summary>
		/// Replace characters above 127 by entities.
		/// </summary>
		/// <param name="text">The source text.</param>
		/// <returns>The result text.</returns>
		public static string Entitize(string text)
		{
			return Entitize(text, true);
		}

		/// <summary>
		/// Replace characters above 127 by entities.
		/// </summary>
		/// <param name="text">The source text.</param>
		/// <param name="useNames">If set to false, the function will not use known entities name. Default is true.</param>
		/// <returns>The result text.</returns>
		public static string Entitize(string text, bool useNames)
		{
			return Entitize( text, useNames, false);
		}
		/// <summary>
		/// Replace characters above 127 by entities.
		/// </summary>
		/// <param name="text">The source text.</param>
		/// <param name="useNames">If set to false, the function will not use known entities name. Default is true.</param>
		/// <param name="entitizeQuotAmpAndLtGt">If set to true, the [quote], [ampersand], [lower than] and [greather than] characters will be entitized.</param>
		/// <returns>The result text</returns>
		public static string Entitize(string text, bool useNames, bool entitizeQuotAmpAndLtGt)
//		_entityValue.Add("quot", 34);	// quotation mark = APL quote, U+0022 ISOnum 
//		_entityName.Add(34, "quot");
//		_entityValue.Add("amp", 38);	// ampersand, U+0026 ISOnum 
//		_entityName.Add(38, "amp");
//		_entityValue.Add("lt", 60);	// less-than sign, U+003C ISOnum 
//		_entityName.Add(60, "lt");
//		_entityValue.Add("gt", 62);	// greater-than sign, U+003E ISOnum 
//		_entityName.Add(62, "gt");
		{
			if (text == null)
				return null;

			if (text.Length == 0)
				return text;

			StringBuilder sb = new StringBuilder(text.Length);
			for(int i=0;i<text.Length;i++)
			{
				int code = (int)text[i];
				if ((code>127) || (entitizeQuotAmpAndLtGt && ((code == 34) || (code == 38) || (code == 60) || (code == 62))))
				{
					string entity = _entityName[code] as string;
					if ((entity == null) || (!useNames))
					{
						sb.Append("&#" + code + ";");
					}
					else
					{
						sb.Append("&" + entity + ";");
					}
				}
				else
				{
					sb.Append(text[i]);
				}
			}

			return sb.ToString();
		}

		/// <summary>
		/// Replace known entities by characters.
		/// </summary>
		/// <param name="text">The source text.</param>
		/// <returns>The result text.</returns>
		public static string DeEntitize(string text)
		{
			if (text == null)
				return null;

			if (text.Length == 0)
				return text;

			StringBuilder sb = new StringBuilder(text.Length);
			ParseState state = ParseState.Text;
			StringBuilder entity = new StringBuilder(10);
			
			for(int i=0;i<text.Length;i++)
			{
				switch(state)
				{
					case ParseState.Text:
						switch(text[i])
						{
							case '&':
								state = ParseState.EntityStart;
								break;

							default:
								sb.Append(text[i]);
								break;

						}
						break;

					case ParseState.EntityStart:
						switch(text[i])
						{
							case ';':
								if (entity.Length == 0)
								{
									sb.Append("&;");
								}
								else
								{
									if (entity[0] == '#')
									{
										string e = entity.ToString();
										try
										{
											int code = Convert.ToInt32(e.Substring(1, e.Length-1));
											sb.Append(Convert.ToChar(code));
										}
										catch
										{
											sb.Append("&#" + e + ";");
										}
									}
									else
									{
										// named entity?
										int code;
										object o = _entityValue[entity.ToString()];
										if (o == null)
										{
											// nope
											sb.Append("&" + entity + ";");
										}
										else
										{
											// we found one
											code = (int)o;
											sb.Append(Convert.ToChar(code));
										}
									}
									entity.Remove(0, entity.Length);
								}
								state = ParseState.Text;
								break;

							case '&':
								// new entity start without end, it was not an entity...
								sb.Append("&" + entity);
								entity.Remove(0, entity.Length);
								break;

							default:
								entity.Append(text[i]);
								if (entity.Length>_maxEntitySize)
								{
									// unknown stuff, just don't touch it
									state = ParseState.Text;
									sb.Append("&" + entity);
									entity.Remove(0, entity.Length);
								}
								break;

						}
						break;
				}
			}

			// finish the work
			if (state == ParseState.EntityStart)
			{
				sb.Append("&" + entity);
			}
			return sb.ToString();
		}

		private enum ParseState
		{
			Text,
			EntityStart
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HtmlAgilityPack\HtmlAgilityPack\HtmlDocument.cs ===
// HtmlAgilityPack V1.0 - Simon Mourier <simon underscore mourier at hotmail dot com>
using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections;
using System.Text.RegularExpressions;
using System.Xml;
using System.Xml.XPath;

namespace Test.Common.Library.HtmlAgilityPack
{

	/// <summary>
	/// Represents a complete HTML document.
	/// </summary>
	public class HtmlDocument: IXPathNavigable
	{
		internal static readonly string HtmlExceptionRefNotChild = "Reference node must be a child of this node";
		internal static readonly string HtmlExceptionUseIdAttributeFalse = "You need to set UseIdAttribute property to true to enable this feature";

		internal Hashtable _openednodes;
		internal Hashtable _lastnodes = new Hashtable();
		internal Hashtable _nodesid;
		private HtmlNode _documentnode;
		internal string _text;
		private string _remainder;
		private int _remainderOffset;
		private HtmlNode _currentnode;
		private HtmlNode _lastparentnode;
		private HtmlAttribute _currentattribute;
		private int _index;
		private int _line;
		private int _lineposition, _maxlineposition;
		private int _c;
		private bool _fullcomment;
		private System.Text.Encoding _streamencoding;
		private System.Text.Encoding _declaredencoding;
		private ArrayList _parseerrors = new ArrayList();
		private ParseState _state, _oldstate;
		private Crc32 _crc32 = null;
		private bool _onlyDetectEncoding = false;

		// public props

		/// <summary>
		/// Defines if a checksum must be computed for the document while parsing. Default is false.
		/// </summary>
		public bool OptionComputeChecksum = false;

		/// <summary>
		/// Defines if declared encoding must be read from the document.
		/// Declared encoding is determined using the meta http-equiv="content-type" content="text/html;charset=XXXXX" html node.
		/// Default is true.
		/// </summary>
		public bool OptionReadEncoding = true;


		/// <summary>
		/// Defines if non closed nodes will be checked at the end of parsing. Default is true.
		/// </summary>
		public bool OptionCheckSyntax = true;

		/// <summary>
		/// Defines if the 'id' attribute must be specifically used. Default is true.
		/// </summary>
		public bool OptionUseIdAttribute = true;

		/// <summary>
		/// Defines if empty nodes must be written as closed during output. Default is false.
		/// </summary>
		public bool OptionWriteEmptyNodes = false;

		/// <summary>
		/// Defines if output must conform to XML, instead of HTML.
		/// </summary>
		public bool OptionOutputAsXml = false;

		/// <summary>
		/// Defines if name must be output in uppercase. Default is false.
		/// </summary>
		public bool OptionOutputUpperCase = false;

		/// <summary>
		/// Defines if attribute value output must be optimized (not bound with double quotes if it is possible). Default is false.
		/// </summary>
		public bool OptionOutputOptimizeAttributeValues = false;

		/// <summary>
		/// Adds Debugging attributes to node. Default is false.
		/// </summary>
		public bool OptionAddDebuggingAttributes = false;

		/// <summary>
		/// Defines if source text must be extracted while parsing errors.
		/// If the document has a lot of errors, or cascading errors, parsing performance can be dramatically affected if set to true.
		/// Default is false.
		/// </summary>
		public bool OptionExtractErrorSourceText = false; // turning this on can dramatically slow performance if a lot of errors are detected

		/// <summary>
		/// Defines if closing for non closed nodes must be done at the end or directly in the document.
		/// Setting this to true can actually change how browsers render the page. Default is false.
		/// </summary>
		public bool OptionAutoCloseOnEnd = false; // close errors at the end

		/// <summary>
		/// Defines if LI, TR, TH, TD tags must be partially fixed when nesting errors are detected. Default is false.
		/// </summary>
		public bool OptionFixNestedTags = false; // fix li, tr, th, td tags

		/// <summary>
		/// Defines the maximum length of source text or parse errors. Default is 100.
		/// </summary>
		public int OptionExtractErrorSourceTextMaxLength = 100;

		/// <summary>
		/// Defines the default stream encoding to use. Default is System.Text.Encoding.Default.
		/// </summary>
		public System.Text.Encoding OptionDefaultStreamEncoding = System.Text.Encoding.Default;

		/// <summary>
		/// Defines the name of a node that will throw the StopperNodeException when found as an end node. Default is null.
		/// </summary>
		public string OptionStopperNodeName = null;

		/// <summary>
		/// Gets the remaining text.
		/// Will always be null if OptionStopperNodeName is null.
		/// </summary>
		public string Remainder
		{
			get
			{
				return _remainder;
			}
		}

		/// <summary>
		/// Gets the offset of Remainder in the original Html text.
		/// If OptionStopperNodeName is null, this will return the length of the original Html text.
		/// </summary>
		public int RemainderOffset
		{
			get
			{
				return _remainderOffset;
			}
		}

		/// <summary>
		/// Gets a list of parse errors found in the document.
		/// </summary>
		public ArrayList ParseErrors
		{
			get
			{
				return _parseerrors;
			}
		}

		/// <summary>
		/// Gets the document's stream encoding.
		/// </summary>
		public System.Text.Encoding StreamEncoding
		{
			get
			{
				return _streamencoding;
			}
		}

		/// <summary>
		/// Gets the document's declared encoding.
		/// Declared encoding is determined using the meta http-equiv="content-type" content="text/html;charset=XXXXX" html node.
		/// </summary>
		public System.Text.Encoding DeclaredEncoding
		{
			get
			{
				return _declaredencoding;
			}
		}

		/// <summary>
		/// Creates an instance of an HTML document.
		/// </summary>
		public HtmlDocument()
		{
			_documentnode = CreateNode(HtmlNodeType.Document, 0);
		}

		internal HtmlNode GetXmlDeclaration()
		{
			if (!_documentnode.HasChildNodes)
			{
				return null;
			}

			foreach(HtmlNode node in _documentnode._childnodes)
			{
				if (node.Name == "?xml") // it's ok, names are case sensitive
				{
					return node;
				}
			}
			return null;
		}

		/// <summary>
		/// Applies HTML encoding to a specified string.
		/// </summary>
		/// <param name="html">The input string to encode. May not be null.</param>
		/// <returns>The encoded string.</returns>
		public static string HtmlEncode(string html)
		{
			if (html == null)
			{
				throw new ArgumentNullException("html");
			}
			// replace & by &amp; but only once!
			Regex rx = new Regex("&(?!(amp;)|(lt;)|(gt;)|(quot;))", RegexOptions.IgnoreCase);
			return rx.Replace(html, "&amp;").Replace("<", "&lt;").Replace(">", "&gt;").Replace("\"", "&quot;");
		}

		/// <summary>
		/// Detects the encoding of an HTML stream.
		/// </summary>
		/// <param name="stream">The input stream. May not be null.</param>
		/// <returns>The detected encoding.</returns>
		public Encoding DetectEncoding(Stream stream)
		{
			if (stream == null)
			{
				throw new ArgumentNullException("stream");
			}
			return DetectEncoding(new StreamReader(stream));
		}

		/// <summary>
		/// Detects the encoding of an HTML file.
		/// </summary>
		/// <param name="path">Path for the file containing the HTML document to detect. May not be null.</param>
		/// <returns>The detected encoding.</returns>
		public Encoding DetectEncoding(string path)
		{
			if (path == null)
			{
				throw new ArgumentNullException("path");
			}
			StreamReader sr = new StreamReader(path, OptionDefaultStreamEncoding);
			Encoding encoding = DetectEncoding(sr);
			sr.Close();
			return encoding;
		}

		/// <summary>
		/// Detects the encoding of an HTML text.
		/// </summary>
		/// <param name="html">The input html text. May not be null.</param>
		/// <returns>The detected encoding.</returns>
		public Encoding DetectEncodingHtml(string html)
		{
			if (html == null)
			{
				throw new ArgumentNullException("html");
			}
			StringReader sr = new StringReader(html);
			Encoding encoding = DetectEncoding(sr);
			sr.Close();
			return encoding;
		}

		/// <summary>
		/// Detects the encoding of an HTML text provided on a TextReader.
		/// </summary>
		/// <param name="reader">The TextReader used to feed the HTML. May not be null.</param>
		/// <returns>The detected encoding.</returns>
		public Encoding DetectEncoding(TextReader reader)
		{
			if (reader == null)
			{
				throw new ArgumentNullException("reader");
			}
			_onlyDetectEncoding = true;
			if (OptionCheckSyntax)
			{
				_openednodes = new Hashtable();
			}
			else
			{
				_openednodes = null;
			}

			if (OptionUseIdAttribute)
			{
				_nodesid = new Hashtable();
			}
			else
			{
				_nodesid = null;
			}

			StreamReader sr = reader as StreamReader;
			if (sr != null)
			{
				_streamencoding = sr.CurrentEncoding;
			}
			else
			{
				_streamencoding = null;
			}
			_declaredencoding = null;

			_text = reader.ReadToEnd();
			_documentnode = CreateNode(HtmlNodeType.Document, 0);

			// this is almost a hack, but it allows us not to muck with the original parsing code
			try
			{
				Parse();
			}
			catch(EncodingFoundException ex)
			{
				return ex.Encoding;
			}
			return null;
		}

		/// <summary>
		/// Loads an HTML document from a stream.
		/// </summary>
		/// <param name="stream">The input stream.</param>
		public void Load(Stream stream)
		{
			Load(new StreamReader(stream, OptionDefaultStreamEncoding));
		}

		/// <summary>
		/// Loads an HTML document from a stream.
		/// </summary>
		/// <param name="stream">The input stream.</param>
		/// <param name="detectEncodingFromByteOrderMarks">Indicates whether to look for byte order marks at the beginning of the stream.</param>
		public void Load(Stream stream, bool detectEncodingFromByteOrderMarks)
		{
			Load(new StreamReader(stream, detectEncodingFromByteOrderMarks));
		}

		/// <summary>
		/// Loads an HTML document from a stream.
		/// </summary>
		/// <param name="stream">The input stream.</param>
		/// <param name="encoding">The character encoding to use.</param>
		public void Load(Stream stream, Encoding encoding)
		{
			Load(new StreamReader(stream, encoding));
		}

		/// <summary>
		/// Loads an HTML document from a stream.
		/// </summary>
		/// <param name="stream">The input stream.</param>
		/// <param name="encoding">The character encoding to use.</param>
		/// <param name="detectEncodingFromByteOrderMarks">Indicates whether to look for byte order marks at the beginning of the stream.</param>
		public void Load(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks)
		{
			Load(new StreamReader(stream, encoding, detectEncodingFromByteOrderMarks));
		}

		/// <summary>
		/// Loads an HTML document from a stream.
		/// </summary>
		/// <param name="stream">The input stream.</param>
		/// <param name="encoding">The character encoding to use.</param>
		/// <param name="detectEncodingFromByteOrderMarks">Indicates whether to look for byte order marks at the beginning of the stream.</param>
		/// <param name="buffersize">The minimum buffer size.</param>
		public void Load(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks, int buffersize)
		{
			Load(new StreamReader(stream, encoding, detectEncodingFromByteOrderMarks, buffersize));
		}

		/// <summary>
		/// Loads an HTML document from a file.
		/// </summary>
		/// <param name="path">The complete file path to be read. May not be null.</param>
		public void Load(string path)
		{
			if (path == null)
			{
				throw new ArgumentNullException("path");
			}
			StreamReader sr = new StreamReader(path, OptionDefaultStreamEncoding);
			Load(sr);
			sr.Close();
		}

		/// <summary>
		/// Loads an HTML document from a file.
		/// </summary>
		/// <param name="path">The complete file path to be read. May not be null.</param>
		/// <param name="detectEncodingFromByteOrderMarks">Indicates whether to look for byte order marks at the beginning of the file.</param>
		public void Load(string path, bool detectEncodingFromByteOrderMarks)
		{
			if (path == null)
			{
				throw new ArgumentNullException("path");
			}
			StreamReader sr = new StreamReader(path, detectEncodingFromByteOrderMarks);
			Load(sr);
			sr.Close();
		}

		/// <summary>
		/// Loads an HTML document from a file.
		/// </summary>
		/// <param name="path">The complete file path to be read. May not be null.</param>
		/// <param name="encoding">The character encoding to use. May not be null.</param>
		public void Load(string path, Encoding encoding)
		{
			if (path == null)
			{
				throw new ArgumentNullException("path");
			}
			if (encoding == null)
			{
				throw new ArgumentNullException("encoding");
			}
			StreamReader sr = new StreamReader(path, encoding);
			Load(sr);
			sr.Close();
		}

		/// <summary>
		/// Loads an HTML document from a file.
		/// </summary>
		/// <param name="path">The complete file path to be read. May not be null.</param>
		/// <param name="encoding">The character encoding to use. May not be null.</param>
		/// <param name="detectEncodingFromByteOrderMarks">Indicates whether to look for byte order marks at the beginning of the file.</param>
		public void Load(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks)
		{
			if (path == null)
			{
				throw new ArgumentNullException("path");
			}
			if (encoding == null)
			{
				throw new ArgumentNullException("encoding");
			}
			StreamReader sr = new StreamReader(path, encoding, detectEncodingFromByteOrderMarks);
			Load(sr);
			sr.Close();
		}

		/// <summary>
		/// Loads an HTML document from a file.
		/// </summary>
		/// <param name="path">The complete file path to be read. May not be null.</param>
		/// <param name="encoding">The character encoding to use. May not be null.</param>
		/// <param name="detectEncodingFromByteOrderMarks">Indicates whether to look for byte order marks at the beginning of the file.</param>
		/// <param name="buffersize">The minimum buffer size.</param>
		public void Load(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks, int buffersize)
		{
			if (path == null)
			{
				throw new ArgumentNullException("path");
			}
			if (encoding == null)
			{
				throw new ArgumentNullException("encoding");
			}
			StreamReader sr = new StreamReader(path, encoding, detectEncodingFromByteOrderMarks, buffersize);
			Load(sr);
			sr.Close();
		}

		/// <summary>
		/// Loads the HTML document from the specified string.
		/// </summary>
		/// <param name="html">String containing the HTML document to load. May not be null.</param>
		public void LoadHtml(string html)
		{
			if (html == null)
			{
				throw new ArgumentNullException("html");
			}
			StringReader sr = new StringReader(html);
			Load(sr);
			sr.Close();
		}

		/// <summary>
		/// Detects the encoding of an HTML document from a file first, and then loads the file.
		/// </summary>
		/// <param name="path">The complete file path to be read.</param>
		public void DetectEncodingAndLoad(string path)
		{
			DetectEncodingAndLoad(path, true);
		}

		/// <summary>
		/// Detects the encoding of an HTML document from a file first, and then loads the file.
		/// </summary>
		/// <param name="path">The complete file path to be read. May not be null.</param>
		/// <param name="detectEncoding">true to detect encoding, false otherwise.</param>
		public void DetectEncodingAndLoad(string path, bool detectEncoding)
		{
			if (path == null)
			{
				throw new ArgumentNullException("path");
			}
			System.Text.Encoding enc;
			if (detectEncoding)
			{
				enc = DetectEncoding(path);
			}
			else
			{
				enc = null;
			}

			if (enc == null)
			{
				Load(path);
			}
			else
			{
				Load(path, enc);
			}
		}

		/// <summary>
		/// Loads the HTML document from the specified TextReader.
		/// </summary>
		/// <param name="reader">The TextReader used to feed the HTML data into the document. May not be null.</param>
		public void Load(TextReader reader)
		{
			// all Load methods pass down to this one
			if (reader == null)
			{
				throw new ArgumentNullException("reader");
			}

			_onlyDetectEncoding = false;

			if (OptionCheckSyntax)
			{
				_openednodes = new Hashtable();
			}
			else
			{
				_openednodes = null;
			}

			if (OptionUseIdAttribute)
			{
				_nodesid = new Hashtable();
			}
			else
			{
				_nodesid = null;
			}

			StreamReader sr = reader as StreamReader;
			if (sr != null)
			{
				try
				{
					// trigger bom read if needed
					sr.Peek();
				}
				catch
				{
					// void on purpose
				}
				_streamencoding = sr.CurrentEncoding;
			}
			else
			{
				_streamencoding = null;
			}
			_declaredencoding = null;

			_text = reader.ReadToEnd();
			_documentnode = CreateNode(HtmlNodeType.Document, 0);
			Parse();

			if (OptionCheckSyntax)
			{
				foreach(HtmlNode node in _openednodes.Values)
				{
					if (!node._starttag)	// already reported
					{
						continue;
					}

					string html;
					if (OptionExtractErrorSourceText)
					{
						html = node.OuterHtml;
						if (html.Length > OptionExtractErrorSourceTextMaxLength)
						{
							html = html.Substring(0, OptionExtractErrorSourceTextMaxLength);
						}
					}
					else
					{
						html = string.Empty;
					}
					AddError(
						HtmlParseErrorCode.TagNotClosed,
						node._line, node._lineposition,
						node._streamposition, html,
						"End tag </" + node.Name + "> was not found");
				}

				// we don't need this anymore
				_openednodes.Clear();
			}
		}

		internal System.Text.Encoding GetOutEncoding()
		{
			// when unspecified, use the stream encoding first
			if (_declaredencoding != null)
			{
				return _declaredencoding;
			}
			else
			{
				if (_streamencoding != null)
				{
					return _streamencoding;
				}
			}
			return OptionDefaultStreamEncoding;
		}


		/// <summary>
		/// Gets the document's output encoding.
		/// </summary>
		public System.Text.Encoding Encoding
		{
			get
			{
				return GetOutEncoding();
			}
		}

		/// <summary>
		/// Saves the HTML document to the specified stream.
		/// </summary>
		/// <param name="outStream">The stream to which you want to save.</param>
		public void Save(Stream outStream)
		{
			StreamWriter sw = new StreamWriter(outStream, GetOutEncoding());
			Save(sw);
		}

		/// <summary>
		/// Saves the HTML document to the specified stream.
		/// </summary>
		/// <param name="outStream">The stream to which you want to save. May not be null.</param>
		/// <param name="encoding">The character encoding to use. May not be null.</param>
		public void Save(Stream outStream, System.Text.Encoding encoding)
		{
			if (outStream == null)
			{
				throw new ArgumentNullException("outStream");
			}
			if (encoding == null)
			{
				throw new ArgumentNullException("encoding");
			}
			StreamWriter sw = new StreamWriter(outStream, encoding);
			Save(sw);
		}

		/// <summary>
		/// Saves the mixed document to the specified file.
		/// </summary>
		/// <param name="filename">The location of the file where you want to save the document.</param>
		public void Save(string filename)
		{
			StreamWriter sw = new StreamWriter(filename, false, GetOutEncoding());
			Save(sw);
			sw.Close();
		}

		/// <summary>
		/// Saves the mixed document to the specified file.
		/// </summary>
		/// <param name="filename">The location of the file where you want to save the document. May not be null.</param>
		/// <param name="encoding">The character encoding to use. May not be null.</param>
		public void Save(string filename, System.Text.Encoding encoding)
		{
			if (filename == null)
			{
				throw new ArgumentNullException("filename");
			}
			if (encoding == null)
			{
				throw new ArgumentNullException("encoding");
			}
			StreamWriter sw = new StreamWriter(filename, false, encoding);
			Save(sw);
			sw.Close();
		}

		/// <summary>
		/// Saves the HTML document to the specified StreamWriter.
		/// </summary>
		/// <param name="writer">The StreamWriter to which you want to save.</param>
		public void Save(StreamWriter writer)
		{
			Save((TextWriter)writer);
		}

		/// <summary>
		/// Saves the HTML document to the specified TextWriter.
		/// </summary>
		/// <param name="writer">The TextWriter to which you want to save. May not be null.</param>
		public void Save(TextWriter writer)
		{
			if (writer == null)
			{
				throw new ArgumentNullException("writer");
			}
			DocumentNode.WriteTo(writer);
		}

		/// <summary>
		/// Saves the HTML document to the specified XmlWriter.
		/// </summary>
		/// <param name="writer">The XmlWriter to which you want to save.</param>
		public void Save(XmlWriter writer)
		{
			DocumentNode.WriteTo(writer);
			writer.Flush();
		}

		/// <summary>
		/// Creates a new XPathNavigator object for navigating this HTML document.
		/// </summary>
		/// <returns>An XPathNavigator object. The XPathNavigator is positioned on the root of the document.</returns>
		public XPathNavigator CreateNavigator()
		{
			return new HtmlNodeNavigator(this, _documentnode);
		}

		/// <summary>
		/// Gets a valid XML name.
		/// </summary>
		/// <param name="name">Any text.</param>
		/// <returns>A string that is a valid XML name.</returns>
		public static string GetXmlName(string name)
		{
			string xmlname = string.Empty;
			bool nameisok = true;
			for(int i=0;i<name.Length;i++)
			{
				// names are lcase
				// note: we are very limited here, too much?
				if (((name[i]>='a') && (name[i]<='z')) ||
					((name[i]>='0') && (name[i]<='9')) ||
					//					(name[i]==':') || (name[i]=='_') || (name[i]=='-') || (name[i]=='.')) // these are bads in fact
					(name[i]=='_') || (name[i]=='-') || (name[i]=='.'))
				{
					xmlname += name[i];
				}
				else
				{
					nameisok = false;
					byte[] bytes = System.Text.Encoding.UTF8.GetBytes(new char[]{name[i]});
					for(int j=0;j<bytes.Length;j++)
					{
						xmlname += bytes[j].ToString("x2");
					}
					xmlname += "_";
				}
															  
			}
			if (nameisok)
			{
				return xmlname;
			}
			return "_" + xmlname;
		}

		internal void SetIdForNode(HtmlNode node, string id)
		{
			if (!OptionUseIdAttribute)
			{
				return;
			}

			if ((_nodesid == null) || (id == null))
			{
				return;
			}

			if (node == null)
			{
				_nodesid.Remove(id.ToLower());
			}
			else
			{
				_nodesid[id.ToLower()] = node;
			}
		}

		/// <summary>
		/// Gets the HTML node with the specified 'id' attribute value.
		/// </summary>
		/// <param name="id">The attribute id to match. May not be null.</param>
		/// <returns>The HTML node with the matching id or null if not found.</returns>
		public HtmlNode GetElementbyId(string id)
		{
			if (id == null)
			{
				throw new ArgumentNullException("id");
			}
			if (_nodesid == null)
			{
				throw new Exception(HtmlExceptionUseIdAttributeFalse);
			}

			return _nodesid[id.ToLower()] as HtmlNode;
		}

		/// <summary>
		/// Creates an HTML element node with the specified name.
		/// </summary>
		/// <param name="name">The qualified name of the element. May not be null.</param>
		/// <returns>The new HTML node.</returns>
		public HtmlNode CreateElement(string name)
		{
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			HtmlNode node = CreateNode(HtmlNodeType.Element);
			node._name = name;
			return node;
		}

		/// <summary>
		/// Creates an HTML comment node.
		/// </summary>
		/// <returns>The new HTML comment node.</returns>
		public HtmlCommentNode CreateComment()
		{
			return (HtmlCommentNode)CreateNode(HtmlNodeType.Comment);
		}

		/// <summary>
		/// Creates an HTML comment node with the specified comment text.
		/// </summary>
		/// <param name="comment">The comment text. May not be null.</param>
		/// <returns>The new HTML comment node.</returns>
		public HtmlCommentNode CreateComment(string comment)
		{
			if (comment == null)
			{
				throw new ArgumentNullException("comment");
			}
			HtmlCommentNode c = CreateComment();
			c.Comment = comment;
			return c;
		}

		/// <summary>
		/// Creates an HTML text node.
		/// </summary>
		/// <returns>The new HTML text node.</returns>
		public HtmlTextNode CreateTextNode()
		{
			return (HtmlTextNode)CreateNode(HtmlNodeType.Text);
		}

		/// <summary>
		/// Creates an HTML text node with the specified text.
		/// </summary>
		/// <param name="text">The text of the node. May not be null.</param>
		/// <returns>The new HTML text node.</returns>
		public HtmlTextNode CreateTextNode(string text)
		{
			if (text == null)
			{
				throw new ArgumentNullException("text");
			}
			HtmlTextNode t = CreateTextNode();
			t.Text = text;
			return t;
		}

		internal HtmlNode CreateNode(HtmlNodeType type)
		{
			return CreateNode(type, -1);
		}

		internal HtmlNode CreateNode(HtmlNodeType type, int index)
		{
			switch (type)
			{
				case HtmlNodeType.Comment:
					return new HtmlCommentNode(this, index);

				case HtmlNodeType.Text:
					return new HtmlTextNode(this, index);

				default:
					return new HtmlNode(type, this, index);
			}
		}

		internal HtmlAttribute CreateAttribute()
		{
			return new HtmlAttribute(this);
		}

		/// <summary>
		/// Creates an HTML attribute with the specified name.
		/// </summary>
		/// <param name="name">The name of the attribute. May not be null.</param>
		/// <returns>The new HTML attribute.</returns>
		public HtmlAttribute CreateAttribute(string name)
		{
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			HtmlAttribute att = CreateAttribute();
			att.Name = name;
			return att;
		}

		/// <summary>
		/// Creates an HTML attribute with the specified name.
		/// </summary>
		/// <param name="name">The name of the attribute. May not be null.</param>
		/// <param name="value">The value of the attribute.</param>
		/// <returns>The new HTML attribute.</returns>
		public HtmlAttribute CreateAttribute(string name, string value)
		{
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			HtmlAttribute att = CreateAttribute(name);
			att.Value = value;
			return att;
		}

		/// <summary>
		/// Gets the root node of the document.
		/// </summary>
		public HtmlNode DocumentNode
		{
			get
			{
				return _documentnode;
			}
		}

		/// <summary>
		/// Gets the document CRC32 checksum if OptionComputeChecksum was set to true before parsing, 0 otherwise.
		/// </summary>
		public int CheckSum
		{
			get
			{
				if (_crc32 == null)
				{
					return 0;
				}
				else
				{
					return (int)_crc32.CheckSum;
				}
			}
		}

		private HtmlParseError AddError(
				HtmlParseErrorCode code,
				int line,
				int linePosition,
				int streamPosition,
				string sourceText,
				string reason)
			{
			HtmlParseError err = new HtmlParseError(code, line, linePosition, streamPosition, sourceText, reason);
			_parseerrors.Add(err);
			return err;
		}


		private enum ParseState
		{
			Text,
			WhichTag,
			Tag,
			BetweenAttributes,
			EmptyTag,
			AttributeName,
			AttributeBeforeEquals,
			AttributeAfterEquals,
			AttributeValue,
			Comment,
			QuotedAttributeValue,
			ServerSideCode,
			PcData
		}

		private void IncrementPosition()
		{
			if (_crc32 != null)
			{
				// REVIEW: should we add some checksum code in DecrementPosition too?
				_crc32.AddToCRC32(_c);
			}

			_index++;
			_maxlineposition = _lineposition;
			if (_c == 10)
			{
				_lineposition = 1;
				_line++;
			}
			else
			{
				_lineposition++;
			}
		}

		private void DecrementPosition()
		{
			_index--;
			if (_lineposition == 1)
			{
				_lineposition = _maxlineposition;
				_line--;
			}
			else
			{
				_lineposition--;
			}
		}

		private void Parse()
		{
			int lastquote = 0;
			if (OptionComputeChecksum)
			{
				_crc32 = new Crc32();
			}

			_lastnodes = new Hashtable();
			_c = 0;
			_fullcomment = false;
			_parseerrors = new ArrayList();
			_line = 1;
			_lineposition = 1;
			_maxlineposition = 1;

			_state = ParseState.Text;
			_oldstate = _state;
			_documentnode._innerlength = _text.Length;
			_documentnode._outerlength = _text.Length;
			_remainderOffset = _text.Length;

			_lastparentnode = _documentnode;
			_currentnode = CreateNode(HtmlNodeType.Text, 0);
			_currentattribute = null;

			_index = 0;
			PushNodeStart(HtmlNodeType.Text, 0);
			while (_index<_text.Length)
			{
				_c = _text[_index];
				IncrementPosition();

				switch(_state)
				{
					case ParseState.Text:
						if (NewCheck())
							continue;
						break;

					case ParseState.WhichTag:
						if (NewCheck())
							continue;
						if (_c == '/')
						{
							PushNodeNameStart(false, _index);
						}
						else
						{
							PushNodeNameStart(true, _index-1);
							DecrementPosition();
						}
						_state = ParseState.Tag;
						break;

					case ParseState.Tag:
						if (NewCheck())
							continue;
						if (IsWhiteSpace(_c))
						{
							PushNodeNameEnd(_index-1);
							if (_state != ParseState.Tag)
								continue;
							_state = ParseState.BetweenAttributes;
							continue;
						}
						if (_c == '/')
						{
							PushNodeNameEnd(_index-1);
							if (_state != ParseState.Tag)
								continue;
							_state = ParseState.EmptyTag;
							continue;
						}
						if (_c == '>')
						{
							PushNodeNameEnd(_index-1);
							if (_state != ParseState.Tag)
								continue;
							if (!PushNodeEnd(_index, false))
							{
								// stop parsing
								_index = _text.Length;
								break;
							}
							if (_state != ParseState.Tag)
								continue;
							_state = ParseState.Text;
							PushNodeStart(HtmlNodeType.Text, _index);
						}
						break;

					case ParseState.BetweenAttributes:
						if (NewCheck())
							continue;

						if (IsWhiteSpace(_c))
							continue;

						if ((_c == '/') || (_c == '?'))
						{
							_state = ParseState.EmptyTag;
							continue;
						}

						if (_c == '>')
						{
							if (!PushNodeEnd(_index, false))
							{
								// stop parsing
								_index = _text.Length;
								break;
							}
									
							if (_state != ParseState.BetweenAttributes)
								continue;
							_state = ParseState.Text;
							PushNodeStart(HtmlNodeType.Text, _index);
							continue;
						}

						PushAttributeNameStart(_index-1);
						_state = ParseState.AttributeName;
						break;

					case ParseState.EmptyTag:
						if (NewCheck())
							continue;

						if (_c == '>')
						{
							if (!PushNodeEnd(_index, true))
							{
								// stop parsing
								_index = _text.Length;
								break;
							}

							if (_state != ParseState.EmptyTag)
								continue;
							_state = ParseState.Text;
							PushNodeStart(HtmlNodeType.Text, _index);
							continue;
						}
						_state = ParseState.BetweenAttributes;
						break;

					case ParseState.AttributeName:
						if (NewCheck())
							continue;

						if (IsWhiteSpace(_c))
						{
							PushAttributeNameEnd(_index-1);
							_state = ParseState.AttributeBeforeEquals;
							continue;
						}
						if (_c == '=')
						{
							PushAttributeNameEnd(_index-1);
							_state = ParseState.AttributeAfterEquals;
							continue;
						}
						if (_c == '>')
						{
							PushAttributeNameEnd(_index-1);
							if (!PushNodeEnd(_index, false))
							{
								// stop parsing
								_index = _text.Length;
								break;
							}
							if (_state != ParseState.AttributeName)
								continue;
							_state = ParseState.Text;
							PushNodeStart(HtmlNodeType.Text, _index);
							continue;
						}
						break;

					case ParseState.AttributeBeforeEquals:
						if (NewCheck())
							continue;

						if (IsWhiteSpace(_c))
							continue;
						if (_c == '>')
						{
							if (!PushNodeEnd(_index, false))
							{
								// stop parsing
								_index = _text.Length;
								break;
							}
							if (_state != ParseState.AttributeBeforeEquals)
								continue;
							_state = ParseState.Text;
							PushNodeStart(HtmlNodeType.Text, _index);
							continue;
						}
						if (_c == '=')
						{
							_state = ParseState.AttributeAfterEquals;
							continue;
						}
						// no equals, no whitespace, it's a new attrribute starting
						_state = ParseState.BetweenAttributes;
						DecrementPosition();
						break;

					case ParseState.AttributeAfterEquals:
						if (NewCheck())
							continue;

						if (IsWhiteSpace(_c))
							continue;

						if ((_c == '\'') || (_c == '"'))
						{
							_state = ParseState.QuotedAttributeValue;
							PushAttributeValueStart(_index);
							lastquote = _c;
							continue;
						}
						if (_c == '>')
						{
							if (!PushNodeEnd(_index, false))
							{
								// stop parsing
								_index = _text.Length;
								break;
							}
							if (_state != ParseState.AttributeAfterEquals)
								continue;
							_state = ParseState.Text;
							PushNodeStart(HtmlNodeType.Text, _index);
							continue;
						}
						PushAttributeValueStart(_index-1);
						_state = ParseState.AttributeValue;
						break;

					case ParseState.AttributeValue:
						if (NewCheck())
							continue;

						if (IsWhiteSpace(_c))
						{
							PushAttributeValueEnd(_index-1);
							_state = ParseState.BetweenAttributes;
							continue;
						}

						if (_c == '>')
						{
							PushAttributeValueEnd(_index-1);
							if (!PushNodeEnd(_index, false))
							{
								// stop parsing
								_index = _text.Length;
								break;
							}
							if (_state != ParseState.AttributeValue)
								continue;
							_state = ParseState.Text;
							PushNodeStart(HtmlNodeType.Text, _index);
							continue;
						}
						break;

					case ParseState.QuotedAttributeValue:
						if (_c == lastquote)
						{
							PushAttributeValueEnd(_index-1);
							_state = ParseState.BetweenAttributes;
							continue;
						}
						if (_c == '<')
						{
							if (_index<_text.Length)
							{
								if (_text[_index] == '%')
								{
									_oldstate = _state;
									_state = ParseState.ServerSideCode;
									continue;
								}
							}
						}
						break;

					case ParseState.Comment:
						if (_c == '>')
						{
							if (_fullcomment)
							{
								if ((_text[_index-2] != '-') ||
									(_text[_index-3] != '-'))
								{
									continue;
								}
							}
							if (!PushNodeEnd(_index, false))
							{
								// stop parsing
								_index = _text.Length;
								break;
							}
							_state = ParseState.Text;
							PushNodeStart(HtmlNodeType.Text, _index);
							continue;
						}
						break;

					case ParseState.ServerSideCode:
						if (_c == '%')
						{
							if (_index<_text.Length)
							{
								if (_text[_index] == '>')
								{
									switch(_oldstate)
									{
										case ParseState.AttributeAfterEquals:
											_state = ParseState.AttributeValue;
											break;

										case ParseState.BetweenAttributes:
											PushAttributeNameEnd(_index+1);
											_state = ParseState.BetweenAttributes;
											break;

										default:
											_state = _oldstate;
											break;
									}
									IncrementPosition();
								}
							}
						}
						break;

					case ParseState.PcData:
						// look for </tag + 1 char

						// check buffer end
						if ((_currentnode._namelength+3)<=(_text.Length-(_index-1)))
						{
							if (string.Compare(_text.Substring(_index-1, _currentnode._namelength+2),
								"</" + _currentnode.Name, true) == 0)
							{
								int c = _text[_index-1 + 2 + _currentnode.Name.Length];
								if ((c == '>') || (IsWhiteSpace(c)))
								{
									// add the script as a text node
									HtmlNode script = CreateNode(HtmlNodeType.Text,
										_currentnode._outerstartindex + _currentnode._outerlength);
									script._outerlength = _index-1 - script._outerstartindex;
									_currentnode.AppendChild(script);


									PushNodeStart(HtmlNodeType.Element, _index-1);
									PushNodeNameStart(false, _index-1 +2);
									_state = ParseState.Tag;
									IncrementPosition();
								}
							}
						}
						break;
				}
			}

			// finish the current work
			if (_currentnode._namestartindex > 0)
			{
				PushNodeNameEnd(_index);
			}
			PushNodeEnd(_index, false);

			// we don't need this anymore
			_lastnodes.Clear();
		}

		private bool NewCheck()
		{
			if (_c != '<')
			{
				return false;
			}
			if (_index<_text.Length)
			{
				if (_text[_index] == '%')
				{
					switch(_state)
					{
						case ParseState.AttributeAfterEquals:
                            PushAttributeValueStart(_index-1);
							break;

						case ParseState.BetweenAttributes:
							PushAttributeNameStart(_index-1);
							break;

						case ParseState.WhichTag:
							PushNodeNameStart(true, _index-1);
							_state = ParseState.Tag;
							break;
					}
					_oldstate = _state;
					_state = ParseState.ServerSideCode;
					return true;
				}
			}

			if (!PushNodeEnd(_index-1, true))
			{
				// stop parsing
				_index = _text.Length;
				return true;
			}
			_state = ParseState.WhichTag;
			if ((_index-1) <= (_text.Length-2))
			{
				if (_text[_index] == '!')
				{
					PushNodeStart(HtmlNodeType.Comment, _index-1);
					PushNodeNameStart(true, _index);
					PushNodeNameEnd(_index+1);
					_state = ParseState.Comment;
					if (_index<(_text.Length-2))
					{
						if ((_text[_index+1] == '-') &&
							(_text[_index+2] == '-'))
						{
							_fullcomment = true;
						}
						else
						{
							_fullcomment = false;
						}
					}
					return true;
				}
			}
			PushNodeStart(HtmlNodeType.Element, _index-1);
			return true;
		}

		private void ReadDocumentEncoding(HtmlNode node)
		{
			if (!OptionReadEncoding)
				return;
			// format is 
			// <meta http-equiv="content-type" content="text/html;charset=iso-8859-1" />
			
			// when we append a child, we are in node end, so attributes are already populated
			if (node._namelength == 4)	// quick check, avoids string alloc
			{
				if (node.Name == "meta") // all nodes names are lowercase
				{
					HtmlAttribute att = node.Attributes["http-equiv"];
					if (att != null)
					{
						if (string.Compare(att.Value, "content-type", true) == 0)
						{
							HtmlAttribute content = node.Attributes["content"];
							if (content != null)
							{
								string charset = NameValuePairList.GetNameValuePairsValue(content.Value, "charset");
								if (charset != null)
								{
									_declaredencoding = Encoding.GetEncoding(charset);
									if (_onlyDetectEncoding)
									{
										throw new EncodingFoundException(_declaredencoding);
									}

									if (_streamencoding != null)
									{
										if (_declaredencoding.WindowsCodePage != _streamencoding.WindowsCodePage)
										{
											AddError(
												HtmlParseErrorCode.CharsetMismatch,
												_line, _lineposition,
												_index, node.OuterHtml,
												"Encoding mismatch between StreamEncoding: " +
												_streamencoding.WebName + " and DeclaredEncoding: " + _declaredencoding.WebName);
										}
									}
								}
							}
						}
					}
				}
			}
		}

		private void PushAttributeNameStart(int index)
		{
			_currentattribute = CreateAttribute();
			_currentattribute._namestartindex = index;
			_currentattribute._line = _line;
			_currentattribute._lineposition = _lineposition;
			_currentattribute._streamposition = index;
		}

		private void PushAttributeNameEnd(int index)
		{
			_currentattribute._namelength = index - _currentattribute._namestartindex;
			_currentnode.Attributes.Append(_currentattribute);
		}

		private void PushAttributeValueStart(int index)
		{
			_currentattribute._valuestartindex = index;
		}

		private void PushAttributeValueEnd(int index)
		{
			_currentattribute._valuelength = index - _currentattribute._valuestartindex;
		}

		private void PushNodeStart(HtmlNodeType type, int index)
		{
			_currentnode = CreateNode(type, index);
			_currentnode._line = _line;
			_currentnode._lineposition = _lineposition;
			if (type == HtmlNodeType.Element)
			{
				_currentnode._lineposition--;
			}
			_currentnode._streamposition = index;
		}

		private bool PushNodeEnd(int index, bool close)
		{
			_currentnode._outerlength = index - _currentnode._outerstartindex;

			if ((_currentnode._nodetype == HtmlNodeType.Text) ||
				(_currentnode._nodetype == HtmlNodeType.Comment))
			{
				// forget about void nodes
				if (_currentnode._outerlength>0)
				{
					_currentnode._innerlength = _currentnode._outerlength;
					_currentnode._innerstartindex = _currentnode._outerstartindex;
					if (_lastparentnode != null)
					{
						_lastparentnode.AppendChild(_currentnode);
					}
				}
			}
			else
			{
				if ((_currentnode._starttag) && (_lastparentnode != _currentnode))
				{
					// add to parent node
					if (_lastparentnode != null)
					{
						_lastparentnode.AppendChild(_currentnode);
					}

					ReadDocumentEncoding(_currentnode);

					// remember last node of this kind
					HtmlNode prev = (HtmlNode)_lastnodes[_currentnode.Name];
					_currentnode._prevwithsamename = prev;
					_lastnodes[_currentnode.Name] = _currentnode;

					// change parent?
					if ((_currentnode.NodeType == HtmlNodeType.Document) ||
						(_currentnode.NodeType == HtmlNodeType.Element))
					{
						_lastparentnode = _currentnode;
					}

					if (HtmlNode.IsCDataElement(CurrentNodeName()))
					{
						_state = ParseState.PcData;
						return true;
					}

					if ((HtmlNode.IsClosedElement(_currentnode.Name)) ||
						(HtmlNode.IsEmptyElement(_currentnode.Name)))
					{
						close = true;
					}
				}
			}

			if ((close) || (!_currentnode._starttag))
			{
				if ((OptionStopperNodeName != null) && (_remainder == null) &&
					(string.Compare(_currentnode.Name, OptionStopperNodeName, true) == 0))
				{
					_remainderOffset = index;
					_remainder = _text.Substring(_remainderOffset);
					CloseCurrentNode();
					return false; // stop parsing
				}
				CloseCurrentNode();
			}
			return true;
		}

		private void PushNodeNameStart(bool starttag, int index)
		{
			_currentnode._starttag = starttag;
			_currentnode._namestartindex = index;
		}

		private string[] GetResetters(string name)
		{
			switch (name)
			{
				case "li":
					return new string[]{"ul"};

				case "tr":
					return new string[]{"table"};

				case "th":
				case "td":
					return new string[]{"tr", "table"};

				default:
					return null;
			}
		}

		private void FixNestedTags()
		{
			// we are only interested by start tags, not closing tags
			if (!_currentnode._starttag)
				return;

			string name = CurrentNodeName().ToLower();
			FixNestedTag(name, GetResetters(name));
		}
		
		private void FixNestedTag(string name, string[] resetters)
		{
			if (resetters == null)
				return;

			HtmlNode prev;
					
			// if we find a previous unclosed same name node, without a resetter node between, we must close it
			prev = (HtmlNode)_lastnodes[name];
			if ((prev != null) && (!prev.Closed))
			{

				// try to find a resetter node, if found, we do nothing
				if (FindResetterNodes(prev, resetters))
				{
					return;
				}

				// ok we need to close the prev now
				// create a fake closer node
				HtmlNode close = new HtmlNode(prev.NodeType, this, -1);
				close._endnode = close;
				prev.CloseNode(close);

			}
		}

		private bool FindResetterNodes(HtmlNode node, string[] names)
		{
			if (names == null)
			{
				return false;
			}
			for(int i=0;i<names.Length;i++)
			{
				if (FindResetterNode(node, names[i]) != null)
				{
					return true;
				}
			}
			return false;
		}

		private HtmlNode FindResetterNode(HtmlNode node, string name)
		{
			HtmlNode resetter = (HtmlNode)_lastnodes[name];
			if (resetter == null)
				return null;
			if (resetter.Closed)
			{
				return null;
			}
			if (resetter._streamposition<node._streamposition)
			{
				return null;
			}
			return resetter;
		}

		private void PushNodeNameEnd(int index)
		{
			_currentnode._namelength = index - _currentnode._namestartindex;
			if (OptionFixNestedTags)
			{
				FixNestedTags();
			}
		}

		private void CloseCurrentNode()
		{
			if (_currentnode.Closed) // text or document are by def closed
				return;

			bool error = false;

			// find last node of this kind
			HtmlNode prev = (HtmlNode)_lastnodes[_currentnode.Name];
			if (prev == null)
			{
				if (HtmlNode.IsClosedElement(_currentnode.Name))
				{
					// </br> will be seen as <br>
					_currentnode.CloseNode(_currentnode);

					// add to parent node
					if (_lastparentnode != null)
					{
						HtmlNode foundNode = null;
						Stack futureChild = new Stack();
						for (HtmlNode node = _lastparentnode.LastChild; node != null; node = node.PreviousSibling)
						{
							if ((node.Name == _currentnode.Name) && (! node.HasChildNodes))
							{
								foundNode = node;
								break;
							}
							futureChild.Push(node);
						}
						if (foundNode != null)
						{
							HtmlNode node = null;
							while(futureChild.Count != 0) 
							{
								node = (HtmlNode)futureChild.Pop();
								_lastparentnode.RemoveChild(node);
								foundNode.AppendChild(node);
							}
						}
						else
						{
							_lastparentnode.AppendChild(_currentnode);
						}

					}
				}
				else
				{
					// node has no parent
					// node is not a closed node

					if (HtmlNode.CanOverlapElement(_currentnode.Name))
					{
						// this is a hack: add it as a text node
						HtmlNode closenode = CreateNode(HtmlNodeType.Text, _currentnode._outerstartindex);
						closenode._outerlength = _currentnode._outerlength;
						((HtmlTextNode)closenode).Text = ((HtmlTextNode)closenode).Text.ToLower();
						if (_lastparentnode != null)
						{
							_lastparentnode.AppendChild(closenode);
						}

					}
					else
					{
						if (HtmlNode.IsEmptyElement(_currentnode.Name))
						{
							AddError(
								HtmlParseErrorCode.EndTagNotRequired,
								_currentnode._line, _currentnode._lineposition,
								_currentnode._streamposition, _currentnode.OuterHtml,
								"End tag </" + _currentnode.Name + "> is not required");
						}
						else
						{
							// node cannot overlap, node is not empty
							AddError(
								HtmlParseErrorCode.TagNotOpened,
								_currentnode._line, _currentnode._lineposition,
								_currentnode._streamposition, _currentnode.OuterHtml,
								"Start tag <" + _currentnode.Name + "> was not found");
							error = true;
						}
					}
				}
			}
			else
			{
				if (OptionFixNestedTags)
				{
					if (FindResetterNodes(prev, GetResetters(_currentnode.Name)))
					{
						AddError(
							HtmlParseErrorCode.EndTagInvalidHere,
							_currentnode._line, _currentnode._lineposition,
							_currentnode._streamposition, _currentnode.OuterHtml,
							"End tag </" + _currentnode.Name + "> invalid here");
						error = true;					
					}
				}

				if (!error)
				{
					_lastnodes[_currentnode.Name] = prev._prevwithsamename;
					prev.CloseNode(_currentnode);
				}
			}


			// we close this node, get grandparent
			if (!error)
			{
				if ((_lastparentnode != null) &&
					((!HtmlNode.IsClosedElement(_currentnode.Name)) || 
					(_currentnode._starttag)))
				{
					UpdateLastParentNode();
				}
			}
		}

		internal void UpdateLastParentNode()
		{
			do
			{
				if (_lastparentnode.Closed)
				{
					_lastparentnode = _lastparentnode.ParentNode;
				}
			}
			while ((_lastparentnode != null) && (_lastparentnode.Closed));
			if (_lastparentnode == null)
			{
				_lastparentnode = _documentnode;
			}
		}
		
		private string CurrentAttributeName()
		{
			return _text.Substring(_currentattribute._namestartindex, _currentattribute._namelength);
		}

		private string CurrentAttributeValue()
		{
			return _text.Substring(_currentattribute._valuestartindex, _currentattribute._valuelength);
		}

		private string CurrentNodeName()
		{
			return _text.Substring(_currentnode._namestartindex, _currentnode._namelength);
		}

		private string CurrentNodeOuter()
		{
			return _text.Substring(_currentnode._outerstartindex, _currentnode._outerlength);
		}

		private string CurrentNodeInner()
		{
			return _text.Substring(_currentnode._innerstartindex, _currentnode._innerlength);
		}

		/// <summary>
		/// Determines if the specified character is considered as a whitespace character.
		/// </summary>
		/// <param name="c">The character to check.</param>
		/// <returns>true if if the specified character is considered as a whitespace character.</returns>
		public static bool IsWhiteSpace(int c)
		{
			if ((c == 10) || (c == 13) || (c == 32) || (c == 9))
			{
				return true;
			}
			return false;
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HtmlAgilityPack\HtmlAgilityPack\HtmlWebException.cs ===
// HtmlAgilityPack V1.0 - Simon Mourier <simon underscore mourier at hotmail dot com>
using System;

namespace Test.Common.Library.HtmlAgilityPack
{
    /// <summary>
    /// Represents an exception thrown by the HtmlWeb utility class.
    /// </summary>
    public class HtmlWebException : Exception
    {
        /// <summary>
        /// Creates an instance of the HtmlWebException.
        /// </summary>
        /// <param name="message">The exception's message.</param>
        public HtmlWebException(string message)
            : base(message)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HtmlAgilityPack\HtmlAgilityPack\HtmlTextNode.cs ===
// HtmlAgilityPack V1.0 - Simon Mourier <simon underscore mourier at hotmail dot com>
using System;

namespace Test.Common.Library.HtmlAgilityPack
{
    /// <summary>
    /// Represents an HTML text node.
    /// </summary>
    public class HtmlTextNode : HtmlNode
    {
        private string _text;

        internal HtmlTextNode(HtmlDocument ownerdocument, int index)
            :
            base(HtmlNodeType.Text, ownerdocument, index)
        {
        }

        /// <summary>
        /// Gets or Sets the HTML between the start and end tags of the object. In the case of a text node, it is equals to OuterHtml.
        /// </summary>
        public override string InnerHtml
        {
            get
            {
                return OuterHtml;
            }
            set
            {
                _text = value;
            }
        }

        /// <summary>
        /// Gets or Sets the object and its content in HTML.
        /// </summary>
        public override string OuterHtml
        {
            get
            {
                if (_text == null)
                {
                    return base.OuterHtml;
                }
                return _text;
            }
        }

        /// <summary>
        /// Gets or Sets the text of the node.
        /// </summary>
        public string Text
        {
            get
            {
                if (_text == null)
                {
                    return base.OuterHtml;
                }
                return _text;
            }
            set
            {
                _text = value;
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HtmlAgilityPack\HtmlAgilityPack\IOLibrary.cs ===
// HtmlAgilityPack V1.0 - Simon Mourier <simon underscore mourier at hotmail dot com>
using System;
using System.IO;

namespace Test.Common.Library.HtmlAgilityPack
{
    internal struct IOLibrary
    {
        internal static void MakeWritable(string path)
        {
            if (!File.Exists(path))
                return;
            File.SetAttributes(path, File.GetAttributes(path) & ~FileAttributes.ReadOnly);
        }

        internal static void CopyAlways(string source, string target)
        {
            if (!File.Exists(source))
                return;
            Directory.CreateDirectory(Path.GetDirectoryName(target));
            MakeWritable(target);
            File.Copy(source, target, true);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HtmlAgilityPack\HtmlAgilityPack\MixedCodeDocumentFragmentList.cs ===
// HtmlAgilityPack V1.0 - Simon Mourier <simon underscore mourier at hotmail dot com>
using System;
using System.Collections;

namespace Test.Common.Library.HtmlAgilityPack
{
    /// <summary>
    /// Represents a list of mixed code fragments.
    /// </summary>
    public class MixedCodeDocumentFragmentList : IEnumerable
    {
        private MixedCodeDocument _doc;
        private ArrayList _items = new ArrayList();

        internal MixedCodeDocumentFragmentList(MixedCodeDocument doc)
        {
            _doc = doc;
        }

        /// <summary>
        /// Appends a fragment to the list of fragments.
        /// </summary>
        /// <param name="newFragment">The fragment to append. May not be null.</param>
        public void Append(MixedCodeDocumentFragment newFragment)
        {
            if (newFragment == null)
            {
                throw new ArgumentNullException("newFragment");
            }
            _items.Add(newFragment);
        }

        /// <summary>
        /// Prepends a fragment to the list of fragments.
        /// </summary>
        /// <param name="newFragment">The fragment to append. May not be null.</param>
        public void Prepend(MixedCodeDocumentFragment newFragment)
        {
            if (newFragment == null)
            {
                throw new ArgumentNullException("newFragment");
            }
            _items.Insert(0, newFragment);
        }

        /// <summary>
        /// Remove a fragment from the list of fragments. If this fragment was not in the list, an exception will be raised.
        /// </summary>
        /// <param name="fragment">The fragment to remove. May not be null.</param>
        public void Remove(MixedCodeDocumentFragment fragment)
        {
            if (fragment == null)
            {
                throw new ArgumentNullException("fragment");
            }
            int index = GetFragmentIndex(fragment);
            if (index == -1)
            {
                throw new IndexOutOfRangeException();
            }
            RemoveAt(index);
        }

        /// <summary>
        /// Remove a fragment from the list of fragments, using its index in the list.
        /// </summary>
        /// <param name="index">The index of the fragment to remove.</param>
        public void RemoveAt(int index)
        {
            MixedCodeDocumentFragment frag = (MixedCodeDocumentFragment)_items[index];
            _items.RemoveAt(index);
        }

        /// <summary>
        /// Remove all fragments from the list.
        /// </summary>
        public void RemoveAll()
        {
            _items.Clear();
        }

        /// <summary>
        /// Gets the number of fragments contained in the list.
        /// </summary>
        public int Count
        {
            get
            {
                return _items.Count;
            }
        }

        internal int GetFragmentIndex(MixedCodeDocumentFragment fragment)
        {
            if (fragment == null)
            {
                throw new ArgumentNullException("fragment");
            }
            for (int i = 0; i < _items.Count; i++)
            {
                if (((MixedCodeDocumentFragment)_items[i]) == fragment)
                {
                    return i;
                }
            }
            return -1;
        }

        /// <summary>
        /// Gets a fragment from the list using its index.
        /// </summary>
        public MixedCodeDocumentFragment this[int index]
        {
            get
            {
                return _items[index] as MixedCodeDocumentFragment;
            }
        }

        internal void Clear()
        {
            _items.Clear();
        }

        /// <summary>
        /// Gets an enumerator that can iterate through the fragment list.
        /// </summary>
        public MixedCodeDocumentFragmentEnumerator GetEnumerator()
        {
            return new MixedCodeDocumentFragmentEnumerator(_items);
        }

        /// <summary>
        /// Gets an enumerator that can iterate through the fragment list.
        /// </summary>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        /// <summary>
        /// Represents a fragment enumerator.
        /// </summary>
        public class MixedCodeDocumentFragmentEnumerator : IEnumerator
        {
            int _index;
            ArrayList _items;

            internal MixedCodeDocumentFragmentEnumerator(ArrayList items)
            {
                _items = items;
                _index = -1;
            }

            /// <summary>
            /// Sets the enumerator to its initial position, which is before the first element in the collection.
            /// </summary>
            public void Reset()
            {
                _index = -1;
            }

            /// <summary>
            /// Advances the enumerator to the next element of the collection.
            /// </summary>
            /// <returns>true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.</returns>
            public bool MoveNext()
            {
                _index++;
                return (_index < _items.Count);
            }

            /// <summary>
            /// Gets the current element in the collection.
            /// </summary>
            public MixedCodeDocumentFragment Current
            {
                get
                {
                    return (MixedCodeDocumentFragment)(_items[_index]);
                }
            }

            /// <summary>
            /// Gets the current element in the collection.
            /// </summary>
            object IEnumerator.Current
            {
                get
                {
                    return (Current);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HtmlAgilityPack\HtmlAgilityPack\MixedCodeDocument.cs ===
// HtmlAgilityPack V1.0 - Simon Mourier <simon underscore mourier at hotmail dot com>
using System;
using System.IO;
using System.Text;
using System.Collections;

namespace Test.Common.Library.HtmlAgilityPack
{
	/// <summary>
	/// Represents a document with mixed code and text. ASP, ASPX, JSP, are good example of such documents.
	/// </summary>
	public class MixedCodeDocument
	{
		private System.Text.Encoding _streamencoding = null;
		internal string _text;
		internal MixedCodeDocumentFragmentList _fragments;
		internal MixedCodeDocumentFragmentList _codefragments;
		internal MixedCodeDocumentFragmentList _textfragments;
		private ParseState _state;
		private int _index;
		private int _c;
		private int _line;
		private int _lineposition;
		private MixedCodeDocumentFragment _currentfragment;

		/// <summary>
		/// Gets or sets the token representing code start.
		/// </summary>
		public string TokenCodeStart = "<%";

		/// <summary>
		/// Gets or sets the token representing code end.
		/// </summary>
		public string TokenCodeEnd = "%>";

		/// <summary>
		/// Gets or sets the token representing code directive.
		/// </summary>
		public string TokenDirective = "@";

		/// <summary>
		/// Gets or sets the token representing response write directive.
		/// </summary>
		public string TokenResponseWrite = "Response.Write ";


		private string TokenTextBlock = "TextBlock({0})";

		/// <summary>
		/// Creates a mixed code document instance.
		/// </summary>
		public MixedCodeDocument()
		{
			_codefragments = new MixedCodeDocumentFragmentList(this);
			_textfragments = new MixedCodeDocumentFragmentList(this);
			_fragments = new MixedCodeDocumentFragmentList(this);
		}

		/// <summary>
		/// Loads a mixed code document from a stream.
		/// </summary>
		/// <param name="stream">The input stream.</param>
		public void Load(Stream stream)
		{
			Load(new StreamReader(stream));
		}

		/// <summary>
		/// Loads a mixed code document from a stream.
		/// </summary>
		/// <param name="stream">The input stream.</param>
		/// <param name="detectEncodingFromByteOrderMarks">Indicates whether to look for byte order marks at the beginning of the file.</param>
		public void Load(Stream stream, bool detectEncodingFromByteOrderMarks)
		{
			Load(new StreamReader(stream, detectEncodingFromByteOrderMarks));
		}

		/// <summary>
		/// Loads a mixed code document from a stream.
		/// </summary>
		/// <param name="stream">The input stream.</param>
		/// <param name="encoding">The character encoding to use.</param>
		public void Load(Stream stream, Encoding encoding)
		{
			Load(new StreamReader(stream, encoding));
		}

		/// <summary>
		/// Loads a mixed code document from a stream.
		/// </summary>
		/// <param name="stream">The input stream.</param>
		/// <param name="encoding">The character encoding to use.</param>
		/// <param name="detectEncodingFromByteOrderMarks">Indicates whether to look for byte order marks at the beginning of the file.</param>
		public void Load(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks)
		{
			Load(new StreamReader(stream, encoding, detectEncodingFromByteOrderMarks));
		}

		/// <summary>
		/// Loads a mixed code document from a stream.
		/// </summary>
		/// <param name="stream">The input stream.</param>
		/// <param name="encoding">The character encoding to use.</param>
		/// <param name="detectEncodingFromByteOrderMarks">Indicates whether to look for byte order marks at the beginning of the file.</param>
		/// <param name="buffersize">The minimum buffer size.</param>
		public void Load(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks, int buffersize)
		{
			Load(new StreamReader(stream, encoding, detectEncodingFromByteOrderMarks, buffersize));
		}

		/// <summary>
		/// Loads a mixed code document from a file.
		/// </summary>
		/// <param name="path">The complete file path to be read.</param>
		public void Load(string path)
		{
			Load(new StreamReader(path));
		}

		/// <summary>
		/// Loads a mixed code document from a file.
		/// </summary>
		/// <param name="path">The complete file path to be read.</param>
		/// <param name="detectEncodingFromByteOrderMarks">Indicates whether to look for byte order marks at the beginning of the file.</param>
		public void Load(string path, bool detectEncodingFromByteOrderMarks)
		{
			Load(new StreamReader(path, detectEncodingFromByteOrderMarks));
		}

		/// <summary>
		/// Loads a mixed code document from a file.
		/// </summary>
		/// <param name="path">The complete file path to be read.</param>
		/// <param name="encoding">The character encoding to use.</param>
		public void Load(string path, Encoding encoding)
		{
			Load(new StreamReader(path, encoding));
		}

		/// <summary>
		/// Loads a mixed code document from a file.
		/// </summary>
		/// <param name="path">The complete file path to be read.</param>
		/// <param name="encoding">The character encoding to use.</param>
		/// <param name="detectEncodingFromByteOrderMarks">Indicates whether to look for byte order marks at the beginning of the file.</param>
		public void Load(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks)
		{
			Load(new StreamReader(path, encoding, detectEncodingFromByteOrderMarks));
		}

		/// <summary>
		/// Loads a mixed code document from a file.
		/// </summary>
		/// <param name="path">The complete file path to be read.</param>
		/// <param name="encoding">The character encoding to use.</param>
		/// <param name="detectEncodingFromByteOrderMarks">Indicates whether to look for byte order marks at the beginning of the file.</param>
		/// <param name="buffersize">The minimum buffer size.</param>
		public void Load(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks, int buffersize)
		{
			Load(new StreamReader(path, encoding, detectEncodingFromByteOrderMarks, buffersize));
		}

		/// <summary>
		/// Loads a mixed document from a text
		/// </summary>
		/// <param name="html">The text to load.</param>
		public void LoadHtml(string html)
		{
			Load(new StringReader(html));
		}

		/// <summary>
		/// Loads the mixed code document from the specified TextReader.
		/// </summary>
		/// <param name="reader">The TextReader used to feed the HTML data into the document.</param>
		public void Load(TextReader reader)
		{
			_codefragments.Clear();
			_textfragments.Clear();

			// all pseudo constructors get down to this one
			StreamReader sr = reader as StreamReader;
			if (sr != null)
			{
				_streamencoding = sr.CurrentEncoding;
			}

			_text = reader.ReadToEnd();
			reader.Close();
			Parse();
		}

		internal System.Text.Encoding GetOutEncoding()
		{
			if (_streamencoding != null)
				return _streamencoding;
			return System.Text.Encoding.Default;
		}

		/// <summary>
		/// Gets the encoding of the stream used to read the document.
		/// </summary>
		public System.Text.Encoding StreamEncoding
		{
			get
			{
				return _streamencoding;
			}
		}

		/// <summary>
		/// Gets the list of code fragments in the document.
		/// </summary>
		public MixedCodeDocumentFragmentList CodeFragments
		{
			get
			{
				return _codefragments;
			}
		}

		/// <summary>
		/// Gets the list of text fragments in the document.
		/// </summary>
		public MixedCodeDocumentFragmentList TextFragments
		{
			get
			{
				return _textfragments;
			}
		}

		/// <summary>
		/// Gets the list of all fragments in the document.
		/// </summary>
		public MixedCodeDocumentFragmentList Fragments
		{
			get
			{
				return _fragments;
			}
		}

		/// <summary>
		/// Saves the mixed document to the specified stream.
		/// </summary>
		/// <param name="outStream">The stream to which you want to save.</param>
		public void Save(Stream outStream)
		{
			StreamWriter sw = new StreamWriter(outStream, GetOutEncoding());
			Save(sw);
		}

		/// <summary>
		/// Saves the mixed document to the specified stream.
		/// </summary>
		/// <param name="outStream">The stream to which you want to save.</param>
		/// <param name="encoding">The character encoding to use.</param>
		public void Save(Stream outStream, System.Text.Encoding encoding)
		{
			StreamWriter sw = new StreamWriter(outStream, encoding);
			Save(sw);
		}

		/// <summary>
		/// Saves the mixed document to the specified file.
		/// </summary>
		/// <param name="filename">The location of the file where you want to save the document.</param>
		public void Save(string filename)
		{
			StreamWriter sw = new StreamWriter(filename, false, GetOutEncoding());
			Save(sw);
		}

		/// <summary>
		/// Saves the mixed document to the specified file.
		/// </summary>
		/// <param name="filename">The location of the file where you want to save the document.</param>
		/// <param name="encoding">The character encoding to use.</param>
		public void Save(string filename, System.Text.Encoding encoding)
		{
			StreamWriter sw = new StreamWriter(filename, false, encoding);
			Save(sw);
		}

		/// <summary>
		/// Saves the mixed document to the specified StreamWriter.
		/// </summary>
		/// <param name="writer">The StreamWriter to which you want to save.</param>
		public void Save(StreamWriter writer)
		{
			Save((TextWriter)writer);
		}

		/// <summary>
		/// Saves the mixed document to the specified TextWriter.
		/// </summary>
		/// <param name="writer">The TextWriter to which you want to save.</param>
		public void Save(TextWriter writer)
		{

			writer.Flush();
		}

		/// <summary>
		/// Gets the code represented by the mixed code document seen as a template.
		/// </summary>
		public string Code
		{
			get
			{
				string s = "";
				int i = 0;
				foreach(MixedCodeDocumentFragment frag in _fragments)
				{
					switch(frag._type)
					{
						case MixedCodeDocumentFragmentType.Text:
							s += TokenResponseWrite + string.Format(TokenTextBlock, i) + "\n";
							i++;
							break;

						case MixedCodeDocumentFragmentType.Code:
							s += ((MixedCodeDocumentCodeFragment)frag).Code + "\n";
							break;
					}
				}
				return s;
			}
		}

		/// <summary>
		/// Create a text fragment instances.
		/// </summary>
		/// <returns>The newly created text fragment instance.</returns>
		public MixedCodeDocumentTextFragment CreateTextFragment()
		{
			return (MixedCodeDocumentTextFragment)CreateFragment(MixedCodeDocumentFragmentType.Text);
		}

		/// <summary>
		/// Create a code fragment instances.
		/// </summary>
		/// <returns>The newly created code fragment instance.</returns>
		public MixedCodeDocumentCodeFragment CreateCodeFragment()
		{
			return (MixedCodeDocumentCodeFragment)CreateFragment(MixedCodeDocumentFragmentType.Code);
		}

		internal MixedCodeDocumentFragment CreateFragment(MixedCodeDocumentFragmentType type)
		{
			switch(type)
			{
				case MixedCodeDocumentFragmentType.Text:
					return new MixedCodeDocumentTextFragment(this);

				case MixedCodeDocumentFragmentType.Code:
					return new MixedCodeDocumentCodeFragment(this);

				default:
					throw new NotSupportedException();
			}
		}

		private void SetPosition()
		{
			_currentfragment._line = _line;
			_currentfragment._lineposition = _lineposition;
			_currentfragment._index = _index - 1;
			_currentfragment._length = 0;
		}

		private void IncrementPosition()
		{
			_index++;
			if (_c == 10)
			{
				_lineposition = 1;
				_line++;
			}
			else
				_lineposition++;
		}

		private enum ParseState
		{
			Text,
			Code
		}

		private void Parse()
		{
			_state = ParseState.Text;
			_index = 0;
			_currentfragment = CreateFragment(MixedCodeDocumentFragmentType.Text);

			while (_index<_text.Length)
			{
				_c = _text[_index];
				IncrementPosition();

				switch(_state)
				{
					case ParseState.Text:
						if (_index+TokenCodeStart.Length<_text.Length)
						{
							if (_text.Substring(_index-1, TokenCodeStart.Length) == TokenCodeStart)
							{
								_state = ParseState.Code;
								_currentfragment._length = _index -1 - _currentfragment._index;
								_currentfragment = CreateFragment(MixedCodeDocumentFragmentType.Code);
								SetPosition();
								continue;
							}
						}
						break;

					case ParseState.Code:
						if (_index+TokenCodeEnd.Length<_text.Length)
						{
							if (_text.Substring(_index-1, TokenCodeEnd.Length) == TokenCodeEnd)
							{
								_state = ParseState.Text;
								_currentfragment._length = _index + TokenCodeEnd.Length - _currentfragment._index;
								_index += TokenCodeEnd.Length;
								_lineposition += TokenCodeEnd.Length;
								_currentfragment = CreateFragment(MixedCodeDocumentFragmentType.Text);
								SetPosition();
								continue;
							}
						}
						break;
				}
			}

			_currentfragment._length = _index - _currentfragment._index;
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HtmlAgilityPack\HtmlAgilityPack\MixedCodeDocumentFragment.cs ===
// HtmlAgilityPack V1.0 - Simon Mourier <simon underscore mourier at hotmail dot com>
using System;

namespace Test.Common.Library.HtmlAgilityPack
{
    /// <summary>
    /// Represents a base class for fragments in a mixed code document.
    /// </summary>
    public abstract class MixedCodeDocumentFragment
    {
        internal MixedCodeDocumentFragmentType _type;
        internal MixedCodeDocument _doc;
        internal int _index;
        internal int _length;
        internal int _line;
        internal int _lineposition;
        internal string _fragmenttext;

        internal MixedCodeDocumentFragment(MixedCodeDocument doc, MixedCodeDocumentFragmentType type)
        {
            _doc = doc;
            _type = type;
            switch (type)
            {
                case MixedCodeDocumentFragmentType.Text:
                    _doc._textfragments.Append(this);
                    break;

                case MixedCodeDocumentFragmentType.Code:
                    _doc._codefragments.Append(this);
                    break;
            }
            _doc._fragments.Append(this);
        }

        /// <summary>
        /// Gets the type of fragment.
        /// </summary>
        public MixedCodeDocumentFragmentType FragmentType
        {
            get
            {
                return _type;
            }
        }

        /// <summary>
        /// Gets the fragment position in the document's stream.
        /// </summary>
        public int StreamPosition
        {
            get
            {
                return _index;
            }
        }

        /// <summary>
        /// Gets the line number of the fragment.
        /// </summary>
        public int Line
        {
            get
            {
                return _line;
            }
        }

        /// <summary>
        /// Gets the line position (column) of the fragment.
        /// </summary>
        public int LinePosition
        {
            get
            {
                return _lineposition;
            }
        }

        /// <summary>
        /// Gets the fragement text.
        /// </summary>
        public string FragmentText
        {
            get
            {
                if (_fragmenttext == null)
                {
                    _fragmenttext = _doc._text.Substring(_index, _length);
                }
                return _fragmenttext;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HtmlAgilityPack\HtmlAgilityPack\MixedCodeDocumentCodeFragment.cs ===
// HtmlAgilityPack V1.0 - Simon Mourier <simon underscore mourier at hotmail dot com>
using System;

namespace Test.Common.Library.HtmlAgilityPack
{
    /// <summary>
    /// Represents a fragment of code in a mixed code document.
    /// </summary>
    public class MixedCodeDocumentCodeFragment : MixedCodeDocumentFragment
    {
        internal string _code;

        internal MixedCodeDocumentCodeFragment(MixedCodeDocument doc)
            :
            base(doc, MixedCodeDocumentFragmentType.Code)
        {
        }

        /// <summary>
        /// Gets the fragment code text.
        /// </summary>
        public string Code
        {
            get
            {
                if (_code == null)
                {
                    _code = FragmentText.Substring(_doc.TokenCodeStart.Length,
                        FragmentText.Length - _doc.TokenCodeEnd.Length - _doc.TokenCodeStart.Length - 1).Trim();
                    if (_code.StartsWith("="))
                    {
                        _code = _doc.TokenResponseWrite + _code.Substring(1, _code.Length - 1);
                    }
                }
                return _code;
            }
            set
            {
                _code = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HtmlAgilityPack\HtmlAgilityPack\HtmlWeb.cs ===
// HtmlAgilityPack V1.0 - Simon Mourier <simon underscore mourier at hotmail dot com>
using System;
using System.IO;
using System.Net;
using System.Xml;
using System.Xml.Serialization;
using System.Xml.Xsl;
using Microsoft.Win32;

namespace Test.Common.Library.HtmlAgilityPack
{
	/// <summary>
	/// A utility class to get HTML document from HTTP.
	/// </summary>
	public class HtmlWeb
	{
		/// <summary>
		/// Represents the method that will handle the PreRequest event.
		/// </summary>
		public delegate bool PreRequestHandler(HttpWebRequest request);

		/// <summary>
		/// Represents the method that will handle the PostResponse event.
		/// </summary>
		public delegate void PostResponseHandler(HttpWebRequest request, HttpWebResponse response);

		/// <summary>
		/// Represents the method that will handle the PreHandleDocument event.
		/// </summary>
		public delegate void PreHandleDocumentHandler(HtmlDocument document);

		private int _streamBufferSize = 1024;
		private string _cachePath;
		private bool _usingCache;
		private bool _fromCache;
		private bool _cacheOnly;
		private bool _useCookies;
		private int _requestDuration;
		private bool _autoDetectEncoding = true;
		private HttpStatusCode _statusCode = HttpStatusCode.OK;
		private Uri _responseUri;

		/// <summary>
		/// Occurs before an HTTP request is executed.
		/// </summary>
		public PreRequestHandler PreRequest;

		/// <summary>
		/// Occurs after an HTTP request has been executed.
		/// </summary>
		public PostResponseHandler PostResponse;

		/// <summary>
		/// Occurs before an HTML document is handled.
		/// </summary>
		public PreHandleDocumentHandler PreHandleDocument;

		/// <summary>
		/// Creates an instance of an HtmlWeb class.
		/// </summary>
		public HtmlWeb()
		{
		}

		/// <summary>
		/// Gets an HTML document from an Internet resource and saves it to the specified file.
		/// </summary>
		/// <param name="url">The requested URL, such as "http://Myserver/Mypath/Myfile.asp".</param>
		/// <param name="path">The location of the file where you want to save the document.</param>
		public void Get(string url, string path)
		{
			Get(url, path, "GET");
		}
			
		/// <summary>
		/// Gets an HTML document from an Internet resource and saves it to the specified file.
		/// </summary>
		/// <param name="url">The requested URL, such as "http://Myserver/Mypath/Myfile.asp".</param>
		/// <param name="path">The location of the file where you want to save the document.</param>
		/// <param name="method">The HTTP method used to open the connection, such as GET, POST, PUT, or PROPFIND.</param>
		public void Get(string url, string path, string method)
		{
			Uri uri = new Uri(url);
			if ((uri.Scheme == Uri.UriSchemeHttps) ||
				(uri.Scheme == Uri.UriSchemeHttp))
			{
				Get(uri, method, path, null);
			}
			else
			{
				throw new HtmlWebException("Unsupported uri scheme: '" + uri.Scheme + "'.");
			}
		}

		/// <summary>
		/// Gets an HTML document from an Internet resource.
		/// </summary>
		/// <param name="url">The requested URL, such as "http://Myserver/Mypath/Myfile.asp".</param>
		/// <returns>A new HTML document.</returns>
		public HtmlDocument Load(string url)
		{
			return Load(url, "GET");
		}

		/// <summary>
		/// Loads an HTML document from an Internet resource.
		/// </summary>
		/// <param name="url">The requested URL, such as "http://Myserver/Mypath/Myfile.asp".</param>
		/// <param name="method">The HTTP method used to open the connection, such as GET, POST, PUT, or PROPFIND.</param>
		/// <returns>A new HTML document.</returns>
		public HtmlDocument Load(string url, string method)
		{
			Uri uri = new Uri(url);
			HtmlDocument doc;
			if ((uri.Scheme == Uri.UriSchemeHttps) ||
				(uri.Scheme == Uri.UriSchemeHttp))
			{
				doc = LoadUrl(uri, method);
			}
			else
			{

				if (uri.Scheme == Uri.UriSchemeFile)
				{
					doc = new HtmlDocument();
					doc.OptionAutoCloseOnEnd = false;
					doc.OptionAutoCloseOnEnd = true;
					doc.DetectEncodingAndLoad(url, _autoDetectEncoding);
				}
				else
				{
					throw new HtmlWebException("Unsupported uri scheme: '" + uri.Scheme + "'.");
				}
			}
			if (PreHandleDocument != null)
			{
				PreHandleDocument(doc);
			}
			return doc;
		}

		private bool IsCacheHtmlContent(string path)
		{
			string ct = GetContentTypeForExtension(Path.GetExtension(path), null);
			return IsHtmlContent(ct);
		}

		private bool IsHtmlContent(string contentType)
		{
			return contentType.ToLower().StartsWith("text/html");
		}

		private string GetCacheHeadersPath(Uri uri)
		{
			//return Path.Combine(GetCachePath(uri), ".h.xml");
			return GetCachePath(uri) + ".h.xml";
		}

		/// <summary>
		/// Gets the cache file path for a specified url.
		/// </summary>
		/// <param name="uri">The url fo which to retrieve the cache path. May not be null.</param>
		/// <returns>The cache file path.</returns>
		public string GetCachePath(Uri uri)
		{
			if (uri == null)
			{
				throw new ArgumentNullException("uri");
			}
			if (!UsingCache)
			{
				throw new HtmlWebException("Cache is not enabled. Set UsingCache to true first.");
			}
			string cachePath;
			if (uri.AbsolutePath == "/")
			{
				cachePath = Path.Combine(_cachePath, ".htm");
			}
			else
			{
				cachePath = Path.Combine(_cachePath, (uri.Host + uri.AbsolutePath).Replace('/', '\\'));
			}
			return cachePath;
		}

		/// <summary>
		/// Gets a value indicating if the last document was retrieved from the cache.
		/// </summary>
		public bool FromCache
		{
			get
			{
				return _fromCache;
			}
		}

		/// <summary>
		/// Gets the URI of the Internet resource that actually responded to the request.
		/// </summary>
		public Uri ResponseUri
		{
			get
			{
				return _responseUri;
			}
		}

		/// <summary>
		/// Gets or Sets a value indicating whether to get document only from the cache.
		/// If this is set to true and document is not found in the cache, nothing will be loaded.
		/// </summary>
		public bool CacheOnly
		{
			get
			{
				return _cacheOnly;
			}
			set
			{
				if ((value) && !UsingCache)
				{
					throw new HtmlWebException("Cache is not enabled. Set UsingCache to true first.");
				}
				_cacheOnly = value;
			}
		}

		/// <summary>
		/// Gets or Sets a value indicating if cookies will be stored.
		/// </summary>
		public bool UseCookies
		{
			get
			{
				return _useCookies;
			}
			set
			{
				_useCookies = value;
			}
		}

		/// <summary>
		/// Gets the last request duration in milliseconds.
		/// </summary>
		public int RequestDuration
		{
			get
			{
				return _requestDuration;
			}
		}

		/// <summary>
		/// Gets or Sets a value indicating if document encoding must be automatically detected.
		/// </summary>
		public bool AutoDetectEncoding
		{
			get
			{
				return _autoDetectEncoding;
			}
			set
			{
				_autoDetectEncoding = value;
			}
		}

		/// <summary>
		/// Gets the last request status.
		/// </summary>
		public HttpStatusCode StatusCode
		{
			get
			{
				return _statusCode;
			}
		}

		/// <summary>
		/// Gets or Sets the size of the buffer used for memory operations.
		/// </summary>
		public int StreamBufferSize
		{
			get
			{
				return _streamBufferSize;
			}
			set
			{
				if (_streamBufferSize <= 0)
				{
					throw new ArgumentException("Size must be greater than zero.");
				}
				_streamBufferSize = value;
			}
		}

		private HtmlDocument LoadUrl(Uri uri, string method)
		{
			HtmlDocument doc = new HtmlDocument();
			doc.OptionAutoCloseOnEnd = false;
			doc.OptionFixNestedTags = true;
			_statusCode = Get(uri, method, null, doc);
			if (_statusCode == HttpStatusCode.NotModified)
			{
				// read cached encoding
				doc.DetectEncodingAndLoad(GetCachePath(uri));
			}
			return doc;
		}

		private HttpStatusCode Get(Uri uri, string method, string path, HtmlDocument doc)
		{
			string cachePath = null;
			HttpWebRequest req;
			bool oldFile = false;

			req = WebRequest.Create(uri) as HttpWebRequest;
			req.Method = method;

			_fromCache = false;
			_requestDuration = 0;
			int tc = Environment.TickCount;
			if (UsingCache)
			{
				cachePath = GetCachePath(req.RequestUri);
				if (File.Exists(cachePath))
				{
					req.IfModifiedSince = File.GetLastAccessTime(cachePath);
					oldFile = true;
				}
			}

			if (_cacheOnly)
			{
				if (!File.Exists(cachePath))
				{
					throw new HtmlWebException("File was not found at cache path: '" + cachePath + "'");
				}

				if (path != null)
				{
					IOLibrary.CopyAlways(cachePath, path);
					// touch the file
					File.SetLastWriteTime(path, File.GetLastWriteTime(cachePath));
				}
				_fromCache = true;
				return HttpStatusCode.NotModified;
			}

			if (_useCookies)
			{
				req.CookieContainer = new CookieContainer();
			}

			if (PreRequest != null)
			{
				// allow our user to change the request at will
				if (!PreRequest(req))
				{
					return HttpStatusCode.ResetContent;
				}

				// dump cookie
//				if (_useCookies)
//				{
//					foreach(Cookie cookie in req.CookieContainer.GetCookies(req.RequestUri))
//					{
//						HtmlLibrary.Trace("Cookie " + cookie.Name + "=" + cookie.Value + " path=" + cookie.Path + " domain=" + cookie.Domain);
//					}
//				}
			}

			HttpWebResponse resp;

			try
			{
				resp = req.GetResponse() as HttpWebResponse;
			}
			catch (WebException we)
			{
				_requestDuration = Environment.TickCount - tc;
				resp = (HttpWebResponse)we.Response;
				if (resp == null)
				{
					if (oldFile)
					{
						if (path != null)
						{
							IOLibrary.CopyAlways(cachePath, path);
							// touch the file
							File.SetLastWriteTime(path, File.GetLastWriteTime(cachePath));
						}
						return HttpStatusCode.NotModified;
					}
					throw;
				}
			}
			catch(Exception)
			{
				_requestDuration = Environment.TickCount - tc;
				throw;
			}

			// allow our user to get some info from the response
			if (PostResponse != null)
			{
				PostResponse(req, resp);
			}

			_requestDuration = Environment.TickCount - tc;
			_responseUri = resp.ResponseUri;
			
			bool html = IsHtmlContent(resp.ContentType);
			System.Text.Encoding respenc;

			if ((resp.ContentEncoding != null) && (resp.ContentEncoding.Length>0))
			{
				respenc = System.Text.Encoding.GetEncoding(resp.ContentEncoding);
			}
			else
			{
				respenc = null;
			}

			if (resp.StatusCode == HttpStatusCode.NotModified)
			{
				if (UsingCache)
				{
					_fromCache = true;
					if (path != null)
					{
						IOLibrary.CopyAlways(cachePath, path);
						// touch the file
						File.SetLastWriteTime(path, File.GetLastWriteTime(cachePath));
					}
					return resp.StatusCode;
				}
				else
				{
					// this should *never* happen...
					throw new HtmlWebException("Server has send a NotModifed code, without cache enabled.");
				}
			}
			Stream s = resp.GetResponseStream();
			if (s != null)
			{
				if (UsingCache)
				{
					// NOTE: LastModified does not contain milliseconds, so we remove them to the file
					SaveStream(s, cachePath, RemoveMilliseconds(resp.LastModified), _streamBufferSize);

					// save headers
					SaveCacheHeaders(req.RequestUri, resp);

					if (path != null)
					{
						// copy and touch the file
						IOLibrary.CopyAlways(cachePath, path);
						File.SetLastWriteTime(path, File.GetLastWriteTime(cachePath));
					}
				}
				else
				{
					// try to work in-memory
					if ((doc != null) && (html))
					{
						if (respenc != null)
						{
							doc.Load(s, respenc);
						}
						else
						{
							doc.Load(s, true);
						}
					}
				}
				resp.Close();
			}
			return resp.StatusCode;
		}

		private string GetCacheHeader(Uri requestUri, string name, string def)
		{
			// note: some headers are collection (ex: www-authenticate)
			// we don't handle that here
			XmlDocument doc = new XmlDocument();
			doc.Load(GetCacheHeadersPath(requestUri));
			XmlNode node = doc.SelectSingleNode("//h[translate(@n, 'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')='" + name.ToUpper() + "']");
			if (node == null)
			{
				return def;
			}
			// attribute should exist
			return node.Attributes[name].Value;
		}

		private void SaveCacheHeaders(Uri requestUri, HttpWebResponse resp)
		{
			// we cache the original headers aside the cached document.
			string file = GetCacheHeadersPath(requestUri);
			XmlDocument doc = new XmlDocument();
			doc.LoadXml("<c></c>");
			XmlNode cache = doc.FirstChild;
			foreach(string header in resp.Headers)
			{
				XmlNode entry = doc.CreateElement("h");
				XmlAttribute att = doc.CreateAttribute("n");
				att.Value = header;
				entry.Attributes.Append(att);

				att = doc.CreateAttribute("v");
				att.Value = resp.Headers[header];
				entry.Attributes.Append(att);

				cache.AppendChild(entry);
			}
			doc.Save(file);
		}

		private static long SaveStream(Stream stream, string path, DateTime touchDate, int streamBufferSize)
		{
			FilePreparePath(path);
			FileStream fs = new FileStream(path, FileMode.Create, FileAccess.Write);
			BinaryReader br = null;
			BinaryWriter bw = null;
			long len;
			try
			{
				br = new BinaryReader(stream);
				bw = new BinaryWriter(fs);
				len = 0;
				byte[] buffer;
				do
				{
					buffer = br.ReadBytes(streamBufferSize);
					len += buffer.Length;
					if (buffer.Length>0)
					{
						bw.Write(buffer);
					}
				}
				while (buffer.Length>0);
			}
			finally
			{
				if (br != null)
				{
					br.Close();
				}
				if (bw != null)
				{
					bw.Flush();
					bw.Close();
				}
				if (fs != null)
				{
					fs.Close();
				}
			}
			File.SetLastWriteTime(path, touchDate);
			return len;
		}

		private static void FilePreparePath(string target)
		{
			if (File.Exists(target))
			{
				FileAttributes atts = File.GetAttributes(target);
				File.SetAttributes(target, atts & ~FileAttributes.ReadOnly);
			}
			else
			{
				string dir = Path.GetDirectoryName(target);
				if (!Directory.Exists(dir))
				{
					Directory.CreateDirectory(dir);
				}
			}
		}

		private static DateTime RemoveMilliseconds(DateTime t)
		{
			return new DateTime(t.Year, t.Month, t.Day, t.Hour, t.Minute, t.Second, 0);
		}

		/// <summary>
		/// Gets the path extension for a given MIME content type.
		/// </summary>
		/// <param name="contentType">The input MIME content type.</param>
		/// <param name="def">The default path extension to return if any error occurs.</param>
		/// <returns>The MIME content type's path extension.</returns>
		public static string GetExtensionForContentType(string contentType, string def)
		{
			if ((contentType == null) || (contentType.Length == 0))
			{
				return def;
			}
			string ext;
			try
			{
				RegistryKey reg = Registry.ClassesRoot;
				reg = reg.OpenSubKey(@"MIME\Database\Content Type\" + contentType, false);
				ext = (string)reg.GetValue("Extension", def);
			}
			catch(Exception)
			{
				ext =  def;
			}
			return ext;
		}

		/// <summary>
		/// Gets the MIME content type for a given path extension.
		/// </summary>
		/// <param name="extension">The input path extension.</param>
		/// <param name="def">The default content type to return if any error occurs.</param>
		/// <returns>The path extention's MIME content type.</returns>
		public static string GetContentTypeForExtension(string extension, string def)
		{
			if ((extension == null) || (extension.Length == 0))
			{
				return def;
			}
			string contentType;
			try
			{
				RegistryKey reg = Registry.ClassesRoot;
				reg = reg.OpenSubKey(extension, false);
				contentType = (string)reg.GetValue("", def);
			}
			catch(Exception)
			{
				contentType =  def;
			}
			return contentType;
		}

		/// <summary>
		/// Loads an HTML document from an Internet resource and saves it to the specified XmlTextWriter.
		/// </summary>
		/// <param name="htmlUrl">The requested URL, such as "http://Myserver/Mypath/Myfile.asp".</param>
		/// <param name="writer">The XmlTextWriter to which you want to save.</param>
		public void LoadHtmlAsXml(string htmlUrl, XmlTextWriter writer)
		{
			HtmlDocument doc = Load(htmlUrl);
			doc.Save(writer);
		}

		/// <summary>
		/// Loads an HTML document from an Internet resource and saves it to the specified XmlTextWriter, after an XSLT transformation.
		/// </summary>
		/// <param name="htmlUrl">The requested URL, such as "http://Myserver/Mypath/Myfile.asp".</param>
		/// <param name="xsltUrl">The URL that specifies the XSLT stylesheet to load.</param>
		/// <param name="xsltArgs">An XsltArgumentList containing the namespace-qualified arguments used as input to the transform.</param>
		/// <param name="writer">The XmlTextWriter to which you want to save.</param>
		public void LoadHtmlAsXml(string htmlUrl, string xsltUrl, XsltArgumentList xsltArgs, XmlTextWriter writer)
		{
			LoadHtmlAsXml(htmlUrl, xsltUrl, xsltArgs, writer, null);
		}

		/// <summary>
		/// Loads an HTML document from an Internet resource and saves it to the specified XmlTextWriter, after an XSLT transformation.
		/// </summary>
		/// <param name="htmlUrl">The requested URL, such as "http://Myserver/Mypath/Myfile.asp". May not be null.</param>
		/// <param name="xsltUrl">The URL that specifies the XSLT stylesheet to load.</param>
		/// <param name="xsltArgs">An XsltArgumentList containing the namespace-qualified arguments used as input to the transform.</param>
		/// <param name="writer">The XmlTextWriter to which you want to save.</param>
		/// <param name="xmlPath">A file path where the temporary XML before transformation will be saved. Mostly used for debugging purposes.</param>
		public void LoadHtmlAsXml(string htmlUrl, string xsltUrl, XsltArgumentList xsltArgs, XmlTextWriter writer, string xmlPath)
		{
			if (htmlUrl == null)
			{
				throw new ArgumentNullException("htmlUrl");
			}

			HtmlDocument doc = Load(htmlUrl);

			if (xmlPath != null)
			{
				XmlTextWriter w = new XmlTextWriter(xmlPath, doc.Encoding);
				doc.Save(w);
				w.Close();
			}
			if (xsltArgs == null)
			{
				xsltArgs = new XsltArgumentList();
			}
			
			// add some useful variables to the xslt doc
			xsltArgs.AddParam("url", "", htmlUrl);
			xsltArgs.AddParam("requestDuration", "", RequestDuration);
			xsltArgs.AddParam("fromCache", "", FromCache);

			XslCompiledTransform xslt = new XslCompiledTransform();
			xslt.Load(xsltUrl);
			xslt.Transform(doc, xsltArgs, writer);
		}

		/// <summary>
		/// Creates an instance of the given type from the specified Internet resource.
		/// </summary>
		/// <param name="url">The requested URL, such as "http://Myserver/Mypath/Myfile.asp".</param>
		/// <param name="type">The requested type.</param>
		/// <returns>An newly created instance.</returns>
		public object CreateInstance(string url, Type type)
		{
			return CreateInstance(url, null, null, type);
		}

		/// <summary>
		/// Creates an instance of the given type from the specified Internet resource.
		/// </summary>
		/// <param name="htmlUrl">The requested URL, such as "http://Myserver/Mypath/Myfile.asp".</param>
		/// <param name="xsltUrl">The URL that specifies the XSLT stylesheet to load.</param>
		/// <param name="xsltArgs">An XsltArgumentList containing the namespace-qualified arguments used as input to the transform.</param>
		/// <param name="type">The requested type.</param>
		/// <returns>An newly created instance.</returns>
		public object CreateInstance(string htmlUrl, string xsltUrl, XsltArgumentList xsltArgs, Type type)
		{
			return CreateInstance(htmlUrl, xsltUrl, xsltArgs, type, null);
		}

		/// <summary>
		/// Creates an instance of the given type from the specified Internet resource.
		/// </summary>
		/// <param name="htmlUrl">The requested URL, such as "http://Myserver/Mypath/Myfile.asp".</param>
		/// <param name="xsltUrl">The URL that specifies the XSLT stylesheet to load.</param>
		/// <param name="xsltArgs">An XsltArgumentList containing the namespace-qualified arguments used as input to the transform.</param>
		/// <param name="type">The requested type.</param>
		/// <param name="xmlPath">A file path where the temporary XML before transformation will be saved. Mostly used for debugging purposes.</param>
		/// <returns>An newly created instance.</returns>
		public object CreateInstance(string htmlUrl, string xsltUrl, XsltArgumentList xsltArgs, Type type, string xmlPath)
		{
			StringWriter sw = new StringWriter();
			XmlTextWriter writer = new XmlTextWriter(sw);
			if (xsltUrl == null)
			{
				LoadHtmlAsXml(htmlUrl, writer);
			}
			else
			{
				if (xmlPath == null)
				{
					LoadHtmlAsXml(htmlUrl, xsltUrl, xsltArgs, writer);
				}
				else
				{
					LoadHtmlAsXml(htmlUrl, xsltUrl, xsltArgs, writer, xmlPath);
				}
			}
			writer.Flush();
			StringReader sr = new StringReader(sw.ToString());
			XmlTextReader reader = new XmlTextReader(sr);
			XmlSerializer serializer = new XmlSerializer(type);
			object o = null;
			try
			{
				o = serializer.Deserialize(reader);
			}
			catch(InvalidOperationException ex)
			{
				throw new Exception(ex.ToString() + ", --- xml:" + sw.ToString());
			}
			return o;
		}

		/// <summary>
		/// Gets or Sets the cache path. If null, no caching mechanism will be used.
		/// </summary>
		public string CachePath
		{
			get
			{
				return _cachePath;
			}
			set
			{
				_cachePath = value;
			}
		}

		/// <summary>
		/// Gets or Sets a value indicating whether the caching mechanisms should be used or not.
		/// </summary>
		public bool UsingCache
		{
			get
			{
				if (_cachePath == null)
				{
					return false;
				}
				return _usingCache;
			}
			set
			{
				if ((value) && (_cachePath == null))
				{
					throw new HtmlWebException("You need to define a CachePath first.");
				}
				_usingCache = value;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HtmlAgilityPack\HtmlAgilityPack\MixedCodeDocumentFragmentType.cs ===
// HtmlAgilityPack V1.0 - Simon Mourier <simon underscore mourier at hotmail dot com>
using System;

namespace Test.Common.Library.HtmlAgilityPack
{
    /// <summary>
    /// Represents the type of fragement in a mixed code document.
    /// </summary>
    public enum MixedCodeDocumentFragmentType
    {
        /// <summary>
        /// The fragment contains code.
        /// </summary>
        Code,

        /// <summary>
        /// The fragment contains text.
        /// </summary>
        Text,
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HtmlAgilityPack\HtmlAgilityPack\NameValuePair.cs ===
// HtmlAgilityPack V1.0 - Simon Mourier <simon underscore mourier at hotmail dot com>
using System;

namespace Test.Common.Library.HtmlAgilityPack
{
    internal class NameValuePair
    {
        internal readonly string Name;
        internal string Value;

        internal NameValuePair()
        {
        }

        internal NameValuePair(string name)
            :
            this()
        {
            Name = name;
        }

        internal NameValuePair(string name, string value)
            :
            this(name)
        {
            Value = value;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HTTPWatchWrapper\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HtmlAgilityPack\HtmlAgilityPack\MixedCodeDocumentTextFragment.cs ===
// HtmlAgilityPack V1.0 - Simon Mourier <simon underscore mourier at hotmail dot com>
using System;

namespace Test.Common.Library.HtmlAgilityPack
{
    /// <summary>
    /// Represents a fragment of text in a mixed code document.
    /// </summary>
    public class MixedCodeDocumentTextFragment : MixedCodeDocumentFragment
    {
        internal MixedCodeDocumentTextFragment(MixedCodeDocument doc)
            :
            base(doc, MixedCodeDocumentFragmentType.Text)
        {
        }

        /// <summary>
        /// Gets the fragment text.
        /// </summary>
        public string Text
        {
            get
            {
                return FragmentText;
            }
            set
            {
                base._fragmenttext = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HtmlAgilityPack\HtmlAgilityPack\NameValuePairList.cs ===
// HtmlAgilityPack V1.0 - Simon Mourier <simon underscore mourier at hotmail dot com>
using System;
using System.Collections;

namespace Test.Common.Library.HtmlAgilityPack
{
	internal class NameValuePairList
	{
		internal readonly string Text;
		private ArrayList _allPairs;
		private Hashtable _pairsWithName;

		internal NameValuePairList():
			this(null)
		{
		}

		internal NameValuePairList(string text)
		{
			Text = text;
			_allPairs = new ArrayList();
			_pairsWithName = new Hashtable();

			Parse(text);
		}

		internal string GetNameValuePairValue(string name)
		{
			if (name==null)
				throw new ArgumentNullException();
			ArrayList al = GetNameValuePairs(name);
			if (al==null)
				return null;

			// return first item
			NameValuePair nvp = al[0] as NameValuePair;
			return nvp.Value;
		}

		internal ArrayList GetNameValuePairs(string name)
		{
			if (name==null)
				return _allPairs;
			return _pairsWithName[name] as ArrayList;
		}

		private void Parse(string text)
		{
			_allPairs.Clear();
			_pairsWithName.Clear();
			if (text==null)
				return;

			string[] p = text.Split(';');
			if (p==null)
				return;
			foreach(string pv in p)
			{
				if (pv.Length==0)
					continue;
				string[] onep = pv.Split(new char[]{'='}, 2);
				if (onep==null)
					continue;
				NameValuePair nvp = new NameValuePair(onep[0].Trim().ToLower());
				if (onep.Length<2)
					nvp.Value = "";
				else
					nvp.Value = onep[1];

				_allPairs.Add(nvp);

				// index by name
				ArrayList al = _pairsWithName[nvp.Name] as ArrayList;
				if (al==null)
				{
					al = new ArrayList();
					_pairsWithName[nvp.Name] = al;
				}
				al.Add(nvp);
			}
		}

		internal static string GetNameValuePairsValue(string text, string name)
		{
			NameValuePairList l = new NameValuePairList(text);
			return l.GetNameValuePairValue(name);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HtmlAgilityPack\HtmlAgilityPack\Properties\AssemblyInfo.cs ===
// HtmlAgilityPack V1.0 - Simon Mourier <simon underscore mourier at hotmail dot com>
using System.Reflection;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;

[assembly: AssemblyTitle("Html Agility Pack")] //Description
[assembly: AssemblyConfiguration("")]
//[assembly: AssemblyCompany("Simon Mourier")]
//[assembly: AssemblyProduct("Html Agility Pack")]
//[assembly: AssemblyCopyright("Copyright (C) 2003-2005 Simon Mourier <simon underscore mourier at hotmail dot com> All rights reserved.")]
//[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

[assembly: ComVisible(false)]

[assembly: Guid("643622ea-d2aa-4572-a2b2-6202b7fcd83f")]

//[assembly: AssemblyVersion("1.3.0.0")]
//[assembly: AssemblyFileVersion("1.3.0.0")]
//[assembly: AssemblyInformationalVersion("2.0.0.0")]

//[assembly: AssemblyDelaySign(false)]

// 
// Welcome to the HTML Agility Pack!
// As you may have noticed, there is no HtmlAgilityPack file provided.
// You need to build one using SN.EXE utility provided with the .NET Framework
//
// The command to use is something like:
//      SN.EXE -k HtmlAgilityPack.snk
//
// Simon.
//
//[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HTTPWatchWrapper\HTTPWatchWrapper\CacheInfo.cs ===
﻿using System;
using System.Text;

namespace Test.Common.Library.HTTPWatchWrapper
{
    /// <summary>
    /// Represents information about the state of a URL in the browser cache.
    /// </summary>
    public class CacheInfo
    {
        /// <summary>
        /// Represents a value that is used by the web server to identify this version
        /// of the cached resource.
        /// </summary>
        public string ETag
        {
            get;
            set;
        }

        /// <summary>
        /// Indicates when this cache entry is no longer valid and will need to be updated.
        /// </summary>
        public DateTime Expires
        {
            get;
            set;
        }

        /// <summary>
        /// Represents how many times this cached resource has been used.
        /// </summary>
        public int HitCount
        {
            get;
            set;
        }

        /// <summary>
        /// Indicates whether an expiration date/time was set by the web server for this cache entry.
        /// </summary>
        public bool IsExpiresSet
        {
            get;
            set;
        }

        /// <summary>
        /// Indicates whether a modification date/time was supplied by the web server for this cache entry.
        /// </summary>
        public bool IsLastModifiedSet
        {
            get;
            set;
        }

        /// <summary>
        /// Represents when this cache entry was last updated with content from the web server.
        /// </summary>
        public DateTime LastUpdate
        {
            get;
            set;
        }

        /// <summary>
        /// Represents when the cache entry was last accessed by the browser.
        /// </summary>
        public DateTime LastAccess
        {
            get;
            set;
        }

        /// <summary>
        /// Represents a value supplied by the server indicating when the
        /// content was last modified.
        /// </summary>
        public DateTime LastModified
        {
            get;
            set;
        }

        /// <summary>
        /// Indicates whether the URL's content is stored in the browser cache.
        /// </summary>
        public bool URLInCache
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HTTPWatchWrapper\HTTPWatchWrapper\Cookie.cs ===
﻿using System;
using System.Text;

namespace Test.Common.Library.HTTPWatchWrapper
{
    /// <summary>
    /// Represents a single cookie that was sent to or received from the web server.
    /// </summary>
    public class Cookie
    {
        /// <summary>
        /// Represents the internet domain name to which this cookie applies.
        /// </summary>
        public string Domain
        {
            get;
            set;
        }

        /// <summary>
        /// Indicates when this cookie expires.
        /// </summary>
        public DateTime Expires
        {
            get;
            set;
        }

        /// <summary>
        /// Indicates whether this cookie will be destroyed at the end of the browser session.
        /// </summary>
        public bool IsSessionCookie
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the name of the cookie.
        /// </summary>
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the URL path to which this cookie applies.
        /// </summary>
        public string Path
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the value of the cookie.
        /// </summary>
        public string Value
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HTTPWatchWrapper\HTTPWatchWrapper\Cookies.cs ===
﻿using System;
using System.Collections;
using System.Text;

namespace Test.Common.Library.HTTPWatchWrapper
{
    /// <summary>
    /// Represents a collection of Cookie objects that 
    /// contains cookies that were sent to or received from the web server.
    /// </summary>
    public class Cookies : CollectionBase
    {
        /// <summary>
        /// Create an empty collection of Cookie objects.
        /// </summary>
        public Cookies() { }

        /// <summary>
        /// Create a collection of Cookie objects with the specified Cookie
        /// as the first item in the collection.
        /// </summary>
        /// <param name="Parameter">The Cookie object to add to the collection.</param>
        public Cookies(Cookie Parameter)
        {
            this.List.Add(Parameter);
        }

        /// <summary>
        /// Adds the specified Cookie object to the collection.
        /// </summary>
        /// <param name="Parameter">The Cookie object to add to the collection.</param>
        /// <returns>An integer indicating the index where the object was added.</returns>
        public int Add(Cookie Parameter)
        {
            return this.List.Add(Parameter);
        }

        /// <summary>
        /// Gets or sets the value of a pre existing element in the collection.
        /// </summary>
        /// <param name="index">The index of the element in the collection.</param>
        /// <returns>A Cookie object corresponding to the specified index.</returns>
        public Cookie this[int index]
        {
            get { return (Cookie)this.List[index]; }

            set
            {
                try
                {
                    this.List[index] = value;
                }
                catch (Exception)
                {
                    throw;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HTTPWatchWrapper\HTTPWatchWrapper\Header.cs ===
﻿using System;
using System.Text;

namespace Test.Common.Library.HTTPWatchWrapper
{
    /// <summary>
    /// Represents a single HTTP header that was sent to or received from the web server.
    /// </summary>
    public class Header
    {
        /// <summary>
        /// Represents the name of the HTTP header.
        /// E.g. "User-Agent" or "Content-Length".
        /// </summary>
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the value of the HTTP header.
        /// </summary>
        public string Value
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HTTPWatchWrapper\HTTPWatchWrapper\Content.cs ===
﻿using System;
using System.Text;

namespace Test.Common.Library.HTTPWatchWrapper
{
    /// <summary>
    /// Represents information about an HTTP resource that was requested.
    /// E.g. an image or an HTML page.
    /// </summary>
    public class Content
    {
        /// <summary>
        /// Represents the compressed size of the content in bytes.
        /// If the content was not compressed (i.e. IsCompressed returns false) the value
        /// will be the same as the Size property.
        /// </summary>
        public int CompressedSize
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the type of compression used by the server.
        /// E.g. "gzip" or "deflate". If no compression was used this property returns an empty string.
        /// </summary>
        public string CompressionType
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the actual content. For web pages this is the HTML of the page
        /// and for images this is the binary data in the image file.
        /// </summary>
        public string Data
        {
            get;
            set;
        }

        /// <summary>
        /// Indicates whether the content was read from the local browser cache.
        /// </summary>
        public bool IsFromCache
        {
            get;
            set;
        }

        /// <summary>
        /// Indicates whether the content was compressed in the HTTP response message from the server.
        /// This value will always be false if IsFromCache returns true.
        /// </summary>
        public bool IsCompressed
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the type of the content.
        /// E.g. "text/html" or "image/gif".
        /// </summary>
        public string MimeType
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the size of the content in bytes. If the content was compressed by the server
        /// this is the uncompressed size of the content.
        /// </summary>
        public int Size
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HTTPWatchWrapper\HTTPWatchWrapper\Entries.cs ===
﻿using System;
using System.Collections;
using System.Text;

namespace Test.Common.Library.HTTPWatchWrapper
{
    /// <summary>
    /// Represents a collection of Entry objects that 
    /// contains request entries for a page or the whole log.
    /// </summary>
    public class Entries : CollectionBase
    {
        /// <summary>
        /// Create an empty collection of Entry objects.
        /// </summary>
        public Entries() { }

        /// <summary>
        /// Create a collection of Entry objects with the specified Entry
        /// as the first item in the collection.
        /// </summary>
        /// <param name="Parameter">The Entry object to add to the collection.</param>
        public Entries(Entry Parameter)
        {
            this.List.Add(Parameter);
        }

        /// <summary>
        /// Adds the specified Entry object to the collection.
        /// </summary>
        /// <param name="Parameter">The Entry object to add to the collection.</param>
        /// <returns>An integer indicating the index where the object was added.</returns>
        public int Add(Entry Parameter)
        {
            return this.List.Add(Parameter);
        }

        /// <summary>
        /// Gets or sets the value of a pre existing element in the collection.
        /// </summary>
        /// <param name="index">The index of the element in the collection.</param>
        /// <returns>A Entry object corresponding to the specified index.</returns>
        public Entry this[int index]
        {
            get { return (Entry)this.List[index]; }

            set
            {
                try
                {
                    this.List[index] = value;
                }
                catch (Exception)
                {
                    throw;
                }
            }
        }

        /// <summary>
        /// Represents summarized information about the HTTP requests that were used to download the page.
        /// </summary>
        public Summary Summary
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HTTPWatchWrapper\HTTPWatchWrapper\Headers.cs ===
﻿using System;
using System.Collections;
using System.Text;

namespace Test.Common.Library.HTTPWatchWrapper
{
    /// <summary>
    /// Represents a collection of Header objects that 
    /// contains HTTP headers that were sent to or received from the web server.
    /// </summary>
    public class Headers : CollectionBase
    {
        /// <summary>
        /// Create an empty collection of Header objects.
        /// </summary>
        public Headers() { }

        /// <summary>
        /// Create a collection of Header objects with the specified Header
        /// as the first item in the collection.
        /// </summary>
        /// <param name="Parameter">The Header object to add to the collection.</param>
        public Headers(Header Parameter)
        {
            this.List.Add(Parameter);
        }

        /// <summary>
        /// Adds the specified Header object to the collection.
        /// </summary>
        /// <param name="Parameter">The Header object to add to the collection.</param>
        /// <returns>An integer indicating the index where the object was added.</returns>
        public int Add(Header Parameter)
        {
            return this.List.Add(Parameter);
        }

        /// <summary>
        /// Gets or sets the value of a pre existing element in the collection.
        /// </summary>
        /// <param name="index">The index of the element in the collection.</param>
        /// <returns>A Header object corresponding to the specified index.</returns>
        public Header this[int index]
        {
            get { return (Header)this.List[index]; }

            set
            {
                try
                {
                    this.List[index] = value;
                }
                catch (Exception)
                {
                    throw;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HTTPWatchWrapper\HTTPWatchWrapper\Entry.cs ===
﻿using System;
using System.Text;

namespace Test.Common.Library.HTTPWatchWrapper
{
    /// <summary>
    /// Represents a single HTTP transaction.
    /// </summary>
    public class Entry
    {
        /// <summary>
        /// Represents the size of the HTTP response message in bytes.
        /// This is the amount of data that was received over the network from the web server.
        /// </summary>
        public int BytesReceived
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the size of the HTTP request message in bytes.
        /// This is the amount of data that was sent over the network from the browser to the web server.
        /// </summary>
        public int BytesSent
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the state of this URL in the browser cache after the request was processed.
        /// </summary>
        public CacheInfo CacheAfter
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the state of this URL in the browser cache before the request was processed.
        /// </summary>
        public CacheInfo CacheBefore
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the local IP address that was used to send this HTTP request.
        /// </summary>
        public string ClientIP
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the local TCP port number that was used to send this HTTP request.
        /// </summary>
        public int ClientPort
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the information about the HTTP resource that was requested.
        /// </summary>
        public Content Content
        {
            get;
            set;
        }

        /// <summary>
        /// Represents details of any error that occurred while processing the HTTP request.
        /// </summary>
        public string Error
        {
            get;
            set;
        }

        /// <summary>
        /// Indicates whether the request has finished processing.
        /// </summary>
        public bool IsComplete
        {
            get;
            set;
        }

        /// <summary>
        /// Indicates whether a redirection request was received from the web server.
        /// </summary>
        public bool IsRedirect
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the HTTP method (e.g. "GET" or "POST").
        /// </summary>
        public string Method
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the Page in which this request was recorded.
        /// </summary>
        public Page Page
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the URL to which a redirect has been requested.
        /// </summary>
        public string RedirectURL
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the information about the HTTP request message.
        /// </summary>
        public Request Request
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the information about the HTTP response message.
        /// </summary>
        public Response Response
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the result of the request in the same format displayed in HttpWatch
        /// E.g. "200", "(Cached)", etc.
        /// </summary>
        public string Result
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the IP address of the web server (or proxy) to which this HTTP request was sent.
        /// </summary>
        public string ServerIP
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the TCP port number of the web server (or proxy) to which this HTTP request was sent.
        /// </summary>
        public int ServerPort
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the time when this request was started as an offset from the start of the log.
        /// </summary>
        public string Started
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the date and time when this request was started.
        /// </summary>
        public DateTime StartedDateTime
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the time when this request was started as an offset in seconds from the
        /// start of the log.
        /// </summary>
        public double StartedSecs
        {
            get;
            set;
        }

        /// <summary>
        /// Represent the HTTP status code from the server.
        /// </summary>
        public int StatusCode
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the time in seconds required to complete this request.
        /// </summary>
        public double Time
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the timing information for this request.
        /// </summary>
        public Timings Timings
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the URL.
        /// </summary>
        public string URL
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HTTPWatchWrapper\HTTPWatchWrapper\HTTPWatchLog.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;

namespace Test.Common.Library.HTTPWatchWrapper
{
    /// <summary>
    /// Represents the HTTP Watch Log.
    /// NOTE: This object is copied from the actual COM object.
    /// </summary>
    public class HTTPWatchLog
    {
        /// <summary>
        /// Represents a list of all the requests in the log.
        /// </summary>
        public Entries Entries
        {
            get;
            set;
        }

        /// <summary>
        /// Represents a filtered list of the requests in the log.
        /// </summary>
        public Entries FilteredEntries
        {
            get;
            set;
        }

        /// <summary>
        /// Represents a filtered list of pages in the log.
        /// </summary>
        public Pages FilteredPages
        {
            get;
            set;
        }

        /// <summary>
        /// Indicates whether the log contains detailed, request level timings.
        /// </summary>
        public bool HasNetworkTimings
        {
            get;
            set;
        }

        /// <summary>
        /// Indicates whether the log contains page grouping information.
        /// </summary>
        public bool HasPageGrouping
        {
            get;
            set;
        }

        /// <summary>
        /// Indicates whether the current filter is enabled.
        /// </summary>
        public bool IsFilterEnabled
        {
            get;
            set;
        }

        /// <summary>
        /// Represents a list of all the pages in the log.
        /// </summary>
        public Pages Pages
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HTTPWatchWrapper\HTTPWatchWrapper\Page.cs ===
﻿using System;
using System.Text;

namespace Test.Common.Library.HTTPWatchWrapper
{
    /// <summary>
    /// Represents information about a web page and the HTTP
    /// requests that were used to download it.
    /// </summary>
    public class Page
    {
        /// <summary>
        /// Indicates whether this page was a dynamic update to an existing web page.
        /// E.g. modified by AJAX / Javascript.
        /// </summary>
        public bool Dynamic
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the time when this request was started as an offset
        /// from the start of the log.
        /// </summary>
        public string Started
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the date and time when this page was started.
        /// </summary>
        public DateTime StartedDateTime
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the time when this page was started as an offset
        /// in seconds from the start of the log.
        /// </summary>
        public double StartedSecs
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the title of this page.
        /// </summary>
        public string Title
        {
            get;
            set;
        }

        /// <summary>
        /// Indicates whether this page contains a single request that was not directly
        /// associated with a window or tab in Internet Explorer.
        /// E.g. the download of a icon for a bookmark or location bar.
        /// </summary>
        public bool Unknown
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HTTPWatchWrapper\HTTPWatchWrapper\HTTPWatchLogger.cs ===
﻿using System;
using System.IO;
using System.Text;

namespace Test.Common.Library.HTTPWatchWrapper
{
    /// <summary>
    /// Represents the logger for the HTTPWatch module.
    /// </summary>
    internal class HTTPWatchLogger
    {
        private StreamWriter g_LogFile = null;
        private readonly string G_LOGFILENAME = String.Empty;

        /// <summary>
        /// The level of the log entry being written.
        /// </summary>
        public enum LogLevel
        {
            /// <summary>
            /// Informational message.
            /// </summary>
            Message = 1,
            /// <summary>
            /// Warning message.
            /// </summary>
            Warning = 2,
            /// <summary>
            /// Exception message.
            /// </summary>
            Exception = 3
        }

        /// <summary>
        /// Initializes a new instance of the Daemon Logger with the specified
        /// log file name.
        /// </summary>
        /// <param name="LogFileName">The name of the Log File.</param>
        public HTTPWatchLogger(string LogFileName)
        {
            G_LOGFILENAME = LogFileName;
            try
            {
                g_LogFile = new StreamWriter(G_LOGFILENAME, true);
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Gets the name of the Log File.
        /// </summary>
        public string LogFileName
        {
            get { return G_LOGFILENAME; }
        }

        /// <summary>
        /// Closes this log file.
        /// </summary>
        public void Close()
        {
            try
            {
                g_LogFile.Close();
                g_LogFile = null;
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Writes a log entry to the log file with the specified
        /// Logentry level.
        /// </summary>
        /// <param name="Level">The level of the log entry being written.</param>
        /// <param name="LogEntry">The log entry to write to the log file.</param>
        public void WriteLine(LogLevel Level, string LogEntry)
        {
            string m_TimeStamp = DateTime.Now.ToString() + " ";

            try
            {
                if (!String.IsNullOrEmpty(LogEntry))
                {
                    switch (Level)
                    {
                        case LogLevel.Warning:
                            g_LogFile.WriteLine(m_TimeStamp + "WARN: " + LogEntry);
                            break;
                        case LogLevel.Message:
                            g_LogFile.WriteLine(m_TimeStamp + "INFO: " + LogEntry);
                            break;
                        case LogLevel.Exception:
                            g_LogFile.WriteLine(m_TimeStamp + "ERROR: " + LogEntry);
                            break;
                    }
                    g_LogFile.Flush();
                }
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Writes the specified Exception to the log file.
        /// </summary>
        /// <param name="Error">The exception to write to the log file.</param>
        public void WriteLine(Exception Error)
        {
            string m_TimeStamp = DateTime.Now.ToString() + " ";

            try
            {
                g_LogFile.WriteLine(m_TimeStamp + "ERROR: " + Error);
                g_LogFile.Flush();
            }
            catch (Exception)
            {
                throw;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HTTPWatchWrapper\HTTPWatchWrapper\Pages.cs ===
﻿using System;
using System.Collections;
using System.Text;

namespace Test.Common.Library.HTTPWatchWrapper
{
    /// <summary>
    /// Represents a collection of Page objects. 
    /// </summary>
    public class Pages : CollectionBase
    {
        /// <summary>
        /// Create an empty collection of Page objects.
        /// </summary>
        public Pages() { }

        /// <summary>
        /// Create a collection of Page objects with the specified Page
        /// as the first item in the collection.
        /// </summary>
        /// <param name="Parameter">The Page object to add to the collection.</param>
        public Pages(Page Parameter)
        {
            this.List.Add(Parameter);
        }

        /// <summary>
        /// Adds the specified Page object to the collection.
        /// </summary>
        /// <param name="Parameter">The Page object to add to the collection.</param>
        /// <returns>An integer indicating the index where the object was added.</returns>
        public int Add(Page Parameter)
        {
            return this.List.Add(Parameter);
        }

        /// <summary>
        /// Gets or sets the value of a pre existing element in the collection.
        /// </summary>
        /// <param name="index">The index of the element in the collection.</param>
        /// <returns>A Page object corresponding to the specified index.</returns>
        public Page this[int index]
        {
            get { return (Page)this.List[index]; }

            set
            {
                try
                {
                    this.List[index] = value;
                }
                catch (Exception)
                {
                    throw;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HTTPWatchWrapper\HTTPWatchWrapper\POSTParameter.cs ===
﻿using System;
using System.Text;

namespace Test.Common.Library.HTTPWatchWrapper
{
    /// <summary>
    /// Represents a single parameter that was encoded in the URL of an HTTP request.
    /// </summary>
    public class POSTParameter
    {
        /// <summary>
        /// Represents the name of the parameter.
        /// </summary>
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the value of the parameter.
        /// </summary>
        public string Value
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HTTPWatchWrapper\HTTPWatchWrapper\HTTPWatcher.cs ===
﻿using System;
using System.Text;
using System.Diagnostics;
using System.Threading;
using System.Runtime.InteropServices;
using System.IO;
using HttpWatch;

namespace Test.Common.Library.HTTPWatchWrapper
{
    /// <summary>
    /// Represents the wrapper for HTTP Watcher.
    /// </summary>
    public class HTTPWatcher : IDisposable
    {
        private HttpWatch.ControllerClass g_COM_HTTPWatchController = null;
        private HttpWatch.Plugin g_COM_HTTPWatchPlugin = null;
        private HttpWatch.Log g_COM_HTTPWatchLog = null;
        private HTTPWatchLog g_HTTPWatchLog = null;
        private string g_HTTPWatchLogFile = null;
        private bool g_IsDisposed;
        private HTTPWatchLogger g_Logger = null;

        /// <summary>
        /// Initializes a new instance of the HTTPWatcher class. <br/>
        /// NOTE: You must have <b>HTTPWatch 5.3</b> installed on your machine to use this library.
        /// See HTTPWatcherPreReq.txt in the dll folder for more details.
        /// </summary>
        public HTTPWatcher()
        {
            //Init Logger
            try
            {
                g_Logger = new HTTPWatchLogger("HTTPWatchDebugLog.log");
                g_Logger.WriteLine(HTTPWatchLogger.LogLevel.Message,
                                   "***********************************************************************");
            }
            catch (Exception)
            {
                throw;
            }

            //Init Controller
            try
            {
                g_COM_HTTPWatchController = new ControllerClass();
                g_IsDisposed = false;
                g_Logger.WriteLine(HTTPWatchLogger.LogLevel.Message, "HTTP Watch Controller initialized.");
            }
            catch (Exception Error)
            {
                g_Logger.WriteLine(HTTPWatchLogger.LogLevel.Exception, "Error occured while initializing HTTP Watch controller.");
                g_Logger.WriteLine(Error);
                g_Logger.Close();
                throw;
            }
        }

        /// <summary>
        /// Navigates to the specified URI in a Internet Explorer window.
        /// </summary>
        /// <param name="URI">The URI to navigate to.</param>
        /// <param name="WaitTimeOut">The maximum time in seconds to wait for page to finish loading. If the page does not load within
        /// this time, the function returns false. If it loads within the specified time, it will return true as soon as the page
        /// completes loading. Specify a value of -1 for infinite wait.</param>
        /// <remarks>True if the page was loaded within the specified wait time out, otherwise False.</remarks>
        public bool NavigateTo(string URI, int WaitTimeOut)
        {
            bool m_IsPageLoaded = false;
            Timer m_IELoadTimer = null;

            try
            {
                //Init & Start Timer
                m_IELoadTimer = new Timer(new TimerCallback(TimerExpire),
                                          null,
                                          new TimeSpan(0, 0, WaitTimeOut + 5),
                                          new TimeSpan(0, 0, 0, 0, -1)
                                         );

                if (g_COM_HTTPWatchPlugin == null)
                    OpenBrowser();

                //Start Recording
                g_COM_HTTPWatchLog = g_COM_HTTPWatchPlugin.Log;
                g_COM_HTTPWatchLog.EnableFilter(false);         //Can be used to provide filters.
                g_COM_HTTPWatchPlugin.Record();
                g_Logger.WriteLine(HTTPWatchLogger.LogLevel.Message, "HTTP Watch Recording started.");

                //Navigate to specified URI
                g_Logger.WriteLine(HTTPWatchLogger.LogLevel.Message, "Navigating to " + URI);
                g_COM_HTTPWatchPlugin.GotoURL(URI);

                //Wait for page load
                m_IsPageLoaded = g_COM_HTTPWatchController.Wait(g_COM_HTTPWatchPlugin, WaitTimeOut);
                if (m_IsPageLoaded)
                    g_Logger.WriteLine(HTTPWatchLogger.LogLevel.Message, "Page load completed.");
                else
                    g_Logger.WriteLine(HTTPWatchLogger.LogLevel.Warning, "Page load timed out.");

                //Dispose Timer
                m_IELoadTimer.Dispose();

                //Stop Recording
                g_COM_HTTPWatchPlugin.Stop();
                g_Logger.WriteLine(HTTPWatchLogger.LogLevel.Message, "HTTP Watch Recording stopped.");

                return m_IsPageLoaded;
            }
            catch (Exception Error)
            {
                g_Logger.WriteLine(HTTPWatchLogger.LogLevel.Exception, "An error occured in ::NavigateTo()");
                g_Logger.WriteLine(Error);
                throw;
            }
        }

        /// <summary>
        /// Callback for IE Load Timer.
        /// </summary>
        /// <param name="StateInfo">A state object. Not used.</param>
        private void TimerExpire(object StateInfo)
        {
            g_Logger.WriteLine(HTTPWatchLogger.LogLevel.Warning, "The IE Load timer has expired.");
            g_Logger.WriteLine(HTTPWatchLogger.LogLevel.Warning, "This indicates a possible IE crash. Terminating IE ...");

            try
            {
                ShutDownIE();
            }
            catch { }
        }

        /// <summary>
        /// Opens a new Internet Explorer browser window. If a window handle already exists then it will do nothing.
        /// </summary>
        public void OpenBrowser()
        {
            int m_AttempNo = 1;
            bool m_Success = false;

            while (m_Success == false)
            {
                try
                {
                    if (g_COM_HTTPWatchPlugin == null)
                        g_COM_HTTPWatchPlugin = g_COM_HTTPWatchController.New();
                    g_Logger.WriteLine(HTTPWatchLogger.LogLevel.Message, "New Browser instance opened.");
                    m_Success = true;
                }
                catch (Exception Error)
                {
                    //There is a bug where if we open IE over and over again, the plugin will fail to attach to
                    //the IE window. If we try again, then it manages to attach to IE.
                    //This loop will try opening IE 100 times, if there is an attach failure.
                    g_Logger.WriteLine(HTTPWatchLogger.LogLevel.Message, "Attempt # " + m_AttempNo.ToString());
                    g_Logger.WriteLine(HTTPWatchLogger.LogLevel.Warning, "Failed to attach to IE window. Trying again ...");
                    ShutDownIE();
                    m_AttempNo++;

                    //Retry for 100 times.
                    if (m_AttempNo > 100)
                    {
                        g_Logger.WriteLine(HTTPWatchLogger.LogLevel.Exception, "Unable to attach to IE window after 100 attempts. Giving up ...");
                        g_Logger.WriteLine(Error);
                        throw;
                    }
                }
            }
        }

        /// <summary>
        /// Kills IE process
        /// </summary>
        private void ShutDownIE()
        {
            Process[] m_Processes = null;

            try
            {
                m_Processes = Process.GetProcessesByName("IEXPLORE");
                if (m_Processes.Length > 0)
                {
                    foreach (Process m_IE in m_Processes)
                        m_IE.Kill();
                    Thread.Sleep(5000);
                }
                g_Logger.WriteLine(HTTPWatchLogger.LogLevel.Message, "All IE instances killed.");
            }
            catch (Exception Error)
            {
                g_Logger.WriteLine(HTTPWatchLogger.LogLevel.Exception, "Error occured in ::ShutDownIE()");
                g_Logger.WriteLine(Error);
                throw;
            }
        }

        /// <summary>
        /// Does a proper dispose of the object including releasing
        /// all COM components.
        /// </summary>
        public void Dispose()
        {
            if (!g_IsDisposed)
            {
                Dispose(true);
                GC.SuppressFinalize(this);
            }
        }

        /// <summary>
        /// Destructor.
        /// </summary>
        ~HTTPWatcher()
        {
            Dispose(false);
        }

        /// <summary>
        /// Disposes the object.
        /// </summary>
        /// <param name="Disposing">Indicates whether the object is being disposed.</param>
        protected virtual void Dispose(bool Disposing)
        {
            if (!g_IsDisposed)
            {
                if (Disposing)
                {
                    g_HTTPWatchLog = null;
                    if (g_Logger != null)
                    {
                        g_Logger.Close();
                        g_Logger = null;
                    }
                }
                if (g_COM_HTTPWatchController != null)
                {
                    ReleaseCOMPluginObjects();
                }
                g_IsDisposed = true;
            }
        }

        /// <summary>
        /// Closes the Internet Explorer browser window. If no browser window is open, then it does nothing.
        /// </summary>
        /// <remarks>
        /// The browser must have been opened via the <i>OpenBrowser</i> or <i>NavigateTo</i> method. Any browsers
        /// already open via other means, will not be effected.
        /// </remarks>
        public void CloseBrowser()
        {
            SHDocVw.IWebBrowser2 m_COM_InternetExplorer = null;

            try
            {
                if (g_COM_HTTPWatchPlugin != null)
                {
                    //Clone the HTTP Watch COM log object to .NET object.
                    CloneCOMLog();
                    g_Logger.WriteLine(HTTPWatchLogger.LogLevel.Message, "HTTPWatch COM Log object cloned.");

                    //Save the log to Local App Data folder
                    SaveHTTPWatchLog();

                    //Close IE Browser
                    m_COM_InternetExplorer = g_COM_HTTPWatchPlugin.Container;
                    m_COM_InternetExplorer.Quit();
                    Thread.Sleep(2000);
                    ShutDownIE();       //In case an error occured while quitting IE
                    g_Logger.WriteLine(HTTPWatchLogger.LogLevel.Message, "IE Window closed.");
                    Marshal.FinalReleaseComObject(m_COM_InternetExplorer);
                    m_COM_InternetExplorer = null;
                    g_Logger.WriteLine(HTTPWatchLogger.LogLevel.Message,"COM_RELEASE::IE COM object.");

                    //Release all HTTP Watch COM objects
                    ReleaseCOMPluginObjects();
                    g_Logger.WriteLine(HTTPWatchLogger.LogLevel.Message, "All COM objects released.");
                    g_Logger.Close();
                    g_Logger = null;
                }
            }
            catch (Exception Error)
            {
                g_Logger.WriteLine(HTTPWatchLogger.LogLevel.Exception, "Error occured in ::CloseBrowser()");
                g_Logger.WriteLine(Error);
                g_Logger.Close();
                g_Logger = null;
                throw;
            }
        }

        /// <summary>
        /// Saves the HTTP Watch Log file to Local Application Data folder.
        /// </summary>
        private void SaveHTTPWatchLog()
        {
            string m_LocalAppDataPath = "";
            try
            {
                m_LocalAppDataPath = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
                g_HTTPWatchLogFile = Guid.NewGuid().ToString() + ".hwl";

                //Check if file with same name already exists
                if (File.Exists(m_LocalAppDataPath + "\\" + g_HTTPWatchLogFile))
                    File.Delete(m_LocalAppDataPath + "\\" + g_HTTPWatchLogFile);

                g_COM_HTTPWatchLog.Save(m_LocalAppDataPath + "\\" + g_HTTPWatchLogFile);
                g_Logger.WriteLine(HTTPWatchLogger.LogLevel.Message, "HTTPWatch Log file saved to temp location:");
                g_Logger.WriteLine(HTTPWatchLogger.LogLevel.Message,
                                   m_LocalAppDataPath +
                                   "\\" + g_HTTPWatchLogFile);
            }
            catch (Exception Error)
            {
                g_Logger.WriteLine(HTTPWatchLogger.LogLevel.Exception, "Error occured in ::SaveHTTPWatchLog()");
                g_Logger.WriteLine(Error);
                throw;
            }
        }

        /// <summary>
        /// Clones the HTTPWatch COM Log object to a .NET object.
        /// </summary>
        private void CloneCOMLog()
        {
            g_HTTPWatchLog = new HTTPWatchLog()
                                    {
                                        HasNetworkTimings = g_COM_HTTPWatchLog.HasNetworkTimings,
                                        HasPageGrouping = g_COM_HTTPWatchLog.HasPageGrouping,
                                        IsFilterEnabled = g_COM_HTTPWatchLog.IsFilterEnabled
                                    };

            if (g_HTTPWatchLog.IsFilterEnabled)
            {
                g_HTTPWatchLog.Entries = CloneHTTPWatchLogEntries(HTTPWatchLogEntriesType.RAWEntries);
                g_Logger.WriteLine(HTTPWatchLogger.LogLevel.Message, "Entries cloned successfully.");
                g_HTTPWatchLog.FilteredEntries = CloneHTTPWatchLogEntries(HTTPWatchLogEntriesType.FilteredEntries);
                g_Logger.WriteLine(HTTPWatchLogger.LogLevel.Message, "FilteredEntries cloned successfully.");
                g_HTTPWatchLog.Pages = CloneHTTPWatchLogPages(HTTPWatchLogPagesType.RAWPages);
                g_Logger.WriteLine(HTTPWatchLogger.LogLevel.Message, "Pages cloned successfully.");
                g_HTTPWatchLog.FilteredPages = CloneHTTPWatchLogPages(HTTPWatchLogPagesType.FilteredPages);
                g_Logger.WriteLine(HTTPWatchLogger.LogLevel.Message, "FilteredPages cloned successfully.");
            }
            else
            {
                Entries m_LogEntries = CloneHTTPWatchLogEntries(HTTPWatchLogEntriesType.RAWEntries);
                Pages m_LogPages = CloneHTTPWatchLogPages(HTTPWatchLogPagesType.RAWPages);
                g_HTTPWatchLog.Entries = m_LogEntries;
                g_Logger.WriteLine(HTTPWatchLogger.LogLevel.Message, "Entries cloned successfully.");
                g_HTTPWatchLog.FilteredEntries = m_LogEntries;
                g_Logger.WriteLine(HTTPWatchLogger.LogLevel.Message, "FilteredEntries cloned successfully.");
                g_HTTPWatchLog.Pages = m_LogPages;
                g_Logger.WriteLine(HTTPWatchLogger.LogLevel.Message, "Pages cloned successfully.");
                g_HTTPWatchLog.FilteredPages = m_LogPages;
                g_Logger.WriteLine(HTTPWatchLogger.LogLevel.Message, "FilteredPages cloned successfully.");
                m_LogPages = null;
                m_LogEntries = null;
            }
        }

        /// <summary>
        /// Represents the type of entries object to clone.
        /// </summary>
        private enum HTTPWatchLogEntriesType
        {
            /// <summary>
            /// Represents the RAW, unfiltered entries.
            /// </summary>
            RAWEntries,
            /// <summary>
            /// Represents the filtered entries.
            /// </summary>
            FilteredEntries
        }

        /// <summary>
        /// Represents the type of pages object to clone.
        /// </summary>
        private enum HTTPWatchLogPagesType
        {
            /// <summary>
            /// Represents the RAW, unfiltered pages.
            /// </summary>
            RAWPages,
            /// <summary>
            /// Represents the filtered pages.
            /// </summary>
            FilteredPages
        }

        /// <summary>
        /// Clones the specified type of entries object of the HTTPWatch COM Log
        /// to a .NET object.
        /// </summary>
        /// <param name="EntriesType">The type of entries to clone.</param>
        /// <returns>An object of Entries class which represents the cloned .NET object.</returns>
        private Entries CloneHTTPWatchLogEntries(HTTPWatchLogEntriesType EntriesType)
        {
            HttpWatch.Entries m_COM_HTTPWatchLogEntries = null;
            Entries m_HTTPWatchEntries = null;

            try
            {
                switch (EntriesType)
                {
                    case HTTPWatchLogEntriesType.RAWEntries:
                        m_COM_HTTPWatchLogEntries = g_COM_HTTPWatchLog.Entries;
                        break;
                    case HTTPWatchLogEntriesType.FilteredEntries:
                        m_COM_HTTPWatchLogEntries = g_COM_HTTPWatchLog.FilteredEntries;
                        break;
                }

                m_HTTPWatchEntries = new Entries();

                #region Clone specified Entries object
                #region Clone Individual Entry
                for (int m_Counter = 0; m_Counter < m_COM_HTTPWatchLogEntries.Count; m_Counter++)
                {
                    Entry m_HTTPWatchEntry = new Entry();
                    HttpWatch.Entry m_COM_HTTPWatchEntry = null;
                    HttpWatch.CacheInfo m_COM_HTTPWatchCacheInfoAfter = null;
                    HttpWatch.CacheInfo m_COM_HTTPWatchCacheInfoBefore = null;
                    HttpWatch.Content m_COM_HTTPWatchContent = null;
                    HttpWatch.Page m_COM_HTTPWatchPage = null;
                    HttpWatch.Request m_COM_HTTPWatchRequest = null;
                    HttpWatch.Response m_COM_HTTPWatchResponse = null;
                    HttpWatch.Cookies m_COM_HTTPWatchCookies = null;
                    HttpWatch.Headers m_COM_HTTPWatchHeaders = null;
                    HttpWatch.POSTParameters m_COM_HTTPWatchPOSTParams = null;
                    HttpWatch.QueryStringValues m_COM_HTTPWatchQSValues = null;
                    HttpWatch.Timings m_COM_HTTPWatchTimings = null;
                    HttpWatch.Timing m_COM_HTTPWatchTiming = null;

                    m_COM_HTTPWatchEntry = m_COM_HTTPWatchLogEntries[m_Counter];

                    //Start Cloning
                    m_HTTPWatchEntry.BytesReceived = m_COM_HTTPWatchEntry.BytesReceived;
                    m_HTTPWatchEntry.BytesSent = m_COM_HTTPWatchEntry.BytesSent;
                    #region CacheAfter
                    m_COM_HTTPWatchCacheInfoAfter = m_COM_HTTPWatchEntry.CacheAfter;
                    m_HTTPWatchEntry.CacheAfter = new CacheInfo()
                    {
                        ETag = m_COM_HTTPWatchCacheInfoAfter.ETag,
                        Expires = m_COM_HTTPWatchCacheInfoAfter.Expires,
                        HitCount = m_COM_HTTPWatchCacheInfoAfter.HitCount,
                        IsExpiresSet = m_COM_HTTPWatchCacheInfoAfter.IsExpiresSet,
                        IsLastModifiedSet = m_COM_HTTPWatchCacheInfoAfter.IsLastModifiedSet,
                        LastAccess = m_COM_HTTPWatchCacheInfoAfter.LastAccess,
                        LastModified = m_COM_HTTPWatchCacheInfoAfter.LastModified,
                        LastUpdate = m_COM_HTTPWatchCacheInfoAfter.LastUpdate,
                        URLInCache = m_COM_HTTPWatchCacheInfoAfter.URLInCache
                    };
                    Marshal.FinalReleaseComObject(m_COM_HTTPWatchCacheInfoAfter);
                    m_COM_HTTPWatchCacheInfoAfter = null;
                    #endregion
                    #region CacheBefore
                    m_COM_HTTPWatchCacheInfoBefore = m_COM_HTTPWatchEntry.CacheBefore;
                    m_HTTPWatchEntry.CacheBefore = new CacheInfo()
                    {
                        ETag = m_COM_HTTPWatchCacheInfoBefore.ETag,
                        Expires = m_COM_HTTPWatchCacheInfoBefore.Expires,
                        HitCount = m_COM_HTTPWatchCacheInfoBefore.HitCount,
                        IsExpiresSet = m_COM_HTTPWatchCacheInfoBefore.IsExpiresSet,
                        IsLastModifiedSet = m_COM_HTTPWatchCacheInfoBefore.IsLastModifiedSet,
                        LastAccess = m_COM_HTTPWatchCacheInfoBefore.LastAccess,
                        LastModified = m_COM_HTTPWatchCacheInfoBefore.LastModified,
                        LastUpdate = m_COM_HTTPWatchCacheInfoBefore.LastUpdate,
                        URLInCache = m_COM_HTTPWatchCacheInfoBefore.URLInCache
                    };
                    Marshal.FinalReleaseComObject(m_COM_HTTPWatchCacheInfoBefore);
                    m_COM_HTTPWatchCacheInfoBefore = null;
                    #endregion
                    m_HTTPWatchEntry.ClientIP = m_COM_HTTPWatchEntry.ClientIP;
                    m_HTTPWatchEntry.ClientPort = m_COM_HTTPWatchEntry.ClientPort;
                    #region Content
                    m_COM_HTTPWatchContent = m_COM_HTTPWatchEntry.Content;
                    m_HTTPWatchEntry.Content = new Content()
                    {
                        CompressedSize = m_COM_HTTPWatchContent.CompressedSize,
                        CompressionType = m_COM_HTTPWatchContent.CompressionType,
                        Data = m_COM_HTTPWatchContent.Data,
                        IsCompressed = m_COM_HTTPWatchContent.IsCompressed,
                        IsFromCache = m_COM_HTTPWatchContent.IsFromCache,
                        MimeType = m_COM_HTTPWatchContent.MimeType,
                        Size = m_COM_HTTPWatchContent.Size
                    };
                    Marshal.FinalReleaseComObject(m_COM_HTTPWatchContent);
                    m_COM_HTTPWatchContent = null;
                    #endregion
                    m_HTTPWatchEntry.Error = m_COM_HTTPWatchEntry.Error;
                    m_HTTPWatchEntry.IsComplete = m_COM_HTTPWatchEntry.IsComplete;
                    m_HTTPWatchEntry.IsRedirect = m_COM_HTTPWatchEntry.IsRedirect;
                    m_HTTPWatchEntry.Method = m_COM_HTTPWatchEntry.Method;
                    #region Page
                    m_COM_HTTPWatchPage = m_COM_HTTPWatchEntry.Page;
                    m_HTTPWatchEntry.Page = new Page()
                    {
                        Dynamic = m_COM_HTTPWatchPage.Dynamic,
                        Started = m_COM_HTTPWatchPage.Started,
                        StartedDateTime = m_COM_HTTPWatchPage.StartedDateTime,
                        StartedSecs = m_COM_HTTPWatchPage.StartedSecs,
                        Title = m_COM_HTTPWatchPage.Title,
                        Unknown = m_COM_HTTPWatchPage.Unknown
                    };
                    Marshal.FinalReleaseComObject(m_COM_HTTPWatchPage);
                    m_COM_HTTPWatchPage = null;
                    #endregion
                    m_HTTPWatchEntry.RedirectURL = m_COM_HTTPWatchEntry.RedirectURL;
                    #region Request
                    m_COM_HTTPWatchRequest = m_COM_HTTPWatchEntry.Request;
                    #region Request::Cookies
                    m_COM_HTTPWatchCookies = m_COM_HTTPWatchRequest.Cookies;
                    Cookies m_RequestCookies = new Cookies();
                    for (int m_CookieCount = 0; m_CookieCount < m_COM_HTTPWatchCookies.Count; m_CookieCount++)
                    {
                        HttpWatch.Cookie m_COM_HTTPWatchCookie = m_COM_HTTPWatchCookies[m_CookieCount];
                        m_RequestCookies.Add(new Cookie()
                        {
                            Domain = m_COM_HTTPWatchCookie.Domain,
                            Expires = m_COM_HTTPWatchCookie.Expires,
                            IsSessionCookie = m_COM_HTTPWatchCookie.IsSessionCookie,
                            Name = m_COM_HTTPWatchCookie.Name,
                            Path = m_COM_HTTPWatchCookie.Path,
                            Value = m_COM_HTTPWatchCookie.Value
                        }
                                     );
                        Marshal.FinalReleaseComObject(m_COM_HTTPWatchCookie);
                        m_COM_HTTPWatchCookie = null;
                    }
                    m_COM_HTTPWatchCookies = null;
                    #endregion
                    #region Request::Headers
                    m_COM_HTTPWatchHeaders = m_COM_HTTPWatchRequest.Headers;
                    Headers m_RequestHeaders = new Headers();
                    for (int m_HeaderCount = 0; m_HeaderCount < m_COM_HTTPWatchHeaders.Count; m_HeaderCount++)
                    {
                        HttpWatch.Header m_COM_HTTPWatchHeader = m_COM_HTTPWatchHeaders[m_HeaderCount];
                        m_RequestHeaders.Add(new Header()
                        {
                            Name = m_COM_HTTPWatchHeader.Name,
                            Value = m_COM_HTTPWatchHeader.Value
                        }
                                            );
                        Marshal.FinalReleaseComObject(m_COM_HTTPWatchHeader);
                        m_COM_HTTPWatchHeader = null;
                    }
                    m_COM_HTTPWatchHeaders = null;
                    #endregion
                    #region Request::POSTParameters
                    m_COM_HTTPWatchPOSTParams = m_COM_HTTPWatchRequest.POSTParameters;
                    POSTParameters m_POSTParams = new POSTParameters();
                    for (int m_ParamCount = 0; m_ParamCount < m_COM_HTTPWatchPOSTParams.Count; m_ParamCount++)
                    {
                        HttpWatch.POSTParameter m_COM_HTTPWatchPOSTParam = m_COM_HTTPWatchPOSTParams[m_ParamCount];
                        m_POSTParams.Add(new POSTParameter()
                        {
                            Name = m_COM_HTTPWatchPOSTParam.Name,
                            Value = m_COM_HTTPWatchPOSTParam.Value
                        }
                                        );
                        Marshal.FinalReleaseComObject(m_COM_HTTPWatchPOSTParam);
                        m_COM_HTTPWatchPOSTParam = null;
                    }
                    Marshal.FinalReleaseComObject(m_COM_HTTPWatchPOSTParams);
                    m_COM_HTTPWatchPOSTParams = null;
                    #endregion
                    #region Request::QueryStringValues
                    m_COM_HTTPWatchQSValues = m_COM_HTTPWatchRequest.QueryStringValues;
                    QueryStringValues m_QSValues = new QueryStringValues();
                    for (int m_QSCount = 0; m_QSCount < m_COM_HTTPWatchQSValues.Count; m_QSCount++)
                    {
                        HttpWatch.QueryStringValue m_COM_HTTPWatchQSValue = m_COM_HTTPWatchQSValues[m_QSCount];
                        m_QSValues.Add(new QueryStringValue()
                        {
                            Name = m_COM_HTTPWatchQSValue.Name,
                            Value = m_COM_HTTPWatchQSValue.Value
                        }
                                      );
                        Marshal.FinalReleaseComObject(m_COM_HTTPWatchQSValue);
                        m_COM_HTTPWatchQSValue = null;
                    }
                    Marshal.FinalReleaseComObject(m_COM_HTTPWatchQSValues);
                    m_COM_HTTPWatchQSValues = null;
                    #endregion
                    m_HTTPWatchEntry.Request = new Request()
                    {
                        Cookies = m_RequestCookies,
                        Headers = m_RequestHeaders,
                        POSTMimeType = m_COM_HTTPWatchRequest.POSTMimeType,
                        POSTParameters = m_POSTParams,
                        QueryStringValues = m_QSValues,
                        RequestLine = m_COM_HTTPWatchRequest.RequestLine,
                        Stream = m_COM_HTTPWatchRequest.Stream
                    };
                    Marshal.FinalReleaseComObject(m_COM_HTTPWatchRequest);
                    m_COM_HTTPWatchRequest = null;
                    #endregion
                    #region Response
                    m_COM_HTTPWatchResponse = m_COM_HTTPWatchEntry.Response;
                    #region Response::Cookies
                    m_COM_HTTPWatchCookies = m_COM_HTTPWatchResponse.Cookies;
                    Cookies m_ResponseCookies = new Cookies();
                    for (int m_CookieCount = 0; m_CookieCount < m_COM_HTTPWatchCookies.Count; m_CookieCount++)
                    {
                        HttpWatch.Cookie m_COM_HTTPWatchCookie = m_COM_HTTPWatchCookies[m_CookieCount];
                        m_ResponseCookies.Add(new Cookie()
                        {
                            Domain = m_COM_HTTPWatchCookie.Domain,
                            Expires = m_COM_HTTPWatchCookie.Expires,
                            IsSessionCookie = m_COM_HTTPWatchCookie.IsSessionCookie,
                            Name = m_COM_HTTPWatchCookie.Name,
                            Path = m_COM_HTTPWatchCookie.Path,
                            Value = m_COM_HTTPWatchCookie.Value
                        }
                                             );
                        Marshal.FinalReleaseComObject(m_COM_HTTPWatchCookie);
                        m_COM_HTTPWatchCookie = null;
                    }
                    Marshal.FinalReleaseComObject(m_COM_HTTPWatchCookies);
                    m_COM_HTTPWatchCookies = null;
                    #endregion
                    #region Response::Headers
                    m_COM_HTTPWatchHeaders = m_COM_HTTPWatchResponse.Headers;
                    Headers m_ResponseHeaders = new Headers();
                    for (int m_HeaderCount = 0; m_HeaderCount < m_COM_HTTPWatchHeaders.Count; m_HeaderCount++)
                    {
                        HttpWatch.Header m_COM_HTTPWatchHeader = m_COM_HTTPWatchHeaders[m_HeaderCount];
                        m_ResponseHeaders.Add(new Header()
                        {
                            Name = m_COM_HTTPWatchHeader.Name,
                            Value = m_COM_HTTPWatchHeader.Value
                        }
                                             );
                        Marshal.FinalReleaseComObject(m_COM_HTTPWatchHeader);
                        m_COM_HTTPWatchHeader = null;
                    }
                    Marshal.FinalReleaseComObject(m_COM_HTTPWatchHeaders);
                    m_COM_HTTPWatchHeaders = null;
                    #endregion
                    m_HTTPWatchEntry.Response = new Response()
                    {
                        Cookies = m_ResponseCookies,
                        Chunks = m_COM_HTTPWatchResponse.Chunks,
                        Headers = m_ResponseHeaders,
                        StatusLine = m_COM_HTTPWatchResponse.StatusLine,
                        Stream = m_COM_HTTPWatchResponse.Stream
                    };
                    Marshal.FinalReleaseComObject(m_COM_HTTPWatchResponse);
                    m_COM_HTTPWatchResponse = null;
                    #endregion
                    m_HTTPWatchEntry.Result = m_COM_HTTPWatchEntry.Result;
                    m_HTTPWatchEntry.ServerIP = m_COM_HTTPWatchEntry.ServerIP;
                    m_HTTPWatchEntry.ServerPort = m_COM_HTTPWatchEntry.ServerPort;
                    m_HTTPWatchEntry.Started = m_COM_HTTPWatchEntry.Started;
                    m_HTTPWatchEntry.StartedDateTime = m_COM_HTTPWatchEntry.StartedDateTime;
                    m_HTTPWatchEntry.StartedSecs = m_COM_HTTPWatchEntry.StartedSecs;
                    m_HTTPWatchEntry.StatusCode = m_COM_HTTPWatchEntry.StatusCode;
                    m_HTTPWatchEntry.Time = m_COM_HTTPWatchEntry.Time;
                    #region Timings
                    m_COM_HTTPWatchTimings = m_COM_HTTPWatchEntry.Timings;
                    Timings m_Timings = new Timings();
                    m_COM_HTTPWatchTiming = m_COM_HTTPWatchTimings.Blocked;
                    m_Timings.Blocked = new Timing()
                    {
                        Duration = m_COM_HTTPWatchTiming.Duration,
                        Started = m_COM_HTTPWatchTiming.Started,
                        Valid = m_COM_HTTPWatchTiming.Valid
                    };
                    m_COM_HTTPWatchTiming = m_COM_HTTPWatchTimings.CacheRead;
                    m_Timings.CacheRead = new Timing()
                    {
                        Duration = m_COM_HTTPWatchTiming.Duration,
                        Started = m_COM_HTTPWatchTiming.Started,
                        Valid = m_COM_HTTPWatchTiming.Valid
                    };
                    m_COM_HTTPWatchTiming = m_COM_HTTPWatchTimings.Connect;
                    m_Timings.Connect = new Timing()
                    {
                        Duration = m_COM_HTTPWatchTiming.Duration,
                        Started = m_COM_HTTPWatchTiming.Started,
                        Valid = m_COM_HTTPWatchTiming.Valid
                    };
                    m_COM_HTTPWatchTiming = m_COM_HTTPWatchTimings.DNSLookup;
                    m_Timings.DNSLookup = new Timing()
                    {
                        Duration = m_COM_HTTPWatchTiming.Duration,
                        Started = m_COM_HTTPWatchTiming.Started,
                        Valid = m_COM_HTTPWatchTiming.Valid
                    };
                    m_COM_HTTPWatchTiming = m_COM_HTTPWatchTimings.Network;
                    m_Timings.Network = new Timing()
                    {
                        Duration = m_COM_HTTPWatchTiming.Duration,
                        Started = m_COM_HTTPWatchTiming.Started,
                        Valid = m_COM_HTTPWatchTiming.Valid
                    };
                    m_COM_HTTPWatchTiming = m_COM_HTTPWatchTimings.Receive;
                    m_Timings.Receive = new Timing()
                    {
                        Duration = m_COM_HTTPWatchTiming.Duration,
                        Started = m_COM_HTTPWatchTiming.Started,
                        Valid = m_COM_HTTPWatchTiming.Valid
                    };
                    m_COM_HTTPWatchTiming = m_COM_HTTPWatchTimings.Send;
                    m_Timings.Send = new Timing()
                    {
                        Duration = m_COM_HTTPWatchTiming.Duration,
                        Started = m_COM_HTTPWatchTiming.Started,
                        Valid = m_COM_HTTPWatchTiming.Valid
                    };
                    m_COM_HTTPWatchTiming = m_COM_HTTPWatchTimings.TTFB;
                    m_Timings.TTFB = new Timing()
                    {
                        Duration = m_COM_HTTPWatchTiming.Duration,
                        Started = m_COM_HTTPWatchTiming.Started,
                        Valid = m_COM_HTTPWatchTiming.Valid
                    };
                    m_COM_HTTPWatchTiming = m_COM_HTTPWatchTimings.Wait;
                    m_Timings.Wait = new Timing()
                    {
                        Duration = m_COM_HTTPWatchTiming.Duration,
                        Started = m_COM_HTTPWatchTiming.Started,
                        Valid = m_COM_HTTPWatchTiming.Valid
                    };
                    m_HTTPWatchEntry.Timings = m_Timings;
                    Marshal.FinalReleaseComObject(m_COM_HTTPWatchTiming);
                    Marshal.FinalReleaseComObject(m_COM_HTTPWatchTimings);
                    m_COM_HTTPWatchTiming = null;
                    m_COM_HTTPWatchTimings = null;
                    #endregion
                    m_HTTPWatchEntry.URL = m_COM_HTTPWatchEntry.URL;

                    m_HTTPWatchEntries.Add(m_HTTPWatchEntry);
                    Marshal.FinalReleaseComObject(m_COM_HTTPWatchEntry);
                    m_COM_HTTPWatchEntry = null;
                } 
                #endregion
                #region Clone Summary
                HttpWatch.ResultSummaries m_COM_HTTPWatchRSErrors = null;
                HttpWatch.ResultSummaries m_COM_HTTPWatchRSStatusCodes = null;
                HttpWatch.Summary m_COM_HTTPWatchSummary = null;
                ResultSummaries m_HTTPWatchRSErrors = null;
                ResultSummaries m_HTTPWatchRSStatusCodes = null;
                
                m_HTTPWatchRSErrors = new ResultSummaries();
                m_HTTPWatchRSStatusCodes = new ResultSummaries();
                m_COM_HTTPWatchSummary = m_COM_HTTPWatchLogEntries.Summary;
                #region Summary::Errors
                m_COM_HTTPWatchRSErrors = m_COM_HTTPWatchSummary.Errors;
                for (int m_Counter = 0; m_Counter < m_COM_HTTPWatchRSErrors.Count; m_Counter++)
                {
                    HttpWatch.ResultSummary m_COM_HTTPWatchRS = m_COM_HTTPWatchRSErrors[m_Counter];
                    m_HTTPWatchRSErrors.Add(new ResultSummary()
                                                    {
                                                        Description = m_COM_HTTPWatchRS.Description,
                                                        Occurrences = m_COM_HTTPWatchRS.Occurrences,
                                                        Result = m_COM_HTTPWatchRS.Result
                                                    }
                                           );
                    Marshal.FinalReleaseComObject(m_COM_HTTPWatchRS);
                    m_COM_HTTPWatchRS = null;
                }
                Marshal.FinalReleaseComObject(m_COM_HTTPWatchRSErrors);
                m_COM_HTTPWatchRSErrors = null; 
                #endregion
                #region Summary::StatusCodes
                m_COM_HTTPWatchRSStatusCodes = m_COM_HTTPWatchSummary.StatusCodes;
                for (int m_Counter = 0; m_Counter < m_COM_HTTPWatchRSStatusCodes.Count; m_Counter++)
                {
                    HttpWatch.ResultSummary m_COM_HTTPWatchRS = m_COM_HTTPWatchRSStatusCodes[m_Counter];
                    m_HTTPWatchRSStatusCodes.Add(new ResultSummary()
                                                        {
                                                            Description = m_COM_HTTPWatchRS.Description,
                                                            Occurrences = m_COM_HTTPWatchRS.Occurrences,
                                                            Result = m_COM_HTTPWatchRS.Result
                                                        }
                                                );
                    Marshal.FinalReleaseComObject(m_COM_HTTPWatchRS);
                    m_COM_HTTPWatchRS = null;
                }
                Marshal.FinalReleaseComObject(m_COM_HTTPWatchRSStatusCodes);
                m_COM_HTTPWatchRSStatusCodes = null; 
                #endregion
                m_HTTPWatchEntries.Summary = new Summary()
                                                    {
                                                        AverageHTTPSOverhead = m_COM_HTTPWatchSummary.AverageHTTPSOverhead,
                                                        BytesReceived = m_COM_HTTPWatchSummary.BytesReceived,
                                                        BytesSent = m_COM_HTTPWatchSummary.BytesSent,
                                                        CompressionSavedBytes = m_COM_HTTPWatchSummary.CompressionSavedBytes,
                                                        DNSLookUps = m_COM_HTTPWatchSummary.DNSLookUps,
                                                        RoundTrips = m_COM_HTTPWatchSummary.RoundTrips,
                                                        TCPConnects = m_COM_HTTPWatchSummary.TCPConnects,
                                                        Time = m_COM_HTTPWatchSummary.Time,
                                                        TotalHTTPSOverhead = m_COM_HTTPWatchSummary.TotalHTTPSOverhead,
                                                        Errors = m_HTTPWatchRSErrors,
                                                        StatusCodes = m_HTTPWatchRSStatusCodes
                                                    };

                Marshal.FinalReleaseComObject(m_COM_HTTPWatchSummary);
                m_COM_HTTPWatchSummary = null;
                #endregion
                Marshal.FinalReleaseComObject(m_COM_HTTPWatchLogEntries);
                m_COM_HTTPWatchLogEntries = null; 
                #endregion

                return m_HTTPWatchEntries;
            }
            catch (Exception Error)
            {
                g_Logger.WriteLine(HTTPWatchLogger.LogLevel.Exception, "Error occured in ::CloneHTTPWatchLogEntries()");
                g_Logger.WriteLine(Error);
                throw;
            }
        }

        /// <summary>
        /// Clones the specified type of pages object of the HTTPWatch COM Log
        /// to a .NET object.
        /// </summary>
        /// <param name="PagesType">The type of pages to clone.</param>
        /// <returns>An object of Pages class which represents the cloned .NET object.</returns>
        private Pages CloneHTTPWatchLogPages(HTTPWatchLogPagesType PagesType)
        {
            HttpWatch.Pages m_COM_HTTPWatchPages = null;
            Pages m_HTTPWatchPages = null;

            try
            {
                switch (PagesType)
                {
                    case HTTPWatchLogPagesType.RAWPages:
                        m_COM_HTTPWatchPages = g_COM_HTTPWatchLog.Pages;
                        break;
                    case HTTPWatchLogPagesType.FilteredPages:
                        m_COM_HTTPWatchPages = g_COM_HTTPWatchLog.FilteredPages;
                        break;
                }

                m_HTTPWatchPages = new Pages();

                for (int m_Counter = 0; m_Counter < m_COM_HTTPWatchPages.Count; m_Counter++)
                {
                    HttpWatch.Page m_COM_HTTPWatchPage = m_COM_HTTPWatchPages[m_Counter];
                    m_HTTPWatchPages.Add(new Page()
                                                {
                                                    Dynamic = m_COM_HTTPWatchPage.Dynamic,
                                                    Started = m_COM_HTTPWatchPage.Started,
                                                    StartedDateTime = m_COM_HTTPWatchPage.StartedDateTime,
                                                    StartedSecs = m_COM_HTTPWatchPage.StartedSecs,
                                                    Title = m_COM_HTTPWatchPage.Title,
                                                    Unknown = m_COM_HTTPWatchPage.Unknown
                                                }
                                         );
                    Marshal.FinalReleaseComObject(m_COM_HTTPWatchPage);
                    m_COM_HTTPWatchPage = null;
                }
                Marshal.FinalReleaseComObject(m_COM_HTTPWatchPages);
                m_COM_HTTPWatchPages = null;

                return m_HTTPWatchPages;
            }
            catch (Exception Error)
            {
                g_Logger.WriteLine(HTTPWatchLogger.LogLevel.Exception, "Error occured in ::CloneHTTPWatchLogPages()");
                g_Logger.WriteLine(Error);
                throw;
            }
        }

        /// <summary>
        /// Releases all the COM objects held by the Plugin class.
        /// </summary>
        private void ReleaseCOMPluginObjects()
        {
            if (g_COM_HTTPWatchController != null)
            {
                try
                {
                    if (g_COM_HTTPWatchLog != null)
                    {
                        Marshal.FinalReleaseComObject(g_COM_HTTPWatchLog);
                        g_COM_HTTPWatchLog = null;
                        if (g_Logger != null)
                            g_Logger.WriteLine(HTTPWatchLogger.LogLevel.Message, "COM_RELEASE::HTTPWatch Log object.");
                    }

                    if (g_COM_HTTPWatchPlugin != null)
                    {
                        Marshal.FinalReleaseComObject(g_COM_HTTPWatchPlugin);
                        g_COM_HTTPWatchPlugin = null;
                        if (g_Logger != null)
                            g_Logger.WriteLine(HTTPWatchLogger.LogLevel.Message, "COM_RELEASE::HTTPWatch Plugin object.");
                    }

                    if (g_COM_HTTPWatchController != null)
                    {
                        Marshal.FinalReleaseComObject(g_COM_HTTPWatchController);
                        g_COM_HTTPWatchController = null;
                        if (g_Logger != null)
                            g_Logger.WriteLine(HTTPWatchLogger.LogLevel.Message, "COM_RELEASE::HTTPWatch Controller object.");
                    }
                }
                catch (Exception)
                {
                    throw;
                }
                finally
                {
                    GC.Collect();
                    GC.WaitForPendingFinalizers();
                    GC.Collect();       //Release RTW memory
                    if (g_Logger != null)
                        g_Logger.WriteLine(HTTPWatchLogger.LogLevel.Message, "Garbage Collection completed.");
                }
            }
        }

        /// <summary>
        /// Gets the .NET HTTP Watch Log object for the last session.
        /// </summary>
        /// <returns>An object of HTTPWatchLog class representing the log for the last session.</returns>
        public HTTPWatchLog GetHTTPWatchLog()
        {
            return g_HTTPWatchLog;
        }

        /// <summary>
        /// Clears the temporary internet cache. <br/>
        /// NOTE: For this method to work, you must call <i>OpenBrowser</i> before
        /// you call this method.
        /// </summary>
        public void ClearCache()
        {
            try
            {
                if (g_COM_HTTPWatchPlugin != null)
                    g_COM_HTTPWatchPlugin.ClearCache();
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Clears all stored and session cookies.
        /// NOTE: For this method to work, you must call <i>OpenBrowser</i> before
        /// you call this method.
        /// </summary>
        public void ClearCookies()
        {
            try
            {
                if (g_COM_HTTPWatchPlugin != null)
                {
                    g_COM_HTTPWatchPlugin.ClearSessionCookies();
                    g_COM_HTTPWatchPlugin.ClearAllCookies();
                }
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Saves the HTTP Watch log file to disk. <br/>
        /// NOTE: This method can be called only once during the object lifetime, and after <i>CloseBrowser</i>
        /// has been called.
        /// </summary>
        /// <param name="HWLFileName">The path and name of the HTTP Watch log file.</param>
        /// <remarks>
        /// Calling this multiple times, will have no effect. The HWL log will be save with the filename
        /// you specified in the first call.
        /// </remarks>
        public void SaveLog(string HWLFileName)
        {
            string m_LocalAppDataPath = "";
            string m_VirtualizedLocalAppDataPath = "";

            if (!String.IsNullOrEmpty(g_HTTPWatchLogFile))
            {
                try
                {
                    m_LocalAppDataPath = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
                    m_VirtualizedLocalAppDataPath = m_LocalAppDataPath +
                                                    "\\Microsoft\\Windows\\Temporary Internet Files\\Virtualized\\" +
                                                    m_LocalAppDataPath.Replace(":", "");
                    //Check if file exists and only then copy
                    if (File.Exists(m_LocalAppDataPath + "\\" + g_HTTPWatchLogFile))
                    {
                        File.Copy(m_LocalAppDataPath + "\\" + g_HTTPWatchLogFile, HWLFileName);
                        File.Delete(m_LocalAppDataPath + "\\" + g_HTTPWatchLogFile);
                        g_HTTPWatchLogFile = null;
                    }
                    else
                    {
                        //Look in Virtualized folder
                        if (File.Exists(m_VirtualizedLocalAppDataPath + "\\" + g_HTTPWatchLogFile))
                        {
                            File.Copy(m_VirtualizedLocalAppDataPath + "\\" + g_HTTPWatchLogFile, HWLFileName);
                            File.Delete(m_VirtualizedLocalAppDataPath + "\\" + g_HTTPWatchLogFile);
                            g_HTTPWatchLogFile = null;
                        }
                    }
                }
                catch (Exception)
                {
                    throw;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HTTPWatchWrapper\HTTPWatchWrapper\QueryStringValue.cs ===
﻿using System;
using System.Text;

namespace Test.Common.Library.HTTPWatchWrapper
{
    /// <summary>
    /// Represents a single parameter that was encoded in the URL of an HTTP request.
    /// </summary>
    public class QueryStringValue
    {
        /// <summary>
        /// Represents the name of the query string parameter.
        /// </summary>
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the value of the query string parameter.
        /// </summary>
        public string Value
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HTTPWatchWrapper\HTTPWatchWrapper\QueryStringValues.cs ===
﻿using System;
using System.Collections;
using System.Text;

namespace Test.Common.Library.HTTPWatchWrapper
{
    /// <summary>
    /// Represents a collection of QueryStringValue objects that 
    /// contains a list of parameters that were encoded in the URL of an HTTP request.
    /// </summary>
    public class QueryStringValues : CollectionBase
    {
        /// <summary>
        /// Create an empty collection of QueryStringValue objects.
        /// </summary>
        public QueryStringValues() { }

        /// <summary>
        /// Create a collection of QueryStringValue objects with the specified QueryStringValue
        /// as the first item in the collection.
        /// </summary>
        /// <param name="Parameter">The QueryStringValue object to add to the collection.</param>
        public QueryStringValues(QueryStringValue Parameter)
        {
            this.List.Add(Parameter);
        }

        /// <summary>
        /// Adds the specified QueryStringValue object to the collection.
        /// </summary>
        /// <param name="Parameter">The QueryStringValue object to add to the collection.</param>
        /// <returns>An integer indicating the index where the object was added.</returns>
        public int Add(QueryStringValue Parameter)
        {
            return this.List.Add(Parameter);
        }

        /// <summary>
        /// Gets or sets the value of a pre existing element in the collection.
        /// </summary>
        /// <param name="index">The index of the element in the collection.</param>
        /// <returns>A QueryStringValue object corresponding to the specified index.</returns>
        public QueryStringValue this[int index]
        {
            get { return (QueryStringValue)this.List[index]; }

            set
            {
                try
                {
                    this.List[index] = value;
                }
                catch (Exception)
                {
                    throw;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HTTPWatchWrapper\HTTPWatchWrapper\POSTParameters.cs ===
﻿using System;
using System.Collections;
using System.Text;

namespace Test.Common.Library.HTTPWatchWrapper
{
    /// <summary>
    /// Represents a collection of POSTParameter objects that 
    /// contains a list of parameters that were sent in a POST request message.
    /// </summary>
    public class POSTParameters : CollectionBase
    {
        /// <summary>
        /// Create an empty collection of POSTParameter objects.
        /// </summary>
        public POSTParameters() { }

        /// <summary>
        /// Create a collection of POSTParameter objects with the specified POSTParameter
        /// as the first item in the collection.
        /// </summary>
        /// <param name="Parameter">The POSTParameter object to add to the collection.</param>
        public POSTParameters(POSTParameter Parameter)
        {
            this.List.Add(Parameter);
        }

        /// <summary>
        /// Adds the specified POSTParameter object to the collection.
        /// </summary>
        /// <param name="Parameter">The POSTParameter object to add to the collection.</param>
        /// <returns>An integer indicating the index where the object was added.</returns>
        public int Add(POSTParameter Parameter)
        {
            return this.List.Add(Parameter);
        }

        /// <summary>
        /// Gets or sets the value of a pre existing element in the collection.
        /// </summary>
        /// <param name="index">The index of the element in the collection.</param>
        /// <returns>A POSTParameter object corresponding to the specified index.</returns>
        public POSTParameter this[int index]
        {
            get { return (POSTParameter)this.List[index]; }

            set
            {
                try
                {
                    this.List[index] = value;
                }
                catch (Exception)
                {
                    throw;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HTTPWatchWrapper\HTTPWatchWrapper\Response.cs ===
﻿using System;
using System.Text;

namespace Test.Common.Library.HTTPWatchWrapper
{
    /// <summary>
    /// Represents the information about the HTTP response message.
    /// </summary>
    public class Response
    {
        /// <summary>
        /// Represents the number of chunks in the HTTP response.
        /// </summary>
        public int Chunks
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the list of cookies that were received from the web server.
        /// </summary>
        public Cookies Cookies
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the list of HTTP headers that were received from the web server.
        /// </summary>
        public Headers Headers
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the HTTP response line that from the server.
        /// E.g. "HTTP/1.1 200 OK".
        /// </summary>
        public string StatusLine
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the raw HTTP response data.
        /// </summary>
        public Array Stream
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HTTPWatchWrapper\HTTPWatchWrapper\ResultSummaries.cs ===
﻿using System;
using System.Collections;
using System.Text;

namespace Test.Common.Library.HTTPWatchWrapper
{
    /// <summary>
    /// Represents a collection of ResultSummary objects that 
    /// hold information about errors and status codes.
    /// </summary>
    public class ResultSummaries : CollectionBase
    {
        /// <summary>
        /// Create an empty collection of ResultSummary objects.
        /// </summary>
        public ResultSummaries() { }

        /// <summary>
        /// Create a collection of ResultSummary objects with the specified ResultSummary
        /// as the first item in the collection.
        /// </summary>
        /// <param name="Parameter">The ResultSummary object to add to the collection.</param>
        public ResultSummaries(ResultSummary Parameter)
        {
            this.List.Add(Parameter);
        }

        /// <summary>
        /// Adds the specified ResultSummary object to the collection.
        /// </summary>
        /// <param name="Parameter">The ResultSummary object to add to the collection.</param>
        /// <returns>An integer indicating the index where the object was added.</returns>
        public int Add(ResultSummary Parameter)
        {
            return this.List.Add(Parameter);
        }

        /// <summary>
        /// Gets or sets the value of a pre existing element in the collection.
        /// </summary>
        /// <param name="index">The index of the element in the collection.</param>
        /// <returns>A ResultSummary object corresponding to the specified index.</returns>
        public ResultSummary this[int index]
        {
            get { return (ResultSummary)this.List[index]; }

            set
            {
                try
                {
                    this.List[index] = value;
                }
                catch (Exception)
                {
                    throw;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HTTPWatchWrapper\HTTPWatchWrapper\Timing.cs ===
﻿using System;
using System.Text;

namespace Test.Common.Library.HTTPWatchWrapper
{
    /// <summary>
    /// Represents information about a single timing such as Blocked or Connect.
    /// </summary>
    public class Timing
    {
        /// <summary>
        /// Represents the duration of the timing in seconds.
        /// </summary>
        public double Duration
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the start time as an offset in seconds from the start of the current request.
        /// </summary>
        public double Started
        {
            get;
            set;
        }

        /// <summary>
        /// Indicates whether this timing is populated with data and applies to the current request.
        /// </summary>
        public bool Valid
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HTTPWatchWrapper\HTTPWatchWrapper\ResultSummary.cs ===
﻿using System;
using System.Text;

namespace Test.Common.Library.HTTPWatchWrapper
{
    /// <summary>
    /// Represents information about the number of requests that returned a specific
    /// status code or error.
    /// </summary>
    public class ResultSummary
    {
        /// <summary>
        /// Represents the error or status returned by the web server.
        /// </summary>
        public string Result
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the full description of the status code or error.
        /// </summary>
        public string Description
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the number of requests in the current Summary that result
        /// this status or error code.
        /// </summary>
        public int Occurrences
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HTTPWatchWrapper\HTTPWatchWrapper\Request.cs ===
﻿using System;
using System.Text;

namespace Test.Common.Library.HTTPWatchWrapper
{
    /// <summary>
    /// Represents the information about the HTTP request message.
    /// </summary>
    public class Request
    {
        /// <summary>
        /// Represents the list of cookies that were sent to the web server.
        /// </summary>
        public Cookies Cookies
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the list of HTTP headers that were sent to the web server.
        /// </summary>
        public Headers Headers
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the encoding scheme used in a POST request message.
        /// </summary>
        public string POSTMimeType
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the list of parameters sent in a POST message.
        /// </summary>
        public POSTParameters POSTParameters
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the list of parameters encoded in the query string section of the URL.
        /// </summary>
        public QueryStringValues QueryStringValues
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the HTTP request line that was sent to the server.
        /// E.g. "GET / HTTP/1.1".
        /// </summary>
        public string RequestLine
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the raw HTTP request data.
        /// </summary>
        public Array Stream
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HTTPWatchWrapper\HTTPWatchWrapper\Summary.cs ===
﻿using System;
using System.Text;

namespace Test.Common.Library.HTTPWatchWrapper
{
    /// <summary>
    /// Represents summarized information requests in a single page or the whole log.
    /// </summary>
    public class Summary
    {
        /// <summary>
        /// Represents the average overhead in bytes of each HTTPS request.
        /// If this value is high (more than a few hundred bytes), it may indicate that
        /// the server is incorrectly configured and is causing an excessive 
        /// number of HTTPS renegotiations.
        /// </summary>
        public int AverageHTTPSOverhead
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the total number of bytes of data that have been received from web server(s).
        /// In the case of HTTPS connections this includes the overhead of the SSL encryption process.
        /// </summary>
        public int BytesReceived
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the total number of bytes of data that have been sent to web server(s).
        /// In the case of HTTPS connections this includes the overhead of the SSL encryption process.
        /// </summary>
        public int BytesSent
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the total number of bytes by which downloaded content was reduced in size by
        /// HTTP compression.
        /// </summary>
        public int CompressionSavedBytes
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the total number of times that a network name was converted to an IP address.
        /// </summary>
        public int DNSLookUps
        {
            get;
            set;
        }

        /// <summary>
        /// Represents a list of the error codes that were returned by requests in this summary.
        /// </summary>
        public ResultSummaries Errors
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the number of requests that caused an HTTP request and response message being exchanged 
        /// with a web server. Some entries do not cause a network round trip because either an error occurred
        /// or because no network request was required.
        /// </summary>
        public int RoundTrips
        {
            get;
            set;
        }

        /// <summary>
        /// Represents a list of the status codes that were returned by requests in this summary.
        /// </summary>
        public ResultSummaries StatusCodes
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the number of times that a new TCP level connection had to be made with web server(s) in
        /// the summary data. An excessively high number of TCP connects may indicate that HTTP persistent
        /// connections, also known as keep-alive connections, have not been correctly configured on the server.
        /// </summary>
        public int TCPConnects
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the time in seconds from the start of the first request in the summary to the end
        /// of the last item. This can be used to find the total time to download a page or set of pages.
        /// </summary>
        public double Time
        {
            get;
            set;
        }

        /// <summary>
        /// Represents how many extra bytes of data were required to encrypt the request and response messages,
        /// if there are any HTTPS requests in the summary data.
        /// </summary>
        public int TotalHTTPSOverhead
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HTTPWebAccessFramework\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HTTPWatchWrapper\HTTPWatchWrapper\Timings.cs ===
﻿using System;
using System.Text;

namespace Test.Common.Library.HTTPWatchWrapper
{
    /// <summary>
    /// Represents the request level timings for a request.
    /// </summary>
    public class Timings
    {
        /// <summary>
        /// Represents the Blocked time.
        /// The Blocked time includes any pre-processing time (such as cache lookup) and the time spent waiting
        /// for a network connection to become available. Internet Explorer will only create a maximum of two
        /// concurrent network connections per host name and will queue up requests until a network connection
        /// is available. Often the Blocked time is the most significant factor in the download time of images
        /// embedded in a web page.
        /// </summary>
        public Timing Blocked
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the DNS Lookup time.
        /// DNS Lookup is the time required to resolve a host name into an IP address.
        /// </summary>
        public Timing DNSLookup
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the Connect time.
        /// Connect is the time required to create a TCP connection to the web server (or proxy). If a secure 
        /// HTTPS connection is being used this time includes the SSL handshake process.
        /// "Keep-Alive connections are often used to avoid the overhead of repeatedly connecting to the web
        /// server.
        /// </summary>
        public Timing Connect
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the Send time.
        /// Send is the time required to send the HTTP request message to the server and will depend on the 
        /// amount of data that is sent to the server. For example, long Send times will result from uploading
        /// files using an HTTP POST.
        /// </summary>
        public Timing Send
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the Wait time.
        /// Wait is the idle time spent waiting for a response message from the server. This value includes delays
        /// introduced due to network latency and the time required to process the request on the web server.
        /// </summary>
        public Timing Wait
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the Receive time.
        /// Receive is the time taken to read the response message from the server. This value will depend on the
        /// size of the content returned, network bandwidth and whether HTTP compression was used.
        /// </summary>
        public Timing Receive
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the Cache Read time.
        /// Cache Read is the time taken to read the content from the browser cache during
        /// (Cache) or 304 responses.
        /// </summary>
        public Timing CacheRead
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the Network time.
        /// Network is the total duration of all network related operations for an HTTP request.
        /// </summary>
        public Timing Network
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the TTFB time.
        /// TTFB (or Time To First Byte) is the duration from the initial network request being initiated
        /// by the browser to the first byte being received from the server. It includes TCP connection 
        /// time, the time to send the request and the time taken to get the first byte of the response 
        /// message.
        /// </summary>
        public Timing TTFB
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HTTPWatchWrapper\HTTPWatchWrapper\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("HTTPWatchWrapper")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
//[assembly: AssemblyCompany("Microsoft Corp.")]
//[assembly: AssemblyProduct("HTTPWatchWrapper")]
//[assembly: AssemblyCopyright("Copyright © Microsoft Corp. 2009")]
//[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("42a5bbd6-53fc-4588-ac8e-8fb60acc36f0")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
//[assembly: AssemblyVersion("1.0.0.0")]
//[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HTTPWebAccessFramework\HTTPWebAccessFramework\FrameWorkSecurity.cs ===
﻿using System;
using System.Net;
using System.Text;

namespace Test.Common.Library.HTTPWebAccessFramework
{
    /// <summary>
    /// Represents the Security for the WebService Request object.
    /// </summary>
    public class FrameWorkSecurity
    {
        private string g_RequestUsername;
        private string g_RequestPassword;
        private string g_RequestDomain;
        private bool g_RequirePreAuthentication;
        private AuthenticationLevel g_RequestAuthenticationLevel;
        private ImpersonationLevel g_RequestImpersonationLevel;
        
        /// <summary>
        /// Supported Authentication Levels for the request.
        /// </summary>
        public enum AuthenticationLevel
        {
            /// <summary>
            /// Indicates that the client and server should be authenticated. The request does not fail if the server is not authenticated.
            /// </summary>
            MutualAuthRequested,
            /// <summary>
            /// Indicates that the client and server should be authenticated. If the server is not authenticated, an Exception will be raised.
            /// </summary>
            MutualAuthRequired,
            /// <summary>
            /// Indicates that no authentication is required for the client and server.
            /// </summary>
            None
        }

        /// <summary>
        /// Supported Impersonation Levels for the request.
        /// </summary>
        public enum ImpersonationLevel
        {
            /// <summary>
            /// Indicates that the server process cannot obtain identification information about the client, and it cannot impersonate the client.
            /// </summary>
            Anonymous,
            /// <summary>
            /// Indicates that the server process can impersonate the client's security context on remote systems.
            /// </summary>
            Delegation,
            /// <summary>
            /// Indicates that the server process can obtain information about the client, such as security identifiers and privileges, 
            /// but it cannot impersonate the client.
            /// </summary>
            Identification,
            /// <summary>
            /// Indicates that the server process can impersonate the client's security context on its local system. The server cannot 
            /// impersonate the client on remote systems. 
            /// </summary>
            Impersonation,
            /// <summary>
            /// Indicates that an impersonation level is not assigned.
            /// </summary>
            None
        }

        /// <summary>
        /// Initializes a new instance of FrameWorkSecurity class. 
        /// </summary>
        public FrameWorkSecurity()
        {
            //Define defaults for credential module
            g_RequestDomain = String.Empty;
            g_RequestPassword = String.Empty;
            g_RequestUsername = String.Empty;

            //Define defaults for authentication module
            g_RequirePreAuthentication = false;
            g_RequestAuthenticationLevel = AuthenticationLevel.MutualAuthRequested;
            g_RequestImpersonationLevel = ImpersonationLevel.Delegation;

        }

        #region Credential Module
        /// <summary>
        /// The Username to send with the WebService Request object.
        /// </summary>
        public string Username
        {
            get { return g_RequestUsername; }
            set
            {
                if (value.Contains("\\"))
                    throw new FormatException("Domain name cannot be included in the Username string. Use the Domain parameter to supply the domain name.");
                else
                    g_RequestUsername = value;
            }
        }

        /// <summary>
        /// The Password to send with the WebService Request object.
        /// </summary>
        public string Password
        {
            get { return g_RequestPassword; }
            set { g_RequestPassword = value; }
        }

        /// <summary>
        /// The Domain for the username to send with the WebService Request object.
        /// </summary>
        public string Domain
        {
            get { return g_RequestDomain; }
            set { g_RequestDomain = value; }
        }

        /// <summary>
        /// Gets an instance of System.Net.NetworkCredential composed of the supplied credentials.
        /// See Username, Password and Domain. If not set, the Default Network Credential is returned.
        /// </summary>
        /// <returns>An object of System.Net.NetworkCredential.</returns>
        public NetworkCredential GetNetworkCredential()
        {
            NetworkCredential m_NetworkCredentialObject;

            //Check if Default Credentials are to be used
            if (IsDefaultNetworkCredentials())
                m_NetworkCredentialObject = (NetworkCredential)CredentialCache.DefaultCredentials;
            else
                m_NetworkCredentialObject = new NetworkCredential(g_RequestUsername, g_RequestPassword, g_RequestDomain);

            return m_NetworkCredentialObject;
        }

        /// <summary>
        /// Checks if the credential in use is the Default Network Credential.
        /// </summary>
        /// <returns>An object of System.Boolean. True if default credential is being used. False if not.</returns>
        public bool IsDefaultNetworkCredentials()
        {
            if (String.IsNullOrEmpty(g_RequestUsername) || String.IsNullOrEmpty(g_RequestPassword))
                return true;
            else
                return false;
        } 
        #endregion

        #region Authentication Module
        /// <summary>
        /// Gets or Sets whether Pre-Authentication is required for the WebService Request.
        /// </summary>
        public bool RequirePreAuthentication
        {
            get { return g_RequirePreAuthentication; }
            set { g_RequirePreAuthentication = value; }
        }

        /// <summary>
        /// Gets or Sets the Authentication Level for the WebService Request object.
        /// </summary>
        public AuthenticationLevel RequestAuthenticationLevel
        {
            get { return g_RequestAuthenticationLevel; }
            set { g_RequestAuthenticationLevel = value; }
        }

        /// <summary>
        /// Gets or Sets the Impersonation Level for the WebService Request object.
        /// </summary>
        public ImpersonationLevel RequestImpersonationLevel
        {
            get { return g_RequestImpersonationLevel; }
            set { g_RequestImpersonationLevel = value; }
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HTTPWebAccessFramework\HTTPWebAccessFramework\RequestParameter.cs ===
﻿using System;
using System.Web;
using System.Text;

namespace Test.Common.Library.HTTPWebAccessFramework
{
    /// <summary>
    /// Represents a parameter name-value pair to be sent with the Request object.
    /// </summary>
    public class RequestParameter
    {
        private string g_ParameterName;
        private string g_ParameterValue;

        /// <summary>
        /// Initializes a new instance of RequestParameter.
        /// </summary>
        public RequestParameter()
        {
            g_ParameterName = String.Empty;
            g_ParameterValue = String.Empty;
        }

        /// <summary>
        /// Initializes a new instance of RequestParameter with the specified
        /// Parameter name and value.
        /// </summary>
        /// <param name="ParameterName">The name of the Request parameter.</param>
        /// <param name="ParameterValue">the value of the Request parameter.</param>
        public RequestParameter(string ParameterName, string ParameterValue)
        {
            g_ParameterName = ParameterName;
            g_ParameterValue = ParameterValue;
        }

        /// <summary>
        /// Gets or Sets the name of the Request parameter.
        /// </summary>
        public string ParameterName
        {
            get { return g_ParameterName; }

            set
            {
                if (value.Contains(" "))
                    throw new FormatException("The parameter name cannot have any blanks.");
                if (value.Contains("\\"))
                    throw new FormatException("Invalid character '\' in parameter name.");
                if (value.Contains("?"))
                    throw new FormatException("Invalid character '?' in parameter name.");
                if (value.Contains("&"))
                    throw new FormatException("Invalid character '&' in parameter name.");
                g_ParameterName = value;
            }
        }

        /// <summary>
        /// Gets or Sets the value of the Request parameter.
        /// </summary>
        public string ParameterValue
        {
            get { return g_ParameterValue; }

            set { g_ParameterValue = HttpUtility.UrlEncode(value); }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HTTPWebAccessFramework\HTTPWebAccessFramework\RequestParameterCollection.cs ===
﻿using System;
using System.Collections;
using System.Text;

namespace Test.Common.Library.HTTPWebAccessFramework
{
    /// <summary>
    /// Represents a collection of RequestParameter objects.
    /// </summary>
    public class RequestParameterCollection : CollectionBase
    {

        /// <summary>
        /// Create an empty collection of RequestParameter object.
        /// </summary>
        public RequestParameterCollection()
        {
            //Do Nothing
        }

        /// <summary>
        /// Create a collection of RequestParameter objects with the specified RequestParameter
        /// as the first item in the collection.
        /// </summary>
        /// <param name="Parameter">The RequestParameter to add to the collection.</param>
        public RequestParameterCollection(RequestParameter Parameter)
        {
            this.List.Add(Parameter);
        }

        /// <summary>
        /// Adds the specified Request Parameter to the collection.
        /// </summary>
        /// <param name="Parameter">The Request Parameter name-value pair.</param>
        /// <returns>An object of System.Int32 indicating the index where the attribute was added.</returns>
        public int Add(RequestParameter Parameter)
        {
            return this.List.Add(Parameter);
        }

        /// <summary>
        /// Gets the index of the specified Request Parameter within the collection.
        /// </summary>
        /// <param name="Parameter">The Request Parameter whose index needs to be found.</param>
        /// <returns>An object of System.Int32 specifying the zero-based index. -1 if not found.</returns>
        public int IndexOf(RequestParameter Parameter)
        {
            for (int m_ParameterIndex = 0; m_ParameterIndex < this.List.Count; m_ParameterIndex++)
            {
                if ((String.Compare(this[m_ParameterIndex].ParameterName, Parameter.ParameterName, true) == 0)&&
                    (String.Compare(this[m_ParameterIndex].ParameterValue, Parameter.ParameterValue, true) == 0))
                    return m_ParameterIndex;
            }
            return -1;
        }

        /// <summary>
        /// Gets or sets the value of a pre existing element in the Request Parameter Collection.
        /// </summary>
        /// <param name="index">The index of the element.</param>
        /// <returns></returns>
        public RequestParameter this[int index]
        {
            get { return (RequestParameter)this.List[index]; }

            set
            {
                try
                {
                    this.List[index] = value;
                }
                catch (Exception)
                {
                    throw;
                }
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HTTPWebAccessFramework\HTTPWebAccessFramework\FrameWorkPolicy.cs ===
﻿using System;
using System.Net.Cache;
using System.Text;

namespace Test.Common.Library.HTTPWebAccessFramework
{
    /// <summary>
    /// Represents the Policy parameters for the WebService Request.
    /// </summary>
    public class FrameWorkPolicy
    {
        private CacheLevel g_RequestCacheLevel;
        private int g_TimeOut;

        /// <summary>
        /// The requested Cache Level.
        /// </summary>
        public enum CacheLevel
        {
            /// <summary>
            /// Indicates that the request will be satisfied by using the server. No entries are taken from cache, added to cache,
            /// or removed from cache between the client and server.
            /// </summary>
            BypassCache,
            /// <summary>
            /// Indicates that the request will be satisfied from the cache, if available; otherwise it will be fetched from the server.
            /// If the requested item is available in any cache between the client and the server, the request might be satisfied by the intermediate cache.
            /// </summary>
            CacheIfAvailable,
            /// <summary>
            /// Indicates that the request will be satisfied using the locally cached resource; does not send a request for an item
            /// that is not in the cache. Exception is thrown if the item is not in the client cache.
            /// </summary>
            CacheOnly,
            /// <summary>
            /// Indicates that the request will be satisfied either by using the cached copy of the resource or by sending a request for
            /// the resource to the server. The action taken is determined by the current cache policy and the age of the content in the cache.
            /// </summary>
            Default,
            /// <summary>
            /// Indicates that the request will never be satisfied by using the cache. If the resource is present in the local cache, it is removed. This policy level indicates to intermediate caches that they should remove the resource.
            /// </summary>
            NoCacheNoStore,
            /// <summary>
            /// Indicates that the request will be satisfied by using the server. The response might be saved in the cache.
            /// </summary>
            Reload,
            /// <summary>
            /// Indicates that the request will be satisfied by using the cached copy of the resource if the timestamp is the same as the timestamp
            /// of the resource on the server; otherwise, the resource is fetched from the server, and stored in the cache. 
            /// </summary>
            Revalidate
        }
        
        /// <summary>
        /// Initializes a new instance of FrameWorkPolicy class.
        /// </summary>
        public FrameWorkPolicy()
        {
            //Set defaults
            g_RequestCacheLevel = CacheLevel.BypassCache;
            g_TimeOut = 100000;
        }

        #region Properties
        /// <summary>
        /// Get or Set the policy for Request Cache Level.
        /// </summary>
        public CacheLevel RequestCacheLevelPolicy
        {
            get { return g_RequestCacheLevel; }
            set { g_RequestCacheLevel = value; }
        }

        /// <summary>
        /// Get or Set the policy for the Request Timeout.
        /// </summary>
        public int RequestTimeOut
        {
            get { return g_TimeOut; }
            set
            {
                try
                {
                    g_TimeOut = value;
                }
                catch (Exception)
                {
                    throw;
                }
            }
        } 
        #endregion

        #region Methods
        /// <summary>
        /// Gets an object of the Requested Cache Policy.
        /// </summary>
        /// <returns></returns>
        public RequestCachePolicy GetCachePolicy()
        {
            RequestCachePolicy CachePolicy = null;

            try
            {
                switch (g_RequestCacheLevel)
                {
                    case CacheLevel.BypassCache:
                        CachePolicy = new RequestCachePolicy(RequestCacheLevel.BypassCache);
                        break;
                    case CacheLevel.CacheIfAvailable:
                        CachePolicy = new RequestCachePolicy(RequestCacheLevel.CacheIfAvailable);
                        break;
                    case CacheLevel.CacheOnly:
                        CachePolicy = new RequestCachePolicy(RequestCacheLevel.CacheOnly);
                        break;
                    case CacheLevel.Default:
                        CachePolicy = new RequestCachePolicy(RequestCacheLevel.Default);
                        break;
                    case CacheLevel.NoCacheNoStore:
                        CachePolicy = new RequestCachePolicy(RequestCacheLevel.NoCacheNoStore);
                        break;
                    case CacheLevel.Reload:
                        CachePolicy = new RequestCachePolicy(RequestCacheLevel.Reload);
                        break;
                    case CacheLevel.Revalidate:
                        CachePolicy = new RequestCachePolicy(RequestCacheLevel.Revalidate);
                        break;
                }
            }
            catch (Exception)
            {
                throw;
            }

            return CachePolicy;
        } 
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HTTPWebAccessFramework\HTTPWebAccessFramework\HTTPGetAccess.cs ===
﻿using System;
using System.Collections.Generic;
using System.Security.Principal;
using System.IO;
using System.Net;
using System.Net.Cache;
using System.Net.Security;
using System.Text;
using System.Web;

namespace Test.Common.Library.HTTPWebAccessFramework
{
    /// <summary>
    /// Represents access of WebSite via HTTP GET protocol.
    /// </summary>
    public class HTTPGetAccess
    {
        private HttpWebRequest g_HttpGetRequest;
        private HttpWebResponse g_HttpGetResponse;
        private FrameWorkSecurity g_SecurityObject;
        private FrameWorkPolicy g_PolicyObject;
        private RequestParameterCollection g_HttpGetRequestParameterCollection;
        
        //Request Object Params
        private bool g_HttpGetRequestRequirePreAuthenticate;
        private TokenImpersonationLevel g_HttpGetRequestImpersonationLevel;
        private RequestCachePolicy g_HttpGetRequestCachePolicy;
        private AuthenticationLevel g_HttpGetRequestAuthenticationLevel;
        private NetworkCredential g_HttpGetRequestCredentials;
        private string g_HttpGetRequestContentType;
        private int g_HttpGetRequestTimeout;
        private string g_RemoteHostName;
        private string g_WebPageURI;

        //Response Object Params
        private string g_HttpGetResponseString;
        private WebHeaderCollection g_HttpGetResponseHeader;
        private CookieCollection g_HttpGetResponseCookies;
        private long g_HttpGetResponseContentLength;
        private string g_HttpGetResponseContentType;
        private bool g_HttpGetResponseIsFromCache;
        private bool g_HttpGetResponseIsMutuallyAuthenticated;
        private Uri g_HttpGetResponseActualURI;


        #region Constructors
        /// <summary>
        /// Initializes a new instance of the HTTPGetAccess class.
        /// </summary>
        public HTTPGetAccess()
        {
            SetDefaults();
        }

        /// <summary>
        /// Initializes a new instance of the HTTPGetAccess class with the specified
        /// Hostname, Page URI and Request Parameter collection.
        /// </summary>
        /// <param name="RemoteHostName">The Remote computername or domainname hosting the WebSite.</param>
        /// <param name="PageRelativePath">The relative URI path to the Web Page (if required).</param>
        /// <param name="ParameterCollection">A collection of parameter-value to pass to the Target WebSite.</param>
        public HTTPGetAccess(string RemoteHostName, string PageRelativePath, RequestParameterCollection ParameterCollection)
        {
            //Set Defaults
            SetDefaults();

            //Set Passed values
            g_RemoteHostName = RemoteHostName;
            g_WebPageURI = PageRelativePath;
            g_HttpGetRequestParameterCollection = ParameterCollection;
        }

        /// <summary>
        /// Initializes a new instance of the HTTPGetAccess class with the specified
        /// Hostname, Page URI, Request Parameter collection, Security object and Policy object.
        /// </summary>
        /// <param name="RemoteHostName">The Remote computername hosting the Web Service.</param>
        /// <param name="PageRelativePath">The relative URI path to the Web Page (if required).</param>
        /// <param name="ParameterCollection">A collection of parameter-value to pass to the Target WebSite.</param>
        /// <param name="WebServiceSecurity">The Security object for accessing the Target WebSite.</param>
        /// <param name="WebServicePolicy">The Policy object for accessing the Target WebSite.</param>
        public HTTPGetAccess(string RemoteHostName, string PageRelativePath, RequestParameterCollection ParameterCollection,
            FrameWorkSecurity WebServiceSecurity, FrameWorkPolicy WebServicePolicy)
        {
            //Set defaults
            SetDefaults();

            //Set Passed values
            g_RemoteHostName = RemoteHostName;
            g_WebPageURI = PageRelativePath;
            g_HttpGetRequestParameterCollection = ParameterCollection;
            g_SecurityObject = WebServiceSecurity;
            g_PolicyObject = WebServicePolicy;
        }

        #endregion

        #region Methods
        /// <summary>
        /// Indicates if the GET Request object has been initialized.
        /// </summary>
        /// <returns>A value of type System.Boolean. True if the object has been initialized.</returns>
        public bool IsGETRequestInitialized()
        {
            if (g_HttpGetRequest != null)
                return true;
            else
                return false;
        }

        /// <summary>
        /// Create the GET Request.
        /// </summary>
        public void CreateGETRequest()
        {
            //Refresh Values
            try
            {
                SetSecurity();
                SetPolicy();
            }
            catch (Exception)
            {
                throw;
            }

            //Create the Get Object
            try
            {
                g_HttpGetRequest = (HttpWebRequest)WebRequest.Create(CreateGetRequestURI());
                g_HttpGetRequest.CookieContainer = new CookieContainer();
                g_HttpGetRequest.AuthenticationLevel = g_HttpGetRequestAuthenticationLevel;
                g_HttpGetRequest.CachePolicy = g_HttpGetRequestCachePolicy;
                g_HttpGetRequest.Credentials = g_HttpGetRequestCredentials;
                g_HttpGetRequest.ImpersonationLevel = g_HttpGetRequestImpersonationLevel;
                g_HttpGetRequest.PreAuthenticate = g_HttpGetRequestRequirePreAuthenticate;
                g_HttpGetRequest.Method = "GET";
                g_HttpGetRequest.Timeout = g_HttpGetRequestTimeout;
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Get the Response for the GET request.
        /// </summary>
        public void GetResponse()
        {
            StreamReader m_ResponseReader;
            Stream m_ResponseDataStream;

            //Check if the GET Request object has been constructed
            if (!IsGETRequestInitialized())
                throw new InvalidOperationException("The GET Request has not been constructed. Please construct the GET request prior to calling this method.");
            
            try
            {
                g_HttpGetResponse = (HttpWebResponse)g_HttpGetRequest.GetResponse();
                m_ResponseDataStream = g_HttpGetResponse.GetResponseStream();
                m_ResponseReader = new StreamReader(m_ResponseDataStream);

                //Update the Response Data objects
                g_HttpGetResponseHeader = g_HttpGetResponse.Headers;
                g_HttpGetResponseString = m_ResponseReader.ReadToEnd();
                g_HttpGetResponseContentLength = g_HttpGetResponse.ContentLength;
                g_HttpGetResponseContentType = g_HttpGetResponse.ContentType;
                g_HttpGetResponseIsFromCache = g_HttpGetResponse.IsFromCache;
                g_HttpGetResponseIsMutuallyAuthenticated = g_HttpGetResponse.IsMutuallyAuthenticated;
                g_HttpGetResponseActualURI = g_HttpGetResponse.ResponseUri;
                g_HttpGetResponseCookies = g_HttpGetResponse.Cookies;
                //Close Response Stream
                g_HttpGetResponse.Close();
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Sets default values for the various properties of the Get Request Object
        /// </summary>
        private void SetDefaults()
        {
            try
            {
                g_HttpGetRequestRequirePreAuthenticate = false;
                g_HttpGetRequestImpersonationLevel = TokenImpersonationLevel.Delegation;
                g_HttpGetRequestCachePolicy = new RequestCachePolicy(RequestCacheLevel.BypassCache);
                g_HttpGetRequestAuthenticationLevel = AuthenticationLevel.MutualAuthRequested;
                g_HttpGetRequestCredentials = (NetworkCredential)CredentialCache.DefaultCredentials;
                g_HttpGetRequestTimeout = 100000;
                g_RemoteHostName = String.Empty;
                g_WebPageURI = String.Empty;
                g_HttpGetRequestParameterCollection = null;
                g_SecurityObject = null;
                g_PolicyObject = null;

                g_HttpGetResponseHeader = null;
                g_HttpGetResponseString = String.Empty;
                g_HttpGetResponseContentLength = 0;
                g_HttpGetResponseContentType = String.Empty;
                g_HttpGetResponseIsFromCache = false;
                g_HttpGetResponseIsMutuallyAuthenticated = false;
                g_HttpGetResponseActualURI = null;
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Set the Security parameters of the HTTP GET Request Object
        /// </summary>
        private void SetSecurity()
        {
            try
            {
                //Check if a Security object exists
                if (g_SecurityObject != null)
                {
                    //Set Access credentials
                    if (!g_SecurityObject.IsDefaultNetworkCredentials())
                        g_HttpGetRequestCredentials = g_SecurityObject.GetNetworkCredential();

                    //Set PreAuth
                    if (g_SecurityObject.RequirePreAuthentication)
                        g_HttpGetRequestRequirePreAuthenticate = true;

                    //Set Impersonation Level
                    switch (g_SecurityObject.RequestImpersonationLevel)
                    {
                        case FrameWorkSecurity.ImpersonationLevel.Anonymous:
                            g_HttpGetRequestImpersonationLevel = TokenImpersonationLevel.Anonymous;
                            break;
                        case FrameWorkSecurity.ImpersonationLevel.Delegation:
                            g_HttpGetRequestImpersonationLevel = TokenImpersonationLevel.Delegation;
                            break;
                        case FrameWorkSecurity.ImpersonationLevel.Identification:
                            g_HttpGetRequestImpersonationLevel = TokenImpersonationLevel.Identification;
                            break;
                        case FrameWorkSecurity.ImpersonationLevel.Impersonation:
                            g_HttpGetRequestImpersonationLevel = TokenImpersonationLevel.Impersonation;
                            break;
                        case FrameWorkSecurity.ImpersonationLevel.None:
                            g_HttpGetRequestImpersonationLevel = TokenImpersonationLevel.None;
                            break;
                    }

                    //Set Authentication Level
                    switch (g_SecurityObject.RequestAuthenticationLevel)
                    {
                        case FrameWorkSecurity.AuthenticationLevel.MutualAuthRequested:
                            g_HttpGetRequestAuthenticationLevel = AuthenticationLevel.MutualAuthRequested;
                            break;
                        case FrameWorkSecurity.AuthenticationLevel.MutualAuthRequired:
                            g_HttpGetRequestAuthenticationLevel = AuthenticationLevel.MutualAuthRequired;
                            break;
                        case FrameWorkSecurity.AuthenticationLevel.None:
                            g_HttpGetRequestAuthenticationLevel = AuthenticationLevel.None;
                            break;
                    }
                }
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Set the general policy for the HTTP GET Request Object
        /// </summary>
        private void SetPolicy()
        {
            try
            {
                //Check if a Policy Object exists
                if (g_PolicyObject != null)
                {
                    //Set Cache policy
                    g_HttpGetRequestCachePolicy = g_PolicyObject.GetCachePolicy();

                    //Set TimeOut
                    g_HttpGetRequestTimeout = g_PolicyObject.RequestTimeOut;
                }
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Create the Get Request URI String
        /// </summary>
        /// <returns></returns>
        private string CreateGetRequestURI()
        {
            string m_RequestURI = string.Empty;
            string m_RequestParameterString = string.Empty;

            //Check RemoteHostName
            if (String.IsNullOrEmpty(g_RemoteHostName))
                throw new NullReferenceException("The Remote HostName has not been set. Please set the HostName prior to calling this method.");
            if (g_RemoteHostName.Contains("http://"))
                throw new FormatException("'http://' cannot be included as a part of the RemoteHost name. It will be automatically inserted.");
            if (g_RemoteHostName.Contains("\\"))
                throw new FormatException("Invalid character '\' in Remote Host name.");
            if (g_RemoteHostName.Contains("/"))
                throw new FormatException("Invalid character '/' in Remote Host name.");
            if (g_RemoteHostName.Contains("?"))
                throw new FormatException("Invalid character '?' in Remote Host name.");


            //Check WebPage URI
            if (!String.IsNullOrEmpty(g_WebPageURI))
            {
                if (g_WebPageURI.Contains("?"))
                    throw new FormatException("Invalid character '?' in Web Page Path.");
                //Remove leading '/' from WebPage URI
                if (g_WebPageURI.Substring(0, 1) == "/")
                    g_WebPageURI = g_WebPageURI.Substring(1);
            }

            //Create the RequestURI string
            if (!String.IsNullOrEmpty(g_WebPageURI))
                m_RequestURI = "http://" + g_RemoteHostName + "/" + g_WebPageURI;
            else
                m_RequestURI = "http://" + g_RemoteHostName;

            //Check for Request Parameter Collection
            if (g_HttpGetRequestParameterCollection != null && g_HttpGetRequestParameterCollection.Count != 0)
            {
                foreach (RequestParameter m_RequestParameter in g_HttpGetRequestParameterCollection)
                    if (m_RequestParameter != null)
                        m_RequestParameterString += HttpUtility.UrlEncode(m_RequestParameter.ParameterName) + "=" + HttpUtility.UrlEncode(m_RequestParameter.ParameterValue) + "&";

                //Remove trailing '&'
                if (m_RequestParameterString.Length > 0)
                    m_RequestParameterString = m_RequestParameterString.Substring(0, m_RequestParameterString.Length - 1);
            }

            if (String.IsNullOrEmpty(m_RequestParameterString))
                return m_RequestURI;
            else
                return m_RequestURI + "?" + m_RequestParameterString;
        } 
        #endregion

        #region Properties
        /// <summary>
        /// Gets or Sets the Request Content-Type.
        /// </summary>
        public string RequestContentType
        {
            get { return g_HttpGetRequestContentType; }

            set { g_HttpGetRequestContentType = value; }
        }

        /// <summary>
        /// Gets or Sets the Remote hostname or domain where the WebPage is hosted.
        /// </summary>
        public string RemoteHostName
        {
            get { return g_RemoteHostName; }

            set { g_RemoteHostName = value; }
        }

        /// <summary>
        /// Gets or Sets the WebPage Relative URI.
        /// </summary>
        public string WebPageURI
        {
            get { return g_WebPageURI; }

            set { g_WebPageURI = value.Replace("\\", "/"); }
        }

        /// <summary>
        /// Gets or Sets the Request Parameter Collection.
        /// </summary>
        public RequestParameterCollection ParameterCollection
        {
            get { return g_HttpGetRequestParameterCollection; }
            set { g_HttpGetRequestParameterCollection = value; }
        }

        /// <summary>
        /// Gets or Sets the Request Security object.
        /// </summary>
        public FrameWorkSecurity RequestSecurity
        {
            get { return g_SecurityObject; }
            set { g_SecurityObject = value; }
        }

        /// <summary>
        /// Gets or Sets the Request Policy object.
        /// </summary>
        public FrameWorkPolicy RequestPolicy
        {
            get { return g_PolicyObject; }
            set { g_PolicyObject = value; }
        }

        /// <summary>
        /// Gets the Response Data for the WebPage HTTP GET Request.
        /// </summary>
        public string HttpGetResponseData
        {
            get { return g_HttpGetResponseString; }
        }

        /// <summary>
        /// Gets the length of the Response Data.
        /// </summary>
        public long HttpGetResponseContentLength
        {
            get { return g_HttpGetResponseContentLength; }
        }

        /// <summary>
        /// Gets the Content Type of the Response Data.
        /// </summary>
        public string HttpGetResponseContentType
        {
            get { return g_HttpGetResponseContentType; }
        }

        /// <summary>
        /// Indicates if the Response Data has been fetched from the cache.
        /// </summary>
        public bool HttpGetResponseIsFromCache
        {
            get { return g_HttpGetResponseIsFromCache; }
        }

        /// <summary>
        /// Indicates if the communication has been Mutually Authenticated.
        /// </summary>
        public bool HttpGetResponseIsMutuallyAuthenticated
        {
            get { return g_HttpGetResponseIsMutuallyAuthenticated; }
        }

        /// <summary>
        /// Gets the actual URI which responded to the WebPage HTTP GET Request.
        /// </summary>
        public Uri HttpGetResponseActualURI
        {
            get { return g_HttpGetResponseActualURI; }
        }

        /// <summary>
        /// Gets the header of the Response for the WebPage HTTP GET Request.
        /// </summary>
        public WebHeaderCollection HttpGetResponseHeader
        {
            get { return g_HttpGetResponseHeader; }
        }

        /// <summary>
        /// Gets the cookies associated with the Response for the WebPage HTTP GET Request.
        /// </summary>
        public CookieCollection HttpGetResponseCookies
        {
            get { return g_HttpGetResponseCookies; }
        }

        /// <summary>
        /// Gets the actual HTTP GET Request string to access the WebSite.
        /// </summary>
        public string HttpGetRequestString
        {
            get
            {
                try
                {
                    return CreateGetRequestURI();
                }
                catch (Exception)
                {
                    throw;
                }
            }
        }
        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HTTPWebAccessFramework\HTTPWebAccessFramework\HTTPPostAccess.cs ===
﻿using System;
using System.Collections.Generic;
using System.Security.Principal;
using System.IO;
using System.Net;
using System.Net.Cache;
using System.Net.Security;
using System.Text;
using System.Web;

namespace Test.Common.Library.HTTPWebAccessFramework
{
    /// <summary>
    /// Represents access of WebSite via HTTP POST protocol.
    /// </summary>
    public class HTTPPostAccess
    {
        private HttpWebRequest g_HttpPostRequest;
        private HttpWebResponse g_HttpPostResponse;
        private FrameWorkSecurity g_SecurityObject;
        private FrameWorkPolicy g_PolicyObject;
        private RequestParameterCollection g_HttpPostRequestParameterCollection;

        //Request Object Params
        private bool g_HttpPostRequestRequirePreAuthenticate;
        private TokenImpersonationLevel g_HttpPostRequestImpersonationLevel;
        private RequestCachePolicy g_HttpPostRequestCachePolicy;
        private AuthenticationLevel g_HttpPostRequestAuthenticationLevel;
        private NetworkCredential g_HttpPostRequestCredentials;
        private string g_HttpPostRequestContentType;
        private int g_HttpPostRequestTimeout;
        private string g_RemoteHostName;
        private string g_WebPageURI;

        //Response Object Params
        private string g_HttpPostResponseString;
        private WebHeaderCollection g_HttpPostResponseHeader;
        private CookieCollection g_HttpPostResponseCookies;
        private long g_HttpPostResponseContentLength;
        private string g_HttpPostResponseContentType;
        private bool g_HttpPostResponseIsFromCache;
        private bool g_HttpPostResponseIsMutuallyAuthenticated;
        private Uri g_HttpPostResponseActualURI;

        #region Constructors
        /// <summary>
        /// Initializes a new instance of the HTTPPostAccess class.
        /// </summary>
        public HTTPPostAccess()
        {
            SetDefaults();
        }

        /// <summary>
        /// Initializes a new instance of the HTTPPostAccess class with the specified
        /// Hostname, Page URI and Request Parameter collection.
        /// </summary>
        /// <param name="RemoteHostName">The Remote computername or domainname hosting the WebSite.</param>
        /// <param name="PageRelativePath">The relative URI path to the Web Page (if required).</param>
        /// <param name="ParameterCollection">A collection of parameter-value to pass to the Target WebSite.</param>
        public HTTPPostAccess(string RemoteHostName, string PageRelativePath, RequestParameterCollection ParameterCollection)
        {
            //Set Defaults
            SetDefaults();

            //Set Passed values
            g_RemoteHostName = RemoteHostName;
            g_WebPageURI = PageRelativePath;
            g_HttpPostRequestParameterCollection = ParameterCollection;
        }

        /// <summary>
        /// Initializes a new instance of the HTTPPostAccess class with the specified
        /// Hostname, Page URI, Request Parameter collection, Security object and Policy object.
        /// </summary>
        /// <param name="RemoteHostName">The Remote computername hosting the Web Service.</param>
        /// <param name="PageRelativePath">The relative URI path to the Web Page (if required).</param>
        /// <param name="ParameterCollection">A collection of parameter-value to pass to the Target WebSite.</param>
        /// <param name="WebServiceSecurity">The Security object for accessing the Target WebSite.</param>
        /// <param name="WebServicePolicy">The Policy object for accessing the Target WebSite.</param>
        public HTTPPostAccess(string RemoteHostName, string PageRelativePath, RequestParameterCollection ParameterCollection,
            FrameWorkSecurity WebServiceSecurity, FrameWorkPolicy WebServicePolicy)
        {
            //Set defaults
            SetDefaults();

            //Set Passed values
            g_RemoteHostName = RemoteHostName;
            g_WebPageURI = PageRelativePath;
            g_HttpPostRequestParameterCollection = ParameterCollection;
            g_SecurityObject = WebServiceSecurity;
            g_PolicyObject = WebServicePolicy;
        }

        #endregion

        #region Methods
        /// <summary>
        /// Indicates if the POST Request object has been initialized.
        /// </summary>
        /// <returns>A value of type System.Boolean. True if the object has been initialized.</returns>
        public bool IsPOSTRequestInitialized()
        {
            if (g_HttpPostRequest != null)
                return true;
            else
                return false;
        }

        /// <summary>
        /// Create the POST Request.
        /// </summary>
        public void CreatePOSTRequest()
        {
            byte[] m_PostRequestContent;
            Stream m_PostRequestStream;

            //Refresh Values
            try
            {
                SetSecurity();
                SetPolicy();
            }
            catch (Exception)
            {
                throw;
            }

            //Create the Post Object
            try
            {
                g_HttpPostRequest = (HttpWebRequest)WebRequest.Create(CreatePostRequestURI());
                g_HttpPostRequest.CookieContainer = new CookieContainer();
                m_PostRequestContent = CreatePostRequestContent();
                g_HttpPostRequest.ContentLength = m_PostRequestContent.Length;
                g_HttpPostRequest.AuthenticationLevel = g_HttpPostRequestAuthenticationLevel;
                g_HttpPostRequest.CachePolicy = g_HttpPostRequestCachePolicy;
                g_HttpPostRequest.ContentType = g_HttpPostRequestContentType;
                g_HttpPostRequest.Credentials = g_HttpPostRequestCredentials;
                g_HttpPostRequest.ImpersonationLevel = g_HttpPostRequestImpersonationLevel;
                g_HttpPostRequest.PreAuthenticate = g_HttpPostRequestRequirePreAuthenticate;
                g_HttpPostRequest.Method = "POST";
                g_HttpPostRequest.Timeout = g_HttpPostRequestTimeout;

                //Write Content
                m_PostRequestStream = g_HttpPostRequest.GetRequestStream();
                m_PostRequestStream.Write(m_PostRequestContent, 0, m_PostRequestContent.Length);
                m_PostRequestStream.Close();
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Get the Response for the POST request.
        /// </summary>
        public void GetResponse()
        {
            StreamReader m_ResponseReader;
            Stream m_ResponseDataStream;

            //Check if the POST Request object has been constructed
            if (!IsPOSTRequestInitialized())
                throw new InvalidOperationException("The POST Request has not been constructed. Please construct the POST request prior to calling this method.");

            try
            {
                g_HttpPostResponse = (HttpWebResponse)g_HttpPostRequest.GetResponse();
                m_ResponseDataStream = g_HttpPostResponse.GetResponseStream();
                m_ResponseReader = new StreamReader(m_ResponseDataStream);
                g_HttpPostResponseHeader = g_HttpPostResponse.Headers;
                g_HttpPostResponseString = m_ResponseReader.ReadToEnd();
                g_HttpPostResponseContentLength = g_HttpPostResponse.ContentLength;
                g_HttpPostResponseContentType = g_HttpPostResponse.ContentType;
                g_HttpPostResponseIsFromCache = g_HttpPostResponse.IsFromCache;
                g_HttpPostResponseIsMutuallyAuthenticated = g_HttpPostResponse.IsMutuallyAuthenticated;
                g_HttpPostResponseActualURI = g_HttpPostResponse.ResponseUri;
                g_HttpPostResponseCookies = g_HttpPostResponse.Cookies;
                //Close Response Stream
                g_HttpPostResponse.Close();
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Sets default values for the various properties of the Post Request Object
        /// </summary>
        private void SetDefaults()
        {
            try
            {
                g_HttpPostRequestRequirePreAuthenticate = false;
                g_HttpPostRequestImpersonationLevel = TokenImpersonationLevel.Delegation;
                g_HttpPostRequestCachePolicy = new RequestCachePolicy(RequestCacheLevel.BypassCache);
                g_HttpPostRequestAuthenticationLevel = AuthenticationLevel.MutualAuthRequested;
                g_HttpPostRequestCredentials = (NetworkCredential)CredentialCache.DefaultCredentials;
                g_HttpPostRequestContentType = "application/x-www-form-urlencoded";
                g_HttpPostRequestTimeout = 100000;
                g_RemoteHostName = String.Empty;
                g_WebPageURI = String.Empty;
                g_HttpPostRequestParameterCollection = null;
                g_SecurityObject = null;
                g_PolicyObject = null;

                g_HttpPostResponseHeader = null;
                g_HttpPostResponseString = String.Empty;
                g_HttpPostResponseContentLength = 0;
                g_HttpPostResponseContentType = String.Empty;
                g_HttpPostResponseIsFromCache = false;
                g_HttpPostResponseIsMutuallyAuthenticated = false;
                g_HttpPostResponseActualURI = null;
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Set the Security parameters of the HTTP POST Request Object.
        /// </summary>
        private void SetSecurity()
        {
            try
            {
                //Check if a Security object exists
                if (g_SecurityObject != null)
                {
                    //Set Access credentials
                    if (!g_SecurityObject.IsDefaultNetworkCredentials())
                        g_HttpPostRequestCredentials = g_SecurityObject.GetNetworkCredential();

                    //Set PreAuth
                    if (g_SecurityObject.RequirePreAuthentication)
                        g_HttpPostRequestRequirePreAuthenticate = true;

                    //Set Impersonation Level
                    switch (g_SecurityObject.RequestImpersonationLevel)
                    {
                        case FrameWorkSecurity.ImpersonationLevel.Anonymous:
                            g_HttpPostRequestImpersonationLevel = TokenImpersonationLevel.Anonymous;
                            break;
                        case FrameWorkSecurity.ImpersonationLevel.Delegation:
                            g_HttpPostRequestImpersonationLevel = TokenImpersonationLevel.Delegation;
                            break;
                        case FrameWorkSecurity.ImpersonationLevel.Identification:
                            g_HttpPostRequestImpersonationLevel = TokenImpersonationLevel.Identification;
                            break;
                        case FrameWorkSecurity.ImpersonationLevel.Impersonation:
                            g_HttpPostRequestImpersonationLevel = TokenImpersonationLevel.Impersonation;
                            break;
                        case FrameWorkSecurity.ImpersonationLevel.None:
                            g_HttpPostRequestImpersonationLevel = TokenImpersonationLevel.None;
                            break;
                    }

                    //Set Authentication Level
                    switch (g_SecurityObject.RequestAuthenticationLevel)
                    {
                        case FrameWorkSecurity.AuthenticationLevel.MutualAuthRequested:
                            g_HttpPostRequestAuthenticationLevel = AuthenticationLevel.MutualAuthRequested;
                            break;
                        case FrameWorkSecurity.AuthenticationLevel.MutualAuthRequired:
                            g_HttpPostRequestAuthenticationLevel = AuthenticationLevel.MutualAuthRequired;
                            break;
                        case FrameWorkSecurity.AuthenticationLevel.None:
                            g_HttpPostRequestAuthenticationLevel = AuthenticationLevel.None;
                            break;
                    }
                }
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Set the general policy for the HTTP POST Request Object.
        /// </summary>
        private void SetPolicy()
        {
            try
            {
                //Check if a Policy Object exists
                if (g_PolicyObject != null)
                {
                    //Set Cache policy
                    g_HttpPostRequestCachePolicy = g_PolicyObject.GetCachePolicy();

                    //Set TimeOut
                    g_HttpPostRequestTimeout = g_PolicyObject.RequestTimeOut;
                }
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Create the POST Request URI String.
        /// </summary>
        /// <returns></returns>
        private string CreatePostRequestURI()
        {
            string m_RequestURI = string.Empty;

            //Check RemoteHostName
            //Check RemoteHostName
            if (String.IsNullOrEmpty(g_RemoteHostName))
                throw new NullReferenceException("The Remote HostName has not been set. Please set the HostName prior to calling this method.");
            if (g_RemoteHostName.Contains("http://"))
                throw new FormatException("'http://' cannot be included as a part of the RemoteHost name. It will be automatically inserted.");
            if (g_RemoteHostName.Contains("\\"))
                throw new FormatException("Invalid character '\' in Remote Host name.");
            if (g_RemoteHostName.Contains("/"))
                throw new FormatException("Invalid character '/' in Remote Host name.");
            if (g_RemoteHostName.Contains("?"))
                throw new FormatException("Invalid character '?' in Remote Host name.");

            //Check WebPage URI
            if (!String.IsNullOrEmpty(g_WebPageURI))
            {
                if (g_WebPageURI.Contains("?"))
                    throw new FormatException("Invalid character '?' in Web Page Path.");
                //Remove leading '/' from WebPage URI
                if (g_WebPageURI.Substring(0, 1) == "/")
                    g_WebPageURI = g_WebPageURI.Substring(1);
            }

            //Create the RequestURI string
            if (!String.IsNullOrEmpty(g_WebPageURI))
                m_RequestURI = "http://" + g_RemoteHostName + "/" + g_WebPageURI;
            else
                m_RequestURI = "http://" + g_RemoteHostName;

            return m_RequestURI;
        }

        /// <summary>
        /// Create the POST request content containing the parameter-value collection.
        /// </summary>
        /// <returns></returns>
        private byte[] CreatePostRequestContent()
        {
            string m_RequestParameterString = String.Empty;

            try
            {
                //Check for Request Parameter Collection
                if (g_HttpPostRequestParameterCollection != null && g_HttpPostRequestParameterCollection.Count != 0)
                {
                    foreach (RequestParameter m_RequestParameter in g_HttpPostRequestParameterCollection)
                        if (m_RequestParameter != null)
                            m_RequestParameterString += HttpUtility.UrlEncode(m_RequestParameter.ParameterName) + "=" + HttpUtility.UrlEncode(m_RequestParameter.ParameterValue) + "&";

                    //Remove trailing '&'
                    if (m_RequestParameterString.Length > 0)
                        m_RequestParameterString = m_RequestParameterString.Substring(0, m_RequestParameterString.Length - 1);
                }
            }
            catch (Exception)
            {
                throw;
            }

            return Encoding.UTF8.GetBytes(m_RequestParameterString);
        }
        #endregion

        #region Properties
        /// <summary>
        /// Gets or Sets the Request Content-Type.
        /// </summary>
        public string RequestContentType
        {
            get { return g_HttpPostRequestContentType; }

            set { g_HttpPostRequestContentType = value; }
        }

        /// <summary>
        /// Gets or Sets the Remote hostname where the WebService is hosted.
        /// </summary>
        public string RemoteHostName
        {
            get { return g_RemoteHostName; }

            set { g_RemoteHostName = value; }
        }

        /// <summary>
        /// Gets or Sets the WebService URI.
        /// </summary>
        public string WebPageURI
        {
            get { return g_WebPageURI; }

            set { g_WebPageURI = value.Replace("\\", "/"); }
        }

        /// <summary>
        /// Gets or Sets the Request Parameter Collection.
        /// </summary>
        public RequestParameterCollection RequestParameterCollection
        {
            get { return g_HttpPostRequestParameterCollection; }
            set { g_HttpPostRequestParameterCollection = value; }
        }

        /// <summary>
        /// Gets or Sets the Request Security object.
        /// </summary>
        public FrameWorkSecurity RequestSecurity
        {
            get { return g_SecurityObject; }
            set { g_SecurityObject = value; }
        }

        /// <summary>
        /// Gets or Sets the Request Policy object.
        /// </summary>
        public FrameWorkPolicy RequestPolicy
        {
            get { return g_PolicyObject; }
            set { g_PolicyObject = value; }
        }

        /// <summary>
        /// Gets the Response Data for the WebPage HTTP POST Request.
        /// </summary>
        public string HttpPostResponseData
        {
            get { return g_HttpPostResponseString; }
        }

        /// <summary>
        /// Gets the length of the Response Data.
        /// </summary>
        public long HttpPostResponseContentLength
        {
            get { return g_HttpPostResponseContentLength; }
        }

        /// <summary>
        /// Gets the Content Type of the Response Data.
        /// </summary>
        public string HttpPostResponseContentType
        {
            get { return g_HttpPostResponseContentType; }
        }

        /// <summary>
        /// Indicates if the Response Data has been fetched from the cache.
        /// </summary>
        public bool HttpPostResponseIsFromCache
        {
            get { return g_HttpPostResponseIsFromCache; }
        }

        /// <summary>
        /// Indicates if the communication has been Mutually Authenticated.
        /// </summary>
        public bool HttpPostResponseIsMutuallyAuthenticated
        {
            get { return g_HttpPostResponseIsMutuallyAuthenticated; }
        }

        /// <summary>
        /// Gets the actual URI which responded to the WebPage HTTP POST Request.
        /// </summary>
        public Uri HttpPostResponseActualURI
        {
            get { return g_HttpPostResponseActualURI; }
        }

        /// <summary>
        /// Gets the header of the Response for the WebPage HTTP POST Request.
        /// </summary>
        public WebHeaderCollection HttpPostResponseHeader
        {
            get { return g_HttpPostResponseHeader; }
        }

        /// <summary>
        /// Gets the cookies associated with the Response for the WebPage HTTP POST Request.
        /// </summary>
        public CookieCollection HttpPostResponseCookies
        {
            get { return g_HttpPostResponseCookies; }
        }

        /// <summary>
        /// Gets the actual HTTP POST Request string to access the WebSite.
        /// </summary>
        public string HttpPostRequestString
        {
            get
            {
                try
                {
                    return CreatePostRequestURI();
                }
                catch (Exception)
                {
                    throw;
                }
            }
        }

        /// <summary>
        /// Gets the HTTP POST Request content.
        /// </summary>
        public byte[] HttpPostRequestContent
        {
            get
            {
                try
                {
                    return CreatePostRequestContent();
                }
                catch (Exception)
                {
                    throw;
                }
            }
        }
        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\NetworkEmulator\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\NetworkMonitor3Wrapper\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\NetworkEmulator\NetworkEmulator\NetworkEmulation.cs ===
﻿using System;
using System.Text;
using NetworkEmulator;

namespace Test.Common.Library.NetworkEmulator
{
    /// <summary>
    /// Represents the network emulator.
    /// </summary>
    public class NetworkEmulation
    {
        INewController g_EmulatorController = null;

        /// <summary>
        /// Initializes a new instance of the NetworkEmulation class
        /// with the specified profile XML.
        /// NOTE: You need to have NEWT installed on your machine to use this API.
        /// See EmulatorPreReq.txt in the dll folder for more details.
        /// </summary>
        /// <param name="ProfileXML">The path and the name of the NEWT profile XML to load.</param>
        public NetworkEmulation(string ProfileXML)
        {
            try
            {
                g_EmulatorController = new NetworkEmulatorClass();
                g_EmulatorController.LoadProfile(ProfileXML);
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Starts the network emulation.
        /// </summary>
        public void StartEmulation()
        {
            try
            {
                g_EmulatorController.Start();
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Stops the network emulation.
        /// </summary>
        public void StopEmulation()
        {
            try
            {
                g_EmulatorController.Stop(1, 10000);
            }
            catch (Exception)
            {
                throw;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\HTTPWebAccessFramework\HTTPWebAccessFramework\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("HTTPWebAccessFramework")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
//[assembly: AssemblyCompany("Microsoft Corporation")]
//[assembly: AssemblyProduct("HTTPWebAccessFramework")]
//[assembly: AssemblyCopyright("Copyright © Microsoft Corporation 2009")]
//[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("04ff6437-f0ea-49b9-928c-9046be45a89e")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
//[assembly: AssemblyVersion("1.0.0.0")]
//[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\NetworkEmulator\NetworkEmulator\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("NetworkEmulator")]
[assembly: AssemblyDescription("")]
//[assembly: AssemblyConfiguration("")]
//[assembly: AssemblyCompany("Microsoft Corp.")]
//[assembly: AssemblyProduct("NetworkEmulator")]
//[assembly: AssemblyCopyright("Copyright © Microsoft Corp. 2009")]
//[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("c12d95ac-662b-46fc-8f31-f031b05b8cbb")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
//[assembly: AssemblyVersion("1.0.0.0")]
//[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\NetworkMonitor3Wrapper\NetworkMonitor3Wrapper\NetmonAPI.cs ===
using System;
using System.Text;
using System.Runtime.InteropServices;

namespace Test.Common.Library.NetworkMonitor3Wrapper.Microsoft.NetworkMonitor
{
    #region Netmon API structs and defines

    /// <summary>
    /// Represents the Netmon API Constants.
    /// </summary>
    public class NmConstant
    {
        /// <summary>
        /// The size of the MAC Address.
        /// </summary>
        public const int MAC_ADDRESS_SIZE = 6;
        /// <summary>
        /// The maximum paths.
        /// </summary>
        public const int MAX_PATH = 260;
        /// <summary>
        /// Size of the NetMon API GUID.
        /// </summary>
        public const int NMAPI_GUID_SIZE = 16;
    }

    /// <summary>
    /// Represents the Netmon API return status code.
    /// </summary>
    public class NmStatusCode
    {
        /// <summary>
        /// The file doesn't have enough space to hold this frame.
        /// </summary>
        public const UInt32 NM_STATUS_FRAME_TOO_BIG_FOR_FILE = 0xE1110001;

        /// <summary>
        /// Capture file size too small. 
        /// </summary>
        public const UInt32 NM_STATUS_FILE_TOO_SMALL = 0xE1110002;

        /// <summary>
        /// Capture file size too large. 
        /// </summary>
        public const UInt32 NM_STATUS_FILE_TOO_LARGE = 0xE1110003;

        /// <summary>
        /// The frame is corrupt. It overlaps with the next frame. 
        /// </summary>
        public const UInt32 NM_STATUS_FRAME_CONTINUES_INTO_NEXT_FRAME = 0xE1110004;

        /// <summary>
        /// The frame is corrupt. The dimensions of the frame are not in the range of the capture file. 
        /// </summary>
        public const UInt32 NM_STATUS_FRAME_RANGE_OUT_OF_BOUNDS = 0xE1110005;

        /// <summary>
        /// The data is in BigEndian and we support only Little Endian 
        /// </summary>
        public const UInt32 NM_STATUS_WRONG_ENDIAN = 0xE1110006;

        /// <summary>
        /// This file is not a valid PCAP file
        /// </summary>
        public const UInt32 NM_STATUS_INVALID_PCAP_FILE = 0xE1110007;

        /// <summary>
        /// This file is not a supported PCAP version 
        /// </summary>
        public const UInt32 NM_STATUS_WRONG_PCAP_VERSION = 0xE1110008;

        /// <summary>
        /// This file type is not supported.
        /// </summary>
        public const UInt32 NM_STATUS_UNSUPPORTED_FILE_TYPE = 0xE1110009;

        /// <summary>
        /// This file type is not a valid Netmon capture file.
        /// </summary>
        public const UInt32 NM_STATUS_INVALID_NETMON_CAP_FILE = 0xE111000A;

        /// <summary>
        /// This Pcap data link type is not supported.
        /// </summary>
        public const UInt32 NM_STATUS_UNSUPPORTED_PCAP_DLT = 0xE111000B;

        /// <summary>
        /// The current NmApi DLL is different from the required version by the application. 
        /// </summary>
        public const UInt32 NM_STATUS_API_VERSION_MISMATCHED = 0xE111000C;
    }

    /// <summary>
    /// Represents the Netmon capture mode.
    /// </summary>
    /// <remarks>
    /// When capturing in promiscuous mode, you may not see traffic if using a switch or if the traffic occurs
    /// on a different segment of the network. The traffic must reach the Network Interface Controller (NIC) on which
    /// you are capturing. Often, network equipment, such as a switch, does not send traffic to a NIC if it is not
    /// directed to that NIC address.
    /// </remarks>
    public enum NmCaptureMode : uint 
    {
        /// <summary>
        /// Specifies only local traffic.
        /// </summary>
        LocalOnly,
        /// <summary>
        /// Specifies all traffic that reaches the network adapter.
        /// </summary>
        Promiscuous
    }

    /// <summary>
    /// Represents the Netmon capture file expansion mode.
    /// </summary> 
    public enum NmCaptureFileFlag : uint
    {
        /// <summary>
        /// Creates a file that wraps around in first-in-first-out (FIFO) order.
        /// When the buffer is full, the oldest data is written over first.
        /// </summary>
        WrapAround,
        /// <summary>
        /// When the maximum file size is reached, a new file is created. If you
        /// have named the file Test.cap, the subsequent files are named test(1).cap,
        /// test(2).cap, and so on.
        /// </summary>
        Chain,
        /// <summary>
        /// Placeholder. Not used.
        /// </summary>
        LastFlag
    };

    /// <summary>
    /// Represents the Capture callback function exit mode.
    /// </summary> 
    public enum NmCaptureCallbackExitMode : uint
    {
        /// <summary>
        /// Remaining frames are discarded.
        /// </summary>
        DiscardRemainFrames = 1,
        /// <summary>
        /// Remaining frames are returned.
        /// </summary>
        ReturnRemainFrames = 2,
    };

    /// <summary>
    /// Represents the Netmon driver adapter operational states.
    /// </summary> 
    /// <remarks>
    /// These states are returned by the Network Driver Interface Specification (NDIS).
    /// </remarks>
    public enum NmAdapterOpState : uint
    {
        /// <summary>
        /// Adapter is currently not bound, or some other low-level error.
        /// </summary>
        None = 0,
        /// <summary>
        /// Adapter is bound to the Network Monitor 3 driver.
        /// </summary>
        Bound,
        /// <summary>
        /// Adapter is bound, but currently not capturing.
        /// </summary>
        Stopped,
        /// <summary>
        /// Adapter is currently capturing network traffic.
        /// </summary>
        Capturing,
        /// <summary>
        /// Adapter is currently paused.
        /// </summary>
        Paused
    };

    /// <summary>
    /// Represents the Status levels of the call back message.
    /// </summary> 
    public enum NmCallbackMsgType : uint
    {
        /// <summary>
        /// Placeholder. This value is never returned.
        /// </summary>
        None,
        /// <summary>
        /// The parser engine has returned an error.
        /// </summary>
        Error,
        /// <summary>
        /// The parser engine has returned a warning message.
        /// </summary>
        Warning,
        /// <summary>
        /// The parser engine has returned an information message. At least
        /// one of these is returned when calling the NmLoadNplParser function.
        /// </summary>
        Information,
        /// <summary>
        /// Placeholder. Not used.
        /// </summary>
        Last
    };

    /// <summary>
    /// Represents the NPL loading option.
    /// </summary> 
    /// <remarks>
    /// By default the NmLoadNplOptionNone is used.  Only the user specified NPL path(s) are loaded.
    /// If both NmAppendRegisteredNplSets and a NPL path are specified, the resulting NPL parser will include
    /// Both and the specified NPL path(s) are prefixed.
    /// </remarks>
    public enum NmNplParserLoadingOption : uint
    {
        /// <summary>
        /// Specifies that only the user-specified NPL path(s) are loaded. This is the default value.
        /// </summary>
        NmLoadNplOptionNone,
        /// <summary>
        /// If both this parameter and an NPL path are specified, the resulting NPL parser will
        /// include both, and the specified NPL path(s) are prefixed.
        /// </summary>
        NmAppendRegisteredNplSets
    };

    /// <summary>
    /// Represents the Frame parser optimization options.
    /// </summary> 
    public enum NmFrameParserOptimizeOption : uint
    {
        /// <summary>
        /// Specifies creating a frame parser without optimization, according to the added filter. This is the default setting.
        /// </summary>
        ParserOptimizeNone = 0,
        /// <summary>
        /// Specifies creating an optimized frame parser, based on added filters, fields, and properties.
        /// </summary>
        ParserOptimizeFull = 1,
        /// <summary>
        /// Placeholder. Not used.
        /// </summary>
        ParserOptimizeLast
    };

    /// <summary>
    /// Represents the Frame parser parsing options.
    /// </summary> 
    [Flags]
    public enum NmFrameParsingOption : uint
    {
        /// <summary>
        /// Not currently used.
        /// </summary>
        None = 0,
        /// <summary>
        /// Return the full field name with the NmGetParsedFieldInfo
        /// function, such as TCP.Flags.Reset. Turning this on degrades performance.
        /// </summary>
        FieldFullNameRequired = 1,
        /// <summary>
        /// Return the containing protocol with NmGetParsedField.
        /// </summary>
        ContainingProtocolNameRequired = 2,
        /// <summary>
        /// Return the data type name, for example, MACAddress when querying for Ethernet.SourceAddress.
        /// </summary>
        DataTypeNameRequired = 4,
        /// <summary>
        /// Use the caller-specified frame number.
        /// </summary>
        UseFrameNumberParameter = 8,
        /// <summary>
        /// Provide the display string of the field.
        /// </summary>
        FieldDisplayStringRequired = 16,
        /// <summary>
        /// Provide frame conversation information.
        /// </summary>
        FrameConversationInfoRequired = 32,
        /// <summary>
        /// Not currently used.
        /// </summary>
        ParsingOptionLast
    };

    /// <summary>
    /// Represents the Fragmentation types returned in parsed frames.
    /// </summary>
    /// <remarks>
    /// When reassembly is performed, the engine signals frames as being first, middle, or last.
    /// You can use this information to determine whether a frame is fragmented. When this occurs,
    /// you can wait for the last frame marked as NmFragmentTypeEnd, and then use the handle to
    /// the inserted frame that is returned by the NmParseFrame function.
    /// </remarks>
    public enum NmFrameFragmentationType : uint
    {
        /// <summary>
        /// This is not part of a fragmented frame.
        /// </summary>
        None,
        /// <summary>
        /// This is the first frame of a set of fragmented frames.
        /// </summary>
        Start,
        /// <summary>
        /// This is a frame in the middle of a set of fragmented frames.
        /// </summary>
        Middle,
        /// <summary>
        /// This is the last frame of a set of fragmented frames.
        /// </summary>
        End
    }

    /// <summary>
    /// Represents the name string properties in parsed field.
    /// </summary> 
    public enum NmParsedFieldNames : uint
    {
        /// <summary>
        /// Field name path is returned.
        /// </summary>
        NamePath,
        /// <summary>
        /// Data type name is returned.
        /// </summary>
        DataTypeName,
        /// <summary>
        /// Containing protocol name is returned.
        /// </summary>
        ContainingProtocolName,
        /// <summary>
        /// Formatted display string is returned.
        /// </summary>
        FieldDisplayString
    };

    /// <summary>
    /// Represents the Key types of the multi storage property.
    /// </summary> 
    public enum NmMvsKeyType : uint
    {
        /// <summary>
        /// Not currently used.
        /// </summary>
        MvsKeyTypeNone,
        /// <summary>
        /// Specifies that the key is a number.
        /// </summary>
        MvsKeyTypeNumber,
        /// <summary>
        /// Specifies that the key is a string.
        /// </summary>
        MvsKeyTypeString,
        /// <summary>
        /// Specifies that the key is a byte array.
        /// </summary>
        MvsKeyTypeByteArray,
        /// <summary>
        /// Specifies that the key is the index of a multivalue storage array.
        /// </summary>
        MvsKeyTypeArrayIndex,
        /// <summary>
        /// Not currently used.
        /// </summary>
        MvsKeyTypeLast
    };

    /// <summary>
    /// Represents the Scopes of properties. It is reported in the property info.
    /// </summary> 
    public enum NmPropertyScope : uint
    {
        /// <summary>
        /// Specifies no scope.
        /// </summary>
        PropertyScopeNone = 0,
        /// <summary>
        /// Specifies that the property applies to the network conversation.
        /// </summary>
        PropertyScopeConversation = 1,
        /// <summary>
        /// Specifies that the property is global.
        /// </summary>
        PropertyScopeGlobal = 2,
        /// <summary>
        /// Specifies that the property applies to the frame. This is the default.
        /// </summary>
        PropertyScopeFrame = 4
    };

    /// <summary>
    /// Represents the property aggregation form, i.e., MVS with key, Array with index, etc.
    /// </summary> 
    /// <remarks>
    /// NmPropertyContainerTypeArray is the regular form if there is only one element.
    /// The NmGetPropertyInfo function may return container type NmPropertyContainerTypeValue if
    /// the key is not specified in the NmAddProperty function.
    /// </remarks>
    public enum NmPropertyContainerType : uint
    {
        /// <summary>
        /// Specifies that there is no property type.
        /// </summary>
        PropertyTypeContainerNone = 0,
        /// <summary>
        /// Specifies that the regular form is a single value of
        /// NmPropertyValueType that can be referenced by just the property name.
        /// </summary>
        PropertyTypeContainerValue,
        /// <summary>
        /// Specifies that the multi-value storage set of properties share the
        /// same name, but have different keys.
        /// </summary>
        PropertyTypeContainerMvs,
        /// <summary>
        /// Specifies a set of properties that are stored in an array and retrieved by name and index.
        /// </summary>
        PropertyTypeContainerArray
    };

    /// <summary>
    /// Represents the type of the property value.
    /// </summary> 
    /// <remarks>
    /// The value types of properties in the same multi-value storage can be different
    /// if they are referenced by different keys. The value types of properties in the 
    /// same property group can also be different if they are referenced by different indexes.
    /// </remarks>
    public enum NmPropertyValueType : uint
    {
        /// <summary>
        /// Specifies no data type for the property value.
        /// </summary>
        PropertyValueNone,
        /// <summary>
        /// Specifies that the property value is a signed integer.
        /// </summary>
        PropertyValueSignedNumber,
        /// <summary>
        /// Specifies that the property value is an unsigned integer.
        /// </summary>
        PropertyValueUnsignedNumber,
        /// <summary>
        /// Specifies that the property value is a string in wide character format.
        /// </summary>
        PropertyValueString,
        /// <summary>
        /// Specifies that the property value is a binary large object (BLOB) presented as a byte array.
        /// </summary>
        PropertyValueByteBlob
    };

    /// <summary>
    /// Represents information on the key for retrieving multi-value storage properties.
    /// The array in this structure is used as a parameter of to the NmGetPropertyValueById
    /// and the NmGetPropertyValueByName functions.
    /// </summary> 
    public struct CNmPropertyStorageKey
    {
        /// <summary>
        /// Type of key to return. Possible values are declared in the NmMvsKeyType enumeration.
        /// </summary>
        public NmMvsKeyType Type;
        /// <summary>
        /// User-supplied length of the key.
        /// </summary>
        public int Length;
        /// <summary>
        /// Marshaled pointer to the key value.
        /// </summary>
        public System.IntPtr ValuePointer;

        /// <summary>
        /// Sets the key to a string value.
        /// </summary>
        public void SetStringKey(String KeyValue)
        {
            Type = NmMvsKeyType.MvsKeyTypeString;
            ValuePointer = Marshal.StringToHGlobalUni(KeyValue);
            Length = KeyValue.Length;
        }

        /// <summary>
        /// Sets the key to a number value.
        /// </summary>
        public void SetNumberKey(Int64 KeyValue)
        {
            Type = NmMvsKeyType.MvsKeyTypeNumber;
            ValuePointer = Marshal.AllocHGlobal(8);
            Marshal.WriteInt64(ValuePointer, KeyValue);
            Length = 8;
        }

        /// <summary>
        /// Sets the key to an array index.
        /// </summary>
        public void SetIndexKey(Int64 KeyValue)
        {
            Type = NmMvsKeyType.MvsKeyTypeArrayIndex;
            ValuePointer = Marshal.AllocHGlobal(8);
            Marshal.WriteInt64(ValuePointer, KeyValue);
            Length = 8;
        }

        /// <summary>
        /// Sets the key to a buffer value.
        /// </summary>
        public void SetByteArrayKey(byte[] KeyValue, Int32 KeyLength)
        {
            Type = NmMvsKeyType.MvsKeyTypeByteArray;
            ValuePointer = Marshal.AllocHGlobal(KeyLength);
            for (int i = 0; i < KeyLength; ++i)
            {
                Marshal.WriteByte(ValuePointer, i, KeyValue[i]);
            }
            Length = KeyLength;
        }
    };

    /// <summary>
    /// Contains runtime information for instantiated properties.
    /// </summary>
    public struct NM_NPL_PROPERTY_INFO
    {
        /// <summary>
        /// Specifies the size of the property for version control.
        /// </summary>
        public System.UInt16 Size;

        /// <summary>
        /// Specifies the property scope, one of the elements of the NmPropertyScope enumeration.
        /// </summary>
        public NmPropertyScope Scope;

        /// <summary>
        /// Specifies the property container type, one of the elements of the NmPropertyContainerType enumeration.
        /// </summary>
        public NmPropertyContainerType ContainerType;

        /// <summary>
        /// Specifies the element count of the name, excluding the terminator. When the name buffer is provided,
        /// this member is used for both input and output parameters. This member acts as an input parameter
        /// specifying the buffer length. The actual length of the name is also returned by the NmGetPropertyInfo
        /// function. When no name buffer is provided (the Name parameter is NULL), this member is used only as output.
        /// </summary>
        public System.UInt16 NameSize;

        /// <summary>
        /// Property name string added by the NmAddProperty function. If a buffer is assigned when calling NmGetPropertyInfo,
        /// the NameSize member must specify the buffer length, in number of elements. NmGetPropertyInfo returns the
        /// property name in the buffer if the buffer has enough space. Otherwise, a buffer overflow error is returned.
        /// Set this member to NULL if you do not need a name returned.
        /// </summary>
        [MarshalAs(UnmanagedType.LPWStr)]
        public System.String Name;

        /// <summary>
        /// Specifies the data type of the property value, one of the elements of the NmPropertyValueType enumeration.
        /// If the value type is string, the termination pattern is not included.
        /// </summary>
        public NmPropertyValueType ValueType;

        /// <summary>
        /// Specifies the size, in byte count, of the value for which the caller must provide a buffer. If ValueType
        /// is set to String, this member is in WCHAR, and the termination pattern is not included.
        /// </summary>
        public System.UInt32 ValueSize;

        /// <summary>
        /// Specifies the number of items in the array. Regular and multi-value storage properties have only one item.
        /// </summary>
        public System.UInt32 ItemCount;
    };

    /// <summary>
    /// Represents the fragmentation information returned in parsed frames.
    /// </summary> 
    /// <remarks>
    /// A frame is either non-fragmented or fragmented. A fragmented frame can be a start fragment,
    /// a middle fragment, or an end fragment. The carrier protocol of the fragment and the
    /// fragmented protocol information is included, if available.
    /// </remarks>
    public struct NmFragmentationInfo
    {
        /// <summary>
        /// Size of the structure to be initialized by the caller.
        /// </summary>
        public UInt16 Size;

        /// <summary>
        /// Name of the protocol that has fragmented the payload, such as IPv4, which breaks payloads
        /// into smaller segments for networks with smaller frame size.
        /// </summary>
        [MarshalAs(UnmanagedType.ByValArray, ArraySubType = UnmanagedType.U2, SizeConst = NmConstant.MAX_PATH)]
        public System.Char[] FragmentedProtocolName;

        /// <summary>
        /// Name of the protocol to which the fragments belong. For example, HTTP may be the payload of TCP.
        /// Multiple TCP packets make up one HTTP page. Although TCP is a byte-stream transport, Network
        /// Monitor currently manipulates TCP at the frame level for simplicity.
        /// </summary>
        [MarshalAs(UnmanagedType.ByValArray, ArraySubType = UnmanagedType.U2, SizeConst = NmConstant.MAX_PATH)]
        public System.Char[] PayloadProtocolName;

        /// <summary>
        /// Type of fragment as defined by the NmFrameFragmentationType enumeration.
        /// </summary>
        public NmFrameFragmentationType FragmentType;
    };

    /// <summary>
    /// Callback function for frame receiving/retrieving.
    /// </summary>
    /// <param name="hCaptureEngine">Handle to the capture engine object responsible for this callback returned by
    /// the NmOpenCaptureEngine function.</param>
    /// <param name="ulAdapterIndex">Index of the adapter on which this frame was captured. Within the range from
    /// zero to the value returned by the NmGetAdapterCount function.</param>
    /// <param name="pCallerContext">Pointer to the object that was passed in to NmConfigAdapter. For example,
    /// a capture file handle can be passed in so that the raw frame received can be saved.</param>
    /// <param name="hFrame">Handle to the raw captured frame. You do not need to free this handle.</param>
    /// <remarks>
    /// This callback is called after the capture engine has stored the frame within the buffer on the computer 
    /// hard drive. Any heavy processing within the callback may cause a loss of network frames if the buffer
    /// grows beyond the capacity of the drive or the set capture file limit or quota.
    /// </remarks>
    public delegate void CaptureCallbackDelegate(IntPtr hCaptureEngine,
                                                 UInt32 ulAdapterIndex,
                                                 IntPtr pCallerContext,
                                                 IntPtr hFrame);


    /// <summary>
    /// Represents the Frame parser conversation configuration options.
    /// </summary> 
    public enum NmConversationConfigOption : uint
    {
        /// <summary>
        /// There are currently no conversation options. Always set this to NmConversationOptionNone.
        /// </summary>
        None,
        /// <summary>
        /// Do not use.
        /// </summary>
        Last
    };

    /// <summary>
    /// Represents the frame parser reassembly configuration options.
    /// </summary> 
    public enum NmReassemblyConfigOption : uint
    {
        /// <summary>
        /// Currently, there are no reassembly options. Always set this to NmReassemblyOptionNone.
        /// </summary>
        None,
        /// <summary>
        /// Do not use.
        /// </summary>
        Last
    };

    /// <summary>
    /// Callback function for parser compile/build process.
    /// </summary>
    /// <param name="pCallerContext">User-defined context to send to parser message callback.</param>
    /// <param name="ulStatusCode">Status code of the message.</param>
    /// <param name="lpDescription">Text description of the message.</param>
    /// <param name="ulType">Type of error message as described by the NmCallbackMsgType enumeration.</param>
    /// <remarks>
    /// The same callback can be used for loading the NmLoadNplParser and NmCreateFrameParserConfiguration functions.
    /// When loading the Network Monitor Parsing Language (NPL), you receive errors, warnings, and status messages.
    /// Since a status message is sent even for a successful load or build, you will be called at least one. When
    /// creating the frame parser, you will be called with error callbacks in the parser and when errors are flagged.
    /// For example, when a frame is not parsed and there is extra data, an error is often flagged by the parser.
    /// </remarks>
    public delegate void ParserCallbackDelegate(IntPtr pCallerContext,
                                                UInt32 ulStatusCode,
                                                [MarshalAs(UnmanagedType.LPWStr)] String lpDescription,
                                                NmCallbackMsgType ulType);

    /// <summary>
    /// Contains adapter or interface information as returned by the NmGetAdapter function.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    public struct NM_NIC_ADAPTER_INFO
    {
        /// <summary>
        /// Size of structure that is set by the caller.
        /// </summary>
        public System.UInt16 Size;

        /// <summary>
        /// Hardware address of the Network Interface Controller (NIC).
        /// </summary>
        [MarshalAs(UnmanagedType.ByValArray, ArraySubType = UnmanagedType.U1, SizeConst = NmConstant.MAC_ADDRESS_SIZE)]
        public System.Byte[] PermanentAddr;

        /// <summary>
        /// Driver-defined hardware address. Not all drivers support this.
        /// </summary>
        [MarshalAs(UnmanagedType.ByValArray, ArraySubType = UnmanagedType.U1, SizeConst = NmConstant.MAC_ADDRESS_SIZE)]
        public System.Byte[] CurrentAddr;

        /// <summary>
        /// Network Driver Interface Specification (NDIS) NdisMediumXXX type that the adapter supports.
        /// </summary>
        public NDIS_MEDIUM MediaType;

        /// <summary>
        /// Physical medium type that the adapter supports.
        /// </summary>
        public NDIS_PHYSICAL_MEDIUM PhysicalMediaType;

        /// <summary>
        /// Internal name of the connection. This is often blank.
        /// </summary>
        [MarshalAs(UnmanagedType.ByValArray, ArraySubType = UnmanagedType.U2, SizeConst = NmConstant.MAX_PATH)]
        public System.Char[] ConnectionName;

        /// <summary>
        /// Friendly name of the interface for this adapter. This is the description that appears in ipconfig.
        /// </summary>
        [MarshalAs(UnmanagedType.ByValArray, ArraySubType = UnmanagedType.U2, SizeConst = NmConstant.MAX_PATH)]
        public System.Char[] FriendlyName;

        /// <summary>
        /// Interface GUID of the adapter.
        /// </summary>
        [MarshalAs(UnmanagedType.ByValArray, ArraySubType = UnmanagedType.U2, SizeConst = NmConstant.MAX_PATH)]
        public System.Char[] Guid;

        /// <summary>
        /// Operation state. For more information, see the NmAdapterOpState enumeration.
        /// </summary>
        public NmAdapterOpState OpState;

        /// <summary>
        /// Whether the adapter is enabled.
        /// </summary>
        public System.Int32 Enabled;

        /// <summary>
        /// Whether the adapter allows for promiscuous mode sniffing.
        /// </summary>
        public System.Int32 PModeEnabled;

        /// <summary>
        /// Callback function provided when you configured the adapter with the NmConfigAdapter function.
        /// The callback function is called by the capture engine to deliver raw frames captured on the adapter.
        /// </summary>
        [MarshalAs(UnmanagedType.FunctionPtr)]
        public CaptureCallbackDelegate CallBackFunction;
    };

    /// <summary>
    /// Contains parser configuration information. It is used to retrieve current configuration
    /// or set user-specified configuration.
    /// </summary>
    /// <remarks>
    /// Use the NmApiInitialize and the NmGetApiConfiguration functions to set and retrieve this structure.
    /// NmAPIInitialize changes the default configuration parameters defined in the this structure.
    /// The values specified in the structure as parameters passed in to NmAPIInitialize overwrite the default
    /// values. Therefore, it is recommended that you first get the configuration, and then change the values
    /// as desired before calling NmAPIInitialize with an alternate configuration.
    /// </remarks>
    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    public struct NM_API_CONFIGURATION
    {
        /// <summary>
        /// Size of the structure to be set by the caller.
        /// </summary>
        public System.UInt16 Size;

        /// <summary>
        /// Maximum number of handles available for raw frames. Default value is 1000.
        /// </summary>
        public System.UInt32 RawFrameHandleCountLimit;

        /// <summary>
        /// Maximum number of handles available for parsed frames. Default value is 1000.
        /// </summary>
        public System.UInt32 ParsedFrameHandleCountLimit;

        /// <summary>
        /// Maximum number of handles available for capture engines. Default value is 10.
        /// </summary>
        public System.UInt32 CaptureEngineCountLimit;

        /// <summary>
        /// Maximum number of handles available for Network Monitor Parsing Language (NPL)
        /// parser sets. Default value is 50.
        /// </summary>
        public System.UInt32 NplParserCountLimit;

        /// <summary>
        /// Maximum number of handles available for frame parser configurations.
        /// Default value is 50.
        /// </summary>
        public System.UInt32 FrameParserConfigCountLimit;

        /// <summary>
        /// Maximum number of handles available for frame parsers. Default value is 50.
        /// </summary>
        public System.UInt32 FrameParserCountLimit;

        /// <summary>
        /// Maximum number of handles available for capture files. Default value is 10.
        /// </summary>
        public System.UInt32 CaptureFileCountLimit;

        /// <summary>
        /// Threading mode. Possible values are COINIT_MULTITHREADED (0) and
        /// COINIT_APARTMENTTHREADED (2). Default value is COINIT_APARTMENTTHREADED.
        /// </summary>
        public System.UInt16 ThreadingMode;

        /// <summary>
        /// Not currently used. See NmConversationConfigOption for information on conversation flags.
        /// </summary>
        public NmConversationConfigOption ConversationOption;

        /// <summary>
        /// Not currently used. See NmReassemblyConfigOption for information on reassembly flags.
        /// </summary>
        public NmReassemblyConfigOption ReassemblyOption;

        /// <summary>
        /// Override default capture file options. Default value is CaptureFileWrapAround. See
        /// NmCaptureFileMode for information on capture flags.
        /// </summary>
        public NmCaptureFileFlag CaptureFileMode;

        /// <summary>
        /// Override default parsing options. No longer used.
        /// </summary>
        public NmFrameParsingOption FrameParsingOption;

        /// <summary>
        /// Stop capture exit mode. Possible values are elements in the NmCaptureCallbackExitMode
        /// enumeration. The default value is NmDiscardRemainFrames.
        /// </summary>
        public NmCaptureCallbackExitMode CaptureCallbackExitMode;

        /// <summary>
        /// Maximum size for a capture file. This is used when the NmCreateCaptureFile function is called.
        /// The value is 500 MB. This member is not user-configurable. It is read-only.
        /// </summary>
        public System.UInt32 MaxCaptureFileSize;

        /// <summary>
        /// Minimum size for a capture file. This is used when NmCreateCaptureFile is called. The value is 2072 bytes.
        /// This member is not user-configurable. It is read-only.
        /// </summary>
        public System.UInt32 MinCaptureFileSize;

        /// <summary>
        /// Maximum number of handles per handle type. Default value is 65,536. It is read-only.
        /// </summary>
        public System.UInt32 MaxApiHandleLimit;
    };

    /// <summary>
    /// Defines how a protocol defines ordering of packets.
    /// </summary>
    /// <remarks>
    /// A caller using this structure must initialize the size before calling NmAddSequenceOrderConfig.
    /// </remarks>
    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    public struct NM_PROTOCOL_SEQUENCE_CONFIG
    {
        /// <summary>
        /// This member must match the size of the version.
        /// </summary>
        public UInt16 Size;

        /// <summary>
        /// Names of the properties containing the values to form the key to identify the group
        /// of the frames to put in order. If multiple properties are used, they are separated by
        /// semicolons. The string must be NULL-terminated.
        /// </summary>
        [MarshalAs(UnmanagedType.LPWStr)]
        public String GroupKeyString;

        /// <summary>
        /// Name of the property containing the frame's sequence number.
        /// </summary>
        [MarshalAs(UnmanagedType.LPWStr)]
        public String SequencePropertyString;

        /// <summary>
        /// Name of the property containing the frame's next sequence number.
        /// </summary>
        [MarshalAs(UnmanagedType.LPWStr)]
        public String NextSequencePropertyString;
    };

    /// <summary>
    /// Structure for calling NmOpCaptureFileInOrder to provide the parser built with sequence
    /// control information to correct potential out-of-order frames in the capture file to be opened.
    /// It also contains an option flag for future extension.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    public struct NM_ORDER_PARSER_PARAMETER
    {
        /// <summary>
        /// This member must match the size of the current version.
        /// </summary>
        public UInt16 Size;

        /// <summary>
        /// Frame parser used for handling out-of-order frames. It must be built from a frame parser
        /// configuration that has sequence information specified by the NM_PROTOCOL_SEQUENCE_CONFIG structure.
        /// </summary>
        public IntPtr hFrameParser;

        /// <summary>
        /// Not currently used.
        /// </summary>
        public UInt32 Option;

    };

    /// <summary>
    /// Represents the Network Medium.
    /// </summary>
    public enum NDIS_MEDIUM
    {
        /// <summary>
        /// </summary>
        Ndis_802_3,
        /// <summary>
        /// </summary>
        Ndis_802_5,
        /// <summary>
        /// </summary>
        Ndis_Fddi,
        /// <summary>
        /// </summary>
        Ndis_Wan,
        /// <summary>
        /// </summary>
        Ndis_LocalTalk,
        /// <summary>
        /// </summary>
        Ndis_Dix,              // defined for convenience, not a real medium
        /// <summary>
        /// </summary>
        Ndis_ArcnetRaw,
        /// <summary>
        /// </summary>
        Ndis_Arcnet878_2,
        /// <summary>
        /// </summary>
        Ndis_Atm,
        /// <summary>
        /// </summary>
        Ndis_WirelessWan,
        /// <summary>
        /// </summary>
        Ndis_Irda,
        /// <summary>
        /// </summary>
        Ndis_Bpc,
        /// <summary>
        /// </summary>
        Ndis_CoWan,
        /// <summary>
        /// </summary>
        Ndis_1394,
        /// <summary>
        /// </summary>
        Ndis_InfiniBand,
        /// <summary>
        /// #if ((NTDDI_VERSION >= NTDDI_VISTA) || NDIS_SUPPORT_NDIS6)
        /// </summary>
        Ndis_Tunnel,
        /// <summary>
        /// </summary>
        Ndis_Native802_11,
        /// <summary>
        /// </summary>
        Ndis_Loopback,
        /// <summary>
        /// #endif // (NTDDI_VERSION >= NTDDI_VISTA)
        /// </summary>
        NdisMediumMax               // Not a real medium, defined as an upper-bound
    };


    /// <summary>
    /// Represents the Network Physical medium.
    /// </summary>
    public enum NDIS_PHYSICAL_MEDIUM
    {
        /// <summary>
        /// </summary>
        Ndis_Unspecified,
        /// <summary>
        /// </summary>
        Ndis_WirelessLan,
        /// <summary>
        /// </summary>
        Ndis_CableModem,
        /// <summary>
        /// </summary>
        Ndis_PhoneLine,
        /// <summary>
        /// </summary>
        Ndis_PowerLine,
        /// <summary>
        /// includes ADSL and UADSL (G.Lite)
        /// </summary>
        Ndis_DSL,
        /// <summary>
        /// </summary>
        Ndis_FibreChannel,
        /// <summary>
        /// </summary>
        Ndis_1394,
        /// <summary>
        /// </summary>
        Ndis_WirelessWan,
        /// <summary>
        /// </summary>
        Ndis_Native802_11,
        /// <summary>
        /// </summary>
        Ndis_Bluetooth,
        /// <summary>
        /// </summary>
        Ndis_Infiniband,
        /// <summary>
        /// </summary>
        Ndis_WiMax,
        /// <summary>
        /// </summary>
        Ndis_UWB,
        /// <summary>
        /// </summary>
        Ndis_802_3,
        /// <summary>
        /// </summary>
        Ndis_802_5,
        /// <summary>
        /// </summary>
        Ndis_Irda,
        /// <summary>
        /// </summary>
        Ndis_WiredWAN,
        /// <summary>
        /// </summary>
        Ndis_WiredCoWan,
        /// <summary>
        /// </summary>
        Ndis_Other,
        /// <summary>
        /// </summary>
        NdisPhysicalMediumMax       // Not a real physical type, defined as an upper-bound
    };

    /// <summary>
    /// Numerical Definitions of Variant Types. <br/>
    /// http://www.marin.clara.net/COM/variant_type_definitions.htm
    /// </summary>
    public class FieldType
    {
        /// <summary>
        /// </summary>
        public const UInt16 VT_EMPTY = 0;
        /// <summary>
        /// </summary>
        public const UInt16 VT_NULL = 1;
        /// <summary>
        /// </summary>
        public const UInt16 VT_I2 = 2;
        /// <summary>
        /// </summary>
        public const UInt16 VT_I4 = 3;
        /// <summary>
        /// </summary>
        public const UInt16 VT_R4 = 4;
        /// <summary>
        /// </summary>
        public const UInt16 VT_R8 = 5;
        /// <summary>
        /// </summary>
        public const UInt16 VT_CY = 6;
        /// <summary>
        /// </summary>
        public const UInt16 VT_DATE = 7;
        /// <summary>
        /// </summary>
        public const UInt16 VT_BSTR = 8;
        /// <summary>
        /// </summary>
        public const UInt16 VT_DISPATCH = 9;
        /// <summary>
        /// </summary>
        public const UInt16 VT_ERROR = 10;
        /// <summary>
        /// </summary>
        public const UInt16 VT_BOOL = 11;
        /// <summary>
        /// </summary>
        public const UInt16 VT_VARIANT = 12;
        /// <summary>
        /// </summary>
        /// <summary>
        /// </summary>
        public const UInt16 VT_UNKNOWN = 13;
        /// <summary>
        /// </summary>
        public const UInt16 VT_DECIMAL = 14;
        /// <summary>
        /// </summary>
        public const UInt16 VT_I1 = 16;
        /// <summary>
        /// </summary>
        public const UInt16 VT_UI1 = 17;
        /// <summary>
        /// </summary>
        public const UInt16 VT_UI2 = 18;
        /// <summary>
        /// </summary>
        public const UInt16 VT_UI4 = 19;
        /// <summary>
        /// </summary>
        public const UInt16 VT_I8 = 20;
        /// <summary>
        /// </summary>
        public const UInt16 VT_UI8 = 21;
        /// <summary>
        /// </summary>
        public const UInt16 VT_INT = 22;
        /// <summary>
        /// </summary>
        public const UInt16 VT_UINT = 23;
        /// <summary>
        /// </summary>
        public const UInt16 VT_VOID = 24;

        /// <summary>
        /// </summary>
        public const UInt16 VT_HRESULT = 25;
        /// <summary>
        /// </summary>
        public const UInt16 VT_PTR = 26;
        /// <summary>
        /// </summary>
        public const UInt16 VT_SAFEARRAY = 27;

        /// <summary>
        /// </summary>
        public const UInt16 VT_CARRAY = 28;
        /// <summary>
        /// </summary>
        public const UInt16 VT_USERDEFINED = 29;
        /// <summary>
        /// </summary>
        public const UInt16 VT_LPSTR = 30;

        /// <summary>
        /// </summary>
        public const UInt16 VT_LPWSTR = 31;
        /// <summary>
        /// </summary>
        public const UInt16 VT_FILETIME = 64;
        /// <summary>
        /// </summary>
        public const UInt16 VT_BLOB = 65;

        /// <summary>
        /// </summary>
        public const UInt16 VT_STREAM = 66;
        /// <summary>
        /// </summary>
        public const UInt16 VT_STORAGE = 67;
        /// <summary>
        /// </summary>
        public const UInt16 VT_STREAMED_OBJECT = 68;

        /// <summary>
        /// </summary>
        public const UInt16 VT_STORED_OBJECT = 69;
        /// <summary>
        /// </summary>
        public const UInt16 VT_BLOB_OBJECT = 70;
        /// <summary>
        /// </summary>
        public const UInt16 VT_CF = 71;

        /// <summary>
        /// </summary>
        public const UInt16 VT_CLSID = 72;
        /// <summary>
        /// </summary>
        public const UInt16 VT_VECTOR = 0x1000;
        /// <summary>
        /// </summary>
        public const UInt16 VT_ARRAY = 0x2000;

        /// <summary>
        /// </summary>
        public const UInt16 VT_BYREF = 0x4000;
        /// <summary>
        /// </summary>
        public const UInt16 VT_RESERVED = 0x8000;
        /// <summary>
        /// </summary>
        public const UInt16 VT_ILLEGAL = 0xffff;

        /// <summary>
        /// </summary>
        public const UInt16 VT_ILLEGALMASKED = 0xfff;
        /// <summary>
        /// </summary>
        public const UInt16 VT_TYPEMASK = 0xfff;
    }

    /// <summary>
    /// Contains information about the data field, such as field offset, field length, and so on.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    public struct NmParsedFieldInfo
    {
        /// <summary>
        /// Caller-provided size of the structure being sent. Should be initialized by the user.
        /// </summary>
        public System.UInt16 Size;

        /// <summary>
        /// Indent of data field. For example, top-level fields have an indent of zero,
        /// but Tcp.flags.reset has an indent of 2.
        /// </summary>
        public System.UInt16 FieldIndent;

        /// <summary>
        /// Length in elements of the name path. Since this is returned as a WCHAR, you must
        /// multiply it by sizeof(WCHAR). This does not include a NULL, which is added by the
        /// NmGetFieldName function.
        /// </summary>
        public System.UInt16 NamePathLength;

        /// <summary>
        /// Length in elements of the data type. Since this is returned as a WCHAR, you must
        /// multiply by sizeof(WCHAR). This does not include a NULL, which is added by NmGetFieldName.
        /// </summary>
        public System.UInt16 NplDataTypeNameLength;

        /// <summary>
        /// Length in elements of the protocol name. Since this is returned as a WCHAR, you must multiply
        /// by sizeof(WCHAR). This does not include a NULL, which is added by NmGetFieldName.
        /// </summary>
        public System.UInt16 ProtocolNameLength;

        /// <summary>
        /// Length of the Display String.
        /// </summary>
        public System.UInt16 DisplayStringLength;

        /// <summary>
        /// Offset from the beginning of the protocol, in bits.
        /// </summary>
        public System.UInt32 ProtocolBitOffset;

        /// <summary>
        /// Frame offset of the data field, in bits.
        /// </summary>
        public System.UInt32 FrameBitOffset;

        /// <summary>
        /// Size of the data field, in bits.
        /// </summary>
        public System.UInt32 FieldBitLength;

        /// <summary>
        /// Variant type of the value, as defined by VARENUM.
        /// </summary>
        public System.UInt16 ValueType;

        /// <summary>
        /// Size of the buffer required to hold the field value.
        /// </summary>
        public System.UInt16 ValueBufferLength;
    };
    #endregion

    /// <summary>
    /// PInvoke wrapper of Netmon API.
    ///     - managed/unmanaged data type mapping: http://msdn2.microsoft.com/en-us/library/ac7ay120.aspx
    ///     - the declaration in this class are strongly tied to nmapi.h
    /// </summary>
    public class NetmonAPI
    {
        #region API Operations

        /// <summary>
        /// Retrieves the current major and minor version numbers of the API.
        /// </summary> 
        /// <remarks>
        /// The API version matches netmon engine version.
        /// </remarks>
        /// <example>
        /// <code>
        ///     UInt16 majorNumber = 0;
        ///     UInt16 minorNumber = 0;
        ///     UInt16 BuildNumber = 0;
        ///     UInt16 RevisionNumber = 0;
        ///     NmGetApiVersion(out majorNumber, out minorNumber, out BuildNumber, out RevisionNumber);
        /// </code>
        /// </example>
        /// <param name="Major">Major version number.</param>
        /// <param name="Minor">Minor version number.</param>
        /// <param name="Build">Build number.</param>
        /// <param name="Revision">Revision number.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        [DllImport("NmApi.Dll")]
        public static extern void NmGetApiVersion(out UInt16 Major, out UInt16 Minor, out UInt16 Build, out UInt16 Revision);

        /// <summary>
        /// Gets the current API configuration parameters.
        /// </summary> 
        /// <example>
        /// <code>
        ///    NM_API_CONFIGURATION apiConfig = new NM_API_CONFIGURATION();
        ///    apiConfig.Size = (ushort)System.Runtime.InteropServices.Marshal.SizeOf(typeof(NM_API_CONFIGURATION));
        ///    uint status = NetmonAPI.NmGetApiConfiguration(ref apiConfig);
        /// </code>
        /// </example>
        /// <param name="ApiConfig">Struct object for API to fill.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     NM_STATUS_API_VERSION_MISMATCHED: The version of NM_API_CONFIGURATION struct is different.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmGetApiConfiguration(ref NM_API_CONFIGURATION ApiConfig);

        /// <summary>
        /// Overrides the default API configuration.
        /// </summary> 
        /// <remarks>
        /// Caller needs to provide storage for NmApiConfiguration struct.
        /// </remarks>
        /// <example>
        /// <code>
        ///    NM_API_CONFIGURATION apiConfig = new NM_API_CONFIGURATION();
        ///    apiConfig.Size = (ushort)System.Runtime.InteropServices.Marshal.SizeOf(typeof(NM_API_CONFIGURATION));
        ///    uint status = NetmonAPI.NmGetApiConfiguration(ref apiConfig);
        ///    apiConfig.ThreadingMode = 0;
        ///    status = NetmonAPI.NmApiInitialize(ref apiConfig);
        /// </code>
        /// </example>
        /// <param name="ApiConfig">Caller specified API configuration parameter struct.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     NM_STATUS_API_VERSION_MISMATCHED: The version of NM_API_CONFIGURATION struct is different. <br/>
        ///     ERROR_INVALID_STATE: Can not change API configuration.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmApiInitialize(ref NM_API_CONFIGURATION ApiConfig);

        /// <summary>
        /// Closes down the API after finishing all work. It releases all the objects referenced by handles.
        /// On Windows XP and Windows Server 2003, it also detaches from the driver DLL.
        /// </summary>
        /// <remarks>
        /// Should be called when done with the API.
        /// </remarks>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmApiClose();

        /// <summary>
        /// Release the reference to the object by handle.</summary> 
        /// <remarks>
        /// Callers need to close all the object handles returned from API after finish using them.
        /// </remarks>
        /// <param name="hObjectHandle">Handle to the object to release </param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        [DllImport("NmApi.Dll")]
        public static extern void NmCloseHandle(IntPtr hObjectHandle);
        
        #endregion

        #region Capture Engine Operations

        /// <summary>
        /// Initializes the engine for live data capture.
        /// </summary> 
        /// <param name="phCaptureEngine">Handle to the capture engine object.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_INVALID_STATE:     The operation is not available. <br/>
        ///     ERROR_ENOUGH_MEMORY: Fail to allocate memory for the object.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmOpenCaptureEngine(out IntPtr phCaptureEngine);

        /// <summary>
        /// Gets the number of network interfaces currently accessible to the API.
        /// </summary> 
        /// <remarks>
        /// The count returned may be zero if no adapters are registered on the computer or the current user
        /// is not a member of the Netmon Users security group. It is required to be a member of this group
        /// in order to capture on Windows Vista and above. New users to the group may be required to log on
        /// again to gain capture privileges unless they run as an administrator.
        /// </remarks>
        /// <param name="hCaptureEngine">Handle to the capture engine returned by the NmOpenCaptureEngine function.</param>
        /// <param name="ulCount">Pointer to the returned adapter count value. If zero, no adapters are available.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: Invalid handle.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmGetAdapterCount(IntPtr hCaptureEngine, out UInt32 ulCount);

        /// <summary>
        /// Gets available information about a specific network adapter.
        /// </summary> 
        /// <remarks>
        /// Caller can use name, GUID etc. to select adapter to use.  The adapter index should be within the 
        /// Range returned by NmGetAdapterCount method.  Caller needs to provide the storage of the
        /// NmNicAdapterInfo struct.
        /// The fix sized name buffers in the NM_NIC_ADAPTER_INFO structure are marshal to System.char[]. 
        /// Use String nameStr = new String("e.g., whateverDefinedStructName.ConnectionName") to translate the
        /// char array to a string object.
        /// </remarks>
        /// <example>
        /// <code>
        ///    IntPtr hCaptureEngine = HandleReturnedByNmOpenCaptureEngine;
        ///    UInt32 ulIndex = 0;
        ///    NM_NIC_ADAPTER_INFO adapterInfo = new NM_NIC_ADAPTER_INFO();
        ///    adapterInfo.Size = (ushort)System.Runtime.InteropServices.Marshal.SizeOf(adapterInfo);
        ///    uint status = NetmonAPI.NmGetAdapter(hCaptureEngine, ulIndex, ref adapterInfo);
        ///    String nameStr = new String(adapterInfo.ConnectionName);
        /// </code>
        /// </example>
        /// <param name="hCaptureEngine">Handle to the capture engine object returned by the NmOpenCaptureEngine function.</param>
        /// <param name="ulIndex">Index of the adapter within the range returned by the NmGetAdapterCount function.</param>
        /// <param name="pNMAdapterInfo">Pointer to a NM_NIC_ADAPTER_INFO structure.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: Invalid handle. <br/>
        ///     NM_STATUS_API_VERSION_MISMATCHED: The version of NM_NIC_ADAPTER_INFO struct is different.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmGetAdapter(IntPtr hCaptureEngine, UInt32 ulIndex, ref NM_NIC_ADAPTER_INFO pNMAdapterInfo);

        /// <summary>
        /// Configure the adapter with the frame indication callback and the caller context.
        /// </summary> 
        /// <remarks>
        /// The current callback function and context will overwrite the previous ones.  The adapter index number
        /// Must be in the range returned from NmGetAdapterCount method.
        /// </remarks>
        /// <param name="hCaptureEngine">Handle to the capture engine object returned by the NmOpenCaptureEngine function.</param>
        /// <param name="ulIndex">Index of the adapter. The range is from zero to value returned by the NmGetAdapterCount function.</param>
        /// <param name="CallbackFunction">Pointer to the callback function to receive live network data frames.
        /// See the NM_FRAME_CALLBACK function for details on the callback function.</param>
        /// <param name="pCallerContext">Arbitrary pointer that passes extra information to the network frame callback function.</param>
        /// <param name="ExitMode">Specifies whether to discard or process remaining frames after the capture engine stops.
        /// See NmCaptureCallbackExitMode for possible values. The default value is NmDiscardRemainFrames.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: Invalid handle.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmConfigAdapter(IntPtr hCaptureEngine, UInt32 ulIndex, CaptureCallbackDelegate CallbackFunction, IntPtr pCallerContext, NmCaptureCallbackExitMode ExitMode);
        
        /// <summary>
        /// Starts capturing live data on an existing capture engine and network adapter.
        /// </summary> 
        /// <remarks>
        /// Capture mode can be PMODE and LocalOnly.
        /// Frame callbacks are made to the NM_FRAME_CALLBACK function registered to the adapter interface
        /// using the adapter index and the NmConfigAdapter function.
        /// </remarks>
        /// <param name="hCaptureEngine">Handle to the capture engine object returned by the NmOpenCaptureEngine function.</param>
        /// <param name="ulAdapterIndex">Index of the adapter within the range returned by the NmGetAdapterCount function.</param>
        /// <param name="CaptureMode">Capture mode. See the NmAdapterCaptureMode enumeration.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: Invalid handle. <br/>
        ///     ERROR_NOT_FOUND: not found capture engine or adapter specified.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmStartCapture(IntPtr hCaptureEngine, UInt32 ulAdapterIndex, NmCaptureMode CaptureMode);

        /// <summary>
        /// Pauses the capture engine.
        /// </summary> 
        /// <remarks>
        /// This function and the NmResumeCapture function have less overhead than the NmStartCapture and the NmStopCapture functions,
        /// since they do not free all the internal objects used to attach to the interface and tracing. <br/>
        /// When you pause the engine, you are pausing the frames which enter the buffer. Therefore, there may be frames returned 
        /// to your callback while the buffer is being cleared. By default, after pausing or stopping a capture, 
        /// the NM_FRAME_CALLBACK function registered with the NmConfigAdapter function should not be called again. <br/>
        /// No new frames coming in on the wire are added to the buffer or receive callbacks. To continue receiving callbacks while
        /// frames remain in the driver buffer, set the CaptureCallbackExitMode parameter of NmConfigAdapter to NmReturnRemainFrames. <br/>
        /// Once capturing resumes after a pause, the buffer continues to be filled again, and callbacks resume.
        /// </remarks>
        /// <param name="hCaptureEngine">Handle to the capture engine returned by the NmOpenCaptureEngine function.</param>
        /// <param name="ulAdapterIndex">Index of the adapter within the range returned by the NmGetAdapterCount function.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: Invalid handle. <br/>
        ///     ERROR_INVALID_STATE: Can not pause at current state. <br/>
        ///     ERROR_NOT_FOUND: not found capture engine or adapter specified.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmPauseCapture(IntPtr hCaptureEngine, UInt32 ulAdapterIndex);

        /// <summary>
        /// resumes a capture that was previously paused by the NmPauseCapture function.
        /// </summary> 
        /// <remarks>
        /// Cannot resume after NmStopCapture is called.  The frame indication callback is no longer invoked 
        /// until NmResumeCapture method is called. <br/>
        /// Using the NmPauseCapture function and this function has less overhead than the NmStartCapture and the NmStopCapture
        /// functions, since they do not free all the internal objects used to attach to the interface and tracing. <br/>
        /// When you pause the engine, you are pausing the frames that enter the buffer. Therefore, there may be frames returned
        /// to your callback while the buffer is being cleared. <br/>
        /// By default, after pausing or stopping a capture, NM_FRAME_CALLBACK registered with the NmConfigAdapter function
        /// should not be called again. No new frames coming in on the wire are added to the buffer or receive callbacks.
        /// To continue receiving callbacks while frames remain in the driver buffer, set the CaptureCallbackExitMode parameter
        /// of NmConfigAdapter to NmReturnRemainFrames. <br/>
        /// Once capturing resumes after a pause, the buffer continues to be filled again, and callbacks resume.
        /// </remarks>
        /// <param name="hCaptureEngine">[in] The handle to the target capture engine</param>
        /// <param name="ulAdapterIndex">[in] The index number of the target adapter</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: Invalid handle. <br/> 
        ///     ERROR_INVALID_STATE: Can not resume at current state. <br/>
        ///     ERROR_NOT_FOUND: not found capture engine or adapter specified.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmResumeCapture(IntPtr hCaptureEngine, UInt32 ulAdapterIndex);

        /// <summary>
        /// Stops capturing data to the driver buffer on the specified capture engine and adapter.
        /// </summary> 
        /// <remarks>
        /// Frames may be received after the capture engine is stopped, but no new frames enter the buffer. <br/>
        /// By default, any frames that remain in the driver buffer are discarded, and no new callbacks are received by 
        /// the calling application. <br/>
        /// If the NmReturnRemainFrames flag is set in the NmConfigAdapter function, the call to this function blocks 
        /// until the last frame is processed. This ensures that the callback function is never invoked after the call
        /// to this function returns. If the callback enters an infinite loop, this call never returns. <br/>
        /// When you pause a capture for a brief time period, use the NmPauseCapture and the NmResumeCapture functions
        /// instead. These have less overhead than the NmStartCapture function and this function, since they do not free
        /// all the internal objects used to attach to the interface and tracing. <br/>
        /// By default, after pausing or stopping a capture, the NM_FRAME_CALLBACK function registered with NmConfigAdapter
        /// should not be called again. No new frames coming in on the wire are added to the buffer or receive callbacks.
        /// To continue receiving callbacks while frames remain in the driver buffer, set the CaptureCallbackExitMode
        /// parameter of NmConfigAdapter to NmReturnRemainFrames.
        /// </remarks>
        /// <param name="hCaptureEngine">Handle to the capture engine object returned by the NmOpenCaptureEngine function.</param>
        /// <param name="ulAdapterIndex">Index of the adapter within the range returned by the NmGetAdapterCount function.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: Invalid handle. <br/>
        ///     ERROR_INVALID_STATE: Can not stop at current state. <br/>
        ///     ERROR_NOT_FOUND: not found capture engine or adapter specified.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmStopCapture(IntPtr hCaptureEngine, UInt32 ulAdapterIndex);
        #endregion
      
        #region Parsing Functions
        
        /// <summary>
        /// Loads the Network Monitor Parsing Language (NPL) parser set for a parser configuration.
        /// </summary> 
        /// <remarks>
        /// A callback function is invoked to compile error and warning information. Even on a successful load,
        /// there is at least one information message stating that Sparser.npb has been successfully loaded. <br/>
        /// When you set the pFileName parameter to NULL and the NmAppendRegisteredNplSets option is set, the function
        /// automatically loads the path used by the UI.
        /// </remarks>
        /// <param name="pFileName">Full path of the parser file, normally Sparser.npl. If set to NULL, the path specified
        /// on the Parsers tab is used (on the Tools menu, click Options, then click Parsers). If no path is specified, 
        /// Network Monitor searches for a local instance of Sparser.npl.</param>
        /// <param name="ulFlags">Option flags. Currently, the following flag is supported: NmNplParserLoadingOption. Possible
        /// values are NmLoadNplOptionNone and NmAppendRegisteredNplSets. The default value is NmLoadNplOptionNone.</param>
        /// <param name="CallbackFunction">Pointer to a function to receive warnings, errors, or messages from the parser
        /// engine. See NM_NPL_PARSER_CALLBACK for details on the callback function.</param>
        /// <param name="pCallerContext">Arbitrary pointer to pass extra information to the NPL engine message callback.
        /// For example, this could be a handle to a dialog box to receive the messages.</param>
        /// <param name="phNplParser">Handle to the NPL parser object.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: Invalid handle. <br/>
        ///     ERROR_ENOUGH_MEMORY: Fail to create NPL parser object.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmLoadNplParser([MarshalAs(UnmanagedType.LPWStr)] String pFileName, 
            NmNplParserLoadingOption ulFlags, ParserCallbackDelegate CallbackFunction, IntPtr pCallerContext,
            out IntPtr phNplParser);
        
        /// <summary>
        /// Creates a frame parser configuration to configure filters and fields.
        /// </summary> 
        /// <remarks>
        /// All the frame parser features, including conversation and reassembly, must be added in the configuration before
        /// creating the frame parser. The callback for this function provides errors that occur when loading a trace, such 
        /// as parsing errors and errors flagged in the NPL. <br/>
        /// Parsing may require that conversations be enabled in the frame parser. Protocols that must maintain state
        /// information, such as HTTP, SMB, and RPC, use conversations to store that information. You may also need to
        /// parse all supporting frames for parsing to work properly.
        /// </remarks>
        /// <exception>None</exception>
        /// <param name="hNplParser">Handle to the Network Monitor Parsing Language (NPL) parser object returned by
        /// the NmLoadNplParser function.</param>
        /// <param name="CallbackFunction">Pointer to the function to receive warnings, errors, or messages from the
        /// parser engine. See NM_NPL_PARSER_CALLBACK for details on the callback function.</param>
        /// <param name="pCallerContext">Arbitrary pointer used to pass extra information to the NPL engine message
        /// callback function.</param>
        /// <param name="phFrameParserConfiguration">Handle to the frame parser configuration object.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: Invalid handle. <br/>
        ///     ERROR_ENOUGH_MEMORY: Fail to create frame parser configuration object. <br/>
        ///     ERROR_NOT_FOUND: not found specified NPL parser.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmCreateFrameParserConfiguration(IntPtr hNplParser, 
            ParserCallbackDelegate CallbackFunction, IntPtr pCallerContext, out IntPtr phFrameParserConfiguration);
 
        /// <summary>
        /// Adds a filter to the parser configuration that can be evaluated on a frame basis.
        /// </summary> 
        /// <remarks>
        /// The filter ID is used to evaluate the state of the filter on a parsed frame when you call the NmEvaluateFilter
        /// function with a parsed frame. The filter string can be any valid filter that the UI accepts. This includes 
        /// properties and conversation variables. <br/>
        /// Parsing may require that conversations be enabled in the frame parser. Protocols that must maintain state information,
        /// such as HTTP, SMB, and RPC, use conversations to store that information. You may also need to parse all supporting
        /// frames for parsing to work properly.
        /// </remarks>
        /// <param name="hFrameParserConfiguration">Handle to the frame parser configuration engine object returned by the 
        /// NmCreateFrameParserConfiguration function.</param>
        /// <param name="pFilterString">Filter string using all the elements available to the UI.</param>
        /// <param name="ulFilterId">Returned filter index in the frame parser for this filter.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: Invalid handle. <br/>
        ///     ERROR_NOT_FOUND: not found specified frame parser configuration.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmAddFilter(IntPtr hFrameParserConfiguration, 
            [MarshalAs(UnmanagedType.LPWStr)] String pFilterString, out UInt32 ulFilterId);

        /// <summary>
        /// Adds a field to the frame parser configuration and optimizes its access.
        /// </summary> 
        /// <remarks>
        /// All the fields are enumerated in the parsed frame if no field is added. The field ID is used to retrieve the field in 
        /// the parsed frame when calling the NmGetXXX functions, such as NmGetFieldValueByteArray. The caller must provide a 
        /// unique fully qualified field name, for example, TCP.Option.Ack. <br/>
        /// Parsing may require that conversations be enabled in the frame parser. Protocols that must maintain state information,
        /// such as HTTP, SMB, and RPC, use conversations to store that information. You may also need to parse all supporting
        /// frames for parsing to work properly.
        /// </remarks>
        /// <exception>None</exception>
        /// <param name="hFrameParserConfiguration">Handle to the desired frame parser configuration object returned by the
        /// NmCreateFrameParserConfiguration function.</param>
        /// <param name="pFieldString">Fully qualified path to the field.</param>
        /// <param name="ulFieldId">Returned field index in the frame parser.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: Invalid handle. <br/>
        ///     ERROR_NOT_FOUND: not found specified frame parser configuration.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmAddField(IntPtr hFrameParserConfiguration, 
            [MarshalAs(UnmanagedType.LPWStr)] String pFieldString, out UInt32 ulFieldId);

        /// <summary>
        /// Adds a property to a configuration.
        /// </summary> 
        /// <remarks>
        /// The property ID is used to retrieve the property value specified by the fully qualified property name starting 
        /// with the scope name: Global, Conversation, or Frame. <br/>
        /// To retrieve the property value, use the NmGetPropertyValueById function. <br/>
        /// If a property is not added to a frame parser configuration when the frame parser is created with optimization
        /// enabled, the property may not be available because it may not qualify with optimization.
        /// </remarks>
        /// <param name="hFrameParserConfiguration">Handle to a frame parser configuration.</param>
        /// <param name="pPropertyString">Pointer to the fully qualified name of a property. The name must have a scope
        /// prefix to indicate whether it is global or applies to a conversation or frame, for example Global.PropertyName,
        /// Conversation.PropertyName, or Frame.PropertyName. The default scope is frame. For options, see the 
        /// NmPropertyScope enumeration.</param>
        /// <param name="ulPropertyId">Pointer to the property ID.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: Invalid handle or NULL pointer. <br/>
        ///     ERROR_NOT_FOUND: not found specified frame parser configuration. <br/>
        ///     ERROR_INVALID_PARAMETER: The specified property name is invalid.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmAddProperty(IntPtr hFrameParserConfiguration, 
            [MarshalAs(UnmanagedType.LPWStr)] String pPropertyString, out UInt32 ulPropertyId);

        /// <summary>
        /// Adds protocol sequence order configurations. 
        /// </summary> 
        /// <remarks>
        /// This function is used in conjunction with NmOpenCaptureFileInOrder. Once you define how to order frames using this 
        /// call, a capture file opened rearranges the frames so that they are loaded in order. <br/>
        /// This function adds a filter to the parser configuration, in addition to other changes. Therefore, the return value
        /// of the NmGetFilterCount function is incremented by 1. <br/>
        /// When using this function, the engine is optimized so you cannot read other data fields. If you need to process the
        /// data in order, write the results to another capture file or use a different parser to get the data fields that you
        /// need to read. 
        /// </remarks>
        /// <param name="hFrameParserConfiguration">Frame parser configuration returned from the 
        /// NmCreateFrameParserConfiguration function.</param>
        /// <param name="SeqConfig">Pointer to a sequence structure defined by the NM_PROTOCOL_SEQUENCE_CONFIG structure.</param>
        /// <param name="ulConfigId">The configuration in the frame parser.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: NULL pointer. <br/>
        ///     ERROR_NOT_ENOUGH_MEMORY: Fail to allocate memory to store the configuration.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmAddSequenceOrderConfig(IntPtr hFrameParserConfiguration, 
            ref NM_PROTOCOL_SEQUENCE_CONFIG SeqConfig, out UInt32 ulConfigId);

        /// <summary>
        /// Enables reassembly for a specified protocol.
        /// </summary> 
        /// <remarks>
        /// Each protocol can provide a way to reassemble its payload. This is dependent on the Network Monitor Parsing Language (NPL)
        /// for the protocol. <br/>
        /// Currently, there are no reassembly options. You can leave this value as zero. <br/>
        /// When you enable reassembly, conversations are also enabled by default because reassembly is dependent on conversations.
        /// When you disable reassembly, conversations are not affected. <br/>
        /// Reassembly is disabled by default.
        /// </remarks>
        /// <param name="hFrameParserConfiguration">Handle to the desired frame parser configuration object returned by the 
        /// NmCreateFrameParserConfiguration function.</param>
        /// <param name="Option">Reassembly options. Currently there are none. Set this value to NmReassemblyOptionNone.</param>
        /// <param name="bEnable">Action to take: enable or disable reassembly for the desired protocol.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: Invalid handle or option. <br/>
        ///     ERROR_NOT_FOUND: not found specified frame parser configuration.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmConfigReassembly(IntPtr hFrameParserConfiguration, 
            NmReassemblyConfigOption Option, Boolean bEnable);

        /// <summary>
        /// Configures conversation options.</summary> 
        /// <remarks>
        /// Parsing may require that conversations be enabled in the frame parser. Protocols that must maintain state information,
        /// such as HTTP, SMB, and RPC, use conversations to store that information. You may also need to parse all supporting
        /// frames for parsing to work properly. <br/>
        /// When you enable conversations, only conversations are enabled. However, when you disable conversations, reassembly is
        /// also disabled. <br/>
        /// This function must be called on the frame parser configuration to get the global and conversation properties. <br/>
        /// You must enable conversations in a parser configuration before you add conversation variables or filters. Otherwise,
        /// the engine is not initialized properly and the added filters or properties that rely on conversations do not work. <br/>
        /// Conversations are disabled by default.
        /// </remarks>
        /// <param name="hFrameParserConfiguration">Handle to the target frame parser configuration object returned by the 
        /// NmCreateFrameParserConfiguration function.</param>
        /// <param name="Option">Conversation options. Currently there are none. Set this value to NmConversationOptionNone.</param>
        /// <param name="bEnable">Flag to enable conversations for the desired protocol.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: Invalid handle or option. <br/>
        ///     ERROR_NOT_FOUND: not found specified frame parser configuration.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmConfigConversation(IntPtr hFrameParserConfiguration, 
            NmConversationConfigOption Option, Boolean bEnable);

        /// <summary>
        /// Creates a frame parser with a specified parser configuration.
        /// </summary> 
        /// <remarks>
        /// With a handle to the frame parser, you can parse a raw frame with the NmParseFrame function. <br/>
        /// A frame parser object should be used to parse only data considered to be part of the same capture stream. A frame
        /// parser keeps state information, so mixing trace data from multiple unrelated capture files causes undesired results.
        /// However, using multiple frame parsers for the same data is supported. <br/>
        /// Parsing may require that conversations be enabled in the frame parser. Protocols that must maintain state information,
        /// such as HTTP, SMB, and RPC, use conversations to store that information. You may also need to parse all supporting
        /// frames for parsing to work properly. <br/>
        /// OptimizeOption explicitly specifies whether the frame parser created should be optimized. The optimization occurs 
        /// when filters, fields, or properties are added and provides better parsing performance. Once the frame parser is
        /// optimized, trying to access additional fields or properties other than those specifically added to the parser with
        /// NmAddField, NmAddFilter, or NmAddProperty produces no results. If it is not known what is needed in advance, it is best
        /// to leave the parser unoptimized. <br/>
        /// The NmGetFieldOffsetAndSize function also depends on optimization being set to NULL. Otherwise, zero is returned for
        /// both size and offset.
        /// </remarks>
        /// <param name="hFrameParserConfiguration">Handle to the capture engine object returned by the 
        /// NmCreateFrameParserConfiguration function.</param>
        /// <param name="phParser">Handle to the frame parser object.</param>
        /// <param name="OptimizeOption">Specifies the optimization setting for the frame parser to be generated. The default setting
        /// is NmParserOptimizeNone.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: Invalid handle. <br/>
        ///     ERROR_NOT_FOUND: not found specified frame parser configuration.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmCreateFrameParser(IntPtr hFrameParserConfiguration, 
            out IntPtr phParser, NmFrameParserOptimizeOption OptimizeOption);


        /// <summary>
        /// Sets the starting data type for use with the NmParseBuffer function.</summary> 
        /// <remarks>
        /// This function is used in conjunction with the NmParseBuffer function. It is useful for parsing a partial payload.
        /// For example, if you have a TCP payload, you can set the parse type to HTTP to try to parse this data as an HTTP header.
        /// </remarks>
        /// <param name="hFrameParserConfiguration">Handle to the desired frame parser configuration object returned by the
        /// NmCreateFrameParserConfiguration function.</param>
        /// <param name="StartDataTypeName">Pointer to the string that represents the starting data type.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: Invalid handle. <br/>
        ///     ERROR_NOT_FOUND: not found specified frame parser configuration.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmConfigStartDataType(IntPtr hFrameParserConfiguration, 
            [MarshalAs(UnmanagedType.LPWStr)] String StartDataTypeName);


        /// <summary>
        /// Determines the current start data type for the NmParseBuffer function.
        /// </summary> 
        /// <remarks>
        /// Unless changed, this function returns the default data type Frame. You can change the default data type for partial
        /// frame parsing with the NmConfigStartDataType function.
        /// </remarks>
        /// <param name="hFrameParserConfiguration">Handle to the desired frame parser configuration object returned by the 
        /// NmCreateFrameParserConfiguration function.</param>
        /// <param name="ulBufferLength">Length of the user-provided buffer for the data type name.</param>
        /// <param name="pBuffer">The name of the data type that the created frame parser starts with</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: Invalid handle. <br/>
        ///     ERROR_NOT_FOUND: not found specified frame parser configuration. <br/>
        ///     ERROR_INSUFFICIENT_BUFFER: The given start type name is longer than 260 characters.
        /// </returns>
        [DllImport("NmApi.Dll")]
        unsafe public static extern UInt32 NmGetStartDataType(IntPtr hFrameParserConfiguration, 
            UInt32 ulBufferLength, char* pBuffer);


        #endregion

        #region Parsed Frame Operations
        /// <summary>
        /// parses a raw frame and returns it as an object that can be used to retrieve information about that parsed frame. 
        /// </summary> 
        /// <remarks>
        /// The parsed frame contains the frame information, filter state, and data field information. When reassembly is enabled,
        /// the last fragment of the payload completing the reassembled frames is processed, and the inserted frame appears 
        /// as a reassembled raw frame. If there is no reassembled frame, INVALID_HANDLE_VALUE is returned. <br/>
        /// You must parse the frames in one capture file sequentially to make the state correct. You may have to parse frames
        /// 0 through n-1 to be able to parse frame n correctly. <br/>
        /// Parsing may require that conversations be enabled in the frame parser. Protocols that must maintain state information,
        /// such as HTTP, SMB, and RPC, use conversations to store that information. You may also need to parse all supporting
        /// frames for parsing to work properly.
        /// </remarks>
        /// <param name="hFrameParser">Handle to the frame parser object created by the NmCreateFrameParser function to parse the 
        /// specified raw frame object.</param>
        /// <param name="hRawFrame">Raw frame returned by the NM_FRAME_CALLBACK or the NmGetFrame function.</param>
        /// <param name="ulFrameNumber">Frame number to assign to the new frame.</param>
        /// <param name="Options">One of the options defined in the NmFrameParsingOption enumeration.</param>
        /// <param name="phParsedFrame">Handle containing a reference to the parsed frame.</param>
        /// <param name="phInsertedRawFrame">Handle containing a reference to the inserted raw frame, if there is one.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: Invalid handle. <br/>
        ///     ERROR_NOT_FOUND: not found specified frame parser or raw frame.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmParseFrame(IntPtr hFrameParser, IntPtr hRawFrame, UInt32 ulFrameNumber,
            NmFrameParsingOption Options, out IntPtr phParsedFrame, out IntPtr phInsertedRawFrame);

        
        /// <summary>
        /// Parses partial frame information or a user-supplied buffer.
        /// </summary> 
        /// <remarks>
        /// The data buffer contains the byte array that can be a raw frame, part of a raw frame, or any specified data. The parsed frame contains
        /// the parsed frame information. The filter state and enumeration of fields are supported. Intra-frame reassembly is not supported since it
        /// requires multiple frames and conversations that are not available in this buffered mode. <br/>
        /// Use the NmConfigStartDataType function to specify where to start parsing. For example, if your buffer contains only HTTP data, configure
        /// the start data type as HTTP, and the parser will start at that level. Be aware, however, that parsers sometimes have dependencies on 
        /// lower-layer protocols and conversations.
        /// </remarks>
        /// <param name="hParser">Handle to the frame parser object returned by the NmCreateFrameParser function.</param>
        /// <param name="DataBuffer">Pointer to the desired buffer for the parsed data.</param>
        /// <param name="ulBufferLength">Length of the provided buffer.</param>
        /// <param name="ulFrameNumber">The frame number should be used in parsing process if enabled by option flag.</param>
        /// <param name="Options">Options for parsing as defined by the NmFrameParsingOption function.</param>
        /// <param name="phParsedFrame">Handle containing a reference to the parsed frame object.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: Invalid handle. <br/>
        ///     ERROR_NOT_FOUND: not found specified frame parser or raw frame.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmParseBuffer(IntPtr hParser, Byte[] DataBuffer, UInt32 ulBufferLength,
            UInt32 ulFrameNumber, NmFrameParsingOption Options, out IntPtr phParsedFrame);

        /// <summary>
        /// Builds a raw frame from a user-provided buffer.
        /// </summary> 
        /// <remarks>
        /// The data buffer is transformed into a raw frame object so that you can enter a contrived frame into a capture file. The media type and
        /// time stamp are optional and can be set to zero. <br/>
        /// The media type is defined per frame with Network Monitor 3 capture files. See Frame Layout. These values are used to determine the type
        /// of network on which a capture occurs. Frame.npl then uses this value to determine how to initially parse a frame. You can look at 
        /// Frame.npl to determine the valid types. You can also create your own types, but you must modify Frame.npl or auto-register your custom
        /// parser so that your new media type is handled.
        /// </remarks>
        /// <param name="DataBuffer">User-provided data buffer to be converted into a raw frame.</param>
        /// <param name="ulBufferLength">Length of the user-provided buffer.</param>
        /// <param name="ulMedia">Optional media type of the new raw frame. See Frame.npl for available media types. The default value is zero.
        /// For more information, see Frame Layout.</param>
        /// <param name="ullTimeStamp">Optional time stamp of the new raw frame. The default value is zero.</param>
        /// <param name="phRawFrame">Handle to the raw frame.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: Invalid handle. <br/>
        ///     ERROR_ENOUGH_MEMORY: No space to build the new frame.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmBuildRawFrameFromBuffer(IntPtr DataBuffer, UInt32 ulBufferLength, UInt32 ulMedia,
            UInt64 ullTimeStamp, out IntPtr phRawFrame);

        /// <summary>
        /// Gets the fragment information for the specified parsed frame.
        /// </summary> 
        /// <remarks>
        /// When receiving frames, you may want to determine whether fragmentation is occurring so that you can discard all 
        /// previous frames and focus on the reassembled frame that appears with the last fragment. <br/>
        /// You cannot determine the fragment type of a raw frame. Only after you parse a frame can you determine whether
        /// it is reassembled.
        /// </remarks>
        /// <param name="hParsedFrame">Handle to the parsed frame object returned by the NmParseFrame function.</param>
        /// <param name="FragmentationInfo">Pointer to an NM_FRAGMENTATION_INFO structure.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: Invalid handle. <br/>
        ///     ERROR_NOT_FOUND: not found specified parsed frame. <br/>
        ///     ERROR_INSUFFICIENT_BUFFER: If the protocol name length is longer than the buffer in PNmReassemblyInfo struct.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmGetFrameFragmentInfo(IntPtr hParsedFrame, ref NmFragmentationInfo FragmentationInfo);

        /// <summary>
        /// Gets the number of filters that have been added to a frame parser configuration.
        /// </summary> 
        /// <remarks>
        /// If you add two filters, this function returns 2. <br/>
        /// The NmAddSequenceOrderConfig function adds a filter to the parser configuration, in addition to other changes.
        /// Therefore, the return value of this function is incremented by 1. Therefore, the count is 1 greater if you use
        /// the NmOpenCaptureFileInOrder function.
        /// </remarks>
        /// <param name="hFrameParser">Handle to the frame parser returned by the NmCreateFrameParser function.</param>
        /// <param name="ulFilterCount">Number of filters available in the frame parser.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: Invalid handle. <br/>
        ///     ERROR_NOT_FOUND: not found specified frame parser.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmGetFilterCount(IntPtr hFrameParser, out UInt32 ulFilterCount);

        /// <summary>
        /// Evaluates a filter that you added with the NmAddFilter function with the current parsed frame. 
        /// </summary> 
        /// <remarks>
        /// The PassFilter value is set to TRUE if the parsed frame passes the specified filter. <br/>
        /// Parsing may require that conversations be enabled in the frame parser. Protocols that must maintain state
        /// information, such as HTTP, SMB, and RPC, use conversations to store that information. You may also need to 
        /// parse all supporting frames for parsing to work properly.
        /// </remarks>
        /// <param name="hParsedFrame">Handle to the parsed frame object returned by the NmParseFrame function.</param>
        /// <param name="ulFilterId">Field ID returned by the NmAddFilter function.</param>
        /// <param name="bPassFilter">Pointer to BOOLEAN variable to contain the results of the test.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: Invalid handle. <br/>
        ///     ERROR_NOT_FOUND: not found specified parsed frame.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmEvaluateFilter(IntPtr hParsedFrame, UInt32 ulFilterId,
            out Boolean bPassFilter);

        /// <summary>
        /// Gets the number of fields enumerated in the specified parsed frame.
        /// </summary> 
        /// <remarks>
        /// The number of fields returned is dependent on whether or not you call the NmAddField function. If you added five 
        /// fields, for example, this function returns 5. However, if you do not add any fields, this function returns the
        /// total number of fields in the currently parsed frame. You can iterate through fields if you do not have a specific
        /// one that you are looking for. However, there is a performance price incurred, and it takes longer to parse every
        /// field. Therefore, if you know which fields you want, you get better performance by adding the fields explicitly. <br/>
        /// Parsing may require that conversations be enabled in the frame parser. Protocols that must maintain state information,
        /// such as HTTP, SMB, and RPC, use conversations to store that information. You may also need to parse all supporting 
        /// frames for parsing to work properly. <br/>
        /// This function returns the total number of fields, regardless of whether any have been added. However, the 
        /// NmGetRequestedPropertyCount function returns zero if no properties have been added.
        /// </remarks>
        /// <param name="hParsedFrame">Handle to the parsed frame object returned by the NmParseFrame function.</param>
        /// <param name="ulFieldCount">Number of fields returned in the parsed frame.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: Invalid handle. <br/>
        ///     ERROR_NOT_FOUND: not found specified parsed frame.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmGetFieldCount(IntPtr hParsedFrame, out UInt32 ulFieldCount);

        /// <summary>
        /// Gets a NM_PARSED_FIELD_INFO structure that contains information such as the offset and bit length of
        /// the requested data field.
        /// </summary> 
        /// <remarks>
        /// The pointer to field is valid until the parsed frame containing the field is closed.
        /// </remarks>
        /// <example>
        /// <code>
        ///     NmParsedFieldInfo parsedDataField = new NmParsedFieldInfo();
        ///     parsedDataField.Size = (ushort)Marshal.SizeOf(typeof(NmParsedFieldInfo));
        ///     NetmonAPI.NmGetParsedFieldInfo(hParsedFrame, 0, 0, ref parsedDataField);
        /// </code>
        /// </example>
        /// <param name="hParsedFrame">Handle to the parsed frame object returned by the NmParseFrame function.</param>
        /// <param name="ulFieldId">ID of the field returned by the NmAddField function.</param>
        /// <param name="ulOption">There are currently no options. Leave this value as zero.</param>
        /// <param name="pParsedFieldInfo">Pointer to the NM_PARSED_FIELD_INFO structure. The Size value must be
        /// initialized to the size of the structure.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: Invalid handle. <br/>
        ///     ERROR_NOT_FOUND: not found specified parsed frame or field.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmGetParsedFieldInfo(IntPtr hParsedFrame, UInt32 ulFieldId,
            UInt32 ulOption, ref NmParsedFieldInfo pParsedFieldInfo);

        /// <summary>
        /// Gets the name, data type, containing protocol, or formatted display string of the field specified by the field ID.
        /// </summary> 
        /// <remarks>
        /// BufferLength is a count of the number of elements. This is probably most useful when you are iterating through 
        /// fields to discover their names, but it can be used to get other field names, such as those containing the protocol
        /// name or the data type name. <br/>
        /// This function retrieves the name of the field, field data type name, field display string, and so on. API users must 
        /// specify parsing options in order for the API to store them in the parsed frame. For example, users must set the frame
        /// parsing option to include NmFieldDisplayStringRequired to store the display string in the parsed frame. For possible
        /// values, see the NmFrameParsingOption enumeration. <br/>
        /// Parsing may require that conversations be enabled in the frame parser. Protocols that must maintain state information,
        /// such as HTTP, SMB, and RPC, use conversations to store that information. You may also need to parse all supporting
        /// frames for parsing to work properly. <br/>
        /// Formatted display stringss can return with leading spaces so that they line up properly in the UI when using bit 
        /// fields. These spaces are part of the returned display string and can be removed by the user.
        /// </remarks>
        /// <param name="hParsedFrame">Handle to the parsed frame object returned by the NmParseFrame function.</param>
        /// <param name="ulFieldId">Handle to the parsed frame object returned by the NmParseFrame function.</param>
        /// <param name="RequestedName">Type of the name requested as described by the NmParsedFieldNames enumeration.</param>
        /// <param name="ulBufferLength">Length, in elements, of the caller-provided buffer.</param>
        /// <param name="pBuffer">Pointer to the caller-provided buffer.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: Invalid handle or NULL pointer. <br/>
        ///     ERROR_NOT_FOUND: not found specified parsed frame or field. <br/>
        ///     ERROR_INSUFFICIENT_BUFFER: If ulBufferLength is shorted than the name length.
        /// </returns>
        [DllImport("NmApi.Dll", CharSet=CharSet.Unicode ) ]
        unsafe public static extern UInt32 NmGetFieldName(IntPtr hParsedFrame, UInt32 ulFieldId, 
            NmParsedFieldNames RequestedName, UInt32 ulBufferLength, char* pBuffer);

        /// <summary>
        /// Gets the offset and size of the field specified by the field ID as returned by the NmAddField function.
        /// </summary> 
        /// <remarks>
        /// Parsing may require that conversations be enabled in the frame parser. Protocols that must maintain state 
        /// information, such as HTTP, SMB, and RPC, use conversations to store that information. You may also need 
        /// to parse all supporting frames for parsing to work properly. <br/>
        /// In order for the size and offset to be returned, optimization must be disabled when you call the 
        /// NmCreateFrameParser function.
        /// </remarks>
        /// <param name="hParsedFrame">Handle to the parsed frame object returned by the NmParseFrame function.</param>
        /// <param name="ulFieldId">The ID returned by NmAddField.</param>
        /// <param name="ulFieldOffset">Pointer to receive the field offset, in bits.</param>
        /// <param name="ulFieldSize">Pointer to receive the field size, in bits.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: Invalid handle. <br/>
        ///     ERROR_NOT_FOUND: not found specified parsed frame or field.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmGetFieldOffsetAndSize(IntPtr hParsedFrame, UInt32 ulFieldId,
            out UInt32 ulFieldOffset, out UInt32 ulFieldSize);

        /// <summary>
        /// Gets a 8-bit value from a parsed frame.
        /// </summary> 
        /// <remarks>
        /// Parsing may require that conversations be enabled in the frame parser. Protocols that must
        /// maintain state information, such as HTTP, SMB, and RPC, use conversations to store that 
        /// information. You may also need to parse all supporting frames for parsing to work properly.
        /// </remarks>
        /// <param name="hParsedFrame">Handle to the parsed frame object returned by the NmParseFrame function.</param>
        /// <param name="ulFieldId">Field ID returned by the NmAddField function.</param>
        /// <param name="ubNumber">Pointer to an 8-bit integer that receives the field value.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: Invalid handle. <br/>
        ///     ERROR_NOT_FOUND: not found specified parsed frame or field.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmGetFieldValueNumber8Bit(IntPtr hParsedFrame, UInt32 ulFieldId, out Byte ubNumber);

        /// <summary>
        /// Gets a 16-bit value from a parsed frame.
        /// </summary> 
        /// <remarks>
        /// Parsing may require that conversations be enabled in the frame parser. Protocols that must maintain state 
        /// information, such as HTTP, SMB, and RPC, use conversations to store that information. You may also need to
        /// parse all supporting frames for parsing to work properly.
        /// </remarks>
        /// <param name="hParsedFrame">Handle to the parsed frame object returned by the NmParseFrame function.</param>
        /// <param name="ulFieldId">Field ID returned by the NmAddField function.</param>
        /// <param name="uiNumber">Pointer to a 16-bit integer that receives the field value.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: Invalid handle or NULL pointer. <br/>
        ///     ERROR_NOT_FOUND: not found specified parsed frame or field.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmGetFieldValueNumber16Bit(IntPtr hParsedFrame, UInt32 ulFieldId, out UInt16 uiNumber);

        /// <summary>
        /// Gets a 32-bit value from a parsed frame.
        /// </summary> 
        /// <remarks>
        /// Parsing may require that conversations be enabled in the frame parser. Protocols that must maintain state 
        /// information, such as HTTP, SMB, and RPC, use conversations to store that information. You may also need to
        /// parse all supporting frames for parsing to work properly.
        /// </remarks>
        /// <param name="hParsedFrame">Handle to the parsed frame object returned by the NmParseFrame function.</param>
        /// <param name="ulFieldId">Field ID returned by the NmAddField function.</param>
        /// <param name="ulNumber">Pointer to a 32-bit integer that receives the field value.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: Invalid handle or NULL pointer. <br/>
        ///     ERROR_NOT_FOUND: not found specified parsed frame or field.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmGetFieldValueNumber32Bit(IntPtr hParsedFrame, UInt32 ulFieldId, out UInt32 ulNumber);

        /// <summary>
        /// Gets a 64-bit value from a parsed frame.
        /// </summary> 
        /// <remarks>
        /// Parsing may require that conversations be enabled in the frame parser. Protocols that must maintain state 
        /// information, such as HTTP, SMB, and RPC, use conversations to store that information. You may also need to
        /// parse all supporting frames for parsing to work properly.
        /// </remarks>
        /// <param name="hParsedFrame">Handle to the parsed frame object returned by the NmParseFrame function.</param>
        /// <param name="ulFieldId">Field ID returned by the NmAddField function.</param>
        /// <param name="ullNumber">Pointer to a 64-bit integer that receives the field value.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: Invalid handle or NULL pointer. <br/>
        ///     ERROR_NOT_FOUND: not found specified parsed frame or field.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmGetFieldValueNumber64Bit(IntPtr hParsedFrame, UInt32 ulFieldId, out UInt64 ullNumber);

        /// <summary>
        /// Gets a field of byte array type. Any binary field of size 3, 5, 6, 7, or greater than 8 is treated as a byte
        /// array. The sizes 2, 4, and 8 are numbers that have corresponding value retrieval functions such as
        /// NmGetFieldValueNumber32Bit.
        /// </summary> 
        /// <remarks>
        /// This function differs from the NmGetFieldInBuffer function in that it is explicitly for data types that are 
        /// described as arrays, whereas NmGetFieldInBuffer can be used to get the raw representation of any data field. <br/>
        /// Parsing may require that conversations be enabled in the frame parser. Protocols that must maintain state 
        /// information, such as HTTP, SMB, and RPC, use conversations to store that information. You may also need to parse 
        /// all supporting frames for parsing to work properly. <br/>
        /// If you are retrieving a field whose size is 1, 2, 4, or 8, you will get an error 160 (ERROR_BAD_ARGUMENTS) returned.
        /// This is because the base data type Number with sizes of 1, 2, 4, or 8 are special cases and are converted
        /// to integers of those sizes, for example, UINT8, UINT16, UINT32, and UINT64. Therefore, these sizes are considered 
        /// numbers, and not byte arrays. <br/>
        /// You can use the NmGetPartialRawFrame function with the offsets returned from the NmGetFieldOffsetAndSize function
        /// to read the information directly from the raw frame for any sizes.
        /// </remarks>
        /// <param name="hParsedFrame">Handle to the parsed frame object returned by the NmParseFrame function.</param>
        /// <param name="ulFieldId">Field ID returned by the NmAddField function.</param>
        /// <param name="ulByteLength">Length of the supplied buffer.</param>
        /// <param name="pBuffer">Pointer to a buffer that receives the field value.</param>
        /// <param name="ulReturnLength">Pointer that receives the size of the buffer returned.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: Invalid handle. <br/>
        ///     ERROR_NOT_FOUND: not found specified parsed frame or field.
        /// </returns>
        [DllImport("NmApi.Dll")]
        unsafe public static extern UInt32 NmGetFieldValueByteArray(IntPtr hParsedFrame, UInt32 ulFieldId, UInt32 ulByteLength,
            byte* pBuffer, out UInt32 ulReturnLength);

        /// <summary>
        /// Gets a string from a parsed frame.
        /// </summary> 
        /// <remarks>
        /// This function retrieves fields of string data type, either ASCII or wide-character. The returned string is always 
        /// in wide-character format, regardless of the string type on the wire. API users can determine the wire data type by
        /// calling the NmGetFieldName function with the RequestedName parameter set to NmFieldDataTypeName. The 
        /// NmDataTypeNameRequired must be specified as the parsing option to get the data type name after parsing.
        /// </remarks>
        /// <param name="hParsedFrame">Handle to the parsed frame object returned by the NmParseFrame function.</param>
        /// <param name="ulFieldId">Field ID returned by the NmAddField function.</param>
        /// <param name="ulBufferLength">Length of the supplied buffer.</param>
        /// <param name="pValueBuffer">Pointer to a buffer that receives the field value.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: Invalid handle. <br/>
        ///     ERROR_NOT_FOUND: not found specified parsed frame or field.
        /// </returns>
        [DllImport("NmApi.Dll")]
        unsafe public static extern UInt32 NmGetFieldValueString(IntPtr hParsedFrame, UInt32 ulFieldId, 
            UInt32 ulBufferLength, char* pValueBuffer);

        /// <summary>
        /// Gets a field value from a parsed frame. The values returned are in the same byte order as they 
        /// appear in the raw frame data.
        /// </summary> 
        /// <remarks>
        /// Only the content up to the buffer length is copied. Callers can use the NmGetFieldOffsetAndSize function to
        /// obtain the size before calling this function. <br/>
        /// This function returns fields in the order that they come over the wire. If the buffer is a byte array with a
        /// field offset of 10 and a length of 3, the first byte in the buffer referenced by index zero contains the 
        /// tenth byte in the raw frame. <br/>
        /// This function does not work with a container object, such as a structure or protocol. For those, use
        /// NmGetPartialRawFrame instead.
        /// </remarks>
        /// <param name="hParsedFrame">Handle to the parsed frame object returned by the NmParseFrame function.</param>
        /// <param name="ulFieldId">Handle to the parsed frame object returned by NmParseFrame.</param>
        /// <param name="ulBufferLength">Length of the caller-provided buffer.</param>
        /// <param name="pFieldBuffer">Pointer to a buffer to receive raw field data.</param>
        /// <param name="ulReturnLength">Receives the length of the buffer returned.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: Invalid handle or NULL pointer. <br/>
        ///     ERROR_NOT_FOUND: not found specified parsed frame or field. <br/>
        ///     ERROR_INSUFFICIENT_BUFFER: Not enough space in buffer, data is not copied.
        /// </returns>
        [DllImport("NmApi.Dll")]
        unsafe public static extern UInt32 NmGetFieldInBuffer(IntPtr hParsedFrame, UInt32 ulFieldId, 
            UInt32 ulBufferLength, byte* pFieldBuffer, out UInt32 ulReturnLength);

        /// <summary>
        /// Gets the number of properties added to the parser with the NmAddProperty function.
        /// </summary> 
        /// <remarks>
        /// This function returns zero unless properties have been added. <br/>
        /// The return value is the number of properties added to the frame parser so that the frame parser
        /// can be optimized not to include NPL objects independent of the added properties. A non-optimized 
        /// frame parser contains thousands of properties, and currently the API does not provide support for
        /// retrieving the total number of properties.
        /// </remarks>
        /// <param name="hFrameParser">Handle to a frame parser object.</param>
        /// <param name="ulCount">Count of properties added to the frame configuration.</param>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: Invalid handle, wrong scope or NULL pointer. <br/>
        ///     ERROR_NOT_FOUND: not found specified frame parser.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmGetRequestedPropertyCount(IntPtr hFrameParser, out UInt32 ulCount);

        /// <summary>
        /// Gets the NM_PROPERTY_INFO structure for a property specified by ID returned by the NmAddProperty function.
        /// </summary> 
        /// <remarks>
        /// If the property container type is multi-value storage or an array and the property added using NmAddProperty
        /// does not contain the key information, the value type and size may be unknown. Therefore, the caller may need
        /// to call the retrieval function, NmGetPropertyValueById or NmGetPropertyValueByName, twice. The first time,
        /// the buffer size needed is returned with the ERROR_INSUFFICIENT_BUFFER error. The correct buffer size can then
        /// be used in the second call. <br/>
        /// If the Name buffer provided is NULL, this function returns successfully, but the name is not returned. <br/>
        /// Set the Name member of the NM_PROPERTY_INFO to NULL if it is not set to a valid memory location.
        /// </remarks>
        /// <param name="hFrameParser">Handle to a frame parser configuration.</param>
        /// <param name="ulPropertyId">ID of the property returned by NmAddProperty.</param>
        /// <param name="pInfo">NM_PROPERTY_INFO structure for this ID.</param>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: Invalid handle or NULL pointer. <br/>
        ///     ERROR_NOT_FOUND: not found specified property. <br/>
        ///     NM_STATUS_API_VERSION_MISMATCHED: NM_PARSED_PROPERTY_INFO version mismatch.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmGetPropertyInfo(IntPtr hFrameParser, UInt32 ulPropertyId,
            ref NM_NPL_PROPERTY_INFO pInfo);

        /// <summary>
        /// Gets the value of a property specified by ID returned by the NmAddProperty function.
        /// </summary> 
        /// <remarks>
        /// The last two parameters, ulKeyCount and pKeyArray, are used to access properties that can be indexed.
        /// This includes multi-value storage arrays and property groups. <br/>
        /// The key for multi-value storage properties or the index for array properties must not be provided if
        /// the entire name was specified when the property was added to the frame configuration. For example, if 
        /// you add Global.NameTable$[192.168.1.1], do not also provide index information when retrieving the 
        /// property. <br/>
        /// In most cases, ulKeyCount is 1, but you can add multiple keys to access properties that are defined 
        /// as in the following NPL example.
        /// </remarks>
        /// <param name="hFrameParser">Handle to a frame parser object.</param>
        /// <param name="ulPropertyId">ID of the property returned by NmAddProperty.</param>
        /// <param name="ulBufferSize">Size of the buffer supplied, in bytes.</param>
        /// <param name="pBuffer">Pointer to a buffer for returned data.</param>
        /// <param name="ulReturnLength">Size of the data returned.</param>
        /// <param name="ulType">Value type of the returned multivalue storage property.</param>
        /// <param name="ulKeyCount">Number of keys provided.</param>
        /// <param name="pKeyArray">Key array to look up for multivalue storage properties or property groups.
        /// The C++ version of this function takes a NM_PROPERTY_STORAGE_KEY structure for this parameter. 
        /// The C# version of this function takes a CNmPropertyStorageKey structure for this parameter.</param>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: Invalid handle or NULL pointer. <br/>
        ///     ERROR_NOT_FOUND: not found specified property. <br/>
        ///     ERROR_INSUFFICIENT_BUFFER: Not enough space in buffer, data is not copied.
        /// </returns>
        [DllImport("NmApi.Dll")]
        unsafe public static extern UInt32 NmGetPropertyById(IntPtr hFrameParser, UInt32 ulPropertyId,
            UInt32 ulBufferSize, byte* pBuffer, out UInt32 ulReturnLength, out NmPropertyValueType ulType,
            UInt32 ulKeyCount, CNmPropertyStorageKey [] pKeyArray);

        /// <summary>
        /// Gets the value for a property specified by name.
        /// </summary> 
        /// <remarks>
        /// In some cases, you can access a property by name without having added it using the NmAddProperty function.
        /// If an optimized frame parser is used, the property name may not be added to the frame parser and therefore
        /// may not be available. If you are using an optimized frame parser, add the property using NmAddProperty so 
        /// that you can access it by name or ID. For more information about optimizing, see NmCreateFrameParser. <br/>
        /// The fully qualified name must be used. <br/>
        /// The key type must match the type used by the parser. <br/>
        /// The key for multi-value storage properties or the index for array properties must not be provided if the 
        /// entire name was specified when the property was added to the frame configuration. For example, if you add 
        /// Global.NameTable$[192.168.1.1], do not also provide index information when retrieving the property. <br/>
        /// Information for the size and types of keys can be obtained with the NmGetPropertyInfo function.
        /// </remarks>
        /// <param name="hFrameParser">Handle to a frame parser object.</param>
        /// <param name="pPropertyName">Fully qualified name of the property.</param>
        /// <param name="ulBufferSize">Size of the buffer supplied, in bytes.</param>
        /// <param name="pBuffer">Pointer to a buffer for returned data.</param>
        /// <param name="pulReturnLength">Size of the data returned.</param>
        /// <param name="ulType">Value type of the returned multivalue storage property.</param>
        /// <param name="ulKeyCount">Number of keys provided.</param>
        /// <param name="pKeyArray">Key array to look up for multivalue storage properties or property groups. The C++
        /// version of this function takes a NM_PROPERTY_STORAGE_KEY structure for this parameter. The C# version of
        /// this function takes a CNmPropertyStorageKey structure for this parameter.</param>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: Invalid handle or NULL pointer. <br/>
        ///     ERROR_NOT_FOUND: not found specified property. <br/>
        ///     ERROR_INSUFFICIENT_BUFFER: Not enough space in buffer, data is not copied.
        /// </returns>
        [DllImport("NmApi.Dll")]
        unsafe public static extern UInt32 NmGetPropertyByName(IntPtr hFrameParser, 
            [MarshalAs(UnmanagedType.LPWStr)] String pPropertyName, UInt32 ulBufferSize, byte* pBuffer, 
            out UInt32 pulReturnLength, out NmPropertyValueType ulType, UInt32 ulKeyCount, CNmPropertyStorageKey [] pKeyArray);

        #endregion

        #region Raw Frame Operations
        /// <summary>
        /// Gets the length of the raw frame.
        /// </summary> 
        /// <remarks>
        /// You cannot use a parsed frame handle. You must use the raw frame handle.
        /// </remarks>
        /// <param name="hFrame">Handle to the raw frame object returned by the NmGetFrame function or 
        /// by the NM_FRAME_CALLBACK function.</param>
        /// <param name="pulLength">Pointer to receive the length of the raw frame.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: Invalid handle. <br/>
        ///     ERROR_NOT_FOUND: not found specified raw frame.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmGetRawFrameLength(IntPtr hFrame, out UInt32 pulLength);

        /// <summary>
        /// Gets a pointer to the raw frame data returned from a capture file by the NmGetFrame function or 
        /// over a network from the capture engine through the NM_FRAME_CALLBACK function.
        /// </summary> 
        /// <remarks>
        /// The frame buffer is valid until the raw frame is closed with the NmCloseHandle function or 
        /// the NM_FRAME_CALLBACK terminates.
        /// </remarks>
        /// <param name="hFrame">Handle to the raw frame object returned by NmGetFrame or by NM_FRAME_CALLBACK.</param>
        /// <param name="ulLength">Length of the provided buffer.</param>
        /// <param name="pFrameBuffer">Returned pointer to the raw frame data.</param>
        /// <param name="pulReturnLength">Size of the data copied to the buffer.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: Invalid handle. <br/>
        ///     ERROR_NOT_FOUND: not found specified raw frame.
        /// </returns>
        [DllImport("NmApi.Dll")]
        unsafe public static extern UInt32 NmGetRawFrame(IntPtr hFrame, UInt32 ulLength,
            byte* pFrameBuffer, out UInt32 pulReturnLength);

        /// <summary>
        /// Gets a pointer to a specific piece of the raw frame data.
        /// </summary> 
        /// <remarks>
        /// The frame buffer is valid until the raw frame is closed with the NmCloseHandle function or
        /// NM_FRAME_CALLBACK terminates. The user must provide the buffer to be copied into.
        /// </remarks>
        /// <param name="hRawFrame">Handle to the raw frame object returned by the NmGetFrame function 
        /// or by the NM_FRAME_CALLBACK function.</param>
        /// <param name="ulFrameOffset">Offset in the raw frame from which to start.</param>
        /// <param name="ulBufferLength">Length of the user-provided buffer.</param>
        /// <param name="pFrameBuffer">Pointer to the user-provided buffer to receive the partial raw frame data.</param>
        /// <param name="pulReturnLength">Pointer to receive the size of the data copied to the buffer.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: Invalid handle. <br/>
        ///     ERROR_NOT_FOUND: not found specified raw frame.
        /// </returns>
        [DllImport("NmApi.Dll")]
        unsafe public static extern UInt32 NmGetPartialRawFrame(IntPtr hRawFrame, UInt32 ulFrameOffset,
            UInt32 ulBufferLength, byte* pFrameBuffer, out UInt32 pulReturnLength);

        /// <summary>
        /// Gets the per-frame media access type.
        /// </summary> 
        /// <remarks>
        /// This function can be used on either a raw or a parsed frame. <br/>
        /// You can capture on multiple adapters. Therefore, the MAC type for each frame is recorded.
        /// For more information, see Capture File Format.
        /// </remarks>
        /// <param name="hFrame">Handle to a raw or parsed frame object.</param>
        /// <param name="pulMacType">Pointer to receive the Machine Address Code (MAC) type.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: Invalid handle. <br/>
        ///     ERROR_INVALID_PARAMETER: hFrame is not a parsed or a raw frame handle. <br/>
        ///     ERROR_NOT_FOUND: not found specified frame.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmGetFrameMacType(IntPtr hFrame, out UInt32 pulMacType);


        /// <summary>
        /// Gets the absolute time stamp of a frame.
        /// </summary> 
        /// <remarks>
        /// This function returns the absolute time stamp, which is calculated by adding the frame offset
        /// to the capture file time stamp in the capture header. <br/>
        /// This function can be used with a raw frame or a parsed frame.
        /// </remarks>
        /// <param name="hFrame">Handle to a raw or parsed frame object.</param>
        /// <param name="pTimeStamp">Pointer to receive the 64-bit time stamp.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: Invalid handle. <br/>
        ///     ERROR_INVALID_PARAMETER: hFrame is not a parsed or a raw frame handle. <br/>
        ///     ERROR_NOT_FOUND: not found specified frame.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmGetFrameTimeStamp(IntPtr hFrame, out UInt64 pTimeStamp);

        /// <summary>
        /// Gets the frame comment title and description.
        /// </summary>
        /// <remarks>
        /// If the buffers passed in are NULL, the buffer length parameters indicate the required 
        /// length of the buffer needed to store the title and comment strings.
        /// </remarks>
        /// <param name="hFrame">Handle to a raw frame object.</param>
        /// <param name="ulCommentTitleBufferLength">Pointer to the actual byte length that corresponds to the title buffer.</param>
        /// <param name="pCommentTitleBuffer">Pointer to a caller-supplied buffer to hold the comment title.</param>
        /// <param name="ulCommentDescriptionBufferLength">Pointer to the actual byte length that corresponds to the description buffer.</param>
        /// <param name="pCommentDescriptionBuffer">Caller-supplied buffer to hold the comment description.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: Invalid handle or NULL pointer. <br/>
        ///     ERROR_NOT_FOUND: Specified parsed frame not found. <br/>
        ///     ERROR_INSUFFICIENT_BUFFER: If either of the supplied buffers is NULL. <br/>
        ///     ERROR_EMPTY: Frame comment information was not found.
        /// </returns>
        [DllImport("NmApi.Dll")]
        unsafe public static extern UInt32 NmGetFrameCommentInfo(IntPtr hFrame, ref UInt32 ulCommentTitleBufferLength,
            byte* pCommentTitleBuffer, ref UInt32 ulCommentDescriptionBufferLength, byte* pCommentDescriptionBuffer);

        #endregion

        #region Capture File Operations

        /// <summary>
        /// Creates a new Network Monitor capture file for adding frames.
        /// </summary> 
        /// <remarks>
        /// If you specify a size of zero, 20 MB is used. <br/>
        /// If you specify a size larger than the maximum size determined by MaxCaptureFileSize, 
        /// the maximum size is used instead. <br/>
        /// If you specify a size that is less than the minimum size determined by the MinCaptureFileSize
        /// member of NM_API_CONFIGURATION, the minimum size is used instead. <br/>
        /// You can close and save the capture file by calling the NmCloseHandle function.
        /// </remarks>
        /// <param name="pFileName">String containing the path of the capture file to create.</param>
        /// <param name="ulSize">Maximum size of the file, in bytes. The upper limit is 500 MB. The default 
        /// upper limit is determined by the current configuration as determined by the NmGetApiConfiguration function.</param>
        /// <param name="ulFlags">Option flags for setting capture style: wraparound or chained.</param>
        /// <param name="phCaptureFile">Handle containing a reference to the capture file object.</param>
        /// <param name="ulReturnSize">Size of the capture file, in bytes.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: NULL pointer.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmCreateCaptureFile([MarshalAs(UnmanagedType.LPWStr)] String pFileName,
            UInt32 ulSize, NmCaptureFileFlag ulFlags, out IntPtr phCaptureFile, out UInt32 ulReturnSize);

        /// <summary>
        /// Opens a Network Monitor capture file for reading.
        /// </summary> 
        /// <remarks>
        /// The file is read only. Close capture file by calling NmCloseObjHandle method.
        /// </remarks>
        /// <param name="pFileName">String containing the path of the existing capture file to open.</param>
        /// <param name="phCaptureFile">Handle containing a reference to the capture file object.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: NULL pointer. <br/>
        ///     ERROR_NOT_FOUND: not found specified file.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmOpenCaptureFile([MarshalAs(UnmanagedType.LPWStr)] String pFileName, 
            out IntPtr phCaptureFile);

        /// <summary>
        /// Opens a capture file and reorders packets based on the configuration defined by the 
        /// NmAddSequenceOrderConfig function.
        /// </summary> 
        /// <remarks>
        /// The frame in file are in the order of the sequence specified in the frame parser parameter
        /// The file is read only. Close capture file by calling NmCloseObjHandle method.
        /// </remarks>
        /// <param name="pFileName">String containing the path of the existing capture file to open.</param>
        /// <param name="pOrderParser">Pointer to a NM_ORDER_PARSER_PARAMETER structure.</param>
        /// <param name="phCaptureFile">Handle containing a reference to the capture file object.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: NULL pointer. <br/>
        ///     ERROR_NOT_FOUND: not found specified file. <br/>
        ///     ERROR_INVALID_PARAMETER: frame parser does not have sequence configuration. <br/>
        ///     ERROR_NOT_ENOUGH_MEMORY: not enough memory to build required objects. <br/>
        ///     NM_STATUS_API_VERSION_MISMATCHED: PNM_ORDER_PARSER_PARAMETER version does not match.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmOpenCaptureFileInOrder([MarshalAs(UnmanagedType.LPWStr)] String pFileName,
            ref NM_ORDER_PARSER_PARAMETER pOrderParser, out IntPtr phCaptureFile);

        /// <summary>
        /// Adds a frame to the specified capture file.
        /// </summary> 
        /// <remarks>
        /// The capture file must be opened with NmCreateCaptureFile function. <br/>
        /// A raw frame can be returned by the frame indication callback or the NmBuildRawFrameFromBuffer function. <br/>
        /// If you add frames into a capture file and the time stamp is older than the time stamp of the last frame
        /// added, the newly added frame is not given the correct time stamp.
        /// </remarks>
        /// <param name="hCaptureFile">Handle to the capture file returned by the NmCreateCaptureFile function.</param>
        /// <param name="hFrame">Handle to raw frame to be added.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: Invalid handle. <br/>
        ///     ERROR_NOT_FOUND: not found specified file or frame.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmAddFrame(IntPtr hCaptureFile, IntPtr hFrame);


        /// <summary>
        /// Gets the frame count in the specified capture file.
        /// </summary> 
        /// <param name="hCaptureFile">Handle to the capture file.</param>
        /// <param name="hFrameCount">Pointer to receive the frame count.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: Invalid handle. <br/>
        ///     ERROR_NOT_FOUND: not found specified capture file.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmGetFrameCount(IntPtr hCaptureFile, out UInt32 hFrameCount);

        /// <summary>
        /// Gets a raw frame from the capture file.
        /// </summary> 
        /// <remarks>
        /// The frame number is the index number in the capture file. The first frame starts 
        /// with an index of zero. <br/>
        /// You must free the handle returned from this call.
        /// </remarks>
        /// <param name="hCaptureFile">Handle to a capture file returned by the NmCreateCaptureFile
        /// or the NmOpenCaptureFile function.</param>
        /// <param name="ulFrameNumber">Zero-based frame number.</param>
        /// <param name="phFrame">Handle containing a reference to the raw frame object. You must 
        /// call the NmCloseHandle function to free this handle.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: Invalid handle. <br/>
        ///     ERROR_NOT_FOUND: not found specified capture file or frame.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmGetFrame(IntPtr hCaptureFile, UInt32 ulFrameNumber, out IntPtr phFrame);
        #endregion

        #region NPL Property Extension

        /// <summary>
        /// Gets the top-level conversation of the parsed frame, described by the conversation protocol name 
        /// and conversation ID.
        /// </summary> 
        /// <remarks>
        /// The parsed frame must have conversation set to TRUE. <br/>
        /// The protocol name length is returned to caller. Therefore, if the provided buffer is not large 
        /// enough, the caller can call again with the correct size of buffer.
        /// </remarks>
        /// <param name="hParsedFrame">Handle to a parsed frame object.</param>
        /// <param name="ulBufferESize">Size of the buffer for the protocol name, in wide characters.</param>
        /// <param name="pProtocolName">Pointer to the buffer for the protocol name.</param>
        /// <param name="pulProtocolNameLength">Length of the protocol name, in wide characters, not including the terminating pattern.</param>
        /// <param name="pulConversationID">ID of the top-level conversation.</param>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: Invalid handle or NULL pointer. <br/>
        ///     ERROR_INSUFFICIENT_BUFFER: Insufficient buffer space. <br/>
        ///     ERROR_NOT_FOUND: not found specified parsed frame.
        /// </returns>
        [DllImport("NmApi.Dll")]
        unsafe public static extern UInt32 NmGetTopConversation(IntPtr hParsedFrame, UInt32 ulBufferESize,
            char* pProtocolName, out UInt32 pulProtocolNameLength, out UInt32 pulConversationID);

        /// <summary>
        /// Gets the parent conversation information for the specified conversation, including 
        /// conversation protocol name and conversation ID.
        /// </summary> 
        /// <remarks>
        /// The parent protocol name length is returned to caller.  So if the provided buffer is not enough, caller
        /// Can call again with the proper sized buffer.
        /// </remarks>
        /// <param name="hParsedFrame">Handle to a frame parser.</param>
        /// <param name="ulConversationId">ID of the child conversation.</param>
        /// <param name="ulBufferESize">Size of the buffer for the parent conversation protocol name, in bytes.</param>
        /// <param name="pParentProtocolNameBuffer">Pointer to the buffer for the parent conversation protocol name.</param>
        /// <param name="ulParentProtocolNameLength">Returned length of the parent conversation protocol name.</param>
        /// <param name="ulParentConversationID">ID of the parent conversation.</param>
        /// <returns>
        ///     ERROR_SUCCESS: Operation Successful. <br/>
        ///     ERROR_BAD_ARGUMENTS: Invalid handle or NULL pointer. <br/>
        ///     ERROR_INSUFFICIENT_BUFFER: Insufficient buffer space. <br/>
        ///     ERROR_NOT_FOUND: not found specified frame parser.
        /// </returns>
        [DllImport("NmApi.Dll")]
        unsafe public static extern UInt32 NmGetParentConversation(IntPtr hParsedFrame, UInt32 ulConversationId,
            UInt32 ulBufferESize, char* pParentProtocolNameBuffer, out UInt32 ulParentProtocolNameLength,
            out UInt32 ulParentConversationID);

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\PageLoadTimeDaemon\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\NetworkMonitor3Wrapper\NetworkMonitor3Wrapper\NetworkMonitor3.cs ===
﻿using System;
using System.Text;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.ComTypes;
using Test.Common.Library.NetworkMonitor3Wrapper.Microsoft.NetworkMonitor;
using System.IO;

namespace Test.Common.Library.NetworkMonitor3Wrapper
{
    /// <summary>
    /// Represents the NETMON Wrapper. <br/>
    /// NOTE: You must have NetMon 3+ installed on your system in order
    /// to use this library.
    /// </summary>
    public class NetworkMonitor : IDisposable
    {
        //Return code constants
        private const ulong ERROR_SUCCESS = 0;
        private const ulong ERROR_NOT_FOUND = 1168;
        private const ulong ERROR_RESOURCE_NOT_AVAILABLE = 5006;

        private uint g_CaptureSize;
        private uint g_NWAdapterIndex;
        private uint g_FilterId;
        private IntPtr g_CaptureFilePointer = IntPtr.Zero;
        private IntPtr g_CaptureEnginePointer = IntPtr.Zero;
        private IntPtr g_NPLParserPointer = IntPtr.Zero;
        private IntPtr g_FrameParserConfigPointer = IntPtr.Zero;
        private IntPtr g_FrameParserPointer = IntPtr.Zero;

        private static CaptureCallbackDelegate g_CaptureDelegate;
        private static ParserCallbackDelegate g_ParserDelegate;

        private string g_CaptureFilename = String.Empty;
        private string g_FrameFilterText = String.Empty;
        private bool g_IsDisposed;

        /// <summary>
        /// Initializes a new instance of the NetworkMonitor class. <br/>
        /// NOTE: This library cannot be used in a multithreaded environment (MTA).
        /// Make sure you mark your calling program / binary as [STAThread].
        /// </summary>
        /// <param name="CaptureFilename">The name of the capture file.</param>
        /// <param name="CaptureAdapterIndex">The index of the network adapter to capture.</param>
        /// <remarks>
        /// The active network adapter index can be found out by running the following command on
        /// your machine: <br/>
        /// nmcap.exe /DisplayNetworks <br/>
        /// The command will display a list of all network adapters and their index on the machine.
        /// The active adapater is usally the one having a valid IP address.
        /// </remarks>
        public NetworkMonitor(string CaptureFilename, uint CaptureAdapterIndex)
            : this(CaptureFilename, CaptureAdapterIndex, String.Empty)
        { }

        /// <summary>
        /// Initializes a new instance of the NetworkMonitor class. <br/>
        /// NOTE: This library cannot be used in a multithreaded environment (MTA).
        /// Make sure you mark your calling program / binary as [STAThread].
        /// </summary>
        /// <param name="CaptureFilename">The name of the capture file.</param>
        /// <param name="CaptureAdapterIndex">The index of the network adapter to capture.</param>
        /// <param name="FrameFilter">
        /// The string representing the Frame filter. Pass NULL for unfiltered capture. <br/>
        /// NOTE: NetMon 3 has a bug wherein it leaks memory when we use the Frame Filter. <i>Use
        /// the Frame Filter feature with extreme caution.</i>
        /// </param>
        /// <remarks>
        /// The active network adapter index can be found out by running the following command on
        /// your machine: <br/>
        /// nmcap.exe /DisplayNetworks <br/>
        /// The command will display a list of all network adapters and their index on the machine.
        /// The active adapater is usally the one having a valid IP address.
        /// </remarks>
        public NetworkMonitor(string CaptureFilename, uint CaptureAdapterIndex, string FrameFilter)
        {
            g_NWAdapterIndex = CaptureAdapterIndex;
            g_CaptureFilename = CaptureFilename;
            g_FrameFilterText = FrameFilter;

            try
            {
                InitCapture();
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Starts the network capture.
        /// </summary>
        public void StartCapture()
        {
            uint m_ReturnCode;

            try
            {
                m_ReturnCode = NetmonAPI.NmStartCapture(g_CaptureEnginePointer,
                                                        g_NWAdapterIndex,
                                                        NmCaptureMode.LocalOnly
                                                        );

                if (m_ReturnCode != ERROR_SUCCESS)
                {
                    CaptureCleanUp();
                    throw new Exception("The capture could not be started. Error Code:" + m_ReturnCode.ToString());
                }
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Stops the network capture.
        /// </summary>
        public void StopCapture()
        {
            uint m_ReturnCode;

            try
            {
                m_ReturnCode = NetmonAPI.NmStopCapture(g_CaptureEnginePointer,
                                                       g_NWAdapterIndex);

                if (m_ReturnCode != ERROR_SUCCESS)
                    throw new Exception("The capture could not be stopped. Error Code:" + m_ReturnCode.ToString());
            }
            catch (Exception)
            {
                throw;
            }
            finally
            {
                CaptureCleanUp();
            }
        }

        /// <summary>
        /// Cleans up after the capture.
        /// </summary>
        private void CaptureCleanUp()
        {
            try
            {
                NetmonAPI.NmCloseHandle(g_CaptureEnginePointer);
                NetmonAPI.NmCloseHandle(g_CaptureFilePointer);

                //Cleanup Parser
                if (!String.IsNullOrEmpty(g_FrameFilterText))
                {
                    NetmonAPI.NmCloseHandle(g_FrameParserConfigPointer);
                    NetmonAPI.NmCloseHandle(g_NPLParserPointer);
                    NetmonAPI.NmCloseHandle(g_FrameParserPointer);
                }
            }
            catch { }
        }

        /// <summary>
        /// Initializes the capture.
        /// </summary>
        private void InitCapture()
        {
            try
            {
                if (!String.IsNullOrEmpty(g_FrameFilterText))
                    LoadFilter();
                CreateCaptureFile();
                OpenCaptureEngine();
                ConfigureNWAdapter();
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Creates the capture file.
        /// </summary>
        private void CreateCaptureFile()
        {
            uint m_ReturnCode;

            try
            {
                m_ReturnCode = NetmonAPI.NmCreateCaptureFile(g_CaptureFilename,
                                                             20000000,
                                                             NmCaptureFileFlag.WrapAround,
                                                             out g_CaptureFilePointer,
                                                             out g_CaptureSize
                                                            );
                if (m_ReturnCode != ERROR_SUCCESS)
                    throw new Exception("The capture file could not be created successfully. Error Code:" + m_ReturnCode.ToString());
            }
            catch (Exception)
            {
                throw;
            }
        }
        //TODO:Configurable capturefileflag

        /// <summary>
        /// Initializes the capture engine.
        /// </summary>
        private void OpenCaptureEngine()
        {
            uint m_ReturnCode;

            try
            {
                m_ReturnCode = NetmonAPI.NmOpenCaptureEngine(out g_CaptureEnginePointer);

                if (m_ReturnCode != ERROR_SUCCESS)
                {
                    NetmonAPI.NmCloseHandle(g_CaptureFilePointer);
                    throw new Exception("The Network Capture Engine could not be initialized successfully. Error Code:" + m_ReturnCode.ToString());
                }
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Configures the network adapter for capture.
        /// </summary>
        private void ConfigureNWAdapter()
        {
            uint m_ReturnCode;

            try
            {
                g_CaptureDelegate = new CaptureCallbackDelegate(FrameIndicationCallback);
                m_ReturnCode = NetmonAPI.NmConfigAdapter(g_CaptureEnginePointer,
                                                         g_NWAdapterIndex,
                                                         g_CaptureDelegate,
                                                         g_CaptureFilePointer,
                                                         NmCaptureCallbackExitMode.DiscardRemainFrames
                                                        );

                if (m_ReturnCode != ERROR_SUCCESS)
                {
                    NetmonAPI.NmCloseHandle(g_CaptureEnginePointer);
                    NetmonAPI.NmCloseHandle(g_CaptureFilePointer);
                    throw new Exception("The network adapter could not be configured successfully for capture. Error Code:" + m_ReturnCode.ToString());
                }
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Callback for each captured frame.
        /// </summary>
        /// <param name="hCapEng"></param>
        /// <param name="ulAdatIdx"></param>
        /// <param name="pContext"></param>
        /// <param name="hRawFrame"></param>
        private void FrameIndicationCallback(IntPtr hCapEng, UInt32 ulAdatIdx, IntPtr pContext, IntPtr hRawFrame)
        {
            uint m_ReturnCode;
            bool m_FramePassed;
            IntPtr m_ParsedFrame = IntPtr.Zero;
            IntPtr m_InsertedRawFrame = IntPtr.Zero;

            try
            {
                //Parse frame if required
                if (!String.IsNullOrEmpty(g_FrameFilterText))
                {
                    m_ReturnCode = NetmonAPI.NmParseFrame(g_FrameParserPointer,
                                                          hRawFrame,
                                                          0,
                                                          NmFrameParsingOption.None,
                                                          out m_ParsedFrame,
                                                          out m_InsertedRawFrame);

                    if (m_ReturnCode == ERROR_SUCCESS)
                    {
                        m_ReturnCode = NetmonAPI.NmEvaluateFilter(m_ParsedFrame,
                                                                  g_FilterId,
                                                                  out m_FramePassed);

                        if (m_ReturnCode != ERROR_SUCCESS)
                            m_FramePassed = false;
                    }
                    else
                        m_FramePassed = false;

                    //CleanUp
                    NetmonAPI.NmCloseHandle(m_ParsedFrame);
                    NetmonAPI.NmCloseHandle(m_InsertedRawFrame);
                    m_InsertedRawFrame = IntPtr.Zero;
                    m_ParsedFrame = IntPtr.Zero;
                }
                else
                    m_FramePassed = true;

                //Write to capture file
                if (m_FramePassed)
                    NetmonAPI.NmAddFrame(g_CaptureFilePointer, hRawFrame);
            }
            catch { }
        }

        /// <summary>
        /// Callback for the parser engine.
        /// </summary>
        /// <param name="pCallerContext"></param>
        /// <param name="ulStatusCode"></param>
        /// <param name="lpDescription"></param>
        /// <param name="ulType"></param>
        private void ParserCallback(IntPtr pCallerContext, UInt32 ulStatusCode, String lpDescription, NmCallbackMsgType ulType)
        {
            //Do nothing
            //If we use a log file at a later stage, we can capture the parser messages here and write to log.
        }

        /// <summary>
        /// Loads the specified capture filter. 
        /// </summary>
        private void LoadFilter()
        {
            uint m_ReturnCode;

            try
            {
                g_ParserDelegate = new ParserCallbackDelegate(ParserCallback);

                #region Load NPL Parser
                m_ReturnCode = NetmonAPI.NmLoadNplParser(null,
                                                                 NmNplParserLoadingOption.NmAppendRegisteredNplSets,
                                                                 g_ParserDelegate,
                                                                 IntPtr.Zero,
                                                                 out g_NPLParserPointer);
                if (m_ReturnCode != ERROR_SUCCESS)
                    throw new Exception("The NPL Parser could not be loaded. Error Code:" + m_ReturnCode.ToString());
                #endregion

                #region Create Frame Parser Configuration
                m_ReturnCode = NetmonAPI.NmCreateFrameParserConfiguration(g_NPLParserPointer,
                                                                          g_ParserDelegate,
                                                                          IntPtr.Zero,
                                                                          out g_FrameParserConfigPointer);
                if (m_ReturnCode != ERROR_SUCCESS)
                {
                    NetmonAPI.NmCloseHandle(g_NPLParserPointer);
                    throw new Exception("The frame parser configuration could not be created successfully. Error Code:" + m_ReturnCode.ToString());
                }
                #endregion

                #region Add Frame Filter
                m_ReturnCode = NetmonAPI.NmAddFilter(g_FrameParserConfigPointer,
                                                     g_FrameFilterText,
                                                     out g_FilterId);
                if (m_ReturnCode != ERROR_SUCCESS)
                {
                    NetmonAPI.NmCloseHandle(g_FrameParserConfigPointer);
                    NetmonAPI.NmCloseHandle(g_NPLParserPointer);
                    throw new Exception("The specified filter could not be added successfully. Error Code:" + m_ReturnCode.ToString());
                }
                #endregion

                #region Create Frame Parser
                m_ReturnCode = NetmonAPI.NmCreateFrameParser(g_FrameParserConfigPointer,
                                                             out g_FrameParserPointer,
                                                             NmFrameParserOptimizeOption.ParserOptimizeFull);
                if (m_ReturnCode != ERROR_SUCCESS)
                {
                    NetmonAPI.NmCloseHandle(g_FrameParserConfigPointer);
                    NetmonAPI.NmCloseHandle(g_NPLParserPointer);
                    throw new Exception("Unable to create the Frame Parser successfully. Error Code:" + m_ReturnCode.ToString());
                }
                #endregion

            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Do a proper dispose of the object releasing unmanaged objects.
        /// </summary>
        public void Dispose()
        {
            if (!g_IsDisposed)
            {
                Dispose(true);
                GC.SuppressFinalize(this);
            }
        }

        /// <summary>
        /// Destructor.
        /// </summary>
        ~NetworkMonitor()
        {
            Dispose(false);
        }

        /// <summary>
        /// Disposes the object, releasing managed and unmanaged handles.
        /// </summary>
        /// <param name="Disposing">Indicates that the object is being disposed.</param>
        protected virtual void Dispose(bool Disposing)
        {
            if (!g_IsDisposed)
            {
                if (Disposing)
                {
                    NetmonAPI.NmCloseHandle(g_CaptureFilePointer);
                    NetmonAPI.NmCloseHandle(g_CaptureEnginePointer);
                    NetmonAPI.NmCloseHandle(g_NPLParserPointer);
                    NetmonAPI.NmCloseHandle(g_FrameParserConfigPointer);
                    NetmonAPI.NmCloseHandle(g_FrameParserPointer);
                    g_CaptureDelegate = null;
                    g_ParserDelegate = null;
                }
                g_CaptureFilePointer = IntPtr.Zero;
                g_CaptureEnginePointer = IntPtr.Zero;
                g_NPLParserPointer = IntPtr.Zero;
                g_FrameParserConfigPointer = IntPtr.Zero;
                g_FrameParserPointer = IntPtr.Zero;

                g_IsDisposed = true;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\NetworkMonitor3Wrapper\NetworkMonitor3Wrapper\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("NetworkMonitor3Wrapper")]
[assembly: AssemblyDescription("")]
//[assembly: AssemblyConfiguration("")]
//[assembly: AssemblyCompany("Microsoft Corp.")]
//[assembly: AssemblyProduct("NetworkMonitor3Wrapper")]
//[assembly: AssemblyCopyright("Copyright © Microsoft Corp. 2009")]
//[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("a5b83641-e76c-4ff7-8649-6c349a2c85f5")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
//[assembly: AssemblyVersion("1.0.0.0")]
//[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\PageLoadTimeDaemon\PageLoadTimeDaemon\CaptureConfiguration.cs ===
﻿using System;
using System.Text;

namespace Test.Common.Library.PageLoadTimeDaemon
{
    /// <summary>
    /// Represents the PLT data capture configuration.
    /// </summary>
    public class CaptureConfiguration
    {
        /// <summary>
        /// The time in milliseconds to wait for a page to load in browser.
        /// </summary>
        public int PageLoadTimeOut
        {
            get;
            set;
        }

        /// <summary>
        /// Indicates whether to perform NetMon captures.
        /// </summary>
        public bool PerformNetMonCapture
        {
            get;
            set;
        }

        /// <summary>
        /// The NetMon 3 capture configuration.
        /// </summary>
        public NetMon3CaptureConfiguration NetMon3Config
        {
            get;
            set;
        }

        /// <summary>
        /// The location where the PLT reports will be stored.
        /// </summary>
        public string ReportOutputLocation
        {
            get;
            set;
        }

    }

    /// <summary>
    /// Represents the NetMon 3 capture configuration.
    /// </summary>
    public class NetMon3CaptureConfiguration
    {
        /// <summary>
        /// The network card index number to perform capture on.
        /// </summary>
        public uint NetworkAdapterIndex
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\PageLoadTimeDaemon\PageLoadTimeDaemon\ExternalToolHandler.cs ===
﻿using System;
using System.Diagnostics;
using System.Text;

namespace Test.Common.Library.PageLoadTimeDaemon
{
    /// <summary>
    /// Represents the external tool execution helper.
    /// </summary>
    internal static class ExternalToolHandler
    {
        /// <summary>
        /// Executes a program.
        /// </summary>
        /// <param name="ExecutableName">The name of the program file to execute.</param>
        /// <param name="Arguments">The command line arguments.</param>
        /// <param name="WorkingDirectory">The working directory for the executable.</param>
        /// <param name="UseWindowsShell">Indicates whether to use the windows shell to execute.</param>
        /// <returns>True if the program executed successfully, otherwise false.</returns>
        internal static bool ExecuteProgram(string ExecutableName, string Arguments, string WorkingDirectory, bool UseWindowsShell)
        {
            bool m_ExecuteOutcome = false;
            Process m_Executable = null;

            try
            {
                m_Executable = new Process();
                m_Executable.StartInfo.FileName = ExecutableName;
                if (!String.IsNullOrEmpty(Arguments))
                    m_Executable.StartInfo.Arguments = Arguments;
                m_Executable.StartInfo.UseShellExecute = UseWindowsShell;
                if (!String.IsNullOrEmpty(WorkingDirectory))
                    m_Executable.StartInfo.WorkingDirectory = WorkingDirectory;

                m_Executable.Start();
                m_Executable.WaitForExit();

                if (m_Executable.ExitCode == 0)
                    m_ExecuteOutcome = true;
            }
            catch { }

            return m_ExecuteOutcome;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\PageLoadTimeDaemon\PageLoadTimeDaemon\PLTIniContent.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;

namespace Test.Common.Library.PageLoadTimeDaemon
{
    /// <summary>
    /// Indicates the type of PLT Tests to run.
    /// </summary>
    [Flags]
    internal enum PLTType
    {
        /// <summary>
        /// Indicates PLT 1 tests.
        /// </summary>
        PLT1 = 0x01,
        /// <summary>
        /// Indicates PLT 1.2 tests.
        /// </summary>
        PLT1_2 = 0x02,
        /// <summary>
        /// Indicates PLT 2 tests.
        /// </summary>
        PLT2 = 0x04
    }

    /// <summary>
    /// Represents the PLT Ini file content.
    /// </summary>
    internal class PLTIniContent
    {
        /// <summary>
        /// The list of URLs to test.
        /// </summary>
        internal PLTTestURL[] TestURLList
        {
            get;
            set;
        }

        /// <summary>
        /// Indicates the type of PLT Tests to run.
        /// </summary>
        internal PLTType PLTTestType
        {
            get;
            set;
        }

        /// <summary>
        /// The number of iterations to run for each page.
        /// </summary>
        internal int Iterations
        {
            get;
            set;
        }

        /// <summary>
        /// The interval in milliseconds between each page load.
        /// </summary>
        internal int Interval
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Represents the PLT Test URL
    /// </summary>
    internal class PLTTestURL
    {
        /// <summary>
        /// Indicates the Test URL.
        /// </summary>
        internal string TestURL
        {
            get;
            set;
        }

        /// <summary>
        /// Indicates the Page Title of the URL.
        /// </summary>
        internal string URLPageTitle
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\PageLoadTimeDaemon\PageLoadTimeDaemon\ConfigurationReader.cs ===
﻿using System;
using System.IO;
using System.Text;
using System.Collections;
using System.Xml.Serialization;

namespace Test.Common.Library.PageLoadTimeDaemon
{
    /// <summary>
    /// Represents the configuration reader.
    /// </summary>
    internal static class ConfigurationReader
    {
        private static string g_CaptureSettingXMLFile = "CaptureSetting.xml";
        private static string g_IniHeader = "Webpage Load Test Configuration Information";

        /// <summary>
        /// Loads the PLT capture configuration from the configuration
        /// XML file.
        /// </summary>
        /// <returns>An object of CaptureConfiguration representing the configuration.</returns>
        internal static CaptureConfiguration LoadCaptureConfiguration()
        {
            CaptureConfiguration m_CaptureConfig = null;
            XmlSerializer m_DSerializer = null;

            if (!File.Exists(g_CaptureSettingXMLFile))
                throw new FileNotFoundException("The capture setting XML [" + g_CaptureSettingXMLFile + "] file does not exist.");

            try
            {
                m_DSerializer = new XmlSerializer(typeof(CaptureConfiguration));
                using (TextReader m_Reader = new StreamReader(g_CaptureSettingXMLFile))
                {
                    m_CaptureConfig = (CaptureConfiguration)m_DSerializer.Deserialize(m_Reader);
                }
            }
            catch (Exception)
            {
                throw;
            }

            return m_CaptureConfig;
        }

        /// <summary>
        /// Loads the specified Test ini file content.
        /// </summary>
        /// <param name="INIFilename">The ini filename to load.</param>
        /// <returns>An object of PLTIniContent representing the ini file content.</returns>
        internal static PLTIniContent LoadTestINIFile(string INIFilename)
        {
            StreamReader m_IniFileStream = null;
            PLTIniContent m_INIContent = null;
            ArrayList m_TestURLList = null;

            if (!File.Exists(INIFilename))
                throw new FileNotFoundException("The specified ini file does not exist.");

            try
            {
                m_IniFileStream = new StreamReader(INIFilename);

                if (m_IniFileStream.EndOfStream)
                    throw new Exception("The specified ini file does not have any content.");

                //Check the ini file header
                if (m_IniFileStream.ReadLine() != g_IniHeader)
                    throw new Exception("This is not a valid ini file.");

                //Initialize Ini Content data structure
                m_INIContent = new PLTIniContent();

                #region Read Test URLs
                m_TestURLList = new ArrayList();
                while (!m_IniFileStream.EndOfStream)
                {
                    string m_ReadLine = String.Empty;

                    m_ReadLine = m_IniFileStream.ReadLine();
                    if (m_ReadLine.StartsWith("------------"))
                        break;
                    else
                    {
                        if (!String.IsNullOrEmpty(m_ReadLine))
                        {
                            string[] m_TestURLInfo = m_ReadLine.Split(new char[] { '|' });

                            if (m_TestURLInfo.Length == 2)
                                m_TestURLList.Add(new PLTTestURL()
                                {
                                    TestURL = m_TestURLInfo[0],
                                    URLPageTitle = m_TestURLInfo[1]
                                }
                                                 );
                        }
                    }
                }
                m_INIContent.TestURLList = (PLTTestURL[])m_TestURLList.ToArray(typeof(PLTTestURL));
                #endregion

                #region Read other configurations
                while (!m_IniFileStream.EndOfStream)
                {
                    string m_ReadLine = String.Empty;

                    m_ReadLine = m_IniFileStream.ReadLine();
                    if (!String.IsNullOrEmpty(m_ReadLine))
                    {
                        string[] m_TestConfig = m_ReadLine.Split(new char[] { '=' });

                        if (m_TestConfig.Length == 2)
                        {
                            switch (m_TestConfig[0].Trim().ToLower())
                            {
                                case "nocache":
                                    if (m_TestConfig[1].Trim().ToLower() == "true")
                                        m_INIContent.PLTTestType = m_INIContent.PLTTestType | PLTType.PLT1;
                                    break;
                                case "withcookienocache":
                                    if (m_TestConfig[1].Trim().ToLower() == "true")
                                        m_INIContent.PLTTestType = m_INIContent.PLTTestType | PLTType.PLT1_2;
                                    break;
                                case "cache":
                                    if (m_TestConfig[1].Trim().ToLower() == "true")
                                        m_INIContent.PLTTestType = m_INIContent.PLTTestType | PLTType.PLT2;
                                    break;
                                case "interval":
                                    int m_Interval;
                                    if (int.TryParse(m_TestConfig[1].Trim(), out m_Interval))
                                        m_INIContent.Interval = m_Interval * 1000;
                                    else
                                        m_INIContent.Interval = 0;
                                    break;
                                case "iterations":
                                    int m_Iterations;
                                    if (int.TryParse(m_TestConfig[1].Trim(), out m_Iterations))
                                        m_INIContent.Iterations = m_Iterations;
                                    else
                                        m_Iterations = -1;
                                    break;
                            }
                        }
                    }
                }

                #endregion

                if (!ValidatePLTIniContent(m_INIContent))
                    throw new Exception("The ini content failed validation.");
            }
            catch (Exception)
            {
                throw;
            }
            return m_INIContent;
        }

        /// <summary>
        /// Validates the PLT INI Content data structure.
        /// </summary>
        /// <param name="INIContent">The PLT Ini Content object to validate.</param>
        /// <returns>True if the validation succeeds, else false.</returns>
        private static bool ValidatePLTIniContent(PLTIniContent INIContent)
        {
            bool m_IsValidated = true;

            //Check if at least 1 URL is present
            if (INIContent.TestURLList == null)
                m_IsValidated = false;
            else
            {
                if (INIContent.TestURLList.Length == 0)
                    m_IsValidated = false;
            }

            //Check if at least 1 PLT type is selected
            if ((int)INIContent.PLTTestType == 0)
                m_IsValidated = false;

            //Check if iterations > 0
            if (INIContent.Iterations <= 0)
                m_IsValidated = false;

            return m_IsValidated;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\PageLoadTimeDaemon\PageLoadTimeDaemon\PLTMonitor.cs ===
﻿using System;
using System.Text;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using System.Diagnostics;
using Test.Common.Library.HTTPWatchWrapper;
using Test.Common.Library.NetworkMonitor3Wrapper;

namespace Test.Common.Library.PageLoadTimeDaemon
{
    /// <summary>
    /// Represents the PLT Monitor.
    /// </summary>
    public class PLTMonitor : IDisposable
    {
        private CaptureConfiguration g_Config = null;
        private PLTIniContent g_INIContent = null;
        private List<PLTTestResult> g_PLT1Results = null;
        private List<PLTTestResult> g_PLT1_2Results = null;
        private List<PLTTestResult> g_PLT2Results = null;
        private bool g_StartTestInvoked;
        private bool g_IsDisposed;
        private PLTMonitorLogger g_PLTLogger = null;
        private string g_NWType = String.Empty;
        private string g_Environment = String.Empty;

        /// <summary>
        /// Initializes a new instance of the PLT Monitor class
        /// for the specified INI File.
        /// </summary>
        /// <param name="INIFilename">The INI filename.</param>
        /// <param name="NetworkType">The type of the network on which this test is run.</param>
        /// <param name="Environment">The environment in which this test is run.</param>
        public PLTMonitor(string INIFilename, string NetworkType, string Environment)
        {
            //Init Logger
            try
            {
                g_PLTLogger = new PLTMonitorLogger("PLTDaemonDebugLog.log");
                g_PLTLogger.WriteLine(PLTMonitorLogger.LogLevel.Message,
                                      "*********************************************");
            }
            catch (Exception)
            {
                throw;
            }

            //Init Daemon
            try
            {
                //Read in Config
                g_Config = ConfigurationReader.LoadCaptureConfiguration();
                g_PLTLogger.WriteLine(PLTMonitorLogger.LogLevel.Message, "Config file loaded.");

                //Read in INI Content
                g_INIContent = ConfigurationReader.LoadTestINIFile(INIFilename);
                g_PLTLogger.WriteLine(PLTMonitorLogger.LogLevel.Message, "Ini file: " + INIFilename + " loaded.");

                //Set Network type and Environment
                g_NWType = NetworkType;
                g_PLTLogger.WriteLine(PLTMonitorLogger.LogLevel.Message, "Network Type set to: " + g_NWType);
                g_Environment = Environment;
                g_PLTLogger.WriteLine(PLTMonitorLogger.LogLevel.Message, "Environemt set to : " + g_Environment);

                g_StartTestInvoked = false;
                g_IsDisposed = false;
            }
            catch (Exception Error)
            {
                g_PLTLogger.WriteLine(PLTMonitorLogger.LogLevel.Exception, "Error occured while initializing PLT daemon.");
                g_PLTLogger.WriteLine(Error);
                throw;
            }
        }

        /// <summary>
        /// Starts running the PLT Tests defined in the loaded ini file.
        /// </summary>
        public void StartPLTTests()
        {
            //Init Result objects
            g_PLT1Results = new List<PLTTestResult>();
            g_PLT1_2Results = new List<PLTTestResult>();
            g_PLT2Results = new List<PLTTestResult>();

            try
            {
                g_StartTestInvoked = true;

                //Check reports folder
                if (!Directory.Exists(g_Config.ReportOutputLocation))
                    Directory.CreateDirectory(g_Config.ReportOutputLocation);

                for (int m_Iteration = 1; m_Iteration <= g_INIContent.Iterations; m_Iteration++)
                {
                    foreach (PLTTestURL m_TestURL in g_INIContent.TestURLList)
                    {
                        string m_URL = m_TestURL.TestURL;
                        string m_PageTitle = m_TestURL.URLPageTitle;

                        g_PLTLogger.WriteLine(PLTMonitorLogger.LogLevel.Message,
                                              "Iteration#" + m_Iteration.ToString() + "-" + m_URL);
                        #region Run PLT 1 Tests
                        if ((g_INIContent.PLTTestType & PLTType.PLT1) == PLTType.PLT1)
                        {
                            PLTTestResult m_PLT1TestResult = null;

                            g_PLTLogger.WriteLine(PLTMonitorLogger.LogLevel.Message, "Running PLT 1 Tests.");
                            m_PLT1TestResult = RunPLTTest(m_URL,
                                                          m_PageTitle,
                                                          PLTType.PLT1,
                                                          m_Iteration);
                            //Add Results
                            g_PLT1Results.Add(m_PLT1TestResult);
                        }
                        #endregion

                        #region Run PLT 1_2 Tests
                        if ((g_INIContent.PLTTestType & PLTType.PLT1_2) == PLTType.PLT1_2)
                        {
                            PLTTestResult m_PLT12TestResult = null;

                            g_PLTLogger.WriteLine(PLTMonitorLogger.LogLevel.Message, "Running PLT 1.2 Tests.");

                            m_PLT12TestResult = RunPLTTest(m_URL,
                                                           m_PageTitle,
                                                           PLTType.PLT1_2,
                                                           m_Iteration);
                            //Add Results
                            g_PLT1_2Results.Add(m_PLT12TestResult);
                        }
                        #endregion

                        #region Run PLT 2 Tests
                        if ((g_INIContent.PLTTestType & PLTType.PLT2) == PLTType.PLT2)
                        {
                            PLTTestResult m_PLT2TestResult = null;

                            g_PLTLogger.WriteLine(PLTMonitorLogger.LogLevel.Message, "Running PLT 2 Tests.");
                            m_PLT2TestResult = RunPLTTest(m_URL,
                                                          m_PageTitle,
                                                          PLTType.PLT2,
                                                          m_Iteration);
                            //Add Results
                            g_PLT2Results.Add(m_PLT2TestResult);
                        }
                        #endregion
                    }
                }
            }
            catch (Exception Error)
            {
                g_PLTLogger.WriteLine(PLTMonitorLogger.LogLevel.Exception, "Error occured in ::StartPLTTests()");
                g_PLTLogger.WriteLine(Error);
                throw;
            }
        }

        /// <summary>
        /// Saves the result of the PLT Test to a CSV file.
        /// </summary>
        public void SaveResultsToCSV()
        {
            StreamWriter m_CSVWriter = null;
            string m_PLT1CSVFile = g_Config.ReportOutputLocation + "\\TestResults_PLT1.csv";
            string m_PLT1_2CSVFile = g_Config.ReportOutputLocation + "\\TestResults_PLT1_2.csv";
            string m_PLT2CSVFile = g_Config.ReportOutputLocation + "\\TestResults_PLT2.csv";

            try
            {
                if (!g_StartTestInvoked)
                    throw new Exception("The PLT Test has not yet been run.");

                #region Write PLT1 Results
                if (g_PLT1Results.Count > 0)
                {
                    m_CSVWriter = new StreamWriter(m_PLT1CSVFile, false);
                    foreach (PLTTestResult m_TestResult in g_PLT1Results)
                    {
                        m_CSVWriter.WriteLine(m_TestResult.TestTimeStamp.ToString() + "," +
                                              m_TestResult.TestURL + "," +
                                              m_TestResult.PageLoadTime.ToString() + "," +
                                              m_TestResult.Availability.ToString() + "," +
                                              m_TestResult.PageErrorCount.ToString());
                    }
                    m_CSVWriter.Close();
                    m_CSVWriter = null;
                    g_PLTLogger.WriteLine(PLTMonitorLogger.LogLevel.Message,
                                          "PLT 1 Results saved to '" + m_PLT1CSVFile + "'");
                }
                #endregion

                #region Write PLT1.2 Results
                if (g_PLT1_2Results.Count > 0)
                {
                    m_CSVWriter = new StreamWriter(m_PLT1_2CSVFile, false);
                    foreach (PLTTestResult m_TestResult in g_PLT1_2Results)
                    {
                        m_CSVWriter.WriteLine(m_TestResult.TestTimeStamp.ToString() + "," +
                                              m_TestResult.TestURL + "," +
                                              m_TestResult.PageLoadTime.ToString() + "," +
                                              m_TestResult.Availability.ToString() + "," +
                                              m_TestResult.PageErrorCount.ToString());
                    }
                    m_CSVWriter.Close();
                    m_CSVWriter = null;
                    g_PLTLogger.WriteLine(PLTMonitorLogger.LogLevel.Message,
                                          "PLT 1.2 Results saved to '" + m_PLT1_2CSVFile + "'");
                }
                #endregion

                #region Write PLT2 Results
                if (g_PLT2Results.Count > 0)
                {
                    m_CSVWriter = new StreamWriter(m_PLT2CSVFile, false);
                    foreach (PLTTestResult m_TestResult in g_PLT2Results)
                    {
                        m_CSVWriter.WriteLine(m_TestResult.TestTimeStamp.ToString() + "," +
                                              m_TestResult.TestURL + "," +
                                              m_TestResult.PageLoadTime.ToString() + "," +
                                              m_TestResult.Availability.ToString() + "," +
                                              m_TestResult.PageErrorCount.ToString());
                    }
                    m_CSVWriter.Close();
                    m_CSVWriter = null;
                    g_PLTLogger.WriteLine(PLTMonitorLogger.LogLevel.Message,
                                          "PLT 2 Results saved to '" + m_PLT2CSVFile + "'");
                }
                #endregion
            }
            catch (Exception Error)
            {
                g_PLTLogger.WriteLine(PLTMonitorLogger.LogLevel.Exception, "Error occured in ::SaveResultsToCSV()");
                g_PLTLogger.WriteLine(Error);
                throw;
            }
        }

        /// <summary>
        /// Executes the Page Load Time test on the specified URL.
        /// </summary>
        /// <param name="TestURL">The URL to test.</param>
        /// <param name="URLPageTitle">The expected title of the page.</param>
        /// <param name="TypeOfPLT">The type of PLT test to run.</param>
        /// <param name="IterationNumber">The iteration number of this test.</param>
        /// <returns>An object of PLTTestResult representing the result of the PLT Test.</returns>
        private PLTTestResult RunPLTTest(string TestURL, string URLPageTitle, PLTType TypeOfPLT, int IterationNumber)
        {
            HTTPWatcher m_HTTPMonitor = null;
            HTTPWatchLog m_HTTPWatchLog = null;
            NetworkMonitor m_NetMon = null;
            PLTTestResult m_Result = new PLTTestResult();
            string m_PLTType = "";
            bool m_IsNetMonDisposed = true;
            bool m_IsHTTPWatchDisposed = false;
            bool m_IsSuccess = false;
            int m_Attempt = 1;

            try
            {
                m_Result.TestURL = TestURL;
                switch (TypeOfPLT)
                {
                    case PLTType.PLT1:
                        m_PLTType = "_PLT1_";
                        break;
                    case PLTType.PLT1_2:
                        m_PLTType = "_PLT1_2_";
                        break;
                    case PLTType.PLT2:
                        m_PLTType = "_PLT2_";
                        break;
                }

                //Create the result folder
                if (!Directory.Exists(g_Config.ReportOutputLocation + "\\" + g_NWType + "\\" + g_Environment + "\\" + GetFolderFriendlyName(TestURL)))
                    Directory.CreateDirectory(g_Config.ReportOutputLocation + "\\" + g_NWType + "\\" + g_Environment + "\\" + GetFolderFriendlyName(TestURL));
            }
            catch (Exception)
            {
                g_PLTLogger.WriteLine(PLTMonitorLogger.LogLevel.Exception, "Error occured in ::RunPLTTest()");
                throw;
            }

            while (m_IsSuccess == false)
            {
                try
                {
                    m_HTTPMonitor = new HTTPWatcher();
                    m_IsHTTPWatchDisposed = false;

                    #region CleanUp::Outside Browser
                    if (TypeOfPLT == PLTType.PLT1 || TypeOfPLT == PLTType.PLT1_2)
                    {
                        //Clean DNS Cache
                        if (!CleanDNSCache())
                        {
                            g_PLTLogger.WriteLine(PLTMonitorLogger.LogLevel.Exception, "Clean DNS Cache failed.");
                            throw new Exception("Failed to clean DNS cache.");
                        }
                        else
                            g_PLTLogger.WriteLine(PLTMonitorLogger.LogLevel.Message, "DNS Cache cleared.");

                        //Clear cache
                        if (!ClearCache())
                        {
                            g_PLTLogger.WriteLine(PLTMonitorLogger.LogLevel.Exception, "Clear Cache failed.");
                            throw new Exception("Failed to clear cache.");
                        }
                        else
                            g_PLTLogger.WriteLine(PLTMonitorLogger.LogLevel.Message, "Cache cleared.");
                    }

                    if (TypeOfPLT == PLTType.PLT1)
                    {
                        //Clear cookies
                        if (!ClearCookies())
                        {
                            g_PLTLogger.WriteLine(PLTMonitorLogger.LogLevel.Exception, "Clear Cookies failed.");
                            throw new Exception("Failed to clear cookies.");
                        }
                        else
                            g_PLTLogger.WriteLine(PLTMonitorLogger.LogLevel.Message, "Cookies cleared.");
                    }
                    #endregion

                    #region Start Netmon Capture
                    if (g_Config.PerformNetMonCapture)
                    {
                        m_NetMon = new NetworkMonitor(g_Config.ReportOutputLocation +
                                                        "\\" +
                                                        g_NWType +
                                                        "\\" +
                                                        g_Environment +
                                                        "\\" +
                                                        GetFolderFriendlyName(TestURL) +
                                                        "\\" +
                                                        GetFolderFriendlyName(TestURL) + m_PLTType +
                                                        IterationNumber.ToString() + ".cap",
                                                      g_Config.NetMon3Config.NetworkAdapterIndex);
                        m_NetMon.StartCapture();
                        g_PLTLogger.WriteLine(PLTMonitorLogger.LogLevel.Message, "NetMon capture started.");
                        m_IsNetMonDisposed = false;
                    }
                    #endregion

                    #region Open Browser, Load Page
                    m_HTTPMonitor.OpenBrowser();
                    m_Result.TestTimeStamp = DateTime.Now;

                    #region CleanUp::Inside Browser
                    if (TypeOfPLT == PLTType.PLT1 || TypeOfPLT == PLTType.PLT1_2)
                    {
                        //Clear cache
                        m_HTTPMonitor.ClearCache();
                        g_PLTLogger.WriteLine(PLTMonitorLogger.LogLevel.Message, "Cache cleared via browser.");
                    }

                    if (TypeOfPLT == PLTType.PLT1)
                    {
                        //Clear cookies
                        m_HTTPMonitor.ClearCookies();
                        g_PLTLogger.WriteLine(PLTMonitorLogger.LogLevel.Message, "Cookies cleared via browser.");
                    }
                    #endregion

                    if (m_HTTPMonitor.NavigateTo(TestURL, (g_Config.PageLoadTimeOut / 1000)))
                    {
                        //Close Browser & get log
                        m_HTTPMonitor.CloseBrowser();
                        m_HTTPWatchLog = m_HTTPMonitor.GetHTTPWatchLog();
                        g_PLTLogger.WriteLine(PLTMonitorLogger.LogLevel.Message, "HTTPWatch log fetched.");

                        if (m_HTTPWatchLog.Pages.Count > 0)
                        {
                            m_Result.Availability = 100;
                            m_Result.PageErrorCount = m_HTTPWatchLog.Entries.Summary.Errors.Count;
                            m_Result.PageLoadTime = m_HTTPWatchLog.Entries.Summary.Time;
                            g_PLTLogger.WriteLine(PLTMonitorLogger.LogLevel.Message, "PLT info successfully added to result set.");
                        }
                        else
                        {
                            g_PLTLogger.WriteLine(PLTMonitorLogger.LogLevel.Warning, "No page information in log. Reverting to max. PLT values.");
                            m_Result = GetDefaultPLTTestResult(TestURL);
                        }
                    }
                    else
                    {
                        m_HTTPMonitor.CloseBrowser();
                        g_PLTLogger.WriteLine(PLTMonitorLogger.LogLevel.Warning, "Page navigation failed. Reverting to max. PLT values.");
                        m_Result = GetDefaultPLTTestResult(TestURL);
                    }
                    #endregion

                    #region Stop Netmon capture
                    if (g_Config.PerformNetMonCapture)
                    {
                        m_NetMon.StopCapture();
                        m_NetMon.Dispose();
                        m_NetMon = null;
                        g_PLTLogger.WriteLine(PLTMonitorLogger.LogLevel.Message, "NetMon capture stopped.");
                        m_IsNetMonDisposed = true;
                    }
                    #endregion

                    #region Save HTTPWatch Log file
                    m_HTTPMonitor.SaveLog(Directory.GetCurrentDirectory() + "\\" +
                                                  g_Config.ReportOutputLocation +
                                                  "\\" +
                                                  g_NWType +
                                                  "\\" +
                                                  g_Environment +
                                                  "\\" +
                                                  GetFolderFriendlyName(TestURL) +
                                                  "\\HTTPWatchResult" +
                                                  m_PLTType +
                                                  IterationNumber.ToString() + ".hwl");
                    g_PLTLogger.WriteLine(PLTMonitorLogger.LogLevel.Message,
                                          "HTTPWatch log file saved to '" +
                                          Directory.GetCurrentDirectory() + "\\" +
                                          g_Config.ReportOutputLocation +
                                          "\\" +
                                          g_NWType +
                                          "\\" +
                                          g_Environment +
                                          "\\" +
                                          GetFolderFriendlyName(TestURL) +
                                          "\\HTTPWatchResult" +
                                          m_PLTType +
                                          IterationNumber.ToString() + ".hwl'");
                    #endregion

                    m_HTTPMonitor.Dispose();
                    m_HTTPMonitor = null;
                    g_PLTLogger.WriteLine(PLTMonitorLogger.LogLevel.Message, "HTTPWatch disposed.");
                    m_IsHTTPWatchDisposed = true;

                    m_IsSuccess = true;

                    //Check Interval
                    if (g_INIContent.Interval > 0)
                        Thread.Sleep(g_INIContent.Interval);
                }
                catch (Exception Error)
                {
                    g_PLTLogger.WriteLine(PLTMonitorLogger.LogLevel.Exception, "Error occured in ::RunPLTTest()");
                    g_PLTLogger.WriteLine(PLTMonitorLogger.LogLevel.Exception, "Attempt # " + m_Attempt.ToString());
                    g_PLTLogger.WriteLine(Error);

                    //Dispose NetMon
                    if (!m_IsNetMonDisposed)
                    {
                        g_PLTLogger.WriteLine(PLTMonitorLogger.LogLevel.Message, "Netmon disposed.");
                        m_NetMon.Dispose();
                    }

                    //Dispose HTTPWatch
                    if (!m_IsHTTPWatchDisposed)
                    {
                        g_PLTLogger.WriteLine(PLTMonitorLogger.LogLevel.Message, "HTTPWatch disposed.");
                        m_HTTPMonitor.Dispose();
                        m_HTTPMonitor = null;
                        m_IsHTTPWatchDisposed = true;
                    }

                    ShutDownIE();
                    g_PLTLogger.WriteLine(PLTMonitorLogger.LogLevel.Warning, "IE shutdown forcibly!");
                    m_Attempt++;

                    //Retry for 3 times
                    if (m_Attempt > 3)
                    {
                        g_PLTLogger.WriteLine(PLTMonitorLogger.LogLevel.Exception,
                                                              "Unable to run PLT test after 3 attempts. Giving up ...");
                        g_PLTLogger.WriteLine(PLTMonitorLogger.LogLevel.Warning,
                                                              "Defaulting to max PLT Test Results.");
                        m_Result = GetDefaultPLTTestResult(TestURL);
                        m_IsSuccess = true;
                    }
                }
            }
            return m_Result;
        }

        /// <summary>
        /// Gets a default PLT Test Result object for the specified URL.
        /// </summary>
        /// <param name="URL">The URL that is under test.</param>
        /// <returns>An object of PLTTestResult representing the default Test Result.</returns>
        private PLTTestResult GetDefaultPLTTestResult(string URL)
        {
            return new PLTTestResult()
            {
                Availability = 0,
                PageErrorCount = 0,
                PageLoadTime = (double)(g_Config.PageLoadTimeOut / 1000),
                TestTimeStamp = DateTime.Now,
                TestURL = URL
            };
        }

        /// <summary>
        /// Gets a folder friendly name from a target URL
        /// </summary>
        /// <param name="TargetURL">The target URL.</param>
        /// <returns>A string represnting the folder friendly name.</returns>
        private string GetFolderFriendlyName(string TargetURL)
        {
            return TargetURL
                    .Trim()
                    .Replace("\\", "+")
                    .Replace("/", "+")
                    .Replace(":", "+")
                    .Replace("*", "+")
                    .Replace("?", "+")
                    .Replace("<", "+")
                    .Replace(">", "+")
                    .Replace("|", "+")
                    .Replace(".", "_")
                    .Replace("&", "_");
        }

        /// <summary>
        /// Cleans the DNS Cache.
        /// </summary>
        /// <returns>True if the operation succeeded, otherwise false.</returns>
        private bool CleanDNSCache()
        {
            try
            {
                return ExternalToolHandler.ExecuteProgram("ipconfig", "/flushdns", null, true);
            }
            catch
            {
                return false;
            }
        }

        /// <summary>
        /// Clears the browser cache.
        /// </summary>
        /// <returns>True if the operation succeeded, otherwise false.</returns>
        private bool ClearCache()
        {
            try
            {
                return ExternalToolHandler.ExecuteProgram(@"support\PLTClear.exe", "-x", null, false);
            }
            catch
            {
                return false;
            }
        }

        /// <summary>
        /// Clears all cookies.
        /// </summary>
        /// <returns>True if the operation succeeded, otherwise false.</returns>
        private bool ClearCookies()
        {
            try
            {
                return ExternalToolHandler.ExecuteProgram(@"support\PLTClear.exe", "-c", null, false);
            }
            catch
            {
                return false;
            }
        }

        /// <summary>
        /// Do a proper dispose of the object releasing created objects.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);

            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Destructor.
        /// </summary>
        ~PLTMonitor()
        {
            Dispose(false);
        }

        /// <summary>
        /// Do a proper dispose of the object releasing created objects.
        /// </summary>
        /// <param name="Disposing">Indicates that the object is being disposed.</param>
        protected virtual void Dispose(bool Disposing)
        {
            if (!g_IsDisposed)
            {
                if (Disposing)
                {
                    g_Config = null;
                    g_INIContent = null;

                    if (g_PLT1Results != null)
                    {
                        g_PLT1Results.Clear();
                        g_PLT1Results = null;
                    }
                    if (g_PLT1_2Results != null)
                    {
                        g_PLT1_2Results.Clear();
                        g_PLT1_2Results = null;
                    }
                    if (g_PLT2Results != null)
                    {
                        g_PLT2Results.Clear();
                        g_PLT2Results = null;
                    }

                    if (g_PLTLogger != null)
                    {
                        g_PLTLogger.Close();
                        g_PLTLogger = null;
                    }
                }
                g_IsDisposed = true;
            }
        }

        /// <summary>
        /// Kills IE process
        /// </summary>
        private void ShutDownIE()
        {
            Process[] m_Processes = null;

            try
            {
                m_Processes = Process.GetProcessesByName("IEXPLORE");
                if (m_Processes.Length > 0)
                {
                    foreach (Process m_IE in m_Processes)
                        m_IE.Kill();
                    Thread.Sleep(5000);
                }
                g_PLTLogger.WriteLine(PLTMonitorLogger.LogLevel.Message, "All IE instances killed.");
            }
            catch (Exception Error)
            {
                g_PLTLogger.WriteLine(PLTMonitorLogger.LogLevel.Exception, "Error occured in ::ShutDownIE()");
                g_PLTLogger.WriteLine(Error);
                //throw;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\PageLoadTimeDaemon\PageLoadTimeDaemon\PLTMonitorLogger.cs ===
﻿using System;
using System.IO;
using System.Text;

namespace Test.Common.Library.PageLoadTimeDaemon
{
    /// <summary>
    /// Represents the PLT Monitor logger.
    /// </summary>
    internal class PLTMonitorLogger
    {
        private StreamWriter g_LogFile = null;
        private readonly string G_LOGFILENAME = String.Empty;

        /// <summary>
        /// The level of the log entry being written.
        /// </summary>
        internal enum LogLevel
        {
            /// <summary>
            /// Informational message.
            /// </summary>
            Message = 1,
            /// <summary>
            /// Warning message.
            /// </summary>
            Warning = 2,
            /// <summary>
            /// Exception message.
            /// </summary>
            Exception = 3
        }

        /// <summary>
        /// Initializes a new instance of the Daemon Logger with the specified
        /// log file name.
        /// </summary>
        /// <param name="LogFileName">The name of the Log File.</param>
        internal PLTMonitorLogger(string LogFileName)
        {
            G_LOGFILENAME = LogFileName;
            try
            {
                g_LogFile = new StreamWriter(G_LOGFILENAME, true);
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Gets the name of the Log File.
        /// </summary>
        internal string LogFileName
        {
            get { return G_LOGFILENAME; }
        }

        /// <summary>
        /// Closes this log file.
        /// </summary>
        internal void Close()
        {
            try
            {
                g_LogFile.Close();
                g_LogFile = null;
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Writes a log entry to the log file with the specified
        /// Logentry level.
        /// </summary>
        /// <param name="Level">The level of the log entry being written.</param>
        /// <param name="LogEntry">The log entry to write to the log file.</param>
        internal void WriteLine(LogLevel Level, string LogEntry)
        {
            string m_TimeStamp = DateTime.Now.ToString() + " ";

            try
            {
                if (!String.IsNullOrEmpty(LogEntry))
                {
                    switch (Level)
                    {
                        case LogLevel.Warning:
                            g_LogFile.WriteLine(m_TimeStamp + "WARN: " + LogEntry);
                            break;
                        case LogLevel.Message:
                            g_LogFile.WriteLine(m_TimeStamp + "INFO: " + LogEntry);
                            break;
                        case LogLevel.Exception:
                            g_LogFile.WriteLine(m_TimeStamp + "ERROR: " + LogEntry);
                            break;
                    }
                    g_LogFile.Flush();
                }
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Writes the specified Exception to the log file.
        /// </summary>
        /// <param name="Error">The exception to write to the log file.</param>
        internal void WriteLine(Exception Error)
        {
            string m_TimeStamp = DateTime.Now.ToString() + " ";

            try
            {
                g_LogFile.WriteLine(m_TimeStamp + "ERROR: " + Error);
                g_LogFile.Flush();
            }
            catch (Exception)
            {
                throw;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\PageLoadTimeDaemon\PageLoadTimeDaemon\PLTTestResult.cs ===
﻿using System;
using System.Text;

namespace Test.Common.Library.PageLoadTimeDaemon
{
    /// <summary>
    /// Represents the result of a PLT Test.
    /// </summary>
    internal class PLTTestResult
    {
        /// <summary>
        /// The timestamp of the PLT test.
        /// </summary>
        internal DateTime TestTimeStamp
        {
            get;
            set;
        }

        /// <summary>
        /// The URL that was tested.
        /// </summary>
        internal string TestURL
        {
            get;
            set;
        }

        /// <summary>
        /// The time required to load the page.
        /// </summary>
        internal double PageLoadTime
        {
            get;
            set;
        }

        /// <summary>
        /// The number of errors on the page.
        /// </summary>
        internal int PageErrorCount
        {
            get;
            set;
        }

        /// <summary>
        /// The availability of the page. If the page loaded within the set time out, even with errors,
        /// then the page is 100% available. Otherwise it is 0% available.
        /// </summary>
        internal int Availability
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\PageLoadTimeDaemon\PageLoadTimeDaemon\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("PageLoadTimeDaemon")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
//[assembly: AssemblyCompany("Microsoft Corp.")]
//[assembly: AssemblyProduct("PageLoadTimeDaemon")]
//[assembly: AssemblyCopyright("Copyright © Microsoft Corp. 2009")]
//[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("6f9ae3c5-a054-4e3e-9065-f0d0618f14a7")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
//[assembly: AssemblyVersion("1.0.0.0")]
//[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\Titanium\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\RpsLogin\RpsEasyLogin.cs ===
﻿using System;
using System.Diagnostics;
using System.Web;
using System.Net;
using System.IO;

namespace Test.Common.Library
{
    public class RpsEasyLogin
    {
        public static string Login(string environmentName, string siteId, string returnTarget, string verb, string postData, string username, string password)
        {
            string output = string.Empty;
            string token = string.Empty;
            string uri = string.Empty;
            string[] ProxyBypass = { ".microsoft.com", ".xboxlive.com", ".xbox.com" };
            string siteUrl = string.Format("https://live.{0}.xbox.com/xweb/live/passport/setcookies.ashx", environmentName);
            returnTarget = HttpUtility.UrlEncode(returnTarget).Replace("%", "Z");
            string targetUrl = string.Format("{0}?rru={1}&wa=wsignin1.0", siteUrl, returnTarget);
            string authPolicy = "MBI";

            RpsLogin login = new RpsLogin(targetUrl, siteUrl, username, password, PassportEnvironment.INT, TargetProperty.Other, siteId, authPolicy);
            login.ImplementProxy = true;
            login.ProxyBypass = ProxyBypass;
            HttpWebRequest req = login.BuildRequest(verb, postData);
            HttpWebResponse resp = null;
            output = login.PerformRequest(req, out resp);
            return output;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\RpsLogin\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("RpsLogin")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("52fdbb5a-ffe3-4d81-bad5-6ef14dbad0f7")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\Titanium\Titanium\TestConfigFile.cs ===
﻿#define DEMO
using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Linq;
using System.Text;
using System.Xml;
using System.IO;
using TCF = Titanium.WritableTitaniumConfigFile;

namespace Titanium
{
    /// <summary>
    /// Provides safe access to a test configuration file, as well as making it visible to 
    /// the entire API. This class also interprets a test matrix to turn it into a flat 
    /// list of tests at load-time. When complete, this class will interlock with the logging 
    /// services of Titanium to make sure all loggers are at least aware of any changes that may affect them. 
    /// </summary>
    public static class TestConfigFile
    {
#if DEMO
        //with the proper #define present, TestConfigFile can
        // save snapshots of the test matrix of each suite at 
        // all three steps in the conversion process. These
        // variables help to generate unique filenames for the snapshots
        static int SuiteNum = 0;
        static string fName = "";
#endif
        #region read-only members
        /// <summary>
        /// The test suite that is currently visible to the API
        /// </summary>
        internal static TestSuite InternalSelectedSuite
        {
            get
            {
                //make sure that a suite has been selected
                if (selectedIndex < 0)
                {
                    throw new System.Exception("Error: Select a suite before accessing this property");
                }
                return testSuites.Values.ElementAt(selectedIndex);
            }
        }
        /// <summary>
        /// The number of suites in the current file
        /// </summary>
        public static int Count
        {
            get
            {
                if (internalCount < 0)
                {
                    internalCount = InternalRoot.SelectNodes("TestSuite").Count;
                }
                return internalCount;
            }
        }
        /// <summary>
        /// Gets just the filename of the current file
        /// </summary>
        public static string FileName
        {
            get
            {
                return System.IO.Path.GetFileName(fullPath);
            }
        }
        /// <summary>
        /// Gets the path and filename of the current config file
        /// </summary>
        public static string FullPath
        {
            get
            {
                return fullPath;
            }
        }
        /// <summary>
        /// Gets just the path of the current config file
        /// </summary>
        public static string Path
        {
            get
            {
                return System.IO.Path.GetDirectoryName(fullPath);
            }
        }
        #endregion
        /// <summary>
        /// Select a new suite by title - throws an exception if that suite doesn't exist
        /// </summary>
        /// <param name="suiteTitle">the title of the suite to select</param>
        public static void SelectSuite(string suiteTitle)
        {
            //find the index of the suite that has the title
            int suiteNumber = testSuites.Keys.ToList().IndexOf(suiteTitle);
            //call the base method to do the real work
            SelectSuite(suiteNumber);
        }
        /// <summary>
        /// Select a new suite by index - throws an exception if the index is out of bounds
        /// </summary>
        /// <param name="suiteNumber">the index of the suite to select</param>
        public static void SelectSuite(int suiteNumber)
        {
            //NOTE: If we're going to check for suiteNumber == selectedSuite (i.e. a command
            // to select the suite we already have), this is the place to do it
            //QUESTION: if we decide to detect and react to suiteNumber == selectedSuite, HOW 
            // should we react? Throw exception? Do nothing? Assume it was NOT a mistake and perform 
            // some of the regular functions (e.g. re-insert TitaniumOverride)?

            //Call this in case we are leaving a previously selected suite
            TLogger.LogEndSuite();
            if ((suiteNumber < 0) || (suiteNumber >= Count))
            {
                throw new System.Exception("This file does not contain the requested suite");
            }
            //update the selectedIndex - this changes the TestSuite object that InternalSelectedSuite grants access to
            selectedIndex = suiteNumber;
            //set the suite's selected test to -1, FORCING the programmer to EXPLICITLY select a test after selecting a suite
            InternalSelectedSuite.SelectNoTest();
            //update TitaniumConfig
            if (InternalSelectedSuite.GlobalInfoNode.TitaniumOverride != null)
            {
                //The selected suite has a titanium override section, so replace all the TitaniumConfig nodes with their counterparts
                UseTitaniumOverride();
            }
            else
            {
                //There's no titanium override, so tell TitaniumConfig to refresh itself from the xml
                TCF.RefreshTitaniumConfig();
            }
            //Log the selection of a suite
            TLogger.LogBeginSuite();
        }
        #region public methods
        /// <summary>
        /// Load a test config file
        /// </summary>
        /// <param name="fileNameAndPath">The path to the desired file</param>
        public static void Load(string fileNameAndPath)
        {
            //call this in case this isn't the first config file we've opened during this log
            TLogger.LogConfigFileClosed();
#if DEMO
            //initialize the tracking variables so we can store the snapshots
            // for demo purposes
            SuiteNum = 0;
            fName = fileNameAndPath;
#endif
            TestSuite tempSuiteObj;
            InternalConfigDoc = new XmlDocument();
            InternalConfigDoc.Load(@fileNameAndPath);
            internalCount = -1; //reset internal count
            //record the full path in case we need it later
            fullPath = fileNameAndPath;
            InternalRoot = InternalConfigDoc.DocumentElement;
            //select all test suite nodes
            XmlNodeList Suites = InternalRoot.SelectNodes("TestSuite");
            //initialize the collection of suites
            testSuites = new Dictionary<string, TestSuite>();
            //scan them and enter them into the dictionary as TestSuite objects
            foreach (XmlNode currentSuite in Suites)
            {
                //create a new suite object
                tempSuiteObj = new TestSuite(currentSuite);
                try
                {
                    //try to store it
                    testSuites.Add(tempSuiteObj.Title, tempSuiteObj);
#if DEMO
                    //tell the snapshot code we've moved on to a new suite
                    SuiteNum++;
#endif
                }
                catch (System.Exception ex)
                {
                    if (ex.Message.Contains("An element with the same key already exists in the System.Collections.Generic.IDictionary<TKey,TValue>"))
                    {
                        throw new System.Exception("Duplicate title exception - two suites in the same file may not have the same title: " + tempSuiteObj.Title);
                    }
                }
            }
            //set the selection to -1 so the programmer is FORCED to explicitly select a suite
            selectedIndex = -1;
#if DEMO
            //save a copy of the entire, processed config file under a new name
            // so people can see the full effect
            InternalConfigDoc.Save(fName + ".debug.xml");
#endif
            //log that we opened a file
            TLogger.LogConfigFileOpened();
        }
        #region test-matrix conversion
        /// <summary>
        /// Given a matrix node (that is, a node whose descendents contain test-case parameters),
        ///  perform the three steps necessary to convert it to a flat list of test cases. 
        /// </summary>
        /// <param name="MatrixNode">The root node of the test matrix to be processed</param>
        /// <param name="TestCaseTemplateNode">The node whose empty attributes define what parameters any given test case is to have</param>
        /// <returns>A collection of the types of descendent node encountered during the process</returns>
        public static StringCollection ConvertTestMatrix(ref XmlNode MatrixNode, XmlNode TestCaseTemplateNode)
        {
            StringCollection typeList = new StringCollection();
            //scan the matrix for different node types, like "car" and "driver"
            Pass0_BuildTypeList(ref typeList, MatrixNode);
#if DEMO
            StreamWriter x;
            if (SuiteNum < Count)
            {
                //store a snapshot of this matrix as-is.
                //The storage happens AFTER pass0, but pass0 doesnt do anything
                // visible to the matrix
                x = new StreamWriter(fName + "." + SuiteNum + ".pass0.xml");
                x.Write(MatrixNode.OuterXml);
                x.Close();
            }
#endif
            //reorder the matrix into a tree, duplicating nodes as neccessary, 
            // so that a path from any given first-order child to any given leaf
            // represents a single test case.
            Pass1_RestructureMatrix(ref MatrixNode, typeList, 0);
#if DEMO
            if (SuiteNum < Count)
            {
                //store a snapshot of the matrix after it has been converted
                // to a tree
                x = new StreamWriter(fName + "." + SuiteNum + ".pass1.xml");
                x.Write(MatrixNode.OuterXml);
                x.Close();
            }
#endif
            //Run from each first-order child out to each leaf, gathering parameters
            // for each of the represented test cases into a single node (one node per test case). 
            // Then erase the tree and replace it with the list of test case nodes.
            Pass2_ConvertMatrixToFlatList(ref MatrixNode, TestCaseTemplateNode);
#if DEMO
            if (SuiteNum < Count)
            {
                //store a snapshot of the flat list built from the tree
                x = new StreamWriter(fName + "." + SuiteNum + ".pass2.xml");
                x.Write(MatrixNode.OuterXml);
                x.Close();
            }
#endif
            return typeList;
        }
        /// <summary>
        /// Perform a depth-first traversal of all descendents of the working node and build a list
        ///  of node types in the order they were encountered. This list is necessary for further processing
        ///  of a test matrix. It is intended that the program call this function with WorkingNode = the root of the test matrix
        /// </summary>
        /// <param name="TypeList">An empty, non-null list to be populated with node types in the order they were encountered</param>
        /// <param name="WorkingNode">The root of the matrix to be scanned</param>
        public static void Pass0_BuildTypeList(ref StringCollection TypeList, XmlNode WorkingNode)
        {
            string tempType = ""; //used as a container for each node's type
            //Note - we avoid recording WorkingNode's type because we expect the first call of this function
            // to provide some sort of bracketing node (e.g. <Matrix></Matrix>) whose type is unimportant to building the test list
            foreach (XmlNode WorkerChild in WorkingNode.ChildNodes)
            {
                //get the child's type (under Xml, this is the .Name value)
                tempType = WorkerChild.Name;
                //if it isn't in the TypeList, append it
                //...unless it's a comment
                if (!TypeList.Contains(tempType) && (tempType != "#comment"))
                {
                    TypeList.Add(tempType);
                }
                //recurse, building up the type list by traversing the XML in a depth-first manner
                Pass0_BuildTypeList(ref TypeList, WorkerChild);
            }
        }

        //NOTE - we might be able to save a LOT of processing power and memory if we don't bother to store all the nodes in arrays
        //I think we could get away with just selecting each set of nodes by type as needed

        /// <summary>
        /// Rearrange and replicate the working node's descendents according to their types, such that the represented
        ///  test parameters are organized in the numbers and combinations implied in the structure of the original file.
        ///  For example, if the root node has five car-node children, followed by five driver-node children, the resulting matrix 
        ///  will contain five car-node children and each car-node will have, as its children, copies of the five driver-nodes. This 
        ///  will represent 25 tests, combining every possible car with every possible driver.
        /// </summary>
        /// <param name="WorkingNode">The root node of the test matrix to be processed</param>
        /// <param name="ListOfTypes">The list of node types - their order dictates the final arrangement of the matrix</param>
        /// <param name="IndexOfFirstType">This should be 0 to start with - it inticates which type to access from the ListOfTypes</param>
        public static void Pass1_RestructureMatrix(ref XmlNode WorkingNode, StringCollection ListOfTypes, int IndexOfFirstType)
        {
            //It's slightly wasteful to make all our arrays one size, but it makes index calculation easier later on
            int ArraySizeAndLoopStop = ListOfTypes.Count;
            int TypeCount = ArraySizeAndLoopStop - IndexOfFirstType; //tells us how many types we actually have to work with
            if (TypeCount < 1)
            {
                return; //prevents IndexOutOfBounds problems
            }
            string FirstType = ListOfTypes[IndexOfFirstType];
            #region sort the children of the working node by type
            XmlNodeList[] WorkingNodeChildren = new XmlNodeList[ArraySizeAndLoopStop];
            for (int i = IndexOfFirstType; i < ArraySizeAndLoopStop; i++)
            {
                WorkingNodeChildren[i] = WorkingNode.SelectNodes(ListOfTypes[i]);
            }
            #endregion
            XmlNodeList[] WorkingNodeGrandchildren;
            XmlNode InsertionPoint;
            //Iterate through all the children of type FirstType
            XmlNode FirstTypeChild;
            int NumFirstTypes = WorkingNodeChildren[IndexOfFirstType].Count;
            for (int i = 0; i < NumFirstTypes; i++)
            {
                FirstTypeChild = WorkingNodeChildren[IndexOfFirstType][i];
                //ensure we have a clean list of grandchildren
                WorkingNodeGrandchildren = new XmlNodeList[ArraySizeAndLoopStop];
                //for each type of grandchild, append all children of that type as new grandchildren
                for (int j = IndexOfFirstType + 1; j < ArraySizeAndLoopStop; j++)
                {
                    foreach (XmlNode AddMe in WorkingNodeChildren[j])
                    {
                        //Find the last grandchild of the specified type
                        InsertionPoint = FirstTypeChild.SelectSingleNode(ListOfTypes[j] + "[last()]");
                        //stick a copy of AddMe on after InsertionPoint, making it a new grandchild
                        FirstTypeChild.InsertAfter(AddMe.Clone(), InsertionPoint);
                    }
                }
                //recurse
                Pass1_RestructureMatrix(ref FirstTypeChild, ListOfTypes, IndexOfFirstType + 1);
            }
            //remove all children not of type FirstType
            for (int i = IndexOfFirstType + 1; i < ArraySizeAndLoopStop; i++)
            {
                foreach (XmlNode RemoveMe in WorkingNodeChildren[i])
                {
                    WorkingNode.RemoveChild(RemoveMe);
                }
            }
        }
        /// <summary>
        /// Perform a depth-first traversal of the descendents of the matrix node, gathering their attribute-values into 
        /// test-case nodes. In a properly formatted matrix, any given path from first child to leaf will provide enough 
        /// parameters for a single test case. Once all test cases are constructed, the tree is deleted and replaced with 
        /// the flat list of test cases.
        /// </summary>
        /// <param name="MatrixNode">The root node of the test matrix</param>
        /// <param name="BlankTestCaseNode">A node whose attributes represent all parameters needed for a complete test case.
        ///  All attribute-values should be blank.</param>
        public static void Pass2_ConvertMatrixToFlatList(ref XmlNode MatrixNode, XmlNode BlankTestCaseNode)
        {
            /*
             * Note: the following process may seem odd, even wasteful, but it is necessary.
             * If it is done the more natural way (i.e. building a flat list and then replacing MatrixNode with the root of that list)
             *  the connection between MatrixNode and the document node it came from will be broken.
             */
            //make a deep copy of the MatrixNode
            XmlNode CopyMatrix = MatrixNode.CloneNode(true);
            //Expunge all all comments from the copy - they cause parsing problems
            XmlNodeList CommentList = CopyMatrix.SelectNodes("//comment()");
            foreach (XmlNode Comment in CommentList)
            {
                Comment.ParentNode.RemoveChild(Comment);
            }
            //remove all children of MatrixNode
            MatrixNode.InnerXml = "";
            //use the recursive algorithm to populate FlatMatrix with child nodes that are complete test cases
            BuildFlatTestList(ref MatrixNode, CopyMatrix, BlankTestCaseNode);
        }

        /// <summary>
        /// Unlike Pass0 and Pass1, Pass2 cannot be entirely recursive, because the matrix cannot be flattened in-place. 
        /// This is the recursive helper method called by Pass2 after it has prepared everything.
        /// </summary>
        /// <param name="TestCaseRootNode">The root of the test matrix, which remains fixed</param>
        /// <param name="WorkingNode">The current node whose children and siblings we are examining</param>
        /// <param name="CurrentTestCase">The current test case we are building</param>
        static void BuildFlatTestList(ref XmlNode TestCaseRootNode, XmlNode WorkingNode, XmlNode CurrentTestCase)
        {
            int repeat;
            XmlNode CopyOfCurrentTestCase = CurrentTestCase.CloneNode(false); //no need for a deep cloning of a node that HAS no children
            try
            {
                //load the repeat attribute from the WorkingNode (if there is one)
                XmlAttribute repeatAtt = WorkingNode.Attributes["Repeat"];
                //set the repeat number
                if (repeatAtt.Value == "")
                {
                    repeat = 1;
                }
                else
                {
                    repeat = int.Parse(repeatAtt.Value);
                }
                WorkingNode.Attributes.Remove(repeatAtt); //we don't need this anymore, so remove it to prevent problems
            }
            catch (NullReferenceException)
            {
                //a null reference exception means there is no "Repeat" attribute
                //Thus, repeat 1 time
                repeat = 1;
            }
            //populate the values of any blank attributes in the test case
            foreach (XmlAttribute TestParameter in WorkingNode.Attributes)
            {
                try
                {
                    //look up that same attribute in the CopyOfCurrentTestCase - see if it is blank
                    if (CopyOfCurrentTestCase.Attributes[TestParameter.Name].Value == "")
                    {
                        //it is empty, so fill it
                        CopyOfCurrentTestCase.Attributes[TestParameter.Name].Value = TestParameter.Value;
                    }
                }
                catch (NullReferenceException)
                {
                    throw new System.Exception("Null reference when attempting to process test matrix - check your sample node's attribute names");
                }
            }
            //now scan the Test Case and see if any of its attributes still have empty values
            bool AllValuesFilled = true;
            foreach (XmlAttribute TestParameter in CopyOfCurrentTestCase.Attributes)
            {
                if (TestParameter.Value == "")
                {
                    AllValuesFilled = false; //any empty attribute falsifies the claim that the test case is filled
                }
            }
            if (AllValuesFilled)
            {
                //append N copies of our local copy of the current test case to the list of tests, where N = repeat
                for (int i = 0; i < repeat; i++)
                {
                    TestCaseRootNode.AppendChild(CopyOfCurrentTestCase.CloneNode(false));
                }
                return;
            }
            else
            {
                //use this node and all children to build test case nodes - repeat this operation repeat times
                for (int i = 0; i < repeat; i++)
                {
                    foreach (XmlNode WorkingNodeChild in WorkingNode.ChildNodes)
                    {
                        BuildFlatTestList(ref TestCaseRootNode, WorkingNodeChild, CopyOfCurrentTestCase);
                    }
                }
            }
        }
        #endregion
        #endregion
        #region private members
        //the XmlDocument object used to read the config file
        static XmlDocument InternalConfigDoc = null;
        //a shortcut to the document's document-element
        static XmlNode InternalRoot = null;
        //the collection of test cases
        static Dictionary<string, TestSuite> testSuites;
        //the private variable that tracks which suite is selected
        static int selectedIndex = 0;
        //the private variable that stores the full path to the config file
        static string fullPath = "";
        //allows us to give an accurate count from the moment we load a config file
        static int internalCount = -1;
        /// <summary>
        /// This overwrites all the relevant nodes in the Titanium config
        /// </summary>
        private static void UseTitaniumOverride()
        {
            XmlNode ImportedReplacement;
            foreach (XmlNode replacement in InternalSelectedSuite.GlobalInfoNode.TitaniumOverride.ChildNodes)
            {
                //Import this node into the TitaniumConfig doc
                ImportedReplacement = TCF.TConfigXmlDoc.ImportNode(replacement, true);
                //find the node with the same name as replacement, then replace it
                TCF.Root.ReplaceChild(ImportedReplacement, TCF.Root.SelectSingleNode(ImportedReplacement.Name));
            }
        }
        #endregion
        #region public static access-classes
        /// <summary>
        /// Allows access to the suite currently visible to the API
        /// </summary>
        public static class SelectedSuite
        {
            /// <summary>
            /// The title of the suite (guarenteed unique with a given config file)
            /// </summary>
            public static string SelectedSuiteTitle
            {
                get
                {
                    return InternalSelectedSuite.Title;
                }
            }
            /// <summary>
            /// The derived list of node-types from this suite's matrix
            /// </summary>
            public static StringCollection SelectedTypeList
            {
                get
                {
                    return InternalSelectedSuite.TypeList;
                }
            }
            /// <summary>
            /// The global info node of the currently selected suite
            /// </summary>
            public static GlobalInfoNodeWrapper SelectedGlobalInfoNode
            {
                get
                {
                    return InternalSelectedSuite.GlobalInfoNode;
                }
            }
            /// <summary>
            /// A way of selecting a new test for the API
            /// </summary>
            /// <param name="trialNum">the current trial (can be anything from 0 to +MaxInt32)</param>
            public static void SelectTest(int trialNum)
            {
                //select the requested test from the internally selected suite
                InternalSelectedSuite.SelectTest(trialNum);
            }
            /// <summary>
            /// The number of test cases in the currently selected suite
            /// </summary>
            public static int Count
            {
                get
                {
                    return InternalSelectedSuite.Count;
                }
            }
            /// <summary>
            /// The index of SelectedTest - this differs from Trial in that it may only be a number from 0 to (number-of-tests - 1)
            /// </summary>
            public static int SelectedTestIndex
            {
                get
                {
                    return InternalSelectedSuite.SelectedIndex;
                }
            }
            /// <summary>
            /// The current trial number (the number last used to select a test). This differs from SelectedTestIndex in that it may be any number from 0 to +MaxInt32
            /// </summary>
            public static int Trial
            {
                get
                {
                    return InternalSelectedSuite.Trial;
                }
            }
            /// <summary>
            /// Allows access to the test currently visible to the API
            /// </summary>
            public static class SelectedTest
            {
                /// <summary>
                /// Read a test parameter from the current test case by name
                /// </summary>
                /// <param name="paramName">the name of the desired parameter</param>
                /// <returns>the value of the reqested parameter</returns>
                public static string ReadNamedParameter(string paramName)
                {
                    return InternalSelectedSuite.SelectedTest[paramName];
                }
                /// <summary>
                /// Read a test parameter from the current test case by number
                /// </summary>
                /// <param name="paramNum">the number of the desired parameter</param>
                /// <returns>the value of the reqested parameter</returns>
                public static string ReadNumberedParameter(int paramNum)
                {
                    return InternalSelectedSuite.SelectedTest[paramNum];
                }
                public static XmlNode RawTestCase
                {
                    get
                    {
                        return InternalSelectedSuite.SelectedTest.RawXmlTestCase;
                    }
                }
            }
        }
        #endregion
    }
    /// <summary>
    /// A class to make it easier to access the standard values in a GlobalInfoNode
    /// </summary>
    public class GlobalInfoNodeWrapper
    {
        public GlobalInfoNodeWrapper(XmlNode GlobalInfoNode)
        {
            Root = GlobalInfoNode;
        }
        /// <summary>
        /// The number of tests to run from this suite's matrix.
        /// </summary>
        public int ScheduledRuns
        {
            get
            {
                return int.Parse(Root["ScheduledRuns"].InnerText);
            }
        }
        /// <summary>
        /// The node that serves as a template for all test cases in the matrix
        /// </summary>
        public XmlNode TestCaseTemplate
        {
            get
            {
                return (Root["TemplateNode"])["TestCase"];
            }
        }
        /// <summary>
        /// Indicates the test parameter whose value may be used as a test name. 
        /// May be left blank.
        /// </summary>
        public string TestNameParameterName
        {
            get
            {
                return Root["TestNameParameterName"].InnerText;
            }
        }
        /// <summary>
        /// The node containing parameters that override their counterparts in
        /// TitaniumConfig.xml
        /// </summary>
        public XmlNode TitaniumOverride
        {
            get
            {
                return Root["TitaniumOverride"];
            }
            protected set
            {
                if (TitaniumOverride != null)
                {
                    Root.ReplaceChild(value, TitaniumOverride);
                }
            }
        }
        /// <summary>
        /// The root of the GlobalInfoNode
        /// </summary>
        public readonly XmlNode Root = null;
    }

    /// <summary>
    /// Basically a wrapper for the TestSuite node that makes it easier to access 
    /// important data from the node and its children.
    /// </summary>
    internal class TestSuite
    {

        #region read-only variables
        /// <summary>
        /// The derived list of node-types from this suite's matrix
        /// </summary>
        public StringCollection TypeList { get; protected set; }
        /// <summary>
        /// The root node of this test suite (the TestSuite node)
        /// </summary>
        public XmlNode Root { get; protected set; }
        /// <summary>
        /// The title of this test suite - titles are guarenteed unique
        ///  within the scope of a single file
        /// </summary>
        public string Title
        {
            get
            {
                return Root.Attributes["Title"].Value;
            }
        }
        #region GlobalInfoNode stuff
        /// <summary>
        /// The GlobalInfoNode as an easy-access wrapper
        /// </summary>
        public readonly GlobalInfoNodeWrapper GlobalInfoNode;
        /// <summary>
        /// The GlobalInfoNode as raw XML
        /// </summary>
        public XmlNode GlobalInfoNodeAsXML
        {
            get
            {
                return GlobalInfoNode.Root;
            }
        }
        #endregion
        /// <summary>
        /// The number of test cases in the current suite
        /// </summary>
        public int Count
        {
            get
            {
                return Matrix.ChildNodes.Count;
            }
        }
        /// <summary>
        /// The current trial number (the number last used to select a test). 
        /// This differs from SelectedIndex in that it may be any number from 
        /// 0 to +MaxInt32
        /// </summary>
        public int Trial { get; protected set; }
        /// <summary>
        /// The index of SelectedTest - this differs from Trial in that it may 
        /// only be a number from 0 to (number-of-tests - 1)
        /// </summary>
        public int SelectedIndex { get; protected set; }
        /// <summary>
        /// The test case currently visible to the API
        /// </summary>
        public TestCase SelectedTest
        {
            get
            {
                if (SelectedIndex < 0)
                {
                    throw new System.Exception("ERROR: Select a test before accessing this property");
                }
                return testCases[SelectedIndex];
            }
        }
        /// <summary>
        /// Change the selected test case. Note: the trialNum may be
        ///  anything from 0 to +MaxInt32; the test case selected will be
        ///  trialNum % Count
        /// </summary>
        /// <param name="index">the trial number - may be anything from 0 to +MaxInt32</param>
        /// <returns></returns>
        public TestCase this[int trialNum]
        {
            get
            {
                //Call this in case we're leaving a previously selected test behind
                TLogger.LogEndTest();
                //record the trial#
                Trial = trialNum;
                //update the SelectedIndex
                SelectedIndex = trialNum % Count;
                //Log the selection of a new test
                TLogger.LogBeginTest();
                return testCases[SelectedIndex];
            }
        }
        /// <summary>
        /// A way of selecting a new test for the API
        /// </summary>
        /// <param name="trialNum">the current trial (can be anything from 0 to +MaxInt32)</param>
        /// <returns>the newly selected test case</returns>
        public TestCase SelectTest(int trialNum)
        {
            return this[trialNum];
        }
        /// <summary>
        /// Create a new test suite from a TestSuite node
        /// </summary>
        /// <param name="SuiteRoot">the xml node from which to derive the suite</param>
        public TestSuite(XmlNode SuiteRoot)
        {
            //initialize the root
            this.Root = SuiteRoot;
            //initialize the TestCase list
            testCases = new List<TestCase>();
            //initialize the GlobalInfoNode
            GlobalInfoNode = new GlobalInfoNodeWrapper(Root["GlobalInfoNode"]);
            //create a temporary matrix
            XmlNode tempMatrix = Matrix.CloneNode(true);
            //flatten the matrix and save the returned TypeList
            TypeList = TestConfigFile.ConvertTestMatrix(ref tempMatrix, this.GlobalInfoNode.TestCaseTemplate);
            //replace the original matrix with the flattened one
            Matrix = tempMatrix;
            //declare a temporary variable we can use to create test cases
            TestCase tempCase;
            foreach (XmlNode testCaseNode in Matrix.ChildNodes)
            {
                //create a new test case object
                tempCase = new TestCase(testCaseNode);
                //store it
                testCases.Add(tempCase);
            }
            //clense the TitaniumOverride (if any) of non-overridable nodes
            if (GlobalInfoNode.TitaniumOverride != null)
            {
                XmlNode IllegalNode = null;
                foreach (string offLimitsType in TCF.NonOverridableNodes)
                {
                    //try to find the illegal node
                    IllegalNode = GlobalInfoNode.TitaniumOverride[offLimitsType];
                    if (IllegalNode != null)
                    {
                        GlobalInfoNode.TitaniumOverride.RemoveChild(IllegalNode);
                    }
                }
            }
            //set this to -1 to FORCE programmers to explicitly select a test the first time
            SelectedIndex = -1;
        }
        #endregion
        #region internal members
        /// <summary>
        /// Sets the index of the test matrix to -1 in order to indicate that no 
        /// test has been explicitly selected yet - called by SelectSuite
        /// </summary>
        internal void SelectNoTest()
        {
            //set this to -1 to FORCE programmers to explicitly select a test after selecting a suite
            SelectedIndex = -1;
        }
        #endregion
        #region private members
        protected XmlNode Matrix
        {
            get
            {
                return Root["TestMatrix"];
            }
            set
            {
                Root.ReplaceChild(value, Matrix);
            }
        }
        protected List<TestCase> testCases;
        #endregion
    }
    /// <summary>
    /// A wrapper class to make the Xml values of a test case node easier to access
    /// </summary>
    internal class TestCase
    {
        #region pulic members
        /// <summary>
        /// The root (and only) node of the test case
        /// </summary>
        public XmlNode RawXmlTestCase { get; protected set; }
        /// <summary>
        /// The number of parameters in the test case node
        /// </summary>
        public int Count
        {
            get
            {
                return RawXmlTestCase.Attributes.Count;
            }
        }
        /// <summary>
        /// Allows the user to look up the value of the test parameter at the given 
        /// index.
        /// </summary>
        /// <param name="attIndex">the index of the parameter to look up</param>
        /// <returns>the value of the test parameter in string form</returns>
        public string this[int attIndex]
        {
            get
            {
                return RawXmlTestCase.Attributes[attIndex].Value;
            }
        }
        /// <summary>
        /// Allows users to look up the value of the named test parameter.
        /// </summary>
        /// <param name="attName">the name of the parameter to look up</param>
        /// <returns>the value of the test parameter in string form</returns>
        public string this[string attName]
        {
            get
            {
                return RawXmlTestCase.Attributes[attName].Value;
            }
        }
        /// <summary>
        /// Bind this wrapper to its corresponding Xml node
        /// </summary>
        /// <param name="TestCaseNode">the node representing a test case and containing the parameters thereof</param>
        public TestCase(XmlNode TestCaseNode)
        {
            RawXmlTestCase = TestCaseNode;
        }
        /// <summary>
        /// Gives the current test a name for the log. Takes into account whether 
        /// a test parameter has been singled out to be added to the test name or not. 
        /// DO NOT call this without selecting a suite and test.
        /// </summary>
        public string TestName
        {
            get
            {
                string tempTitle = "Test Number " + TestConfigFile.InternalSelectedSuite.Trial;
                if (TestConfigFile.InternalSelectedSuite.GlobalInfoNode.TestNameParameterName != "")
                {
                    tempTitle = this[TestConfigFile.InternalSelectedSuite.GlobalInfoNode.TestNameParameterName] + ", " + tempTitle;
                }
                return tempTitle;
            }
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\RpsLogin\RpsLogin.cs ===
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Net;
using System.Text;
using System.Threading;
using System.Web;

namespace Test.Common.Library
{
    /// <summary>
    /// Automated Login Module for RPS.  This class will set up a RPS Ticket and connect to a particular web target, supplying said Ticket.
    /// This module will handle auto-redirects on the target, and return the HTML output as a string.
    /// </summary>
    public class RpsLogin
    {
        #region Properties
        string[] _proxyBypass = { "\\.xbox\\.com", "\\.xna\\.com", "\\.zune\\.net", "\\.xboxlive\\.com", "10", "buy\\.live-int\\.com" };
        PassportEnvironment _passportEnvironment;
        string _username;
        string _password;
        bool _implementProxy;
        string _site;
        string _target;
        string _authPolicy;
        string _siteId;
        string _token;
        private static int Retry_Count = 5;
        string _proxyServer;

        TargetProperty _targetProperty;

        /// <summary>
        /// Server to use for Proxy on requests.
        /// </summary>
        public string ProxyServer
        {
            get { return _proxyServer; }
            set { _proxyServer = value; }
        }
        /// <summary>
        /// List of URLs which should bypass the Proxy
        /// </summary>
        public string[] ProxyBypass
        {
            get { return _proxyBypass; }
            set { _proxyBypass = value; }
        }
        /// <summary>
        /// RPS Environment (each environment has its own user database)
        /// </summary>
        public PassportEnvironment PassportEnvironment
        {
            get { return _passportEnvironment; }
        }
        /// <summary>
        /// Username to log into RPS with
        /// </summary>
        public string Username
        {
            get { return _username; }
            set { _username = value; }
        }
        /// <summary>
        /// Password to log into RPS with
        /// </summary>
        public string Password
        {
            get { return _password; }
            set { _password = value; }
        }
        /// <summary>
        /// Setting to Implement the Proxy on the Request
        /// </summary>
        public bool ImplementProxy
        {
            get { return _implementProxy; }
            set { _implementProxy = value; }
        }
        /// <summary>
        /// Site that requires RPS Ticket (ex: https://www.xbox.com/)
        /// </summary>
        public string Site
        {
            get { return _site; }
            set { _site = value; }
        }
        /// <summary>
        /// Target URL to return HTML from (ex: https://www.xbox.com/en-us/)
        /// </summary>
        public string Target
        {
            get { return _target; }
            set { _target = value; }
        }
        /// <summary>
        /// RPS Auth Policy.  Typically "LBI" or "MBI"
        /// </summary>
        public string AuthPolicy
        {
            get { return _authPolicy; }
            set { _authPolicy = value; }
        }
        /// <summary>
        /// RPS SiteID
        /// </summary>
        public string SiteId
        {
            get { return _siteId; }
            set { _siteId = value; }
        }
        /// <summary>
        /// RPS Token (only populated once BuildRequest is called)
        /// </summary>
        public string Token
        {
            get { return _token; }
            set { _token = value; }
        }
        /// <summary>
        /// Which E&amp;D Property to Target (Some Properties have specific RPS implementation details).
        /// </summary>
        public TargetProperty TargetProperty
        {
            get { return _targetProperty; }
            set { _targetProperty = value; }
        }
        #endregion

        #region Constructors
        /// <summary>
        /// Initializes a new instance of RPS AutoLogin with the specified authorization properties.
        /// </summary>
        /// <param name="target">Target URL to access once RPS is logged in (ex: http://www.xbox.com/en-us/)</param>
        /// <param name="site">Site to create RPS Ticket for (ex: http://www.xbox.com/)</param>
        /// <param name="username">Username (email) to log into RPS</param>
        /// <param name="password">Password to log into RPS</param>
        /// <param name="passportEnvironment">Environment for RPS Login (OneBoxINT is untested currently)</param>
        /// <param name="targetProperty">Which E&amp;D Property to Target (Some require special handling)</param>
        /// <param name="siteId">RPS SiteId for the target Site</param>
        /// <param name="authPolicy">RPS Auth Policy for the target Site (typically "LBI" or "MBI")</param>
        public RpsLogin(string target, string site, string username, string password, PassportEnvironment passportEnvironment, TargetProperty targetProperty, string siteId, string authPolicy)
        {
            Target = target;
            Site = site;
            Username = username;
            Password = password;
            _passportEnvironment = passportEnvironment;
            SiteId = siteId;
            AuthPolicy = authPolicy;
            TargetProperty = targetProperty;
            ProxyServer = "http://itgproxy:80";
        }
        /// <summary>
        /// Initializes a new instance of RPS AutoLogin with the specified authorization properties.
        /// </summary>
        /// <param name="target">Target URL to access once RPS is logged in (ex: http://www.xbox.com/en-us/)</param>
        /// <param name="site">Site to create RPS Ticket for (ex: http://www.xbox.com/)</param>
        /// <param name="username">Username (email) to log into RPS</param>
        /// <param name="password">Password to log into RPS</param>
        /// <param name="passportEnvironment">Environment for RPS Login (OneBoxINT is untested currently)</param>
        /// <param name="targetProperty">Which E&amp;D Property to Target (Some require special handling)</param>
        /// <param name="siteId">RPS SiteId for the target Site</param>
        /// <param name="authPolicy">RPS Auth Policy for the target Site (typically "LBI" or "MBI")</param>
        /// <param name="proxyServer">Proxy Server to apply to each request</param>
        public RpsLogin(string target, string site, string username, string password, PassportEnvironment passportEnvironment, TargetProperty targetProperty, string siteId, string authPolicy, string proxyServer)
        {
            Target = target;
            Site = site;
            Username = username;
            Password = password;
            _passportEnvironment = passportEnvironment;
            SiteId = siteId;
            AuthPolicy = authPolicy;
            TargetProperty = targetProperty;
            ProxyServer = proxyServer;
        }
        #endregion

        #region Methods
        /// <summary>
        /// Creates a HTTP Web request for the specified URL and adds the specified
        /// cookie collection to it.
        /// </summary>
        /// <param name="url">The URL to create request for.</param>
        /// <param name="hash">The cookie collection to add to the request.</param>
        /// <returns>A HTTP Web request object.</returns>
        private HttpWebRequest CreateRequest(string url, List<Cookie> hash)
        {
            CookieContainer cookies = new CookieContainer();
            foreach (Cookie cookie in hash)
            {
                cookies.Add(cookie);
            }

            return CreateRequest(url, cookies);
        }

        private HttpWebRequest CreateRequest(string url, Dictionary<string, Cookie> hash, bool allowRedirect)
        {
            HttpWebRequest req = (HttpWebRequest)HttpWebRequest.Create(url);
            if (ImplementProxy)
            {
                WebProxy proxy = (PassportEnvironment == PassportEnvironment.INT ? new WebProxy(ProxyServer, true, ProxyBypass) : new WebProxy(ProxyServer));
                req.Proxy = proxy;
            }
            req.AllowAutoRedirect = allowRedirect;
            req.MaximumAutomaticRedirections = 50;
            req.Accept = "*/*";
            req.UserAgent = "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; SLCC1; .NET CLR 2.0.50727; .NET CLR 3.0.04506; .NET CLR 3.5.21022; InfoPath.2)";
            req.Method = "POST";
            req.CookieContainer = new CookieContainer();
            foreach (string cookiename in hash.Keys)
            {
                req.CookieContainer.Add(hash[cookiename]);
            }

            return req;
        }

        /// <summary>
        /// Creates a HTTP Web request for the specified URL and adds the specified
        /// cookie collection to it.
        /// </summary>
        /// <param name="url">The URL to create request for.</param>
        /// <param name="hash">The cookie collection to add to the request.</param>
        /// <returns>A HTTP Web request object.</returns>
        private HttpWebRequest CreateRequest(string url, Dictionary<string, Cookie> hash)
        {
            return CreateRequest(url, hash, true);
        }

        /// <summary>
        /// Creates a HTTP Web request for the specified URL and adds the specified
        /// cookie collection to it.
        /// </summary>
        /// <param name="url">The URL to create request for.</param>
        /// <param name="hash">The cookie collection to add to the request.</param>
        /// <returns>A HTTP Web request object.</returns>
        public HttpWebRequest CreateRequest(string url, CookieContainer hash)
        {
            HttpWebRequest req = (HttpWebRequest)HttpWebRequest.Create(url);
            if (ImplementProxy)
            {
                WebProxy proxy = (PassportEnvironment == PassportEnvironment.INT ? new WebProxy(ProxyServer, true, ProxyBypass) : new WebProxy(ProxyServer));
                req.Proxy = proxy;
            }
            req.AllowAutoRedirect = true;
            req.MaximumAutomaticRedirections = 50;
            req.Accept = "*/*";
            req.UserAgent = "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; SLCC1; .NET CLR 2.0.50727; .NET CLR 3.0.04506; .NET CLR 3.5.21022; InfoPath.2)";
            req.Method = "POST";
            req.CookieContainer = new CookieContainer();
            req.CookieContainer = hash;

            return req;
        }

        /// <summary>
        /// Handles redirect requests received from response.
        /// </summary>
        /// <param name="output">The HTML source output received from a response.</param>
        /// <param name="cookies">A collection of cookies originally associated with the request and ones received from the response.</param>
        /// <param name="tries">The number of redirect attempt.</param>
        /// <remarks>
        /// If the number of redirects goes beyond 50, then this method will throw an exception.
        /// </remarks>
        /// <returns>A string representing the HTML source output.</returns>
        private string HandleRedirect(string output, CookieContainer cookies, int tries)
        {
            if (output.IndexOf("document.location.replace(") > -1)
            {
                if (tries >= 50)
                {
                    throw new Exception("Attempted to redirect 50+ times!");
                }
                tries++;

                int pos = output.IndexOf("document.location.replace(");
                string rest = output.Substring(pos + 27);
                string loc = rest.Substring(0, rest.IndexOf("\""));

                HttpWebRequest req = CreateRequest(loc, cookies);
                Encoding UTFEncoding = Encoding.UTF8;
                byte[] byteArray = UTFEncoding.GetBytes("t=" + "");
                req.ContentLength = byteArray.Length;
                Stream ns = req.GetRequestStream();
                ns.Write(byteArray, 0, byteArray.Length);
                ns.Close();

                HttpWebResponse resp = (HttpWebResponse)req.GetResponse();
                StreamReader stream = new StreamReader(resp.GetResponseStream());
                string str = stream.ReadToEnd();

                CookieContainer redirCookies = req.CookieContainer;

                foreach (Cookie cookie in resp.Cookies)
                {
                    redirCookies.Add(cookie);
                }
                return HandleRedirect(str, redirCookies, tries);
            }
            else
            {
                return output;
            }
        }

        /// <summary>
        /// Handles redirect requests received from response.
        /// </summary>
        /// <param name="response">HttpWebResponse to perform redirects upon if necessary</param>
        /// <param name="cookies">A collection of cookies to be added to any redirect requests</param>
        /// <param name="tries">The number of redirect attempt.</param>
        /// <param name="output">HTML source output of final request</param>
        /// <remarks>
        /// If the number of redirects goes beyond 50, then this method will throw an exception.
        /// </remarks>
        /// <returns>Final Request after all redirects are complete</returns>
        private HttpWebResponse HandleRedirect(HttpWebResponse response, CookieContainer cookies, int tries, out string output)
        {
            StreamReader responseStream = new StreamReader(response.GetResponseStream());
            output = responseStream.ReadToEnd();

            if (output.IndexOf("document.location.replace(") > -1)
            {
                if (tries >= 50)
                {
                    throw new Exception("Attempted to redirect 50+ times!");
                }
                tries++;

                int pos = output.IndexOf("document.location.replace(");
                string rest = output.Substring(pos + 27);
                string loc = rest.Substring(0, rest.IndexOf("\""));

                HttpWebRequest req = CreateRequest(loc, cookies);
                Encoding UTFEncoding = Encoding.UTF8;
                byte[] byteArray = UTFEncoding.GetBytes("t=" + "");
                req.ContentLength = byteArray.Length;
                Stream ns = req.GetRequestStream();
                ns.Write(byteArray, 0, byteArray.Length);
                ns.Close();

                HttpWebResponse resp = (HttpWebResponse)req.GetResponse();
                CookieContainer redirCookies = req.CookieContainer;

                foreach (Cookie cookie in resp.Cookies)
                {
                    redirCookies.Add(cookie);
                }
                return HandleRedirect(resp, redirCookies, tries, out output);
            }
            else if (response.StatusCode == HttpStatusCode.Redirect)
            {
                if (tries >= 50)
                {
                    throw new Exception("Attempted to redirect 50+ times!");
                }
                tries++;

                string loc = response.Headers["Location"];

                HttpWebRequest req = CreateRequest(loc, cookies);
                Encoding UTFEncoding = Encoding.UTF8;
                byte[] byteArray = UTFEncoding.GetBytes("t=" + "");
                req.ContentLength = byteArray.Length;
                Stream ns = req.GetRequestStream();
                ns.Write(byteArray, 0, byteArray.Length);
                ns.Close();

                HttpWebResponse resp = (HttpWebResponse)req.GetResponse();
                CookieContainer redirCookies = req.CookieContainer;

                foreach (Cookie cookie in resp.Cookies)
                {
                    redirCookies.Add(cookie);
                }
                return HandleRedirect(resp, redirCookies, tries, out output);
            }
            else
            {
                return response;
            }
        }

        /// <summary>
        /// Converts the specified target URL to a valid
        /// encoded URL.
        /// </summary>
        /// <param name="Target">The target URL to convert.</param>
        /// <returns>A string representing the encoded target URL.</returns>
        private string ConvertTarget(string Target)
        {
            string newUrl = HttpUtility.UrlEncode(Target).Replace("%", "Z");
            newUrl = newUrl.Replace(".", "Z2E").Replace("-", "Z2D");
            newUrl += "&wa=wsignin1.0";
            return newUrl;
        }

        /// <summary>
        /// Logs into RPS and creates the request to be used by PerformRequest.
        /// </summary>
        /// <param name="method">Request Method (GET/POST/PUT/DELETE).</param>
        /// <returns>HttpWebRequest object to be used by PerformRequest.</returns>
        public HttpWebRequest BuildRequest(string method, string postData)
        {
            RPSTicketCreation.RPSTicketGeneratorConfig rpsTicketGenConfigAccount = new RPSTicketCreation.RPSTicketGeneratorConfig();
            rpsTicketGenConfigAccount.ConfigFile = @"RPSTicketGenerator.dll.config";
            rpsTicketGenConfigAccount.PPEnv = (RPSTicketCreation.PassportEnvironment)((int)PassportEnvironment);
            rpsTicketGenConfigAccount.AuthPolicy = AuthPolicy;
            rpsTicketGenConfigAccount.SiteID = SiteId;
            rpsTicketGenConfigAccount.CacheData = false;
            //XBoxCom will give incorrect tickets out if you just use 'live.xbox.com' as the Site.  You have to specify the address below.
            rpsTicketGenConfigAccount.SiteURL = (TargetProperty == TargetProperty.XBoxCom ? Site + "/xweb/live/passport/setCookies.ashx" : Site);
            RPSTicketCreation.RPSTicketGenerator TicketCreator = new RPSTicketCreation.RPSTicketGenerator(rpsTicketGenConfigAccount);

            Dictionary<string, Cookie> hash = new Dictionary<string, Cookie>();
            string tValue = string.Empty;

            int count = 0;
            while (string.IsNullOrEmpty(tValue) && count < Retry_Count)
            {
                try
                {
                    //For some reason ticket generation is inconsistent against "kdc.xblob.xboxlive.com". Hence the retry
                    TicketCreator.GetRPSCompactTicketAndRPSAuthCookies(Username, Password, out hash, out tValue);
                }
                catch
                {
                    Thread.Sleep(10000);
                }
                count++;
            }

            if (string.IsNullOrEmpty(tValue))
            {
                throw new Exception("Compact ticket value not found. Retried" + Retry_Count.ToString() + "times before closing");
            }

            Token = tValue;

            HttpWebRequest req = CreateRequest(Target, hash, false);
            req.Method = method;
            if (method.ToUpperInvariant() != "GET")
            {
                Encoding UTFEncoding = Encoding.UTF8;

                string fullPost = null;
                if (string.IsNullOrEmpty(postData))
                {
                    fullPost = string.Format("t={0}", tValue);
                }
                else
                {
                    fullPost = string.Format("t={0}&{1}", tValue, postData);
                }

                byte[] byteArray = UTFEncoding.GetBytes(fullPost);
                req.ContentLength = byteArray.Length;

                Stream ns = req.GetRequestStream();
                ns.Write(byteArray, 0, byteArray.Length);
                ns.Close();
            }

            return req;
        }

        /// <summary>
        /// Logs into RPS and creates the request to be used by PerformRequest
        /// </summary>
        /// <param name="method">Request Method (GET/POST/PUT/DELETE)</param>
        /// <returns>HttpWebRequest object</returns>
        public HttpWebRequest BuildRequest(string method)
        {
            return BuildRequest(method, null);
        }

        /// <summary>
        /// Performs the Web Request, handles any redirects, and returns the HTML source output.
        /// </summary>
        /// <param name="req">The HTTP Web Request object returned by BuildRequest.</param>
        /// <returns>A string representing the HTML Source output.</returns>
        public string PerformRequest(HttpWebRequest req)
        {
            HttpWebResponse resp = (HttpWebResponse)req.GetResponse();
            StreamReader stream = new StreamReader(resp.GetResponseStream());
            string output = stream.ReadToEnd();
            CookieContainer cookies = req.CookieContainer;
            foreach (Cookie cookie in resp.Cookies)
            {
                cookies.Add(cookie);
            }

            return HandleRedirect(output, cookies, 1);
        }

        /// <summary>
        /// Performs the Web Request, handles any redirects, and returns the HTML source output.
        /// </summary>
        /// <param name="req">The HttpWebRequest object returned by BuildRequest()</param>
        /// <param name="response">The HttpWebResponse of the final request after all redirections</param>
        /// <returns>A string representing the HTML Source output.</returns>
        public string PerformRequest(HttpWebRequest req, out HttpWebResponse response)
        {
            HttpWebResponse resp = (HttpWebResponse)req.GetResponse();

            CookieContainer cookies = req.CookieContainer;
            foreach (Cookie cookie in resp.Cookies)
            {
                cookies.Add(cookie);
            }

            string output = "";
            response = HandleRedirect(resp, cookies, 1, out output);
            return output;

        }
        #endregion

    }

    /// <summary>
    /// Indicates the E&amp;D property to target. <br/>
    /// NOTE: Some Properties have specific RPS implementation details.
    /// </summary>
    public enum TargetProperty
    {
        /// <summary>
        /// Indicates target property is XBox.com.
        /// </summary>
        XBoxCom,
        /// <summary>
        /// Indicates target is a property other than XBox.com.
        /// </summary>
        Other
    }

    /// <summary>
    /// Indicates the environment for Passport Calls.
    /// This will affect valid usernames, passwords, and sites.
    /// </summary>
    public enum PassportEnvironment
    {
        /// <summary>
        /// Indicates authentication against INT RPS Environment.
        /// </summary>
        INT = 0,
        /// <summary>
        /// Indicates authentication against Production RPS Environment.
        /// </summary>
        Production = 1,
        /// <summary>
        /// Indicates authentication against One Box INT RPS Environment.
        /// </summary>
        OneBoxINT = 2,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\Titanium\Titanium\InterProcessTools.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;
using System.IO;
using System.Runtime.Remoting;
using System.Runtime.Remoting.Channels;
using System.Runtime.Remoting.Channels.Http;
using System.Runtime.Remoting.Channels.Tcp;
using System.Threading;
using MST = Wgx.Test.Solutions.MessengerGames.Library.API.Mercury.MillisecondTimes;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters;
using System.Runtime.Serialization.Formatters.Binary;
using System.Collections.Specialized;

namespace Titanium
{
    /// <summary>
    /// A custom exception for Titanium-based remoting
    /// </summary>
    public class TRemotingException : System.Exception
    {
        public TRemotingException(string message)
            : base(message)
        {
            SIDCard = new ServerIDCard();
        }
        public TRemotingException(string message, System.Exception ex)
            : base(message, ex)
        {
            SIDCard = new ServerIDCard();
        }
        public TRemotingException(string message, ServerIDCard myID)
            : base(message)
        {
            SIDCard = myID;
        }
        public TRemotingException(string message, ServerIDCard myID, System.Exception ex)
            : base(message, ex)
        {
            SIDCard = myID;
        }
        /// <summary>
        /// The ServerIDCard of the server that caused the exception
        /// </summary>
        public readonly ServerIDCard SIDCard;
    }
    /// <summary>
    /// A collection of functions for process communication within a single machine or across a network, 
    /// using remoting as the basis for communication.
    /// </summary>
    public static class InterProcessTools
    {
        #region public members

        #endregion
        #region public methods
        /// <summary>
        /// Contacts the local Titanium process, or starts one if it's not already running. 
        /// Just a wrapper for TitaniumServer's own function, for consistency
        /// </summary>
        /// <returns>An instance of the object being served by the running Titanium.exe</returns>
        public static TitaniumServer ContactTitaniumServer()
        {
            return TitaniumServer.ContactTitaniumServer();
        }
        /// <summary>
        /// Contact a process serving a remote interface. Serving process can also be local (i.e. based
        ///  on same machine as caller)
        /// </summary>
        /// <param name="targetProcess">the server ID card of the remote server process</param>
        /// <returns>an instance of the RemoteInterface being served</returns>
        public static RemoteInterface ContactRemoteProcess(ServerIDCard targetProcess)
        {
            return ContactRemoteProcess(targetProcess.ContactString);
        }
        /// <summary>
        /// Contact a process serving a remote interface. Serving process can also be local (i.e. based
        ///  on same machine as caller)
        /// </summary>
        /// <param name="HostName">name of the machine hosthing the server process (or localhost, if same 
        /// machine as caller)</param>
        /// <param name="PortNum">port number that server process is listening on</param>
        /// <param name="ObjectName">name of the remote object - usually, for Titanium-based stuff, the process name</param>
        /// <returns>an instance of the RemoteInterface being served</returns>
        public static RemoteInterface ContactRemoteProcess(string HostName, int PortNum, string ObjectName)
        {
            return ContactRemoteProcess(ServerIDCard.DeriveContactString(HostName, PortNum, ObjectName));
        }
        /// <summary>
        /// Contact a process serving a remote interface. Serving process can also be local (i.e. based
        ///  on same machine as caller)
        /// </summary>
        /// <param name="ContactString"></param>
        /// <returns>an instance of the RemoteInterface being served</returns>
        public static RemoteInterface ContactRemoteProcess(string ContactString)
        {
            EnsureClientChannelExists();
            return (RemoteInterface)Activator.GetObject(typeof(RemoteInterface), ContactString);
        }
        /// <summary>
        /// Serve a RemoteInterface from this exe. Note: this is setup so all clients will receive the same copy
        /// of the RemoteInterface on request. Note: if this method is used, the object served by the server CANNOT 
        /// be cast to anything other than a RemoteInterface (or a parent type thereof)
        /// </summary>
        /// <param name="thisServerID">a properly initialized ServerIDCard for this process</param>
        public static void ServeRemoteInterface(ServerIDCard thisServerID)
        {
            //call the basic function with the default type passed as the second parameter
            ServeRemoteInterface(thisServerID, typeof(RemoteInterface));
        }
        /// <summary>
        /// Serve a RemoteInterface, or any type that inherits from RemoteInterface, from this exe. 
        /// Note: this is setup so all clients will receive the same copy of the RemoteInterface on 
        /// request.
        /// </summary>
        /// <param name="thisServerID">a properly initialized ServerIDCard for this process</param>
        /// <param name="thisDescendentType">the type of this process (must inherit from RemoteInterface)</param>
        public static void ServeRemoteInterface(ServerIDCard thisServerID, Type thisDescendentType)
        {
            ServeThisObject(thisDescendentType, thisServerID.PortNum, thisServerID.ProcessName, true);
        }
        /// <summary>
        /// Channels can only be registered/created once; calling this ensures the client channel gets
        ///  registered if-and-only-if it needs to be
        /// </summary>
        public static void EnsureClientChannelExists()
        {
            lock (ClientChanLock)
            {
                if (ClientChannel == null)
                {
                    ClientChannel = new TcpClientChannel();
                    ChannelServices.RegisterChannel(ClientChannel, EnforceSecurity);
                }
            }
        }
        /// <summary>
        /// Channels can only be registered/created once; calling this ensures the server channel gets
        ///  registered if-and-only-if it needs to be. It ALSO ensures that one process gets one port
        /// </summary>
        /// <param name="port">the port number for the channel - used only if the channel doesnt exist</param>
        public static void EnsureServerChannelExists(int port)
        {
            lock (ServerChanLock)
            {
                string channelName = Process.GetCurrentProcess().ProcessName;
                if (ServerChannel == null)
                {
                    ServerChannel = new TcpServerChannel(channelName, port);
                    ChannelServices.RegisterChannel(ServerChannel, EnforceSecurity);
                }
            }
        }

        #region raw functions - theoretically useable without Titanium.exe, but not recommended, except internal to the API
        /// <summary>
        /// Serves an object of the specified type on the specified port - object MUST be/inherit from MarshalByRef.
        /// Static objects cannot be served.
        /// Be prepared - this function will throw exceptions if the port is in use or the type is illegal. 
        /// NOTE - stand-alone usage is NOT recommended
        /// </summary>
        /// <param name="ObjectTypeToServe">the type of object to serve. MUST be/inherit from MarshalByRef</param>
        /// <param name="PortNum">the port number to serve on</param>
        /// <param name="objectURI">the URI by which clients will find this object - can be as simple as "myObject"</param>
        /// <param name="oneForAllClients">if true, sets things up so that all clients receive the SAME copy of the served object</param>
        public static void ServeThisObject(Type ObjectTypeToServe, int PortNum, string objectURI, bool oneForAllClients)
        {
            lock (ServeObjectLock)
            {
                //Create and register a channel
                EnsureServerChannelExists(PortNum);
                if (oneForAllClients)
                {
                    //set things up so that each client is holding the SAME copy of the object
                    RemotingConfiguration.RegisterWellKnownServiceType(ObjectTypeToServe, objectURI, WellKnownObjectMode.Singleton);
                }
                else
                {
                    //set things up so that each client gets its own copy of the object
                    RemotingConfiguration.RegisterWellKnownServiceType(ObjectTypeToServe, objectURI, WellKnownObjectMode.Singleton);
                }
            }
        }
        /// <summary>
        /// This simplifies the proces of requesting an object from the same machine as the calling process.
        /// Be prepared for this function to throw exceptions if the object doesn't exist. 
        /// NOTE - stand-alone usage is NOT recommended
        /// </summary>
        /// <param name="portNum">the port number on which the local server is listening for requests</param>
        /// <param name="objectURI">the URI of the object (e.g. "myObject")</param>
        /// <returns>a MarshalByRefObject representing the requested object</returns>
        public static MarshalByRefObject RequestLocalObject(int portNum, string objectURI)
        {
            return RequestRemoteObject("localhost", portNum, objectURI);
        }
        /// <summary>
        /// Returns an instance of a remotely served object. Be prepared for exceptions 
        /// if the object doesn't exist, or something else has gone wrong. 
        /// NOTE - stand-alone usage is NOT recommended
        /// </summary>
        /// <param name="Hostname">the name of the machine the object is being served from</param>
        /// <param name="portNum">the port number on which the remote server is listening for requests</param>
        /// <param name="objectURI">the URI of the object (e.g. "myObject")</param>
        /// <returns>a MarshalByRefObject representing the requested object</returns>
        public static MarshalByRefObject RequestRemoteObject(string Hostname, int portNum, string objectURI)
        {
            //First, register a channel to make requests
            EnsureClientChannelExists();
            //concatenate everything the caller gave us into a useful string
            string contactString = "tcp://" + Hostname + ":" + portNum + "/" + objectURI;
            return (MarshalByRefObject)Activator.GetObject(typeof(MarshalByRefObject), contactString);
        }
        #endregion
        #endregion
        #region public read-only members
        /// <summary>
        /// Controls whether channels enforce security
        /// </summary>
        public const bool EnforceSecurity = false;
        ///// <summary>
        ///// The standard URI for servers using the Titanium API to serve
        ///// </summary>
        //public const string ObjectURI = "RemoteInterface";
        #endregion
        #region private members
        private static object Padlock = new object();
        private static object ServeObjectLock = new object(); //lock for ServeThisObject
        private static object ClientChanLock = new object(); //lock for checking if the client channel exists
        private static object ServerChanLock = new object(); //lock for checking if the server channel exists
        private static TcpClientChannel ClientChannel = null;
        private static TcpServerChannel ServerChannel = null;
        #endregion
    }
    /// <summary>
    /// Inextricably welds a message string to the ProcessTag of the process that intends to send it, 
    /// creating a ProcessTag+message pair, just like on the label
    /// </summary>
    [Serializable]
    public sealed class TagMessagePair
    {
        /// <summary>
        /// The tag of whoever intends to send the message
        /// </summary>
        public readonly ProcessTag Sender;
        /// <summary>
        /// The message being sent
        /// </summary>
        public readonly string Message;
        /// <summary>
        /// Creates a TagMessagePair, using the calling process's info to derive the ProcessTag
        /// </summary>
        /// <param name="messageContent">the string content of the message</param>
        public TagMessagePair(string messageContent)
        {
            Sender = new ProcessTag();
            Message = messageContent;
        }
    }
    /// <summary>
    /// Inextricably welds a file object to its intended destination path and the ProcessTag of the process 
    /// that intends to send it, thus creating a ProcessTag+path+file triplet, just like on the label
    /// </summary>
    [Serializable]
    public sealed class TagPathFileTriplet
    {
        /// <summary>
        /// The tag of whoever intends to send the file
        /// </summary>
        public readonly ProcessTag Sender;
        /// <summary>
        /// The file being sent
        /// </summary>
        public readonly GenericFile FileToSend;
        /// <summary>
        /// The path the file is intended to go to (must contain filename.exe, at least)
        /// (receiving object is free to ignore intended path)
        /// </summary>
        public readonly string IntendedPath;
        /// <summary>
        /// Creates a TagPathFileTriplet, using the calling process's info to derive the ProcessTag
        /// </summary>
        /// <param name="fileToSend">the file object to send</param>
        public TagPathFileTriplet(GenericFile fileToSend, string DestinationPath)
        {
            Sender = new ProcessTag();
            FileToSend = fileToSend;
            IntendedPath = DestinationPath;
        }
    }
    /// <summary>
    /// A collection of all the information needed to identify/contact a process that is acting as a server...
    /// provided, of course, that server is serving a RemoteInterface
    /// </summary>
    [Serializable]
    public sealed class ServerIDCard : ProcessTag
    {
        /// <summary>
        /// The port number the process is serving on
        /// </summary>
        public readonly int PortNum;
        #region constructors
        /// <summary>
        /// Construct a card based on the calling process. Warning - the port number will be invalid
        /// </summary>
        public ServerIDCard()
            : base()
        {
            //NOTE: make it so this number IS valid for Titanium.exe - perform a check on the caller
            PortNum = -1;
        }
        /// <summary>
        /// Allows Titanium.exe to construct a card based on the process with ID = procID
        /// </summary>
        /// <param name="portNum">the port number to serve on</param>
        /// <param name="procID">the ID of the server process</param>
        public ServerIDCard(int portNum, int procID)
            : base(procID)
        {
            PortNum = portNum;
        }
        #endregion
        #region public members/methods
        /// <summary>
        /// Return a string representation of the ServerIDCard
        /// </summary>
        /// <returns>A string representation of the ServerIDCard</returns>
        public override string ToString()
        {
            string output = ProcessName + "_" + ProcessPath + "_" + ProcessID + "_" + HostName + "_" + PortNum;
            return output;
        }
        /// <summary>
        /// Returns a string useful for contacting this process's RemoteInterface
        /// </summary>
        public string ContactString
        {
            get
            {
                ////does this process live on the same machine as me?
                //if (HostName == Environment.MachineName)
                //{
                //    //yes, so use "localhost" as the host name
                //    return @"tcp://localhost:" + PortNum + @"/" + ProcessName;
                //}
                //else
                //{
                    //no, so use the machine name as the host name
                    return @"tcp://" + HostName + @":" + PortNum + @"/" + ProcessName;
                //}
            }
        }
        /// <summary>
        /// Effectively, the ToString of the ProcessTag this object has inside it
        /// </summary>
        public string ProcessTagString
        {
            get
            {
                string output = ProcessName + "_" + ProcessPath + "_" + ProcessID + "_" + HostName;
                return output;
            }
        }
        /// <summary>
        /// Returns the remote object being served by this server, or null
        /// if the port number is invalid. WARNING - this accessor assumes the 
        /// remote server is serving a RemoteInterface with the same name as the 
        /// server process.
        /// </summary>
        public RemoteInterface ServerObject
        {
            get
            {
                try
                {
                    if (this.PortNum < 1)
                    {
                        //this is an invalid port, so return null
                        return null;
                    }
                    else
                    {
                        return (RemoteInterface)InterProcessTools.RequestRemoteObject(HostName, PortNum, ProcessName);
                    }
                } 
                catch 
                {
                    //something went wrong
                    return null;
                }
            }
        }
        /// <summary>
        /// Derives the contact string of a remote object
        /// </summary>
        /// <param name="host">the name of the host machine</param>
        /// <param name="port">the port the object is using to communicate</param>
        /// <param name="objName">the name of the object</param>
        /// <returns>a string useful for contacting the remote object</returns>
        public static string DeriveContactString(string host, int port, string objName)
        {
            //does this process live on the same machine as me?
            if (host == Environment.MachineName)
            {
                //yes, so use "localhost" as the host name
                return @"tcp://localhost:" + port + @"/" + objName;
            }
            else
            {
                //no, so use the machine name as the host name
                return @"tcp://" + host + @":" + port + @"/" + objName;
            }
        }
        #endregion
    }
    /// <summary>
    /// A collection of all the information needed to identify a running process on a given machine
    /// </summary>
    [Serializable]
    public class ProcessTag
    {
        #region read-only members
        /// <summary>
        /// The name of the process
        /// </summary>
        public string ProcessName { get; private set; }
        /// <summary>
        /// The full path to the process on its host machine
        /// </summary>
        public string ProcessPath { get; private set; }
        /// <summary>
        /// The path to the process on the host, minus the filename
        /// </summary>
        public string HomeDirectory { get; private set; }
        /// <summary>
        /// The Id of the process
        /// </summary>
        public int ProcessID { get; private set; }
        /// <summary>
        /// The name of the process's exe
        /// </summary>
        public string ExeName
        {
            get
            {
                return ProcessName + ".exe";
            }
        }
        /// <summary>
        /// The name of the host machine
        /// </summary>
        public string HostName { get; private set; }
        /// <summary>
        /// Returns the path to the process's StartupInstructions file, or "" if no file is found
        /// </summary>
        public string StartupInfoPath
        {
            get
            {
                string possiblePath = @StripExtension(ProcessPath) + ".si";
                if (File.Exists(@possiblePath))
                {
                    //the SI exists, so return the path to it
                    return possiblePath;
                }
                else
                {
                    //the SI doesn't exist
                    return "";
                }
            }
        }
        /// <summary>
        /// Strips the extension from a filename
        /// </summary>
        /// <param name="filename">the filename to strip</param>
        /// <returns>the passed-in string, shorn of a .x... extension (e.g. .ex, .exe, .toolong, etc)</returns>
        public static string StripExtension(string filename)
        {
            int lastDot = filename.LastIndexOf('.'); //find the last ., which will be the beginning of the extension
            return filename.Substring(0, lastDot); //this will return everything EXCEPT the .extension
        }
        /// <summary>
        /// Given a string representing a path ending in a filename, strips away the filename
        /// </summary>
        /// <param name="pathAndFile">a string representing the path and filename</param>
        /// <returns>a string representign just the path</returns>
        public static string StripFileName(string pathAndFile)
        {
            int lastSlash = pathAndFile.LastIndexOf('\\'); //find the last \, which is where the file name itself starts
            return pathAndFile.Substring(0, lastSlash + 1); //return only the path to the file, not the filename itself
        }
        /// <summary>
        /// Given a string representing a path ending in a filename, strips away the path
        /// </summary>
        /// <param name="pathAndFile">a string representing the path and filename</param>
        /// <returns>a string representing just the filename</returns>
        public static string StripPath(string pathAndFile)
        {
            int lastSlash = pathAndFile.LastIndexOf('\\');
            return pathAndFile.Substring(lastSlash + 1);
        }
        #endregion
        /// <summary>
        /// Return a string representation of the ProcessTag
        /// </summary>
        /// <returns>A string representation of the ProcessTag</returns>
        public override string ToString()
        {
            string output = ProcessName + "_" + ProcessPath + "_" + ProcessID + "_" + HostName;
            return output;
        }
        #region constructors
        /// <summary>
        /// Construct a process tag for the calling process
        /// </summary>
        public ProcessTag()
        {
            Process p = Process.GetCurrentProcess();
            CommonConstructor(p);
        }
        /// <summary>
        /// Construct a ProcessTag for the LOCAL process with ID = IDofProcToTag
        /// </summary>
        /// <param name="IDofProcToTag">the ID of the LOCAL process for which we want a tag</param>
        public ProcessTag(int IDofProcToTag)
        {
            Process p = Process.GetProcessById(IDofProcToTag);
            CommonConstructor(p);
        }
        /// <summary>
        /// Construct a ProcessTag for the LOCAL process, ProcToTag
        /// </summary>
        /// <param name="ProcToTag">the LOCAL process we want a tag for</param>
        public ProcessTag(Process ProcToTag)
        {
            CommonConstructor(ProcToTag);
        }
        #endregion
        #region operators
        public static bool operator ==(ProcessTag t1, ProcessTag t2)
        {
            //determine if t1 and/or t2 is null
            bool t1IsNull;
            bool t2IsNull;
            try
            {
                t1IsNull = t1.ToString().Equals(null);
            }
            catch (NullReferenceException)
            {
                t1IsNull = true;
            }
            try
            {
                t2IsNull = t2.ToString().Equals(null);
            }
            catch (NullReferenceException)
            {
                t2IsNull = true;
            }
            if (t1IsNull || t2IsNull)
            {
                //at least one of them is null
                if (t1IsNull && t2IsNull)
                {
                    //both of them are null
                    return true;
                }
                else
                {
                    //only one of them is null
                    return false;
                }
            }
            //neither t1 nor t2 is null, so compare their members
            return ((t1.ExeName == t2.ExeName) && (t1.HomeDirectory == t2.HomeDirectory) && (t1.HostName == t2.HostName) && (t1.ProcessID == t2.ProcessID) && (t1.ProcessName == t2.ProcessName) && (t1.ProcessPath == t2.ProcessPath) && (t1.StartupInfoPath == t2.StartupInfoPath));
        }
        public static bool operator !=(ProcessTag t1, ProcessTag t2)
        {
            //determine if t1 and/or t2 is null
            bool t1IsNull;
            bool t2IsNull;
            try
            {
                t1IsNull = t1.ToString().Equals(null);
            }
            catch (NullReferenceException)
            {
                t1IsNull = true;
            }
            try
            {
                t2IsNull = t2.ToString().Equals(null);
            }
            catch (NullReferenceException)
            {
                t2IsNull = true;
            }
            if (t1IsNull || t2IsNull)
            {
                //at least one of them is null
                if (t1IsNull && t2IsNull)
                {
                    //both of them are null
                    return false;
                }
                else
                {
                    //only one of them is null
                    return true;
                }
            }
            //neither t1 nor t2 is null, so compare their members
            return ((t1.ExeName != t2.ExeName) || (t1.HomeDirectory != t2.HomeDirectory) || (t1.HostName != t2.HostName) || (t1.ProcessID != t2.ProcessID) || (t1.ProcessName != t2.ProcessName) || (t1.ProcessPath != t2.ProcessPath) || (t1.StartupInfoPath != t2.StartupInfoPath));
        }
        /// <summary>
        /// WARNING: this is not guaranteed to be accurate - == or != are 
        /// recommended instead.
        /// </summary>
        /// <param name="obj">Object for comparison</param>
        /// <returns>base.Equals(obj)</returns>
        public override bool Equals(object obj)
        {
            return base.Equals(obj);
        }
        /// <summary>
        /// WARNING: unsupported - returns base.GetHashCode()
        /// </summary>
        /// <returns>base.GetHashCode</returns>
        public override int GetHashCode()
        {
            return base.GetHashCode();
        }
        #endregion
        /// <summary>
        /// Code common to all constructors of this object
        /// </summary>
        /// <param name="ProcToTag">the LOCAL process this object will be constructed for</param>
        protected void CommonConstructor(Process ProcToTag)
        {
            ProcessName = ProcToTag.ProcessName;
            ProcessPath = ProcToTag.MainModule.FileName;
            HomeDirectory = StripFileName(ProcessPath);
            ProcessID = ProcToTag.Id;
            HostName = Environment.MachineName;
        }
    }
    /// <summary>
    /// When complete, this will be used to make it easier to search a list of ServerIDCards 
    /// by any of their properties (e.g. search-by-processID)
    /// </summary>
    [Serializable]
    public sealed class ServerIDCardList
    {
        /// <summary>
        /// Create a ServerIDCardList from a List object containing ServerIDCards
        /// </summary>
        /// <param name="CardList">the List of ServerIDCards</param>
        public ServerIDCardList(List<ServerIDCard> CardList)
        {
            Cards = CardList;
        }
        /// <summary>
        /// The contained List of ServerIDCards
        /// </summary>
        public readonly List<ServerIDCard> Cards;
        /// <summary>
        /// Get the ServerIDCard at the specific index
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public ServerIDCard this[int index]
        {
            get
            {
                return Cards[index];
            }
        }
    }
    //NOTE: consider making StartupInstructions read-only except to the process it belongs to
    /// <summary>
    /// Serves as a way for a process to leave up-to-date instructions for what parameters to feed it 
    /// if it needs restarting. Processes making use of Titanium.exe's watchdog MUST provide/maintain one of these
    /// </summary>
    [Serializable]
    public class StartupInstructions
    {
        #region read-only variables
        /// <summary>
        /// the path to the exe and its StartupInstructions object
        /// </summary>
        public string Path { get; protected set; }
        /// <summary>
        /// the name of the exe and the StartupInstructions (no extension)
        /// </summary>
        public string BaseFileName { get; protected set; }
        /// <summary>
        /// The full name of the exe (with extension)
        /// </summary>
        public string ExeFile
        {
            get
            {
                return BaseFileName + ".exe";
            }
        }
        /// <summary>
        /// The full name of the StartupInstructions file (with extension)
        /// </summary>
        public string SIFile
        {
            get
            {
                return BaseFileName + ".si";
            }
        }
        /// <summary>
        /// The full path leading to the exe
        /// </summary>
        public string ExeWithPath
        {
            get
            {
                return @Path + ExeFile;
            }
        }
        /// <summary>
        /// The full path leading to the StartupInstructions
        /// </summary>
        public string SIWithPath
        {
            get
            {
                return @Path + SIFile;
            }
        }
        /// <summary>
        /// Gets or sets a particular argument in the argArray, selected by index
        /// </summary>
        /// <param name="index">the index of the argument</param>
        /// <returns>the value of the argument</returns>
        public string this[int index]
        {
            get
            {
                return argArray[index];
            }
            set
            {
                argArray[index] = value;
                Save(); //save the changes we just made
            }
        }
        /// <summary>
        /// The contained array of arguments as a single, space-separated string
        /// </summary>
        public string ArgString
        {
            get
            {
                string args = "";
                //turn the collection of strings into a single, space-separated string
                foreach (string argument in argArray)
                {
                    args += argument;
                    args += ' ';
                }
                //trim trailing spaces
                args = args.TrimEnd(' ');
                return args;
            }
        }
        #endregion
        #region public functions
        /// <summary>
        /// Save this object (or changes to it) in the associated .si file
        /// </summary>
        public void Save()
        {
            Stream myStream = File.Open(SIFile, FileMode.OpenOrCreate);
            BinaryFormatter myFormatter = new BinaryFormatter();
            myFormatter.Serialize(myStream, this);
            myStream.Close();
        }
        /// <summary>
        /// Create a StartupInstructions object with no starting arguments
        /// </summary>
        public StartupInstructions()
        {
            CommonConstructorCode(new string[0]);
        }
        /// <summary>
        /// Create a StartupInstructions object with arguments
        /// </summary>
        /// <param name="arguments">the array of arguments for the process</param>
        public StartupInstructions(string[] arguments)
        {
            CommonConstructorCode(arguments);
        }
        /// <summary>
        /// Create a StartupInstructions object from a .si file.
        /// WARNING - there is no error protection for improper file format
        /// </summary>
        /// <param name="filename"></param>
        public StartupInstructions(string filename)
        {
            Stream myStream = File.Open(filename, FileMode.Open);
            BinaryFormatter myFormatter = new BinaryFormatter();
            StartupInstructions tempSI = (StartupInstructions)myFormatter.Deserialize(myStream);
            this.BaseFileName = tempSI.BaseFileName;
            this.Path = tempSI.Path;
            this.argArray = tempSI.argArray;
            myStream.Close();
        }
        /// <summary>
        /// Replace the current argsArray with the new one. Arguments that contain spaces
        ///  must be enclosed in escaped ""
        /// </summary>
        /// <param name="newArgs">array of strings to replace the old args arrray</param>
        public void ReplaceArgs(string[] newArgs)
        {
            //empty the collection, then replace it with the new array
            argArray.Clear();
            argArray.AddRange(newArgs);
            Save();
        }
        /// <summary>
        /// Replace the current argsArray with the space-separated sub-strings in this string.
        /// Example: "arg1 arg2 arg3". Note that arguments containing internal spaces are NOT allowed
        /// </summary>
        /// <param name="spaceSeparatedNewArgs">string of space-separated arguments</param>
        public void ReplaceArgs(string spaceSeparatedNewArgs)
        {
            //empty the collection, then replace it with an array created by
            // splitting the incoming string every time there's a space
            // (so "arg1 arg2 arg3" gets fed in as {"arg1","arg2","arg3")
            argArray.Clear();
            argArray.AddRange(spaceSeparatedNewArgs.Split(' '));
            Save();
        }
        /// <summary>
        /// Add the strings in this array to the end of the current argsArray. 
        /// Arguments that contain spaces must be enclosed in escaped ""
        /// </summary>
        /// <param name="argsToAppend">the array of strings to append as arguments</param>
        public void AppendArgs(string[] argsToAppend)
        {
            argArray.AddRange(argsToAppend);
            Save();
        }
        /// <summary>
        /// Add the space-separated sub-strings as arguments to the end of the current argArray.
        /// Example: "arg1 arg2 arg3". Note that arguments containing internal spaces are NOT allowed
        /// </summary>
        /// <param name="spaceSeparatedArgsToAppend">string of space-separated arguments</param>
        public void AppendArgs(string spaceSeparatedArgsToAppend)
        {
            argArray.AddRange(spaceSeparatedArgsToAppend.Split(' '));
            Save();
        }
        /// <summary>
        /// Remove numArgsToTrim from the end of the array.
        /// Nothing bad happens if numArgsToTrim >> argsArray length
        /// </summary>
        /// <param name="numArgsToTrim">the number of arguments to trim from the end of the array</param>
        public void TrimArgs(int numArgsToTrim)
        {
            while ((numArgsToTrim > 0) && (argArray.Count > 0))
            {
                //remove the last argument
                argArray.RemoveAt(argArray.Count - 1);
                //decrement the number of times to keep doing this
                numArgsToTrim--;
            }
            Save();
        }
        /// <summary>
        /// Sets all the relevant StartInfo in the given process
        /// </summary>
        /// <param name="target">the process to set up</param>
        public void PrepareNewProcess(ref Process target)
        {
            Update(); //ensure we have the most up-to-date information
            target.StartInfo.Arguments = ArgString;
            target.StartInfo.WorkingDirectory = Path;
            target.StartInfo.FileName = ExeWithPath;
        }
        #endregion
        #region private members and functions
        /// <summary>
        /// The internally maintained array of argument strings
        /// </summary>
        protected StringCollection argArray;
        /// <summary>
        /// Code common to all constructors of this class
        /// </summary>
        /// <param name="arguments"></param>
        protected void CommonConstructorCode(string[] arguments)
        {
            Process p = Process.GetCurrentProcess();
            //get the path
            string tempPath = p.MainModule.FileName;
            int lastSlash = tempPath.LastIndexOf('\\');
            tempPath = tempPath.Substring(0, lastSlash + 1);
            Path = tempPath;
            //get the base filename
            string tempName = p.MainModule.ModuleName;
            tempName = tempName.Substring(0, tempName.Length - 4); //strip off the .exe
            BaseFileName = tempName;
            //set the arguments
            argArray = new StringCollection();
            if (arguments.Length > 0)
            {
                argArray.AddRange(arguments);
            }
            //save the StartupInstructions
            Save();
        }
        /// <summary>
        /// Refresh all members from the associated .si file
        /// </summary>
        protected void Update()
        {
            Stream myStream = File.Open(SIWithPath, FileMode.Open);
            BinaryFormatter myFormatter = new BinaryFormatter();
            StartupInstructions tempSI = (StartupInstructions)myFormatter.Deserialize(myStream);
            this.BaseFileName = tempSI.BaseFileName;
            this.Path = tempSI.Path;
            this.argArray = tempSI.argArray;
            myStream.Close();
        }
        #endregion
    }
    /// <summary>
    /// A way of sending any file to a remote object as a cluster of bytes, regardless of format or content
    /// </summary>
    [Serializable]
    public class GenericFile
    {
        /// <summary>
        /// The raw byte array representing the file contents
        /// </summary>
        public byte[] internalData { get; protected set; }
        /// <summary>
        /// The number of bytes in the byte array
        /// </summary>
        public int SizeOf
        {
            get
            {
                return internalData.Length;
            }
        }
        /// <summary>
        /// Construct an empty GenericFile object
        /// </summary>
        public GenericFile()
        {
            this.internalData = new byte[0];
        }
        /// <summary>
        /// Construct a GenericFile object
        /// </summary>
        /// <param name="filename">the full path to the local file</param>
        public GenericFile(string filename)
        {
            this.internalData = File.ReadAllBytes(filename);
        }
        /// <summary>
        /// Read all the bytes from a file into the byte array
        /// </summary>
        /// <param name="filename">the full path to the file-to-be-read</param>
        public void Load(string filename)
        {
            internalData = File.ReadAllBytes(@filename);
        }
        /// <summary>
        /// Write all the bytes from the byte array to a file. Warning - overwrites existing files
        /// </summary>
        /// <param name="filename">the full path to the file-to-be-written</param>
        public void Save(string filename)
        {
            File.WriteAllBytes(filename, internalData);
        }
    }
    /// <summary>
    /// This is basically a serializable double for the tragically non-serializable ProcessStartInfo.
    /// More fields from ProcessStartInfo will be added as needed.
    /// </summary>
    [Serializable]
    public class SerializableStartInfo
    {
        public string Arguments = "";
        public string FileName = "";
        public string WorkingDirectory = "";
        /// <summary>
        /// The name of the process (i.e. "explorer" or "notepad")
        /// </summary>
        public string ProcessName
        {
            get
            {
                //strip the extension from the filename
                string temp = ProcessTag.StripExtension(FileName);
                //strip the path from the filename
                temp = ProcessTag.StripPath(temp);
                return temp;
            }
        }
        /// <summary>
        /// A convenient way of converting between a ProcessStartInfo and a SerializableStartInfo.
        /// Reading from this returns a ProcessStartInfo with all this object's information in the right place. 
        /// Writing to this puts all the info from a ProcessStartInfo into this object in the right way.
        /// </summary>
        public ProcessStartInfo PIConverter
        {
            get
            {
                ProcessStartInfo p = new ProcessStartInfo(FileName, Arguments);
                p.WorkingDirectory = WorkingDirectory;
                return p;
            }
            set
            {
                Arguments = value.Arguments;
                FileName = value.FileName;
                WorkingDirectory = value.WorkingDirectory;
            }
        }
        /// <summary>
        /// Create a blank SerializableStartInfo
        /// </summary>
        public SerializableStartInfo()
        {
            //do nothing
        }
        /// <summary>
        /// Create a SerializableStartInfo with the filename of the exe preset
        /// </summary>
        /// <param name="fileName">the filename representing the exe run by this process</param>
        public SerializableStartInfo(string fileName)
        {
            this.FileName = fileName;
        }
        /// <summary>
        /// Create a SerializableStartInfo with the filename and arguments of the exe preset
        /// </summary>
        /// <param name="fileName">the filename representing the exe run by this process</param>
        /// <param name="arguments">the starting arguments to feed the exe when running it</param>
        public SerializableStartInfo(string fileName, string arguments)
        {
            this.FileName = fileName;
            this.Arguments = arguments;
        }
        /// <summary>
        /// Create a SerializableStartInfo from a pre-existing ProcessStartInfo
        /// </summary>
        /// <param name="p">the pre-existing ProcessStartInfo</param>
        public SerializableStartInfo(ProcessStartInfo p)
        {
            this.PIConverter = p;
        }
    }
    /// <summary>
    /// This allows one (and ONLY one) party to wait for another party to release it. 
    /// This differs from the standard mutex/semaphore in that the waiting party can 
    /// be set to stop waiting and report a problem, should a timeout period elapse before 
    /// release occurs.
    /// </summary>
    public class TwoPartySynchronizer
    {
        /// <summary>
        /// The semaphore maintained by this class for synchronization
        /// </summary>
        protected Semaphore synchroSemaphore = new Semaphore(0,1);
        /// <summary>
        /// Releases the party waiting on this object - nothing bad happens if noone is waiting when
        /// this is called
        /// </summary>
        public void Release()
        {
            try
            {
                //try to release the semaphore
                synchroSemaphore.Release();
            }
            catch
            {
                //swallow the exception if the semaphore did not need releasing
            }
        }
        /// <summary>
        /// Block the calling party until TimeOut elapses or another party calls Release. Passing 0 or negative 
        /// numbers as the timeout indicates "never timeout"
        /// </summary>
        /// <param name="TimeOut">the time, in milliseconds, to wait for release. 0 or less indicates wait forever</param>
        /// <returns>true if Release was called before timeout elapsed, otherwise false</returns>
        public bool WaitForRelease(int TimeOut)
        {
            try
            {
                if (TimeOut > 0)
                {
                    //TimeOut value > 0 indicates we are to wait until the timeout expires
                    //we will return true if the semaphore is released before the timeout expires
                    return synchroSemaphore.WaitOne(TimeOut,false);
                }
                else
                {
                    //TimeOut value < 1 indicates we are to wait until the semaphore is released
                    return synchroSemaphore.WaitOne();
                }
            }
            finally
            {
                //reset the semaphore for next time
                synchroSemaphore = new Semaphore(0, 1);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\Titanium\Titanium\RemoteInterface.cs ===
﻿
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;
using System.IO;
using System.Runtime.Remoting;
using System.Runtime.Remoting.Channels;
using System.Runtime.Remoting.Channels.Http;
using System.Runtime.Remoting.Channels.Tcp;
using System.Threading;
using MST = Wgx.Test.Solutions.MessengerGames.Library.API.Mercury.MillisecondTimes;
using TimeKey = System.DateTime; 
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters;
using System.Runtime.Serialization.Formatters.Binary;
using System.Collections.Specialized;

namespace Titanium
{
    //This class is declared partial in order to separate out the code that is meant to be called remotely from
    // the code that is meant to be called locally. This has no effect on actual operation - it is purely for human readability
    /// <summary>
    /// A class to provide basic communication/control functionality.
    /// The Titanium API has functions to serve/request this class.
    /// Note: it is recommended that your serving exe simply inherit from this class, rather than trying to 
    /// keep an instance of it. Note for derived classes: Static members will not be directly accessible 
    /// at the remote end. To render them remotely accessible, provide dynamic wrapper members.
    /// </summary>
    public partial class RemoteInterface : MarshalByRefObject //this is the local section
    {
        /*
         * IMPORTANT NOTE - if you call a static method on a remote class, you are calling it locally, NOT remotely. 
         * The same is true if you access a static member directly.
         */
        #region public members
        /// <summary>
        /// The recommended, global storage space for this process's ServerIDCard
        /// </summary>
        public static ServerIDCard MyIDCard = null;
        /// <summary>
        /// An easy way to get the ID of the process accessing the member (this process)
        /// </summary>
        public static int MyProcessID
        {
            get
            {
                return Process.GetCurrentProcess().Id;
            }
        }
        /// <summary>
        /// A convenient, global storage space for this process's TitaniumServer object
        /// </summary>
        public static TitaniumServer MyTitaniumServer = null;
        /// <summary>
        /// A convenient, global storage space for this process's StartupInstructions object
        /// </summary>
        public static StartupInstructions MyStartupInstructions = null;
        /// <summary>
        /// A storage space for incoming messages
        /// </summary>
        public static Dictionary<TimeKey, TagMessagePair> IncomingMessages
        {
            get
            {
                lock (incomingMessages)
                {
                    return incomingMessages;
                }
            }
            private set
            {
                lock (incomingMessages)
                {
                    incomingMessages = value;
                }
            }
        }
        /// <summary>
        /// A storage space for incoming file objects
        /// </summary>
        public static Dictionary<TimeKey, TagPathFileTriplet> IncomingFiles
        {
            get
            {
                lock (incomingFiles)
                {
                    return incomingFiles;
                }
            }
            private set
            {
                lock (incomingFiles)
                {
                    incomingFiles = value;
                }
            }
        }
        /// <summary>
        /// A storage space for TwoPartySynchronizers used for blocking remote callers
        /// </summary>
        public static Dictionary<TimeKey, TwoPartySynchronizer> BlockerHeap
        {
            get
            {
                lock (blockerHeap)
                {
                    return blockerHeap;
                }
            }
            private set
            {
                lock(blockerHeap)
                {
                    blockerHeap = value;
                }
            }
        }
        #endregion
        #region public functions
        #region threaded tasks
        /// <summary>
        /// Carry out a task on a separate thread. The thread is returned for monitoring purposes, but the call 
        /// is non-blocking, so the caller is free to forget the thread and move on, if desired.
        /// Note: FireAndForget(delegate{myRequestedRemoteObject.SomeRemoteMethod(SomeParameter,SomeOtherParameter);}); is 
        /// valid usage in .Net 3.5 and later. Further note: except for the generic names, the syntax here is exactly correct
        ///  (e.g. the lowercase 'd' in 'delegate' is not a typo).
        /// </summary>
        /// <param name="task">the task to carry out</param>
        /// <returns>The thread carrying out the task, in case the user doesnt actually want to "forget" it</returns>
        public static Thread FireAndForget(ThreadStart task)
        {
            Thread TaskMaster;
            //just call InvokeWithTimeout with a timeout value that means "return at once"
            InvokeWithTimeout(task, 0, out TaskMaster);
            //return TaskMaster, just in case the caller wants to keep an eye on things
            return TaskMaster;
        }
        /// <summary>
        /// Carry out a task on a separate thread and return, whether it completes or not. This is most useful for 
        /// calling remote functions that may freeze up - such a freeze will not permanetly stall the local process.
        /// Note: InvokeWithTimeout(delegate{myRequestedRemoteObject.SomeRemoteMethod(SomeParameter,SomeOtherParameter);},SomeTimeout); is 
        /// valid usage in .Net 3.5 and later. Further note: except for the generic names, the syntax here is exactly correct
        ///  (e.g. the lowercase 'd' in 'delegate' is not a typo).
        /// </summary>
        /// <param name="task">the task to be carried out</param>
        /// <param name="TimeOut">the time, in milliseconds to wait for the task to complete. less than 1 indicates 
        /// return without waiting (let the thread run, but don't wait for it to return)</param>
        /// <param name="TaskMaster">the thread running the task - set as "out" so the user has access, 
        /// particularly in the event TimeOut is less than 1</param>
        /// <returns>true if timeout was less than 1 or if the thread returned before timeout expired, otherwise false</returns>
        public static bool InvokeWithTimeout(ThreadStart task, int TimeOut, out Thread TaskMaster)
        {
            //initialize the TaskMaster
            TaskMaster = new Thread(task);
            TaskMaster.Start();
            if (TimeOut < 1)
            {
                //the caller has no desire to wait around, so just return
                return true;
            }
            else
            {
                //the caller desires to wait until timeout. Return true if the thread completed its task before timeout
                return TaskMaster.Join(TimeOut);
            }
        }
        #endregion
        /// <summary>
        /// Call this to perform all the steps needed for serving a RemoteInterface. 
        /// NOTE: If this overload is used, the class being served CANNOT be cast to 
        /// anything other than RemoteInterface (or a parent type) on the client side. 
        /// If this server class INHERITS from RemoteInterface, it should not be
        /// serving using this overload. NOTE: this overload does not register 
        /// the caller with Titanium's watchdog service.
        /// </summary>
        public static void SetupAndStartRemoting()
        {
            //call the basic function, but pass 'null' for the startup-instructions so 
            // no watchdog registration will take place
            SetupAndStartRemoting(typeof(RemoteInterface),null);
        }
        /// <summary>
        /// Call this to perform all the steps needed for serving a RemoteInterface. 
        /// NOTE: If this overload is used, the class being served CANNOT be cast to 
        /// anything other than RemoteInterface (or a parent type) on the client side. 
        /// If this server class INHERITS from RemoteInterface, it should not be
        /// serving using this overload. NOTE: this overload assumes the caller wants 
        /// to be registered with Titanium's watchdog service, unless 'null' is passed for inputSI
        /// </summary>
        /// <param name="inputSI">the object containing persistent startup instructions, or 
        /// 'null' if watchdog is not desired. NOTE: 'new StartupInstructions()' is another acceptable input</param>
        public static void SetupAndStartRemoting(StartupInstructions inputSI)
        {
            //call the basic function, but use the default type
            SetupAndStartRemoting(typeof(RemoteInterface), inputSI);
        }
        /// <summary>
        /// Call this to perform all the steps needed for serving a RemoteInterface OR 
        /// a type that inherits from RemoteInterface. NOTE: this overload does not register 
        /// the caller with Titanium's watchdog service.
        /// </summary>
        /// <param name="thisDescendentType">the type of the class calling this method (must 
        /// inherit from RemoteInterface)</param>
        public static void SetupAndStartRemoting(Type thisDescendentType)
        {
            //call the basic function, but pass 'null' for the startup-instructions so
            // no watchdog registration will take place
            SetupAndStartRemoting(thisDescendentType, null);
        }
        /// <summary>
        /// Call this to perform all the steps needed for serving a RemoteInterface OR 
        /// a type that inherits from RemoteInterface. NOTE: this overload assumes the caller wants 
        /// to be registered with Titanium's watchdog service, unless 'null' is passed for inputSI
        /// </summary>
        /// <param name="thisDescendentType">the type of the class calling this method (must 
        /// inherit from RemoteInterface)</param>
        /// <param name="inputSI">the object containing persistent startup instructions, or 'null'
        /// if watchdog is not desired.  NOTE: 'new StartupInstructions()' is another acceptable input</param>
        public static void SetupAndStartRemoting(Type thisDescendentType, StartupInstructions inputSI)
        {
            //contact (or start and then contact) the Titanium.exe server
            MyTitaniumServer = TitaniumServer.ContactTitaniumServer();
            //store the provided startup-instructions in case a restart is needed
            MyStartupInstructions = inputSI;
            if (inputSI != null)
            {
                //Register with watchdog and get a ServerIDCard
                MyIDCard = MyTitaniumServer.RegisterServer(MyProcessID, MyStartupInstructions.SIWithPath);
            }
            else
            {
                //No startup-instructions, so no watchdog. Just register as a server and get a ServerIDCard
                MyIDCard = MyTitaniumServer.RegisterServer(MyProcessID);
            }
            //Start serving
            InterProcessTools.ServeRemoteInterface(MyIDCard, thisDescendentType);
        }
        /// <summary>
        /// Call this to deregister from watchdog and perform other clean-up tasks. 
        /// This function should be called even if the process is to be killed.
        /// </summary>
        public static void CallBeforeExit()
        {
            try
            {
                //deregister from the watchdog - if never registered, no harm is done
                MyTitaniumServer.DeRegister(MyProcessID);
            }
            catch (ArgumentOutOfRangeException ex)
            {
                //this is a spurious exception - the deregistration is fine
                TInternalLogger.LogException(ex, VerboseLevel.DebugChatter);
            }
        }
        /// <summary>
        /// Someone is waiting for an ACK on an event that happened at TimeKey. Send that ACK.
        /// </summary>
        /// <param name="TargetTimeKey">the TimeKey at which the event occured</param>
        public static void ACK(TimeKey TargetTimeKey)
        {
            try
            {
                lock (blockerHeap)
                {
                    //try to release the semaphore started at time TimeKey
                    BlockerHeap[TargetTimeKey].Release();
                }
            }
            catch
            {

            }
        }
        /// <summary>
        /// A remote caller is blocking on an event that happened at TimeKey. Unblock them.
        ///  This is really just a wrapper for ACK, allowing the user to think of it in a different way.
        /// </summary>
        /// <param name="TargetTimeKey">the TimeKey at which the event occured</param>
        public static void UnblockRemoteCaller(TimeKey TargetTimeKey)
        {
            ACK(TargetTimeKey);
        }
        #region SendRemote...
        /// <summary>
        /// Send a message to a remote process
        /// </summary>
        /// <param name="MessageToSend">the string to send</param>
        /// <param name="ServerToContact">the ServerIDCard of the remote process</param>
        /// <param name="TimeOut">how long to block, in milliseconds, before timing out. 0 or less = non-blocking</param>
        /// <param name="RemoveOnTimeout">if true, the message is removed from the storage space in the event of a time-out</param>
        /// <returns>true if the blocking call returned before timeout is reached, otherwise false</returns>
        public static bool SendRemoteMessage(string MessageToSend, ServerIDCard ServerToContact, int TimeOut, bool RemoveOnTimeout)
        {
            //use the ServerIDCard's .ServerObject member to get the RemoteInterface object we need
            return SendRemoteMessage(MessageToSend, ServerToContact.ServerObject, TimeOut, RemoveOnTimeout);
        }
        /// <summary>
        /// Send a message to a remote process
        /// </summary>
        /// <param name="MessageToSend">the string to send</param>
        /// <param name="TargetToSendTo">the RemoteInterface object to send the message to</param>
        /// <param name="TimeOut">how long to block, in milliseconds, before timing out. 0 or less = non-blocking</param>
        /// <param name="RemoveOnTimeout">if true, the message is removed from the storage space in the event of a time-out</param>
        /// <returns>true if the blocking call returned before timeout is reached, otherwise false</returns>
        public static bool SendRemoteMessage(string MessageToSend, RemoteInterface TargetToSendTo, int TimeOut, bool RemoveOnTimeout)
        {
            //create a TagMessage pair for this process
            TagMessagePair tempPair = new TagMessagePair(MessageToSend);
            //call SendMessage on TargetToSend 
            return TargetToSendTo.SendMessage(tempPair, TimeOut, RemoveOnTimeout);
        }
        /// <summary>
        /// Send a file to a remote process
        /// </summary>
        /// <param name="LocalPath">the full path to the file on the local machine</param>
        /// <param name="RemotePath">the full path to save the file at on the remote machine</param>
        /// <param name="ServerToContact">the ServerIDCard of the remote process</param>
        /// <param name="TimeOut">how long to block, in milliseconds, before timing out. 0 or less = non-blocking</param>
        /// <param name="RemoveOnTimeout">if true, the file is removed from the storage space in the event of a time-out</param>
        /// <returns>true if the blocking call returned before timeout is reached, otherwise false</returns>
        public static bool SendRemoteFile(string LocalPath, string RemotePath, ServerIDCard ServerToContact, int TimeOut, bool RemoveOnTimeout)
        {
            //create a GenericFile object from the data at the specified path
            GenericFile FileToSend = new GenericFile(LocalPath);
            //Get the RemoteInterface from the ServerToContact
            RemoteInterface TargetToSendTo = ServerToContact.ServerObject;
            //Let one overload do all the real work - send the file
            return SendRemoteFile(FileToSend, RemotePath, TargetToSendTo, TimeOut, RemoveOnTimeout);
        }
        /// <summary>
        /// Send a file to a remote process
        /// </summary>
        /// <param name="FileToSend">the GenericFile object to send</param>
        /// <param name="RemotePath">the full path to save the file at on the remote machine</param>
        /// <param name="ServerToContact">the ServerIDCard of the remote process</param>
        /// <param name="TimeOut">how long to block, in milliseconds, before timing out. 0 or less = non-blocking</param>
        /// <param name="RemoveOnTimeout">if true, the file is removed from the storage space in the event of a time-out</param>
        /// <returns>true if the blocking call returned before timeout is reached, otherwise false</returns>
        public static bool SendRemoteFile(GenericFile FileToSend, string RemotePath, ServerIDCard ServerToContact, int TimeOut, bool RemoveOnTimeout)
        {
            //Get the RemoteInterface from the ServerToContact
            RemoteInterface TargetToSendTo = ServerToContact.ServerObject;
            //Let one overload do all the real work - send the file
            return SendRemoteFile(FileToSend, RemotePath, TargetToSendTo, TimeOut, RemoveOnTimeout);
        }
        /// <summary>
        /// Send a file to a remote process
        /// </summary>
        /// <param name="LocalPath">the full path to the file on the local machine</param>
        /// <param name="RemotePath">the full path to save the file at on the remote machine</param>
        /// <param name="TargetToSendTo">the RemoteInterface object to send the file to</param>
        /// <param name="TimeOut">how long to block, in milliseconds, before timing out. 0 or less = non-blocking</param>
        /// <param name="RemoveOnTimeout">if true, the file is removed from the storage space in the event of a time-out</param>
        /// <returns>true if the blocking call returned before timeout is reached, otherwise false</returns>
        public static bool SendRemoteFile(string LocalPath, string RemotePath, RemoteInterface TargetToSendTo, int TimeOut, bool RemoveOnTimeout)
        {
            //create a GenericFile object from the data at the specified path
            GenericFile FileToSend = new GenericFile(LocalPath);
            //Let one overload do all the real work - send the file
            return SendRemoteFile(FileToSend, RemotePath, TargetToSendTo, TimeOut, RemoveOnTimeout);
        }
        /// <summary>
        /// Send a file to a remote process
        /// </summary>
        /// <param name="FileToSend">the GenericFile object to send</param>
        /// <param name="RemotePath">the full path to save the file at on the remote machine</param>
        /// <param name="TargetToSendTo">the RemoteInterface object to send the message to</param>
        /// <param name="TimeOut">how long to block, in milliseconds, before timing out. 0 or less = non-blocking</param>
        /// <param name="RemoveOnTimeout">if true, the file is removed from the storage space in the event of a time-out</param>
        /// <returns>true if the blocking call returned before timeout is reached, otherwise false</returns>
        public static bool SendRemoteFile(GenericFile FileToSend, string RemotePath, RemoteInterface TargetToSendTo, int TimeOut, bool RemoveOnTimeout)
        {
            //construct the triplet we need
            TagPathFileTriplet tempTriplet = new TagPathFileTriplet(FileToSend, RemotePath);
            //Call SendFile on the RemoteInterface
            return TargetToSendTo.SendFile(tempTriplet, TimeOut, RemoveOnTimeout);
        }
        #endregion
        /// <summary>
        /// Request a file from a RemoteInterface object. Note: RemoteSource and LocalDestination will be 
        /// interpretted as relative to the working directories of the remote and local programs, respectively, unless 
        /// absolute paths are provided. 
        /// </summary>
        /// <param name="requestTarget">the RemoteInterface to request from</param>
        /// <param name="RemoteSource">the path and file name of the file to request</param>
        /// <param name="LocalDestination">the path and file name under which to save the requested data - MUST include extension</param>
        /// <param name="timeout">time, in milliseconds, to wait before giving up</param>
        /// <returns>true if the file was retrieved and saved within the timeout period, otherwise false</returns>
        public static bool RequestRemoteFile(RemoteInterface requestTarget, string RemoteSource, string LocalDestination, int timeout)
        {
            try
            {
                //request the file and store its data in a GenericFile
                GenericFile requestedFile = requestTarget.RequestFile(RemoteSource, timeout);
                if (requestedFile == null)
                {
                    //something went wrong
                    TInternalLogger.LogError("Request for remote file " + RemoteSource + " failed", VerboseLevel.GeneralMessages);
                    return false;
                }
                //dump the stored data to the specified destination
                requestedFile.Save(LocalDestination);
                //check if the file exists
                if (!File.Exists(LocalDestination))
                {
                    TInternalLogger.LogError("File " + RemoteSource + " was retrieved, but not saved", VerboseLevel.GeneralMessages);
                    return false;
                }
                //all conditions passed
                TInternalLogger.LogMessage("Retrieved file " + RemoteSource + " and stored it at " + LocalDestination, VerboseLevel.DebugChatter);
                return true;
            }
            catch (System.Exception ex)
            {
                //something went wrong
                TInternalLogger.LogException(ex, VerboseLevel.GeneralMessages);
                return false;
            }
        }
        #region WaitFor...
        /// <summary>
        /// This function blocks until time runs out or a file is received. WARNING: 
        /// exception will be thrown if there are no event listeners attached to the 
        /// IncomingFile event. Event listener MUST call ReleaseFileWait to unblock 
        /// things.
        /// </summary>
        /// <param name="timeout">time, in milliseconds, to wait before giving up. 0 or less = wait forever</param>
        /// <param name="fileSender">null = function unblocks for ANY incoming file. value = function unblocks 
        /// ONLY for a file from the sender with that ProcessTag</param>
        /// <returns>true if unblocked before timeout, otherwise false</returns>
        public static bool WaitForFile(int timeout,ProcessTag fileSender)
        {
            //create an event handler - it will be null if there are no listeners attached
            EventHandler<RemoteEventArgs> handler = IncomingFile;
            if (handler == null)
            {
                //no listeners, so tell the programmer what went wrong
                TInternalLogger.LogError("Attempt to WaitForFile with no event listner attached", VerboseLevel.CriticalMessages);
                throw new RemotingException("No IncomingFile event listener detected - WaitForFile would never release");
            }
            //set the ExpectingFile flag
            ExpectingFile = true;
            //if a fileSender was provided, record it so we can wait for that ProcessTag
            if (fileSender != null)
            {
                TInternalLogger.LogMessage("Waiting for a file from " + fileSender.ToString(), VerboseLevel.GeneralMessages);
                ExpectedFileSender = fileSender;
            }
            //block and wait - fileBlock will take care of the timeout logic
            bool fileReceivedOK = fileBlock.WaitForRelease(timeout);
            //whether we timed out or not, we are no longer waiting
            ExpectingFile = false; //this will also nullify ExpectedFileSender, if it was not null already
            if (fileReceivedOK)
            {
                TInternalLogger.LogMessage("Received expected file within time limit", VerboseLevel.DebugChatter);
            }
            else
            {
                TInternalLogger.LogMessage("Timed out while waiting for file", VerboseLevel.GeneralMessages);
            }
            return fileReceivedOK;
        }
        /// <summary>
        /// This function blocks until time runs out or a message is received. WARNING: 
        /// exception will be thrown if there are no event listeners attached to the 
        /// IncomingMessage event. Event listener MUST call ReleaseMessageWait to unblock 
        /// things.
        /// </summary>
        /// <param name="timeout">time, in milliseconds, to wait before giving up. 0 or less = wait forever</param>
        /// <param name="fileSender">null = function unblocks for ANY incoming message. value = function unblocks 
        /// ONLY for a message from the sender with that ProcessTag</param>
        /// <returns>true if unblocked before timeout, otherwise false</returns>
        public static bool WaitForMessage(int timeout, ProcessTag messageSender)
        {
            //create an event handler - it will be null if there are no listeners attached
            EventHandler<RemoteEventArgs> handler = IncomingMessage;
            if (handler == null)
            {
                //no listeners, so tell the programmer what went wrong
                TInternalLogger.LogError("Attempt to WaitForMessage with no event listner attached", VerboseLevel.CriticalMessages);
                throw new RemotingException("No IncomingMessage event listener detected - WaitForMessage would never release");
            }
            //set the ExpectingMessage flag
            ExpectingMessage = true;
            //if a messageSender was provided, record it so we can wait for that ProcessTag
            if (messageSender != null)
            {
                TInternalLogger.LogMessage("Waiting for a message from " + messageSender.ToString(), VerboseLevel.GeneralMessages);
                ExpectedMessageSender = messageSender;
            }
            //block and wait - messageBlock will take care of the timeout logic
            bool messageReceivedOK = messageBlock.WaitForRelease(timeout);
            //whether we timed out or not, we are no longer waiting
            ExpectingMessage = false; //this will also nullify ExpectedMessageSender, if it was not null already
            if (messageReceivedOK)
            {
                TInternalLogger.LogMessage("Received expected message within time limit", VerboseLevel.DebugChatter);
            }
            else
            {
                //it's tempting to log this as an error, but the timeout could be expected, or even desired, behavior
                TInternalLogger.LogMessage("Timed out while waiting for message", VerboseLevel.GeneralMessages);
            }
            return messageReceivedOK;
        }
        /// <summary>
        /// Call this in your IncomingFile event listener to stop waiting for 
        /// an incoming file.
        /// </summary>
        /// <param name="fileSender">The ProcessTag of who sent the file - get this from the event args</param>
        public static void ReleaseFileWait(ProcessTag fileSender)
        {
            if (!ExpectingFile)
            {
                return; //do nothing, as we weren't expecting a file
            }
            if (ExpectedFileSender != null)
            {
                //We're waiting for a file from a specific sender
                if (fileSender != ExpectedFileSender)
                {
                    return; //we got a file, but not from someone we were waiting for, so do nothing
                }
            }
            //criteria passed, so release the blocking function
            fileBlock.Release();
            TInternalLogger.LogMessage("Released program from waiting for file", VerboseLevel.DebugChatter);
        }
        /// <summary>
        /// Call this in your IncomingMessage event listener to stop waiting for 
        /// an incoming message.
        /// </summary>
        /// <param name="messageSender">The ProcessTag of who sent the message - get this from the event args</param>
        public static void ReleaseMessageWait(ProcessTag messageSender)
        {
            if (!ExpectingMessage)
            {
                return; //do nothing, as we weren't expecting a message
            }
            if (ExpectedMessageSender != null)
            {
                //We're waiting for a message from a specific sender
                if (messageSender != ExpectedMessageSender)
                {
                    return; //we got a message, but not from someone we were waiting for, so do nothing
                }
            }
            //criteria passed, so release the blocking function
            messageBlock.Release();
            TInternalLogger.LogMessage("Released program from waiting for message", VerboseLevel.DebugChatter);
        }
        #region support members
        /// <summary>
        /// If non-null, indicates that this RemoteInterface is waiting for a message 
        /// from the sender with this ProcessTag
        /// </summary>
        public static ProcessTag ExpectedMessageSender
        {
            get
            {
                return expectedMessageSender;
            }
            protected set
            {
                expectedMessageSender = value;
            }
        }
        /// <summary>
        /// If true, indicates that we are blocked and waiting for a file
        /// </summary>
        public static bool ExpectingFile
        {
            get
            {
                return expectingFile;
            }
            protected set
            {
                //we can't be expecting a file from a specific 
                // person while simultaneously NOT expecting a file
                // so nullify expectedFileSender if expectingFile is set 
                // to false
                if (value == false)
                {
                    expectedFileSender = null;
                }
                expectingFile = value;
            }
        }
        /// <summary>
        /// If true, indicates that we are blocked and waiting for a message
        /// </summary>
        public static bool ExpectingMessage
        {
            get
            {
                return expectingMessage;
            }
            protected set
            {
                //we can't be expecting a message from a specific 
                // person while simultaneously NOT expecting a message
                // so nullify expectedMessageSender if expectingMessage is set 
                // to false
                if (value == false)
                {
                    expectedMessageSender = null;
                }
                expectingMessage = value;
            }
        }
        /// <summary>
        /// If non-null, indicates that this RemoteInterface is waiting for a file 
        /// from the sender with this ProcessTag
        /// </summary>
        public static ProcessTag ExpectedFileSender
        {
            get
            {
                return expectedFileSender;
            }
            protected set
            {
                expectedFileSender = value;
            }
        }
        #region private support
        //the private versions of publicly readable members - mainly so we can init them here
        static ProcessTag expectedMessageSender = null;
        static ProcessTag expectedFileSender = null;
        static bool expectingFile = false;
        static bool expectingMessage = false;
        static TwoPartySynchronizer fileBlock = new TwoPartySynchronizer();
        static TwoPartySynchronizer messageBlock = new TwoPartySynchronizer();
        #endregion
        #endregion
        #endregion
        #region local message and file processing
        /// <summary>
        /// This is the same concept as peeking a queue, allowing you to read a message without removing it. 
        /// </summary>
        /// <param name="TargetTimeKey">the TimeKey object that indicates when the message was sent</param>
        /// <returns>null if something went wrong, otherwise the TagMessagePair that was sent at TimeKey time</returns>
        public static TagMessagePair ReadMessage(TimeKey TargetTimeKey)
        {
            TagMessagePair Contents;
            try
            {
                //peek the message that was sent at time TimeKey
                Contents = IncomingMessages[TargetTimeKey];
                return Contents;
            }
            catch
            {
                //regardless of the exception thrown, just return null
                return null;
            }
        }
        /// <summary>
        /// This is the same concept as dequeuing from a queue; it removes the message from the dictionary before reading it. 
        /// </summary>
        /// <param name="TargetTimeKey">the TimeKey object that indicates when the message was sent</param>
        /// <returns>null if something went wrong, otherwise the TagMessagePair that was sent at TimeKey time</returns>
        public static TagMessagePair RemoveAndReadMessage(TimeKey TargetTimeKey)
        {
            //get the message contents
            TagMessagePair Contents = ReadMessage(TargetTimeKey);
            //remove the message from the dictionary
            IncomingMessages.Remove(TargetTimeKey);
            return Contents;
        }
        /// <summary>
        /// This is the same concept as peeking a queue, allowing you to access a file without removing it.
        /// </summary>
        /// <param name="TargetTimeKey">the TimeKey object that indicates when the file was sent</param>
        /// <returns>null if something went wrong, otherwise the TagPathFileTriplet that was sent at TimeKey time</returns>
        public static TagPathFileTriplet AccessFile(TimeKey TargetTimeKey)
        {
            TagPathFileTriplet Contents;
            try
            {
                //peek the file that was sent at time TimeKey
                Contents = IncomingFiles[TargetTimeKey];
                return Contents;
            }
            catch
            {
                //regardless of the exception thrown, just return null
                return null;
            }

        }
        /// <summary>
        /// This is the same concept as dequeuing from a queue; it removes the file from the dictionary before accessing it.
        /// </summary>
        /// <param name="TargetTimeKey">the TimeKey object that indicates when the file was sent</param>
        /// <returns>null if something went wrong, otherwise the TagPathFileTriplet that was sent at TimeKey time</returns>
        public static TagPathFileTriplet RemoveAndAccessFile(TimeKey TargetTimeKey)
        {
            //get the file
            TagPathFileTriplet Contents = AccessFile(TargetTimeKey);
            //remove the file from the dictionary
            IncomingFiles.Remove(TargetTimeKey);
            return Contents;
        }
        /// <summary>
        /// Clear all incoming messages currently enqueued - use with caution
        /// </summary>
        public static void ClearMessageQueue()
        {
            IncomingMessages.Clear();
        }
        /// <summary>
        /// Clear all incoming files currently enqueued - use with caution
        /// </summary>
        public static void ClearFileQueue()
        {
            IncomingFiles.Clear();
        }
        #endregion
        #endregion
        #region private members
        #region the private counterparts to the public accessors
        private static Dictionary<TimeKey, TagMessagePair> incomingMessages = new Dictionary<TimeKey, TagMessagePair>();
        private static Dictionary<TimeKey, TagPathFileTriplet> incomingFiles = new Dictionary<TimeKey, TagPathFileTriplet>();
        private static Dictionary<TimeKey, TwoPartySynchronizer> blockerHeap = new Dictionary<TimeKey, TwoPartySynchronizer>();
        #endregion
        #region TimeKey stuff
        #endregion
        #region semaphores for blocking
        //blocking for messages
        private static Semaphore blockForMessage = new Semaphore(0, 1);
        //blocking for files
        private static Semaphore blockForFile = new Semaphore(0, 1);
        //blocking for...well, whatever you want
        private static Semaphore blockForGeneric = new Semaphore(0, 1);
        #endregion
        #endregion
        #region event members
        #region events
        /// <summary>
        /// Indicates that a new message has been placed in storage (usually 
        /// by a remote process)
        /// </summary>
        public static event EventHandler<RemoteEventArgs> IncomingMessage;
        /// <summary>
        /// Indicates that a new file has been placed in storage (usually by 
        /// a remote process)
        /// </summary>
        public static event EventHandler<RemoteEventArgs> IncomingFile;
        #endregion
        //If enabled, this code provides an alternative method for servicing
        // incoming message and file events. When SendMessage or SendFile are called, 
        // a RemoteEventArgs object is created and put into the appropriate queue.
        // The event pumping threads scan the queues periodically, and dequeue any
        // event args they find. They then use these args to publish the event, and they
        // service the event code.
#if EVENT_PUMPS_ON
        #region event pumps
        /// <summary>
        /// Call this before closing, so the event pump threads will stop - otherwise, the program may not exit
        /// </summary>
        public static void StopEventPumps()
        {
            FileEventPump.Abort();
            MsgEventPump.Abort();
        }
        //threads that service event code
        private static Thread FileEventPump = null;
        private static Thread MsgEventPump = null;
        #region functions carried out by those threads
        private static void PumpFileEvents()
        {
            while (true)
            {
                lock (FileEventQueue)
                {
                    while (FileEventQueue.Count > 0)
                    {
                        //pop the next RemoteEventArgs off this queue and publish with it
                        StaticOnIncomingFile(FileEventQueue.Dequeue());
                    }
                }
                //leave some time for args to be stored
                Thread.Sleep(MST.ONE_SECOND);
            }
        }
        private static void PumpMessageEvents()
        {
            while (true)
            {
                lock (MsgEventQueue)
                {
                    while (MsgEventQueue.Count > 0)
                    {
                        //pop the next RemoteEventArgs off this queue and publish with it
                        StaticOnIncomingMessage(MsgEventQueue.Dequeue());
                    }
                }
                //leave some time for args to be stored
                Thread.Sleep(MST.ONE_SECOND);
            }
        }
        #endregion
        #region functions to publish events
        //these are only called within the Send functions
        private static void PublishFileEvent(bool isBlocking, TagPathFileTriplet FileContainer, TimeKey TargetTimeKey)
        {
            //create a RemoteEventArgs for the caller of this function
            RemoteEventArgs r = new RemoteEventArgs(isBlocking, FileContainer.Sender, TargetTimeKey);
            //put the RemoteEventArgs in the queue
            lock (FileEventQueue)
            {
                FileEventQueue.Enqueue(r);
                if (FileEventPump == null)
                {
                    //the event pump has not been started yet, so start it
                    FileEventPump = new Thread(PumpFileEvents);
                    FileEventPump.Name = "File event pump";
                    FileEventPump.Start();
                }
            }
        }
        private static void PublishMessageEvent(bool isBlocking, TagMessagePair MsgContainer, TimeKey TargetTimeKey)
        {
            //create a RemoteEventArgs for the caller of this function
            RemoteEventArgs r = new RemoteEventArgs(isBlocking, MsgContainer.Sender, TargetTimeKey);
            //put the RemoteEventArgs in the queue
            lock (MsgEventQueue)
            {
                MsgEventQueue.Enqueue(r);
                if (MsgEventPump == null)
                {
                    //the event pump has not been started yet, so start it
                    MsgEventPump = new Thread(PumpMessageEvents);
                    MsgEventPump.Name = "Message event pump";
                    MsgEventPump.Start();
                }
            }
        }
        #endregion
        //queues for events to go into
        private static Queue<RemoteEventArgs> FileEventQueue = new Queue<RemoteEventArgs>();
        private static Queue<RemoteEventArgs> MsgEventQueue = new Queue<RemoteEventArgs>();
        #endregion
#endif
        #endregion
    }
    public partial class RemoteInterface : MarshalByRefObject //this is the remote section
    {
        /*
         * IMPORTANT NOTE FOR FUTURE MAINTAINABILITY - if you call a function on a remote instance of this class, 
         * the variables in that function, whether static or dynamic, will be the REMOTE INSTANCE'S VARIABLES, NOT YOURS!
         * This is confusing, but important to keep straight. Only passed-in parameters will be yours, and on that note:
         * DO NOT WRITE A REMOTE-FUNCTION THAT TAKES A REFERENCE/OUT PARAMETER - it will compile, but WILL FAIL WHEN CALLED!
         */
        /*
         * IMPORTANT NOTE - if you call a static method on a remote class, you are calling it locally, NOT remotely. 
         * The same is true if you access a static member directly.
         */
        /// <summary>
        /// Gets the RemoteInterface's "MyIDCard" field (or null, if the field was not used). 
        /// NOTE: MyIDCard contains the RemoteInterface's ServerIDCard, which has all info needed
        ///  to contact or identify it remotely.
        /// </summary>
        public ServerIDCard GetID
        {
            get
            {
                try
                {
                    return MyIDCard;
                }
                catch
                {
                    return null;
                }
            }
        }
        /// <summary>
        /// Send a message. This function is intended to be called like so "myRequestedObject.SendMessage".
        /// </summary>
        /// <param name="MessageContainer">The TagMessage pair containing the message to send</param>
        /// <param name="TimeOut">how long to block, in milliseconds, before timing out. 0 or less = non-blocking</param>
        /// <param name="RemoveOnTimeout">if true, the message is removed from the storage space in the event of a time-out</param>
        /// <returns>true if the blocking call returned before timeout is reached, otherwise false</returns>
        public bool SendMessage(TagMessagePair MessageContainer, int TimeOut, bool RemoveOnTimeout)
        {
            //First, record the time to use as a key
            TimeKey MyTimeKey = ObtainTimeKey();
            //next, put the message in the storage space
            IncomingMessages.Add(MyTimeKey, MessageContainer);
#if EVENT_PUMPS_ON
            //find out if this is a blocking call
            if (TimeOut > 0)
            {
                //get a TwoPartySynchronizer to block on
                BlockerHeap.Add(MyTimeKey, new TwoPartySynchronizer());
                ////construct the appropriate RemoteEventArgs object
                //RemoteEventArgs r = new RemoteEventArgs(true, MessageContainer.Sender, MyTimeKey);
                ////raise the event
                //OnIncomingMessage(r);
                //Publish the event
                PublishMessageEvent(true, MessageContainer, MyTimeKey);
                //block
                if (BlockerHeap[MyTimeKey].WaitForRelease(TimeOut))
                {
                    //if we got here, the blocking call was serviced before the timeout
                    //remove the synchronizer, as we don't need it anymore
                    BlockerHeap.Remove(MyTimeKey);
                    return true;
                }
                else
                {
                    //we ran out of time, so remove the synchronizer, and possibly the message as well
                    BlockerHeap.Remove(MyTimeKey);
                    if (RemoveOnTimeout)
                    {
                        //remove our message from the queue, as instructed
                        IncomingMessages.Remove(MyTimeKey);
                    }
                    //report failure
                    return false;
                }
            }
            else
            {
                ////construct the appropriate RemoteEventArgs object
                //RemoteEventArgs r = new RemoteEventArgs(true, MessageContainer.Sender, MyTimeKey);
                ////raise the event
                //OnIncomingMessage(r);
                //Publish the event
                PublishMessageEvent(true, MessageContainer, MyTimeKey);
                return true;
            }
#else
            //get a TwoPartySynchronizer to block on (no sweat if it's not a blocking call)
            BlockerHeap.Add(MyTimeKey, new TwoPartySynchronizer());
            try
            {
                //Use a thread to publish the event
                Thread EventThread;
                //construct the appropriate RemoteEventArgs object
                RemoteEventArgs r = new RemoteEventArgs(true, MessageContainer.Sender, MyTimeKey);
                //raise the event by turning the event publisher call into an anonymous delegate
                //, casting it as a ThreadStart, and feeding it to our thread
                EventThread = new Thread((ThreadStart)(delegate { OnIncomingMessage(r); }));
                EventThread.Start();
                //find out if this is a blocking call
                if (TimeOut > 0)
                {
                    //first, figure out when the timeout will expire
                    DateTime TimeToStop = DateTime.Now.AddMilliseconds(TimeOut);
                    //because this is a blocking call, join our event thread and record whether the join timed out
                    bool TimedOut = !EventThread.Join(TimeOut); //we use a NOT because the Join returns false if it timed out
                    if (TimedOut)
                    {
                        //we ran out of time - see if we need to remove the Message
                        if (RemoveOnTimeout)
                        {
                            //remove our Message from the queue, as instructed
                            IncomingMessages.Remove(MyTimeKey);
                        }
                        //Report the bad news
                        return false;
                    }
                    //if we got here, we didn't time out...yet. See if we are still blocked by "waiting" 1ms
                    if (BlockerHeap[MyTimeKey].WaitForRelease(1))
                    {
                        //the event listener unblocked us before returning, so report success
                        return true;
                    }
                    TimeSpan TimeLeftToWait = new TimeSpan();
                    try
                    {
                        TimeLeftToWait = TimeToStop - DateTime.Now;
                    }
                    catch
                    {
                        //an exception here is likely caused by the TimeSpan being set to negative, meaning we are out of time
                        //see if we need to remove the Message
                        if (RemoveOnTimeout)
                        {
                            //remove our Message from the queue, as instructed
                            IncomingMessages.Remove(MyTimeKey);
                        }
                        //report the bad news
                        return false;
                    }
                    //if we got here, we're still blocked, but we're not out of time yet, so feed whatever time we have left into
                    // a block
                    if (BlockerHeap[MyTimeKey].WaitForRelease((int)TimeLeftToWait.TotalMilliseconds))
                    {
                        //we were unblocked before time-out
                        return true;
                    }
                    else
                    {
                        //we ran out of time - see if we need to remove the Message
                        if (RemoveOnTimeout)
                        {
                            //remove our Message from the queue, as instructed
                            IncomingMessages.Remove(MyTimeKey);
                        }
                        //report failure
                        return false;
                    }
                }
                else
                {
                    //Leave our event thread to his own devices
                    return true;
                }
            }
            finally
            {
                //whatever happens, we returned, so we don't need the synchronizer anymore
                BlockerHeap.Remove(MyTimeKey);
            }
#endif
        }
        /// <summary>
        /// Send a file. This function is intended to be called like so "myRequestedObject.SendFile".
        /// </summary>
        /// <param name="FileContainer">The TagPathFile triplet containing the file to send</param>
        /// <param name="TimeOut">how long to block, in milliseconds, before timing out. 0 or less = non-blocking</param>
        /// <param name="RemoveOnTimeout">if true, the file is removed from the storage space in the event of a time-out</param>
        /// <returns>true if the blocking call returned before timeout was reached, otherwise false</returns>
        public bool SendFile(TagPathFileTriplet FileContainer, int TimeOut, bool RemoveOnTimeout)
        {
            //First, record the time to use as a key
            TimeKey MyTimeKey = ObtainTimeKey();
            //next, put the file in the storage space
            IncomingFiles.Add(MyTimeKey, FileContainer);
#if EVENT_PUMPS_ON
            //find out if this is a blocking call
            if (TimeOut > 0)
            {
                //get a TwoPartySynchronizer to block on
                BlockerHeap.Add(MyTimeKey, new TwoPartySynchronizer());
                ////construct the appropriate RemoteEventArgs object
                //RemoteEventArgs r = new RemoteEventArgs(true, FileContainer.Sender, MyTimeKey);
                ////raise the event
                //OnIncomingFile(r);
                //Publish the event
                PublishFileEvent(true, FileContainer, MyTimeKey);
                //block
                if (BlockerHeap[MyTimeKey].WaitForRelease(TimeOut))
                {
                    //if we got here, the blocking call was serviced before the timeout
                    //remove the synchronizer, as we don't need it anymore
                    BlockerHeap.Remove(MyTimeKey);
                    return true;
                }
                else
                {
                    //we ran out of time, so remove the synchronizer, and possibly the file as well
                    BlockerHeap.Remove(MyTimeKey);
                    if (RemoveOnTimeout)
                    {
                        //remove our file from the queue, as instructed
                        IncomingFiles.Remove(MyTimeKey);
                    }
                    //report failure
                    return false;
                }
            }
            else
            {
                ////construct the appropriate RemoteEventArgs object
                //RemoteEventArgs r = new RemoteEventArgs(true, FileContainer.Sender, MyTimeKey);
                ////raise the event
                //OnIncomingFile(r);
                //Publish the event
                PublishFileEvent(true, FileContainer, MyTimeKey);
                return true;
            }
#else
            //get a TwoPartySynchronizer to block on (no sweat if it's not a blocking call)
            BlockerHeap.Add(MyTimeKey, new TwoPartySynchronizer());
            try
            {
                //Use a thread to publish the event
                Thread EventThread;
                //construct the appropriate RemoteEventArgs object
                RemoteEventArgs r = new RemoteEventArgs(true, FileContainer.Sender, MyTimeKey);
                //raise the event by turning the event publisher call into an anonymous delegate
                //, casting it as a ThreadStart, and feeding it to our thread
                EventThread = new Thread((ThreadStart)(delegate { OnIncomingFile(r); }));
                EventThread.Start();
                //find out if this is a blocking call
                if (TimeOut > 0)
                {
                    //first, figure out when the timeout will expire
                    DateTime TimeToStop = DateTime.Now.AddMilliseconds(TimeOut);
                    //because this is a blocking call, join our event thread and record whether the join timed out
                    bool TimedOut = !EventThread.Join(TimeOut); //we use a NOT because the Join returns false if it timed out
                    if (TimedOut)
                    {
                        //we ran out of time - see if we need to remove the File
                        if (RemoveOnTimeout)
                        {
                            //remove our File from the queue, as instructed
                            IncomingFiles.Remove(MyTimeKey);
                        }
                        //Report the bad news
                        return false;
                    }
                    //if we got here, we didn't time out...yet. See if we are still blocked by "waiting" 1ms
                    if (BlockerHeap[MyTimeKey].WaitForRelease(1))
                    {
                        //the event listener unblocked us before returning, so report success
                        return true;
                    }
                    TimeSpan TimeLeftToWait = new TimeSpan();
                    try
                    {
                        TimeLeftToWait = TimeToStop - DateTime.Now;
                    }
                    catch
                    {
                        //an exception here is likely caused by the TimeSpan being set to negative, meaning we are out of time
                        //see if we need to remove the File
                        if (RemoveOnTimeout)
                        {
                            //remove our File from the queue, as instructed
                            IncomingFiles.Remove(MyTimeKey);
                        }
                        //report the bad news
                        return false;
                    }
                    //if we got here, we're still blocked, but we're not out of time yet, so feed whatever time we have left into
                    // a block
                    if (BlockerHeap[MyTimeKey].WaitForRelease((int)TimeLeftToWait.TotalMilliseconds))
                    {
                        //we were unblocked before time-out
                        return true;
                    }
                    else
                    {
                        //we ran out of time - see if we need to remove the File
                        if (RemoveOnTimeout)
                        {
                            //remove our File from the queue, as instructed
                            IncomingFiles.Remove(MyTimeKey);
                        }
                        //report failure
                        return false;
                    }
                }
                else
                {
                    //Leave our event thread to his own devices
                    return true;
                }
            }
            finally
            {
                //whatever happens, we returned, so we don't need the synchronizer anymore
                BlockerHeap.Remove(MyTimeKey);
            }
#endif
        }
        /// <summary>
        /// Request a file. This function is intended to be called like so "myRequestedObject.RequestFile". 
        /// If the full path is not provided (e.g. C:\...), the system assumes the path is relative to the 
        /// remote app's working directory.
        /// </summary>
        /// <param name="FileSource">The full path to the file, including filename</param>
        /// <param name="TimeOut">how long to block, in milliseconds, before timing out. 0 or less = non-blocking</param>
        /// <returns>a GenericFile containing the bytes of the requested file, or null if something went wrong</returns>
        public GenericFile RequestFile(string FileSource, int TimeOut)
        {
            GenericFile output = new GenericFile();
            ThreadStart t = delegate { output.Load(FileSource); };
            Thread getFile = new Thread(t);
            try
            {
                getFile.Start();
                //check to see if TimeOut is greater than 0 (indicating a desire to wait for a limited time)
                if (TimeOut > 0)
                {
                    //if .Join returns false, there was a timeout, so return null
                    if (!getFile.Join(TimeOut))
                    {
                        return null;
                    }
                }
                else
                {
                    //just wait for as long as it takes
                    getFile.Join();
                }
            }
            catch
            {
                //something went wrong - return null
                return null;
            }
            //assuming we got the file, make sure it is of non-zero size 
            //(the thread may have failed internally, leaving us no exception, but also no file)
            if (output.SizeOf < 1)
            {
                //something went wrong - return null
                return null;
            }
            else
            {
                return output;
            }
        }
        //NOTE: This summary is out of date - how???
        /// <summary>
        /// Call this to obtain the current date and time, which can be used to uniquely identify
        /// you. If multiple threads call this, it ensures that the "now" times they receive are spaced out 
        /// enough to be unique.
        /// </summary>
        /// <returns>the current time (within a few milliseconds) - used to uniquely identify the caller's subsequent actions</returns>
        public TimeKey ObtainTimeKey()
        {
            //lock for thread safety
            lock (TimeLock)
            {
                //This code provides two methods to make sure
                // incoming threads get unique timekeys.
                //If USE_TIME_DELAY is defined, calling threads wait
                // until DateTime.Now is different than the last time key
                // given out.
#if USE_TIME_DELAY
                //wait for a unique timekey
                while (DateTime.Now == LastTimeKeyGiven)
                {
                    Thread.Sleep(1);
                }
                //record this timekey so the next calling thread doesnt get it again
                LastTimeKeyGiven = DateTime.Now;
                return LastTimeKeyGiven;
#else
                //record the current DateTime
                TimeKey ToReturn = DateTime.Now;
                //Instead of waiting for a unique time, just add a few ticks to the last
                // timekey we gave out
                if (ToReturn <= LastTimeKeyGiven)
                {
                    ToReturn = LastTimeKeyGiven.AddTicks(1);
                }
                //record the timekey we gave out, so nobody else will get it again
                LastTimeKeyGiven = ToReturn;
                return ToReturn;
#endif
            }
        }
        #region event members
        #region publishers
        /// <summary>
        /// Call to trigger an incoming message event - to signal that a message has been placed in the 
        /// collection. This version can be called locally or remotely. 
        /// WARNING - using this by itself is NOT recommended
        /// </summary>
        /// <param name="r">contains important info about the process sending the message</param>
        public void OnIncomingMessage(RemoteEventArgs r)
        {
            // Make a temporary copy of the event to avoid possibility of
            // a race condition if the last subscriber unsubscribes
            // immediately after the null check and before the event is raised.
            EventHandler<RemoteEventArgs> handler = IncomingMessage;

            // Event will be null if there are no subscribers
            if (handler != null)
            {
                // Use the () operator to raise the event.
                handler(null, r);
            }
        }
        /// <summary>
        /// Call to trigger an incoming message event - to signal that a message has been placed in the 
        /// collection. This version can only be called locally. 
        /// WARNING - using this by itself is NOT recommended
        /// </summary>
        /// <param name="r">contains important info about the process sending the message</param>
        public static void StaticOnIncomingMessage(RemoteEventArgs r)
        {
            // Make a temporary copy of the event to avoid possibility of
            // a race condition if the last subscriber unsubscribes
            // immediately after the null check and before the event is raised.
            EventHandler<RemoteEventArgs> handler = IncomingMessage;

            // Event will be null if there are no subscribers
            if (handler != null)
            {
                // Use the () operator to raise the event.
                handler(null, r);
            }
        }
        /// <summary>
        /// Call to trigger an incoming file event - to signal that a file has been placed 
        /// in the collection. This version can be called locally or remotely. 
        /// WARNING - using this by itself is NOT recommended
        /// </summary>
        /// <param name="r">contains important info about the process sending the file</param>
        public void OnIncomingFile(RemoteEventArgs r)
        {
            // Make a temporary copy of the event to avoid possibility of
            // a race condition if the last subscriber unsubscribes
            // immediately after the null check and before the event is raised.
            EventHandler<RemoteEventArgs> handler = IncomingFile;

            // Event will be null if there are no subscribers
            if (handler != null)
            {
                // Use the () operator to raise the event.
                handler(null, r);
            }
        }
        /// <summary>
        /// Call to trigger an incoming file event - to signal that a file has been placed 
        /// in the collection. This version can only be called locally.
        /// WARNING - using this by itself is NOT recommended
        /// </summary>
        /// <param name="r">contains important info about the process sending the file</param>
        public static void StaticOnIncomingFile(RemoteEventArgs r)
        {
            // Make a temporary copy of the event to avoid possibility of
            // a race condition if the last subscriber unsubscribes
            // immediately after the null check and before the event is raised.
            EventHandler<RemoteEventArgs> handler = IncomingFile;

            // Event will be null if there are no subscribers
            if (handler != null)
            {
                // Use the () operator to raise the event.
                handler(null, r);
            }
        }
        #endregion
        #endregion
        //provides protection when getting time keys
        static object TimeLock = new object();
        //prevents two threads from getting the same timekey
        static TimeKey LastTimeKeyGiven = DateTime.Now;
    }
    #region helper classes

    #endregion
    #region custom event args
    /// <summary>
    /// Argument container for both incoming-file and incoming-message events
    /// </summary>
    public class RemoteEventArgs : EventArgs
    {
        /// <summary>
        /// The tag of the process that initiated this event
        /// </summary>
        public readonly ProcessTag Initiator;
        /// <summary>
        /// If true, the initiator is waiting for an ACK on the file/message that triggered
        ///  this event.
        /// </summary>
        public readonly bool Blocking;
        /// <summary>
        /// The TimeKey the initiator was given when it first sent the file/message. 
        /// This can be used to release it from blocking and to identify the thing it sent 
        /// in the proper storage space (messages and files are stored in their respective 
        /// dictionaries with TimeKeys as keys
        /// </summary>
        public readonly TimeKey InitiatorTimeKey;
        /// <summary>
        /// Construct a RemoteEventArgs for an event
        /// </summary>
        /// <param name="blockingBool">true if the process triggering this event is going to wait for an ACK on the file/message it sent</param>
        /// <param name="theInitiator">the tag of the process that initiated the event by sending a file/message</param>
        /// <param name="theTimeKey">the TimeKey given to the initiator, used to identify it and whatever it sent</param>
        public RemoteEventArgs(bool blockingBool, ProcessTag theInitiator, TimeKey theTimeKey)
        {
            Initiator = theInitiator;
            Blocking = blockingBool;
            InitiatorTimeKey = theTimeKey;
        }
    }
    #endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\Titanium\Titanium\TimingConstants.cs ===
﻿namespace Wgx.Test.Solutions.MessengerGames.Library.API.Mercury
{
    public struct MillisecondTimes
    {
        //WARNING - do not use VS "Format Document" on this, or the alignment will be lost
        public const int EIGHTH_OF_A_SECOND =           125;
        public const int QUARTER_SECOND =               250;
        public const int HALF_SECOND =                  500;
        public const int ONE_SECOND =                  1000;
        public const int TWO_SECONDS =                 2000;
        public const int THREE_SECONDS =               3000;
        public const int FOUR_SECONDS =                4000;
        public const int FIVE_SECONDS =                5000;
        public const int TEN_SECONDS =                10000;
        public const int FIFTEEN_SECONDS =            15000;
        public const int HALF_MINUTE =                30000;
        public const int ONE_MINUTE =                 60000;
        public const int TWO_MINUTES =               120000;
        public const int FIVE_MINUTES =              300000;
        public const int TEN_MINUTES =               600000;
        public const int TWENTY_MINUTES =           1200000;
        public const int HALF_HOUR =                1800000;
        public const int FORTY_FIVE_MINUTES =       2700000;
        public const int ABOUT_TWENTY_FIVE_DAYS = int.MaxValue;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\UITest\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\Titanium\Titanium\TitaniumConfigFile.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml;
using TCF = Titanium.WritableTitaniumConfigFile;

namespace Titanium
{
    /// <summary>
    /// This class globalizes TitaniumConfig and grants write-access to anyone within THIS namespace. 
    /// NOTE: this class expects a TitaniumConfig.xml file to be present in API/exe's home directory.
    /// </summary>
    static class WritableTitaniumConfigFile
    {
        static object basicFileLock = new object();
        #region public "members"
        /// <summary>
        /// The raw Xml document. 
        /// </summary>
        public static XmlDocument TConfigXmlDoc
        {
            get
            {
                lock (basicFileLock)
                {
                    //if the object is null, then this is our first access, and the file needs to be loaded
                    if (tConfigXmlDoc == null)
                    {
                        tConfigXmlDoc = new XmlDocument();
                        tConfigXmlDoc.Load("TitaniumConfig.xml");
                    }
                }
                return tConfigXmlDoc;
            }
            set
            {
                tConfigXmlDoc = value;
            }
        }
        /// <summary>
        /// The root element of TitaniumConfig
        /// </summary>
        public static XmlNode Root
        {
            get
            {
                //by making this call TConfigXmlDoc, and by making all other
                // properties call this, we make sure that nobody accesses
                // a null config doc - if the doc is null, TConfigXmlDoc will trigger
                // a load
                return TConfigXmlDoc.DocumentElement;
            }
        }
        /// <summary>
        /// Defines a list of nodes that can't be overridden
        /// </summary>
        public static string[] NonOverridableNodes = new string[] { "Remoting" };
        /// <summary>
        /// Parameters pertaining to remoting, such as the port number Titanium.exe can listen on
        /// </summary>
        public static RemotingSection RemotingParams = new RemotingSection();
        #endregion
        #region public functions
        /// <summary>
        /// Reload the TitaniumConfig.xml file
        /// </summary>
        public static void RefreshTitaniumConfig()
        {
            //reload the file from the xml
            TConfigXmlDoc.Load("TitaniumConfig.xml");
        }
        #endregion
        #region storage members - not to be used, not even internally. Use the public counterparts, as they ensure non-null values
        static XmlDocument tConfigXmlDoc = null; //stores the document
        #endregion
    }

    /// <summary>
    /// A wrapper class to make it easier to get important information from the remoting section of
    /// TitaniumConfig.xml
    /// </summary>
    class RemotingSection
    {
        /// <summary>
        /// The "root" of the remoting section - all remoting info is a descendent of this node
        /// </summary>
        public XmlNode Root
        {
            get
            {
                return TCF.Root["Remoting"];
            }
        }
        /// <summary>
        /// The time between checks by the watchdog for dead/halted processes
        /// </summary>
        public TimeSpan WatchdogPeriod
        {
            get
            {
                if(period == TimeSpan.Zero)
                {
                    int hours = int.Parse(Root["WatchdogPeriod"].Attributes["Hours"].Value);
                    int minutes = int.Parse(Root["WatchdogPeriod"].Attributes["Minutes"].Value);
                    int seconds = int.Parse(Root["WatchdogPeriod"].Attributes["Seconds"].Value);
                    period = new TimeSpan(hours, minutes, seconds);
                }
                return period;
            }
        }
        /// <summary>
        /// The port on which the local Titanium.exe will listen
        /// </summary>
        public int TitaniumPort
        {
            get
            {
                return int.Parse(Root["TitaniumPort"].InnerText);
            }
        }
        /// <summary>
        /// DDefines the beginning of the range of ports the Titanium API can 
        /// grant to server processes. NOTE: this is an inclusive range at both ends.
        /// </summary>
        public int StartingServerPort
        {
            get
            {
                return int.Parse(Root["ServerPorts"].Attributes["Start"].Value);
            }
        }
        /// <summary>
        /// Defines the end of the range of ports the Titanium API can grant
        ///  to server processes. NOTE: this is an inclusive range at both ends.
        /// </summary>
        public int EndingServerPort
        {
            get
            {
                return int.Parse(Root["ServerPorts"].Attributes["End"].Value);
            }
        }
        TimeSpan period = TimeSpan.Zero;
    }
    /// <summary>
    /// This class globalizes a read-only copy of TitaniumConfig
    /// </summary>
    public static class TitaniumConfigFile
    {
        /// <summary>
        /// Gets a read-only copy of the TitaniumConfig xml
        /// </summary>
        public static XmlDocument TConfigXmlDoc
        {
            get
            {
                //return a clone to prevent any kind of write-access
                return (XmlDocument)TCF.TConfigXmlDoc.Clone();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\Titanium\Titanium\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Titanium")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("b5b83ec2-21f0-4253-a499-dd1025aa99b2")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\Titanium\Titanium\TLogger.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;
using Microsoft.DistributedAutomation.Logger;
using System.IO;

namespace Titanium
{
    /// <summary>
    /// Allows labeling of the severity of errors/exceptions in the public log
    /// </summary>
    public enum SeverityLevel
    {
        ProgramKiller = 1,
        SuiteKiller = 2,
        TestKiller = 3,
        TestRetry = 4,
        JustFYI = 5
    }
    /// <summary>
    /// Allows filtering of messages in the private log by importance. Note: 
    /// if the verbose level of a message is higher than the verbose level of the 
    /// log, that message WILL NOT BE LOGGED
    /// </summary>
    public enum VerboseLevel
    {
        /// <summary>
        /// Anything that must not be ignored - e.g. errors that are unexpected or 
        /// could throw the whole program off track -or- success of a vital process
        /// </summary>
        CriticalMessages = 1,
        /// <summary>
        /// Success/failure of important steps - especially if the program can compensate 
        /// for the failure.
        /// </summary>
        GeneralMessages = 2, 
        /// <summary>
        /// Suspected-spurious errors or sub-steps in a process. Also messages that are 
        /// only needed during development
        /// </summary>
        DebugChatter = 3
    }
    /// <summary>
    /// Contains functions for internal logging - basically wrappers for TRACE
    /// </summary>
    public static class TInternalLogger
    {
        /// <summary>
        /// Allows filtering of messages by msgVerbosityLevel. Higher = more verbose = less important 
        /// messages get recorderd. NOTE: if Verbosity is set lower, less-vital messages will be 
        /// IGNORED (i.e. not logged at all)
        /// </summary>
        public static int Verbosity = 3;
        /// <summary>
        /// Log an error
        /// </summary>
        /// <param name="message">What went wrong</param>
        /// <param name="msgVerbosityLevel">Allows filtering of lesser messages</param>
        public static void LogError(string message, VerboseLevel msgVerbosityLevel)
        {
            //convert the enum to its corresponding int value, then call the base
            // function to do the work
            LogError(message, (int)msgVerbosityLevel);
        }
        /// <summary>
        /// Log an error
        /// </summary>
        /// <param name="message">What went wrong</param>
        /// <param name="msgVerbosityLevel">Allows filtering of lesser messages</param>
        public static void LogError(string message, int msgVerbosityLevel)
        {
            if (msgVerbosityLevel <= Verbosity)
            {
                TimeStamp();
                Trace.Write("Error: ");
                Trace.WriteLine(message);
            }
        }
        /// <summary>
        /// Log a message
        /// </summary>
        /// <param name="message">The content of the message</param>
        /// <param name="msgVerbosityLevel">Allows filtering of lesser messages</param>
        public static void LogMessage(string message, VerboseLevel msgVerbosityLevel)
        {
            //convert the enum to its corresponding int value, then call the base
            // function to do the work
            LogMessage(message, (int)msgVerbosityLevel);
        }
        /// <summary>
        /// Log a message
        /// </summary>
        /// <param name="message">The content of the message</param>
        /// <param name="msgVerbosityLevel">Allows filtering of lesser messages</param>
        public static void LogMessage(string message, int msgVerbosityLevel)
        {
            if (msgVerbosityLevel <= Verbosity)
            {
                TimeStamp();
                Trace.Write("Message: ");
                Trace.WriteLine(message);
            }
        }
        /// <summary>
        /// Log an exception
        /// </summary>
        /// <param name="ex">The exception to be logged</param>
        /// <param name="msgVerbosityLevel">Allows filtering of lesser messages</param>
        public static void LogException(Exception ex, VerboseLevel msgVerbosityLevel)
        {
            //convert the enum to its corresponding int value, then call the base
            // function to do the work
            LogException(ex, (int)msgVerbosityLevel);
        }
        /// <summary>
        /// Log an exception
        /// </summary>
        /// <param name="ex">The exception to be logged</param>
        /// <param name="msgVerbosityLevel">Allows filtering of lesser messages</param>
        public static void LogException(Exception ex, int msgVerbosityLevel)
        {
            if (msgVerbosityLevel <= Verbosity)
            {
                TimeStamp();
                Trace.WriteLine("Exception occured");
                Trace.WriteLine("Message: " + ex.Message);
                Trace.WriteLine("Stack trace: " + ex.StackTrace);
                if (ex.InnerException != null)
                {
                    Trace.Indent();
                    Trace.WriteLine("Inner exception");
                    Trace.WriteLine("Message: " + ex.InnerException.Message);
                    Trace.WriteLine("Stack trace: " + ex.InnerException.StackTrace);
                    Trace.Unindent();
                }
            }
        }
        static bool ConsoleListenerEnabled = false; //keep us from enabling the console listener multiple times
        /// <summary>
        /// Attaches a console listener to the TRACE - causes all 
        /// internal logging messages to be repeated to the console's standard 
        /// output. Requiring the programmer to enable this listener manually 
        /// avoids problems with Titanium-based programs that don't have a console.
        /// </summary>
        public static void EnableConsoleListener()
        {
            //see if the console listener already exists
            if (ConsoleListenerEnabled)
            {
                LogError("Attempted to enable already-enabled console listener", VerboseLevel.DebugChatter);
                return;
            }
            //if we got this far, it doesn't, so enable it
            Trace.Listeners.Add(new ConsoleTraceListener());
            //set this to true so we don't enable more than one
            ConsoleListenerEnabled = true;
            LogMessage("Console listener enabled", VerboseLevel.DebugChatter);
        }
        /// <summary>
        /// Write the current date and time (format example: 12_11_2009 12-33-42 AM) to 
        /// the current line of the TRACE. 
        /// </summary>
        static void TimeStamp()
        {
            Trace.Write(DateTime.Now.ToString("MM_d_yyyy hh-mm-ss tt") + " ");
        }
        #region auto-init hack
        /*
         * Hacky McHack says "This region contains a static boolean 
         * that is initialized on assembly-load by a function. This 
         * function's TRUE purpose is to setup the trace listeners."
         * Hacky McHack adds "At some point, we might want to retool this 
         * so the boolean actually means something and is used somewhere, 
         * e.g true = AutoInit worked, false = AutoInit failed. Alternatively, 
         * AutoInit could return an int, which would be used to initialize 
         * Verbosity, thus killing two birds with one stone and removing the 
         * need for an otherwise useless boolean and the function that pretends 
         * to care about it."
         */
        //Hacky McHack says "This bool only exists so the consuming exe will 
        // call AutoInitialize on startup"
        static bool UsingAutoInit = AutoInitialize();
        /// <summary>
        /// This is automatically called (through a hack) to setup 
        /// the internal logger (probably a trace-listener)
        /// </summary>
        /// <returns>true or false, at random</returns>
        static bool AutoInitialize()
        {
            //Setup the trace listener(s)
            Trace.AutoFlush = true;
            //Trace.Listeners.Add(new ConsoleTraceListener());
            Trace.Listeners.Add(new TextWriterTraceListener("TitaniumInternalLog.txt"));
            //Return true, since the bool is called UsingAutoInit
            return true;
        }
        //Hacky McHack says "We pretend to 'use' this variable so as not to 
        // get any warnings from the compiler about it"
        static void PlacateMSBuild()
        {
            //Pretend to care about this variable to avoid build-breaking warnings
            if (UsingAutoInit)
            {
                //Do something (not really)
            }
            else
            {
                //Do something else (not realy)
            }
        }
        #endregion
    }
    public static class TLogger
    {
        #region Logger vars
        static TestLogger WTT_Tinatium = null;
        //important note - pretty much any result other than blocked or failed gets counted as a pass
        // This is why Blocked was chosen as the default, it being the closest appriximation to "InfraFail"
        const TestResult DefaultResult = TestResult.Blocked;
        const string DefaultReproString = "Unknown Failure"; //if this is default, noone set it, which means something went wrong
        static TestResult CurrentTestResult = DefaultResult;
        //Hacky McHack says "We're going to use the repro string as a sort of closing remark for a test"
        static string TestReproString = DefaultReproString; //the value that will go into the repro string of a closing test
        //static string CurrentConfig = "";
        //static string CurrentSuite = "";
        //static string CurrentTest = "";
        #endregion
        #region internal functions
        #region config file functions
        internal static void LogConfigFileOpened()
        {
            if (WTT_Tinatium == null)
            {
                //no point in continuing if logging hasn't been turned on
                TInternalLogger.LogError("Attempt to log information without initializing log", VerboseLevel.DebugChatter);
                return;
            }
            beginFileCalled = true; //set this flag to show we've started logging a config file
            //Do the actual logging
            WTT_Tinatium.StartContext(TestConfigFile.FullPath);
            WTT_Tinatium.Trace(new LevelMessage("Now opening config file: " + TestConfigFile.FullPath));
        }
        internal static void LogConfigFileClosed()
        {
            if (WTT_Tinatium == null)
            {
                //no point in continuing if logging hasn't been turned on
                TInternalLogger.LogError("Attempt to log information without initializing log", VerboseLevel.DebugChatter);
                return;
            }
            if (!beginFileCalled)
            {
                //we never started logging a file, so we can't finish logging it either
                return;
            }
            else
            {
                //call the next "End" function, which will cap logging for 
                //the current suite if needed
                LogEndSuite();
                beginFileCalled = false; //clear this flag
                //Do the actual logging
                //This makes the assumption that TLogger has correctly reset the context to the config-file level
                WTT_Tinatium.Trace(new LevelMessage("Now closing config file: " + TestConfigFile.FullPath));
                WTT_Tinatium.EndContext(TestConfigFile.FullPath);
            }
        }
        #endregion
        #region suite functions
        internal static void LogBeginSuite()
        {
            if (WTT_Tinatium == null)
            {
                //no point in continuing if logging hasn't been turned on
                TInternalLogger.LogError("Attempt to log information without initializing log", VerboseLevel.DebugChatter);
                return;
            }
            if (!beginFileCalled)
            {
                //we're trying to log a suite without logging the file it came from
                //Throw an exception
                throw new System.Exception("ERROR: Attempt to start logging a suite without logging its config file");
            }
            else
            {
                beginSuiteCalled = true; //set this flag to show we've started logging a suite
                //Do the actual logging
                WTT_Tinatium.StartContext(TestConfigFile.InternalSelectedSuite.Title);
                //Hacky McHack says "Tracing the outer XML of the suite's GlobalInfoNode is a clumsy, but
                // cheap way to record all its info in one go. This should be replaced, as it makes an awful 
                // mess in the log"
                WTT_Tinatium.Trace(new LevelMessage("Beginning suite: " + TestConfigFile.InternalSelectedSuite.Title, TestConfigFile.InternalSelectedSuite.GlobalInfoNodeAsXML.OuterXml));
            }
        }
        internal static void LogEndSuite()
        {
            if (WTT_Tinatium == null)
            {
                //no point in continuing if logging hasn't been turned on
                TInternalLogger.LogError("Attempt to log information without initializing log", VerboseLevel.DebugChatter);
                return;
            }
            if (!beginSuiteCalled)
            {
                //we never started logging a suite, so we can't finish logging it either
                return;
            }
            else
            {
                //Call the next "End" function, which will cap logging for 
                // the current test if needed
                LogEndTest();
                beginSuiteCalled = false; //clear this flag
                //Do the actual logging
                //This assumes TLogger has reset the context correctly
                WTT_Tinatium.Trace(new LevelMessage("Concluding suite: " + TestConfigFile.InternalSelectedSuite.Title));
                WTT_Tinatium.EndContext(TestConfigFile.InternalSelectedSuite.Title);
            }
        }
        #endregion
        #region test functions
        internal static void LogBeginTest()
        {
            if (WTT_Tinatium == null)
            {
                //no point in continuing if logging hasn't been turned on
                TInternalLogger.LogError("Attempt to log information without initializing log", VerboseLevel.DebugChatter);
                return;
            }
            if (!beginSuiteCalled)
            {
                //we're trying to log a test without logging the suite it comes from
                //Throw an exception
                throw new System.Exception("ERROR: Attepted to start logging a test without logging its suite");
            }
            else
            {
                beginTestCalled = true; //set this flag to show we've started logging a test
                //Do the actual logging
                WTT_Tinatium.StartTest(TestConfigFile.InternalSelectedSuite.SelectedTest.TestName);
                //write the xml of the test case...at least 'til we think of a better way to report its key info
                WTT_Tinatium.Trace(new LevelMessage(TestConfigFile.InternalSelectedSuite.SelectedTest.RawXmlTestCase.OuterXml));
                //Console.WriteLine("Beginning test: " + TestConfigFile.InternalSelectedSuite.SelectedTest.RawXmlTestCase.OuterXml);
            }
        }
        internal static void LogEndTest()
        {
            if (WTT_Tinatium == null)
            {
                //no point in continuing if logging hasn't been turned on
                TInternalLogger.LogError("Attempt to log information without initializing log", VerboseLevel.DebugChatter);
                return;
            }
            if (!beginTestCalled)
            {
                //we never started logging a test, so we can't finish logging it either
                return;
            }
            else
            {
                //There is no "End" function below this level, so nothing to call
                beginTestCalled = false; //clear this flag
                //Do the actual logging
                WTT_Tinatium.Trace(new LevelMessage("Concluding test number " + TestConfigFile.InternalSelectedSuite.Trial));
                WTT_Tinatium.EndTest(TestConfigFile.InternalSelectedSuite.SelectedTest.TestName, CurrentTestResult, TestReproString);
                //reset the appropriate variables
                TestReproString = DefaultReproString;
                CurrentTestResult = DefaultResult;
                //Console.WriteLine("Ending test: " + TestConfigFile.InternalSelectedSuite.SelectedTest.RawXmlTestCase.OuterXml);
            }
        }
        #endregion
        #endregion

        #region public members
        /// <summary>
        /// Log an exception.
        /// </summary>
        /// <param name="ex">The exception to be logged</param>
        public static void LogException(System.Exception ex)
        {
            if (WTT_Tinatium == null)
            {
                //no point in continuing if logging hasn't been turned on
                TInternalLogger.LogError("Attempt to log information without initializing log", VerboseLevel.DebugChatter);
                return;
            }
            //Do the logging
            WTT_Tinatium.Trace(new LevelMessage("Exception: ", ex));
        }
        /// <summary>
        /// Log an error message. The error will be logged as 
        /// "Sev " + severity + " error: " + errorMessage
        /// </summary>
        /// <param name="errorMessage">the message describing the error</param>
        /// <param name="severity">ProgramKiller is the highest severity</param>
        public static void LogError(string errorMessage, SeverityLevel severity)
        {
            LogError(errorMessage, (int)severity);
        }
        /// <summary>
        /// Log an error message. The error will be logged as 
        /// "Sev " + severity + " error: " + errorMessage
        /// </summary>
        /// <param name="errorMessage">the message describing the error</param>
        /// <param name="severity">1 is the highest severity</param>
        public static void LogError(string errorMessage, int severity)
        {
            if (WTT_Tinatium == null)
            {
                //no point in continuing if logging hasn't been turned on
                TInternalLogger.LogError("Attempt to log information without initializing log", VerboseLevel.DebugChatter);
                return;
            }
            //Do the logging
            WTT_Tinatium.Trace(new LevelMessage("Sev " + severity + " error: " + errorMessage));
        }
        /// <summary>
        /// Log a basic string message
        /// </summary>
        /// <param name="message">The message to log</param>
        public static void LogMessage(string message)
        {
            if (WTT_Tinatium == null)
            {
                //no point in continuing if logging hasn't been turned on
                TInternalLogger.LogError("Attempt to log information without initializing log", VerboseLevel.DebugChatter);
                return;
            }
            //Do the logging
            WTT_Tinatium.Trace(new LevelMessage(message));
        }
        /// <summary>
        /// Log the success of a test - this CANNOT be called if a test case 
        /// has not been selected.
        /// </summary>
        /// <param name="message">Closing remarks about the test, if any</param>
        public static void LogSuccess(string message)
        {
            if (WTT_Tinatium == null)
            {
                //no point in continuing if logging hasn't been turned on
                TInternalLogger.LogError("Attempt to log information without initializing log", VerboseLevel.DebugChatter);
                return;
            }
            if (!beginTestCalled)
            {
                TInternalLogger.LogError("Attempt to log test result outside the context of a test", VerboseLevel.CriticalMessages);
                throw new System.Exception("Error: attempt to log test result without starting a test");
            }
            //Do the logging - does LogSuccess write the result to the log, or does LogEndTest?
            CurrentTestResult = TestResult.Pass;
            TestReproString = message;
            //A success indicates the end of a test, so call the "End" function
            LogEndTest();
        }
        /// <summary>
        /// Log the failure of a test - this CANNOT be called if a 
        /// test case has not been selected.
        /// </summary>
        /// <param name="message">Generally, a brief message explaining the failure</param>
        public static void LogFailure(string message)
        {
            if (WTT_Tinatium == null)
            {
                //no point in continuing if logging hasn't been turned on
                TInternalLogger.LogError("Attempt to log information without initializing log", VerboseLevel.DebugChatter);
                return;
            }
            if (!beginTestCalled)
            {
                TInternalLogger.LogError("Attempt to log test result outside the context of a test", VerboseLevel.CriticalMessages);
                throw new System.Exception("Error: attempt to log test result without starting a test");
            }
            //Do the logging - does LogFailure write the result to the log, or does LogEndTest?
            CurrentTestResult = TestResult.Fail;
            TestReproString = message;
            //A failure indicates the end of a test, so call the "End" function
            LogEndTest();
        }
        /// <summary>
        /// Log a failure of the test infrastructure (hence the name, 
        /// which is short for INFRAstructure FAILure). This should 
        /// be called when the failure was external to the object being 
        /// tested (e.g. testing a network game and the network goes down)
        /// </summary>
        /// <param name="message">Generally, a brief message explaining the failure</param>
        public static void LogInfraFail(string message)
        {
            if (WTT_Tinatium == null)
            {
                //no point in continuing if logging hasn't been turned on
                TInternalLogger.LogError("Attempt to log information without initializing log", VerboseLevel.DebugChatter);
                return;
            }
            if (!beginTestCalled)
            {
                TInternalLogger.LogError("Attempt to log test result outside the context of a test", VerboseLevel.CriticalMessages);
                throw new System.Exception("Error: attempt to log test result without starting a test");
            }
            //Do the logging - does LogInfraFail write the result to the log, or does LogEndTest?
            CurrentTestResult = TestResult.Blocked;
            TestReproString = message;
            //An infrafail indicates the end of a test, so call the "End" function
            LogEndTest();
        }
        #region File methods
        /// <summary>
        /// Open (or create) the various log files.
        /// </summary>
        /// <param name="logname">This name will be given to any custom-nameable log files 
        /// (e.g. passing "ThisName" could create/open "ThisName.txt" AND "ThisName.wtt" and "ThisName.someOtherFormat"</param>
        /// <param name="logpath">The path to where the files are to be created/opened</param>
        /// <param name="appendIfTrue">If true, any files that can be opened in Append mode will be so opened</param>
        public static void BeginLogging(string logname, string logpath, bool appendIfTrue)
        {
            //Open or create the various logs
            //begin building the device string for WTT and txt logging
            //determine the writemode
            string writemode;
            if (appendIfTrue)
            {
                writemode = "writemode=writeappend";
            }
            else
            {
                writemode = "writemode=overwrite";
            }
            //determine the path to the log files (extensions will be added later)
            string LogPathAndFile = Path.Combine(logpath, logname);
            //Start the device string with the WTT log particulars
            string deviceString = "$logfile:file=\"" + LogPathAndFile + ".wtl\",encoding=UNICODE,";
            deviceString += writemode + ";";
            //Add the particulars for the txt log
            deviceString += "$plainlog:file=\"" + LogPathAndFile + ".log\",encoding=ANSI,";
            deviceString += writemode;
            //Initalize the logger
            WTT_Tinatium = new TestLogger(deviceString);
            //Trace the machine info
            WTT_Tinatium.TraceMachineInfo();
        }
        /// <summary>
        /// Finalizes any logs that need finalizing
        /// </summary>
        public static void EndLogging()
        {
            if (WTT_Tinatium == null)
            {
                //no point in continuing if logging hasn't been turned on
                TInternalLogger.LogError("Attempt to log information without initializing log", VerboseLevel.DebugChatter);
                return;
            }
            //reset variables and flags, as well as logging the end of test, suite, and config file
            //QUESTION: do we want to call this in EndLogging? What if the user wants to keep testing but stop logging?
            LogConfigFileClosed();
            WTT_Tinatium.Dispose();
            WTT_Tinatium = null;
        }
        #endregion
        #endregion
        #region private variables
        #region file paths
        //static string wttLog = "";
        //static string vstsLog = "";
        //static string txtLog = "";
        //static string xmlLog = "";
        #endregion
        #region flags
        //if any of these are true, it indicates that we have begun to log 
        // the corresponding context (e.g. beginFileCalled means we've started 
        // logging stuff under a new TestConfigFile)
        static bool beginFileCalled = false;
        static bool beginSuiteCalled = false;
        static bool beginTestCalled = false;
        #endregion
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\UITest\AboutBlankPage.cs ===
﻿using System;
using Test.Common.Library.UITest.Exceptions;

namespace Test.Common.Library.UITest
{
    /// <summary>
    /// Generic blank page.
    /// </summary>
    public class AboutBlankPage : WebPage
    {
        #region Initialization
        /// <summary>
        /// Initializes a blank page and sets default title and Uri.
        /// </summary>
        public AboutBlankPage() : base()
        {
            this.Title = "Blank Page";
            this.Uri = new Uri("about:Blank");
        }
        #endregion

        #region Private Methods
        /// <summary>
        /// Checks if the web browser title matches the expected title as defined by the class.
        /// </summary>
        protected internal override void  WaitForLoadComplete()
        {
            int trial = 5;
            int waitTime = 15;
            while (trial > 0)
            {
                if (WebBrowserFactory.CurrentBrowser.Title != this.Title)
                {
                    Logger.WriteLine(string.Format("{0} not fully loaded. Waiting {1} seconds.", this.Title, waitTime));
                    UITestManager.Wait(waitTime * 1000);
                    trial--;
                }
                else
                {
                    return;
                }
            }
            Logger.WriteException(new PageTimeOutException(trial * waitTime), true);
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\Titanium\Titanium\TitaniumServer.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Runtime.Serialization.Formatters.Binary;
using System.Runtime.Remoting;
using System.Runtime.Remoting.Channels;
using System.Runtime.Remoting.Channels.Http;
using System.Runtime.Remoting.Channels.Tcp;
using System.Diagnostics;
using System.Threading;
using System.Timers;
using MST = Wgx.Test.Solutions.MessengerGames.Library.API.Mercury.MillisecondTimes;
using TCF = Titanium.WritableTitaniumConfigFile;

namespace Titanium
{
    /// <summary>
    /// The object within the running Titanium.exe. It provides functions for 
    /// interactions between Titanium.exe and other processes, allowing them to 
    /// use the communication and control functionality.
    /// </summary>
    public class TitaniumServer : MarshalByRefObject
    {
        /// <summary>
        /// The background process that allows one Titanium test machine to communicate 
        /// with and control another. It provides watchdog services for restarting dead 
        /// processes and keeps track of which ports are in use from its list of usable ports.
        /// </summary>
        /// <param name="args">the standard array of cmdline args</param>
        static void Main(string[] args)
        {
            #region get the range of ports from the config file and initialize all variables we can
            //get the first port in the range
            int firstPort = TCF.RemotingParams.StartingServerPort;
            //get the last port in the range
            int lastPort = TCF.RemotingParams.EndingServerPort;
            #region setup the port variables
            freePortCount = 0;
            ports = new Dictionary<int, bool>();
            for (int i = firstPort; i <= lastPort; i++)
            {
                freePortCount++;
                //add this port to the dictionary and set its InUse value to false
                ports.Add(i, false);
            }
            #endregion
            //initialize the list of processes under guard
            processesUnderGuard = new Dictionary<Process, StartupInstructions>();
            //initialize the list of servers
            registeredServers = new List<ServerIDCard>();
            #region setup and start the watchdog
            SetupWatchdog();
            #endregion
            #endregion
            try
            {
                //Start serving the TitaniumServer object
                InterProcessTools.ServeThisObject(typeof(TitaniumServer), TitaniumPort, "TitaniumServer", true);
            }
            catch (System.Exception ex)
            {
                Console.WriteLine("Exception while trying to serve remote object:");
                Console.WriteLine(ex.Message);
                Console.WriteLine(ex.StackTrace);
                Console.WriteLine("press ENTER to exit");
                Console.ReadLine();
            }
            //wait for the user to say exit
            Console.WriteLine("type 'exit' to exit");
            string command = "";
            while (command != "exit")
            {
                command = Console.ReadLine();
            }
            StopWatchDog();
        }
        #region remotely accessible stuff
        /// <summary>
        /// Fetch a list of ServerIDCards from server proceses registered with 
        /// the remote host's Titanium.exe
        /// </summary>
        /// <param name="HostName">the machine name of the remote host to contact</param>
        /// <returns>a list of ServerIDCards for servers registered on the remote host</returns>
        public ServerIDCardList FetchRemoteHostServerList(string HostName)
        {
            TitaniumServer QueryTarget = ContactRemoteServer(HostName);
            return new ServerIDCardList(QueryTarget.RegisteredServers);
        }
        #region registration
        /// <summary>
        /// Registers the process with ThisProcessID to be watched by Titanium for failure or freeze.
        /// Server exes do not need to call this; it is automatically called by the overloaded 
        /// version of RegisterServer when the caller provides a path to an SI file
        /// </summary>
        /// <param name="ThisProcessID">the ID of the process that needs watching</param>
        public void RegisterForWatchDog(int ThisProcessID, string PathToStartupInstructions)
        {
            lock (processesUnderGuard)
            {
                Process thisProcess = Process.GetProcessById(ThisProcessID);
                if (thisProcess != null)
                {
                    #region make sure not to let anyone register twice
                    if (!processesUnderGuard.Keys.Contains(thisProcess))
                    {
                        StartupInstructions tempSI = new StartupInstructions(PathToStartupInstructions);
                        processesUnderGuard.Add(thisProcess, tempSI);
                        Console.WriteLine("Register for watchdog: " + thisProcess.ProcessName);
                    }
                    #endregion
                }
            }
        }
        //NOTE: Update comment when upgrading
        /// <summary>
        /// Register the process with ThisProcessID as a server of a RemoteInterface object. 
        /// This is currently the only way to get a ServerIDCard with a valid port number. NOTE:
        ///  RegisterServer expects the calling process to be serving 
        ///  either a RemoteInterface or some descendent thereof. FURTHER NOTE: 
        ///  RegisterServer does not initiate the serving of any objects - it simply declares 
        ///  your intent to serve and gives you (among other things) a valid port on which to listen.
        /// </summary>
        /// <param name="ThisProcessID">the ID of the process trying to register as a server</param>
        /// <returns>a valid ServerIDCard for this process, or null if something went awry</returns>
        public ServerIDCard RegisterServer(int ThisProcessID)
        {
            //register with no startup-instructions path
            return RegisterServer(ThisProcessID, "");
        }
        /// <summary>
        /// Register the process with ThisProcessID as a server of a RemoteInterface object. 
        /// This is currently the only way to get a ServerIDCard with a valid port number. Given 
        /// a path to a .si file, this overload will also register the process with Titanium's watch
        /// -dog service. NOTE: RegisterServer expects the calling process to be serving 
        ///  either a RemoteInterface or some descendent thereof. FURTHER NOTE: 
        ///  RegisterServer does not initiate the serving of any objects - it simply declares 
        ///  your intent to serve and gives you (among other things) a valid port on which to listen.
        /// </summary>
        /// <param name="ThisProcessID">the ID of the process trying to register as a server</param>
        /// <param name="PathToStartupInstructions">the path to the StartupInstructions file maintained by this process. Leave this as "" if you don't want watchdog services</param>
        /// <returns>a valid ServerIDCard for this process, or null if something went awry</returns>
        public ServerIDCard RegisterServer(int ThisProcessID, string PathToStartupInstructions)
        {
            lock (registerLock)
            {
                ServerIDCard CallersCard = null;
                Process thisProcess = Process.GetProcessById(ThisProcessID);
                #region make sure this one isnt already registered as a server or client
                foreach (ServerIDCard server in registeredServers)
                {
                    if (server.ProcessID == ThisProcessID)
                    {
                        //this server is already registered
                        return null;
                    }
                }
                #endregion
                #region try to fetch a port number for this guy
                if (freePortCount < 1)
                {
                    //no free ports
                    return null;
                }
                //find the first free port
                int tempPort = FindFreePort();
                //use it to initialize the ID card
                CallersCard = new ServerIDCard(tempPort, ThisProcessID);
                //tell the system that this port is no longer free
                ports[tempPort] = true;
                freePortCount--;
                #endregion
                //add this guy to the list of servers
                registeredServers.Add(CallersCard);
                Console.WriteLine("Registering server: " + CallersCard.ProcessName + " " + CallersCard.PortNum);
                if (PathToStartupInstructions != "")
                {
                    RegisterForWatchDog(ThisProcessID, PathToStartupInstructions);
                }
                return CallersCard;
            }
        }
        /// <summary>
        /// Removes this process from the watchdog list so it can be closed gracefully.
        /// Channels cannot be destroyed at this time, so they are only reclaimed when 
        /// the server process goes out of scope. NOTE: nothing bad happens if the proces
        ///  we are trying to deregister was not registered in the first place.
        /// </summary>
        /// <param name="thisProcess">the ID of the calling process</param>
        public void DeRegister(int thisProccessID)
        {
            lock (processesUnderGuard)
            {
                int stop = processesUnderGuard.Count;
                Process p;
                for (int i = 0; i < stop; i++)
                {
                    p = processesUnderGuard.Keys.ElementAt(i);
                    if (p.Id == thisProccessID)
                    {
                        processesUnderGuard.Remove(p);
                        Console.WriteLine("Deregistering: " + p.ProcessName);
                    }
                }
            }
        }
        #endregion
        #region file transfer
        /// <summary>
        /// Request a file from the source path on the remote host and put it in the destination path on the local machine. 
        /// Note: if a drive letter is not specified, all paths are relative to the home directory of the Titanium.exe.
        /// Note: if destination is set to "", the file will not be saved locally, only returned as an object
        /// </summary>
        /// <param name="sourcePath">The complete path to the file on the remote computer (e.g. C:\something something\something.someExtension)</param>
        /// <param name="destinationPath">The complete path to the file on the local computer (e.g. C:\SomeName.someExtension)</param>
        /// <param name="remoteHost">The machine name of the remote host</param>
        /// <returns>an object containing all the bytes from the requested file, or null if something went wrong</returns>
        public GenericFile RequestFile(string sourcePath, string destinationPath, string remoteHost)
        {
            GenericFile requestedFile = null;
            try
            {
                if ((remoteHost == "") || (IsLocal(remoteHost)))
                {
                    //I'm not sure why, but someone is requesting a file FROM this machine, FOR this machine
                    //Therefore, no remote Titanium contact is needed
                    requestedFile = new GenericFile(sourcePath);
                    //check if there's a destination path
                    if (destinationPath != "")
                    {
                        //there is, so save the file
                        requestedFile.Save(destinationPath);
                    }
                }
                else
                {
                    //this is a request to a remote host, so contact it
                    TitaniumServer TServ = ContactRemoteServer(remoteHost);
                    //get the file in a generic form we can move around
                    requestedFile = TServ.UploadFile(sourcePath);
                    //check if there's a destination path
                    if (destinationPath != "")
                    {
                        //there is, so save the file
                        requestedFile.Save(destinationPath);
                    }
                }
                //return the requested file. If something has gone wrong, it will be null, as specified
                return requestedFile;
            }
            catch
            {
                //something went wrong
                return null;
            }
        }
        /// <summary>
        /// Transmit a file from the source path on this computer to a destination path on the remote host.
        /// Note: if a drive letter is not specified, all paths are relative to the home directory of the Titanium.exe.
        /// Note: the transmitted file has no format at either end except the extension tacked onto it.
        /// </summary>
        /// <param name="sourcePath">The complete path to the file on this computer (e.g. C:\something something\something.someExtension)</param>
        /// <param name="destinationPath">The complete path to the file on the remote computer (e.g. C:\something something\something.someExtension)</param>
        /// <param name="remoteHost">The machine name of the remote host</param>
        /// <returns>a copy of the transmitted file, or null if something went wrong</returns>
        public GenericFile TransmitFile(string sourcePath, string destinationPath, string remoteHost)
        {
            GenericFile fileToTransmit = null;
            try
            {
                fileToTransmit = new GenericFile(sourcePath);
                if ((remoteHost == "") || (IsLocal(remoteHost)))
                {
                    //I'm not sure why, but someone is requesting a file FROM this machine, FOR this machine
                    //Therefore, no remote Titanium contact is needed
                    fileToTransmit.Save(destinationPath);
                }
                else
                {
                    //this is a request to a remote host, so contact it
                    TitaniumServer TServ = ContactRemoteServer(remoteHost);
                    //hand the remote host the file
                    TServ.DownloadFile(destinationPath, fileToTransmit);
                }
                return fileToTransmit;
            }
            catch
            {
                //something went wrong
                return null;
            }
        }
        /// <summary>
        /// Convert a remote file into a GenericFile object. An intermediary 
        /// used by Transmit- and RequestFile. Not recommended for 
        /// stand-alone use, but must be public for remoting purposes.
        /// </summary>
        /// <param name="sourcePath">The path where the file-to-upload is located, including filename and extension</param>
        /// <returns>A GenericFile containing the uploaded data as bytes</returns>
        public GenericFile UploadFile(string sourcePath)
        {
            try
            {
                //return a generic byte collection that represents the file
                return new GenericFile(sourcePath);
            }
            catch
            {
                //something went wrong
                return null;
            }
        }
        /// <summary>
        /// Convert a GenericFile object into a remote file. An intermediary 
        /// used by Transmit- and RequestFile. Not recommended for 
        /// stand-alone use, but must be public for remoting purposes.
        /// </summary>
        /// <param name="destinationPath">The full path where the file will be stored, including filename and extension</param>
        /// <param name="fileToDownLoad">The GenericFile to decode and store</param>
        /// <returns>false if there was an exception while storing the file, otherwise true</returns>
        public bool DownloadFile(string destinationPath, GenericFile fileToDownLoad)
        {
            try
            {
                fileToDownLoad.Save(destinationPath);
                return true; //all went well
            }
            catch
            {
                //something went wrong
                return false;
            }
        }
        #endregion
        #region test stuff - remove on code-cleanup
        //public void WaitForWatchDog()
        //{
        //    //ensure we actually wait on the watchdog
        //    waitTest.WaitOne();
        //    waitTest.WaitOne();
        //}
        //public Process GetMeAProcess()
        //{
        //    Process note = new Process();
        //    note.StartInfo.FileName = @"C:\Windows\System32\notepad.exe";
        //    note.Start();
        //    return note;
        //}
        //public bool TestFileTransfer(GenericFile fileToSave, string localPath)
        //{
        //    try
        //    {
        //        fileToSave.Save(localPath);
        //        return true;
        //    }
        //    catch
        //    {
        //        return false;
        //    }
        //}
        //public static bool PerformThreadTask1(string message,TitaniumServer t,int timeout)
        //{
        //    ThreadStart task = delegate { t.WriteToConsole(message); };
        //    Thread taskExecuter = new Thread(task);
        //    taskExecuter.Start();
        //    return taskExecuter.Join(timeout);
        //}
        //public static bool PerformThreadTask2(ThreadStart task, int timeout)
        //{
        //    Thread taskExecuter = new Thread(task);
        //    taskExecuter.Start();
        //    return taskExecuter.Join(timeout);
        //}
        //public void WasteTime(int timeToWaste)
        //{
        //    Thread.Sleep(timeToWaste);
        //}
        //public void WriteToConsole(string message)
        //{
        //    Console.WriteLine(message);
        //    Console.WriteLine(TestPrivateInvoke());
        //}
        //private string TestPrivateInvoke()
        //{
        //    return "Yes, of course we can invoke private methods from public ones";
        //}
        #endregion
        #region remote process control
        /// <summary>
        /// Start a process on a remote machine
        /// </summary>
        /// <param name="PathToProcess">The full path, including filename, to the process exe on the remote machine. 
        /// If a drive-letter is not provided, all paths are relative to the remote machine's Titanium.exe's home directory</param>
        /// <param name="HostName">The name of the machine on which to start the process</param>
        /// <param name="killRestart">if true, any pre-existing instances of this process will be killed</param>
        /// <returns>A valid ProcessTag for the new process on success, null on failure</returns>
        public ProcessTag StartRemoteProcess(string PathToProcess, string HostName, bool killRestart)
        {
            //create a new SerializableStartInfo with just the path to the exe in it
            SerializableStartInfo tempStartInfo = new SerializableStartInfo(PathToProcess);
            //feed this information to the main version of StartRemoteProcess
            return StartRemoteProcess(tempStartInfo, HostName, killRestart);
        }
        /// <summary>
        /// Start a process on a remote machine
        /// </summary>
        /// <param name="PathToProcess">The full path, including filename, to the process exe on the remote machine. 
        /// If a drive-letter is not provided, all paths are relative to the remote machine's Titanium.exe's home directory</param>
        /// <param name="StartInfoArgs">Command-line arguments to be fed to the new process on startup</param>
        /// <param name="HostName">The name of the machine on which to start the process</param>
        /// <param name="killRestart">if true, any pre-existing instances of this process will be killed</param>
        /// <returns>A valid ProcessTag for the new process on success, null on failure</returns>
        public ProcessTag StartRemoteProcess(string PathToProcess, string StartInfoArgs, string HostName, bool killRestart)
        {
            //create a new SerializableStartInfo with the path to the exe and the starting arguments
            SerializableStartInfo tempStartInfo = new SerializableStartInfo(PathToProcess,StartInfoArgs);
            //feed this information to the main version of StartRemoteProcess
            return StartRemoteProcess(tempStartInfo, HostName, killRestart);
        }
        /// <summary>
        /// Start a process on the remote machine
        /// </summary>
        /// <param name="TargetStartInfo">Contains the starting commands and other start info for the new process</param>
        /// <param name="HostName">The name of the machine on which to start the process</param>
        /// <param name="killRestart">if true, any pre-existing instances of this process will be killed</param>
        /// <returns>A valid ProcessTag for the new process on success, null on failure</returns>
        public ProcessTag StartRemoteProcess(SerializableStartInfo TargetStartInfo, string HostName, bool killRestart)
        {
            //Call ContactRemoteServer to get a remote instance of Titanium "on the line", then use this
            // instance to start a local process
            return ContactRemoteServer(HostName).StartLocalProcess(TargetStartInfo, killRestart);
        }
        /// <summary>
        /// Restart a process on a remote machine
        /// </summary>
        /// <param name="TargetStartInfo">Contains the starting commands and other start info for the process when it restarts</param>
        /// <param name="ProcessID">The ID of the process to be restarted</param>
        /// <param name="HostName">The name of the machine on which the target process is running</param>
        /// <returns>A valid ProcessTag on success, null on failure</returns>
        public ProcessTag RestartRemoteProcess(SerializableStartInfo TargetStartInfo, int ProcessID, string HostName)
        {
            //Call ContactRemoteServer to get a remote instance of Titanium "on the line", then use this
            // instance to restart a local process
            return ContactRemoteServer(HostName).RestartLocalProcess(TargetStartInfo, ProcessID);
        }
        /// <summary>
        /// Stop a proces on a remote machine
        /// </summary>
        /// <param name="ProcessID">the ID of the process to stop</param>
        /// <param name="HostName">the name of the remote machine</param>
        /// <returns>true if the process was successfully stopped, otherwise false</returns>
        public bool StopRemoteProcess(int ProcessID, string HostName)
        {
            //Call ContactRemoteServer to get a remote instance of Titanium "on the line", then use this
            // instance to stop a local process
            return ContactRemoteServer(HostName).StopLocalProcess(ProcessID);
        }
        #endregion
        #region local process control
        /// <summary>
        /// Starts a process on the local machine
        /// </summary>
        /// <param name="TargetStartInfo">Contains the starting commands and other start info for the new process</param>
        /// <param name="killRestart">if true, any pre-existing instances of this process will be killed</param>
        /// <returns>A valid ProcessTag for the new process on success, null on failure</returns>
        public ProcessTag StartLocalProcess(SerializableStartInfo TargetStartInfo, bool killRestart)
        {
            Process[] anyRunningInstances = Process.GetProcessesByName(TargetStartInfo.ProcessName);
            if (anyRunningInstances.Length > 0)
            {
                //there's already at least one instance of this process running
                if (killRestart)
                {
                    //stop all instances
                    foreach (Process toBeStopped in anyRunningInstances)
                    {
                        if (!StopLocalProcess(toBeStopped.Id))
                        {
                            //failed to stop at least one instance, but we can't depend on it to work properly, so return null
                            return null;
                        }
                    }
                    return StartLocalProcess(TargetStartInfo, false);
                }
                else
                {
                    //return a tag for the first running instance
                    return new ProcessTag(anyRunningInstances[0]);
                }
            }
            else
            {
                try
                {
                    //create a new process and start it
                    Process toBeStarted = new Process();
                    toBeStarted.StartInfo = TargetStartInfo.PIConverter;
                    toBeStarted.Start();
                    //Hacky McHack says "this delay is to reduce the likelihood of exceptions.
                    // The process needs time to establish itself before it can be interrogated to create
                    // a process tag. There should really be a re-try loop here."
                    Thread.Sleep(MST.TEN_SECONDS);
                    //create a ProcessTag and return it
                    ProcessTag toReturn = new ProcessTag(toBeStarted);
                    return toReturn;
                }
                catch (System.Exception ex)
                {
                    Console.WriteLine(ex.Message);
                    Console.WriteLine(ex.StackTrace);
                    throw ex;
                }
            }
        }
        /// <summary>
        /// Stops and restarts a local process
        /// </summary>
        /// <param name="TargetStartInfo">Contains starting commands for the process to be restarted</param>
        /// <param name="ProcessID">The ID of the local process to be restarted</param>
        /// <returns>A valid ProcessTag for the restarted process, or null if something went wrong</returns>
        public ProcessTag RestartLocalProcess(SerializableStartInfo TargetStartInfo, int ProcessID)
        {
            if (StopLocalProcess(ProcessID))
            {
                return StartLocalProcess(TargetStartInfo, false);
            }
            else
            {
                //couldn't stop the previous process, so don't start a new one
                return null;
            }
        }
        /// <summary>
        /// Stop a local process
        /// </summary>
        /// <param name="ProcessID">the ID of the process to stop</param>
        /// <returns>true if the process was successfully stopped, otherwise false</returns>
        public bool StopLocalProcess(int ProcessID)
        {
            try
            {
                //try to find the process
                Process toBeStopped = Process.GetProcessById(ProcessID);
                //if we found it...
                if (toBeStopped != null)
                {
                    //take the process off the watch-dog list - nothing bad will happen if it was never there to begin with
                    DeRegister(ProcessID);
                    //try to kill it
                    toBeStopped.Kill();
                    //wait up to 15 seconds
                    toBeStopped.WaitForExit(MST.FIFTEEN_SECONDS);
                    //return the result (will be true if it is "dead")
                    return toBeStopped.HasExited;
                }
                else
                {
                    //we didn't stop a process, but that's because there was no process to stop
                    return true;
                }
            }
            catch
            {
                //something went wrong, so return false
                return false;
            }
        }
        #endregion
        #region read-only members and accessors
        /// <summary>
        /// A list of processes being watched for failure/freeze
        /// </summary>
        public Dictionary<Process, StartupInstructions> ProcessesUnderGuard
        {
            get
            {
                return processesUnderGuard;
            }
        }
        /// <summary>
        /// A list of ServerIDCards for the servers that have registered with Titanium.exe
        /// </summary>
        public List<ServerIDCard> RegisteredServers
        {
            get
            {
                return registeredServers;
            }
        }
        #endregion
        #region public, static methods and members
        #region contact titanium
        private static object ContactLock = new object(); //lock for ContactTitanium
        /// <summary>
        /// Contact the running Titanium.exe, starting it if it is not already running
        /// </summary>
        /// <returns>An instance of the remote object served by Titanium.exe</returns>
        public static TitaniumServer ContactTitaniumServer()
        {
            lock (ContactLock)
            {
                Process Titanium;
                //see if Titanium.exe is running
                Process[] ListOfProcs = Process.GetProcessesByName("Titanium");
                if (ListOfProcs.Length < 1)
                {
                    //it isn't, so start it
                    Titanium = new Process();
                    //since titanium is both a library AND an exe, it MUST be local to our working directory
                    Titanium.StartInfo.FileName = "Titanium.exe";
                    Titanium.Start();
                    //Hacky McHack says: "Wait for the process to start, until we find a better way"
                    Thread.Sleep(MST.HALF_MINUTE);
                }
                else if (ListOfProcs.Length > 1)
                {
                    throw new TRemotingException("Multiple instances of Titanium detected. Unable to proceed");
                }
                TitaniumServer TServ = (TitaniumServer)InterProcessTools.RequestLocalObject(TitaniumServer.TitaniumPort, "TitaniumServer");
                return TServ;
            }
        }
        #endregion
        /// <summary>
        /// The port on which Titanium listens for requests
        /// </summary>
        public static int TitaniumPort
        {
            get
            {
                return TCF.RemotingParams.TitaniumPort;
            }
        }
        /// <summary>
        /// The name of the local machine
        /// </summary>
        public static string ThisMachine
        {
            get
            {
                return Environment.MachineName;
            }
        }
        /// <summary>
        /// Returns true if the supplied host name is the same as the local machine's name
        /// </summary>
        /// <param name="hostName">the name of the 'remote' host</param>
        /// <returns>true if the remote host name is really this machine's name, otherwise false</returns>
        public bool IsLocal(string hostName)
        {
            return (hostName == ThisMachine);
        }
        #endregion
        #region private members for remoting
        static Dictionary<Process, StartupInstructions> processesUnderGuard; //the private list that the public member wraps
        static List<ServerIDCard> registeredServers; //the list of registered servers
        static Dictionary<int, bool> ports; //the list of ports and whether they are free or not
        static int freePortCount = 0; //the number of free ports
        static object registerLock = new object(); //used to lock the "Register" function
        static Semaphore waitTest = new Semaphore(0, 1);
        #endregion
        #endregion
        #region private helpers
        //Look through the list of usable ports and see which ones have already
        // been marked as in-use. Return the first one that hasn't been so marked 
        //(or -1 if all are in use)
        static int FindFreePort()
        {
            foreach (int tempPort in ports.Keys)
            {
                //see if the InUse boolean is set to false
                if (ports[tempPort] == false)
                {
                    return tempPort;
                }
            }
            return -1; //couldn't find a free port
        }
        //This just makes it easier for Titanium code to contact remote servers
        static TitaniumServer ContactRemoteServer(string HostName)
        {
            InterProcessTools.EnsureClientChannelExists();
            string contactString = ServerIDCard.DeriveContactString(HostName, TitaniumPort, "TitaniumServer");
            return (TitaniumServer)Activator.GetObject(typeof(TitaniumServer), contactString);
        }
        #region watchdog stuff
        static Thread watchdogThread;
        static System.Timers.Timer watchdogTimer;
        /// <summary>
        /// Sets up the watchdog thread, which sets up and services the watchdog timer
        /// </summary>
        static void SetupWatchdog()
        {
            //NOTE: apparently, you don't need to start the watchdog from a thread to make it work
            //Confirm that's true, then restructure this code
            watchdogThread = new Thread(StartWatchdog);
            watchdogThread.Start();
        }
        /// <summary>
        /// Called by the watchdog thread to set the watchdog timer in motion and attaches its event handler.
        /// This ensures that the timer will be serviced by this thread.
        /// </summary>
        static void StartWatchdog()
        {
            watchdogTimer = new System.Timers.Timer();
            watchdogTimer.AutoReset = false; //set NOT to auto-restart
            //get the period from the TitaniumConfig file
            watchdogTimer.Interval = TCF.RemotingParams.WatchdogPeriod.TotalMilliseconds;
            watchdogTimer.Elapsed += new ElapsedEventHandler(ScanProcesses);
            watchdogTimer.Start();
            //while (true)
            //{
            //    //never return
            //}
        }
        /// <summary>
        /// This is invoked each time the watchdog timer goes off
        /// </summary>
        static void ScanProcesses(object sender, ElapsedEventArgs e)
        {
            //putting the processes into a list will allow us to start them all at once
            List<Process> ProcessesToStart = new List<Process>();
            //Hacky McHack says "this is a crude way of forcing the thread to have the correct name
            try
            {
                Thread.CurrentThread.Name = "Watchdog";
            }
            catch
            {

            }
            try
            {
                waitTest.Release();
            }
            catch
            {

            }
            try
            {
                lock (processesUnderGuard)
                {
                    //first, deal with any processes that need restarting
                    Process CPR;
                    //find where the array ends
                    int lastProcIndex = processesUnderGuard.Count - 1;
                    //walk backward through the array - this way, even if we remove an element here and there
                    // it will not interrupt our progress
                    Process isTroubled;
                    for (int i = lastProcIndex; i >= 0; i--)
                    {
                        isTroubled = processesUnderGuard.Keys.ElementAt(i);
                        if (isTroubled.HasExited)
                        {
                            //make sure CPR is clean and ready to go
                            CPR = new Process();
                            //the process is dead, so start a new instance
                            //this allows us to start an exact copy of the process
                            processesUnderGuard.Values.ElementAt(i).PrepareNewProcess(ref CPR);
                            processesUnderGuard.Remove(isTroubled); //remove this, as the process should re-register itself when restarted
                            ProcessesToStart.Add(CPR); //add this to the list of processes to start
                            Console.WriteLine("Restarting dead process: " + isTroubled.ProcessName);
                        }
                        else if (!isTroubled.Responding)
                        {
                            //make sure CPR is clean and ready to go
                            CPR = new Process();
                            //this allows us to start an exact copy of the process
                            processesUnderGuard.Values.ElementAt(i).PrepareNewProcess(ref CPR);
                            isTroubled.Kill();
                            isTroubled.WaitForExit(MST.TEN_SECONDS);
                            processesUnderGuard.Remove(isTroubled); //remove this, as the process should re-register itself when restarted
                            //don't bother to check if it exited; we can't do anything if it didn't
                            ProcessesToStart.Add(CPR); //add this to the list of processes to start
                            Console.WriteLine("Killing and restarting process: " + isTroubled.ProcessName);
                        }

                    }
                    //now deal with any servers that have exited
                    int lastCardIndex = registeredServers.Count - 1;
                    int procID;
                    int tempPort;
                    for (int i = lastCardIndex; i >= 0; i--)
                    {
                        isTroubled = null;
                        //get the process ID
                        procID = registeredServers[i].ProcessID;
                        //get the process by its ID (if it exists)
                        try
                        {
                            isTroubled = Process.GetProcessById(procID);
                        }
                        catch
                        {
                            //no matter what this exception is, we can do nothing, not even reporting
                            //therefore, assume it is caused by isTroubled being non-running
                        }
                        if (isTroubled == null)
                        {
                            //the process is toast, so flip the InUse boolean for that port back to false
                            tempPort = registeredServers[i].PortNum;
                            ports[tempPort] = false;
                            freePortCount++; //increment the number of free ports
                            //remove the records of this process from the registeredServers table
                            registeredServers.RemoveAt(i);
                            Console.WriteLine("Recycling port: " + tempPort);
                        }
                    }
                    //now start the processes
                    foreach (Process StartMe in ProcessesToStart)
                    {
                        StartMe.Start();
                    }
                }
            }
            catch
            {
                //swallow all exceptions, since they will never be reported anyway
                Console.WriteLine("Exception occured in watchdog server");
            }
            finally
            {
                //all work done - restart the timer...no matter what
                watchdogTimer.Start();
            }

        }
        /// <summary>
        /// This stops the timer, aborts the thread, and disposes of the timer.
        /// It should only be called on close.
        /// </summary>
        static void StopWatchDog()
        {
            watchdogTimer.Stop();
            watchdogThread.Abort();
            watchdogTimer.Dispose();
        }
        #endregion
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\UITest\RandomDictionary.cs ===
﻿using System;
using System.Collections.Generic;

namespace Test.Common.Library.UITest
{
    /// <summary>
    /// Represents a collection of key/value pairs that are sorted by key based on the associated System.Collections.Generic.IComparer implementation.
    /// Random key or value can be retrieved.
    /// </summary>
    /// <typeparam name="TKey">The type of keys in the collection.</typeparam>
    /// <typeparam name="TValue">The type of values in the collection.</typeparam>
    public class RandomCollection<TKey, TValue> : SortedList<TKey, TValue>
    {
        #region Fields
        /// <summary>
        /// Random number generator to be used for retrieving random key or value.
        /// </summary>
        private Random random = new Random();
        #endregion

        #region Public Methods
        /// <summary>
        /// Returns a random value from the collection.
        /// </summary>
        /// <returns>Random value from the collection. If the collection is empty, returns a default value.</returns>
        public TValue GetRandomValue()
        {
            TKey key = GetRandomKey();
            if (key != null)
            {
                return this[key];
            }
            else
            {
                return default(TValue);
            }
        }

        /// <summary>
        /// Returns a random key from the collection.
        /// </summary>
        /// <returns>Random value from the collection. If the collection is empty, returns a default value.</returns>
        public TKey GetRandomKey()
        {
            if (this.Count > 0)
            {
                int index = random.Next(0, this.Count);
                return this.Keys[index];
            }
            else
            {
                return default(TKey);
            }
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\UITest\Logger.cs ===
﻿using System;

namespace Test.Common.Library.UITest
{
    /// <summary>
    /// Static helper class for writing comments to Console.
    /// </summary>
    public static class Logger
    {
        /// <summary>
        /// Writes the given message to Console.
        /// </summary>
        /// <param name="logLine">String to write.</param>
        public static void WriteLine(string logLine)
        {
            Console.WriteLine(logLine);
        }

        /// <summary>
        /// Write the given message and exception to Console. Exception is not thrown.
        /// </summary>
        /// <param name="logLine">String to write.</param>
        /// <param name="exception">Exception to write.</param>
        public static void WriteLine(string logLine, Exception exception)
        {
            Logger.WriteLine(logLine, exception, false);
        }
        /// <summary>
        /// Write the given message and exception to Console. Exception can be thrown if indicated.
        /// </summary>
        /// <param name="logLine">String to write.</param>
        /// <param name="exception">Exception to write.</param>
        /// <param name="throwException">True if exception should be thrown; false otherwise.</param>
        public static void WriteLine(string logLine, Exception exception, bool throwException)
        {
            Console.WriteLine(logLine);
            Logger.WriteException(exception, throwException);

        }

        /// <summary>
        /// Writes the exception details to Console and throws the exception if indicated.
        /// </summary>
        /// <param name="exception">Exception to write.</param>
        /// <param name="throwException">True if exception should be thrown; false otherwise.</param>
        public static void WriteException(Exception exception, bool throwException)
        {
            if (exception != null)
            {
                Console.WriteLine("Exception: " + exception.Message);
                Console.WriteLine("StackTrace: " + exception.StackTrace);
                if (exception.InnerException != null)
                {
                    Console.WriteLine("InnerException: " + exception.InnerException.Message);
                }
            }

            if (throwException)
            {
                throw exception;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\UITest\VerificationManager.cs ===
﻿using System;
using System.Collections.Generic;

namespace Test.Common.Library.UITest
{
    /// <summary>
    /// This class was written for Dante.xbox.com UI tests. You may borrow/modify to fit your needs.
    /// This is an extremely trimmed down version of  Wgx.Test.Web.AutomationFramework.VerificationManager.
    /// Class for indicating test start and test end. At test ending, any validations on the given pages will be executed.
    /// </summary>
    public static class VerificationManager
    {
        #region Properties
        /// <summary>
        /// Gets the name of the current action for logging purposes.
        /// </summary>
        public static string CurrentAction { get; private set; }

        /// <summary>
        /// Gets whether or not the test can continue on any error occured during the current action.
        /// </summary>
        public static bool ContinueOnError { get; private set; }
        #endregion

        #region Public Methods
        /// <summary>
        /// Sets the current action name with continue on error set to false.
        /// </summary>
        /// <param name="actionName">Current action name.</param>
        public static void ActionStarting(string actionName)
        {
            ActionStarting(actionName, false);
        }

        /// <summary>
        /// Sets the current action name and whether or not to continue on error.
        /// </summary>
        /// <param name="actionName">Current action name.</param>
        /// <param name="continueOnError">True if it's okay to continue on error; false otherwise.</param>
        public static void ActionStarting(string actionName, bool continueOnError)
        {
            CurrentAction = actionName;
            ContinueOnError = continueOnError;
            Logger.WriteLine(string.Format("''{0}'' Starting....Continue On Error = {1}", CurrentAction, ContinueOnError));
        }

        /// <summary>
        /// Wait for the page to be completely loaded
        /// </summary>
        /// <param name="pagesToVerify"></param>
        public static void WaitForPageLoadingComplete(params WebPage[] pagesToVerify)
        {
            foreach (WebPage pageToVerify in pagesToVerify)
            {
                pageToVerify.WaitForLoadComplete();
            }
        }

        /// <summary>
        /// Executes validations on the given web pages to verify.
        /// </summary>
        /// <param name="pagesToVerify">Web pages to run validations on.</param>
        public static void ActionEnding(params WebPage[] pagesToVerify)
        {
            foreach (WebPage pageToVerify in pagesToVerify)
            {
                pageToVerify.WaitForLoadComplete();

                Logger.WriteLine(string.Format("Verifying ''{0}''", pageToVerify.Name));
                List<ValidationRule> resultList = pageToVerify.RunPageValidations();

                Outcome actionOutcome = LogResults(resultList);
                if (actionOutcome != Outcome.Pass)
                {
                    Logger.WriteLine(string.Format("''{0}'' FAILED", pageToVerify.Name));
                    // quit test here if continueOnError = false
                    if (!ContinueOnError)
                    {
                        Logger.WriteLine("Test Aborting...");
                        throw new Exception("Test Aborting..");
                    }
                }
                else
                {
                    Logger.WriteLine(string.Format("''{0}'' PASSED", pageToVerify.Name));
                }

            }
            Logger.WriteLine("\n");
        }
        #endregion

        #region Private Methods
        /// <summary>
        /// Returns an overall outcome of the current action from the list of validation results.
        /// </summary>
        /// <param name="resultList">List of validation rules with results.</param>
        /// <returns>Overall outcome of the current action.</returns>
        private static Outcome LogResults(List<ValidationRule> resultList)
        {
            Outcome testOutcome = Outcome.Pass;
            int count = 1;
            
            foreach (ValidationRule rule in resultList)
            {
                string logLine = string.Format("\t{0}. {1}\t", count, rule.RuleName);
                if (rule.Result.Exception == null)
                {
                    if (!rule.Result.IsValid)
                    {
                        testOutcome = testOutcome | Outcome.Fail;
                        logLine += "Failed\t";
                    }
                    else
                    {
                        logLine += "Passed\t";
                    }
                }
                else
                {
                    testOutcome = testOutcome | Outcome.Error;
                    logLine += string.Format("Error\t{0}\t{1}", rule.Result.Exception.Message, rule.Result.Exception.StackTrace);
                }
                logLine += rule.Result.Message;
                Logger.WriteLine(logLine);
                count++;
            }
            return testOutcome;
        }
        #endregion
    }

    /// <summary>
    /// Specifies the test outcome.
    /// </summary>
    public enum Outcome
    {
        /// <summary>
        /// Test passed.
        /// </summary>
        Pass = 0,
        /// <summary>
        /// Test failed.
        /// </summary>
        Fail = 1,
        /// <summary>
        /// An error occured during a test, so the outcome cannot be determined.
        /// </summary>
        Error = 2
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\UITest\UserActions.cs ===
﻿using Keyboard = Microsoft.VisualStudio.TestTools.UITesting.Keyboard;
using Mouse = Microsoft.VisualStudio.TestTools.UITesting.Mouse;

namespace Test.Common.Library.UITest
{
    /// <summary>
    /// UserActions contains static methods for performing mouse and keyboard actions.
    /// </summary>
    public class UserActions
    {
        /// <summary>
        /// Sends the keystrokes to the control object.
        /// </summary>
        /// <param name="control">Control object to which the keys are to be send.</param>
        /// <param name="keys">Text to generate.</param>
        public static void SendKeys(ControlBase control, string keys)
        {
            UserActions.SendKeys(control, keys, false);
        }

        /// <summary>
        /// Sends the keystrokes to the control object.
        /// </summary>
        /// <param name="control">Control object to which the keys are to be send.</param>
        /// <param name="keys">Text to generate.</param>
        /// <param name="isEncoded">True if the text is encoded; false otherwise.</param>
        public static void SendKeys(ControlBase control, string keys, bool isEncoded)
        {
            Keyboard.SendKeys(control.controlObject, keys, isEncoded);
        }

        /// <summary>
        /// Clicks the default mouse button on the control object.
        /// </summary>
        /// <param name="control">Control object to be clicked.</param>
        public static void Click(ControlBase control)
        {
            Mouse.Click(control.controlObject);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\UITest\UITestManager.cs ===
﻿using Microsoft.VisualStudio.TestTools.UITesting;

namespace Test.Common.Library.UITest
{
    /// <summary>
    /// UITestManager contains static methods for initialization or cleanup of UITest.
    /// </summary>
    public class UITestManager
    {
        /// <summary>
        /// Initializes the Playback engine.
        /// </summary>
        public static void Initialize()
        {
            Playback.Initialize();
        }

        /// <summary>
        /// Cleans up the Playback engine.
        /// </summary>
        public static void Cleanup()
        {
            if (Playback.IsInitialized)
            {
                Playback.Cleanup();
            }
        }

        /// <summary>
        /// Waits for the given think time.
        /// </summary>
        /// <param name="milliseconds">Duration of think time in milliseconds.</param>
        public static void Wait(int milliseconds)
        {
            Playback.Wait(milliseconds);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\UITest\WebPage.cs ===
﻿using System;
using System.Collections.Generic;

namespace Test.Common.Library.UITest
{
    /// <summary>
    /// Represents a method that will handle page validations.
    /// </summary>
    /// <param name="sender">The WebPage object to validate.</param>
    public delegate void PageValidationEventHandler (WebPage sender);

    /// <summary>
    /// Abstract class representing a web page. Possible user actions and UI elements on the web page should be included in this class.
    /// </summary>
    public abstract class WebPage
    {
        #region Initialization
        /// <summary>
        /// Private constructor to prevent instantiation outside of this class. A static LaunchWebPage method that returns an instance of the page object is encouraged.
        /// </summary>
        protected WebPage() { }
        #endregion

        #region Properties
        /// <summary>
        /// Gets or sets the title of the web page as appears on the browser.
        /// </summary>
        public string Title { get; set; }

        /// <summary>
        /// Gets or sets the default Uri of the page. Use this Uri to navigate to this web page.
        /// </summary>
        public Uri Uri { get; set; }

        /// <summary>
        /// Gets the type name of the current WebPage class.
        /// </summary>
        public string Name
        {
            get
            {
                return this.GetType().Name;
            }
        }
        #endregion

        #region Fields
        /// <summary>
        /// Occurs in VerificationManager.TestEnding()
        /// </summary>
        private event PageValidationEventHandler ValidatePage;

        ///// <summary>
        ///// Indicated whether the page object is initialized. It's useful for lazy-loaded properties.
        ///// </summary>
        //private bool Initialized;
        #endregion

        #region Public Methods
        /// <summary>
        /// Adds the given validation rule to the event handler.
        /// </summary>
        /// <param name="rule">Validation rule to add to the event handler.</param>
        public void AddValidationRule(ValidationRule rule)
        {
            ValidatePage += new PageValidationEventHandler(rule.Validate);
        }

        /// <summary>
        /// Resets the page validation event handler.
        /// </summary>
        public void ResetValidations()
        {
            ValidatePage = null;
        }
        #endregion

        #region Private Methods
        /// <summary>
        /// Determines if the page load is complete.
        /// </summary>
        protected internal abstract void WaitForLoadComplete();

        /// <summary>
        /// Executes page validations and returns a list of validation rules with results.
        /// </summary>
        /// <returns>List of validation rules executed with results.</returns>
        internal virtual List<ValidationRule> RunPageValidations()
        {
            if (ValidatePage != null)
            {
                Delegate[] validators = ValidatePage.GetInvocationList();
                return ExecuteValidationRules(this, validators);
            }
            return new List<ValidationRule>();
        }

        /// <summary>
        /// Executes the given validation handlers on the given page and returns a list of validations rules with results.
        /// </summary>
        /// <param name="webPage">WebPage to validate.</param>
        /// <param name="validationHandlers">Array of validation handlers.</param>
        /// <returns>List of validation rules executed with results.</returns>
        private List<ValidationRule> ExecuteValidationRules(WebPage webPage, Delegate[] validationHandlers)
        {
            List<ValidationRule> resultList = new List<ValidationRule>(validationHandlers.Length);
            foreach (PageValidationEventHandler handler in validationHandlers)
            {
                ValidationRule target = null;
                try
                {
                    target = handler.Target as ValidationRule;
                    handler(this);
                }
                catch (Exception ex)
                {
                    target.Result.Exception = ex;
                }
                resultList.Add(target);
            }
            return resultList;
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\UITest\ControlObjects\WebBrowser.cs ===
﻿using System;
using System.Diagnostics;
using System.Net;
using System.Windows;
using Microsoft.VisualStudio.TestTools.UITesting;
using Microsoft.VisualStudio.TestTools.UITest.Extension;

namespace Test.Common.Library.UITest
{
    /// <summary>
    /// Class representing a web browser object. 
    /// Any action you can perform with a web browser is expected to be in this class as public methods.
    /// </summary>
    public class WebBrowser
    {
        #region Initialization
        /// <summary>
        /// Initializes a WebBrowser instance. Internal only.
        /// </summary>
        /// <param name="browser">Active BrowserWindow control object</param>
        internal WebBrowser(BrowserWindow browser)
        {
            activeBrowser = browser;
        }
        #endregion

        #region Fields
        /// <summary>
        /// Currently active browser control object.
        /// </summary>
        internal BrowserWindow activeBrowser;
        #endregion

        #region Properties
        /// <summary>
        /// Gets the Uri of the page loaded.
        /// </summary>
        public virtual Uri Uri { 
            get
            {
                return activeBrowser.Uri;
            }
        }

        /// <summary>
        /// Gets the version of browser.
        /// </summary>
        public virtual Version Version {
            get
            {
                return activeBrowser.Version;
            }
        }

        /// <summary>
        /// Gets the title of browser.
        /// </summary>
        public virtual string Title
        {
            get
            {
                return activeBrowser.Title;
            }
        }
        #endregion

        #region Internal methods for getting BrowserWindow object

        /// <summary>
        /// Returns the WebBrowser object for the given window handle.
        /// </summary>
        /// <param name="browserWindowHandle">Window Handle</param>
        /// <returns>WebBrowser object for the given window handle.</returns>
        internal static WebBrowser FromWindowHandle(IntPtr browserWindowHandle)
        {
            WebBrowser browser = new WebBrowser((BrowserWindow)UITestControlFactory.FromWindowHandle(browserWindowHandle));
            return browser;
        }

        /// <summary>
        /// Returns the WebBrowser object created from an existing process.
        /// </summary>
        /// <param name="processToWrap">Process to create from.</param>
        /// <returns>WebBrowser instance from an existing process.</returns>
        internal static WebBrowser FromProcess(Process processToWrap)
        {
            WebBrowser browser = new WebBrowser(BrowserWindow.FromProcess(processToWrap));
            return browser;
        }

        /// <summary>
        /// Launches a new WebBrowser.
        /// </summary>
        /// <returns>WebBrowser instance.</returns>
        internal static WebBrowser Launch()
        {
            WebBrowser browser = new WebBrowser(BrowserWindow.Launch());

            WebBrowserFactory.SetActiveInstance(browser);
            return browser;
        }

        /// <summary>
        /// Launches a new WebBrowser instance with the Uri. 
        /// </summary>
        /// <param name="uri">Uri to launch the WebBrowser with.</param>
        /// <returns>WebBrowser instance.</returns>
        internal static WebBrowser Launch(Uri uri)
        {
            return WebBrowser.Launch(uri, false, false, false);
        }

        /// <summary>
        /// Launches a new WebBrowser instance with the Uri. Can clear cache or cookies, and close all open browsers.
        /// </summary>
        /// <param name="uri">Uri to launch the WebBrowser with.</param>
        /// <param name="clearCache">True to clear all existing cache; false otherwise.</param>
        /// <param name="clearCookies">True to clear all existing cookies; false otherwise.</param>
        /// <param name="closeOpenBrowsers">True to close all open browsers; false otherwise.</param>
        /// <returns>WebBrowser instance.</returns>
        internal static WebBrowser Launch(Uri uri, bool clearCache, bool clearCookies, bool closeOpenBrowsers)
        {
            if (closeOpenBrowsers)
            {
                CloseAllBrowsers();
            }

            WebBrowser browser = new WebBrowser(BrowserWindow.Launch(uri));
            if (clearCache)
            {
                browser.ClearCache();
            }
            if (clearCookies)
            {
                browser.ClearCookies();
            }

            WebBrowserFactory.SetActiveInstance(browser);
            return browser;
        }
        #endregion

        #region Public Browser Operations
        /// <summary>
        /// Closes currently active WebBrowser.
        /// </summary>
        public void CloseBrowser()
        {
            activeBrowser.Close();
        }

        /// <summary>
        /// Kills currently active WebBrowser process.
        /// </summary>
        public void KillBrowser()
        {
            activeBrowser.Process.Kill();
        }

        /// <summary>
        /// Closes all browser instances.
        /// </summary>
        public static void CloseAllBrowsers()
        {
            //Close all the IE windows
            Process[] procs = Process.GetProcessesByName("iexplore");
            foreach (Process proc in procs)
            {
                proc.Kill();
            }
        }

        /// <summary>
        /// Closes currently active WebBrowser process.
        /// </summary>
        public void CloseProcess()
        {
            activeBrowser.Process.Close();
        }
        
        /// <summary>
        /// Navigates to a WebPage.
        /// </summary>
        /// <param name="page">WebPage to which browser will navigate.</param>
        public virtual void NavigateToPage(WebPage page)
        {
            NavigateToUrl(page.Uri);
        }

        /// <summary>
        /// Navigates to home page.
        /// </summary>
        public virtual void NavigateToHomepage()
        {
            activeBrowser.NavigateToHomepage();
        }

        /// <summary>
        /// Navigates to given Uri.
        /// </summary>
        /// <param name="uri">Uri to which browser will navigate.</param>
        public virtual void NavigateToUrl(Uri uri)
        {
            activeBrowser.NavigateToUrl(uri);
        }

        /// <summary>
        /// Navigate to blank page.
        /// </summary>
        public virtual void NavigateToBlankPage()
        {
            NavigateToPage(new AboutBlankPage());
        }

        /// <summary>
        /// Performs Back operation on the browser.
        /// </summary>
        public virtual void Back()
        {
            activeBrowser.Back();
        }
        
        /// <summary>
        /// Perfoms Forward operation on the browser.
        /// </summary>
        public virtual void Forward()
        {
            activeBrowser.Forward();
        }
        
        /// <summary>
        /// Refreshes the page.
        /// </summary>
        public virtual void Refresh()
        {
            activeBrowser.Refresh();
        }
        
        /// <summary>
        /// Stops the page load.
        /// </summary>
        public virtual void StopPageLoad()
        {
            activeBrowser.StopPageLoad();
        }

        /// <summary>
        /// Clears the existing browser cache.
        /// </summary>
        public void ClearCache()
        {
            BrowserWindow.ClearCache();
        }

        /// <summary>
        /// Clears the existing browser cookies.
        /// </summary>
        public void ClearCookies()
        {
            BrowserWindow.ClearCookies();
        }

        /// <summary>
        /// Sets the cookie in the browser.
        /// </summary>
        /// <param name="cookie"></param>
        public void SetCookie(Cookie cookie)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Gets the cookie of the given name.
        /// </summary>
        /// <param name="cookieName">Cookie name to get.</param>
        public Cookie GetCookie(string cookieName)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Search for a scripted web dialog and perform the clicking-OK action
        /// </summary>
        public void ConfirmDialogActionOk()
        {
            this.activeBrowser.PerformDialogAction(BrowserDialogAction.Ok);
        }

        /// <summary>
        /// Search for a scripted web dialog, provide the given text string to the dialog, then perform the clicking-OK action
        /// </summary>
        /// <param name="text"></param>
        public void ConfirmDialogActionWithPromptText(string text)
        {
            this.activeBrowser.PerformDialogAction(BrowserDialogAction.PromptText, text);
        }
        /// <summary>
        /// Search for a scripted web dialog and perform the clicking-Cancel action
        /// </summary>
        public void ConfirmDialogActionCancel()
        {
            this.activeBrowser.PerformDialogAction(BrowserDialogAction.Cancel);
        }
        
        #endregion

        #region Browser Size
        /// <summary>
        /// Minimizes the WebBrowser window.
        /// </summary>
        /// <returns></returns>
        public bool MinimizeWebBrowser()
        {
            if (activeBrowser.Resizable)
            {
                return activeBrowser.Minimized;
            }
            return false;
        }

        /// <summary>
        /// Resizes the WebBrowser window to the given windows state.
        /// </summary>
        /// <param name="stateToResizeTo">Windows state to resize to.</param>
        public void ResizeWebBrowser(WindowState stateToResizeTo)
        {
            bool resized = false;
            switch (stateToResizeTo)
            {
                case WindowState.Maximized:
                    resized = activeBrowser.Maximized;
                    break;
                case WindowState.Minimized:
                    resized = activeBrowser.Minimized;
                    break;
                case WindowState.Normal:
                    resized = activeBrowser.Restored;
                    break;
            }
        }
        
        /// <summary>
        /// Resizes the WebBrowser window to the given width and height.
        /// </summary>
        /// <param name="width">Width of the window in pixels.</param>
        /// <param name="height">Height of the window in pixels.</param>
        public void ResizeWebBrowser(int width, int height)
        {
            throw new NotImplementedException();
        }
        #endregion
        
        /// <summary>
        /// Disposes the resource associated with browser.
        /// </summary>
        protected void Dispose()
        {
            activeBrowser.Dispose();
        }
    }

    /// <summary>
    /// There's not enough support for multiple browsers and versions in RnP as of now. This class is useless.
    /// </summary>
    public enum BrowserType
    {
        /// <summary>
        /// Internet Explorer 6.0
        /// </summary>
        IE60 = 0,
        
        /// <summary>
        /// Internet Explorer 7.0
        /// </summary>
        IE70 = 1,

        /// <summary>
        /// Internet Explorer 8.0
        /// </summary>
        IE80 = 2,

        /// <summary>
        /// Firefox 1.5
        /// </summary>
        Firefox15 = 3,

        /// <summary>
        /// Firefox 2.0
        /// </summary>
        Firefox20 = 4,

        /// <summary>
        /// Firefox 3.0
        /// </summary>
        Firefox30 = 5,

        /// <summary>
        /// Safari 3.1
        /// </summary>
        Safari31 = 6,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\UITest\ControlObjects\WinControlObjects.cs ===
﻿using Microsoft.VisualStudio.TestTools.UITest.Extension;
using Microsoft.VisualStudio.TestTools.UITesting;
using WinControls = Microsoft.VisualStudio.TestTools.UITesting.WinControls;
using System;

namespace Test.Common.Library.UITest
{
    /// <summary>
    /// Abstract base class that represents a generic Windows control object.
    /// </summary>
    public abstract class WinControl : ControlBase
    {
        #region Initialization
        /// <summary>
        /// Initializes a WinControl instance with null parent control.
        /// </summary>
        protected WinControl() 
            : base() { }

        /// <summary>
        /// Initializes a WinControl instance with given parent control.
        /// </summary>
        /// <param name="parent">Parent control object that contains WinControl to be initialized.</param>
        protected WinControl(UITestControl parent) 
            : base(parent) { }
        #endregion

        #region Properties
        /// <summary>
        /// Gets whether the control exists or not.
        /// </summary>
        public virtual bool Exists
        {
            get
            {
                try
                {
                    return ((bool)this.GetProperty(UITestControl.PropertyNames.Exists));
                }
                catch (Exception)
                {
                    return false;
                }
            }
        }
        /// <summary>
        /// Gets the class name of the control.
        /// </summary>
        public virtual string ClassName
        {
            get
            {
                return ((string)(this.GetProperty(UITestControl.PropertyNames.ClassName)));
            }
        }

        /// <summary>
        /// Gets the friendly name of the control.
        /// </summary>
        public virtual string FriendlyName
        {
            get
            {
                return ((string)(this.GetProperty(UITestControl.PropertyNames.FriendlyName)));
            }
        }

        /// <summary>
        /// Gets whether the control has focus or not.
        /// </summary>
        public virtual bool HasFocus
        {
            get
            {
                return ((bool)(this.GetProperty(UITestControl.PropertyNames.HasFocus)));
            }
        }

        /// <summary>
        /// Gets the native technology element corresponding to the UITestControl.
        /// </summary>
        public virtual object NativeElement
        {
            get
            {
                return ((object)(this.GetProperty(UITestControl.PropertyNames.NativeElement)));
            }
        }

        /// <summary>
        /// Gets the window handle of the control.  Data-type: System.IntPtr
        /// </summary>
        public virtual System.IntPtr WindowHandle
        {
            get
            {
                return ((System.IntPtr)(this.GetProperty(UITestControl.PropertyNames.WindowHandle)));
            }
        }

        /// <summary>
        /// Gets the control's name.  Can be used for search.
        /// </summary>
        public virtual string ControlName
        { 
            get
            {
                return ((string)(this.GetProperty(WinControls.WinControl.PropertyNames.ControlName)));
            }
        }

        /// <summary>
        /// Gets the control's id.  Can be used for search.
        /// </summary>
        public virtual int ControlId
        {
            get
            {
                return ((int)(this.GetProperty(WinControls.WinControl.PropertyNames.ControlId)));
            }
        }
        #endregion
    }

    /// <summary>
    /// Class representing a Window control.
    /// </summary>
    public class WinWindow : WinControl
    {
        #region Initialization
        /// <summary>
        /// Initializes a WinWindow instance with null parent control.
        /// </summary>
        public WinWindow()
            : this((UITestControl)null) { }

        /// <summary>
        /// Initializes a WinWindow instance with given parent Win control.
        /// </summary>
        /// <param name="parent">Windows control object that contains WinWindow to be initialized.</param>
        public WinWindow(WinControl parent)
            : this(parent.controlObject) { }

        /// <summary>
        /// Initializes a WinWindow instance with given parent control.
        /// </summary>
        /// <param name="parent">Control object that contains WinWindow to be initialized.</param>
        private WinWindow(UITestControl parent) :
            base(parent)
        {
            SetDefaultProperties();
        }
        #endregion

        #region Properties
        /// <summary>
        /// Gets a value indicating whether the window is resizable.
        /// </summary>
        public virtual bool Resizable
        {
            get
            {
                return ((bool)(this.GetProperty(WinControls.WinWindow.PropertyNames.Resizable)));
            }
        }

        /// <summary>
        /// Gets a value indicating whether the window has titlebar.
        /// </summary>
        public virtual bool HasTitleBar
        {
            get
            {
                return ((bool)(this.GetProperty(WinControls.WinWindow.PropertyNames.HasTitleBar)));
            }
        }

        /// <summary>
        /// Gets a value indicating whether the window is a pop-up window.
        /// </summary>
        public virtual bool Popup
        {
            get
            {
                return ((bool)(this.GetProperty(WinControls.WinWindow.PropertyNames.Popup)));
            }
        }

        /// <summary>
        /// Gets a value indicating whether the window can be brought to focus using the 'TAB" key.
        /// </summary>
        public virtual bool TabStop
        {
            get
            {
                return ((bool)(this.GetProperty(WinControls.WinWindow.PropertyNames.TabStop)));
            }
        }

        /// <summary>
        /// Gets a value indicating whether the window is transperent.
        /// </summary>
        public virtual bool Transparent
        {
            get
            {
                return ((bool)(this.GetProperty(WinControls.WinWindow.PropertyNames.Transparent)));
            }
        }

        /// <summary>
        /// Gets a value indicating whether the window will always be on top.
        /// </summary>
        public virtual bool AlwaysOnTop
        {
            get
            {
                return ((bool)(this.GetProperty(WinControls.WinWindow.PropertyNames.AlwaysOnTop)));
            }
        }

        /// <summary>
        /// Gets or sets the window's maximized state.
        /// </summary>
        public virtual bool Maximized
        {
            get
            {
                return ((bool)(this.GetProperty(WinControls.WinWindow.PropertyNames.Maximized)));
            }
            set
            {
                this.SetProperty(WinControls.WinWindow.PropertyNames.Maximized, value);
            }
        }

        /// <summary>
        /// Gets or sets the window's minimized state.
        /// </summary>
        public virtual bool Minimized
        {
            get
            {
                return ((bool)(this.GetProperty(WinControls.WinWindow.PropertyNames.Minimized)));
            }
            set
            {
                this.SetProperty(WinControls.WinWindow.PropertyNames.Minimized, value);
            }
        }

        /// <summary>
        /// Gets a value indicating whether the window will be shown on taskbar.
        /// </summary>
        public virtual bool ShowInTaskbar
        {
            get
            {
                return ((bool)(this.GetProperty(WinControls.WinWindow.PropertyNames.ShowInTaskbar)));
            }
        }

        /// <summary>
        /// Gets a value indicating whether the window in restored. Sets the window to its previous state.
        /// </summary>
        public virtual bool Restored
        {
            get
            {
                return ((bool)(this.GetProperty(WinControls.WinWindow.PropertyNames.Restored)));
            }
            set
            {
                this.SetProperty(WinControls.WinWindow.PropertyNames.Restored, value);
            }
        }

        /// <summary>
        /// Gets the rank of the current window if two or more windows were interacted with which had a same title.
        /// </summary>
        public virtual int OrderOfInvocation
        {
            get
            {
                return ((int)(this.GetProperty(WinControls.WinWindow.PropertyNames.OrderOfInvocation)));
            }
        }
        #endregion

        #region Private Methods
        /// <summary>
        /// Sets default properties of the control to be called by the constructor.
        /// </summary>
        internal override void SetDefaultProperties()
        {
            controlObject.TechnologyName = "MSAA";
            controlObject.SearchProperties.Add("ControlType", "Window");
            controlObject.SearchConfigurations.Add(SearchConfiguration.VisibleOnly);
        }
        #endregion
    }

    /// <summary>
    /// Class representing a Windows ListItem control.
    /// </summary>
    public class WinListItem : WinControl
    {
        #region Initialization
        /// <summary>
        /// Initializes a WinListItem instance with null parent control.
        /// </summary>
        public WinListItem()
            : this((UITestControl)null) { }

        /// <summary>
        /// Initializes a WinListItem instance with given parent Win control.
        /// </summary>
        /// <param name="parent">Windows control object that contains WinListItem to be initialized.</param>
        public WinListItem(WinControl parent)
            : this(parent.controlObject) { }

        /// <summary>
        /// Initializes a WinListItem instance with given parent control.
        /// </summary>
        /// <param name="parent">Control object that contains WinListItem to be initialized.</param>
        private WinListItem(UITestControl parent) :
            base(parent)
        {
            SetDefaultProperties();
        }
        #endregion

        #region Properties
        /// <summary>
        /// Gets the display text of the list item.
        /// </summary>
        public virtual string DisplayText
        {
            get
            {
                return ((string)(this.GetProperty(WinControls.WinListItem.PropertyNames.DisplayText)));
            }
        }

        /// <summary>
        /// Gets the selected state of the list item.
        /// </summary>
        public virtual bool Selected
        {
            get
            {
                return ((bool)(this.GetProperty(WinControls.WinListItem.PropertyNames.Selected)));
            }
        }
        #endregion

        #region Private Methods
        /// <summary>
        /// Sets default properties of the control to be called by the constructor.
        /// </summary>
        internal override void SetDefaultProperties()
        {
            controlObject.TechnologyName = "MSAA";
            controlObject.SearchProperties.Add("ControlType", "ListItem");
            controlObject.SearchConfigurations.Remove(SearchConfiguration.VisibleOnly);
        }
        #endregion
    }

    /// <summary>
    /// Class representing a Windows Edit control.
    /// </summary>
    public class WinEdit : WinControl
    {
        #region Initialization
        /// <summary>
        /// Initializes a WinEdit instance with null parent control.
        /// </summary>
        public WinEdit()
            : this((UITestControl)null) { }

        /// <summary>
        /// Initializes a WinEdit instance with given parent Win control.
        /// </summary>
        /// <param name="parent">Windows control object that contains WinEdit to be initialized.</param>
        public WinEdit(WinControl parent)
            : this(parent.controlObject) { }

        /// <summary>
        /// Initializes a WinEdit instance with given parent control.
        /// </summary>
        /// <param name="parent">Control object that contains WinEdit to be initialized.</param>
        private WinEdit(UITestControl parent) :
            base(parent)
        {
            SetDefaultProperties();
        }
        #endregion

        #region Properties
        /// <summary>
        /// Gets the number of lines in a multiline edit control.
        /// </summary>
        public virtual int LineCount
        {
            get
            {
                return ((int)(this.GetProperty(WinControls.WinEdit.PropertyNames.LineCount)));
            }
        }

        /// <summary>
        /// Gets the character position of the caret relative to the first character in the Edit control.
        /// </summary>
        public virtual int InsertionIndexAbsolute
        {
            get
            {
                return ((int)(this.GetProperty(WinControls.WinEdit.PropertyNames.InsertionIndexAbsolute)));
            }
            set
            {
                this.SetProperty(WinControls.WinEdit.PropertyNames.InsertionIndexAbsolute, value);
            }
        }

        /// <summary>
        /// Gets the column number of the caret position in the line containing the caret. e.g InsertionIndexLineRelative of first character of the current line is Zero.
        /// </summary>
        public virtual int InsertionIndexLineRelative
        {
            get
            {
                return ((int)(this.GetProperty(WinControls.WinEdit.PropertyNames.InsertionIndexLineRelative)));
            }
        }

        /// <summary>
        /// Gets or sets the starting point of the selected text.
        /// </summary>
        public virtual int SelectionStart
        {
            get
            {
                return ((int)(this.GetProperty(WinControls.WinEdit.PropertyNames.SelectionStart)));
            }
            set
            {
                this.SetProperty(WinControls.WinEdit.PropertyNames.SelectionStart, value);
            }
        }

        /// <summary>
        /// Gets or sets the ending point of selected text.
        /// </summary>
        public virtual int SelectionEnd
        {
            get
            {
                return ((int)(this.GetProperty(WinControls.WinEdit.PropertyNames.SelectionEnd)));
            }
            set
            {
                this.SetProperty(WinControls.WinEdit.PropertyNames.SelectionEnd, value);
            }
        }

        /// <summary>
        /// Gets or sets the selected text.
        /// </summary>
        public virtual string SelectionText
        {
            get
            {
                return ((string)(this.GetProperty(WinControls.WinEdit.PropertyNames.SelectionText)));
            }
            set
            {
                this.SetProperty(WinControls.WinEdit.PropertyNames.SelectionText, value);
            }
        }

        /// <summary>
        /// Gets a value indicating whether the control is a password.
        /// </summary>
        public virtual bool IsPassword
        {
            get
            {
                return ((bool)(this.GetProperty(WinControls.WinEdit.PropertyNames.IsPassword)));
            }
        }

        /// <summary>
        /// Gets a value indicating whether the edit control is read-only.
        /// </summary>
        public virtual bool ReadOnly
        {
            get
            {
                return ((bool)(this.GetProperty(WinControls.WinEdit.PropertyNames.ReadOnly)));
            }
        }

        /// <summary>
        /// Gets the line number of the cursor position in a multi-line edit control.
        /// </summary>
        public virtual int CurrentLine
        {
            get
            {
                return ((int)(this.GetProperty(WinControls.WinEdit.PropertyNames.CurrentLine)));
            }
        }

        /// <summary>
        /// Gets or sets the text on the edit control.
        /// </summary>
        public virtual string Text
        {
            get
            {
                return ((string)(this.GetProperty(WinControls.WinEdit.PropertyNames.Text)));
            }
            set
            {
                this.SetProperty(WinControls.WinEdit.PropertyNames.Text, value);
            }
        }

        /// <summary>
        /// Gets or sets the text on the edit control.
        /// </summary>
        public virtual string CopyPastedText
        {
            get
            {
                return ((string)(this.GetProperty(WinControls.WinEdit.PropertyNames.CopyPastedText)));
            }
            set
            {
                this.SetProperty(WinControls.WinEdit.PropertyNames.CopyPastedText, value);
            }
        }

        /// <summary>
        /// Sets the encrypted text on the edit control of password type.
        /// </summary>
        public virtual string Password
        {
            set
            {
                this.SetProperty(WinControls.WinEdit.PropertyNames.Password, value);
            }
        }
        #endregion

        #region Private Methods
        /// <summary>
        /// Sets default properties of the control to be called by the constructor.
        /// </summary>
        internal override void SetDefaultProperties()
        {
            controlObject.TechnologyName = "MSAA";
            controlObject.SearchProperties.Add(WinControls.WinEdit.PropertyNames.ControlType, "Edit");
            controlObject.SearchConfigurations.Remove(SearchConfiguration.VisibleOnly);
        }
        #endregion
    }

    /// <summary>
    /// Class representing a Windows Button control.
    /// </summary>
    public class WinButton : WinControl
    {
        #region Initialization
        /// <summary>
        /// Initializes a WinButton instance with null parent control.
        /// </summary>
        public WinButton()
            : this((UITestControl)null) { }

        /// <summary>
        /// Initializes a WinButton instance with given parent Win control.
        /// </summary>
        /// <param name="parent">Windows control object that contains WinButton to be initialized.</param>
        public WinButton(WinControl parent)
            : this(parent.controlObject) { }

        /// <summary>
        /// Initializes a WinButton instance with given parent control.
        /// </summary>
        /// <param name="parent">Control object that contains WinButton to be initialized.</param>
        private WinButton(UITestControl parent) :
            base(parent)
        {
            SetDefaultProperties();
        }
        #endregion

        #region Properties
        /// <summary>
        /// Gets the display text of the button.
        /// </summary>
        public virtual string DisplayText
        {
            get
            {
                return ((string)(this.GetProperty(WinControls.WinButton.PropertyNames.DisplayText)));
            }
        }

        /// <summary>
        /// Gets the short-cut for the button.
        /// </summary>
        public virtual string Shortcut
        {
            get
            {
                return ((string)(this.GetProperty(WinControls.WinButton.PropertyNames.Shortcut)));
            }
        }
        #endregion

        #region Private Methods
        /// <summary>
        /// Sets default properties of the control to be called by the constructor.
        /// </summary>
        internal override void SetDefaultProperties()
        {
            controlObject.TechnologyName = "MSAA";
            controlObject.SearchProperties.Add("ControlType", "Button");
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\UITest\ControlObjects\HtmlControlObjects.cs ===
﻿using System;
using Microsoft.VisualStudio.TestTools.UITesting;
using HtmlControls = Microsoft.VisualStudio.TestTools.UITesting.HtmlControls;

namespace Test.Common.Library.UITest
{
    /// <summary>
    /// Abstract base class that represents a generic Html control object.
    /// </summary>
    public abstract class HtmlControl : ControlBase
    {
        #region Initialization
        /// <summary>
        /// Initializes a HtmlControl instance with null parent control.
        /// </summary>
        protected HtmlControl() 
            : base() { }

        /// <summary>
        /// Initializes a HtmlControl instance with given parent control.
        /// </summary>
        /// <param name="parent">Parent control object that contains HtmlControl to be initialized.</param>
        protected HtmlControl(UITestControl parent) 
            : base(parent) { }
        #endregion

        #region Properties
        /// <summary>
        /// Gets whether the control exists or not.
        /// </summary>
        public virtual bool Exists
        {
            get
            {
                try
                {
                    return ((bool)this.GetProperty(UITestControl.PropertyNames.Exists));
                }
                catch (Exception)
                {
                    return false;
                }
            }
        }

        /// <summary>
        /// Gets the class name of the control.
        /// </summary>
        public virtual string ClassName
        {
            get
            {
                return ((string)(this.GetProperty(UITestControl.PropertyNames.ClassName)));
            }
        }

        /// <summary>
        /// Gets the friendly name of the control.
        /// </summary>
        public virtual string FriendlyName
        {
            get
            {
                return ((string)(this.GetProperty(UITestControl.PropertyNames.FriendlyName)));
            }
        }

        /// <summary>
        /// Gets whether the control has focus or not.
        /// </summary>
        public virtual bool HasFocus
        {
            get
            {
                return ((bool)(this.GetProperty(UITestControl.PropertyNames.HasFocus)));
            }
        }

        /// <summary>
        /// Gets the native technology element corresponding to the UITestControl.
        /// </summary>
        public virtual object NativeElement
        {
            get
            {
                return ((object)(this.GetProperty(UITestControl.PropertyNames.NativeElement)));
            }
        }

        /// <summary>
        /// Gets the window handle of the control.  Data-type: System.IntPtr
        /// </summary>
        public virtual System.IntPtr WindowHandle
        {
            get
            {
                return ((System.IntPtr)(this.GetProperty(UITestControl.PropertyNames.WindowHandle)));
            }
        }

        /// <summary>
        /// Gets the value of Class attribute.  Can be used for search.
        /// </summary>
        public virtual string Class
        {
            get
            {
                return ((string)(this.GetProperty(HtmlControls.HtmlControl.PropertyNames.Class)));
            }
        }

        /// <summary>
        /// Gets the value of Id attribute.  Can be used for search.
        /// </summary>
        public virtual string Id
        {
            get
            {
                return ((string)(this.GetProperty(HtmlControls.HtmlControl.PropertyNames.Id)));
            }
        }
        
        /// <summary>
        /// Gets the control's text content.  Can be used for search.
        /// </summary>
        public virtual string InnerText
        {
            get
            {
                return ((string)(this.GetProperty(HtmlControls.HtmlControl.PropertyNames.InnerText)));
            }
        }
        
        /// <summary>
        /// Gets the instance of the control among controls with same tagname.  Can be used for search.
        /// </summary>
        public virtual int TagInstance
        {
            get
            {
                return ((int)(this.GetProperty(HtmlControls.HtmlControl.PropertyNames.TagInstance)));
            }
        }

        /// <summary>
        /// Gets the control's HTML tag-name.  Can be used for search.
        /// </summary>
        public virtual string TagName
        {
            get
            {
                return ((string)(this.GetProperty(HtmlControls.HtmlControl.PropertyNames.TagName)));
            }
        }

        /// <summary>
        /// Gets the value of control's Title attribute.  Can be used for search.
        /// </summary>
        public virtual string Title
        {
            get
            {
                return ((string)(this.GetProperty(HtmlControls.HtmlControl.PropertyNames.Title)));
            }
        }

        /// <summary>
        /// Gets the value of control's Type attribute.  Can be used for search. 
        /// </summary>
        public virtual string Type
        {
            get
            {
                return ((string)(this.GetProperty(HtmlControls.HtmlControl.PropertyNames.Type)));
            }
        }

        /// <summary>
        /// Gets the value of control's Value attribute.  Can be used for search. 
        /// </summary>
        public virtual string ValueAttribute
        {
            get
            {
                return ((string)(this.GetProperty(HtmlControls.HtmlControl.PropertyNames.ValueAttribute)));
            }
        }

        /// <summary>
        /// Gets the control's Access key.  Can be used for search. 
        /// </summary>
        public virtual string AccessKey
        {
            get
            {
                return ((string)(this.GetProperty(HtmlControls.HtmlControl.PropertyNames.AccessKey)));
            }
        }

        /// <summary>
        /// Gets the control's definition in the HTML page.  Can be used for search.
        /// </summary>
        public virtual string ControlDefinition
        {
            get
            {
                return ((string)(this.GetProperty(HtmlControls.HtmlControl.PropertyNames.ControlDefinition)));
            }
        }
        #endregion
    }

    /// <summary>
    /// Class representing a custom Html control.
    /// </summary>
    public class HtmlCustom : HtmlControl
    {
        #region Initialization
        /// <summary>
        /// Initializes a HtmlCustom instance with null parent control.
        /// </summary>
        public HtmlCustom() 
            : this((UITestControl)null) { }

        /// <summary>
        /// Initializes a HtmlCustom instance with given WebBrowser.
        /// </summary>
        /// <param name="parent">WebBrowser object that contains HtmlCustom to be initialized.</param>
        public HtmlCustom(WebBrowser parent) 
            : this(parent.activeBrowser) { }

        /// <summary>
        /// Initializes a HtmlCustom instance with given parent Html control.
        /// </summary>
        /// <param name="parent">Html control object that contains HtmlCustom to be initialized.</param>
        public HtmlCustom(HtmlControl parent) 
            : this(parent.controlObject) { }

        /// <summary>
        /// Initializes a HtmlCustom instance with given parent control.
        /// </summary>
        /// <param name="parent">Control object that contains HtmlCustom to be initialized.</param>
        private HtmlCustom(UITestControl parent)
            : base(parent) { }
        #endregion

        #region Private Mathods
        /// <summary>
        /// Sets default properties of the control to be called by the constructor.
        /// </summary>
        internal override void SetDefaultProperties()
        {
            controlObject.TechnologyName = "Web";
            controlObject.SearchProperties.Add("ControlType", "Custom");
        }
        #endregion 
    }

    /// <summary>
    /// Class representing an Html document
    /// </summary>
    public class HtmlDocument : HtmlControl
    {
        #region Initialization
        /// <summary>
        /// Initializes a HtmlDocument instance with null parent control.
        /// </summary>
        public HtmlDocument() 
            : this((UITestControl)null) { }

        /// <summary>
        /// Initializes a HtmlDocument instance with given WebBrowser.
        /// </summary>
        /// <param name="parent">WebBrowser object that contains HtmlDocument to be initialized</param>
        public HtmlDocument(WebBrowser parent) 
            : this(parent.activeBrowser) { }

        /// <summary>
        /// Initializes a HtmlDocument instance with given parent Html control.
        /// </summary>
        /// <param name="parent">Html control object that contains HtmlDocument to be initialized</param>
        public HtmlDocument(HtmlControl parent) 
            : this(parent.controlObject) { }

        /// <summary>
        /// Initializes a HtmlDocument instance with given parent control.
        /// </summary>
        /// <param name="parent">Control object that contains HtmlDocument to be initialized</param>
        private HtmlDocument(UITestControl parent)
            : base(parent)
        {
            SetDefaultProperties();
        }
        #endregion

        #region Properties
        /// <summary>
        /// Gets the Url of the document.  Can be used for search.
        /// </summary>
        public virtual string PageUrl
        {
            get
            {
                return ((string)(this.GetProperty(HtmlControls.HtmlDocument.PropertyNames.PageUrl)));
            }
        }

        /// <summary>
        /// Gets whether the document resides in a frame or not.  Can be used for search.
        /// </summary>
        public virtual bool FrameDocument
        {
            get
            {
                return ((bool)(this.GetProperty(HtmlControls.HtmlDocument.PropertyNames.FrameDocument)));
            }
        }

        /// <summary>
        /// Gets whether the page is a redirecting page or not.  Can be used for search.
        /// </summary>
        public virtual bool RedirectingPage
        {
            get
            {
                return ((bool)(this.GetProperty(HtmlControls.HtmlDocument.PropertyNames.RedirectingPage)));
            }
        }

        /// <summary>
        /// Gets the absolute path of the document.  Can be used for search.
        /// </summary>
        public virtual string AbsolutePath
        {
            get
            {
                return ((string)(this.GetProperty(HtmlControls.HtmlDocument.PropertyNames.AbsolutePath)));
            }
        }
        #endregion

        #region Private Methods
        /// <summary>
        /// Sets default properties of the control to be called by the constructor.
        /// </summary>
        internal override void SetDefaultProperties()
        {
            controlObject.TechnologyName = "Web";
            controlObject.SearchProperties.Add("ControlType", "Document");
            controlObject.SearchProperties.Add("TagName", "BODY");
        }
        #endregion
    }
    
    /// <summary>
    /// Class representing an Html div
    /// </summary>
    public class HtmlDiv : HtmlControl
    {
        #region Initialization
        /// <summary>
        /// Initializes a HtmlDiv instance with null parent control.
        /// </summary>
        public HtmlDiv() 
            : this((UITestControl)null) { }

        /// <summary>
        /// Initializes a HtmlDiv instance with given WebBrowser.
        /// </summary>
        /// <param name="parent">WebBrowser object that contains HtmlDiv to be initialized</param>
        public HtmlDiv(WebBrowser parent) 
            : this(parent.activeBrowser) { }

        /// <summary>
        /// Initializes a HtmlDiv instance with given parent Html control.
        /// </summary>
        /// <param name="parent">Html control object that contains HtmlDiv to be initialized</param>
        public HtmlDiv(HtmlControl parent) 
            : this(parent.controlObject) { }

        /// <summary>
        /// Initializes a HtmlDiv instance with given parent control.
        /// </summary>
        /// <param name="parent">Control object that contains HtmlDiv to be initialized</param>
        private HtmlDiv(UITestControl parent)
            : base(parent)
        {
            SetDefaultProperties();
        }
        #endregion

        #region Properties
        /// <summary>
        ///  Gets the text in the pane.  Can be used for search.
        /// </summary>
        public virtual string DisplayText
        {
            get
            {
                return ((string)(this.GetProperty(HtmlControls.HtmlDiv.PropertyNames.DisplayText)));
            }
        }
        #endregion

        #region Private Methods
        /// <summary>
        /// Sets default properties of the control to be called by the constructor.
        /// </summary>
        internal override void SetDefaultProperties()
        {
            controlObject.TechnologyName = "Web";
            controlObject.SearchProperties.Add("ControlType", "Pane");
            controlObject.SearchProperties.Add("TagName", "DIV");
        }
        #endregion
    }

    /// <summary>
    /// Class representing and Htm span
    /// </summary>
    public class HtmlSpan : HtmlControl
    {
        #region Initialization
        /// <summary>
        /// Initializes an HtmlSpan instance with null parent control.
        /// </summary>
        public HtmlSpan()
            : this((UITestControl)null) { }

        /// <summary>
        /// Initializes an HtmlSpan instance with given WebBrowser.
        /// </summary>
        /// <param name="parent">WebBrowser object that contains HtmlSpan to be initialized</param>
        public HtmlSpan(WebBrowser parent)
            : this(parent.activeBrowser) { }

        /// <summary>
        /// Initializes an HtmlSpan instance with given parent Html control.
        /// </summary>
        /// <param name="parent">Html control object that contains HtmlSpan to be initialized</param>
        public HtmlSpan(HtmlControl parent)
            : this(parent.controlObject) { }

        /// <summary>
        /// Initializes an HtmlSpan instance with given parent control.
        /// </summary>
        /// <param name="parent">Control object that contains HtmlSpan to be initialized</param>
        private HtmlSpan(UITestControl parent)
            : base(parent)
        {
            SetDefaultProperties();
        }
        #endregion

        #region Properties
        /// <summary>
        ///  Gets the text in the pane.  Can be used for search.
        /// </summary>
        public virtual string DisplayText
        {
            get
            {
                return ((string)(this.GetProperty(HtmlControls.HtmlSpan.PropertyNames.DisplayText)));
            }
        }
        #endregion

        #region Private Methods
        /// <summary>
        /// Sets default properties of the control to be called by the constructor.
        /// </summary>
        internal override void SetDefaultProperties()
        {
            controlObject.TechnologyName = "Web";
            controlObject.SearchProperties.Add("ControlType", "Pane");
            controlObject.SearchProperties.Add("TagName", "SPAN");
        }
        #endregion
    }

    /// <summary>
    /// Class representing an Html hyperlink
    /// </summary>
    public class HtmlHyperlink : HtmlControl
    {
        #region Initialization
        /// <summary>
        /// Initializes a HtmlHyperlink instance with null parent control.
        /// </summary>
        public HtmlHyperlink() 
            : this((UITestControl)null) { }

        /// <summary>
        /// Initializes a HtmlHyperlink instance with given WebBrowser.
        /// </summary>
        /// <param name="parent">WebBrowser object that contains HtmlHyperlink to be initialized</param>
        public HtmlHyperlink(WebBrowser parent) 
            : this(parent.activeBrowser) { }

        /// <summary>
        /// Initializes a HtmlHyperlink instance with given parent Html control.
        /// </summary>
        /// <param name="parent">Html control object that contains HtmlHyperlink to be initialized</param>
        public HtmlHyperlink(HtmlControl parent) 
            : this(parent.controlObject) { }

        /// <summary>
        /// Initializes a HtmlHyperlink instance with given parent control.
        /// </summary>
        /// <param name="parent">Control object that contains HtmlHyperlink to be initialized</param>
        private HtmlHyperlink(UITestControl parent)
            : base(parent)
        {
            SetDefaultProperties();
        }
        #endregion

        #region Properties
        /// <summary>
        /// Gets the absolute path of the hyperlink's Href.  Can be used for search.
        /// </summary>
        public virtual string AbsolutePath
        {
            get
            {
                return ((string)(this.GetProperty(HtmlControls.HtmlHyperlink.PropertyNames.AbsolutePath)));
            }
        }

        /// <summary>
        /// Gets the value of Alt attribute.  Can be used for search.
        /// </summary>
        public virtual string Alt
        {
            get
            {
                return ((string)(this.GetProperty(HtmlControls.HtmlHyperlink.PropertyNames.Alt)));
            }
        }

        /// <summary>
        /// Gets the value of Href attribute of the hyperlink.  Can be used for search.
        /// </summary>
        public virtual string Href
        {
            get
            {
                return ((string)(this.GetProperty(HtmlControls.HtmlHyperlink.PropertyNames.Href)));
            }
        }

        /// <summary>
        /// Gets the value of Target attribute of the hyperlink.  Can be used for search.
        /// </summary>
        public virtual string Target
        {
            get
            {
                return ((string)(this.GetProperty(HtmlControls.HtmlHyperlink.PropertyNames.Target)));
            }
        }

        /// <summary>
        /// Gets or sets whether or not the link is enabled. User must specify the value since the framework cannot detect this from Html.
        /// </summary>
        public virtual bool Enabled { get; set; }
        #endregion

        #region Private Methods
        /// <summary>
        /// Sets default properties of the control to be called by the constructor.
        /// </summary>
        internal override void SetDefaultProperties()
        {
            controlObject.TechnologyName = "Web";
            controlObject.SearchProperties.Add("ControlType", "Hyperlink");
            controlObject.SearchProperties.Add("TagName", "A");
        }
        #endregion
    }

    /// <summary>
    /// Class representing an Html combobox
    /// </summary>
    public class HtmlComboBox : HtmlControl
    {

        #region Initialization
        /// <summary>
        /// Initializes a HtmlComboBox instance with null parent control.
        /// </summary>
        public HtmlComboBox() 
            : this((UITestControl)null) { }

        /// <summary>
        /// Initializes a HtmlComboBox instance with given WebBrowser.
        /// </summary>
        /// <param name="parent">WebBrowser object that contains HtmlComboBox to be initialized</param>
        public HtmlComboBox(WebBrowser parent) 
            : this(parent.activeBrowser) { }

        /// <summary>
        /// Initializes a HtmlComboBox instance with given parent Html control.
        /// </summary>
        /// <param name="parent">Html control object that contains HtmlComboBox to be initialized</param>
        public HtmlComboBox(HtmlControl parent) 
            : this(parent.controlObject) { }

        /// <summary>
        /// Initializes a HtmlComboBox instance with given parent control.
        /// </summary>
        /// <param name="parent">Control object that contains HtmlComboBox to be initialized</param>
        private HtmlComboBox(UITestControl parent)
            : base(parent)
        {
            SetDefaultProperties();
        }
        #endregion

        #region Properties
        /// <summary>
        ///  Gets the number of items in the combo-box Can be used for search.
        /// </summary>
        public virtual int ItemCount
        {
            get
            {
                return ((int)(this.GetProperty(HtmlControls.HtmlComboBox.PropertyNames.ItemCount)));
            }
        }

        /// <summary>
        /// Gets the collection of items the combo-box
        /// </summary>
        public virtual UITestControlCollection Items
        {
            get
            {
                return ((UITestControlCollection)(this.GetProperty(HtmlControls.HtmlComboBox.PropertyNames.Items)));
            }
        }

        /// <summary>
        /// Gets or sets the selected item of the combo-box.  Can be used for search.
        /// </summary>
        public virtual string SelectedItem
        {
            get
            {
                return ((string)(this.GetProperty(HtmlControls.HtmlComboBox.PropertyNames.SelectedItem)));
            }
            set
            {
                this.SetProperty(HtmlControls.HtmlComboBox.PropertyNames.SelectedItem, value);
            }
        }

        /// <summary>
        /// Gets the selected item's index.  Can be used for search.
        /// </summary>
        public virtual int SelectedIndex
        {
            get
            {
                return ((int)(this.GetProperty(HtmlControls.HtmlComboBox.PropertyNames.SelectedIndex)));
            }
            set
            {
                this.SetProperty(HtmlControls.HtmlComboBox.PropertyNames.SelectedIndex, value);
            }
        }

        /// <summary>
        /// Gets the label text of the combo-box. .Can be used for search.
        /// </summary>
        public virtual string LabeledBy
        {
            get
            {
                return ((string)(this.GetProperty(HtmlControls.HtmlComboBox.PropertyNames.LabeledBy)));
            }
        }

        /// <summary>
        /// Gets the size attribute value.  Can be used for search.
        /// </summary>
        public virtual int Size
        {
            get
            {
                return ((int)(this.GetProperty(HtmlControls.HtmlComboBox.PropertyNames.Size)));
            }
        }
        #endregion

        #region Private Methods
        /// <summary>
        /// Sets default properties of the control to be called by the constructor.
        /// </summary>
        internal override void SetDefaultProperties()
        {
            controlObject.TechnologyName = "Web";
            controlObject.SearchProperties.Add("ControlType", "ComboBox");
            controlObject.SearchProperties.Add("TagName", "SELECT");
        }
        #endregion
    }

    /// <summary>
    /// Class representing an Html option inside Html combo box
    /// </summary>
    public class HtmlOption : HtmlControl
    {
        #region Initialization
        /// <summary>
        /// Initializes a HtmlOption instance with null parent control.
        /// </summary>
        public HtmlOption() 
            : this((UITestControl)null) { }

        /// <summary>
        /// Initializes a HtmlOption instance with given WebBrowser.
        /// </summary>
        /// <param name="parent">WebBrowser object that contains HtmlOption to be initialized</param>
        public HtmlOption(WebBrowser parent) 
            : this(parent.activeBrowser) { }

        /// <summary>
        /// Initializes a HtmlOption instance with given parent Html control.
        /// </summary>
        /// <param name="parent">Html control object that contains HtmlOption to be initialized</param>
        public HtmlOption(HtmlControl parent) 
            : this(parent.controlObject) { }

        /// <summary>
        /// Initializes a HtmlOption instance with given parent control.
        /// </summary>
        /// <param name="parent">Control object that contains HtmlOption to be initialized</param>
        private HtmlOption(UITestControl parent)
            : base(parent)
        {
            SetDefaultProperties();
        }
        #endregion

        #region Private Methods
        /// <summary>
        /// Sets default properties of the control to be called by the constructor.
        /// </summary>
        internal override void SetDefaultProperties()
        {
            controlObject.TechnologyName = "Web";
            controlObject.SearchProperties.Add("ControlType", "ListItem");
            controlObject.SearchProperties.Add("ClassName", "HtmlOption");
            controlObject.SearchProperties.Add("TagName", "OPTION");
        }
        #endregion
    }

    /// <summary>
    /// Class representing an Html table cell
    /// </summary>
    public class HtmlTableCell : HtmlControl
    {
        #region Initialization
        /// <summary>
        /// Initializes a HtmlTableCell instance with null parent control.
        /// </summary>
        public HtmlTableCell() 
            : this((UITestControl)null) { }

        /// <summary>
        /// Initializes a HtmlTableCell instance with given WebBrowser.
        /// </summary>
        /// <param name="parent">WebBrowser object that contains HtmlTableCell to be initialized</param>
        public HtmlTableCell(WebBrowser parent) 
            : this(parent.activeBrowser) { }

        /// <summary>
        /// Initializes a HtmlTableCell instance with given parent Html control.
        /// </summary>
        /// <param name="parent">Html control object that contains HtmlTableCell to be initialized</param>
        public HtmlTableCell(HtmlControl parent) 
            : this(parent.controlObject) { }

        /// <summary>
        /// Initializes a HtmlTableCell instance with given parent control.
        /// </summary>
        /// <param name="parent">Control object that contains HtmlTableCell to be initialized</param>
        private HtmlTableCell(UITestControl parent)
            : base(parent)
        {
            SetDefaultProperties();
        }
        #endregion

        #region Private Methods
        /// <summary>
        /// Sets default properties of the control to be called by the constructor.
        /// </summary>
        internal override void SetDefaultProperties()
        {
            controlObject.TechnologyName = "Web";
            controlObject.SearchProperties.Add("ControlType", "Cell");
            controlObject.SearchProperties.Add("ClassName", "HtmlTableCell");
            controlObject.SearchProperties.Add("TagName", "TD");
        }
        #endregion
    }

    /// <summary>
    /// Class representing an Html table row
    /// </summary>
    public class HtmlTableRow : HtmlControl
    {
        #region Initialization
        /// <summary>
        /// Initializes an HtmlTableRow instance with null parent control.
        /// </summary>
        public HtmlTableRow()
            : this((UITestControl)null) { }

        /// <summary>
        /// Initializes an HtmlTableRow instance with given WebBrowser.
        /// </summary>
        /// <param name="parent">WebBrowser object that contains HtmlTableRow to be initialized</param>
        public HtmlTableRow(WebBrowser parent)
            : this(parent.activeBrowser) { }

        /// <summary>
        /// Initializes an HtmlTableRow instance with given parent Html control.
        /// </summary>
        /// <param name="parent">Html control object that contains HtmlTableRow to be initialized</param>
        public HtmlTableRow(HtmlControl parent)
            : this(parent.controlObject) { }

        /// <summary>
        /// Initializes an HtmlTableRow instance with given parent control.
        /// </summary>
        /// <param name="parent">Control object that contains HtmlTableRow to be initialized</param>
        private HtmlTableRow(UITestControl parent)
            : base(parent)
        {
            SetDefaultProperties();
        }
        #endregion

        #region Private Methods
        /// <summary>
        /// Sets default properties of the control to be called by the constructor.
        /// </summary>
        internal override void SetDefaultProperties()
        {
            controlObject.TechnologyName = "Web";
            controlObject.SearchProperties.Add("ControlType", "Row");
            controlObject.SearchProperties.Add("ClassName", "HtmlTableRow");
            controlObject.SearchProperties.Add("TagName", "TR");
        }
        #endregion
    }

    /// <summary>
    /// Class representing an Html table
    /// </summary>
    public class HtmlTable : HtmlControl
    {
        #region Initialization
        /// <summary>
        /// Initializes a HtmlTable instance with null parent control.
        /// </summary>
        public HtmlTable() 
            : this((UITestControl)null) { }

        /// <summary>
        /// Initializes a HtmlTable instance with given WebBrowser.
        /// </summary>
        /// <param name="parent">WebBrowser object that contains HtmlTable to be initialized</param>
        public HtmlTable(WebBrowser parent) 
            : this(parent.activeBrowser) { }

        /// <summary>
        /// Initializes a HtmlTable instance with given parent Html control.
        /// </summary>
        /// <param name="parent">Html control object that contains HtmlTable to be initialized</param>
        public HtmlTable(HtmlControl parent) 
            : this(parent.controlObject) { }

        /// <summary>
        /// Initializes a HtmlTable instance with given parent control.
        /// </summary>
        /// <param name="parent">Control object that contains HtmlTable to be initialized</param>
        private HtmlTable(UITestControl parent)
            : base(parent)
        {
            SetDefaultProperties();
        }
        #endregion

        #region Private Methods
        /// <summary>
        /// Sets default properties of the control to be called by the constructor.
        /// </summary>
        internal override void SetDefaultProperties()
        {
            controlObject.TechnologyName = "Web";
            controlObject.SearchProperties.Add("ControlType", "Table");
            controlObject.SearchProperties.Add("ClassName", "HtmlTable");
        }
        #endregion
    }

    /// <summary>
    /// Class representing an Html button. TagName = button.
    /// </summary>
    public class HtmlButton : HtmlControl
    {
        #region Initialization
        /// <summary>
        /// Initializes a HtmlButton instance with null parent control.
        /// </summary>
        public HtmlButton() 
            : this((UITestControl)null) { }

        /// <summary>
        /// Initializes a HtmlButton instance with given WebBrowser.
        /// </summary>
        /// <param name="parent">WebBrowser object that contains HtmlButton to be initialized</param>
        public HtmlButton(WebBrowser parent) 
            : this(parent.activeBrowser) { }

        /// <summary>
        /// Initializes a HtmlButton instance with given parent Html control.
        /// </summary>
        /// <param name="parent">Html control object that contains HtmlButton to be initialized</param>
        public HtmlButton(HtmlControl parent) 
            : this(parent.controlObject) { }

        /// <summary>
        /// Initializes a HtmlButton instance with given parent control.
        /// </summary>
        /// <param name="parent">Control object that contains HtmlButton to be initialized</param>
        private HtmlButton(UITestControl parent)
            : base(parent)
        {
            SetDefaultProperties();
        }
        #endregion

        #region Properties
        /// <summary>
        /// Gets the text on the button.  Can be used for search.
        /// </summary>
        public virtual string DisplayText
        {
            get
            {
                return ((string)(this.GetProperty(HtmlControls.HtmlButton.PropertyNames.DisplayText)));
            }
        }
        #endregion

        #region Private Methods
        /// <summary>
        /// Sets default properties of the control to be called by the constructor.
        /// </summary>
        internal override void SetDefaultProperties()
        {
            this.controlObject.TechnologyName = "Web";
            this.controlObject.SearchProperties.Add("ControlType", "Button");
            this.controlObject.SearchProperties.Add("TagName", "BUTTON");
        }
        #endregion
    }

    /// <summary>
    /// Class representing an Html edit box
    /// </summary>
    public class HtmlEdit : HtmlControl
    {
        #region Initialization
        /// <summary>
        /// Initializes a HtmlEdit instance with null parent control.
        /// </summary>
        public HtmlEdit() 
            : this((UITestControl)null) { }

        /// <summary>
        /// Initializes a HtmlEdit instance with given WebBrowser.
        /// </summary>
        /// <param name="parent">WebBrowser object that contains HtmlEdit to be initialized</param>
        public HtmlEdit(WebBrowser parent) 
            : this(parent.activeBrowser) { }

        /// <summary>
        /// Initializes a HtmlEdit instance with given parent Html control.
        /// </summary>
        /// <param name="parent">Html control object that contains HtmlEdit to be initialized</param>
        public HtmlEdit(HtmlControl parent) 
            : this(parent.controlObject) { }

        /// <summary>
        /// Initializes a HtmlEdit instance with given parent control.
        /// </summary>
        /// <param name="parent">Control object that contains HtmlEdit to be initialized</param>
        private HtmlEdit(UITestControl parent)
            : base(parent)
        {
            SetDefaultProperties();
        }
        #endregion

        #region Properties
        /// <summary>
        /// Gets or sets the text in the edit box.  Use this property on password type edit box, if input is not encoded.  Can be used for search. 
        /// </summary>
        public virtual string Text
        {
            get
            {
                return ((string)(this.GetProperty(HtmlControls.HtmlEdit.PropertyNames.Text)));
            }
            set
            {
                this.SetProperty(HtmlControls.HtmlEdit.PropertyNames.Text, value);
            }
        }

        /// <summary>
        /// Gets whether the control is password type edit box or not.  Can be used for search.  
        /// </summary>
        public virtual bool IsPassword
        {
            get
            {
                return ((bool)(this.GetProperty(HtmlControls.HtmlEdit.PropertyNames.IsPassword)));
            }
        }

        /// <summary>
        /// Gets the default value of the edit box.  Can be used for search.
        /// </summary>
        public virtual string DefaultText
        {
            get
            {
                return ((string)(this.GetProperty(HtmlControls.HtmlEdit.PropertyNames.DefaultText)));
            }
        }

        /// <summary>
        /// Gets or sets the text in edit box using Copy-Paste (IME based scenarios).  Can be used for search. 
        /// </summary>
        public virtual string CopyPastedText
        {
            get
            {
                return ((string)(this.GetProperty(HtmlControls.HtmlEdit.PropertyNames.CopyPastedText)));
            }
            set
            {
                this.SetProperty(HtmlControls.HtmlEdit.PropertyNames.CopyPastedText, value);
            }
        }

        /// <summary>
        /// Gets the control's label text.  Can be used for search.
        /// </summary>
        public virtual string LabeledBy
        {
            get
            {
                return ((string)(this.GetProperty(HtmlControls.HtmlEdit.PropertyNames.LabeledBy)));
            }
        }

        /// <summary>
        /// Gets whether the edit box is read-only or not.  Can be used for search.
        /// </summary>
        public virtual bool ReadOnly
        {
            get
            {
                return ((bool)(this.GetProperty(HtmlControls.HtmlEdit.PropertyNames.ReadOnly)));
            }
        }

        /// <summary>
        /// Gets or sets an encoded text value in the edit box. 
        /// </summary>
        public virtual string Password
        {
            set
            {
                this.SetProperty(HtmlControls.HtmlEdit.PropertyNames.Password, value);
            }
        }
        #endregion

        #region Private Methods
        /// <summary>
        /// Sets default properties of the control to be called by the constructor.
        /// </summary>
        internal override void SetDefaultProperties()
        {
            this.controlObject.TechnologyName = "Web";
            this.controlObject.SearchProperties.Add("ControlType", "Edit");
            this.controlObject.SearchProperties.Add("TagName", "INPUT");
        }
        #endregion
    }

    /// <summary>
    /// Class representing an Html text area
    /// </summary>
    public class HtmlTextArea : HtmlControl
    {
        #region Initialization
        /// <summary>
        /// Initializes a HtmlTextArea instance with null parent control.
        /// </summary>
        public HtmlTextArea()
            : this((UITestControl)null) { }

        /// <summary>
        /// Initializes a HtmlTextArea instance with given WebBrowser.
        /// </summary>
        /// <param name="parent">WebBrowser object that contains HtmlEdit to be initialized</param>
        public HtmlTextArea(WebBrowser parent)
            : this(parent.activeBrowser) { }

        /// <summary>
        /// Initializes an HtmlTextArea instance with given parent Html control.
        /// </summary>
        /// <param name="parent">Html control object that contains HtmlTextArea to be initialized</param>
        public HtmlTextArea(HtmlControl parent)
            : this(parent.controlObject) { }

        /// <summary>
        /// Initializes an HtmlTextArea instance with given parent control.
        /// </summary>
        /// <param name="parent">Control object that contains HtmlTextArea to be initialized</param>
        private HtmlTextArea(UITestControl parent)
            : base(parent)
        {
            SetDefaultProperties();
        }
        #endregion

        #region Properties
        /// <summary>
        /// Gets or sets the text in the text area. Use this property on password type text area, if input is not encoded.  Can be used for search. 
        /// </summary>
        public virtual string Text
        {
            get
            {
                return ((string)(this.GetProperty(HtmlControls.HtmlTextArea.PropertyNames.Text)));
            }
            set
            {
                this.SetProperty(HtmlControls.HtmlTextArea.PropertyNames.Text, value);
            }
        }

        /// <summary>
        /// Gets whether the control is password type text area or not.  Can be used for search.  
        /// </summary>
        public virtual bool IsPassword
        {
            get
            {
                return ((bool)(this.GetProperty(HtmlControls.HtmlTextArea.PropertyNames.IsPassword)));
            }
        }

        /// <summary>
        /// Gets the default value of the text area.  Can be used for search.
        /// </summary>
        public virtual string DefaultText
        {
            get
            {
                return ((string)(this.GetProperty(HtmlControls.HtmlTextArea.PropertyNames.DefaultText)));
            }
        }

        /// <summary>
        /// Gets or sets the text in text area using Copy-Paste (IME based scenarios).  Can be used for search. 
        /// </summary>
        public virtual string CopyPastedText
        {
            get
            {
                return ((string)(this.GetProperty(HtmlControls.HtmlTextArea.PropertyNames.CopyPastedText)));
            }
            set
            {
                this.SetProperty(HtmlControls.HtmlTextArea.PropertyNames.CopyPastedText, value);
            }
        }

        /// <summary>
        /// Gets the control's label text.  Can be used for search.
        /// </summary>
        public virtual string LabeledBy
        {
            get
            {
                return ((string)(this.GetProperty(HtmlControls.HtmlTextArea.PropertyNames.LabeledBy)));
            }
        }

        /// <summary>
        /// Gets whether the text area is read-only or not.  Can be used for search.
        /// </summary>
        public virtual bool ReadOnly
        {
            get
            {
                return ((bool)(this.GetProperty(HtmlControls.HtmlTextArea.PropertyNames.ReadOnly)));
            }
        }

        /// <summary>
        /// Gets or sets an encoded text value in the edit box. 
        /// </summary>
        public virtual string Password
        {
            set
            {
                this.SetProperty(HtmlControls.HtmlTextArea.PropertyNames.Password, value);
            }
        }
        #endregion

        #region Private Methods
        /// <summary>
        /// Sets default properties of the control to be called by the constructor.
        /// </summary>
        internal override void SetDefaultProperties()
        {
            this.controlObject.TechnologyName = "Web";
            this.controlObject.SearchProperties.Add("ControlType", "Edit");
            this.controlObject.SearchProperties.Add("TagName", "TEXTAREA");
        }
        #endregion
    }

    /// <summary>
    /// Class representing an Html input button. TagName = input.
    /// </summary>
    public class HtmlInputButton : HtmlControl
    {
        #region Initialization
        /// <summary>
        /// Initializes a HtmlInputButton instance with null parent control.
        /// </summary>
        public HtmlInputButton() 
            : this((UITestControl)null) { }

        /// <summary>
        /// Initializes a HtmlInputButton instance with given WebBrowser.
        /// </summary>
        /// <param name="parent">WebBrowser object that contains HtmlInputButton to be initialized</param>
        public HtmlInputButton(WebBrowser parent) 
            : this(parent.activeBrowser) { }

        /// <summary>
        /// Initializes a HtmlInputButton instance with given parent Html control.
        /// </summary>
        /// <param name="parent">Html control object that contains HtmlInputButton to be initialized</param>
        public HtmlInputButton(HtmlControl parent) 
            : this(parent.controlObject) { }

        /// <summary>
        /// Initializes a HtmlInputButton instance with given parent control.
        /// </summary>
        /// <param name="parent">Control object that contains HtmlInputButton to be initialized</param>
        private HtmlInputButton(UITestControl parent)
            : base(parent)
        {
            SetDefaultProperties();
        }
        #endregion

        #region Properties
        /// <summary>
        /// Gets the text on the button.  Can be used for search.
        /// </summary>
        public virtual string DisplayText
        {
            get
            {
                return ((string)(this.GetProperty(HtmlControls.HtmlButton.PropertyNames.DisplayText)));
            }
        }
        #endregion

        #region Private Methods
        /// <summary>
        /// Sets default properties of the control to be called by the constructor.
        /// </summary>
        internal override void SetDefaultProperties()
        {
            this.controlObject.TechnologyName = "Web";
            this.controlObject.SearchProperties.Add("ControlType", "Button");
            this.controlObject.SearchProperties.Add("TagName", "INPUT");
        }
        #endregion
    }

    /// <summary>
    /// Class representing an Html image.
    /// </summary>
    public class HtmlImage : HtmlControl
    {
        #region Initialization
        /// <summary>
        /// Initializes a HtmlImage instance with null parent control.
        /// </summary>
        public HtmlImage() 
            : this((UITestControl)null) { }

        /// <summary>
        /// Initializes a HtmlImage instance with given WebBrowser.
        /// </summary>
        /// <param name="parent">WebBrowser object that contains HtmlImage to be initialized</param>
        public HtmlImage(WebBrowser parent) 
            : this(parent.activeBrowser) { }

        /// <summary>
        /// Initializes a HtmlImage instance with given parent Html control.
        /// </summary>
        /// <param name="parent">Html control object that contains HtmlImage to be initialized</param>
        public HtmlImage(HtmlControl parent) 
            : this(parent.controlObject) { }

        /// <summary>
        /// Initializes a HtmlImage instance with given parent control.
        /// </summary>
        /// <param name="parent">Control object that contains HtmlImage to be initialized</param>
        private HtmlImage(UITestControl parent)
            : base(parent)
        {
            SetDefaultProperties();
        }
        #endregion

        #region Properties
        /// <summary>
        /// Gets the value of Alt attribute of the image.  Can be used for serach.
        /// </summary>
        public virtual string Alt
        {
            get
            {
                return ((string)(this.GetProperty(HtmlControls.HtmlImage.PropertyNames.Alt)));
            }
        }

        /// <summary>
        /// Gets the value of Src attribute of the image.  Can be used for search.
        /// </summary>
        public virtual string Src
        {
            get
            {
                return ((string)(this.GetProperty(HtmlControls.HtmlImage.PropertyNames.Src)));
            }
        }

        /// <summary>
        /// Gets the absolute path of the image.  Can be used for search.
        /// </summary>
        public virtual string AbsolutePath
        {
            get
            {
                return ((string)(this.GetProperty(HtmlControls.HtmlImage.PropertyNames.AbsolutePath)));
            }
        }

        /// <summary>
        /// Gets the absolute path, if it is an image hyperlink.  Can be used for search.
        /// </summary>
        public virtual string LinkAbsolutePath
        {
            get
            {
                return ((string)(this.GetProperty(HtmlControls.HtmlImage.PropertyNames.LinkAbsolutePath)));
            }
        }

        /// <summary>
        /// Gets the Href, if it is an image hyperlink.  Can be used for search.
        /// </summary>
        public virtual string Href
        {
            get
            {
                return ((string)(this.GetProperty(HtmlControls.HtmlImage.PropertyNames.Href)));
            }
        }
        #endregion

        #region Private Methods
        /// <summary>
        /// Sets default properties of the control to be called by the constructor.
        /// </summary>
        internal override void SetDefaultProperties()
        {
            this.controlObject.TechnologyName = "Web";
            this.controlObject.SearchProperties.Add("ControlType", "Image");
            this.controlObject.SearchProperties.Add("TagName", "IMG");
        }
        #endregion
    }

    /// <summary>
    /// Class representing an Html radio button.
    /// </summary>
    public class HtmlRadioButton : HtmlControl
    {
        #region Initialization
        /// <summary>
        /// Initializes a HtmlRadioButton instance with null parent control.
        /// </summary>
        public HtmlRadioButton() 
            : this((UITestControl)null) { }

        /// <summary>
        /// Initializes a HtmlRadioButton instance with given WebBrowser.
        /// </summary>
        /// <param name="parent">WebBrowser object that contains HtmlRadioButton to be initialized</param>
        public HtmlRadioButton(WebBrowser parent) 
            : this(parent.activeBrowser) { }

        /// <summary>
        /// Initializes a HtmlRadioButton instance with given parent Html control.
        /// </summary>
        /// <param name="parent">Html control object that contains HtmlRadioButton to be initialized</param>
        public HtmlRadioButton(HtmlControl parent) 
            : this(parent.controlObject) { }

        /// <summary>
        /// Initializes a HtmlRadioButton instance with given parent control.
        /// </summary>
        /// <param name="parent">Control object that contains HtmlRadioButton to be initialized</param>
        private HtmlRadioButton(UITestControl parent)
            : base(parent)
        {
            SetDefaultProperties();
        }
        #endregion

        #region Properties
        /// <summary>
        /// Gets whether the radio button is selected or not.  Can be used for search.
        /// </summary>
        public virtual bool Selected
        {
            get
            {
                return ((bool)(this.GetProperty(HtmlControls.HtmlRadioButton.PropertyNames.Selected)));
            }
            set
            {
                this.SetProperty(HtmlControls.HtmlRadioButton.PropertyNames.Selected, value);
            }
        }

        /// <summary>
        /// Gets the value of the radio button's Value attribute.  Can be used for search.
        /// </summary>
        public virtual string Value
        {
            get
            {
                return ((string)(this.GetProperty(HtmlControls.HtmlRadioButton.PropertyNames.Value)));
            }
        }

        /// <summary>
        /// Gets the collection of all radio buttons in the group.
        /// </summary>
        public virtual UITestControlCollection Group
        {
            get
            {
                return ((UITestControlCollection)(this.GetProperty(HtmlControls.HtmlRadioButton.PropertyNames.Group)));
            }
        }

        /// <summary>
        /// Gets the number of radio buttons in the group.  Can be used for search. 
        /// </summary>
        public virtual int ItemCount
        {
            get
            {
                return ((int)(this.GetProperty(HtmlControls.HtmlRadioButton.PropertyNames.ItemCount)));
            }
        }

        /// <summary>
        /// Gets the radio button's label text.  Can be used for search.  
        /// </summary>
        public virtual string LabeledBy
        {
            get
            {
                return ((string)(this.GetProperty(HtmlControls.HtmlRadioButton.PropertyNames.LabeledBy)));
            }
        }
        #endregion

        #region Private Methods
        /// <summary>
        /// Sets default properties of the control to be called by the constructor.
        /// </summary>
        internal override void SetDefaultProperties()
        {
            this.controlObject.TechnologyName = "Web";
            this.controlObject.SearchProperties.Add("ControlType", "RadioButton");
            this.controlObject.SearchProperties.Add("TagName", "INPUT");
        }
        #endregion
    }

    /// <summary>
    /// Class representing an Html check box.
    /// </summary>
    public class HtmlCheckBox : HtmlControl
    {
        #region Initialization
        /// <summary>
        /// Initializes a HtmlCheckBox instance with null parent control.
        /// </summary>
        public HtmlCheckBox() 
            : this((UITestControl)null) { }

        /// <summary>
        /// Initializes a HtmlCheckBox instance with given WebBrowser.
        /// </summary>
        /// <param name="parent">WebBrowser object that contains HtmlCheckBox to be initialized</param>
        public HtmlCheckBox(WebBrowser parent) 
            : this(parent.activeBrowser) { }

        /// <summary>
        /// Initializes a HtmlCheckBox instance with given parent Html control.
        /// </summary>
        /// <param name="parent">Html control object that contains HtmlCheckBox to be initialized</param>
        public HtmlCheckBox(HtmlControl parent) 
            : this(parent.controlObject) { }

        /// <summary>
        /// Initializes a HtmlCheckBox instance with given parent control.
        /// </summary>
        /// <param name="parent">Control object that contains HtmlCheckBox to be initialized</param>
        private HtmlCheckBox(UITestControl parent)
            : base(parent)
        {
            SetDefaultProperties();
        }
        #endregion

        #region Properties
        /// <summary>
        /// Gets or sets checkbox's checked state.  Can be used for search.
        /// </summary>
        public virtual bool Checked
        {
            get
            {
                return ((bool)(this.GetProperty(HtmlControls.HtmlCheckBox.PropertyNames.Checked)));
            }
            set
            {
                this.SetProperty(HtmlControls.HtmlCheckBox.PropertyNames.Checked, value);
            }
        }

        /// <summary>
        /// Gets the value attribute of the check-box.  Can be used for search.
        /// </summary>
        public virtual string Value
        {
            get
            {
                return ((string)(this.GetProperty(HtmlControls.HtmlCheckBox.PropertyNames.Value)));
            }
        }

        /// <summary>
        /// Gets the checkbox's label.  Can be used for search.
        /// </summary>
        public virtual string LabeledBy
        {
            get
            {
                return ((string)(this.GetProperty(HtmlControls.HtmlCheckBox.PropertyNames.LabeledBy)));
            }
        }
        #endregion

        #region Private Methods
        /// <summary>
        /// Sets default properties of the control to be called by the constructor.
        /// </summary>
        internal override void SetDefaultProperties()
        {
            this.controlObject.TechnologyName = "Web";
            this.controlObject.SearchProperties.Add("ControlType", "CheckBox");
            this.controlObject.SearchProperties.Add("TagName", "INPUT");
        }
        #endregion
    }

    /// <summary>
    /// Class representing an Html label
    /// </summary>
    public class HtmlLabel : HtmlControl
    {
        #region Initialization
        /// <summary>
        /// Initializes an HtmlLabel instance with null parent control.
        /// </summary>
        public HtmlLabel()
            : this((UITestControl)null) { }

        /// <summary>
        /// Initializes an HtmlLabel instance with given WebBrowser.
        /// </summary>
        /// <param name="parent">WebBrowser object that contains HtmlLabel to be initialized</param>
        public HtmlLabel(WebBrowser parent)
            : this(parent.activeBrowser) { }

        /// <summary>
        /// Initializes an HtmlLabel instance with given parent Html control.
        /// </summary>
        /// <param name="parent">Html control object that contains HtmlLabel to be initialized</param>
        public HtmlLabel(HtmlControl parent)
            : this(parent.controlObject) { }

        /// <summary>
        /// Initializes an HtmlLabel instance with given parent control.
        /// </summary>
        /// <param name="parent">Control object that contains HtmlLabel to be initialized</param>
        private HtmlLabel(UITestControl parent)
            : base(parent)
        {
            SetDefaultProperties();
        }
        #endregion

        #region Properties
        /// <summary>
        ///  Gets the text on the Label. Can be used for search.
        /// </summary>
        public virtual string DisplayText
        {
            get
            {
                return ((string)(this.GetProperty(HtmlControls.HtmlLabel.PropertyNames.DisplayText)));
            }
        }
        #endregion

        #region Private Methods
        /// <summary>
        /// Sets default properties of the control to be called by the constructor.
        /// </summary>
        internal override void SetDefaultProperties()
        {
            controlObject.TechnologyName = "Web";
            controlObject.SearchProperties.Add("ControlType", "Label");
            controlObject.SearchProperties.Add("TagName", "LABEL");
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\UITest\Exceptions\OperatorNotFoundException.cs ===
﻿using System;

namespace Test.Common.Library.UITest.Exceptions
{
    /// <summary>
    /// Contains information about the exception that is raised when the given operator is not found.
    /// </summary>
    public class OperatorNotFoundException : Exception
    {
        #region Initialization
        /// <summary>
        /// Initializes a new instance of the OperationNotFoundException class with the given operation.
        /// </summary>
        /// <param name="op">The operator.</param>
        public OperatorNotFoundException(Operator op)
            : base(string.Format("The operator ''{0}'' is not found.", op.ToString())) { }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\UITest\ControlObjects\ControlBase.cs ===
﻿using System;
using Microsoft.VisualStudio.TestTools.UITesting;

namespace Test.Common.Library.UITest
{
    /// <summary>
    /// Abstract base class that represents a generic UI control object.
    /// </summary>
    public abstract class ControlBase
    {
        #region Initialization
        /// <summary>
        /// Initializes a ControlBase and creates a control object with null parent.
        /// </summary>
        protected ControlBase()
        {
            controlObject = new UITestControl(null);
            SetDefaultProperties();
        }

        /// <summary>
        /// Initializes a ControlBase and creates a control object with given parent control.
        /// </summary>
        /// <param name="parent">Parent control object that contains Control Base object to be initialized.</param>
        protected ControlBase(UITestControl parent)
        {
            controlObject = new UITestControl(parent);
            SetDefaultProperties();
        }
        #endregion

        #region Fields
        /// <summary>
        /// Actual control object that drives the automation.
        /// </summary>
        internal UITestControl controlObject = null;
        #endregion

        #region Private Methods
        /// <summary>
        /// Sets default properties of the control to be called by the constructor.
        /// </summary>
        internal virtual void SetDefaultProperties() { }
        #endregion

        #region Get/Set Properties
        /// <summary>
        /// Gets the property value for the given property name.
        /// </summary>
        /// <param name="propertyName">Name of the property.</param>
        /// <returns>Value of the given property.</returns>
        public virtual object GetProperty(string propertyName)
        {
            return controlObject.GetProperty(propertyName);
        }

        /// <summary>
        /// Sets the property value for the given property name.
        /// </summary>
        /// <param name="propertyName">Name of the property.</param>
        /// <param name="value">Value of the property to set.</param>
        public virtual void SetProperty(string propertyName, object value)
        {
            controlObject.SetProperty(propertyName, value);
        }
        #endregion

        #region Search Methods
        /// <summary>
        /// Adds the given property-value pairs to identify a control. If the property 
        /// with the same name already exists, then updates its value.
        /// </summary>
        /// <param name="nameValuePairs">Property-value pairs.</param>
        public virtual void AddSearchProperties(params string[] nameValuePairs)
        {
            controlObject.SearchProperties.Add(nameValuePairs);
        }

        /// <summary>
        /// Adds a range of UIProperty objects to identify a control. If the property 
        /// with the same name already exists, then updates its value.
        /// </summary>
        /// <param name="searchPropertyList">UIProperty objects to be added.</param>
        public virtual void AddSearchProperties(params UIProperty[] searchPropertyList)
        {
            foreach (UIProperty property in searchPropertyList)
            {
                PropertyExpressionOperator expOperator;

                switch (property.PropertyOperator)
                {
                    case Operator.Contains:
                        expOperator = PropertyExpressionOperator.Contains;
                        break;
                    case Operator.EqualTo:
                    default:
                        expOperator = PropertyExpressionOperator.EqualTo;
                        break;
                }

                controlObject.SearchProperties.Add(new PropertyExpression(property.PropertyName, property.PropertyValue, expOperator));
            }
        }
        
        /// <summary>
        /// Adds a search configuration.
        /// </summary>
        /// <param name="configuration">Search configuration to add.</param>
        public virtual void AddSearchConfiguration(string configuration)
        {
            controlObject.SearchConfigurations.Add(configuration);
        }

        /// <summary>
        /// Removes a search configuration.
        /// </summary>
        /// <param name="configuration">Search configuration to remove.</param>
        public virtual void RemoveSearchConfiguration(string configuration)
        {
            controlObject.SearchConfigurations.Remove(configuration);
        }

        /// <summary>
        /// Returns a formatted string for when the current control is not found.
        /// </summary>
        /// <returns>Formatted string for when the current control is not found.</returns>
        public string GetControlNotFoundExceptionString()
        {
            string message = string.Format("The following {0} control does not exist.", this.GetType().Name);

            if (this.controlObject.SearchProperties.Count > 0)
            {
                message += "Additional Details:";
                foreach (PropertyExpression exp in this.controlObject.SearchProperties)
                {
                    message += "\n" + exp.ToString();
                }
            }

            return message;
        }
        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\UITest\Exceptions\PageTimeOutException.cs ===
﻿using System;

namespace Test.Common.Library.UITest.Exceptions
{
    /// <summary>
    /// Contains information about the exception that is raised when page time out expires.
    /// </summary>
    public class PageTimeOutException : Exception
    {
        #region Initialization
        /// <summary>
        /// Initializes a new instance of the PageTimeOutException class with the number of seconds in timeout.
        /// </summary>
        /// <param name="timeOutInSeconds">Timeout in seconds.</param>
        public PageTimeOutException(int timeOutInSeconds)
            : base(string.Format("Timeout expired. Waited {0} seconds.", timeOutInSeconds)) { }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\UnifiedLogger\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\UITest\Exceptions\ControlNotFoundException.cs ===
﻿using System;

namespace Test.Common.Library.UITest.Exceptions
{
    /// <summary>
    /// Contains information about the exception that is raised when ControlBase.Exists returns false.
    /// </summary>
    public class ControlNotFoundException : Exception
    {
        #region Initialization
        /// <summary>
        /// Initializes a new instance of the ControlNotFoundException class with the control that is not found.
        /// </summary>
        /// <param name="control">Control object to find.</param>
        public ControlNotFoundException(ControlBase control)
            : base(control.GetControlNotFoundExceptionString())
        {
            this.ControlToFind = control;
        }

        #endregion

        #region Properties
        /// <summary>
        /// Control object to find.
        /// </summary>
        public ControlBase ControlToFind { get; private set; }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\UITest\Factory\UIElementFactory.cs ===
﻿using System;
using System.Collections.Generic;
using Microsoft.VisualStudio.TestTools.UITesting;
using Test.Common.Library.UITest.Exceptions;

namespace Test.Common.Library.UITest
{
    /// <summary>
    /// Factory class with static methods to get ControlBase objects from control scope and search name-value pairs.
    /// </summary>
    public class UIElementFactory
    {
        #region GetUIElement Methods
        /// <summary>
        /// Returns an object of type T, where T is of base type ControlBase, with given name-value search parameters.
        /// </summary>
        /// <typeparam name="T">Type of ControlBase object to return.</typeparam>
        /// <param name="nameValuePairs">Name-value pairs to include in search paramters.</param>
        /// <returns>UI element object of type T.</returns>
        public static T GetUIElement<T>(params string[] nameValuePairs) where T : ControlBase, new()
        {
            return GetUIElement<T>(null, nameValuePairs);
        }

        /// <summary>
        /// Returns an object of type T, where T is of base type ControlBase, with given scope in which to search the UI element and a name-value pair to search for.
        /// </summary>
        /// <typeparam name="T">Type of ControlBase object to return.</typeparam>
        /// <param name="controlScope">Scope in which to search the UI element.</param>
        /// <param name="propertyName">Name of the search property.</param>
        /// <param name="propertyValue">Value of the search property.</param>
        /// <returns>UI element object of type T.</returns>
        public static T GetUIElement<T>(ControlBase controlScope, string propertyName, string propertyValue) where T : ControlBase, new()
        {
            return GetUIElement<T>(controlScope, GetUIPropertyList(propertyName, propertyValue));
        }

        /// <summary>
        /// Returns an object of type T, where T is of base type ControlBase, with given scope in which to search the UI element and name-value pairs to search for.
        /// </summary>
        /// <typeparam name="T">Type of ControlBase object to return.</typeparam>
        /// <param name="controlScope">Scope in which to search the UI element.</param>
        /// <param name="nameValuePairs">Name-value pairs to include in search paramters.</param>
        /// <returns>UI element object of type T.</returns>
        public static T GetUIElement<T>(ControlBase controlScope, params string[] nameValuePairs) where T : ControlBase, new()
        {
            return GetUIElement<T>(controlScope, GetUIPropertyList(nameValuePairs));
        }

        /// <summary>
        /// Returns an object of type T, where T is of base type ControlBase, with given scope in which to search the UI element and an array of UI properties to search for.
        /// </summary>
        /// <typeparam name="T">Type of ControlBase object to return.</typeparam>
        /// <param name="controlScope">Scope in which to search the UI element.</param>
        /// <param name="searchPropertyList">Array of UI properties to include in search paramters.</param>
        /// <returns>UI element object of type T.</returns>
        public static T GetUIElement<T>(ControlBase controlScope, UIProperty[] searchPropertyList) where T : ControlBase, new()
        {
            UITestControl controlObject;

            if (controlScope == null)
            {
                controlObject = new UITestControl(null);
            }
            else
            {
                controlObject = new UITestControl(controlScope.controlObject);
            }
            return GetUIElement<T>(controlObject, searchPropertyList);
        }

        /// <summary>
        /// Returns an object of type T, where T is of base type ControlBase, with given control scope in which to search the UI element and UI properties to search for.
        /// </summary>
        /// <typeparam name="T">Type of ControlBase object to return.</typeparam>
        /// <param name="controlObject">Scope in which to search the UI element.</param>
        /// <param name="searchPropertyList">UI properties to include in search paramters.</param>
        /// <returns>UI element object of type T.</returns>
        private static T GetUIElement<T>(UITestControl controlObject, params UIProperty[] searchPropertyList) where T : ControlBase, new()
        {            
            T element = new T();
            element.controlObject = controlObject;
            element.SetDefaultProperties();
            element.AddSearchProperties(searchPropertyList);
            return element;
        }

        /// <summary>
        /// Returns a Html object of type T, where T is of base type ControlBase, in the currently active WebBrowser instance with given name-value search parameters.
        /// </summary>
        /// <typeparam name="T">Type of ControlBase object to return.</typeparam>
        /// <param name="nameValuePairs">Name-value pairs to include in search paramters.</param>
        /// <returns>Html element object of type T.</returns>
        public static T GetWebUIElement<T>(params string[] nameValuePairs) where T : ControlBase, new()
        {
            return GetWebUIElement<T>(GetUIPropertyList(nameValuePairs));
        }

        /// <summary>
        /// Returns a Html object of type T, where T is of base type ControlBase, in the currently active WebBrowser instance with given UI properties to search for.
        /// </summary>
        /// <typeparam name="T">Type of ControlBase object to return.</typeparam>
        /// <param name="searchPropertyList">UI properties to include in search parameters.</param>
        /// <returns>Html element object of type T.</returns>
        public static T GetWebUIElement<T>(params UIProperty[] searchPropertyList) where T : ControlBase, new()
        {
            return GetUIElement<T>(new UITestControl(WebBrowserFactory.CurrentBrowser.activeBrowser), searchPropertyList);
        }
        #endregion

        #region Methods to Find Others
        /// <summary>
        /// Returns a list of objects of type T, where T is of base type ControlBase, that matches the given match object.
        /// </summary>
        /// <typeparam name="T">Type of ControlBase objects to return.</typeparam>
        /// <param name="matchItem">Object to match.</param>
        /// <returns>List of objects of type T that matches the given match object.</returns>
        public static List<T> FindMatchingControls<T>(ControlBase matchItem) where T : ControlBase, new()
        {
            UITestControlCollection collection = matchItem.controlObject.FindMatchingControls();

            List<T> matchList = new List<T>(collection.Count);
            foreach (UITestControl uicontrol in collection)
            {
                T control = new T();
                control.controlObject = uicontrol;
                matchList.Add(control);
            }
            return matchList;
        }

        /// <summary>
        /// Returns a list of all first level children of the given parent object.
        /// </summary>
        /// <typeparam name="T">Type of ControlBase objects to return.</typeparam>
        /// <param name="parentItem">Parent object from which to retrieve first level children.</param>
        /// <returns>List of children objects of type T.</returns>
        public static List<T> GetChildren<T>(ControlBase parentItem) where T : ControlBase, new()
        {
            UITestControlCollection collection = parentItem.controlObject.GetChildren();

            List<T> childrenList = new List<T>(collection.Count);
            foreach (UITestControl uicontrol in collection)
            {
                T control = new T();
                control.controlObject = uicontrol;
                childrenList.Add(control);
            }
            return childrenList;
        }
        #endregion

        #region Methods to find control objects
        /// <summary>
        /// Returns whether or not a control is available on the current web browser in the given number of trials and wait time between the trials.
        /// </summary>
        /// <param name="htmlControl">Html control to look for.</param>
        /// <param name="trialCount">Number or trials.</param>
        /// <param name="waitTimeInSeconds">Wait time in seconds between trials.</param>
        /// <returns>True if the control is found; false otherwise.</returns>
        public static bool TryFindHtmlControl(HtmlControl htmlControl, int trialCount, int waitTimeInSeconds)
        {
            Exception searchError = null;
            while (trialCount > 0)
            {
                try
                {
                    if (htmlControl.Exists)
                    {
                        Logger.WriteLine(string.Format("Control {0} found", htmlControl.GetType().Name));
                        return true;
                    }
                    else
                    {
                        throw new ControlNotFoundException(htmlControl);
                    }
                }
                catch (Exception ex)
                {
                    trialCount--;
                    searchError = ex;
                    Logger.WriteLine(string.Format("Page not fully loaded. Waiting {1} seconds. Trials remaining: {0}", trialCount, waitTimeInSeconds));
                    UITestManager.Wait(waitTimeInSeconds * 1000);
                }
            }
            if (searchError != null)
            {
                Logger.WriteException(searchError, false);
                Logger.WriteException(new PageTimeOutException(trialCount * waitTimeInSeconds), true);
            }

            return false;
        }
        #endregion

        #region Private Helper Methods
        /// <summary>
        /// Returns an array of UIProperty objects from the given name-value pairs with default operator set to EqualTo.
        /// </summary>
        /// <param name="nameValuePairs">Name-value pairs.</param>
        /// <returns>Array of UIProperty objects.</returns>
        private static UIProperty[] GetUIPropertyList(params string[] nameValuePairs)
        {
            List<UIProperty> searchPropertyList = new List<UIProperty>();
            for (int i = 0; i < nameValuePairs.Length; i += 2)
            {
                searchPropertyList.Add(new UIProperty(nameValuePairs[i], nameValuePairs[i + 1]));
            }
            return searchPropertyList.ToArray();
        }
        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\UITest\Factory\WebBrowserFactory.cs ===
﻿using System;
using Microsoft.VisualStudio.TestTools.UITesting;

namespace Test.Common.Library.UITest
{
    /// <summary>
    /// Class for managing and setting currently active instance of WebBrowser.
    /// </summary>
    public static class WebBrowserFactory
    {
        #region Properties
        /// <summary>
        /// Gets or sets the type of the WebBrowser. Current version of RnP does not support multiple browser types and versions very well.
        /// </summary>
        public static BrowserType BrowserType { get; set; }

        /// <summary>
        /// Gets the currently active browser instance. If CurrentBrowser is null, a new WebBrowser is initialized and returned.
        /// </summary>
        public static WebBrowser CurrentBrowser
        {
            get
            {
                if (currentBrowser == null)
                {
                    LaunchWebBrowser();
                    return currentBrowser;
                }
                return currentBrowser;
            }
            private set
            {
                currentBrowser = value;
            }
        }
        #endregion

        #region Fields
        /// <summary>
        /// Private instance of the current browser object.
        /// </summary>
        private static WebBrowser currentBrowser;
        #endregion

        #region Public Methods
        /// <summary>
        /// Sets current browser instance to one that matches the given title.
        /// </summary>
        /// <param name="Title">Title of the browser instance.</param>
        public static void SetCurrentBrowser(string Title)
        {
            currentBrowser = new WebBrowser(new BrowserWindow());
            currentBrowser.activeBrowser.SearchProperties.Add("Name", Title);
        }

        /// <summary>
        /// Launches a new WebBrowser instance and sets it as currently active.
        /// </summary>
        public static void LaunchWebBrowser()
        {
            currentBrowser = WebBrowser.Launch();
        }

        /// <summary>
        /// Launches a new WebBrowser instance to the given Uri and sets it as currently active.
        /// </summary>
        /// <param name="uri">Uri to navigate to.</param>
        public static void LaunchWebBrowser(Uri uri)
        {
            LaunchWebBrowser(uri, false, false);
        }

        /// <summary>
        /// Launches a new WebBrowser instance to the given Uri and sets it as currently active. Can clear cache or cookies.
        /// </summary>
        /// <param name="uri">Uri to navigate to.</param>
        /// <param name="clearCache">True to clear all existing cache; false otherwise.</param>
        /// <param name="clearCookies">True to clear all existing cookies; false otherwise.</param>
        public static void LaunchWebBrowser(Uri uri, bool clearCache, bool clearCookies)
        {
            LaunchWebBrowser(uri, false, false, false);
        }

        /// <summary>
        /// Launches a new WebBrowser instance to the given Uri and sets it as currently active. Can clear cache or cookies, and close all open browsers.
        /// </summary>
        /// <param name="uri">Uri to navigate to.</param>
        /// <param name="clearCache">True to clear all existing cache; false otherwise.</param>
        /// <param name="clearCookies">True to clear all existing cookies; false otherwise.</param>
        /// <param name="closeOpenBrowsers">True to close all open browsers; flase otherwise.</param>
        public static void LaunchWebBrowser(Uri uri, bool clearCache, bool clearCookies, bool closeOpenBrowsers)
        {
            currentBrowser = WebBrowser.Launch(uri, clearCache, clearCookies, closeOpenBrowsers);
        }
        #endregion

        #region Private Methods
        /// <summary>
        /// Sets current browser instance to the given WebBrowser instance.
        /// </summary>
        /// <param name="browser">WebBrowser instance to set currently active.</param>
        internal static void SetActiveInstance(WebBrowser browser)
        {
            currentBrowser = browser;
        }

        /// <summary>
        /// Sets current browser instance to a WebBrowser object for the given window handle.
        /// </summary>
        /// <param name="browserHandle">Window handle of the browser instance to set currently active.</param>
        internal static void SetActiveInstance(IntPtr browserHandle)
        {
            currentBrowser = WebBrowser.FromWindowHandle(browserHandle);
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\UITest\Factory\UIProperty.cs ===
﻿using Microsoft.VisualStudio.TestTools.UITesting;

namespace Test.Common.Library.UITest
{
    /// <summary>
    /// Class representing a name-value pair of search properties with an optional search Operator.
    /// </summary>
    public class UIProperty
    {
        #region Initialization
        /// <summary>
        /// Initializes a UIProperty instance from given property name and value.
        /// </summary>
        /// <param name="propertyName">Name of the property.</param>
        /// <param name="propertyValue">Value of the property.</param>
        public UIProperty(string propertyName, string propertyValue)
            : this(propertyName, propertyValue, Operator.EqualTo) { }

        /// <summary>
        /// Initializes a UIProperty instance from given property name, value and operator.
        /// </summary>
        /// <param name="propertyName">Name of the property.</param>
        /// <param name="propertyValue">Value of the property.</param>
        /// <param name="propertyOperator">Operator to use for matching value.</param>
        public UIProperty(string propertyName, string propertyValue, Operator propertyOperator)
        {
            PropertyName = propertyName;
            PropertyValue = propertyValue;
            PropertyOperator = propertyOperator;
        }
        #endregion

        #region Properties
        /// <summary>
        /// Gets or sets the property name.
        /// </summary>
        public string PropertyName { get; set; }

        /// <summary>
        /// Gets or set the property value.
        /// </summary>
        public string PropertyValue { get; set; }

        /// <summary>
        /// Gets or sets the property operator.
        /// </summary>
        public Operator PropertyOperator { get; set; }
        #endregion

        #region Public Methods
        /// <summary>
        /// Returns a string representation of the object.
        /// </summary>
        /// <returns>String representation of the object.</returns>
        public override string ToString()
        {
            return string.Format("{0} {1} {2}", PropertyName, PropertyOperator.ToString(), PropertyValue);
        }
        #endregion
    }

    /// <summary>
    /// Operator to use for matching the property value.
    /// </summary>
    public enum Operator
    {
        /// <summary>
        /// The target and property values are equal.
        /// </summary>
        EqualTo = PropertyExpressionOperator.EqualTo,

        /// <summary>
        /// The property value contains the target.
        /// </summary>
        Contains = PropertyExpressionOperator.Contains,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\UITest\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Test.Common.Library.UITest")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
//[assembly: AssemblyCompany("Microsoft")]
//[assembly: AssemblyProduct("Test.Common.Library.UITest")]
//[assembly: AssemblyCopyright("Copyright © Microsoft 2009")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("255afc3d-07b8-43b6-a224-2757dcb0deee")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
//[assembly: AssemblyVersion("1.0.0.0")]
//[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\UITest\Validations\ValidationRule.cs ===
﻿using System;

namespace Test.Common.Library.UITest
{
    /// <summary>
    /// Abstract base class to validate contents.
    /// </summary>
    public abstract class ValidationRule
    {
        #region Initialization
        /// <summary>
        /// Initializes a ValidationRule instance.
        /// </summary>
        protected ValidationRule()
        {
            Result = new ValidationResult();
        }
        #endregion

        #region Properties
        /// <summary>
        /// Gets the result of the validation rule.
        /// </summary>
        public ValidationResult Result { get; private set; }

        /// <summary>
        /// Gets the description of the validation rule.
        /// </summary>
        public abstract string RuleDescription { get; }

        /// <summary>
        /// Gets the name of the validation rule.
        /// </summary>
        public string RuleName
        {
            get
            {
                return this.GetType().Name;
            }
        }
        #endregion

        #region Public Methods
        /// <summary>
        /// Validates the content within the sender.
        /// </summary>
        /// <param name="sender">Object to validate.</param>
        public abstract void Validate(WebPage sender);
        #endregion
    }

    /// <summary>
    /// Class representing the result of the validation.
    /// </summary>
    public class ValidationResult
    {
        #region Properties
        /// <summary>
        /// Gets or sets the name of the rule.
        /// </summary>
        public string RuleName { get; set; }

        /// <summary>
        /// Gets or sets whether or not the validation is passed.
        /// </summary>
        public bool IsValid { get; set; }

        /// <summary>
        /// Gets or sets the message that describes the validation attempts.
        /// </summary>
        public string Message { get; set; }

        /// <summary>
        /// Gets or sets the exception captured during validation attempts.
        /// </summary>
        public Exception Exception { get; set; }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\UnifiedLogger\UnifiedLogger\TRXTestResult.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using TrxGenerator;

namespace Test.Common.Library.UnifiedLogger
{
	/// <summary>
	/// Represents a test result in the TRX log.
	/// </summary>
    public class TRXTestResult
	{
		#region private fields
		string _SessionId = "";
		string _BuildNumber = "";
		string _TestName = "";
		string _Description = "";
		string _ProjectAreaGUID = "";
		string _TestOwnerAlias = "";
		string _Message = "";
		TrxE2EGenerator.TestingCategory _TestingCategory;
		Logger.TestOutcome _TestResult;
		TrxE2EGenerator.Flavor _BuildType;
		TrxE2EGenerator.Platform _Platform;
		DateTime _StartDate;
		#endregion

		#region Public Properties
		/// <summary>
		/// The Test Session Id for the TRX log.
		/// </summary>
        public string SessionId
		{
			get { return _SessionId; }
			set { _SessionId = value; }
		}

        /// <summary>
        /// The Build number of the build on which the test was executed.
        /// </summary>
		public string BuildNumber
		{
			get { return _BuildNumber; }
			set { _BuildNumber = value; }
		}

        /// <summary>
        /// The name of the test.
        /// </summary>
		public string TestName
		{
			get { return _TestName; }
			set { _TestName = value; }
		}

        /// <summary>
        /// The description of the test.
        /// </summary>
		public string Description
		{
			get { return _Description; }
			set { _Description = value; }
		}

        /// <summary>
        /// The TFS Area GUID under which this test belongs.
        /// </summary>
		public string ProjectAreaGUID
		{
			get { return _ProjectAreaGUID; }
			set { _ProjectAreaGUID = value; }
		}

        /// <summary>
        /// The test owner alias.
        /// </summary>
		public string TestOwnerAlias
		{
			get { return _TestOwnerAlias; }
			set { _TestOwnerAlias = value; }
		}

        /// <summary>
        /// The message text to add to the test result.
        /// </summary>
		public string Message
		{
			get { return _Message; }
			set { _Message = value; }
		}

        /// <summary>
        /// The category under which this test belongs.
        /// </summary>
		public TrxE2EGenerator.TestingCategory TestingCategory
		{
			get { return _TestingCategory; }
			set { _TestingCategory = value; }
		}

        /// <summary>
        /// The result of the test.
        /// </summary>
		public Logger.TestOutcome Result
		{
			get { return _TestResult; }
			set { _TestResult = value; }
		}

        /// <summary>
        /// The Build type of the build on which the test was executed.
        /// </summary>
		public TrxE2EGenerator.Flavor BuildType
		{
			get { return _BuildType; }
			set { _BuildType = value; }
		}

        /// <summary>
        /// The platform on which the test was executed.
        /// </summary>
		public TrxE2EGenerator.Platform Platform
		{
			get { return _Platform; }
			set { _Platform = value; }
		}

        /// <summary>
        /// The start timestamp of the test.
        /// </summary>
		public DateTime StartDate
		{
			get { return _StartDate; }
			set { _StartDate = value; }
		}
		#endregion

		#region Constructors
		/// <summary>
		/// Initialize a new instance of the TRXTestResult class.
		/// </summary>
        public TRXTestResult()
		{
			_StartDate = DateTime.Now;
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\UnifiedLogger\UnifiedLogger\Logger.cs ===
﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.IO;
using TrxGenerator;
using Microsoft.DistributedAutomation.Logger;

namespace Test.Common.Library.UnifiedLogger
{
	/// <summary>
	/// Represents the test Logger.
	/// </summary>
    /// <remarks>
    /// If you are referencing this project, make sure you have a post build task
    /// in your project to copy down WTTLog.dll to the Build Output folder.
    /// </remarks>
    public class Logger : IDisposable
	{
		#region private fields
        /// <summary>
        /// The number of test results added to the logger.
        /// This is primarily used by the TRX module, as we have a uppper limit of 3000 test results.
        /// </summary>
		private int _testCount;
        /// <summary>
        /// The TRX session GUID.
        /// </summary>
		private string _testSessionGuid = "";
        /// <summary>
        /// The path where the log files will be created.
        /// </summary>
		private string _logFilePath = "";
        /// <summary>
        /// The name of the WTT Log file.
        /// </summary>
        private string _wttLogFileName = "";
        /// <summary>
        /// The name of the Text Log file.
        /// </summary>
        private string _textLogFileName = "";
        /// <summary>
        /// A collection to keep the added test results in memory.
        /// This is used by the TRX module.
        /// </summary>
		private Hashtable _testResults;
        /// <summary>
        /// The TRX generator object.
        /// </summary>
		private TrxE2EGenerator _generator;
        /// <summary>
        /// The type of logging flag.
        /// </summary>
		private LoggingType _loggingType;
        /// <summary>
        /// The WTT Logger object.
        /// </summary>
        private TestLogger _wttLogger = null;
        /// <summary>
        /// Indicates if the object has been disposed.
        /// </summary>
        private bool _IsDisposed;
        /// <summary>
        /// Indicates if the TRX session has been closed.
        /// </summary>
        private bool _IsTRXSessionClosed;
		/// <summary>
		/// Project Area Guid for TRX file. This allows the TRX file to be uploaded
        /// to TFS and associated with a particular project area.
		/// </summary>
		private string _projectAreaGuid;
        /// <summary>
        /// Indicates whether to append to an existing log file, or to overwrite it.
        /// </summary>
        private WriteMode _logWriteMode;
		/// <summary>
		/// Name of the last test started.
		/// </summary>
		private string _lastTestName;
		#endregion

		#region Public Properties
		/// <summary>
		/// Number of tests added so far this run.
		/// </summary>
		public int TestCount
		{
			get { return _testCount; }
		}
		/// <summary>
		/// File Path for the log file(s).
		/// </summary>
        public string LogFilePath
        {
            get { return _logFilePath; }
        }
        /// <summary>
        /// The file name for the WTT Log file.
        /// NOTE: The TRX filename cannot be specified. It is autogenerated. This is by design.
        /// </summary>
        public string WTTLogFileName
        {
            get { return _wttLogFileName; }
        }
        /// <summary>
        /// The file name for the Text Log file.
        /// NOTE: The TRX filename cannot be specified. It is autogenerated. This is by design.
        /// </summary>
        public string TextLogFileName
        {
            get { return _textLogFileName; }
        }
        /// <summary>
        /// The write mode of the log files.
        /// NOTE: This is only applicable for WTT and Text log files. TRX logs will always be overwritten.
        /// </summary>
        public WriteMode LogWriteMode
        {
            get { return _logWriteMode; }
        }
		/// <summary>
		/// Name of the Last Test Started.
		/// </summary>
		public string LastTestName
		{
			get { return _lastTestName; }
			set { _lastTestName = value; }
		}
		/// <summary>
		/// Logging Type bitmask
		/// </summary>
		[Serializable]
		[Flags]
		public enum LoggingType
		{
			/// <summary>
			/// Represents VSTS 2008 TRX logging.
			/// </summary>
            TRX = 1,
            /// <summary>
            /// Represents WTT 2.6 logging.
            /// </summary>
			WTT = 2,
            /// <summary>
            /// Represents plain text file logging.
            /// </summary>
			Text = 4
		}

		/// <summary>
		/// Message Type.  The message type will be prepended to each message added to the test log.
		/// </summary>
		public enum MessageType
		{
			/// <summary>
			/// Indicates an informational message.
			/// </summary>
            Info,
            /// <summary>
            /// Indicates a warning message.
            /// </summary>
			Warning,
            /// <summary>
            /// Indicates an error message.
            /// </summary>
			Error,
            /// <summary>
            /// Indicates a message about a bug.
            /// </summary>
			Bug
		}

		/// <summary>
		/// Result of the test.
		/// </summary>
		public enum TestOutcome
		{
			/// <summary>
			/// Indicates that the test has not completed.
			/// </summary>
            Incomplete,
            /// <summary>
            /// Indicates that the test was invalid.
            /// </summary>
			Invalid,
            /// <summary>
            /// Indicates that the test passed.
            /// </summary>
			Pass,
            /// <summary>
            /// Indicates that the test failed.
            /// </summary>
			Fail,
            /// <summary>
            /// Indicates that the test is blocked, possibly due to a bug.
            /// </summary>
			Blocked,
            /// <summary>
            /// Indicates that the test test resulted in a warning.
            /// </summary>
			Warning,
            /// <summary>
            /// Indicates that the test was skipped.
            /// </summary>
			Skipped,
            /// <summary>
            /// Indicates that the test resulted in an error.
            /// </summary>
			Error
		}

        /// <summary>
        /// The write mode of the WTT or Text log files.
        /// </summary>
        public enum WriteMode
        {
            /// <summary>
            /// Indicates that the log file will overwrite any existing log file
            /// with the same name.
            /// </summary>
            OverWrite,
            /// <summary>
            /// Indicates that the log file will append to any existing lof file
            /// with the same name.
            /// </summary>
            Append
        }

        /// <summary>
        /// The type of the build.
        /// NOTE: This will only be used by the TRX log.
        /// </summary>
        public enum BuildType
        {
            /// <summary>
            /// Indicates a Release build.
            /// </summary>
            Release = 0,
            /// <summary>
            /// Indicates a Debug build.
            /// </summary>
            Debug = 1,
        }

        /// <summary>
        /// The platform where the test is executed.
        /// NOTE: This will only be used by the TRX log.
        /// </summary>
        public enum Platform
        {
            /// <summary>
            /// Indicates any platform.
            /// </summary>
            AnyCPU = 0,
            /// <summary>
            /// Indicates a x86 platform.
            /// </summary>
            x86 = 1,
        }

        /// <summary>
        /// The category of the test.
        /// NOTE: This will only be used by the TRX log.
        /// </summary>
        public enum TestingCategory
        {
            /// <summary>
            /// Indicates an End To End Test.
            /// </summary>
            E2E = 0,
            /// <summary>
            /// Indicates a Build Verification Test.
            /// </summary>
            BVT = 1,
            /// <summary>
            /// Indicates a Functional Test.
            /// </summary>
            Functional = 2,
            /// <summary>
            /// Indicates a Customer Story Test.
            /// </summary>
            CustomerStory = 3,
            /// <summary>
            /// Indicates a Pre-CheckIn test.
            /// </summary>
            PreCheckin = 4,
            /// <summary>
            /// Indicates a EVT Test.
            /// </summary>
            EVT = 5,
            /// <summary>
            /// Indicates a Load Test.
            /// </summary>
            Load = 6,
            /// <summary>
            /// Indicates a Stress Test.
            /// </summary>
            Stress = 7,
        }
		#endregion

		#region Constructors
		/// <summary>
        /// Initializes a new instance of the Logger class.
		/// </summary>
        /// <remarks>
        /// This will create log files for all the 3 log types. The log files will be created with default file names
        /// in the same folder as the application. Default file names are as follows:
        ///     TRX   - This file name is autogenerated and cannot be set by user. This is a TRX restriction.
        ///     WTT   - The log file will be named 'WTTLog.wtl'.
        ///     Text  - The log file will be named 'TextLog.log'.
        /// The WTT and the Text log files will be created in Append mode.
        /// </remarks>
        public Logger()
            : this(LoggingType.TRX | LoggingType.WTT | LoggingType.Text)
        { }
         
        /// <summary>
        /// Initializes a new instance of the Logger class.
        /// </summary>
        /// <param name="type">Bit mask of logging types for the Logger to use.</param>
        /// <remarks>
        /// This will create log of the specified type(s) with default filename(s) in the same folder as the application.
        /// Default file names are as follows:
        ///     TRX   - This file name is autogenerated and cannot be set by user. This is a TRX restriction.
        ///     WTT   - The log file will be named 'WTTLog.wtl'.
        ///     Text  - The log file will be named 'TextLog.log'.
        /// The WTT and / or the Text log file (if specified) will be created in Append mode.
        /// </remarks>
        public Logger(LoggingType type)
            : this(type, WriteMode.Append)
        { }

		/// <summary>
		/// Initializes a new instance of the Logger class.
		/// </summary>
		/// <param name="type">Bit mask of logging types for the Logger to use.</param>
        /// <param name="logWriteMode">The write mode of the WTT and / or the Text log file(s).</param>
        /// <remarks>
        /// This will create log of the specified type(s) with default filename(s) in the same folder as the application.
        /// Default file names are as follows:
        ///     TRX   - This file name is autogenerated and cannot be set by user. This is a TRX restriction.
        ///     WTT   - The log file will be named 'WTTLog.wtl'.
        ///     Text  - The log file will be named 'TextLog.log'.
        /// </remarks>
        public Logger(LoggingType type, WriteMode logWriteMode)
            : this(type, logWriteMode, null, null, null, null)
        { }

        /// <summary>
        /// Initializes a new instance of the Logger class.
        /// </summary>
        /// <param name="type">Bit mask of logging types for the Logger to use.</param>
        /// <param name="logFilePath">The path where the logs will be created. One will be created if it does not exist.</param>
        /// <param name="projectAreaGUID">
        /// Project Area Guid for TRX file. This allows the TRX file to be uploaded to TFS 
        /// and associated with a particular project area.
        /// </param>
        /// <remarks>
        /// This will create log of the specified type(s) with default filename(s).
        /// Default file names are as follows:
        ///     TRX   - This file name is autogenerated and cannot be set by user. This is a TRX restriction.
        ///     WTT   - The log file will be named 'WTTLog.wtl'.
        ///     Text  - The log file will be named 'TextLog.log'.
        /// </remarks>
        public Logger(LoggingType type, string logFilePath, string projectAreaGUID)
            : this(type, WriteMode.Append, logFilePath, null, null, projectAreaGUID)
        { }

        /// <summary>
        /// Initializes a new instance of the Logger class.
        /// </summary>
        /// <param name="type">Bit mask of logging types for the Logger to use.</param>
        /// <param name="logWriteMode">The write mode of the WTT and / or the Text log file(s).</param>
        /// <param name="logFilePath">The path where the logs will be created. This path should already exist.</param>
        /// <param name="wttLogFileName">The name of the WTT log file. Set this to NULL or empty if you're not creating a WTT Log
        /// or if you want to use the default WTT log filename.</param>
        /// <param name="textLogFileName">The name of the Text log file. Set this to NULL or empty if you're not creating a Text Log
        /// or if you want to use the default Text log filename.</param>
        /// <param name="projectAreaGUID">Project Area Guid for TRX file. This allows the TRX file to be uploaded to TFS 
        /// and associated with a particular project area.</param>
        /// <remarks>
        /// NOTE: The TRX log filename will be autogenerated, and cannot be set by the user. This is by design.
        /// </remarks>
        public Logger(LoggingType type, WriteMode logWriteMode, string logFilePath, 
            string wttLogFileName, string textLogFileName, string projectAreaGUID)
        {
            _loggingType = type;
            _logFilePath = logFilePath;
            _wttLogFileName = wttLogFileName;
            _textLogFileName = textLogFileName;
            _logWriteMode = logWriteMode;
			_projectAreaGuid = (null == projectAreaGUID ? "" : projectAreaGUID);

            #region Check Params
            if (!String.IsNullOrEmpty(_logFilePath))
            {
                _logFilePath = _logFilePath.Trim();
                if (_logFilePath.Substring(_logFilePath.Length - 1, 1) == "\\")                         //Remove traling '\' from path
                    _logFilePath = _logFilePath.Substring(0, _logFilePath.Length - 1);

                if (!Directory.Exists(_logFilePath))
                {
                    //Create the folder
                    Directory.CreateDirectory(_logFilePath);
                }
            }

            if (!String.IsNullOrEmpty(_wttLogFileName))
            {
                if (_wttLogFileName.IndexOf("\\") >= 0)
                    throw new Exception("The WTT Log filename has invalid character '\'. If you want to specify the folder name, do so via the logFilePath param.");
            }

            if (!String.IsNullOrEmpty(_textLogFileName))
            {
                if (_textLogFileName.IndexOf("\\") >= 0)
                    throw new Exception("The Text Log filename has invalid character '\'. If you want to specify the folder name, do so via the logFilePath param.");
            }
            #endregion

            try
            {
                SetupDefaults();
                Init();
            }
            catch (Exception)
            {
                throw;
            }
        }
		#endregion

		#region Deconstructors / Dispose methods
		/// <summary>
		/// Destructor.
		/// </summary>
        ~Logger()
		{
            Dispose(false);
		}

        /// <summary>
        /// Disposes the current object and releases all handles.
        /// </summary>
        public void Dispose()
        {
            if (!_IsDisposed)
            {
                Dispose(true);
                GC.SuppressFinalize(this);
            }
        }

        /// <summary>
        /// Disposes the current object.
        /// </summary>
        /// <param name="disposing">Indicates whether the object is being disposed.</param>
        protected virtual void Dispose(bool disposing)
        {
            if (!_IsDisposed)
            {
				try
				{
					CloseLog();
				}
				catch (Exception)
				{
					throw;
				}

                if (disposing)
                {
                    if ((LoggingType.TRX & _loggingType) == LoggingType.TRX)
                    {
                        _testResults.Clear();
                        _testResults = null;
                        _testSessionGuid = "";
                        _testCount = 0;
                        _generator = null;
                    }

                    if ((LoggingType.WTT & _loggingType) == LoggingType.WTT)
                        _wttLogger = null;
                    
                }
                _IsDisposed = true;
            }
        }
		#endregion

		#region Methods
        /// <summary>
        /// Begins a test with the specified name. <br/>
        /// NOTE: TRX Logging will not commit to file until the test run is complete.
        /// </summary>
        /// <param name="testName">Name of the test to start.</param>
        /// <remarks>
        /// <para>
        /// If the TRX log file is enabled, then the following parameters of the TRX result will be set to their 
        /// default values:
        /// </para>
        /// BuildNumber     - Empty String<br/>
        /// BuildType       - Debug<br/>    
        /// Platform        - Any CPU<br/>    
        /// TestingCategory - Functional<br/>    
        /// OwnerAlias      - Empty String<br/>    
        /// </remarks>
        public void StartTest(string testName)
        {
            try
            {
                StartTest(testName, "", "", BuildType.Debug, Platform.AnyCPU, TestingCategory.Functional);
            }
            catch (Exception)
            {
                throw;
            }
        }

		/// <summary>
        /// Begins a test with the specified name. <br/>
        /// NOTE: TRX Logging will not commit to file until the test run is complete.
		/// </summary>
		/// <param name="testName">Name of the test to start.</param>
        /// <param name="buildNumber">The build number on which this test is running. <br/>NOTE: This will only be used by the TRX Log file.</param>
        /// <param name="ownerAlias">The test owner alias. <br/>NOTE: This will only be used by the TRX Log file.</param>
        /// <param name="buildType">Specifies whether its a Release or Debug build. <br/>NOTE: This will only be used by the TRX Log file.</param>
        /// <param name="platform">Specifies the platform where the test was executed. <br/>NOTE: This will only be used by the TRX Log file.</param>
        /// <param name="category">Specifies the test category of this test. <br/>NOTE: This will only be used by the TRX Log file.</param>
		public void StartTest(string testName, string buildNumber, string ownerAlias, BuildType buildType,
            Platform platform, TestingCategory category)
		{
			_testCount++;

            if (String.IsNullOrEmpty(testName))
                throw new Exception("The Test Name cannot be empty.");

            try
            {
                #region TRX
                if ((LoggingType.TRX & _loggingType) == LoggingType.TRX)
                {
                    TRXTestResult tr = new TRXTestResult();
                    tr.StartDate = DateTime.Now;
					tr.BuildNumber = buildNumber;
                    tr.BuildType = (TrxE2EGenerator.Flavor)((int)buildType);
                    tr.Description = testName;
                    tr.Platform = (TrxE2EGenerator.Platform)((int)platform);
					tr.ProjectAreaGUID = _projectAreaGuid;
                    tr.SessionId = _testSessionGuid;
                    tr.TestingCategory = (TrxE2EGenerator.TestingCategory)((int)category);
                    tr.TestName = testName;
					tr.TestOwnerAlias = ownerAlias;
                    tr.Result = TestOutcome.Incomplete;

                    _testResults.Add(testName, tr);
                }
                #endregion

                #region WTT / Text
                if (((LoggingType.WTT & _loggingType) == LoggingType.WTT) ||
                    ((LoggingType.Text & _loggingType) == LoggingType.Text))
                {
                    _wttLogger.StartTest(testName);
                }
                #endregion

                //Set the last test name
                LastTestName = testName;
            }
            catch (Exception)
            {
                throw;
            }
		}

		/// <summary>
		/// Adds an Info type message to the last Test started (TestName matches LastTestName).
		/// </summary>
		/// <param name="message">Message to add.</param>
		public void AddMessage(string message)
		{
            try
            {
                AddMessage(message, MessageType.Info);
            }
            catch (Exception)
            {
                throw;
            }
		}

		/// <summary>
		/// Adds a message to the last Test started (TestName matches LastTestName).
		/// </summary>
		/// <param name="message">Message to add.</param>
		/// <param name="type">Type of Message to add.</param>
		public void AddMessage(string message, MessageType type)
		{
            try
            {
                AddMessage(LastTestName, message, type);
            }
            catch (Exception)
            {
                throw;
            }
		}

		/// <summary>
		/// Adds a generic message to the specified test. <br/>
        /// NOTE: TRX Logging will not commit to file until the test run is complete.
		/// </summary>
		/// <param name="testName">Name of the test to add message to.</param>
		/// <param name="message">Message to add.</param>
		/// <param name="type">Type of message.  A flag based on this type is prepended to each Message in the log.</param>
        /// <remarks>
        /// Using this method allows you to control the WTT and / or Text log test result from your code. Use this call only, if you
        /// want to log exceptions, bugs, warnings etc. to the log, and also want to control the test outcome.
        /// </remarks>
		public void AddMessage(string testName, string message, MessageType type)
		{
            try
            {
                #region TRX
                if ((LoggingType.TRX & _loggingType) == LoggingType.TRX)
                {
                    if (String.IsNullOrEmpty(testName))
                        throw new Exception("The test name cannot be empty when you have TRX logging enabled.");
					AddTRXMessage(testName, message, type);
                }
                #endregion

                #region WTT / Text
                if (((LoggingType.WTT & _loggingType) == LoggingType.WTT) ||
                    ((LoggingType.Text & _loggingType) == LoggingType.Text))
                {
                    switch (type)
                    {
                        case MessageType.Bug:
                            _wttLogger.Trace(new LevelMessage("BUG: " + message));
                            break;
                        case MessageType.Error:
                            _wttLogger.Trace(new LevelMessage("ERROR: " + message));
                            break;
                        case MessageType.Info:
                            _wttLogger.Trace(new LevelMessage("INFO: " + message));
                            break;
                        case MessageType.Warning:
                            _wttLogger.Trace(new LevelMessage("WARN: " + message));
                            break;
                    }
                }
                #endregion
            }
            catch (Exception)
            {
                throw;
            }
		}

        /// <summary>
        /// Adds a BUG message to the last Test started (TestName matches LastTestName). <br/>
        /// NOTE: TRX Logging will not commit to file until the test run is complete.
        /// </summary>
        /// <param name="bugID">A Product Studio bug id.</param>
        /// <param name="psDBName">A Product Studio database name.</param>
        /// <remarks>
        /// Using this method will override the Test Result for this test in WTT / Text log, to <b>BLOCKED</b>. The test result supplied
        /// to EndTest call will have no effect. If you want to control the test result, consider using <i>AddMessage</i> instead.
        /// </remarks>
        public void AddBug(int bugID, string psDBName)
        {
            try
            {
                AddBug(LastTestName, bugID, psDBName);
            }
            catch (Exception)
            {
                throw;
            }

        }

        /// <summary>
        /// Adds a BUG message to the specified test. <br/>
        /// NOTE: TRX Logging will not commit to file until the test run is complete.
        /// </summary>
        /// <param name="testName">Name of the test to add message to.</param>
        /// <param name="bugID">A Product Studio bug id.</param>
        /// <param name="psDBName">A Product Studio database name.</param>
        /// <remarks>
        /// Using this method will override the Test Result for this test in WTT / Text log, to <b>BLOCKED</b>. The test result supplied
        /// to EndTest call will have no effect. If you want to control the test result, consider using <i>AddMessage</i> instead.
        /// </remarks>
        public void AddBug(string testName, int bugID, string psDBName)
        {
            try
            {
                #region TRX
                if ((LoggingType.TRX & _loggingType) == LoggingType.TRX)
                {
                    if (String.IsNullOrEmpty(testName))
                        throw new Exception("The test name cannot be empty when you have TRX logging enabled.");

                    AddTRXMessage(testName,
                               "Product Studio database: " + psDBName + ", Bug ID: " + bugID.ToString(),
                               MessageType.Bug);
					
                }
                #endregion

                #region WTT / Text
                if (((LoggingType.WTT & _loggingType) == LoggingType.WTT) ||
                    ((LoggingType.Text & _loggingType) == LoggingType.Text))
                    _wttLogger.Trace(new LevelBug(bugID, psDBName));
                #endregion
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Adds an exception message to the last Test started (TestName matches LastTestName). <br/>
        /// NOTE: TRX Logging will not commit to file until the test run is complete.
        /// </summary>
        /// <param name="error">An exception object to add to the log.</param>
        /// <param name="message">Message to add.</param>
        /// <remarks>
        /// Using this method will override the Test Result for this test in WTT / Text log, to <b>FAIL</b>. The test result supplied
        /// to EndTest call will have no effect. If you want to control the test result, consider using <i>AddMessage</i> instead.
        /// </remarks>
        public void AddException(Exception error, string message)
        {
            try
            {
                AddException(LastTestName, error, message);
            }
            catch (Exception)
            {
                throw;
            }
        }
        
        /// <summary>
        /// Adds an exception message to the specified test. <br/>
        /// NOTE: TRX Logging will not commit to file until the test run is complete.
        /// </summary>
        /// <param name="testName">Name of the test to add message to.</param>
        /// <param name="error">An exception object to add to the log.</param>
        /// <param name="message">Message to add.</param>
        /// <remarks>
        /// Using this method will override the Test Result for this test in WTT / Text log, to <b>FAIL</b>. The test result supplied
        /// to EndTest call will have no effect. If you want to control the test result, consider using <i>AddMessage</i> instead.
        /// </remarks>
        public void AddException(string testName, Exception error, string message)
        {
            try
            {
                #region TRX
                if ((LoggingType.TRX & _loggingType) == LoggingType.TRX)
                {
                    if (String.IsNullOrEmpty(testName))
                        throw new Exception("The test name cannot be empty when you have TRX logging enabled.");

                    AddTRXMessage(testName,
                                  message + Environment.NewLine + error.ToString(),
                                  MessageType.Error);
                }
                #endregion

                #region WTT / Text
                if (((LoggingType.WTT & _loggingType) == LoggingType.WTT) ||
                    ((LoggingType.Text & _loggingType) == LoggingType.Text))
                    _wttLogger.Trace(new LevelError(error, message));
                #endregion
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Adds a warning message to the last Test started (TestName matches LastTestName). <br/>
        /// NOTE: TRX Logging will not commit to file until the test run is complete. 
        /// </summary>
        /// <param name="warning">The warning text to add.</param>
        /// <remarks>
        /// Using this method will override the Test Result for this test in WTT / Text log, to <b>WARN</b>. The test result supplied
        /// to EndTest call will have no effect. If you want to control the test result, consider using <i>AddMessage</i> instead.
        /// </remarks>
        public void AddWarning(string warning)
        {
            try
            {
                AddWarning(LastTestName, warning);
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Adds a warning message to the specified test. <br/>
        /// NOTE: TRX Logging will not commit to file until the test run is complete. 
        /// </summary>
        /// <param name="testName">Name of the test to add message to.</param>
        /// <param name="warning">The warning text to add.</param>
        /// <remarks>
        /// Using this method will override the Test Result for this test in WTT / Text log, to <b>WARN</b>. The test result supplied
        /// to EndTest call will have no effect. If you want to control the test result, consider using <i>AddMessage</i> instead.
        /// </remarks>
        public void AddWarning(string testName, string warning)
        {
            try
            {
                #region TRX
                if ((LoggingType.TRX & _loggingType) == LoggingType.TRX)
                {
                    if (String.IsNullOrEmpty(testName))
                        throw new Exception("The test name cannot be empty when you have TRX logging enabled.");

                    AddTRXMessage(testName,
                                  warning,
                                  MessageType.Warning);
                }
                #endregion

                #region WTT / Text
                if (((LoggingType.WTT & _loggingType) == LoggingType.WTT) ||
                    ((LoggingType.Text & _loggingType) == LoggingType.Text))
                    _wttLogger.Trace(new LevelWarning(warning));
                #endregion
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Ends the test that was last created. <br/>
        /// NOTE: TRX Logging will not commit to file until the test run is complete.
        /// </summary>
        /// <param name="result">Result of the test.</param>
        public void EndTest(TestOutcome result)
        {
            EndTest(LastTestName, result);
        }

		/// <summary>
		/// Ends a test with the specified name. <br/>
        /// NOTE: TRX Logging will not commit to file until the test run is complete.
		/// </summary>
		/// <param name="testName">Name of the test to end. If null, the last started TEST is ended.</param>
		/// <param name="result">Overall outcome of the test.</param>
        /// <remarks>
        /// <para>
        /// NOTE: The result will be ignored in the WTT / Text log, if you added a message of the following types
        /// to this test. If you did, then the result will be set to the specified Test Result:
        /// </para>
        /// MessageType : BUG - BLOCKED <br/>
        /// MessageType : Exception - FAIL <br/>
        /// MessageType : Warning - WARN <br/>
        /// </remarks>
		public void EndTest(string testName, TestOutcome result)
		{
            try
            {
                if (String.IsNullOrEmpty(testName))
                    testName = LastTestName;

                #region TRX
                if ((LoggingType.TRX & _loggingType) == LoggingType.TRX)
                {
                    if (_testResults.ContainsKey(testName))
                    {
                        TRXTestResult tr = (TRXTestResult)_testResults[testName];
						tr.Result = result; //We have to set the result inside our data structure or else nothing gets cleaned out.
                        _generator.AddTestResults(tr.SessionId, tr.BuildNumber, tr.TestName, tr.Description, tr.ProjectAreaGUID, tr.TestingCategory, tr.TestOwnerAlias,
                            MapTestOutcomeToTRX(tr.Result), tr.StartDate, DateTime.Now, tr.Message, tr.BuildType, tr.Platform);

                        if (_generator.TestResultArraylist.Count >= 3000) //We have too many reported results, time to close the file and start a new one.
                        {
                            CleanTestResults();
                            _generator.CloseSession(_testSessionGuid, (LogFilePath.Length > 0 ? LogFilePath : Directory.GetCurrentDirectory()));
                            _generator = new TrxE2EGenerator();
                            _testSessionGuid = _generator.StartTestSession();
                        }
                    }
                }
                #endregion

                #region WTT / Text
                if (((LoggingType.WTT & _loggingType) == LoggingType.WTT) ||
                    ((LoggingType.Text & _loggingType) == LoggingType.Text))
                {
                    _wttLogger.EndTest(testName, MapTestOutcomeToWTT(result), null);
                }
                #endregion
            }
            catch (Exception)
            {
                throw;
            }
		}

		/// <summary>
		/// Adds a message to a TRXTestResult.
		/// </summary>
		/// <param name="testName">Name of test to add message to</param>
		/// <param name="message">Message to add</param>
		/// <param name="type">Type of message to add</param>
		private void AddTRXMessage(string testName, string message, MessageType type)
		{
			if (_testResults.ContainsKey(testName))
			{
				TRXTestResult tr = (TRXTestResult)_testResults[testName];
				switch (type)
				{
					case MessageType.Bug:
						tr.Message += Environment.NewLine + "BUG: " + message;
						break;
					case MessageType.Error:
						tr.Message += Environment.NewLine + "ERROR: " + message;
						break;
					case MessageType.Info:
						tr.Message += Environment.NewLine + "INFO: " + message;
						break;
					case MessageType.Warning:
						tr.Message += Environment.NewLine + "WARN: " + message;
						break;
				}
			}
		}

		/// <summary>
		/// Finalizes and closes the log files.
        /// Call this only if this object is to be used no more.
		/// </summary>
		public void CloseLog()
		{
            try
            {
                #region TRX
                if ((LoggingType.TRX & _loggingType) == LoggingType.TRX)
                {
                    if (!_IsTRXSessionClosed)
                    {
                        _generator.CloseSession(_testSessionGuid, (LogFilePath.Length > 0 ? LogFilePath + "\\" : Directory.GetCurrentDirectory() + "\\"));
                        _IsTRXSessionClosed = true;
                    }
                } 
                #endregion

                #region WTT / Text
                if (((LoggingType.WTT & _loggingType) == LoggingType.WTT) ||
                    ((LoggingType.Text & _loggingType) == LoggingType.Text))
                {
                    _wttLogger.Dispose();
                } 
                #endregion
            }
            catch (Exception)
            {
                throw;
            }
		}

        /// <summary>
        /// Initialize internal objects.
        /// </summary>
        private void Init()
        {
            #region TRX
            if ((LoggingType.TRX & _loggingType) == LoggingType.TRX)
            {
                _testResults = new Hashtable();
                _generator = new TrxE2EGenerator();
                _testSessionGuid = _generator.StartTestSession();
                _IsTRXSessionClosed = false;
            } 
            #endregion

            #region WTT / Text
            if (((LoggingType.WTT & _loggingType) == LoggingType.WTT) ||
                    ((LoggingType.Text & _loggingType) == LoggingType.Text))
            {
                string writeMode = (_logWriteMode == WriteMode.Append ? "append" : "overwrite");
                string wttLoggerDeviceString = String.Empty;

                //WTT
                if ((LoggingType.WTT & _loggingType) == LoggingType.WTT)
                {
                    string wttLogFile = _logFilePath + "\\" + _wttLogFileName;
                    wttLoggerDeviceString = "$logfile:file=\"" + wttLogFile + "\",encoding=UNICODE,Writemode=" + writeMode;
                }

                //Text
                if ((LoggingType.Text & _loggingType) == LoggingType.Text)
                {
                    string textLogFile = _logFilePath + "\\" + _textLogFileName;
                    if (String.IsNullOrEmpty(wttLoggerDeviceString))
                        wttLoggerDeviceString += "$plainlog:file=\"" + textLogFile + "\",encoding=ANSI,Verbose=false,Writemode=" + writeMode;
                    else
                        wttLoggerDeviceString += ";$plainlog:file=\"" + textLogFile + "\",encoding=ANSI,Verbose=false,Writemode=" + writeMode;
                }

                try
                {
                    _wttLogger = new TestLogger(wttLoggerDeviceString);
                }
                catch (Exception)
                {
                    throw;
                }
                _wttLogger.TraceMachineInfo();
            }
            #endregion
        }

		/// <summary>
		/// Assigns default values to the log folder path, the WTT log file name
        /// and the Text log file name, if not already defined.
		/// </summary>
        private void SetupDefaults()
		{
            //Set the log file path to current directory, if not already set.
            if (String.IsNullOrEmpty(_logFilePath))
                _logFilePath = Directory.GetCurrentDirectory();

            //Set WTT Log file name, if not already set.
            if ((LoggingType.WTT & _loggingType) == LoggingType.WTT)
            {
                if (String.IsNullOrEmpty(_wttLogFileName))
                    _wttLogFileName = "WTTLog.wtl";
            }

            //Set the Text Log file name, if not already set.
            if ((LoggingType.Text & _loggingType) == LoggingType.Text)
            {
                if (String.IsNullOrEmpty(_textLogFileName))
                    _textLogFileName = "TextLog.log";
            }

		}

        /// <summary>
        /// Maps the test outcome to a registered TRX test result.
        /// </summary>
        /// <param name="outcome">The test outcome to map.</param>
        /// <returns>A TestResult representing the TRX test result value.</returns>
        private TrxE2EGenerator.TestResult MapTestOutcomeToTRX(TestOutcome outcome)
		{
			switch (outcome)
			{
				case TestOutcome.Blocked:
					return TrxE2EGenerator.TestResult.NotRunnable;
				case TestOutcome.Error:
					return TrxE2EGenerator.TestResult.Error;
				case TestOutcome.Fail:
					return TrxE2EGenerator.TestResult.Failed;
				case TestOutcome.Incomplete:
					return TrxE2EGenerator.TestResult.InProgress;
				case TestOutcome.Invalid:
					return TrxE2EGenerator.TestResult.Inconclusive;
				case TestOutcome.Pass:
					return TrxE2EGenerator.TestResult.Passed;
				case TestOutcome.Skipped:
					return TrxE2EGenerator.TestResult.NotExecuted;
				case TestOutcome.Warning:
					return TrxE2EGenerator.TestResult.Warning;
                default:
                    return TrxE2EGenerator.TestResult.Inconclusive;
			}
		}

        /// <summary>
        /// Maps the test outcome to a registered WTT test result.
        /// </summary>
        /// <param name="outcome">The test outcome to map.</param>
        /// <returns>A TestResult representing the WTT test result value.</returns>
        private Microsoft.DistributedAutomation.Logger.TestResult MapTestOutcomeToWTT(TestOutcome outcome)
        {
            switch (outcome)
            {
                case TestOutcome.Blocked:
                    return TestResult.Blocked;
                case TestOutcome.Error:
                    return TestResult.Fail;
                case TestOutcome.Fail:
                    return TestResult.Fail;
                case TestOutcome.Incomplete:
                    return TestResult.Blocked;
                case TestOutcome.Invalid:
                    return TestResult.NoneInvalid;
                case TestOutcome.Pass:
                    return TestResult.Pass;
                case TestOutcome.Skipped:
                    return TestResult.Skipped;
                case TestOutcome.Warning:
                    return TestResult.Warning;
                default:
                    return TestResult.NoneInvalid;
            }
        }

		/// <summary>
		/// Cleans out reported TRX results from internal datastore.
		/// </summary>
        private void CleanTestResults()
		{
			Hashtable resultsReported = new Hashtable();
			//Find each one that has been reported.
			foreach (TRXTestResult tr in _testResults)
			{
				if (tr.Result != TestOutcome.Incomplete)
				{
					resultsReported.Add(tr.TestName, tr);
				}
			}

			//Remove reported ones from the main collection (so that unreported ones are left alone)
			foreach (TRXTestResult tr in resultsReported)
			{
				if (_testResults.ContainsKey(tr.TestName))
				{
					_testResults.Remove(tr.TestName);
				}
			}

			resultsReported.Clear();
		}
		#endregion
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\WebServiceTestFramework\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\WebServiceTestFramework\WebServiceTestFramework\FrameWorkException.cs ===
﻿using System;
using System.Text;

namespace MS.Internal.WebServiceTestFramework
{
    /// <summary>
    /// Represents errors encountered by the Framework.
    /// </summary>
    public class FrameWorkException : Exception
    {
        //protected string g_ErrorDescription;
        //protected Exception g_InnerException;

        /// <summary>
        /// Initializes a new instance of the MS.Internal.WebServiceTestFramework.FrameworkException class with specified ErrorMessage.
        /// </summary>
        /// <param name="ErrorMessage">The Error Message.</param>
        public FrameWorkException(string ErrorMessage)
            : base(ErrorMessage)
        {
            //g_ErrorDescription = ErrorMessage;
            //g_InnerException = null;
        }

        /// <summary>
        /// Initializes a new instance of the MS.Internal.WebServiceTestFramework.FrameworkException class with specified ErrorMessage
        /// and a reference to the InnerException that caused the error.
        /// </summary>
        /// <param name="ErrorMessage">The Error Message.</param>
        /// <param name="InnerException">The Inner Exception causing the error.</param>
        public FrameWorkException(string ErrorMessage, Exception InnerException)
            : base(ErrorMessage, InnerException)
        {
            //g_ErrorDescription = ErrorMessage;
            //g_InnerException = InnerException;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\WebServiceTestFramework\WebServiceTestFramework\FrameWorkPolicy.cs ===
﻿using System;
using System.Collections.Generic;
using System.Net.Cache;
using System.Text;

namespace Test.Common.Library.WebServiceTestFramework
{
    /// <summary>
    /// Represents the Policy parameters for the WebService Request.
    /// </summary>
    public class FrameWorkPolicy
    {
        private CacheLevel g_RequestCacheLevel;
        private int g_TimeOut;

        /// <summary>
        /// The requested Cache Level.
        /// </summary>
        public enum CacheLevel
        {
            /// <summary>
            /// Indicates that the request will be satisfied by using the server. No entries are taken from cache, added to cache,
            /// or removed from cache between the client and server.
            /// </summary>
            BypassCache,
            /// <summary>
            /// Indicates that the request will be satisfied from the cache, if available; otherwise it will be fetched from the server.
            /// If the requested item is available in any cache between the client and the server, the request might be satisfied by the intermediate cache.
            /// </summary>
            CacheIfAvailable,
            /// <summary>
            /// Indicates that the request will be satisfied using the locally cached resource; does not send a request for an item
            /// that is not in the cache. Exception is thrown if the item is not in the client cache.
            /// </summary>
            CacheOnly,
            /// <summary>
            /// Indicates that the request will be satisfied either by using the cached copy of the resource or by sending a request for
            /// the resource to the server. The action taken is determined by the current cache policy and the age of the content in the cache.
            /// </summary>
            Default,
            /// <summary>
            /// Indicates that the request will never be satisfied by using the cache. If the resource is present in the local cache, it is removed. This policy level indicates to intermediate caches that they should remove the resource.
            /// </summary>
            NoCacheNoStore,
            /// <summary>
            /// Indicates that the request will be satisfied by using the server. The response might be saved in the cache.
            /// </summary>
            Reload,
            /// <summary>
            /// Indicates that the request will be satisfied by using the cached copy of the resource if the timestamp is the same as the timestamp
            /// of the resource on the server; otherwise, the resource is fetched from the server, and stored in the cache. 
            /// </summary>
            Revalidate
        }
        
        /// <summary>
        /// Initializes a new instance of FrameWorkPolicy class.
        /// </summary>
        public FrameWorkPolicy()
        {
            //Set defaults
            g_RequestCacheLevel = CacheLevel.BypassCache;
            g_TimeOut = 100000;
        }

        #region Properties
        /// <summary>
        /// Get or Set the policy for Request Cache Level.
        /// </summary>
        public CacheLevel RequestCacheLevelPolicy
        {
            get { return g_RequestCacheLevel; }
            set { g_RequestCacheLevel = value; }
        }

        /// <summary>
        /// Get or Set the policy for the Request Timeout.
        /// </summary>
        public int RequestTimeOut
        {
            get { return g_TimeOut; }
            set
            {
                try
                {
                    g_TimeOut = value;
                }
                catch (Exception Error)
                {
                    throw new Exception("Error occured while setting the TimeOut value. " + Error.Message, Error.InnerException);
                }
            }
        } 
        #endregion

        #region Methods
        /// <summary>
        /// Gets an object of the Requested Cache Policy.
        /// </summary>
        /// <returns></returns>
        public RequestCachePolicy GetCachePolicy()
        {
            RequestCachePolicy CachePolicy = null;

            try
            {
                switch (g_RequestCacheLevel)
                {
                    case CacheLevel.BypassCache:
                        CachePolicy = new RequestCachePolicy(RequestCacheLevel.BypassCache);
                        break;
                    case CacheLevel.CacheIfAvailable:
                        CachePolicy = new RequestCachePolicy(RequestCacheLevel.CacheIfAvailable);
                        break;
                    case CacheLevel.CacheOnly:
                        CachePolicy = new RequestCachePolicy(RequestCacheLevel.CacheOnly);
                        break;
                    case CacheLevel.Default:
                        CachePolicy = new RequestCachePolicy(RequestCacheLevel.Default);
                        break;
                    case CacheLevel.NoCacheNoStore:
                        CachePolicy = new RequestCachePolicy(RequestCacheLevel.NoCacheNoStore);
                        break;
                    case CacheLevel.Reload:
                        CachePolicy = new RequestCachePolicy(RequestCacheLevel.Reload);
                        break;
                    case CacheLevel.Revalidate:
                        CachePolicy = new RequestCachePolicy(RequestCacheLevel.Revalidate);
                        break;
                }
            }
            catch (Exception)
            {
                throw;
            }

            return CachePolicy;
        } 
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\WebServiceTestFramework\WebServiceTestFramework\FrameWorkSecurity.cs ===
﻿using System;
using System.Net;
using System.Text;

namespace Test.Common.Library.WebServiceTestFramework
{
    /// <summary>
    /// Represents the Security for the WebService Request object.
    /// </summary>
    public class FrameWorkSecurity
    {
        private string g_RequestUsername;
        private string g_RequestPassword;
        private string g_RequestDomain;
        private bool g_RequirePreAuthentication;
        private AuthenticationLevel g_RequestAuthenticationLevel;
        private ImpersonationLevel g_RequestImpersonationLevel;
        
        /// <summary>
        /// Supported Authentication Levels for the request.
        /// </summary>
        public enum AuthenticationLevel
        {
            /// <summary>
            /// Indicates that the client and server should be authenticated. The request does not fail if the server is not authenticated.
            /// </summary>
            MutualAuthRequested,
            /// <summary>
            /// Indicates that the client and server should be authenticated. If the server is not authenticated, an Exception will be raised.
            /// </summary>
            MutualAuthRequired,
            /// <summary>
            /// Indicates that no authentication is required for the client and server.
            /// </summary>
            None
        }

        /// <summary>
        /// Supported Impersonation Levels for the request.
        /// </summary>
        public enum ImpersonationLevel
        {
            /// <summary>
            /// Indicates that the server process cannot obtain identification information about the client, and it cannot impersonate the client.
            /// </summary>
            Anonymous,
            /// <summary>
            /// Indicates that the server process can impersonate the client's security context on remote systems.
            /// </summary>
            Delegation,
            /// <summary>
            /// Indicates that the server process can obtain information about the client, such as security identifiers and privileges, 
            /// but it cannot impersonate the client.
            /// </summary>
            Identification,
            /// <summary>
            /// Indicates that the server process can impersonate the client's security context on its local system. The server cannot 
            /// impersonate the client on remote systems. 
            /// </summary>
            Impersonation,
            /// <summary>
            /// Indicates that an impersonation level is not assigned.
            /// </summary>
            None
        }

        /// <summary>
        /// Initializes a new instance of FrameWorkSecurity class. 
        /// </summary>
        public FrameWorkSecurity()
        {
            //Define defaults for credential module
            g_RequestDomain = String.Empty;
            g_RequestPassword = String.Empty;
            g_RequestUsername = String.Empty;

            //Define defaults for authentication module
            g_RequirePreAuthentication = false;
            g_RequestAuthenticationLevel = AuthenticationLevel.MutualAuthRequested;
            g_RequestImpersonationLevel = ImpersonationLevel.Delegation;

        }

        #region Credential Module
        /// <summary>
        /// The Username to send with the WebService Request object.
        /// </summary>
        public string Username
        {
            get { return g_RequestUsername; }
            set
            {
                if (value.Contains("\\"))
                    throw new FormatException("Domain name cannot be included in the Username string. Use the Domain parameter to supply the domain name.");
                else
                    g_RequestUsername = value;
            }
        }

        /// <summary>
        /// The Password to send with the WebService Request object.
        /// </summary>
        public string Password
        {
            get { return g_RequestPassword; }
            set { g_RequestPassword = value; }
        }

        /// <summary>
        /// The Domain for the username to send with the WebService Request object.
        /// </summary>
        public string Domain
        {
            get { return g_RequestDomain; }
            set { g_RequestDomain = value; }
        }

        /// <summary>
        /// Gets an instance of System.Net.NetworkCredential composed of the supplied credentials.
        /// See Username, Password and Domain. If not set, the Default Network Credential is returned.
        /// </summary>
        /// <returns>An object of System.Net.NetworkCredential.</returns>
        public NetworkCredential GetNetworkCredential()
        {
            NetworkCredential m_NetworkCredentialObject;

            //Check if Default Credentials are to be used
            if (IsDefaultNetworkCredentials())
                m_NetworkCredentialObject = (NetworkCredential)CredentialCache.DefaultCredentials;
            else
                m_NetworkCredentialObject = new NetworkCredential(g_RequestUsername, g_RequestPassword, g_RequestDomain);

            return m_NetworkCredentialObject;
        }

        /// <summary>
        /// Checks if the credential in use is the Default Network Credential.
        /// </summary>
        /// <returns>An object of System.Boolean. True if default credential is being used. False if not.</returns>
        public bool IsDefaultNetworkCredentials()
        {
            if (String.IsNullOrEmpty(g_RequestUsername) || String.IsNullOrEmpty(g_RequestPassword))
                return true;
            else
                return false;
        } 
        #endregion

        #region Authentication Module
        /// <summary>
        /// Gets or Sets whether Pre-Authentication is required for the WebService Request.
        /// </summary>
        public bool RequirePreAuthentication
        {
            get { return g_RequirePreAuthentication; }
            set { g_RequirePreAuthentication = value; }
        }

        /// <summary>
        /// Gets or Sets the Authentication Level for the WebService Request object.
        /// </summary>
        public AuthenticationLevel RequestAuthenticationLevel
        {
            get { return g_RequestAuthenticationLevel; }
            set { g_RequestAuthenticationLevel = value; }
        }

        /// <summary>
        /// Gets or Sets the Impersonation Level for the WebService Request object.
        /// </summary>
        public ImpersonationLevel RequestImpersonationLevel
        {
            get { return g_RequestImpersonationLevel; }
            set { g_RequestImpersonationLevel = value; }
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\UnifiedLogger\UnifiedLogger\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("LEET.Test.Logger")]
[assembly: AssemblyDescription("")]
//[assembly: AssemblyConfiguration("")]
//[assembly: AssemblyCompany("Microsoft")]
//[assembly: AssemblyProduct("LEET.Test.Logger")]
//[assembly: AssemblyCopyright("Copyright © Microsoft 2009")]
//[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("e0ee4a18-8058-44b7-81ca-aca052b58782")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
//[assembly: AssemblyVersion("1.0.0.0")]
//[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\WebServiceTestFramework\WebServiceTestFramework\HTTPGetAccess.cs ===
﻿using System;
using System.Collections.Generic;
using System.Security.Principal;
using System.IO;
using System.Net;
using System.Net.Cache;
using System.Net.Security;
using System.Text;
using System.Web;

namespace Test.Common.Library.WebServiceTestFramework
{
    /// <summary>
    /// Represents access of Web Service via HTTP GET protocol.
    /// </summary>
    public class HTTPGetAccess
    {
        private WebRequest g_HttpGetRequest;
        private WebResponse g_HttpGetResponse;
        private FrameWorkSecurity g_SecurityObject;
        private FrameWorkPolicy g_PolicyObject;
        private RequestParameter[] g_HttpGetRequestParameterCollection;
        
        //Request Object Params
        private bool g_HttpGetRequestRequirePreAuthenticate;
        private TokenImpersonationLevel g_HttpGetRequestImpersonationLevel;
        private RequestCachePolicy g_HttpGetRequestCachePolicy;
        private AuthenticationLevel g_HttpGetRequestAuthenticationLevel;
        private NetworkCredential g_HttpGetRequestCredentials;
        private string g_HttpGetRequestContentType;
        private int g_HttpGetRequestTimeout;
        private string g_RemoteHostName;
        private string g_WebServiceURI;
        private string g_WebMethodName;

        //Response Object Params
        private string g_HttpGetResponseString;
        private WebHeaderCollection g_HttpGetResponseHeader;
        private long g_HttpGetResponseContentLength;
        private string g_HttpGetResponseContentType;
        private bool g_HttpGetResponseIsFromCache;
        private bool g_HttpGetResponseIsMutuallyAuthenticated;
        private Uri g_HttpGetResponseActualURI;


        #region Constructors
        /// <summary>
        /// Initializes a new instance of the HTTPGetAccess class.
        /// </summary>
        public HTTPGetAccess()
        {
            SetDefaults();
        }

        /// <summary>
        /// Initializes a new instance of the HTTPGetAccess class with the specified
        /// Hostname, Service URI, WebMethod name and Request Parameter collection.
        /// </summary>
        /// <param name="RemoteHostName">The Remote computername hosting the Web Service.</param>
        /// <param name="WebServiceURI">The URI path to the Web Service.</param>
        /// <param name="WebMethodName">The Web Methodname to call in the Web Service.</param>
        /// <param name="ParameterCollection">An array of parameter-value to pass to the Web Method.</param>
        public HTTPGetAccess(string RemoteHostName, string WebServiceURI, string WebMethodName, RequestParameter[] ParameterCollection)
        {
            //Set Defaults
            SetDefaults();

            //Set Passed values
            g_RemoteHostName = RemoteHostName;
            g_WebServiceURI = WebServiceURI;
            g_WebMethodName = WebMethodName;
            g_HttpGetRequestParameterCollection = ParameterCollection;
        }

        /// <summary>
        /// Initializes a new instance of the HTTPGetAccess class with the specified
        /// Hostname, Service URI, WebMethod name, Request Parameter collection, Security object and Policy object.
        /// </summary>
        /// <param name="RemoteHostName">The Remote computername hosting the Web Service.</param>
        /// <param name="WebServiceURI">The URI path to the Web Service.</param>
        /// <param name="WebMethodName"></param>
        /// <param name="ParameterCollection">The Web Methodname to call in the Web Service.</param>
        /// <param name="WebServiceSecurity">The Security object for accessing the Web Service.</param>
        /// <param name="WebServicePolicy">The Policy object for accessing the Web Service.</param>
        public HTTPGetAccess(string RemoteHostName, string WebServiceURI, string WebMethodName, RequestParameter[] ParameterCollection,
            FrameWorkSecurity WebServiceSecurity, FrameWorkPolicy WebServicePolicy)
        {
            //Set defaults
            SetDefaults();

            //Set Passed values
            g_RemoteHostName = RemoteHostName;
            g_WebServiceURI = WebServiceURI;
            g_WebMethodName = WebMethodName;
            g_HttpGetRequestParameterCollection = ParameterCollection;
            g_SecurityObject = WebServiceSecurity;
            g_PolicyObject = WebServicePolicy;
        }

        #endregion

        #region Methods
        /// <summary>
        /// Indicates if the GET Request object has been initialized.
        /// </summary>
        /// <returns>A value of type System.Boolean. True if the object has been initialized.</returns>
        public bool IsGETRequestInitialized()
        {
            if (g_HttpGetRequest != null)
                return true;
            else
                return false;
        }

        /// <summary>
        /// Create the GET Request.
        /// </summary>
        public void CreateGETRequest()
        {
            //Refresh Values
            try
            {
                SetSecurity();
                SetPolicy();
            }
            catch (Exception)
            {
                throw;
            }

            //Create the Get Object
            try
            {
                g_HttpGetRequest = WebRequest.Create(CreateGetRequestURI());
                g_HttpGetRequest.AuthenticationLevel = g_HttpGetRequestAuthenticationLevel;
                g_HttpGetRequest.CachePolicy = g_HttpGetRequestCachePolicy;
                g_HttpGetRequest.Credentials = g_HttpGetRequestCredentials;
                g_HttpGetRequest.ImpersonationLevel = g_HttpGetRequestImpersonationLevel;
                g_HttpGetRequest.PreAuthenticate = g_HttpGetRequestRequirePreAuthenticate;
                g_HttpGetRequest.Method = "GET";
                g_HttpGetRequest.Timeout = g_HttpGetRequestTimeout;
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Get the Response for the GET request.
        /// </summary>
        public void GetResponse()
        {
            StreamReader m_ResponseReader;
            Stream m_ResponseDataStream;

            //Check if the GET Request object has been constructed
            if (g_HttpGetRequest == null)
                throw new InvalidOperationException("The GET Request has not been constructed. Please construct the GET request prior to calling this method.");
            
            try
            {
                g_HttpGetResponse = g_HttpGetRequest.GetResponse();
                m_ResponseDataStream = g_HttpGetResponse.GetResponseStream();
                m_ResponseReader = new StreamReader(m_ResponseDataStream);

                //Update the Response Data objects
                g_HttpGetResponseHeader = g_HttpGetResponse.Headers;
                g_HttpGetResponseString = m_ResponseReader.ReadToEnd();
                g_HttpGetResponseContentLength = g_HttpGetResponse.ContentLength;
                g_HttpGetResponseContentType = g_HttpGetResponse.ContentType;
                g_HttpGetResponseIsFromCache = g_HttpGetResponse.IsFromCache;
                g_HttpGetResponseIsMutuallyAuthenticated = g_HttpGetResponse.IsMutuallyAuthenticated;
                g_HttpGetResponseActualURI = g_HttpGetResponse.ResponseUri;

                //Close Response Stream
                g_HttpGetResponse.Close();
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Sets default values for the various properties of the Get Request Object
        /// </summary>
        private void SetDefaults()
        {
            try
            {
                g_HttpGetRequestRequirePreAuthenticate = false;
                g_HttpGetRequestImpersonationLevel = TokenImpersonationLevel.Delegation;
                g_HttpGetRequestCachePolicy = new RequestCachePolicy(RequestCacheLevel.BypassCache);
                g_HttpGetRequestAuthenticationLevel = AuthenticationLevel.MutualAuthRequested;
                g_HttpGetRequestCredentials = (NetworkCredential)CredentialCache.DefaultCredentials;
                g_HttpGetRequestTimeout = 100000;
                g_RemoteHostName = String.Empty;
                g_WebServiceURI = String.Empty;
                g_WebMethodName = String.Empty;
                g_HttpGetRequestParameterCollection = null;
                g_SecurityObject = null;
                g_PolicyObject = null;

                g_HttpGetResponseHeader = null;
                g_HttpGetResponseString = String.Empty;
                g_HttpGetResponseContentLength = 0;
                g_HttpGetResponseContentType = String.Empty;
                g_HttpGetResponseIsFromCache = false;
                g_HttpGetResponseIsMutuallyAuthenticated = false;
                g_HttpGetResponseActualURI = null;
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Set the Security parameters of the HTTP GET Request Object
        /// </summary>
        private void SetSecurity()
        {
            try
            {
                //Check if a Security object exists
                if (g_SecurityObject != null)
                {
                    //Set Access credentials
                    if (!g_SecurityObject.IsDefaultNetworkCredentials())
                        g_HttpGetRequestCredentials = g_SecurityObject.GetNetworkCredential();

                    //Set PreAuth
                    if (g_SecurityObject.RequirePreAuthentication)
                        g_HttpGetRequestRequirePreAuthenticate = true;

                    //Set Impersonation Level
                    switch (g_SecurityObject.RequestImpersonationLevel)
                    {
                        case FrameWorkSecurity.ImpersonationLevel.Anonymous:
                            g_HttpGetRequestImpersonationLevel = TokenImpersonationLevel.Anonymous;
                            break;
                        case FrameWorkSecurity.ImpersonationLevel.Delegation:
                            g_HttpGetRequestImpersonationLevel = TokenImpersonationLevel.Delegation;
                            break;
                        case FrameWorkSecurity.ImpersonationLevel.Identification:
                            g_HttpGetRequestImpersonationLevel = TokenImpersonationLevel.Identification;
                            break;
                        case FrameWorkSecurity.ImpersonationLevel.Impersonation:
                            g_HttpGetRequestImpersonationLevel = TokenImpersonationLevel.Impersonation;
                            break;
                        case FrameWorkSecurity.ImpersonationLevel.None:
                            g_HttpGetRequestImpersonationLevel = TokenImpersonationLevel.None;
                            break;
                    }

                    //Set Authentication Level
                    switch (g_SecurityObject.RequestAuthenticationLevel)
                    {
                        case FrameWorkSecurity.AuthenticationLevel.MutualAuthRequested:
                            g_HttpGetRequestAuthenticationLevel = AuthenticationLevel.MutualAuthRequested;
                            break;
                        case FrameWorkSecurity.AuthenticationLevel.MutualAuthRequired:
                            g_HttpGetRequestAuthenticationLevel = AuthenticationLevel.MutualAuthRequired;
                            break;
                        case FrameWorkSecurity.AuthenticationLevel.None:
                            g_HttpGetRequestAuthenticationLevel = AuthenticationLevel.None;
                            break;
                    }
                }
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Set the general policy for the HTTP GET Request Object
        /// </summary>
        private void SetPolicy()
        {
            try
            {
                //Check if a Policy Object exists
                if (g_PolicyObject != null)
                {
                    //Set Cache policy
                    g_HttpGetRequestCachePolicy = g_PolicyObject.GetCachePolicy();

                    //Set TimeOut
                    g_HttpGetRequestTimeout = g_PolicyObject.RequestTimeOut;
                }
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Create the Get Request URI String
        /// </summary>
        /// <returns></returns>
        private string CreateGetRequestURI()
        {
            string m_RequestURI = string.Empty;
            string m_RequestParameterString = string.Empty;

            //Check RemoteHostName
            if (String.IsNullOrEmpty(g_RemoteHostName))
                throw new NullReferenceException("The Remote HostName has not been set. Please set the HostName prior to calling this method.");
            if (g_RemoteHostName.Contains("http://"))
                throw new FormatException("'http://' cannot be included as a part of the RemoteHost name.");
            if (g_RemoteHostName.Contains("\\"))
                throw new FormatException("Invalid character '\' in Remote Host name.");
            if (g_RemoteHostName.Contains("/"))
                throw new FormatException("Invalid character '/' in Remote Host name.");


            //Check WebService URI
            if (String.IsNullOrEmpty(g_WebServiceURI))
                throw new NullReferenceException("The WebService URI has not been set. Please set the URI prior to calling this method.");

            //Check Webmethod name
            if (String.IsNullOrEmpty(g_WebMethodName))
                throw new NullReferenceException("The WebMethod name has not been set. Please set the WebMethod name prior to calling this method.");
            if (g_WebMethodName.Contains("\\"))
                throw new FormatException("Invalid character '\' in WebMethod name.");
            if (g_WebMethodName.Contains("/"))
                throw new FormatException("Invalid character '/' in WebMethod name.");

            //Remove leading and trailing '/' from WebService URI and check format
            if (g_WebServiceURI.Substring(0, 1) == "/")
                g_WebServiceURI = g_WebServiceURI.Substring(1);
            if (g_WebServiceURI.Substring(g_WebServiceURI.Length - 1) == "/")
                g_WebServiceURI = g_WebServiceURI.Substring(0, g_WebServiceURI.Length - 1);
            if (g_WebServiceURI.Substring(g_WebServiceURI.Length - 5).ToLower() != ".asmx")
                throw new FormatException("The WebService URI must end with '.asmx'.");

            //Create the RequestURI string
            m_RequestURI = "http://" + g_RemoteHostName + "/" + g_WebServiceURI + "/" + g_WebMethodName;

            //Check for Request Parameter Collection
            if (g_HttpGetRequestParameterCollection != null && g_HttpGetRequestParameterCollection.Length != 0)
            {
                foreach (RequestParameter m_RequestParameter in g_HttpGetRequestParameterCollection)
                    if (m_RequestParameter != null)
                        m_RequestParameterString += HttpUtility.UrlEncode(m_RequestParameter.ParameterName) + "=" + HttpUtility.UrlEncode(m_RequestParameter.ParameterValue) + "&";

                //Remove trailing '&'
                if (m_RequestParameterString.Length > 0)
                    m_RequestParameterString = m_RequestParameterString.Substring(0, m_RequestParameterString.Length - 1);
            }

            if (String.IsNullOrEmpty(m_RequestParameterString))
                return m_RequestURI;
            else
                return m_RequestURI + "?" + m_RequestParameterString;
        } 
        #endregion

        #region Properties
        /// <summary>
        /// Gets or Sets the Request Content-Type.
        /// </summary>
        public string RequestContentType
        {
            get { return g_HttpGetRequestContentType; }

            set { g_HttpGetRequestContentType = value; }
        }

        /// <summary>
        /// Gets or Sets the Remote hostname where the WebService is hosted.
        /// </summary>
        public string RemoteHostName
        {
            get { return g_RemoteHostName; }

            set { g_RemoteHostName = value; }
        }

        /// <summary>
        /// Gets or Sets the WebService URI.
        /// </summary>
        public string WebServiceURI
        {
            get { return g_WebServiceURI; }

            set { g_WebServiceURI = value.Replace("\\", "/"); }
        }

        /// <summary>
        /// Gets or Sets the Request WebMethod name.
        /// </summary>
        public string WebMethodName
        {
            get { return g_WebMethodName; }

            set { g_WebMethodName = value; }
        }

        /// <summary>
        /// Gets or Sets the Request Parameter Collection.
        /// </summary>
        public RequestParameter[] RequestParameterCollection
        {
            get { return g_HttpGetRequestParameterCollection; }
            set { g_HttpGetRequestParameterCollection = value; }
        }

        /// <summary>
        /// Gets or Sets the Request Security object.
        /// </summary>
        public FrameWorkSecurity RequestSecurity
        {
            get { return g_SecurityObject; }
            set { g_SecurityObject = value; }
        }

        /// <summary>
        /// Gets or Sets the Request Policy object.
        /// </summary>
        public FrameWorkPolicy RequestPolicy
        {
            get { return g_PolicyObject; }
            set { g_PolicyObject = value; }
        }

        /// <summary>
        /// Gets the Response Data for the WebService HTTP GET Request.
        /// </summary>
        public string HttpGetResponseData
        {
            get { return g_HttpGetResponseString; }
        }

        /// <summary>
        /// Gets the length of the Response Data.
        /// </summary>
        public long HttpGetResponseContentLength
        {
            get { return g_HttpGetResponseContentLength; }
        }

        /// <summary>
        /// Gets the Content Type of the Response Data.
        /// </summary>
        public string HttpGetResponseContentType
        {
            get { return g_HttpGetResponseContentType; }
        }

        /// <summary>
        /// Indicates if the Response Data has been fetched from the cache.
        /// </summary>
        public bool HttpGetResponseIsFromCache
        {
            get { return g_HttpGetResponseIsFromCache; }
        }

        /// <summary>
        /// Indicates if the communication has been Mutually Authenticated.
        /// </summary>
        public bool HttpGetResponseIsMutuallyAuthenticated
        {
            get { return g_HttpGetResponseIsMutuallyAuthenticated; }
        }

        /// <summary>
        /// Gets the actual URI which responded to the WebService HTTP GET Request.
        /// </summary>
        public Uri HttpGetResponseActualURI
        {
            get { return g_HttpGetResponseActualURI; }
        }

        /// <summary>
        /// Gets the header of the Response for the WebService HTTP GET Request.
        /// </summary>
        public WebHeaderCollection HttpGetResponseHeader
        {
            get { return g_HttpGetResponseHeader; }
        }

        /// <summary>
        /// Gets the actual HTTP GET Request string to access the Web Service.
        /// </summary>
        public string HttpGetRequestString
        {
            get
            {
                try
                {
                    return CreateGetRequestURI();
                }
                catch (Exception)
                {
                    throw;
                }
            }
        }
        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\WebServiceTestFramework\WebServiceTestFramework\HTTPSoap11Access.cs ===
﻿using System;
using System.Text;

namespace Test.Common.Library.WebServiceTestFramework
{
    /// <summary>
    /// Represents access of Web Service via SOAP 1.1 protocol.
    /// </summary>
    public class HTTPSoap11Access : HTTPSoapAccess
    {
        /// <summary>
        /// Initializes a new instance of HTTPSoap11Access.
        /// </summary>
        public HTTPSoap11Access()
            : base()
        {
            ReSetSoap11Defaults();
        }

        /// <summary>
        /// Initializes a new instance of HTTPSoap11Access with specified
        /// Hostname, Service URI, WebMethod name and the request parameter collection.
        /// </summary>
        /// <param name="RemoteHostName">The Remote computername hosting the Web Service.</param>
        /// <param name="WebServiceURI">The URI path to the Web Service.</param>
        /// <param name="WebMethodName">The Web Methodname to call in the Web Service.</param>
        /// <param name="WebServiceXMLNameSpace">The XML namespace of the Web Service.</param>
        /// <param name="ParameterCollection">An array of parameter-value to pass to the Web Method.</param>
        public HTTPSoap11Access(string RemoteHostName, string WebServiceURI, string WebMethodName, string WebServiceXMLNameSpace,
            RequestParameter[] ParameterCollection)
            : base(RemoteHostName, WebServiceURI, WebMethodName, WebServiceXMLNameSpace, ParameterCollection)
        {
            ReSetSoap11Defaults();
        }

        /// <summary>
        /// Initializes a new instance of HTTPSoap11Access with specified
        /// Hostname, Service URI, WebMethod name, request parameter collection, Security object and Policy object.
        /// </summary>
        /// <param name="RemoteHostName">The Remote computername hosting the Web Service.</param>
        /// <param name="WebServiceURI">The URI path to the Web Service.</param>
        /// <param name="WebMethodName">The Web Methodname to call in the Web Service.</param>
        /// <param name="WebServiceXMLNameSpace">The XML namespace of the Web Service.</param>
        /// <param name="ParameterCollection">An array of parameter-value to pass to the Web Method.</param>
        /// <param name="WebServiceSecurity">The Security object for accessing the Web Service.</param>
        /// <param name="WebServicePolicy">The Policy object for accessing the Web Service.</param>
        public HTTPSoap11Access(string RemoteHostName, string WebServiceURI, string WebMethodName, string WebServiceXMLNameSpace,
            RequestParameter[] ParameterCollection, FrameWorkSecurity WebServiceSecurity, FrameWorkPolicy WebServicePolicy)
            : base(RemoteHostName, WebServiceURI, WebMethodName, WebServiceXMLNameSpace, ParameterCollection,
            WebServiceSecurity, WebServicePolicy)
        {
            ReSetSoap11Defaults();
        }

        /// <summary>
        /// Sets the defaults for SOAP 1.1 specific implementation.
        /// </summary>
        private void ReSetSoap11Defaults()
        {
            RequestContentType = "text/xml; charset=utf-8";
            SetSOAPAccessType(SOAPAccessType.Soap11);
        }

        /// <summary>
        /// Create the POST request content containing the SOAP 1.1 Envelope.
        /// </summary>
        /// <returns></returns>
        protected override byte[] CreatePostRequestSoapContent()
        {
            StringBuilder m_RequestParameterString = new StringBuilder();

            //Create the initial SOAP Envelope
            m_RequestParameterString.Append("<?xml version=\"1.0\" encoding=\"utf-8\"?>");
            m_RequestParameterString.Append("<soap:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\">");
            m_RequestParameterString.Append("<soap:Body>");

            //Create the WebMethod and Param tags
            if (RequestParameterCollection != null && RequestParameterCollection.Length != 0)
            {
                //Add param tags
                m_RequestParameterString.Append("<" + WebMethodName + " xmlns=\"" + WebServiceXMLNameSpace + "\">");
                foreach (RequestParameter m_Requestparameter in RequestParameterCollection)
                    if (m_Requestparameter != null)
                        m_RequestParameterString.Append("<" + m_Requestparameter.ParameterName + ">" + m_Requestparameter.ParameterValue + "</" + m_Requestparameter.ParameterName + ">");
            }
            else
                m_RequestParameterString.Append("<" + WebMethodName + " xmlns=\"" + WebServiceXMLNameSpace + "\" />");

            m_RequestParameterString.Append("</soap:Body>");
            m_RequestParameterString.Append("</soap:Envelope>");

            return Encoding.UTF8.GetBytes(m_RequestParameterString.ToString());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\WebServiceTestFramework\WebServiceTestFramework\RequestParameter.cs ===
﻿using System;
using System.Web;
using System.Text;

namespace Test.Common.Library.WebServiceTestFramework
{
    /// <summary>
    /// Represents a parameter name-value pair to be sent with the Request object.
    /// </summary>
    public class RequestParameter
    {
        private string g_ParameterName;
        private string g_ParameterValue;

        /// <summary>
        /// Initializes a new instance of RequestParameter.
        /// </summary>
        public RequestParameter()
        {
            //Empty Constructor
        }

        /// <summary>
        /// Initializes a new instance of RequestParameter with the specified
        /// Parameter name and value.
        /// </summary>
        /// <param name="ParameterName">The name of the Request parameter.</param>
        /// <param name="ParameterValue">the value of the Request parameter.</param>
        public RequestParameter(string ParameterName, string ParameterValue)
        {
            g_ParameterName = ParameterName;
            g_ParameterValue = ParameterValue;
        }

        /// <summary>
        /// Gets or Sets the name of the Request parameter.
        /// </summary>
        public string ParameterName
        {
            get { return g_ParameterName; }

            set
            {
                if (value.Contains(" "))
                    throw new FormatException("The parameter name cannot have any blanks.");
                if (value.Contains("\\"))
                    throw new FormatException("Invalid character '\' in parameter name.");
                if (value.Contains("?"))
                    throw new FormatException("Invalid character '?' in parameter name.");
                if (value.Contains("&"))
                    throw new FormatException("Invalid character '&' in parameter name.");
                g_ParameterName = value;
            }
        }

        /// <summary>
        /// Gets or Sets the value of the Request parameter.
        /// </summary>
        public string ParameterValue
        {
            get { return g_ParameterValue; }

            set { g_ParameterValue = HttpUtility.UrlEncode(value); }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\WebServiceTestFramework\WebServiceTestFramework\HTTPSoap12Access.cs ===
﻿using System;
using System.Text;

namespace Test.Common.Library.WebServiceTestFramework
{
    /// <summary>
    /// Represents access of Web Service via SOAP 1.2 protocol.
    /// </summary>
    public class HTTPSoap12Access : HTTPSoapAccess
    {
        /// <summary>
        /// Initializes a new instance of HTTPSoap12Access.
        /// </summary>
        public HTTPSoap12Access()
            : base()
        {
            ReSetSoap12Defaults();
        }

        /// <summary>
        /// Initializes a new instance of HTTPSoap12Access with specified
        /// Hostname, Service URI, WebMethod name and the request parameter collection.
        /// </summary>
        /// <param name="RemoteHostName">The Remote computername hosting the Web Service.</param>
        /// <param name="WebServiceURI">The URI path to the Web Service.</param>
        /// <param name="WebMethodName">The Web Methodname to call in the Web Service.</param>
        /// <param name="WebServiceXMLNameSpace">The XML namespace of the Web Service.</param>
        /// <param name="ParameterCollection">An array of parameter-value to pass to the Web Method.</param>
        public HTTPSoap12Access(string RemoteHostName, string WebServiceURI, string WebMethodName, string WebServiceXMLNameSpace,
            RequestParameter[] ParameterCollection)
            : base(RemoteHostName, WebServiceURI, WebMethodName, WebServiceXMLNameSpace, ParameterCollection)
        {
            ReSetSoap12Defaults();
        }

        /// <summary>
        /// Initializes a new instance of HTTPSoap12Access with specified
        /// Hostname, Service URI, WebMethod name, request parameter collection, Security object and Policy object.
        /// </summary>
        /// <param name="RemoteHostName">The Remote computername hosting the Web Service.</param>
        /// <param name="WebServiceURI">The URI path to the Web Service.</param>
        /// <param name="WebMethodName">The Web Methodname to call in the Web Service.</param>
        /// <param name="WebServiceXMLNameSpace">The XML namespace of the Web Service.</param>
        /// <param name="ParameterCollection">An array of parameter-value to pass to the Web Method.</param>
        /// <param name="WebServiceSecurity">The Security object for accessing the Web Service.</param>
        /// <param name="WebServicePolicy">The Policy object for accessing the Web Service.</param>
        public HTTPSoap12Access(string RemoteHostName, string WebServiceURI, string WebMethodName, string WebServiceXMLNameSpace,
            RequestParameter[] ParameterCollection, FrameWorkSecurity WebServiceSecurity, FrameWorkPolicy WebServicePolicy)
            : base(RemoteHostName, WebServiceURI, WebMethodName, WebServiceXMLNameSpace, ParameterCollection,
            WebServiceSecurity, WebServicePolicy)
        {
            ReSetSoap12Defaults();
        }

        /// <summary>
        /// Sets the defaults for SOAP 1.2 specific implementation.
        /// </summary>
        private void ReSetSoap12Defaults()
        {
            RequestContentType = "application/soap+xml; charset=utf-8";
            SetSOAPAccessType(SOAPAccessType.Soap12);
        }

        /// <summary>
        /// Create the POST request content containing the SOAP 1.2 Envelope.
        /// </summary>
        /// <returns></returns>
        protected override byte[] CreatePostRequestSoapContent()
        {
            StringBuilder m_RequestParameterString = new StringBuilder();

            //Create the initial SOAP Envelope
            m_RequestParameterString.Append("<?xml version=\"1.0\" encoding=\"utf-8\"?>");
            m_RequestParameterString.Append("<soap12:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:soap12=\"http://www.w3.org/2003/05/soap-envelope\">");
            m_RequestParameterString.Append("<soap12:Body>");
            
            //Create the WebMethod and Param tags
            if (RequestParameterCollection != null && RequestParameterCollection.Length != 0)
            {
                //Add param tags
                m_RequestParameterString.Append("<" + WebMethodName + " xmlns=\"" + WebServiceXMLNameSpace + "\">");
                foreach (RequestParameter m_Requestparameter in RequestParameterCollection)
                    if (m_Requestparameter != null)
                        m_RequestParameterString.Append("<" + m_Requestparameter.ParameterName + ">" + m_Requestparameter.ParameterValue + "</" + m_Requestparameter.ParameterName + ">");
            }
            else
                m_RequestParameterString.Append("<" + WebMethodName + " xmlns=\"" + WebServiceXMLNameSpace + "\" />");

            m_RequestParameterString.Append("</soap12:Body>");
            m_RequestParameterString.Append("</soap12:Envelope>");

            return Encoding.UTF8.GetBytes(m_RequestParameterString.ToString());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\LiveCacheEmulator\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\WebServiceTestFramework\WebServiceTestFramework\HTTPPostAccess.cs ===
﻿using System;
using System.Collections.Generic;
using System.Security.Principal;
using System.IO;
using System.Net;
using System.Net.Cache;
using System.Net.Security;
using System.Text;
using System.Web;

namespace Test.Common.Library.WebServiceTestFramework
{
    /// <summary>
    /// Represents access of Web Service via HTTP POST protocol.
    /// </summary>
    public class HTTPPostAccess
    {
        private WebRequest g_HttpPostRequest;
        private WebResponse g_HttpPostResponse;
        private FrameWorkSecurity g_SecurityObject;
        private FrameWorkPolicy g_PolicyObject;
        private RequestParameter[] g_HttpPostRequestParameterCollection;

        //Request Object Params
        private bool g_HttpPostRequestRequirePreAuthenticate;
        private TokenImpersonationLevel g_HttpPostRequestImpersonationLevel;
        private RequestCachePolicy g_HttpPostRequestCachePolicy;
        private AuthenticationLevel g_HttpPostRequestAuthenticationLevel;
        private NetworkCredential g_HttpPostRequestCredentials;
        private string g_HttpPostRequestContentType;
        private int g_HttpPostRequestTimeout;
        private string g_RemoteHostName;
        private string g_WebServiceURI;
        private string g_WebMethodName;

        //Response Object Params
        private string g_HttpPostResponseString;
        private WebHeaderCollection g_HttpPostResponseHeader;
        private long g_HttpPostResponseContentLength;
        private string g_HttpPostResponseContentType;
        private bool g_HttpPostResponseIsFromCache;
        private bool g_HttpPostResponseIsMutuallyAuthenticated;
        private Uri g_HttpPostResponseActualURI;

        #region Constructors
        /// <summary>
        /// Initializes a new instance of the HTTPPostAccess class.
        /// </summary>
        public HTTPPostAccess()
        {
            SetDefaults();
        }

        /// <summary>
        /// Initializes a new instance of the HTTPPostAccess class with the specified
        /// Hostname, Service URI, WebMethod name and Request Parameter collection.
        /// </summary>
        /// <param name="RemoteHostName">The Remote computername hosting the Web Service.</param>
        /// <param name="WebServiceURI">The URI path to the Web Service.</param>
        /// <param name="WebMethodName">The Web Methodname to call in the Web Service.</param>
        /// <param name="ParameterCollection">An array of parameter-value to pass to the Web Method.</param>
        public HTTPPostAccess(string RemoteHostName, string WebServiceURI, string WebMethodName, RequestParameter[] ParameterCollection)
        {
            //Set Defaults
            SetDefaults();

            //Set Passed values
            g_RemoteHostName = RemoteHostName;
            g_WebServiceURI = WebServiceURI;
            g_WebMethodName = WebMethodName;
            g_HttpPostRequestParameterCollection = ParameterCollection;
        }

        /// <summary>
        /// Initializes a new instance of the HTTPPostAccess class with the specified
        /// Hostname, Service URI, WebMethod name, Request Parameter collection, Security object and Policy object.
        /// </summary>
        /// <param name="RemoteHostName">The Remote computername hosting the Web Service.</param>
        /// <param name="WebServiceURI">The URI path to the Web Service.</param>
        /// <param name="WebMethodName"></param>
        /// <param name="ParameterCollection">The Web Methodname to call in the Web Service.</param>
        /// <param name="WebServiceSecurity">The Security object for accessing the Web Service.</param>
        /// <param name="WebServicePolicy">The Policy object for accessing the Web Service.</param>
        public HTTPPostAccess(string RemoteHostName, string WebServiceURI, string WebMethodName, RequestParameter[] ParameterCollection,
            FrameWorkSecurity WebServiceSecurity, FrameWorkPolicy WebServicePolicy)
        {
            //Set defaults
            SetDefaults();

            //Set Passed values
            g_RemoteHostName = RemoteHostName;
            g_WebServiceURI = WebServiceURI;
            g_WebMethodName = WebMethodName;
            g_HttpPostRequestParameterCollection = ParameterCollection;
            g_SecurityObject = WebServiceSecurity;
            g_PolicyObject = WebServicePolicy;
        }

        #endregion

        #region Methods
        /// <summary>
        /// Indicates if the POST Request object has been initialized.
        /// </summary>
        /// <returns>A value of type System.Boolean. True if the object has been initialized.</returns>
        public bool IsPOSTRequestInitialized()
        {
            if (g_HttpPostRequest != null)
                return true;
            else
                return false;
        }

        /// <summary>
        /// Create the POST Request.
        /// </summary>
        public void CreatePOSTRequest()
        {
            byte[] m_PostRequestContent;
            Stream m_PostRequestStream;

            //Refresh Values
            try
            {
                SetSecurity();
                SetPolicy();
            }
            catch (Exception)
            {
                throw;
            }

            //Create the Post Object
            try
            {
                g_HttpPostRequest = WebRequest.Create(CreatePostRequestURI());
                m_PostRequestContent = CreatePostRequestContent();
                g_HttpPostRequest.ContentLength = m_PostRequestContent.Length;
                g_HttpPostRequest.AuthenticationLevel = g_HttpPostRequestAuthenticationLevel;
                g_HttpPostRequest.CachePolicy = g_HttpPostRequestCachePolicy;
                g_HttpPostRequest.ContentType = g_HttpPostRequestContentType;
                g_HttpPostRequest.Credentials = g_HttpPostRequestCredentials;
                g_HttpPostRequest.ImpersonationLevel = g_HttpPostRequestImpersonationLevel;
                g_HttpPostRequest.PreAuthenticate = g_HttpPostRequestRequirePreAuthenticate;
                g_HttpPostRequest.Method = "POST";
                g_HttpPostRequest.Timeout = g_HttpPostRequestTimeout;

                //Write Content
                m_PostRequestStream = g_HttpPostRequest.GetRequestStream();
                m_PostRequestStream.Write(m_PostRequestContent, 0, m_PostRequestContent.Length);
                m_PostRequestStream.Close();
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Get the Response for the POST request.
        /// </summary>
        public void GetResponse()
        {
            StreamReader m_ResponseReader;
            Stream m_ResponseDataStream;

            //Check if the POST Request object has been constructed
            if (g_HttpPostRequest == null)
                throw new InvalidOperationException("The POST Request has not been constructed. Please construct the POST request prior to calling this method.");

            try
            {
                g_HttpPostResponse = g_HttpPostRequest.GetResponse();
                m_ResponseDataStream = g_HttpPostResponse.GetResponseStream();
                m_ResponseReader = new StreamReader(m_ResponseDataStream);
                g_HttpPostResponseHeader = g_HttpPostResponse.Headers;
                g_HttpPostResponseString = m_ResponseReader.ReadToEnd();
                g_HttpPostResponseContentLength = g_HttpPostResponse.ContentLength;
                g_HttpPostResponseContentType = g_HttpPostResponse.ContentType;
                g_HttpPostResponseIsFromCache = g_HttpPostResponse.IsFromCache;
                g_HttpPostResponseIsMutuallyAuthenticated = g_HttpPostResponse.IsMutuallyAuthenticated;
                g_HttpPostResponseActualURI = g_HttpPostResponse.ResponseUri;
                //Close Response Stream
                g_HttpPostResponse.Close();
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Sets default values for the various properties of the Post Request Object
        /// </summary>
        private void SetDefaults()
        {
            try
            {
                g_HttpPostRequestRequirePreAuthenticate = false;
                g_HttpPostRequestImpersonationLevel = TokenImpersonationLevel.Delegation;
                g_HttpPostRequestCachePolicy = new RequestCachePolicy(RequestCacheLevel.BypassCache);
                g_HttpPostRequestAuthenticationLevel = AuthenticationLevel.MutualAuthRequested;
                g_HttpPostRequestCredentials = (NetworkCredential)CredentialCache.DefaultCredentials;
                g_HttpPostRequestContentType = "application/x-www-form-urlencoded";
                g_HttpPostRequestTimeout = 100000;
                g_RemoteHostName = String.Empty;
                g_WebServiceURI = String.Empty;
                g_WebMethodName = String.Empty;
                g_HttpPostRequestParameterCollection = null;
                g_SecurityObject = null;
                g_PolicyObject = null;

                g_HttpPostResponseHeader = null;
                g_HttpPostResponseString = String.Empty;
                g_HttpPostResponseContentLength = 0;
                g_HttpPostResponseContentType = String.Empty;
                g_HttpPostResponseIsFromCache = false;
                g_HttpPostResponseIsMutuallyAuthenticated = false;
                g_HttpPostResponseActualURI = null;
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Set the Security parameters of the HTTP POST Request Object.
        /// </summary>
        private void SetSecurity()
        {
            try
            {
                //Check if a Security object exists
                if (g_SecurityObject != null)
                {
                    //Set Access credentials
                    if (!g_SecurityObject.IsDefaultNetworkCredentials())
                        g_HttpPostRequestCredentials = g_SecurityObject.GetNetworkCredential();

                    //Set PreAuth
                    if (g_SecurityObject.RequirePreAuthentication)
                        g_HttpPostRequestRequirePreAuthenticate = true;

                    //Set Impersonation Level
                    switch (g_SecurityObject.RequestImpersonationLevel)
                    {
                        case FrameWorkSecurity.ImpersonationLevel.Anonymous:
                            g_HttpPostRequestImpersonationLevel = TokenImpersonationLevel.Anonymous;
                            break;
                        case FrameWorkSecurity.ImpersonationLevel.Delegation:
                            g_HttpPostRequestImpersonationLevel = TokenImpersonationLevel.Delegation;
                            break;
                        case FrameWorkSecurity.ImpersonationLevel.Identification:
                            g_HttpPostRequestImpersonationLevel = TokenImpersonationLevel.Identification;
                            break;
                        case FrameWorkSecurity.ImpersonationLevel.Impersonation:
                            g_HttpPostRequestImpersonationLevel = TokenImpersonationLevel.Impersonation;
                            break;
                        case FrameWorkSecurity.ImpersonationLevel.None:
                            g_HttpPostRequestImpersonationLevel = TokenImpersonationLevel.None;
                            break;
                    }

                    //Set Authentication Level
                    switch (g_SecurityObject.RequestAuthenticationLevel)
                    {
                        case FrameWorkSecurity.AuthenticationLevel.MutualAuthRequested:
                            g_HttpPostRequestAuthenticationLevel = AuthenticationLevel.MutualAuthRequested;
                            break;
                        case FrameWorkSecurity.AuthenticationLevel.MutualAuthRequired:
                            g_HttpPostRequestAuthenticationLevel = AuthenticationLevel.MutualAuthRequired;
                            break;
                        case FrameWorkSecurity.AuthenticationLevel.None:
                            g_HttpPostRequestAuthenticationLevel = AuthenticationLevel.None;
                            break;
                    }
                }
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Set the general policy for the HTTP POST Request Object.
        /// </summary>
        private void SetPolicy()
        {
            try
            {
                //Check if a Policy Object exists
                if (g_PolicyObject != null)
                {
                    //Set Cache policy
                    g_HttpPostRequestCachePolicy = g_PolicyObject.GetCachePolicy();

                    //Set TimeOut
                    g_HttpPostRequestTimeout = g_PolicyObject.RequestTimeOut;
                }
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Create the POST Request URI String.
        /// </summary>
        /// <returns></returns>
        private string CreatePostRequestURI()
        {
            string m_RequestURI = string.Empty;

            //Check RemoteHostName
            if (String.IsNullOrEmpty(g_RemoteHostName))
                throw new NullReferenceException("The Remote HostName has not been set. Please set the HostName prior to calling this method.");
            if (g_RemoteHostName.Contains("http://"))
                throw new FormatException("'http://' cannot be included as a part of the RemoteHost name.");
            if (g_RemoteHostName.Contains("\\"))
                throw new FormatException("Invalid character '\' in Remote Host name.");
            if (g_RemoteHostName.Contains("/"))
                throw new FormatException("Invalid character '/' in Remote Host name.");


            //Check WebService URI
            if (String.IsNullOrEmpty(g_WebServiceURI))
                throw new NullReferenceException("The WebService URI has not been set. Please set the URI prior to calling this method.");

            //Check Webmethod name
            if (String.IsNullOrEmpty(g_WebMethodName))
                throw new NullReferenceException("The WebMethod name has not been set. Please set the WebMethod name prior to calling this method.");
            if (g_WebMethodName.Contains("\\"))
                throw new FormatException("Invalid character '\' in WebMethod name.");
            if (g_WebMethodName.Contains("/"))
                throw new FormatException("Invalid character '/' in WebMethod name.");

            //Remove leading and trailing '/' from WebService URI
            if (g_WebServiceURI.Substring(0, 1) == "/")
                g_WebServiceURI = g_WebServiceURI.Substring(1);
            if (g_WebServiceURI.Substring(g_WebServiceURI.Length - 1) == "/")
                g_WebServiceURI = g_WebServiceURI.Substring(0, g_WebServiceURI.Length - 1);
            if (g_WebServiceURI.Substring(g_WebServiceURI.Length - 5).ToLower() != ".asmx")
                throw new FormatException("The WebService URI must end with '.asmx'.");

            //Create the RequestURI string
            m_RequestURI = "http://" + g_RemoteHostName + "/" + g_WebServiceURI + "/" + g_WebMethodName;

            return m_RequestURI;
        }

        /// <summary>
        /// Create the POST request content containing the parameter-value collection.
        /// </summary>
        /// <returns></returns>
        private byte[] CreatePostRequestContent()
        {
            string m_RequestParameterString = String.Empty;

            try
            {
                //Check for Request Parameter Collection
                if (g_HttpPostRequestParameterCollection != null && g_HttpPostRequestParameterCollection.Length != 0)
                {
                    foreach (RequestParameter m_RequestParameter in g_HttpPostRequestParameterCollection)
                        if (m_RequestParameter != null)
                            m_RequestParameterString += HttpUtility.UrlEncode(m_RequestParameter.ParameterName) + "=" + HttpUtility.UrlEncode(m_RequestParameter.ParameterValue) + "&";

                    //Remove trailing '&'
                    if (m_RequestParameterString.Length > 0)
                        m_RequestParameterString = m_RequestParameterString.Substring(0, m_RequestParameterString.Length - 1);
                }
            }
            catch (Exception)
            {
                throw;
            }

            return Encoding.UTF8.GetBytes(m_RequestParameterString);
        }
        #endregion

        #region Properties
        /// <summary>
        /// Gets or Sets the Request Content-Type.
        /// </summary>
        public string RequestContentType
        {
            get { return g_HttpPostRequestContentType; }

            set { g_HttpPostRequestContentType = value; }
        }

        /// <summary>
        /// Gets or Sets the Remote hostname where the WebService is hosted.
        /// </summary>
        public string RemoteHostName
        {
            get { return g_RemoteHostName; }

            set { g_RemoteHostName = value; }
        }

        /// <summary>
        /// Gets or Sets the WebService URI.
        /// </summary>
        public string WebServiceURI
        {
            get { return g_WebServiceURI; }

            set { g_WebServiceURI = value.Replace("\\", "/"); }
        }

        /// <summary>
        /// Gets or Sets the Request WebMethod name.
        /// </summary>
        public string WebMethodName
        {
            get { return g_WebMethodName; }

            set { g_WebMethodName = value; }
        }

        /// <summary>
        /// Gets or Sets the Request Parameter Collection.
        /// </summary>
        public RequestParameter[] RequestParameterCollection
        {
            get { return g_HttpPostRequestParameterCollection; }
            set { g_HttpPostRequestParameterCollection = value; }
        }

        /// <summary>
        /// Gets or Sets the Request Security object.
        /// </summary>
        public FrameWorkSecurity RequestSecurity
        {
            get { return g_SecurityObject; }
            set { g_SecurityObject = value; }
        }

        /// <summary>
        /// Gets or Sets the Request Policy object.
        /// </summary>
        public FrameWorkPolicy RequestPolicy
        {
            get { return g_PolicyObject; }
            set { g_PolicyObject = value; }
        }

        /// <summary>
        /// Gets the Response Data for the WebService HTTP POST Request.
        /// </summary>
        public string HttpPostResponseData
        {
            get { return g_HttpPostResponseString; }
        }

        /// <summary>
        /// Gets the length of the Response Data.
        /// </summary>
        public long HttpPostResponseContentLength
        {
            get { return g_HttpPostResponseContentLength; }
        }

        /// <summary>
        /// Gets the Content Type of the Response Data.
        /// </summary>
        public string HttpPostResponseContentType
        {
            get { return g_HttpPostResponseContentType; }
        }

        /// <summary>
        /// Indicates if the Response Data has been fetched from the cache.
        /// </summary>
        public bool HttpPostResponseIsFromCache
        {
            get { return g_HttpPostResponseIsFromCache; }
        }

        /// <summary>
        /// Indicates if the communication has been Mutually Authenticated.
        /// </summary>
        public bool HttpPostResponseIsMutuallyAuthenticated
        {
            get { return g_HttpPostResponseIsMutuallyAuthenticated; }
        }

        /// <summary>
        /// Gets the actual URI which responded to the WebService HTTP POST Request.
        /// </summary>
        public Uri HttpPostResponseActualURI
        {
            get { return g_HttpPostResponseActualURI; }
        }

        /// <summary>
        /// Gets the header of the Response for the WebService HTTP POST Request.
        /// </summary>
        public WebHeaderCollection HttpPostResponseHeader
        {
            get { return g_HttpPostResponseHeader; }
        }

        /// <summary>
        /// Gets the actual HTTP POST Request string to access the Web Service.
        /// </summary>
        public string HttpPostRequestString
        {
            get
            {
                try
                {
                    return CreatePostRequestURI();
                }
                catch (Exception)
                {
                    throw;
                }
            }
        }

        /// <summary>
        /// Gets the HTTP POST Request content.
        /// </summary>
        public byte[] HttpPostRequestContent
        {
            get
            {
                try
                {
                    return CreatePostRequestContent();
                }
                catch (Exception)
                {
                    throw;
                }
            }
        }
        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\WebServiceTestFramework\WebServiceTestFramework\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("WebServiceTestFramework")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
//[assembly: AssemblyCompany("")]
//[assembly: AssemblyProduct("")]
//[assembly: AssemblyCopyright("")]
//[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("9ac7cf8b-739a-423e-91e7-2cc7d57ce330")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
//[assembly: AssemblyVersion("1.0.0.0")]
//[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\LiveCacheEmulator\AccountCreationDataAccessEmulator.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Leet.Live.Livecache.DataAccess;
using xonline.common.protocol;

namespace Test.Common.LiveCacheEmulator
{
	public class AccountCreationDataAccessEmulator : IAccountCreationDataAccess
	{
		public void GetUserWebInfo(ulong livePuid, ServiceTypeEnum liveServiceType, out uint tier, out uint[] privileges,
			out DateTime lastWebActivity, out byte parentalControlGroup, out bool isLightAccount, out bool isProvisioned, out byte accountType)
		{
			LiveCacheData data = LiveCacheEmulator.GetDataFromXuid((long)livePuid);
			tier = (uint)data.Tier;
			privileges = data.Priveleges;
			lastWebActivity = data.LastWebActivity;
			parentalControlGroup = data.ParentalControlGroup;
			isLightAccount = data.IsLightAccount;
			isProvisioned = data.IsProvisioned;
            accountType = data.AccountType;
		}


        public void UpdateParentalControls(ulong livePuid, uint[] grantPrivileges, uint[] restrictPrivileges, string source)
        {
            throw new NotImplementedException();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Library\WebServiceTestFramework\WebServiceTestFramework\HTTPSoapAccess.cs ===
﻿using System;
using System.Collections.Generic;
using System.Security.Principal;
using System.IO;
using System.Net;
using System.Net.Cache;
using System.Net.Security;
using System.Text;
using System.Web;

namespace Test.Common.Library.WebServiceTestFramework
{
    /// <summary>
    /// Represents access of Web Service via SOAP protocol.
    /// Version specific implementation in the derived class.
    /// </summary>
    public abstract class HTTPSoapAccess
    {
        private WebRequest g_HttpSoapRequest;
        private WebResponse g_HttpSoapResponse;
        private FrameWorkSecurity g_SecurityObject;
        private FrameWorkPolicy g_PolicyObject;
        private RequestParameter[] g_HttpSoapRequestParameterCollection;
        private SOAPAccessType g_HttpSoapAccessVersion;

        //Request Object Params
        private bool g_HttpSoapRequestRequirePreAuthenticate;
        private TokenImpersonationLevel g_HttpSoapRequestImpersonationLevel;
        private RequestCachePolicy g_HttpSoapRequestCachePolicy;
        private AuthenticationLevel g_HttpSoapRequestAuthenticationLevel;
        private NetworkCredential g_HttpSoapRequestCredentials;
        private string g_HttpSoapRequestContentType;
        private int g_HttpSoapRequestTimeout;
        private string g_RemoteHostName;
        private string g_WebServiceURI;
        private string g_WebMethodName;
        private string g_WebServiceXMLNameSpace;

        //Response Object Params
        private string g_HttpSoapResponseString;
        private WebHeaderCollection g_HttpSoapResponseHeader;
        private long g_HttpSoapResponseContentLength;
        private string g_HttpSoapResponseContentType;
        private bool g_HttpSoapResponseIsFromCache;
        private bool g_HttpSoapResponseIsMutuallyAuthenticated;
        private Uri g_HttpSoapResponseActualURI;

        #region Constructors
        /// <summary>
        /// Initializes HTTPSoapAccess from derived class.
        /// </summary>
        protected HTTPSoapAccess()
        {
            SetDefaults();
        }

        /// <summary>
        /// Initializes HTTPSoapAccess from derived class with specified
        /// Hostname, Service URI, WebMethod name, Service namespace and the Request Parameter collection.
        /// </summary>
        /// <param name="RemoteHostName">The Remote computername hosting the Web Service.</param>
        /// <param name="WebServiceURI">The URI path to the Web Service.</param>
        /// <param name="WebMethodName">The Web Methodname to call in the Web Service.</param>
        /// <param name="WebServiceXMLNameSpace">The XML namespace of the Web Service.</param>
        /// <param name="ParameterCollection">An array of parameter-value to pass to the Web Method.</param>
        protected HTTPSoapAccess(string RemoteHostName, string WebServiceURI, string WebMethodName,
            string WebServiceXMLNameSpace, RequestParameter[] ParameterCollection)
        {
            //Set Defaults
            SetDefaults();

            //Set Passed values
            g_RemoteHostName = RemoteHostName;
            g_WebServiceURI = WebServiceURI;
            g_WebMethodName = WebMethodName;
            g_WebServiceXMLNameSpace = WebServiceXMLNameSpace;
            g_HttpSoapRequestParameterCollection = ParameterCollection;
        }

        /// <summary>
        /// Initializes HTTPSoapAccess from derived class with specified
        /// Hostname, Service URI, WebMethod name, Service namespace, Request Parameter collection, Security object and Policy object.
        /// </summary>
        /// <param name="RemoteHostName">The Remote computername hosting the Web Service.</param>
        /// <param name="WebServiceURI">The URI path to the Web Service.</param>
        /// <param name="WebMethodName"></param>
        /// <param name="WebServiceXMLNameSpace">The XML namespace of the Web Service.</param>
        /// <param name="ParameterCollection">The Web Methodname to call in the Web Service.</param>
        /// <param name="WebServiceSecurity">The Security object for accessing the Web Service.</param>
        /// <param name="WebServicePolicy">The Policy object for accessing the Web Service.</param>
        protected HTTPSoapAccess(string RemoteHostName, string WebServiceURI, string WebMethodName, string WebServiceXMLNameSpace,
            RequestParameter[] ParameterCollection, FrameWorkSecurity WebServiceSecurity, FrameWorkPolicy WebServicePolicy)
        {
            //Set defaults
            SetDefaults();

            //Set Passed values
            g_RemoteHostName = RemoteHostName;
            g_WebServiceURI = WebServiceURI;
            g_WebMethodName = WebMethodName;
            g_WebServiceXMLNameSpace = WebServiceXMLNameSpace;
            g_HttpSoapRequestParameterCollection = ParameterCollection;
            g_SecurityObject = WebServiceSecurity;
            g_PolicyObject = WebServicePolicy;
        }

        #endregion

        /// <summary>
        /// Indicates the version of the SOAP Access.
        /// </summary>
        protected enum SOAPAccessType
        {
            /// <summary>
            /// Indicates that access is of SOAP 1.1.
            /// </summary>
            Soap11,
            /// <summary>
            /// Indicates that access is of SOAP 1.2.
            /// </summary>
            Soap12
        }

        #region Methods
        /// <summary>
        /// Set the SOAP Version.
        /// </summary>
        /// <param name="SOAPVersion">The version of the SOAP Request.</param>
        protected void SetSOAPAccessType(SOAPAccessType SOAPVersion)
        {
            g_HttpSoapAccessVersion = SOAPVersion;
        }

        /// <summary>
        /// Indicates if the SOAP Request object has been initialized.
        /// </summary>
        /// <returns>A value of type System.Boolean. True if the object has been initialized.</returns>
        public bool IsSOAPRequestInitialized()
        {
            if (g_HttpSoapRequest != null)
                return true;
            else
                return false;
        }

        /// <summary>
        /// Create the SOAP Request.
        /// </summary>
        public void CreateSOAPRequest()
        {
            byte[] m_SoapRequestContent;
            Stream m_SoapRequestStream;

            //Refresh Values
            try
            {
                SetSecurity();
                SetPolicy();
            }
            catch (Exception)
            {
                throw;
            }

            //Create the Soap Object
            try
            {
                g_HttpSoapRequest = WebRequest.Create(CreateSoapRequestURI());
                m_SoapRequestContent = CreatePostRequestSoapContent();
                g_HttpSoapRequest.ContentLength = m_SoapRequestContent.Length;
                g_HttpSoapRequest.AuthenticationLevel = g_HttpSoapRequestAuthenticationLevel;
                g_HttpSoapRequest.CachePolicy = g_HttpSoapRequestCachePolicy;
                g_HttpSoapRequest.ContentType = g_HttpSoapRequestContentType;
                g_HttpSoapRequest.Credentials = g_HttpSoapRequestCredentials;
                g_HttpSoapRequest.ImpersonationLevel = g_HttpSoapRequestImpersonationLevel;
                g_HttpSoapRequest.PreAuthenticate = g_HttpSoapRequestRequirePreAuthenticate;
                g_HttpSoapRequest.Method = "POST";
                g_HttpSoapRequest.Timeout = g_HttpSoapRequestTimeout;

                //Add custom header if required
                if (g_HttpSoapAccessVersion == SOAPAccessType.Soap11)
                    g_HttpSoapRequest.Headers.Add("SOAPAction", "\"" + g_WebServiceXMLNameSpace + "/" + g_WebMethodName + "\"");

                //Write Content
                m_SoapRequestStream = g_HttpSoapRequest.GetRequestStream();
                m_SoapRequestStream.Write(m_SoapRequestContent, 0, m_SoapRequestContent.Length);
                m_SoapRequestStream.Close();
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Get the Response for the SOAP request.
        /// </summary>
        public void GetResponse()
        {
            StreamReader m_ResponseReader;
            Stream m_ResponseDataStream;

            //Check if the SOAP Request object has been constructed
            if (g_HttpSoapRequest == null)
                throw new InvalidOperationException("The SOAP Request has not been constructed. Please construct the SOAP request prior to calling this method.");

            try
            {
                g_HttpSoapResponse = g_HttpSoapRequest.GetResponse();
                m_ResponseDataStream = g_HttpSoapResponse.GetResponseStream();
                m_ResponseReader = new StreamReader(m_ResponseDataStream);
                g_HttpSoapResponseHeader = g_HttpSoapResponse.Headers;
                g_HttpSoapResponseString = m_ResponseReader.ReadToEnd();
                g_HttpSoapResponseContentLength = g_HttpSoapResponse.ContentLength;
                g_HttpSoapResponseContentType = g_HttpSoapResponse.ContentType;
                g_HttpSoapResponseIsFromCache = g_HttpSoapResponse.IsFromCache;
                g_HttpSoapResponseIsMutuallyAuthenticated = g_HttpSoapResponse.IsMutuallyAuthenticated;
                g_HttpSoapResponseActualURI = g_HttpSoapResponse.ResponseUri;
                //Close Response Stream
                g_HttpSoapResponse.Close();
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Sets default values for the various properties of the Soap Request Object
        /// </summary>
        private void SetDefaults()
        {
            try
            {
                g_HttpSoapRequestRequirePreAuthenticate = false;
                g_HttpSoapRequestImpersonationLevel = TokenImpersonationLevel.Delegation;
                g_HttpSoapRequestCachePolicy = new RequestCachePolicy(RequestCacheLevel.BypassCache);
                g_HttpSoapRequestAuthenticationLevel = AuthenticationLevel.MutualAuthRequested;
                g_HttpSoapRequestCredentials = (NetworkCredential)CredentialCache.DefaultCredentials;
                g_HttpSoapRequestTimeout = 100000;
                g_RemoteHostName = String.Empty;
                g_WebServiceURI = String.Empty;
                g_WebMethodName = String.Empty;
                g_HttpSoapRequestParameterCollection = null;
                g_SecurityObject = null;
                g_PolicyObject = null;

                g_HttpSoapResponseHeader = null;
                g_HttpSoapResponseString = String.Empty;
                g_HttpSoapResponseContentLength = 0;
                g_HttpSoapResponseContentType = String.Empty;
                g_HttpSoapResponseIsFromCache = false;
                g_HttpSoapResponseIsMutuallyAuthenticated = false;
                g_HttpSoapResponseActualURI = null;
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Set the Security parameters of the HTTP SOAP Request Object.
        /// </summary>
        private void SetSecurity()
        {
            try
            {
                //Check if a Security object exists
                if (g_SecurityObject != null)
                {
                    //Set Access credentials
                    if (!g_SecurityObject.IsDefaultNetworkCredentials())
                        g_HttpSoapRequestCredentials = g_SecurityObject.GetNetworkCredential();

                    //Set PreAuth
                    if (g_SecurityObject.RequirePreAuthentication)
                        g_HttpSoapRequestRequirePreAuthenticate = true;

                    //Set Impersonation Level
                    switch (g_SecurityObject.RequestImpersonationLevel)
                    {
                        case FrameWorkSecurity.ImpersonationLevel.Anonymous:
                            g_HttpSoapRequestImpersonationLevel = TokenImpersonationLevel.Anonymous;
                            break;
                        case FrameWorkSecurity.ImpersonationLevel.Delegation:
                            g_HttpSoapRequestImpersonationLevel = TokenImpersonationLevel.Delegation;
                            break;
                        case FrameWorkSecurity.ImpersonationLevel.Identification:
                            g_HttpSoapRequestImpersonationLevel = TokenImpersonationLevel.Identification;
                            break;
                        case FrameWorkSecurity.ImpersonationLevel.Impersonation:
                            g_HttpSoapRequestImpersonationLevel = TokenImpersonationLevel.Impersonation;
                            break;
                        case FrameWorkSecurity.ImpersonationLevel.None:
                            g_HttpSoapRequestImpersonationLevel = TokenImpersonationLevel.None;
                            break;
                    }

                    //Set Authentication Level
                    switch (g_SecurityObject.RequestAuthenticationLevel)
                    {
                        case FrameWorkSecurity.AuthenticationLevel.MutualAuthRequested:
                            g_HttpSoapRequestAuthenticationLevel = AuthenticationLevel.MutualAuthRequested;
                            break;
                        case FrameWorkSecurity.AuthenticationLevel.MutualAuthRequired:
                            g_HttpSoapRequestAuthenticationLevel = AuthenticationLevel.MutualAuthRequired;
                            break;
                        case FrameWorkSecurity.AuthenticationLevel.None:
                            g_HttpSoapRequestAuthenticationLevel = AuthenticationLevel.None;
                            break;
                    }
                }
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Set the general policy for the HTTP SOAP Request Object.
        /// </summary>
        private void SetPolicy()
        {
            try
            {
                //Check if a Policy Object exists
                if (g_PolicyObject != null)
                {
                    //Set Cache policy
                    g_HttpSoapRequestCachePolicy = g_PolicyObject.GetCachePolicy();

                    //Set TimeOut
                    g_HttpSoapRequestTimeout = g_PolicyObject.RequestTimeOut;
                }
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Create the SOAP Request URI String.
        /// </summary>
        /// <returns></returns>
        private string CreateSoapRequestURI()
        {
            string m_RequestURI = string.Empty;

            //Check RemoteHostName
            if (String.IsNullOrEmpty(g_RemoteHostName))
                throw new NullReferenceException("The Remote HostName has not been set. Please set the HostName prior to calling this method.");
            if (g_RemoteHostName.Contains("http://"))
                throw new FormatException("'http://' cannot be included as a part of the RemoteHost name.");
            if (g_RemoteHostName.Contains("\\"))
                throw new FormatException("Invalid character '\' in Remote Host name.");
            if (g_RemoteHostName.Contains("/"))
                throw new FormatException("Invalid character '/' in Remote Host name.");


            //Check WebService URI
            if (String.IsNullOrEmpty(g_WebServiceURI))
                throw new NullReferenceException("The WebService URI has not been set. Please set the URI prior to calling this method.");

            //Check Webmethod name
            if (String.IsNullOrEmpty(g_WebMethodName))
                throw new NullReferenceException("The WebMethod name has not been set. Please set the WebMethod name prior to calling this method.");
            if (g_WebMethodName.Contains("\\"))
                throw new FormatException("Invalid character '\' in WebMethod name.");
            if (g_WebMethodName.Contains("/"))
                throw new FormatException("Invalid character '/' in WebMethod name.");

            //Remove leading and trailing '/' from WebService URI
            if (g_WebServiceURI.Substring(0, 1) == "/")
                g_WebServiceURI = g_WebServiceURI.Substring(1);
            if (g_WebServiceURI.Substring(g_WebServiceURI.Length - 1) == "/")
                g_WebServiceURI = g_WebServiceURI.Substring(0, g_WebServiceURI.Length - 1);
            if (g_WebServiceURI.Substring(g_WebServiceURI.Length - 5).ToLower() != ".asmx")
                throw new FormatException("The WebService URI must end with '.asmx'.");

            //Create the RequestURI string
            m_RequestURI = "http://" + g_RemoteHostName + "/" + g_WebServiceURI + "/" + g_WebMethodName;

            return m_RequestURI;
        }

        /// <summary>
        /// Create the POST request content containing the SOAP Envelope.
        /// </summary>
        /// <returns></returns>
        protected abstract byte[] CreatePostRequestSoapContent();

        #endregion

        #region Properties
        /// <summary>
        /// Gets or Sets the Request Content-Type.
        /// </summary>
        public string RequestContentType
        {
            get { return g_HttpSoapRequestContentType; }

            set { g_HttpSoapRequestContentType = value; }
        }

        /// <summary>
        /// Gets or Sets the Remote hostname where the WebService is hosted.
        /// </summary>
        public string RemoteHostName
        {
            get { return g_RemoteHostName; }

            set { g_RemoteHostName = value; }
        }

        /// <summary>
        /// Gets or Sets the WebService URI.
        /// </summary>
        public string WebServiceURI
        {
            get { return g_WebServiceURI; }

            set { g_WebServiceURI = value.Replace("\\", "/"); }
        }

        /// <summary>
        /// Gets or Sets the Request WebMethod name.
        /// </summary>
        public string WebMethodName
        {
            get { return g_WebMethodName; }

            set { g_WebMethodName = value; }
        }

        /// <summary>
        /// Gets or Sets the Web Service XML NameSpace.
        /// </summary>
        public string WebServiceXMLNameSpace
        {
            get { return g_WebServiceXMLNameSpace; }

            set
            {
                g_WebServiceXMLNameSpace = value.Replace("\\", "/");
                if (g_WebServiceXMLNameSpace.Substring(g_WebServiceXMLNameSpace.Length - 1) == "/")
                    g_WebServiceXMLNameSpace = g_WebServiceXMLNameSpace.Substring(g_WebServiceXMLNameSpace.Length - 2);
            }
        }

        /// <summary>
        /// Gets or Sets the Request Parameter Collection.
        /// </summary>
        public RequestParameter[] RequestParameterCollection
        {
            get { return g_HttpSoapRequestParameterCollection; }
            set { g_HttpSoapRequestParameterCollection = value; }
        }

        /// <summary>
        /// Gets or Sets the Request Security object.
        /// </summary>
        public FrameWorkSecurity RequestSecurity
        {
            get { return g_SecurityObject; }
            set { g_SecurityObject = value; }
        }

        /// <summary>
        /// Gets or Sets the Request Policy object.
        /// </summary>
        public FrameWorkPolicy RequestPolicy
        {
            get { return g_PolicyObject; }
            set { g_PolicyObject = value; }
        }

        /// <summary>
        /// Gets the Response Data for the WebService HTTP SOAP Request.
        /// </summary>
        public string HttpSoapResponseData
        {
            get { return g_HttpSoapResponseString; }
        }

        /// <summary>
        /// Gets the length of the Response Data.
        /// </summary>
        public long HttpSoapResponseContentLength
        {
            get { return g_HttpSoapResponseContentLength; }
        }

        /// <summary>
        /// Gets the Content Type of the Response Data.
        /// </summary>
        public string HttpSoapResponseContentType
        {
            get { return g_HttpSoapResponseContentType; }
        }

        /// <summary>
        /// Indicates if the Response Data has been fetched from the cache.
        /// </summary>
        public bool HttpSoapResponseIsFromCache
        {
            get { return g_HttpSoapResponseIsFromCache; }
        }

        /// <summary>
        /// Indicates if the communication has been Mutually Authenticated.
        /// </summary>
        public bool HttpSoapResponseIsMutuallyAuthenticated
        {
            get { return g_HttpSoapResponseIsMutuallyAuthenticated; }
        }

        /// <summary>
        /// Gets the actual URI which responded to the WebService HTTP SOAP Request.
        /// </summary>
        public Uri HttpSoapResponseActualURI
        {
            get { return g_HttpSoapResponseActualURI; }
        }

        /// <summary>
        /// Gets the header of the Response for the WebService HTTP SOAP Request.
        /// </summary>
        public WebHeaderCollection HttpSoapResponseHeader
        {
            get { return g_HttpSoapResponseHeader; }
        }

        /// <summary>
        /// Gets the actual HTTP SOAP Request string to access the Web Service.
        /// </summary>
        public string HttpSoapRequestString
        {
            get
            {
                try
                {
                    return CreateSoapRequestURI();
                }
                catch (Exception)
                {
                    throw;
                }
            }
        }

        /// <summary>
        /// Gets the HTTP SOAP Request content.
        /// </summary>
        public byte[] HttpSoapRequestContent
        {
            get
            {
                try
                {
                    return CreatePostRequestSoapContent();
                }
                catch (Exception)
                {
                    throw;
                }
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\LiveCacheEmulator\AchievementDataAccessEmulator.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Leet.Live.Livecache.DataAccess;
using Leet.Live.Livecache.Logic.Achievements;
using Leet.Live.Livecache.Logic.Games;
namespace Test.Common.LiveCacheEmulator
{
	public class AchievementDataAccessEmulator : IAchievementDataAccess
	{
		public List<IReadOnlyAchievementInfo> GetUserAchievements(uint gameTitleId, ulong callingUserPuid, ulong targetUserPuid, ushort localeId)
		{
			List<IReadOnlyAchievementInfo> validAchievements = new List<IReadOnlyAchievementInfo>();
            List<Achievement> allAchievementsList = LiveCacheEmulator.GetDataFromXuidWithSecurity((long)callingUserPuid, (long)targetUserPuid).Achievements;
			List<IReadOnlyAchievementInfo> allAchievements = new List<IReadOnlyAchievementInfo>();
			foreach (Achievement ach in allAchievementsList)
			{
				allAchievements.Add((IReadOnlyAchievementInfo)ach);
			}
			foreach (IReadOnlyAchievementInfo achievement in allAchievements)
			{
				if (((Achievement)achievement).TitleID == gameTitleId)
				{
					validAchievements.Add(achievement);
				}
			}
			return validAchievements;
		}

        
        public List<IReadOnlyUserTitle> GetUserTitles(ulong callingUserPuid, ulong targetUserPuid, ushort localeId, 
            ushort startingIndex, ushort maxTitles)
        {

            List<Title> titles = LiveCacheEmulator.GetDataFromXuidWithSecurity((long)callingUserPuid, (long)targetUserPuid).Titles;
            List<IReadOnlyUserTitle> roTitles = new List<IReadOnlyUserTitle>();
            
            for (ushort i = startingIndex; i < maxTitles && i < titles.Count; i++)
            {
                roTitles.Add(titles[i]);
            }
            
            return roTitles;

        }

        
        public List<IReadOnlyUserTitle> GetPublicUserTitles(ulong targetUserPuid, ushort localeId, 
            ushort startingIndex, ushort maxTitles, out DateTime responseTTL)
        {

            List<Title> titles = LiveCacheEmulator.GetDataFromXuid((long)targetUserPuid).Titles;
            List<IReadOnlyUserTitle> roTitles = new List<IReadOnlyUserTitle>();
            
            for(ushort i = startingIndex; i < maxTitles && i < titles.Count; i++)
            {
                roTitles.Add(titles[i]);
            }
            responseTTL = new DateTime();
            return roTitles;
        }

        public void SyncAchievements(uint gameTitleId, ulong targetUserPuid, ushort localeId, IList<IReadOnlyAchievementInfo> readOnlyAchievementInfos)
        {
            throw new NotImplementedException();
            // Update achievements here
        }

        public void SyncTitles(uint gameTitleId, ulong targetUserPuid, ushort localeId, DateTime lastPlayedTime)
        {
            throw new NotImplementedException();
            // Update last played time here
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\LiveCacheEmulator\LiveCacheData.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Leet.Live.Livecache.Logic.Profile;
using Leet.Live.Livecache.Logic.Achievements;
using Leet.Live.Livecache.Logic.Avatars;
using Leet.Live.Livecache.Logic.Games;
using Leet.Live.Livecache;

namespace Test.Common.LiveCacheEmulator
{
	public class LiveCacheData : IGamerProfile, IReadOnlyPresenceInfo
	{
		#region IGamerProfile members
		public ulong LivePuid { get; set; }
		public string GamerTag { get; set; }
		public string Bio { get; set; }
		public string Name { get; set; }
		public string Location { get; set; }
		public int Gamerscore { get; set; }
		public string Motto { get; set; }
		public bool HasAcceptedTOU { get; set; }
		public int Country { get; set; }
		public float Reputation { get; set; }
		public int ReputationBucket { get; set; }
		public string GamerTileUrl { get; set; }
        public string SecureGamerTileUrl { get; set; }
        public string SmallGamerTileUrl { get; set; }
        public string SecureSmallGamerTileUrl { get; set; }
		public string GamerTileId { get; set; }
		public GamercardZone Zone { get; set; }
		public GamerTier Tier { get; set; }
        public byte[] AvatarManifest { get; set; }
		public bool IsLaunchTeamMember { get; set; }
		public bool IsCheater { get; set; }
		public bool IsNXELaunchTeamMember { get; set; }
        public int ProfilePermissions { get; set; }
        public PrivilegeValue ProfileActivityPrivilege { get; set; }
        public PrivilegeValue ProfileUserCreatedContentPrivilege { get; set; }
        public PrivilegeValue PlayedMusicSharingPrivilege { get; set; }
        public PrivilegeValue ProfileViewingPrivilege { get; set; }
        public AvatarBodyType AvatarBodyType { get; set; }
        public string GamerTile { get; set; }
        public string BlogUrl { get; set; }
        public GamerTypeFlags GamerType { get; set; }
		#endregion

		#region IReadOnlyPresenceInfo members
		public string Gamertag { get;set; }
		public OnlineState State { get;set; }
		public bool IsOnline { get;set; }
		public bool IsJoinable { get;set; }
		public bool IsPlaying { get;set; }
		public DateTime LastSeen { get;set; }
		public uint TitleId { get;set; }
		public string PresenceString { get;set; }
		#endregion

		public uint[] Priveleges { get; set; }
		public DateTime LastWebActivity { get; set; }
		public byte ParentalControlGroup { get; set; }
		public bool IsLightAccount { get; set; }
		public bool IsProvisioned { get; set; }
        public byte AccountType { get; set; }

		public long WLIDPuid { get; set; }

		public ProfileSecurity Security { get; set; }

		public List<Achievement> Achievements { get; set; }
		public List<FriendInfo> Friends { get; set; }
        public List<Title> Titles { get; set; }
    }

    public class Title : IReadOnlyUserTitle
    {
        #region IReadOnlyUserTitle Members

        public DateTime LastPlayed { get; set; }
        public ushort EarnedAchievements { get; set; }
        public uint EarnedGamerscore { get; set; }
        public uint Reserved { get; set; }
        public uint Sequence { get; set; }
        public uint TitleId { get; set; }
        public string TitleName { get; set; }
        public ushort TotalAchievements { get; set; }
        public uint TotalGamerscore { get; set; }

        #endregion
    }

	public class Achievement : IReadOnlyAchievementInfo
	{
		public DateTime DateUnlocked { get; set; }
		public uint AchievementId { get; set; }
		public int GamerscoreValue { get; set; }
		public string Description { get; set; }
		public int Flags { get; set; }
		public uint ImageId { get; set; }
		public Uri ImageHref { get { return new Uri(strImageHref); } }
		public string strImageHref { get; set; }
		public Uri SecureImageHref { get { return new Uri(strSecureImageHref); } }
		public string strSecureImageHref { get; set; }
		public string Title { get; set; }
		public byte Type { get; set; }
		public bool IsHidden { get; set; }
        public bool IsUnlocked { get; set; }
		public bool WasEarnedOnline { get; set; }
        public bool WasEarnedOffline { get; set; }
		public uint TitleID { get; set; }
	}

	public class FriendInfo : IReadOnlyFriendInfo
	{
		public string Gamertag { get; set; }
		public ulong LivePuid { get; set; }
		public FriendState FriendState { get; set; }
		public OnlineState State { get; set; }
		public bool IsOnline { get; set; }
		public bool IsJoinable { get; set; }
		public bool IsPlaying { get; set; }
		public DateTime LastSeen { get; set; }
		public uint TitleId { get; set; }
		public string PresenceString { get; set; }
	}

	public enum ProfileSecurity
	{
		Public = 0,
		FriendsOnly,
		Private
	};
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\LiveCacheEmulator\SettingsDataAccessEmulator.cs ===
﻿using System;
using System.Collections.ObjectModel;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Leet.Live.Livecache.DataAccess;
using Leet.Live.Livecache.Logic.Profile;
using xonline.common.protocol;

namespace Test.Common.LiveCacheEmulator
{
	public class SettingsDataAccessEmulator : ISettingsDataAccess
	{
        public IGamerProfile GetGamerProfile(string gamertag, ulong callingLivepuid, ulong targetLivepuid)
        {
            return LiveCacheEmulator.GetDataFromXuidWithSecurity((long)callingLivepuid, (long)targetLivepuid);
        }
		public IGamerProfile GetGamerProfile(ulong callingLivepuid, ulong targetLivepuid)
		{
			return LiveCacheEmulator.GetDataFromXuidWithSecurity((long)callingLivepuid, (long)targetLivepuid);
		}
		public IGamerProfile GetPublicGamerProfile(ulong targetLivepuid)
		{
			return LiveCacheEmulator.GetDataFromXuid((long)targetLivepuid);
		}
        public IGamerProfile GetPublicGamerProfile(string gamertag, ulong targetLivepuid)
        {
            return LiveCacheEmulator.GetDataFromXuid((long)targetLivepuid);
        }

        public void LoadSettings(ReadSettingsResponse readResp, IGamerProfile profile, IWebPreferences webPreferences)
        {
            throw new NotImplementedException();
        }

        public IGamerProfile[] LoadSettings(ReadSettingsResponse readResp)
        {
            throw new NotImplementedException();
        }

        public ReadSettingsResponse[] ReadProfileSettings(ulong callingLivepuid, ulong[] targetLivepuids, uint[] settings)
        {
            throw new NotImplementedException();
        }

        public IGamerProfile[] GetGamerProfilesBySetting(ulong callingLivepuid, ulong[] targetLivepuids, uint[] settings, bool getGamertag)
        {
            throw new NotImplementedException();
        }

        public Dictionary<ulong, IGamerProfile> GetGamerProfileCollectionBySetting(ulong callingLivepuid, ulong[] targetLivepuids, uint[] settings, bool getGamertag)
        {
            throw new NotImplementedException();
        }
                
        public SaveSettingsResponse SyncSettings(ulong callingLivepuid, ProfileSetting[] settings)
        {
            throw new NotImplementedException();
        }

        public ReadOnlyCollection<AwardedAvatarAsset> GetUserAvatarAwards(ulong livePuid, ushort localeId, uint titleID)
        {
            throw new NotImplementedException();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\LiveCacheEmulator\PresenceDataAccessEmulator.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Leet.Live.Livecache.DataAccess;
using Leet.Live.Livecache.Logic.Profile;
using xonline.common.protocol;
using Leet.Live.Livecache.Logic.Messaging;

namespace Test.Common.LiveCacheEmulator
{
	public class PresenceDataAccessEmulator : IPresenceDataAccess
	{
		public void SendWebAlive(ulong livePuid)
		{
			//Nothing to do here.
		}

		public IReadOnlyPresenceInfo GetPresenceInfo(ulong senderLivePuid, ulong targetLivePuid)
		{
			return LiveCacheEmulator.GetDataFromXuidWithSecurity((long)senderLivePuid, (long)targetLivePuid);
		}
		public IReadOnlyPresenceInfo GetPublicPresenceInfo(ulong targetLivepuid, out DateTime responseTTL)
		{
			responseTTL = DateTime.Now.AddSeconds(30);
			return LiveCacheEmulator.GetDataFromXuid((long)targetLivepuid);
		}

		public QueryAffiliatesReplyData[] GetQueryAffiliatesReplyData(ulong callingLivepuid, ushort maxCount)
		{
			throw new NotImplementedException();
		}

		public IReadOnlyFriendInfo[] GetFriendsInfo(ulong callerLivepuid, bool sortAlphabetically, bool includeProfileData)
		{
			return LiveCacheEmulator.GetDataFromXuid((long)callerLivepuid).Friends.ToArray();
		}
		public void AddFriend(ulong userPuid, ulong targetPuid)
		{
			LiveCacheData target = LiveCacheEmulator.GetDataFromXuid((long)targetPuid);
			LiveCacheData friend = LiveCacheEmulator.GetDataFromXuid((long)userPuid);

			FriendInfo friendForTarget = LoadFriend(friend);
			friendForTarget.FriendState = FriendState.Requesting;
			target.Friends.Add(friendForTarget);

			FriendInfo friendForCaller = LoadFriend(target);
			friendForCaller.FriendState = FriendState.Pending;
			friend.Friends.Add(friendForCaller);

			LiveCacheEmulator.SaveData(target, ((long)target.LivePuid).ToString());
			LiveCacheEmulator.SaveData(friend, ((long)target.LivePuid).ToString());
		}
		public void AddFriendFromContact(ulong userPuid, ulong targetPuid)
		{
			AddFriend(userPuid, targetPuid);
		}
		public void DeleteFriend(ulong userPuid, ulong targetPuid)
		{
			LiveCacheData target = LiveCacheEmulator.GetDataFromXuid((long)targetPuid);
			LiveCacheData friend = LiveCacheEmulator.GetDataFromXuid((long)userPuid);

			target.Friends.Remove(LoadFriend(friend));
			friend.Friends.Remove(LoadFriend(target));

			LiveCacheEmulator.SaveData(target, ((long)target.LivePuid).ToString());
			LiveCacheEmulator.SaveData(friend, ((long)friend.LivePuid).ToString());
		}
		public void AcceptFriendRequest(ulong userPuid, ulong targetPuid)
		{
			LiveCacheData target = LiveCacheEmulator.GetDataFromXuid((long)targetPuid);
			LiveCacheData friend = LiveCacheEmulator.GetDataFromXuid((long)userPuid);
			foreach (IReadOnlyFriendInfo targetFriend in target.Friends)
			{
				if (targetFriend.LivePuid == friend.LivePuid)
				{
					((FriendInfo)targetFriend).FriendState = FriendState.Friend;
				}
			}
			foreach (IReadOnlyFriendInfo friendFriend in friend.Friends)
			{
				if (friendFriend.LivePuid == target.LivePuid)
				{
					((FriendInfo)friendFriend).FriendState = FriendState.Friend;
				}
			}
			LiveCacheEmulator.SaveData(target, ((long)target.LivePuid).ToString());
			LiveCacheEmulator.SaveData(friend, ((long)friend.LivePuid).ToString());
		}
		public void RejectFriendRequest(ulong userPuid, ulong targetPuid)
		{
			LiveCacheData target = LiveCacheEmulator.GetDataFromXuid((long)targetPuid);
			LiveCacheData friend = LiveCacheEmulator.GetDataFromXuid((long)userPuid);
			foreach (IReadOnlyFriendInfo targetFriend in target.Friends)
			{
				if (targetFriend.LivePuid == friend.LivePuid)
				{
					((FriendInfo)targetFriend).FriendState = FriendState.NotAFriend;
				}
			}
			foreach (IReadOnlyFriendInfo friendFriend in friend.Friends)
			{
				if (friendFriend.LivePuid == target.LivePuid)
				{
					((FriendInfo)friendFriend).FriendState = FriendState.NotAFriend;
				}
			}
			LiveCacheEmulator.SaveData(target, ((long)target.LivePuid).ToString());
			LiveCacheEmulator.SaveData(friend, ((long)friend.LivePuid).ToString());
		}

		public MessageSummary2[] EnumerateMessages(ulong userPuid)
		{
			throw new NotImplementedException();
		}
		public MessageSummary2 GetMessageSummary(ulong userPuid, uint messageId)
		{
			throw new NotImplementedException();
		}
		public bool DeleteMessage(ulong userPuid, uint messageId, uint flags)
		{
			throw new NotImplementedException();
		}
		public bool SetMessageFlags(ulong userPuid, uint messageId, uint setFlags, uint unsetFlags)
		{
			throw new NotImplementedException();
		}
		public void SendMessage(ulong userPuid, string szSenderName, ulong qwSenderContext, uint dwMessageFlags,
			ushort wExpireMinutes, byte bMessageType, ulong[] rgqwRecipients, MessageDetails details)
		{
			throw new NotImplementedException();
		}
		public SystemMessageSummary[] EnumerateSystemMessages(ulong userPuid, uint titleId)
		{
			throw new NotImplementedException();
		}

		FriendInfo LoadFriend(LiveCacheData source)
		{
			FriendInfo friend = new FriendInfo();
			friend.Gamertag = source.Gamertag;
			friend.IsJoinable = source.IsJoinable;
			friend.IsOnline = source.IsOnline;
			friend.IsPlaying = source.IsPlaying;
			friend.LastSeen = source.LastSeen;
			friend.LivePuid = source.LivePuid;
			friend.PresenceString = source.PresenceString;
			friend.State = source.State;
			friend.TitleId = source.TitleId;
			return friend;
		}

        public IReadOnlyFriendInfo[] GetFriendsOfFriend(ulong sender, ulong target)
        {
            throw new NotImplementedException();
        }

        public IReadOnlySystemMessage GetSystemMessageDetails(ulong userPuid, uint titleId, uint messageId)
        {
            throw new NotImplementedException();
        }

        public IReadOnlyMessage GetMessageDetails(ulong userPuid, uint messageId, uint setFlags, uint unsetFlags)
        {
            throw new NotImplementedException();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\LiveCacheEmulator\XCacheDataAccessEmulator.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Leet.Live.Livecache.DataAccess;

namespace Test.Common.LiveCacheEmulator
{
	public class XCacheDataAccessEmulator : IXCacheDataAccess
	{
		public bool GetGamertagByPuid(ulong livePuid, out string gamertag)
		{
			LiveCacheData data = LiveCacheEmulator.GetDataFromXuid((long)livePuid);
			gamertag = data.Gamertag;
			return (data.LivePuid > 0);
		}
		public bool GetOfficialGamerTag(string gamertag, out ulong livePuid, out string officialGamertag)
		{
			LiveCacheData data = LiveCacheEmulator.GetDataFromGamertag(gamertag);
			livePuid = data.LivePuid;
			officialGamertag = data.GamerTag;
			return (data.LivePuid > 0);
		}
		public bool GetPuidByGamerTag(string gamertag, out ulong livePuid)
		{
			LiveCacheData data = LiveCacheEmulator.GetDataFromGamertag(gamertag);
			livePuid = data.LivePuid;
			return (data.LivePuid > 0);
		}
		public bool LookupWebID(ulong passportPuid, out ulong livePuid, out string gamertag)
		{
			LiveCacheData data = LiveCacheEmulator.GetDataFromPuid((long)passportPuid);
			livePuid = data.LivePuid;
			gamertag = data.Gamertag;
			return (data.LivePuid > 0);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\LivenMobileGadget\LivenGadget\LivenGadget\Game1.cs ===
using System;
using System.IO;
using System.Net;
using System.Xml;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;

#if WINDOWS_PHONE
using Microsoft.Xna.Framework.Input.Touch;
#endif

namespace LivenGadget
{
    /// <summary>
    /// This is the main type for your game
    /// </summary>
    public class Game1 : Microsoft.Xna.Framework.Game
    {
        GraphicsDeviceManager graphics;
        SpriteBatch spriteBatch;
        SiteStatus sitestatus;
        SpriteFont statusfont;
        string lastmessage = "";
        string lastenv = "";
        string lastservice = "";
        DateTime lastupdate = DateTime.Now;
        Texture2D Dot;
        Texture2D logo;



        bool detailview = false;
        bool pressed = false;
        int width = 70;
        int widthoffset = 100;
        int height = 60;
        int heightoffset = 100;

#if WINDOWS_PHONE
        TouchCollection touchCollection;
#endif

        public Game1()
        {
            graphics = new GraphicsDeviceManager(this);
            Content.RootDirectory = "Content";
        }

        /// <summary>
        /// Allows the game to perform any initialization it needs to before starting to run.
        /// This is where it can query for any required services and load any non-graphic
        /// related content.  Calling base.Initialize will enumerate through any components
        /// and initialize them as well.
        /// </summary>
        protected override void Initialize()
        {
            // TODO: Add your initialization logic here
            //create 1x1 texture
            Color[] colorArray = new Color[1];
            colorArray[0] = Color.White;
            Dot = new Texture2D(graphics.GraphicsDevice, 1, 1);
            Dot.SetData(colorArray);
#if WINDOWS
            this.IsMouseVisible = true;
#endif
            base.Initialize();
        }

        /// <summary>
        /// LoadContent will be called once per game and is the place to load
        /// all of your content.
        /// </summary>
        protected override void LoadContent()
        {
            // Create a new SpriteBatch, which can be used to draw textures.
            spriteBatch = new SpriteBatch(GraphicsDevice);
            Getupdate();
            statusfont = Content.Load<SpriteFont>("SpriteFont1");
            logo = Content.Load<Texture2D>("logo_liveengagement_h_lrg");
        }

        private void Getupdate()
        {
            Uri u = new Uri("http://dl.dropbox.com/u/2604247/SiteStatus.xml");
            WebClient client = new WebClient();
            client.OpenReadCompleted += wc_OpenReadCompleted;
            client.OpenReadAsync(u);
        }

        

        private void wc_OpenReadCompleted(object sender, OpenReadCompletedEventArgs e)
        {

            if (e.Error == null)
            {
                Stream stream = e.Result;
                SiteStatus tempsitestatus =null;
                XmlReader reader = XmlReader.Create(stream);
                string imageName = String.Empty;
                string areaName = String.Empty;
                string fileName = String.Empty;
                while (reader.Read())
                {
                    if (reader.NodeType == XmlNodeType.Element)
                    {
                        if (reader.Name == "SiteList")
                        {
                            reader.MoveToFirstAttribute();
                            tempsitestatus = new SiteStatus(reader);
                            
                        }
                    }
                }
                lastupdate = DateTime.Now;
                lastmessage = "";
                lastenv = "";
                lastservice = "";
                detailview = false;
                sitestatus = tempsitestatus;
            }
        }


        /// <summary>
        /// UnloadContent will be called once per game and is the place to unload
        /// all content.
        /// </summary>
        protected override void UnloadContent()
        {
            // TODO: Unload any non ContentManager content here
        }

        /// <summary>
        /// Allows the game to run logic such as updating the world,
        /// checking for collisions, gathering input, and playing audio.
        /// </summary>
        /// <param name="gameTime">Provides a snapshot of timing values.</param>
        protected override void Update(GameTime gameTime)
        {
            Vector2 p=new Vector2();
            
            // Allows the game to exit
            if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed)
                this.Exit();

            if(DateTime.Now>lastupdate+TimeSpan.FromMinutes(2))
                Getupdate();

#if WINDOWS_PHONE
            touchCollection = TouchPanel.GetState();
            if (touchCollection.Count > 0)
            {
                if (pressed == false)
                {

                    p = touchCollection[0].Position;
                    detailview = !detailview;
                }
                pressed = true;
            }
            else
                pressed = false;
        
            
#endif

#if WINDOWS
            if (Mouse.GetState().LeftButton == ButtonState.Pressed)
            {
                if (pressed == false)
                {
                    p = new Vector2(Mouse.GetState().X, Mouse.GetState().Y);
                    detailview = !detailview;
                }
                pressed = true;
            }
            else
                pressed = false;
#endif

            if(p.X!=0&&p.Y!=0)
            {
                bool updated=false;
                lastservice = "";
                lastmessage = "";
                lastenv = "";
                {
                    if (sitestatus != null)
                    {
                        int envcount = sitestatus.Enviroments.Count;
                        int servicescount = sitestatus.Enviroments[0].SiteServices.Count;

                        for (int i = 0; i < envcount; i++)
                            for (int j = 0; j < servicescount; j++)
                            {

                                if (pointinrectangle(p, new Rectangle(j * width + widthoffset - (widthoffset / 4), i * height + heightoffset - (heightoffset / 4), width - 1, height - 1)))
                                {
                                    updated = true;
                                    lastmessage = sitestatus.Enviroments[i].SiteServices[j].ClientMessage;
                                    lastenv = sitestatus.Enviroments[i].SiteName;
                                    lastservice = sitestatus.Enviroments[i].SiteServices[j].ServiceName;
                                }

                            }
                    }
                    if (!updated)
                        detailview = false;
                }
            }


            base.Update(gameTime);
        }

        private bool pointinrectangle(Vector2 p, Rectangle r)
        {
            if (p.X > r.Left && p.X < r.Right && p.Y > r.Top && p.Y < r.Bottom)
                return true;

            return false;
        }

        /// <summary>
        /// This is called when the game should draw itself.
        /// </summary>
        /// <param name="gameTime">Provides a snapshot of timing values.</param>
        protected override void Draw(GameTime gameTime)
        {
            GraphicsDevice.Clear(Color.Black);

            //Draw sitelist....
            spriteBatch.Begin();

            spriteBatch.Draw(logo, new Rectangle(25, 50, 750, 396), new Color(50, 50, 50, 2));
            if (sitestatus != null)
            {
                int envcount = sitestatus.Enviroments.Count;
                int servicescount = sitestatus.Enviroments[0].SiteServices.Count;

                if (detailview == false)
                {

                    string updatelabel = "Last Update: " + sitestatus.LastUpdated;
                    spriteBatch.DrawString(statusfont, updatelabel, new Vector2(400, 25), Color.White);

                    for (int i = 0; i < envcount; i++)
                    {
                        spriteBatch.DrawString(statusfont, sitestatus.Enviroments[i].SiteName, new Vector2(25, i * height + heightoffset), Color.White);
                    }

                    for (int j = 0; j < servicescount; j++)
                    {
                        spriteBatch.DrawString(statusfont, sitestatus.Enviroments[0].SiteServices[j].ShortServiceName, new Vector2(j * width + widthoffset - (widthoffset / 4), 50), Color.White);

                    }

                    for (int i = 0; i < envcount; i++)
                        for (int j = 0; j < servicescount; j++)
                        {

                            if (sitestatus.Enviroments[i].SiteServices[j].Status > 0)
                                spriteBatch.Draw(Dot, new Rectangle(j * width + widthoffset - (widthoffset / 4), i * height + heightoffset - (heightoffset / 4), width - 1, height - 1), new Color(0, (int)(100 / 15 * (sitestatus.Enviroments[i].SiteServices[j].Status + 1)) * Color.Green.G / 100, 0,160));
                            else if (sitestatus.Enviroments[i].SiteServices[j].Status < 0)
                                spriteBatch.Draw(Dot, new Rectangle(j * width + widthoffset - (widthoffset / 4), i * height + heightoffset - (heightoffset / 4), width - 1, height - 1), new Color((int)(100 / 15 * (-sitestatus.Enviroments[i].SiteServices[j].Status + 1)) * Color.Red.R / 100, 0, 0,160));
                            else
                                spriteBatch.Draw(Dot, new Rectangle(j * width + widthoffset - (widthoffset / 4), i * height + heightoffset - (heightoffset / 4), width - 1, height - 1), new Color(0, 0, 0, 160));
                            spriteBatch.DrawString(statusfont, sitestatus.Enviroments[i].SiteServices[j].LastAttempt, new Vector2(j * width + widthoffset, i * height + heightoffset), Color.White);

                        }
                }
                else
                {
                    spriteBatch.DrawString(statusfont, lastenv, new Vector2(25, heightoffset/2), Color.White);
                    spriteBatch.DrawString(statusfont, lastservice, new Vector2(25+200, heightoffset/2), Color.White);
                    spriteBatch.DrawString(statusfont, lastmessage, new Vector2(25,  heightoffset), Color.White);
                }
            }
            else
            {
                spriteBatch.DrawString(statusfont, "Updating Sitestatus", new Vector2(200, 200), Color.White);
            }
            spriteBatch.End();

            base.Draw(gameTime);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\LiveCacheEmulator\LiveCacheEmulator.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Test.Identity.Common;
using System.Web;
using System.IO;
using System.Reflection;

namespace Test.Common.LiveCacheEmulator
{
    public class LiveCacheEmulator : BaseEmulator
    {
        public static LiveCacheData GetDataFromXuid(long xuid)
        {
            LiveCacheData data = new LiveCacheData();

            string pattern = String.Format("LiveCache_{0}.xml", xuid.ToString());
            string[] filenames = GetFiles(pattern);

            foreach (string filename in filenames)
            {
                return (LiveCacheData)LoadData(typeof(LiveCacheData), filename);
            }
            return data;
        }

        public static LiveCacheData GetDataFromXuidWithSecurity(long callingPuid, long targetPuid)
        {
            LiveCacheData data = new LiveCacheData();

            string pattern = String.Format("LiveCache_{0}.xml", targetPuid.ToString());
            string[] filenames = GetFiles(pattern);

            foreach (string filename in filenames)
            {
                LiveCacheData fromFile = (LiveCacheData)LoadData(typeof(LiveCacheData), filename);
                switch (fromFile.Security)
                {
                    case ProfileSecurity.Private:
                        if (callingPuid == targetPuid)
                        {
                            return fromFile;
                        }
                        break;
                    case ProfileSecurity.Public:
                        return fromFile;
                    case ProfileSecurity.FriendsOnly:
                        if (callingPuid == targetPuid)
                        {
                            return fromFile;
                        }
                        else
                        {
                            foreach (FriendInfo friend in fromFile.Friends)
                            {
                                if (callingPuid == (long)friend.LivePuid)
                                {
                                    return fromFile;
                                }
                            }
                        }
                        break;
                }
            }
            return data;
        }

        public static LiveCacheData GetDataFromPuid(long puid)
        {
            foreach (LiveCacheData data in GetAllUsers())
            {
                if (data.WLIDPuid == puid)
                {
                    return data;
                }
            }
            return new LiveCacheData();
        }

        public static LiveCacheData GetDataFromGamertag(string gamertag)
        {
            foreach (LiveCacheData data in GetAllUsers())
            {
                if (data.Gamertag == gamertag)
                {
                    return data;
                }
            }
            return new LiveCacheData();
        }

        public static LiveCacheData GetDataFromOfficialGamerTag(string gamerTag)
        {
            foreach (LiveCacheData data in GetAllUsers())
            {
                if (data.GamerTag == gamerTag)
                {
                    return data;
                }
            }
            return new LiveCacheData();
        }

        static List<LiveCacheData> GetAllUsers()
        {
            List<LiveCacheData> data = new List<LiveCacheData>();

            string pattern = "LiveCache_*.xml";
            string[] filenames = GetFiles(pattern);

            foreach (string filename in filenames)
            {
                data.Add((LiveCacheData)LoadData(typeof(LiveCacheData), filename));
            }

            return data;
        }

        static string[] GetFiles(string pattern)
        {
            string filePath;
            if (HttpContext.Current != null)
            {
                filePath = HttpContext.Current.Server.MapPath("~/EmulatorXML/");
            }
            else
            {
                filePath = (Path.GetDirectoryName(Assembly.GetExecutingAssembly().GetName().CodeBase) + @"\EmulatorXML\").Substring("file:/".Length);
            }

            string[] filenames = Directory.GetFiles(filePath, pattern);
            return filenames;
        }

        static object LoadData(Type TypeOfObject, string XMLFileName)
        {
            LiveCacheEmulator obj = new LiveCacheEmulator();
            return obj.LoadState(TypeOfObject, XMLFileName);
        }

        public static void SaveData(object data, string puid)
        {
            string filePath = (HttpContext.Current != null ? HttpContext.Current.Server.MapPath("~/EmulatorXML/") : (Path.GetDirectoryName(Assembly.GetExecutingAssembly().GetName().CodeBase) + @"\EmulatorXML\").Substring("file:/".Length));

            LiveCacheEmulator obj = new LiveCacheEmulator();
            obj.SaveState(filePath + "LiveCache_" + puid + ".xml", data);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\LivenMobileGadget\LivenGadget\LivenGadget\Program.cs ===
using System;

namespace LivenGadget
{
#if WINDOWS || XBOX
    static class Program
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        static void Main(string[] args)
        {
            using (Game1 game = new Game1())
            {
                game.Run();
            }
        }
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\LiveCacheEmulator\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("LiveCacheEmulator")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("ad765b8c-fd1b-40b2-ac86-9b0babf6ed06")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\LivenMobileGadget\LivenGadget\LivenGadget\SiteStatus.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml;
using System.IO;

namespace LivenGadget
{
    class SiteStatus
    {
        private string _currentversion;

        public string CurrentVersion
        {
            get { return _currentversion; }
        }

        private string _currentversionurl;

        public string CurrentVersionURL
        {
            get { return _currentversionurl; }
        }


        private string _lastupdated;
        public string LastUpdated
        {
            get { return _lastupdated; }
        }

        private string _newlocation;

        public string NewLocation
        {
            get { return _newlocation; }
        }

        private int _updateinterval;

        public int UpdateInterval
        {
            get { return _updateinterval; }
        }


        private List<Enviroment> _enviroments;
        public List<Enviroment> Enviroments
        {
            get { return _enviroments; }
        }


        public SiteStatus(XmlReader reader)
        {
            _enviroments = new List<Enviroment>();
            reader.Read();
            while (reader.NodeType!=XmlNodeType.EndElement)
            {
                //
                if (reader.NodeType == XmlNodeType.Element)
                {
                    
                    string name = reader.Name;
                    if (string.Compare(name, "CurrentVersion") == 0)
                    {
                        _currentversion = reader.ReadElementContentAsString();
                        name = reader.Name;
                    }

                    if (string.Compare(name, "CurrentVersionUrl") == 0)
                    {
                        _currentversionurl = reader.ReadElementContentAsString();
                        name = reader.Name;
                    }
                    
                    if (string.Compare(name, "LastUpdated") == 0)
                    {
                        _lastupdated = reader.ReadElementContentAsString();
                        name = reader.Name;
                    }
                    
                    if (string.Compare(name, "NewLocation") == 0)
                    {
                        _newlocation = reader.ReadElementContentAsString();
                        name = reader.Name;
                    }
                    
                    if (string.Compare(name, "UpdateInterval") == 0)
                    {
                        _updateinterval = reader.ReadElementContentAsInt();
                        name = reader.Name;
                    }

                    if (string.Compare(name, "Site") == 0)
                    {
                        _enviroments.Add(new Enviroment(reader));
                    }
                }
            }
            reader.Read();
        }
    }
    public class Enviroment
    {
        
        private string _sitename;

        public string SiteName
        {
            get { return _sitename; }
        }

        private List<SiteService> _siteservices;
        public List<SiteService> SiteServices
        {
            get { return _siteservices; }
        }


        public Enviroment(XmlReader reader)
        {
            _siteservices = new List<SiteService>();
            reader.Read();

            
            while (reader.NodeType != XmlNodeType.EndElement)
            {
                string name = reader.Name;

                if (string.Compare(name, "SiteName") == 0)
                {
                    _sitename = reader.ReadElementContentAsString();
                    name = reader.Name;
                }

                if (string.Compare(name, "Service") == 0)
                {
                    _siteservices.Add(new SiteService(reader));
                }
            }
            reader.Read();
        }
    }

    public class SiteService
    {
        private string _servicename;
        public string ServiceName
        {
            get { return _servicename; }
            set { _servicename = value; }
        }

        private string _shortservicename;
        public string ShortServiceName
        {
            get { return _shortservicename; }
            set { _shortservicename = value; }
        }

        private string _clientmessage;
        public string ClientMessage
        {
            get { return _clientmessage; }
            set { _clientmessage = value; }
        }

        private int _status;
        public int Status
        {
            get { return _status; }
            set { _status = value; }
        }

        private string _lastattempt;
        public string LastAttempt
        {
            get { return _lastattempt; }
            set { _lastattempt = value; }
        }



        public SiteService(XmlReader reader)
        {
            reader.Read();
            while (reader.NodeType != XmlNodeType.EndElement)
            {
                string name = reader.Name;

                if (string.Compare(reader.Name, "ServiceName") == 0)
                {
                    _servicename = reader.ReadElementContentAsString();
                    name = reader.Name;
                }

                if (string.Compare(reader.Name, "ShortServiceName") == 0)
                {
                    _shortservicename = reader.ReadElementContentAsString();
                    name = reader.Name;
                }

                if (string.Compare(reader.Name, "ClientMessage") == 0)
                {
                    _clientmessage = reader.ReadElementContentAsString();
                    name = reader.Name;
                }

                if (string.Compare(reader.Name, "Status") == 0)
                {
                    _status = reader.ReadElementContentAsInt();
                    name = reader.Name;
                }

                if (string.Compare(reader.Name, "LastAttempt") == 0)
                {
                    _lastattempt = reader.ReadElementContentAsString();
                    name = reader.Name;
                }
            }
            reader.Read();
        }
    }



}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OfferLib\File.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml.Serialization;

namespace LiveN.Test.Offers
{
    /// <summary>
    /// Class that describes the file associated to a content
    /// </summary>
    [XmlRoot(ElementName = "File", Namespace = "http://xonline.mix.productmanagement.contracts/V1")]
    public class File
    {
        /// <summary>
        /// Gets or sets the url of the file
        /// </summary>
        public string FileUrl { get; set; }

        /// <summary>
        /// Gets or sets the sort order of the file
        /// </summary>
        public int SortOrder { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OfferLib\Game.cs ===
﻿using System.Runtime.Serialization;

namespace LiveN.Test.Offers
{
    /// <summary>
    /// Class that describes a game
    /// </summary>
    [DataContract(Name = "Game", Namespace = "http://xonline.mix.productmanagement.contracts/V1")]
    public class Game : ProductBase
    {
        /// <summary>
        /// Gets or sets the Xbox LIVE title id
        /// </summary>
        [DataMember]
        public uint LiveTitleId { get; set; }

        /// <summary>
        /// Gets or sets the localized data for the game
        /// </summary>
        [DataMember]
        public LocalizedData[] GameLocalizedData { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\LivenMobileGadget\LivenGadget\LivenGadget\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("LiveN Enviroment Gadget")]
[assembly: AssemblyProduct("LiveN Gadget")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyCopyright("Copyright © Microsoft 2010")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type. Only Windows
// assemblies support COM.
[assembly: ComVisible(false)]

// On Windows, the following GUID is for the ID of the typelib if this
// project is exposed to COM. On other platforms, it unique identifies the
// title storage container when deploying this assembly to the device.
[assembly: Guid("9bc1088e-890e-4e41-996d-d62158903d0d")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
[assembly: AssemblyVersion("1.1.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OfferLib\GameRelationship.cs ===
﻿using System;
using System.Runtime.Serialization;

namespace LiveN.Test.Offers
{
    /// <summary>
    /// Class that describes the relationship of a content to a game
    /// </summary>
    [DataContract(Name = "GameRelationship", Namespace = "http://xonline.mix.productmanagement.contracts/V1")]
    public class GameRelationship
    {
        /// <summary>
        /// Gets or sets the game id
        /// </summary>
        [DataMember]
        public Guid GameId { get; set; }

        /// <summary>
        /// Gets or sets the sort order of the game
        /// </summary>
        [DataMember]
        public int SortOrder { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OfferLib\GameContent.cs ===
﻿using System.Runtime.Serialization;

namespace LiveN.Test.Offers
{
    /// <summary>
    /// Class that describes a downloadable content for a game
    /// </summary>
    [DataContract(Name = "GameContent", Namespace = "http://xonline.mix.productmanagement.contracts/V1")]
    public class GameContent : ProductBase
    {
        /// <summary>
        /// Gets or sets the effective Xbox LIVE title Id of the content
        /// </summary>
        [DataMember]
        public int EffectiveLiveTitle { get; set; }

        /// <summary>
        /// Gets or sets the media type of the game content
        /// </summary>
        [DataMember]
        public int GameContentTypeId { get; set; }

        /// <summary>
        /// Gets or sets the game relationships that the content has
        /// </summary>
        [DataMember]
        public GameRelationship[] GameRelationships { get; set; }

        /// <summary>
        /// Gets or sets the localized data of the content
        /// </summary>
        [DataMember]
        public LocalizedData[] LocalizedData { get; set; }

        /// <summary>
        /// Gets or sets the downloadable packages of the content
        /// </summary>
        [DataMember]
        public Package[] Packages { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OfferLib\MixTestDataFile.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml.Serialization;
using System.Xml;
using System.IO;
using System.Runtime.Serialization;

namespace LiveN.Test.Offers
{
    /// <summary>
    /// Class that describes the MIX data file used to ingest test content
    /// </summary>
    [XmlRootAttribute("MixTestDataFile", Namespace = "", IsNullable = false)]
    public class MixTestDataFile
    {
        private List<XmlDocument> products = new List<XmlDocument>();
        private List<XmlDocument> offers = new List<XmlDocument>();

        /// <summary>
        /// List of products included in the test data file
        /// </summary>
        [XmlArray("MixProductList"), XmlArrayItem(ElementName = "MixProductListItem", Type = typeof(XmlDocument))]
        public XmlDocument[] Products
        {
            get
            {
                return products.ToArray();
            }
            set
            {
                products = new List<XmlDocument>(value);
            }
        }

        /// <summary>
        /// List of offers included in the test data file
        /// </summary>
        [XmlArray("MixOfferList"), XmlArrayItem(ElementName = "MixOfferListItem", Type = typeof(XmlDocument))]
        public XmlDocument[] Offers
        {
            get
            {
                return offers.ToArray();
            }
            set
            {
                offers = new List<XmlDocument>(value);
            }
        }

        /// <summary>
        /// Deserializes the file into a MixTestDataFile
        /// </summary>
        /// <param name="fileName">Path to the file</param>
        /// <returns>MixTestDataFile object that describes the content of the file</returns>
        public static MixTestDataFile Deserialize(string fileName)
        {
            XmlSerializer serializer = new XmlSerializer(typeof(MixTestDataFile));
            using (FileStream fs = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read))
            {
                XmlReader reader = new XmlTextReader(fs);
                MixTestDataFile result = (MixTestDataFile)serializer.Deserialize(reader);
                return result;
            }
        }

        /// <summary>
        /// Returns the list of games in the file
        /// </summary>
        /// <returns></returns>
        public List<Game> GetGames()
        {
            List<Game> gameList = new List<Game>();
            foreach (XmlDocument productXml in this.Products)
            {
                if (productXml.DocumentElement.Name.Equals("game", StringComparison.OrdinalIgnoreCase))
                {
                    Game game = DeserializeFromXmlDoc<Game>(productXml);
                    gameList.Add(game);
                }
            }
            return gameList;
        }

        /// <summary>
        /// Returns the list of game contents in the file
        /// </summary>
        /// <returns></returns>
        public List<GameContent> GetGameContent()
        {
            List<GameContent> contentList = new List<GameContent>();
            foreach (XmlDocument productXml in this.Products)
            {
                if (productXml.DocumentElement.Name.Equals("gamecontent", StringComparison.OrdinalIgnoreCase))
                {
                    GameContent game = DeserializeFromXmlDoc<GameContent>(productXml);
                    contentList.Add(game);
                }
            }
            return contentList;
        }

        /// <summary>
        /// Returns the list of offers in the file
        /// </summary>
        /// <returns></returns>
        public List<Offer> GetOffers()
        {
            List<Offer> offerList = new List<Offer>(this.Offers.Length);
            foreach (XmlDocument offerXml in this.Offers)
            {
                Offer offer = DeserializeFromXmlDoc<Offer>(offerXml);
                offerList.Add(offer);
            }
            return offerList;
        }

        /// <summary>
        /// Deserializes from a given xml document to a type T
        /// </summary>
        /// <typeparam name="T">Type of the object</typeparam>
        /// <param name="xmlDoc">Source xml document</param>
        /// <returns></returns>
        private static T DeserializeFromXmlDoc<T>(XmlDocument xmlDoc) where T : class
        {
            try
            {
                XmlTextReader reader = new XmlTextReader(new StringReader(xmlDoc.OuterXml));
                DataContractSerializer serializer = new DataContractSerializer(typeof(T));
                return serializer.ReadObject(reader, true) as T;
            }
            catch (InvalidOperationException)
            {
            }
            catch (IOException)
            {
            }
            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OfferLib\OfferEntry.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace LiveN.Test.Offers
{
    /// <summary>
    /// Class that holds an offer instance as well as its related parent information
    /// </summary>
    public class OfferEntry
    {
        /// <summary>
        /// Holds the offer instance that describes the current entry
        /// </summary>
        private OfferInstance offerInstance { get; set; }

        /// <summary>
        /// Holds the offer that's associated with the current entry
        /// </summary>
        private Offer offer { get; set; }
        
        /// <summary>
        /// Holds the content that's associated with the current offer
        /// </summary>
        private GameContent gameContent { get; set; }

        /// <summary>
        /// Holds the game that's associated with the current content
        /// </summary>
        private Game game { get; set; }

        public OfferEntry(OfferInstance offerInstance, Offer offer, GameContent gameContent, Game game)
        {
            this.offerInstance = offerInstance;
            this.offer = offer;
            this.gameContent = gameContent;
            this.game = game;
        }
        
        /// <summary>
        /// Gets the offer id
        /// </summary>
        public Guid OfferId
        {
            get
            {
                return this.offer.OfferId;
            }
        }

        /// <summary>
        /// Gets the offer instance id
        /// </summary>
        public Guid OfferInstanceId
        {
            get
            {
                return this.offerInstance.OfferInstanceId;
            }
        }

        /// <summary>
        /// Gets the title id of the game
        /// </summary>
        public uint TitleId
        {
            get
            {
                return this.game.LiveTitleId;
            }
        }

        /// <summary>
        /// Gets the price of the offer instance
        /// </summary>
        public decimal Price
        {
            get
            {
                return this.offerInstance.PaymentPrice;
            }
        }

        /// <summary>
        /// Gets the media type id of the offer
        /// </summary>
        public int MediaTypeId
        {
            get
            {
                return this.gameContent.GameContentTypeId;
            }
        }

        /// <summary>
        /// Gets the array of store id's for the offer
        /// </summary>
        public int[] StoreIds
        {
            get
            {
                return this.offer.StoreIds;
            }
        }

        /// <summary>
        /// Gets the payment type id of the offer instance
        /// </summary>
        public int PaymentTypeId
        {
            get
            {
                return this.offerInstance.PaymentTypeId;
            }
        }

        /// <summary>
        /// Gets the country code of the offer instance
        /// </summary>
        public string CountryCode
        {
            get
            {
                return this.offerInstance.CountryCode;
            }
        }

        /// <summary>
        /// Gets the array of supported user type id's
        /// </summary>
        public int[] UserTypeIds
        {
            get
            {
                return this.offerInstance.UserTypeIds;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OfferLib\Offer.cs ===
﻿using System;
using System.Runtime.Serialization;

namespace LiveN.Test.Offers
{
    /// <summary>
    /// Class that describes an offer
    /// </summary>
    [DataContract(Name = "Offer", Namespace = "http://xonline.mix.offermanagement.contracts/V1")]
    public class Offer
    {
        /// <summary>
        /// Gets or sets the array of offer instances for this offer
        /// </summary>
        [DataMember]
        public OfferInstance[] Instances { get; set; }

        /// <summary>
        /// Gets or sets the LIVE offer id
        /// </summary>
        [DataMember]
        public long LiveOfferId { get; set; }

        /// <summary>
        /// Gets or sets the name of the offer
        /// </summary>
        [DataMember]
        public string Name { get; set; }

        /// <summary>
        /// Gets or sets the offer id
        /// </summary>
        [DataMember]
        public Guid OfferId { get; set; }

        /// <summary>
        /// Gets or sets the offer type (1 = one-time purchase, 2 = subscription, 3 = sub trial)
        /// </summary>
        [DataMember]
        public int OfferType { get; set; }

        /// <summary>
        /// Gets or sets the product id associated to this offer
        /// </summary>
        [DataMember]
        public Guid ProductId { get; set; }

        /// <summary>
        /// Gets or sets the store id of the offer
        /// </summary>
        [DataMember]
        public int[] StoreIds { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OfferLib\LocalizedData.cs ===
﻿using System.Runtime.Serialization;

namespace LiveN.Test.Offers
{
    /// <summary>
    /// Class that describes the localized data for a game or a game content
    /// </summary>
    [DataContract(Name = "LocalizedData", Namespace = "http://xonline.mix.productmanagement.contracts/V1")]
    public class LocalizedData
    {
        /// <summary>
        /// Gets or sets the description text
        /// </summary>
        [DataMember]
        public string Description { get; set; }

        /// <summary>
        /// Gets or sets the reduced description text
        /// </summary>
        [DataMember]
        public string DescriptionReduced { get; set; }

        /// <summary>
        /// Gets or sets the array of equivalent locales
        /// </summary>
        [DataMember]
        public string[] EquivalentLocales { get; set; }

        /// <summary>
        /// Gets or sets the locale of the data
        /// </summary>
        [DataMember]
        public string Locale { get; set; }

        /// <summary>
        /// Gets or sets the title text
        /// </summary>
        [DataMember]
        public string Title { get; set; }

        /// <summary>
        /// Gets or setes the reduced title text
        /// </summary>
        [DataMember]
        public string TitleReduced { get; set; }

        /// <summary>
        /// Gets or sets the sort order of the title
        /// </summary>
        [DataMember]
        public string TitleSort { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OfferLib\OfferInstance.cs ===
﻿using System;
using System.Runtime.Serialization;

namespace LiveN.Test.Offers
{
    /// <summary>
    /// Class that describes the offer instance
    /// </summary>
    [DataContract(Name = "OfferInstance", Namespace = "http://xonline.mix.offermanagement.contracts/V1")]
    public class OfferInstance
    {
        /// <summary>
        /// Gets or sets the country code
        /// </summary>
        [DataMember]
        public string CountryCode { get; set; }

        /// <summary>
        /// Gets or setes the offer instance id
        /// </summary>
        [DataMember]
        public Guid OfferInstanceId { get; set; }

        /// <summary>
        /// Gets or sets the price of the offer instance
        /// </summary>
        [DataMember]
        public decimal PaymentPrice { get; set; }

        /// <summary>
        /// Gets or sets the currency code for the price
        /// </summary>
        [DataMember]
        public string PaymentPriceCurrencyCode { get; set; }

        /// <summary>
        /// Gets or sets the payment type id
        /// </summary>
        [DataMember]
        public int PaymentTypeId { get; set; }

        /// <summary>
        /// Gets or sets the array of user type id's
        /// </summary>
        [DataMember]
        public int[] UserTypeIds { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OfferLib\Package.cs ===
﻿using System.Runtime.Serialization;

namespace LiveN.Test.Offers
{
    /// <summary>
    /// Class that describes the downloadable package for the game or game content
    /// </summary>
    [DataContract(Name = "ProductPackage", Namespace = "http://xonline.mix.productmanagement.contracts/V1")]
    public class Package
    {
        /// <summary>
        /// Gets or sets the array of client types
        /// </summary>
        [DataMember]
        public int[] ClientTypes { get; set; }

        /// <summary>
        /// Gets or sets the array of files
        /// </summary>
        [DataMember]
        public File[] Files { get; set; }

        /// <summary>
        /// Gets or sets the install size
        /// </summary>
        [DataMember]
        public ulong InstallSize { get; set; }

        /// <summary>
        /// Gets or sets the package size
        /// </summary>
        [DataMember]
        public ulong PackageSize { get; set; }

        /// <summary>
        /// Gets or sets the package type
        /// </summary>
        [DataMember]
        public int PackageType { get; set; }

        /// <summary>
        /// Gets or sets the mask for supported game region
        /// </summary>
        [DataMember]
        public long SupportedGameRegionMask { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OfferLib\ProductBase.cs ===
﻿using System;
using System.Runtime.Serialization;

namespace LiveN.Test.Offers
{
    /// <summary>
    /// Base class that describes a product
    /// </summary>
    [DataContract(Name = "Product", Namespace = "http://xonline.mix.productmanagement.contracts/V1")]
    public class ProductBase
    {
        /// <summary>
        /// Gets or sets the product id
        /// </summary>
        [DataMember]
        public Guid ProductId { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCard\Game\CardEventArgs.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace OneCard.Game
{
    public class CardEventArgs : EventArgs
    {
        public PlayingCard Card { get; private set; }
        public CardEventArgs(PlayingCard card)
        {
            Card = card;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OfferLib\TestContentCollection.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Collections.ObjectModel;
using System.IO;
using System.Xml.Serialization;

namespace LiveN.Test.Offers
{
    /// <summary>
    /// Singleton class that holds offers that are propped in a test environment. 
    /// Use the FindOffers method to retrieve offers.
    /// </summary>
    public sealed class TestContentCollection
    {
        /// <summary>
        /// ReadOnlyCollection that holds offer entries.
        /// </summary>
        public ReadOnlyCollection<OfferEntry> OfferEntryCollection;

        /// <summary>
        /// Private instance of the class
        /// </summary>
        static readonly TestContentCollection instance = new TestContentCollection();

        /// <summary>
        /// Gets the singleton instance of the class.
        /// </summary>
        public static TestContentCollection Instance { get { return instance; } }
        
        /// <summary>
        /// Static constructor 
        /// </summary>
        static TestContentCollection()
        {
        }

        /// <summary>
        /// Private constructor that loads the offer xml and populates the collection
        /// </summary>
        private TestContentCollection()
        {
            MixTestDataFile testDataFile = MixTestDataFile.Deserialize("mobile_pdlc.xml");

            List<Offer> offerCollection = testDataFile.GetOffers();
            List<Game> gameCollection = testDataFile.GetGames();
            List<GameContent> gameContentCollection = testDataFile.GetGameContent();

            List<OfferEntry> offerList = new List<OfferEntry>();

            foreach (Game game in gameCollection)
            {
                foreach (GameContent gameContent in gameContentCollection.Where(content => 
                    content.GameRelationships.Where(relationship => relationship.GameId == game.ProductId).Count() > 0))
                {
                    foreach (Offer offer in offerCollection.Where(offer => offer.ProductId == gameContent.ProductId))
                    {
                        foreach (OfferInstance instance in offer.Instances)
                        {
                            offerList.Add(new OfferEntry(instance, offer, gameContent, game));
                        }
                    }
                }
            }

            this.OfferEntryCollection = new ReadOnlyCollection<OfferEntry>(offerList);
        }

        /// <summary>
        /// Finds offers that satisfy the given condition and returns an array of offers
        /// </summary>
        /// <param name="storeId"></param>
        /// <param name="titleId"></param>
        /// <param name="offerMediaType"></param>
        /// <param name="countryCode"></param>
        /// <param name="minPrice"></param>
        /// <param name="paymentTypeId"></param>
        /// <param name="userType"></param>
        /// <returns>Array of offer entries</returns>
        public OfferEntry[] FindOffers(int? storeId, uint? titleId, int? offerMediaType, string countryCode, decimal? minPrice, int? paymentTypeId, int? userType)
        {
            IEnumerable<OfferEntry> offerResults = this.OfferEntryCollection;

            if (storeId != null)
            {
                offerResults = offerResults.Where(entry => entry.StoreIds.Contains((int)storeId));
            }

            if (titleId != null)
            {
                offerResults = offerResults.Where(entry => entry.TitleId == titleId);
            }

            if (offerMediaType != null)
            {
                offerResults = offerResults.Where(entry => entry.MediaTypeId == offerMediaType);
            }

            if (!string.IsNullOrEmpty(countryCode))
            {
                offerResults = offerResults.Where(entry => entry.CountryCode == countryCode);
            }

            if (minPrice != null)
            {
                offerResults = offerResults.Where(entry => entry.Price >= minPrice);
            }

            if (paymentTypeId != null)
            {
                offerResults = offerResults.Where(entry => entry.PaymentTypeId == paymentTypeId);
            }

            if (userType != null)
            {
                offerResults = offerResults.Where(entry => entry.UserTypeIds.Contains((int)userType));
            }

            if (offerResults.Count() == 0)
            {
                string errorText = string.Format("No offer found: storeId = '{0}', titleId = '{1}', "
                    + "offerMediaType = '{2}', countryCode = '{3}', minPrice = '{4}', paymentTypeId = '{5}', userType ='{6}'",
                    storeId == null ? "null" : storeId.ToString(), titleId == null ? "null" : titleId.ToString(),
                    offerMediaType == null ? "null" : offerMediaType.ToString(), countryCode == null ? "null" : countryCode,
                    minPrice == null ? "null" : minPrice.ToString(), paymentTypeId == null ? "null" : paymentTypeId.ToString(),
                    userType == null ? "null" : userType.ToString());
                throw new Exception(errorText);
            }
            return offerResults.ToArray();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCard\Program.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Reflection;

using AsyncMultiplayer.SessionCommon;
using AsyncMultiplayer.NotificationService;

using OneCardFramework.Configuration;
using OneCardFramework.Services;
using OneCard.Game;
using OneCardFramework;
using OneCardFramework.Game;
using System.Diagnostics;
using OneCardFramework.Cache;

namespace OneCard
{
    class Program
    {
        static void Main(string[] args)
        {
            //Trace.Listeners.Add(new ConsoleTraceListener(false));

            ApplicationConfiguration appConfig = ApplicationConfiguration.LoadFromFile("Content/Config.xml");
            ServicesConfiguration serviceConfig = (from entry in appConfig.ServiceConfigEntries
                                                  where entry.Name == "DefaultInt2"
                                                  select entry).First();
            UserConfiguration userConfig = (from entry in appConfig.UserProfiles
                                            where entry.Environments.Contains(serviceConfig.Environment)
                                            select entry).First();
            AuthenticationConfig authConfig = serviceConfig.AuthenticationConfiguration;
            MultiplayerServiceConfig multiplayerConfig = serviceConfig.MultiplayerServicesConfiguration;

            string username = userConfig.Username;
            string password = userConfig.Password;

            AuthenticationService.InstallDefaultCertificates();

            User user = AuthenticationService.CreateUser(username, password, authConfig);

            //CreationData cd = new CreationData();
            //cd.GameID = authConfig.TitleID;
            //cd.Variant = 0;
            //cd.TotalSeatsAvailable = cd.ReservedSeatsAvailable = 8;
            //cd.DisplayName = "Test on Test";
            //cd.InactivityWarning = new InactivityWarningBehavior();
            //SessionState newSession = SessionService.CreateSession(cd, ticket);

            //SessionEntry[] sessions = SessionService.ViewSessionSummaries(config.TitleID, ShowSessionType.All, ticket, config);

            //InviteRequest invite = new InviteRequest();
            //invite.GameId = sessions[0].GameID;
            //invite.SessionId = sessions[0].SessionID;
            //invite.Recipients = "opssek-test@live-int.com";
            //invite.Data = string.Format("Hello. G: {0} S: {1}", invite.GameId, invite.SessionId);
            //NotificationService.SendInvite(invite, ticket, config);

            NotificationList notifications = NotificationService.GetNotifications(user.Authentication, multiplayerConfig);


            ISessionSystem sessionStore =
                new SessionStoreCustom<OneCardConfig, OneCardGame>(user, multiplayerConfig, OneCardGame.GameInitializer, OneCardGame.GameBuilder);

            OneCardConfig gameConfig = new OneCardConfig();
            gameConfig.DisplayName = "Reorg Test";
            gameConfig.TotalSeatsAvailable = 12;
            gameConfig.CanRemoveEmptySeats = true;
            gameConfig.InactivityWarning = new InactivityWarningBehavior();
            string sessionID = sessionStore.CreateSession(gameConfig);

            OneCardGame createdGame = (OneCardGame)sessionStore.AcquireGame(sessionID);
            createdGame.PlayCard(createdGame.MyHand[0]);

            Console.ReadLine();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OfferLib\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("LiveN.Test.Offers")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("a002c744-618b-4929-92ed-d3678895142e")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCard\Game\InfiniteDeck.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace OneCard.Game
{
    /// <summary>
    /// A deck of playing cards that can be fast-forwarded to synchronize with
    /// infinite decks on other machines
    /// </summary>
    public class InfiniteDeck
    {
        //Store the possible suits and values to select from
        Suit[] suits = (Suit[])Enum.GetValues(typeof(Suit));
        FaceValue[] faceValues = (FaceValue[])Enum.GetValues(typeof(FaceValue));

        Random random;

        #region Properties
        /// <summary>
        /// Gets the total number of cards that have been drawn from the deck
        /// </summary>
        public int TotalCardsDrawn
        {
            get { return totalCardsDrawn; }
        }
        private int totalCardsDrawn = 0;

        /// <summary>
        /// Gets the seed value used for generating cards at random
        /// </summary>
        public int RandomSeed
        {
            get { return randomSeed; }
        }
        private int randomSeed;
        #endregion


        /// <summary>
        /// Creates an infinite deck of cards (drawn at random)
        /// </summary>
        /// <param name="seed">Random seed value</param>
        public InfiniteDeck(int seed)
        {
            randomSeed = seed;
            random = new Random(seed);
        }

        /// <summary>
        /// Fast-forwards the deck's randomizer to reach the current point 
        /// in time
        /// </summary>
        /// <param name="numCardsDrawn">The number of cards to "draw" to
        /// get to the current point in time</param>
        public void FastForward(int numCardsDrawn)
        {
            for (int i = 0; i < numCardsDrawn; ++i)
            {
                random.NextDouble(); //Replicates Suit selection
                random.NextDouble(); //Replicates Value selection
            }
            totalCardsDrawn += numCardsDrawn;
        }

        /// <summary>
        /// Draws a card from the deck
        /// </summary>
        /// <returns></returns>
        public PlayingCard Draw()
        {
            double suitSelect = random.NextDouble();
            double valueSelect = random.NextDouble();
            ++totalCardsDrawn;

            Suit suit = suits[(int)(suitSelect * suits.Length)];
            FaceValue face = faceValues[(int)(valueSelect * faceValues.Length)];
            
            return new PlayingCard(suit, face, FaceDirection.FaceDown);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCard\Game\OneCardGame.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using AsyncMultiplayer.SessionCommon;
using System.ComponentModel;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters.Binary;
using System.IO;
using System.Diagnostics;
using OneCardFramework.Game;
using OneCardFramework;
using OneCardFramework.Extensions;

namespace OneCard.Game
{
    public class OneCardConfig : GameConfig
    {

    }

    /// <summary>
    /// Contains client logic for a game of OneCard.
    /// </summary>
    public class OneCardGame : IGame
    {
        public event EventHandler<CardEventArgs> CardDrawn;
        public event EventHandler<CardEventArgs> CardPlayed;

        /// <summary>
        /// Fired whenever large state changes occur, such as receiving a new state
        /// </summary>
        public event EventHandler Updated;


        public PlayingCard TopDiscard
        {
            get {
                if (discardPile == null || discardPile.Count == 0)
                    return null;

                return discardPile[discardPile.Count - 1];
            }
        }

        /// <summary>
        /// The cards in the discard pile. Ordered from Bottom to Top
        /// </summary>
        public ReadOnlyCollection<PlayingCard> DiscardPile
        {
            get { return discardPileReadOnly; }
        }
        private ReadOnlyCollection<PlayingCard> discardPileReadOnly;

        
        /// <summary>
        /// The cards I currently have in my hand
        /// </summary>
        public ReadOnlyCollection<PlayingCard> MyHand
        {
            get { return myCardsReadOnly; }
        }
        private ReadOnlyCollection<PlayingCard> myCardsReadOnly;


        /// <summary>
        /// The stacked attack value, representing the number of cards
        /// we must draw due to an attack.
        /// </summary>
        public int AttackOnUs
        {
            get { return (_session.IsMyTurn) ? attackOnUs : 0;}
        }

        /// <summary>
        /// Gets the direction around the table that play progresses
        /// </summary>
        public int PlayDirection
        {
            get { return PlayDirection; }
        }

        /// <summary>
        /// Gets whether we are the winner of this game
        /// </summary>
        public bool IsWinner
        {
            //Right now, the only way to tell if we are the winner is to examine our custom game state
            //and see if we match the win conditions. It would be nice if Session/GameState had the info we need.
            get { return _session.IsGameOver && MyHand.Count == 0 && playerHands.ContainsKey(_session.MyUid); }
        }


        private InfiniteDeck deck;        
        private List<PlayingCard> discardPile;        
        private List<PlayingCard> myCards;
        private Dictionary<string, List<PlayingCard>> playerHands;
        private int currentTurn; //The number of turns (active player changes) that have passed since the start of the game
        private int currentTurnWithRepeat; //The number of game turns (including TakeAnotherTurn) that have passed since the start of the game
        private int attackOnUs; //The cumulative attack power of the cards played by the previous active player
        private int currentAttackPower; //The current attack power of cards we have played this turn
        private int numSkips; //The number of skips we have played this turn
        private int playDirection = 1; //The direction of play around the table

        private bool needToDrawHand = false; //True if we are new to the game and need to draw a hand when we start our turn
        private bool hasDrawnThisTurn = false;
        //private bool isInitialized = false;
        private bool isTurnStarted = false;

        /// <summary>
        /// Gets the session object this game instance uses to link to the online game state
        /// </summary>
        public GameSession Session { get { return _session; } }
        private GameSession _session;


        #region Construction and Initialization

        /// <summary>
        /// Creates a game of OneCard
        /// </summary>
        /// <param name="session"></param>
        public OneCardGame(GameSession session)
        {
            _session = session;

            //Initialize our collections
            myCards = new List<PlayingCard>();
            myCardsReadOnly = new ReadOnlyCollection<PlayingCard>(myCards);

            discardPile = new List<PlayingCard>();
            discardPileReadOnly = new ReadOnlyCollection<PlayingCard>(discardPile);

            //Load our initial state from the server's data
            LoadFromState(session.GameState);

            //And start listening for any changes
            session.Updated += HandleSessionUpdated;
        }


        /// <summary>
        /// Creates a game of OneCard
        /// </summary>
        public static Func<GameSession, OneCardGame> GameBuilder = delegate(GameSession session)
        {
            return new OneCardGame(session);
        };

        /// <summary>
        /// Generates initial game state data for use when creating a new game session
        /// </summary>
        /// <param name="config"></param>
        /// <returns></returns>
        public static Func<OneCardConfig, byte[]> GameInitializer = delegate(OneCardConfig config)
        {
            //Here we can generate an initial OneCardState and serialize it out
            OneCardState state = new OneCardState();
            state.RandomSeed = (new Random()).Next();
            state.CurrentTurn = 0;
            state.CurrentTurnWithRepeat = 0;
            state.AttackPower = 0;
            state.TotalCardsDrawn = 0;
            state.PlayDirection = 1;
            state.PlayerHands = new Dictionary<string, List<PlayingCard>>();
            state.DiscardPile = new List<PlayingCard>();

            //Flip top card into discard
            InfiniteDeck deck = new InfiniteDeck(state.RandomSeed);
            PlayingCard topCard = deck.Draw();
            topCard.Facing = FaceDirection.FaceUp;
            state.DiscardPile.Add(topCard);
            state.TotalCardsDrawn = deck.TotalCardsDrawn;

            return state.GetBytes();
        };


        #endregion





        /// <summary>
        /// Called by the game management system just prior to leaving the session (i.e. when the player is quitting early)
        /// </summary>
        public void NotifyPreLeave()
        {
        }

        /// <summary>
        /// Called by the game management system just after leaving the session (i.e. when the player is quitting early)
        /// </summary>
        public void NotifyPostLeave()
        {
        }


        #region Update Logic

        /// <summary>
        /// Updates the local game state from the supplied serialized state
        /// </summary>
        /// <param name="state">A serialized OneCardState object</param>
        private void LoadFromState(byte[] state)
        {
            if (state == null)
                throw new ArgumentNullException("state");

            //Keep up to date by loading in data from the online game state
            OneCardState onlineState = OneCardState.FromBytes(state);

            this.currentTurn = onlineState.CurrentTurn;
            this.currentTurnWithRepeat = onlineState.CurrentTurnWithRepeat;
            this.attackOnUs = onlineState.AttackPower;
            this.discardPile.Clear();
            this.discardPile.AddRange(onlineState.DiscardPile);
            this.playDirection = onlineState.PlayDirection;

            this.deck = new InfiniteDeck(onlineState.RandomSeed);
            this.deck.FastForward(onlineState.TotalCardsDrawn);

            this.playerHands = onlineState.PlayerHands;

            if (playerHands.ContainsKey(_session.MyUid))
            {
                myCards.Clear();
                myCards.AddRange(playerHands[_session.MyUid]);
            }
            else if(isTurnStarted == false)
            {
                //If our hand is not in the online state and we haven't started our turn, we need to draw
                this.needToDrawHand = true;
            }

            //Start our turn if we can
            if (_session.IsMyTurn && !isTurnStarted)
            {
                StartMyTurn();
            }

            //Notify listeners that our state changed greatly
            OnUpdated();
        }



        /// <summary>
        /// Handles consuming updated session and game state
        /// </summary>
        /// <param name="newSessionState"></param>
        /// <param name="newGameState"></param>
        private void HandleSessionUpdated(object sender, SessionUpdatedEventArgs args)
        {
            SessionState newSessionState = args.SessionState;
            byte[] newGameState = args.GameState;


            //If it's not our turn or we haven't started actually taking our turn,
            //we should keep our state updated. If it is our turn, we don't want to
            //disrupt the player's actions with old data.
            if (_session.IsMyTurn == false || isTurnStarted == false)
            {
                LoadFromState(newGameState);
            }
        }

        #endregion

        /// <summary>
        /// Gets the number of cards a player is holding
        /// </summary>
        /// <param name="uid">The unique identifier for the player</param>
        /// <returns></returns>
        public int GetNumberOfCards(string uid)
        {
            return (playerHands.ContainsKey(uid) ? playerHands[uid].Count : 0);
        }

        /// <summary>
        /// Gets the number of cards a player is holding
        /// </summary>
        /// <param name="seat">The player's seat</param>
        /// <returns></returns>
        public int GetNumberOfCards(SeatInfo seat)
        {
            return GetNumberOfCards(seat.Profile.PublicToken);
        }

        #region Game Logic

        /// <summary>
        /// Begins a player's turn, drawing their initial hand if necessary
        /// </summary>
        private void StartMyTurn()
        {
            Debug.Assert(_session.IsMyTurn, "Attempting to start a turn when we are not the Active Player");

            if (isTurnStarted || _session.IsGameOver)
                return;

            if (needToDrawHand)
            {
                DrawInitialHand();
            }

            currentAttackPower = 0;
            numSkips = 0;
            hasDrawnThisTurn = false;
            isTurnStarted = true;
        }


        /// <summary>
        /// Draws a player's starting hand
        /// </summary>
        private void DrawInitialHand()
        {
            Debug.Assert(_session.IsMyTurn, "We should only be drawing our hand on our turn");
            Debug.Assert(!_session.IsGameOver, "We should only be drawing if the game is still active");
            Debug.Assert(myCards.Count == 0, "We should not have any cards if this is our first draw");

            for (int i = 0; i < 7; i++)
            {
                PlayingCard card = deck.Draw();
                card.Facing = FaceDirection.FaceUp;

                myCards.Add(card);
            }
            needToDrawHand = false;
        }



        /// <summary>
        /// Plays the given card to the discard pile
        /// </summary>
        /// <param name="card"></param>
        public void PlayCard(PlayingCard card)
        {
            if (IsValidPlay(card))
            {
                //Move the card from my hand to the discard
                myCards.Remove(card);
                discardPile.Add(card);

                //Handle consequences of playing the card
                HandleCardPlayed(card);
            }
        }

        /// <summary>
        /// Applies the consequences of playing a card
        /// </summary>
        /// <param name="card">The card played</param>
        private void HandleCardPlayed(PlayingCard card)
        {
            //TODO: Deal with wild cards

            //Apply any special abilities of the card
            CardAbility ability = GetCardAbility(card);

            //Playing a card usually means we're done
            bool isTurnOver = true;

            switch (ability)
            {
                case CardAbility.Reverse:
                    playDirection *= -1;

                    //If there are only two players, Reverse
                    //acts like Skip
                    if (_session.PlayerCount <= 2)
                    {
                        isTurnOver = false;
                    }

                    break;

                case CardAbility.Skip:
                    ++numSkips;
                    break;

                case CardAbility.TakeAnotherTurn:
                    isTurnOver = false;
                    ++currentTurnWithRepeat;
                    break;

                case CardAbility.Attack:
                    //Stack attack power
                    currentAttackPower += GetAttackPower(card);
                    currentAttackPower += attackOnUs;
                    attackOnUs = 0;
                    break;

                default:
                    break;
            }


            //Notify others that a card was played
            OnCardPlayed(card);


            if (MyHand.Count == 0)
            {
                //We won!
                int[] winners = new int[] { _session.MySeatIndex };
                int[] losers = (from seat in _session.SessionState.Seats
                                 where seat.Index != _session.MySeatIndex
                                 select seat.Index).ToArray();
                int[] tie = null;
                int[] gameover = null;

                //Make sure we save off our winning state so that if we view it later,
                //it actually makes sense
                _session.CommitGameState(this.GetState());
                //End the game
                _session.EndGame(winners, losers, tie, gameover);
            }
            else if (isTurnOver)
            {
                FinishTurn();
            }
            else
            {
                //We made a play. Save it so if we quit and reload, it's persisted.
                _session.CommitGameState(this.GetState());
            }
        }

        private void FinishTurn()
        {
            //We finished a play. Now we need to figure out whose turn it is. This
            //is slightly complicated because of the game rules.

            //We can look at the Seats list to see who else is participating
            SeatInfo[] currentPlayers = _session.SessionState.Seats; //Get a continuous set of current participants
            Array.Sort(currentPlayers, (SeatInfo a, SeatInfo b) => a.Index.CompareTo(b.Index));
            int me = Array.FindIndex(currentPlayers, (SeatInfo seat) => seat.Index == _session.MySeatIndex);

            //Take into account skips and reverses
            int delta = ((numSkips == 0) ? 1 : numSkips * 2) * playDirection;

            //Select the next player (if it's just us right now, act like there are 2 players so we can't play against ourselves)
            int nextActive = MathUtility.Wrap(me + delta, 0, Math.Max(2, currentPlayers.Length));
            nextActive = (nextActive >= currentPlayers.Length) ? nextActive : currentPlayers[nextActive].Index;

            //Increment our counter of how many non-repeat turns we've taken
            ++currentTurn;

            //Commit the changes
            _session.EndTurn(this.GetState(), nextActive);
            isTurnStarted = false;
        }

        /// <summary>
        /// Draws a card from the deck if it is a valid move
        /// </summary>
        public void DrawCard()
        {
            if (_session.IsMyTurn && !_session.IsGameOver)
            {
                PlayingCard newCard = deck.Draw();
                newCard.Facing = FaceDirection.FaceUp;
                myCards.Add(newCard);

                var prevAttackOnUs = attackOnUs;
                HandleCardDrawn(newCard);

                OnCardDrawn(newCard);

                if (prevAttackOnUs == 0)
                    FinishTurn();
            }
        }
        
        /// <summary>
        /// Applies the consequences of playing a card
        /// </summary>
        /// <param name="card"></param>
        private void HandleCardDrawn(PlayingCard card)
        {
            attackOnUs = Math.Max(0, attackOnUs - 1);
            hasDrawnThisTurn = true;
        }


        /// <summary>
        /// Checks whether we are allowed to play a given card at the moment
        /// </summary>
        /// <param name="card"></param>
        /// <returns></returns>
        public bool IsValidPlay(PlayingCard card)
        {
            if (card == null)
                return false;

            //Can only play on our turn!
            if (!_session.IsMyTurn || _session.IsGameOver)
                return false;

            bool isAttack = GetAttackPower(card) > 0;
            bool discardIsAttack = GetAttackPower(TopDiscard) > 0;

            //If we've been attacked, we have to draw cards unless we are playing
            //an attack card and the top discard is an attack card. If we've already 
            //started drawing cards due to the attack, we can no longer perform this
            //stacked attack and must continue drawing cards as normal (prevents cheating
            //by only drawing until we get an attack card).
            if (attackOnUs > 0)
            {
                return isAttack && discardIsAttack && !hasDrawnThisTurn;
            }

            //Wild's can be played on top of anything
            if (IsWild(card))
                return true;

            //TODO: Implement actual wild card logic (player must choose suit)
            if (IsWild(TopDiscard))
                return true;

            //Attack cards of any kind can be played on top of each other
            if (isAttack && discardIsAttack)
                return true;

            //Otherwise we need to match the suit or value
            if (TopDiscard.Suit == card.Suit || TopDiscard.Value == card.Value)
                return true;

            return false;
        }

        public bool IsWild(PlayingCard card)
        {
            return card.Value == FaceValue.Eight;
        }

        public int GetAttackPower(PlayingCard card)
        {
            switch (card.Value)
            {
                case FaceValue.Two:
                    return 2;
                case FaceValue.Ace:
                    return 4;

                default:
                    return 0;
            }
        }

        public enum CardAbility
        {
            None,
            TakeAnotherTurn,
            Reverse,
            Skip,
            Attack,
            Wild
        }

        public CardAbility GetCardAbility(PlayingCard card)
        {
            switch (card.Value)
            {
                case FaceValue.King:
                    return CardAbility.TakeAnotherTurn;

                case FaceValue.Queen:
                    return CardAbility.Reverse;

                case FaceValue.Jack:
                    return CardAbility.Skip;

                case FaceValue.Two:
                case FaceValue.Ace:
                    return CardAbility.Attack;

                case FaceValue.Eight:
                    return CardAbility.Wild;

                default:
                    return CardAbility.None;
            }
        }

        public string GetCardAbilityString(CardAbility ability)
        {
            switch (ability)
            {
                default:
                case CardAbility.None:
                    return string.Empty;

                case CardAbility.Attack:
                    return "Attack";

                case CardAbility.TakeAnotherTurn:
                    return "Take Another Turn";

                case CardAbility.Skip:
                    return "Skip";

                case CardAbility.Reverse:
                    return "Reverse";

                case CardAbility.Wild:
                    return "Wild";
            }
        }

        public string GetCardAbilityStringShort(CardAbility ability)
        {
            switch (ability)
            {
                default:
                case CardAbility.None:
                    return string.Empty;

                case CardAbility.Attack:
                    return "Atk";

                case CardAbility.TakeAnotherTurn:
                    return "Turn";

                case CardAbility.Skip:
                    return "Skip";

                case CardAbility.Reverse:
                    return "Rev";

                case CardAbility.Wild:
                    return "Wild";
            }
        }



        public string GetFullCardName(PlayingCard card)
        {
            CardAbility ability = GetCardAbility(card);
            string abilityName = GetCardAbilityString(ability);
            int attackPower = GetAttackPower(card);

            string fullname = card.Value.ToString() + " of " + card.Suit.ToString();
            fullname += " (";
            fullname += abilityName;
            if(attackPower > 0) fullname += " " + attackPower;
            fullname += " )";

            return fullname;
        }


        #endregion

        #region Event Firing

        private void OnCardDrawn(PlayingCard card)
        {
            CardDrawn.Raise(this, new CardEventArgs(card));
        }

        private void OnCardPlayed(PlayingCard card)
        {
            CardPlayed.Raise(this, new CardEventArgs(card));
        }

        private void OnUpdated()
        {
            Updated.Raise(this, EventArgs.Empty);
        }
        
        #endregion

        #region Serialization

        private byte[] GetState()
        {
            OneCardState state = new OneCardState();

            state.RandomSeed = this.deck.RandomSeed;
            state.TotalCardsDrawn = this.deck.TotalCardsDrawn;
            state.CurrentTurn = this.currentTurn;
            state.CurrentTurnWithRepeat = this.currentTurnWithRepeat;
            state.DiscardPile = this.DiscardPile.ToList();
            state.PlayDirection = this.playDirection;
            state.AttackPower = this.currentAttackPower;
            state.PlayerHands = this.playerHands;

            //We use the online state to persist our hand, as well as check whether we
            //need to draw our initial hand. If we've drawn cards on this client instance,
            //we need to save them to the server.
            if (needToDrawHand == false)
            {
                state.PlayerHands[_session.MyUid] = myCards;
            }

            return state.GetBytes();
        }

        /// <summary>
        /// Data container for game state
        /// </summary>
        [Serializable]
        private class OneCardState
        {
            public int RandomSeed;
            public int TotalCardsDrawn; //Used for fast-forwarding the Infinite Deck
            public int CurrentTurn;
            public int CurrentTurnWithRepeat;

            public List<PlayingCard> DiscardPile;
            public int PlayDirection;
            public int AttackPower;

            //public Dictionary<string, int> CardCounters;
            public Dictionary<string, List<PlayingCard>> PlayerHands;

            public byte[] GetBytes()
            {
                return SerializationHelper.Serialize(this);
            }

            public static OneCardState FromBytes(byte[] data)
            {
                return SerializationHelper.Deserialize<OneCardState>(data);
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardFramework\MathUtility.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace OneCardFramework
{
    /// <summary>
    /// Helper library for math operations
    /// </summary>
    public static class MathUtility
    {
        /// <summary>
        /// Clamps a number to a given range
        /// </summary>
        /// <param name="value"></param>
        /// <param name="min">The minimum value, inclusive</param>
        /// <param name="max">The maximum value, inclusive</param>
        /// <returns></returns>
        public static int Clamp(int value, int min, int max)
        {
            return Math.Max(min, Math.Min(max, value));
        }

        /// <summary>
        /// Wraps a value to lie within a range
        /// </summary>
        /// <param name="value">The value to wrap</param>
        /// <param name="min">The inclusive lower bound of the range</param>
        /// <param name="maxExclusive">The exclusive upper bound of the range</param>
        /// <returns></returns>
        public static int Wrap(int value, int min, int maxExclusive)
        {
            int range = maxExclusive - min;

            int modded = Mod(value - min, range);

            return min + modded;
        }

        /// <summary>
        /// Performs modulus division, but with negative numbers wrapping around (-1 mod 4 gives 3);
        /// </summary>
        /// <param name="value"></param>
        /// <param name="divisor"></param>
        /// <returns></returns>
        public static int Mod(int value, int divisor)
        {
            return value % divisor + ((value < 0) ? divisor : 0);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCard\Game\PlayingCard.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ComponentModel;

namespace OneCard.Game
{
    /// <summary>
    /// Card suit values
    /// </summary>
    [Serializable]
    public enum Suit : byte
    {
        Diamonds, Spades, Clubs, Hearts
    }

    /// <summary>
    /// Card face values
    /// </summary>
    [Serializable]
    public enum FaceValue : byte
    {
        Two = 2, Three = 3, Four = 4, Five = 5, Six = 6, Seven = 7, Eight = 8,
        Nine = 9, Ten = 10, Jack = 11, Queen = 12, King = 13, Ace = 14
    }

    /// <summary>
    /// The direction a card is flipped
    /// </summary>
    [Serializable]
    public enum FaceDirection : byte
    {
        FaceDown,
        FaceUp
    }


    /// <summary>
    /// Represents a standard playing card. A card's suit and value are immutable.
    /// </summary>
    [Serializable]
    public class PlayingCard : INotifyPropertyChanged
    {
        public event PropertyChangedEventHandler PropertyChanged;

        public readonly FaceValue Value;
        public readonly Suit Suit;

        /// <summary>
        /// The direction the card is facing
        /// </summary>
        public FaceDirection Facing
        {
            get { return _facing; }
            set
            {
                if (_facing != value)
                {
                    _facing = value;
                    OnPropertyChanged("Facing");
                }
            }
        }
        private FaceDirection _facing;


        /// <summary>
        /// Creates a playing card
        /// </summary>
        /// <param name="suit"></param>
        /// <param name="value"></param>
        /// <param name="facing">The initial direction the card is facing</param>
        public PlayingCard(Suit suit, FaceValue value, FaceDirection facing)
        {
            Suit = suit;
            Value = value;
            Facing = facing;
        }

        public virtual PlayingCard Clone()
        {
            return (PlayingCard)MemberwiseClone();
        }

        public override string ToString()
        {
            return "The " + Value.ToString() + " of " + Suit.ToString();
        }

        protected void OnPropertyChanged(string propName)
        {
            if (PropertyChanged != null)
                PropertyChanged(this, new PropertyChangedEventArgs(propName));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardFramework\SerializationHelper.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml.Serialization;
using System.Runtime.Serialization;
using System.IO;
using System.Runtime.Serialization.Formatters.Binary;
using System.Xml;

namespace OneCardFramework
{
    public static class SerializationHelper
    {
        /// <summary>
        /// Serializes an object that adheres to a data contract into an XML string
        /// </summary>
        /// <param name="obj"></param>
        /// <returns>The object, represented as a string containing XML</returns>
        public static string SerializeDataContract(object obj)
        {
            string data;

            using (MemoryStream stream = new MemoryStream())
            {
                DataContractSerializer serializer = new DataContractSerializer(obj.GetType());
                serializer.WriteObject(stream, obj);
                stream.Flush();
                stream.Position = 0;

                using (StreamReader reader = new StreamReader(stream))
                {
                    data = reader.ReadToEnd();
                }
            }
            
            return data;
        }

        /// <summary>
        /// Deserializes an object that adheres to a data contract from a string containing XML
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="xmlData"></param>
        /// <returns></returns>
        public static T DeserializeDataContract<T>(string xmlData)
        {
            return (T)DeserializeDataContract(typeof(T), xmlData);
        }

        /// <summary>
        /// Deserializes an object that adheres to a data contract from a string containing XML
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="xmlData"></param>
        /// <returns></returns>
        public static object DeserializeDataContract(Type outputType, string xmlData)
        {
            object obj;
            Encoding encoding = Encoding.UTF8; //The XML parsers require UTF-8 if no encoding is declared

            //Figure out what the actual encoding of the XML is
            XmlDocument doc = new XmlDocument();
            doc.LoadXml(xmlData);

            //Look at the Xml Declaration's encoding attribute
            if (doc.FirstChild.NodeType == XmlNodeType.XmlDeclaration)
            {
                XmlDeclaration decl = (XmlDeclaration)doc.FirstChild;
                if(string.IsNullOrEmpty(decl.Encoding) == false)
                    encoding = Encoding.GetEncoding(decl.Encoding);
            }
            
            //Decode the string xml into an object
            using (MemoryStream stream = new MemoryStream())
            {
                using (StreamWriter writer = new StreamWriter(stream, encoding))
                {
                    writer.Write(xmlData);
                    writer.Flush();
                    stream.Position = 0;
                    
                    DataContractSerializer serializer = new DataContractSerializer(outputType);

                    obj = serializer.ReadObject(stream);
                }
            }
            return obj;
        }


        /// <summary>
        /// Helper for serializing an object into a byte stream
        /// </summary>
        /// <param name="state"></param>
        /// <returns></returns>
        public static byte[] Serialize(object state)
        {
            byte[] data;

            using (MemoryStream stream = new MemoryStream())
            {
                BinaryFormatter formatter = new BinaryFormatter();

                formatter.Serialize(stream, state);

                data = stream.GetBuffer();
            }
            return data;
        }

        /// <summary>
        /// Helper for deserializing an object from a byte stream
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="state"></param>
        /// <returns></returns>
        public static T Deserialize<T>(byte[] state)
        {
            T ret;
            using (MemoryStream stream = new MemoryStream(state))
            {
                BinaryFormatter formatter = new BinaryFormatter();

                ret = (T)formatter.Deserialize(stream);
            }
            return ret;
        }

        /// <summary>
        /// Helper for serializing an object into a string containing XML
        /// </summary>
        /// <param name="obj"></param>
        /// <returns></returns>
        public static string SerializeXml(object obj)
        {
            string data;

            using (StringWriter writer = new StringWriter())
            {
                XmlSerializer serializer = new XmlSerializer(obj.GetType());
                serializer.Serialize(writer, obj);
                data = writer.ToString();
            }

            return data;
        }

        /// <summary>
        /// Helper for deserializing an object from XML
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="xml"></param>
        /// <returns></returns>
        public static T DeserializeXml<T>(string xml)
        {
            T obj;
            Encoding encoding = Encoding.UTF8;

            //Figure out what the actual encoding of the XML is
            XmlDocument doc = new XmlDocument();
            doc.LoadXml(xml);

            //Look at the Xml Declaration's encoding attribute
            if (doc.FirstChild.NodeType == XmlNodeType.XmlDeclaration)
            {
                XmlDeclaration decl = (XmlDeclaration)doc.FirstChild;
                if (string.IsNullOrEmpty(decl.Encoding) == false)
                    encoding = Encoding.GetEncoding(decl.Encoding);
            }

            //Decode the string xml into an object
            using (MemoryStream stream = new MemoryStream())
            {
                using (StreamWriter writer = new StreamWriter(stream, encoding))
                {
                    writer.Write(xml);
                    writer.Flush();
                    stream.Position = 0;

                    XmlSerializer serializer = new XmlSerializer(typeof(T));

                    obj = (T)serializer.Deserialize(stream);
                }
            }
            return obj;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardFramework\Cache\AutoLoader.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Timers;
using System.Diagnostics;
using System.Threading;
using System.ComponentModel;

namespace OneCardFramework.Cache
{
    /// <summary>
    /// Provides the ability to perform an operation on a background thread at
    /// a set minimum interval.
    /// </summary>
    public class AutoLoader
    {
        /// <summary>
        /// Fired when an exception occurs during the asyncronous operation. Permits
        /// listeners to set whether we halt or continue the auto-load cycle
        /// </summary>
        public event EventHandler<AutoLoadExceptionEventArgs> Error;


        private System.Timers.Timer _queryTimer;
        private volatile bool _enableAutoLoad;
        private Action _userOperation;

        /// <summary>
        /// Creates an auto loader that will repeatedly execute the supplied operation on a background thread.
        /// Does not start the auto-load cycle.
        /// </summary>
        /// <param name="name">An optional identifier for this loader</param>
        /// <param name="operation">The operation to perform at each interval</param>
        public AutoLoader(string name, Action operation)
        {
            Name = name;
            _userOperation = operation;

            _enableAutoLoad = false;
            _queryTimer = new System.Timers.Timer();
            _queryTimer.AutoReset = false;
            _queryTimer.Elapsed += AutoLoadWorker;
        }


        #region Public Interface
        /// <summary>
        /// Custom identifier for this loader
        /// </summary>
        public string Name
        {
            get;
            private set;
        }

        /// <summary>
        /// Gets whether we are currently set to auto-load
        /// </summary>
        public bool Enabled
        {
            get { return _enableAutoLoad; }
        }

        /// <summary>
        /// Gets/sets the minimum interval the auto-loader is set to execute
        /// </summary>
        public TimeSpan Interval
        {
            get { return TimeSpan.FromMilliseconds(_queryTimer.Interval); }
            set { _queryTimer.Interval = value.TotalMilliseconds; }
        }

        /// <summary>
        /// Sets the auto loader to begin/resume execution
        /// </summary>
        /// <param name="interval">The minimum interval between loads</param>
        public void StartAutoLoad(TimeSpan interval)
        {
            _enableAutoLoad = true;
            _queryTimer.Interval = interval.TotalMilliseconds;
            _queryTimer.Enabled = true;
        }

        /// <summary>
        /// Stops auto loading
        /// </summary>
        public void StopAutoLoad()
        {
            _enableAutoLoad = false;
            _queryTimer.Enabled = false;
        }
        #endregion


        /// <summary>
        /// The worker. Executes the operation and handles exceptions.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void AutoLoadWorker(object sender, ElapsedEventArgs args)
        {
            //Pause the timer until we're done the operation so that
            //we don't get overlapping executions
            _queryTimer.Enabled = false;

            try
            {
                Trace.TraceInformation("Executing {0} auto-load on thread {1}", Name, Thread.CurrentThread.ManagedThreadId);

                _userOperation();
            }
            catch (Exception e)
            {
                Trace.TraceError("Error occurred in auto-loader {0}: {1}", Name, e.ToString());

                //Notify event subscribers and see if anyone wants to change 
                //from our defacto continue state
                var handler = Error;
                if (handler != null)
                {
                    AutoLoadExceptionEventArgs eventArgs = new AutoLoadExceptionEventArgs(e, true);
                    handler(this, eventArgs);

                    if (eventArgs.Continue == false)
                        StopAutoLoad();
                }
            }

            if (_enableAutoLoad)
            {
                //Set our timer to run again. We do this after the operation, and don't
                //use the AutoReset toggle, so that we don't have overlapping loads
                _queryTimer.Enabled = true;
            }
        }
    }

    /// <summary>
    /// Stores information generated by an exception occuring during auto-loading and
    /// permits changing whether to continue or halt the loading cycle.
    /// </summary>
    public class AutoLoadExceptionEventArgs : EventArgs
    {
        /// <summary>
        /// The exception that was thrown during execution of the auto-load operation
        /// </summary>
        public Exception Error { get; private set; }

        /// <summary>
        /// Allows the event consumer to set whether to continue the auto-loading cycle. True
        /// to continue. False to stop.
        /// </summary>
        public bool Continue { get; set; }

        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="e"></param>
        /// <param name="continue"></param>
        public AutoLoadExceptionEventArgs(Exception e, bool @continue)
        {
            Error = e;
            Continue = @continue;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCard\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("OneCard")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("78b80133-44ea-45e3-bb44-5ea12f28d58d")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
// [assembly: AssemblyVersion("1.0.0.0")]
// [assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardFramework\Cache\ConfigurationStore.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Xml.Serialization;
using System.Collections.Specialized;
using OneCardFramework.Extensions;
using OneCardFramework.Events;

namespace OneCardFramework.Configuration
{

    /// <summary>
    /// Stores configuration data
    /// </summary>
    public class ConfigurationStore
    {
        #region Events
        public event EventHandler<ServicesConfigurationEventArgs> ConfigurationAdded
        {
            //Use weak events
            add { _configurationAdded += value.MakeWeak(n => _configurationAdded -= n); }
            remove { EventManager.Remove(ref _configurationAdded, value); }
        }
        private EventHandler<ServicesConfigurationEventArgs> _configurationAdded;

        public event EventHandler<ServicesConfigurationEventArgs> ConfigurationRemoved
        {
            //Use weak events
            add { _configurationRemoved += value.MakeWeak(n => _configurationRemoved -= n); }
            remove { EventManager.Remove(ref _configurationRemoved, value); }
        }
        private EventHandler<ServicesConfigurationEventArgs> _configurationRemoved;

        public event EventHandler<UserConfigurationEventArgs> UserAdded
        {
            //Use weak events
            add { _userAdded += value.MakeWeak(n => _userAdded -= n); }
            remove { EventManager.Remove(ref _userAdded, value); }
        }
        private EventHandler<UserConfigurationEventArgs> _userAdded;

        public event EventHandler<UserConfigurationEventArgs> UserRemoved
        {
            //Use weak events
            add { _userRemoved += value.MakeWeak(n => _userRemoved -= n); }
            remove { EventManager.Remove(ref _userRemoved, value); }
        }
        private EventHandler<UserConfigurationEventArgs> _userRemoved;
        #endregion

        private Dictionary<string, ServicesConfiguration> _serviceConfigs;
        private List<UserConfiguration> _userConfigs;

        #region Public Interface

        /// <summary>
        /// Creates a store and initializes it with data from the specified XML file
        /// </summary>
        /// <param name="pathToXml"></param>
        public ConfigurationStore(string pathToXml)
        {
            _serviceConfigs = new Dictionary<string, ServicesConfiguration>();
            _userConfigs = new List<UserConfiguration>();

            if (File.Exists(pathToXml))
            {
                ApplicationConfiguration savedConfigData = ApplicationConfiguration.LoadFromFile(pathToXml);

                foreach (ServicesConfiguration config in savedConfigData.ServiceConfigEntries)
                {
                    _serviceConfigs.Add(config.Name, config);
                }
                _userConfigs.AddRange(savedConfigData.UserProfiles);
            }
        }

        /// <summary>
        /// Adds a new configuration to the store
        /// </summary>
        /// <param name="config"></param>
        public void AddServiceConfig(ServicesConfiguration config)
        {
            if (config == null)
                throw new ArgumentNullException();
            if (string.IsNullOrEmpty(config.Name))
                throw new InvalidDataException("Configuration does not have a name");
            if (_serviceConfigs.ContainsKey(config.Name))
                throw new InvalidOperationException("Configuration name is already in use");

            _serviceConfigs.Add(config.Name, config);
            OnServiceConfigAdded(config);
        }


        public void RemoveServiceConfig(string name)
        {
            if (string.IsNullOrEmpty(name))
                throw new ArgumentException("name");
            if (!_serviceConfigs.ContainsKey(name))
                throw new InvalidOperationException("No configuration exists with that name");

            ServicesConfiguration toRemove = _serviceConfigs[name];
            _serviceConfigs.Remove(name);
            OnServiceConfigRemoved(toRemove);
        }

        public bool ContainsServiceConfig(string name)
        {
            return _serviceConfigs.ContainsKey(name);
        }

        public ICollection<ServicesConfiguration> GetServiceConfigs()
        {
            return _serviceConfigs.Values;
        }


        public void AddUserConfig(UserConfiguration user)
        {
            _userConfigs.Add(user);
            OnUserAdded(user);
        }

        public void RemoveUserConfig(UserConfiguration user)
        {
            _userConfigs.Remove(user);
            OnUserRemoved(user);
        }

        public bool ContainsUserConfig(UserConfiguration user)
        {
            return _userConfigs.Contains(user);
        }

        public ICollection<UserConfiguration> GetUserConfigs()
        {
            return _userConfigs.AsReadOnly();
        }


        /// <summary>
        /// Serializes the current data in the store into the stream
        /// </summary>
        /// <param name="stream"></param>
        public void Save(Stream stream)
        {
            XmlSerializer contentLoader = new XmlSerializer(typeof(ApplicationConfiguration));
            contentLoader.Serialize(stream, new ApplicationConfiguration()
            {
                ServiceConfigEntries = _serviceConfigs.Values.ToArray(),
                UserProfiles = _userConfigs.ToArray()
            });
        }

        /// <summary>
        /// Saves the current data in the store to the specified location on disk
        /// </summary>
        /// <param name="stream"></param>
        public void Save(string filePath)
        {
            using (FileStream stream = File.Open(filePath, FileMode.Create, FileAccess.Write))
            {
                Save(stream);
            }
        }

        #endregion

        #region Helpers

        private void OnServiceConfigAdded(ServicesConfiguration config)
        {
            _configurationAdded.Raise(this, new ServicesConfigurationEventArgs(config));
        }

        private void OnServiceConfigRemoved(ServicesConfiguration config)
        {
            _configurationRemoved.Raise(this, new ServicesConfigurationEventArgs(config));
        }

        private void OnUserAdded(UserConfiguration config)
        {
            _userAdded.Raise(this, new UserConfigurationEventArgs(config));
        }

        private void OnUserRemoved(UserConfiguration config)
        {
            _userRemoved.Raise(this, new UserConfigurationEventArgs(config));
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardFramework\WebHelper.cs ===
﻿using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Linq;
using System.Text;
using System.Net;
using System.IO;

using OneCardFramework.Extensions;
using System.Diagnostics;
using OneCardFramework.Services;

namespace OneCardFramework
{
    /// <summary>
    /// Contains helper methods for common web operations
    /// </summary>
    public static class WebHelper
    {
        /// <summary>
        /// Diagnostic tracing source used as the default for web requests generated by the framework
        /// </summary>
        public static readonly TraceSource Tracer = new TraceSource("OneCardFramework.Web", SourceLevels.All);

        #region URL Construction

        /// <summary>
        /// Generates a URL query string in the format ?key=value&key2=value2
        /// </summary>
        /// <param name="parameters"></param>
        /// <param name="includeNull">True to include keys that have null values</param>
        /// <returns>The generated query string</returns>
        public static string BuildQueryString(IDictionary<string, object> parameters, bool includeNull)
        {
            IEnumerable<string> data;

            if (includeNull)
            {
                data = from kvp in parameters
                       select kvp.Key + "=" + kvp.Value;
            }
            else
            {
                data = from kvp in parameters
                       where kvp.Value != null
                       select kvp.Key + "=" + kvp.Value;
            }

            return "?" + string.Join("&", data.ToArray());
        }

        /// <summary>
        /// Generates a URL query string in the format ?key=value&key2=value2
        /// </summary>
        /// <param name="parameters">A collection of key/value pairs used as the parameters to the query</param>
        /// <returns>The generated query string</returns>
        public static string BuildQueryString(NameValueCollection parameters)
        {
            return "?" + string.Join("&", Array.ConvertAll(parameters.AllKeys, key => key + "=" + parameters[key]));
        }
        #endregion

        #region Service Requests

        /// <summary>
        /// Creates and sends an HTTP web request, and reads back the response as a string.
        /// </summary>
        /// <param name="uri">The address of the target service</param>
        /// <param name="method">The HTTP method, such as GET or POST</param>
        /// <param name="headers">A collection of HTTP headers</param>
        /// <param name="contentType">The HTTP content type</param>
        /// <param name="data">The content of the request. Null to omit content.</param>
        /// <param name="contentMessage">An optional string-version of the request content, used for logging</param>
        /// <param name="trace">An optional tracing source to output debugging information to</param>
        /// <returns>The response from the service</returns>
        /// 
        /// <exception cref="ServiceException">Thrown when an exception occurred within the multiplayer service</exception>
        /// <exception cref="WebProtocolException">Thrown when the service returns a generic protocol error</exception>
        /// <exception cref="WebException">Thrown when the transaction could not be completed</exception>
        public static string ExecuteServiceRequest(string uri, string method, NameValueCollection headers, string contentType, byte[] data, string contentMessage, TraceSource trace)
        {
            if (trace == null)
                trace = WebHelper.Tracer;

            //Generate a service request and fill it with our data
            HttpWebRequest request = (HttpWebRequest)WebRequest.Create(uri);
            request.Method = method;
            request.ContentType = contentType;
            request.Headers.Add(headers);
            request.ContentLength = (data == null) ? 0 : data.Length;
            if (data != null)
                request.WriteAllData(data);

            return ExecuteServiceRequest(request, contentMessage, trace);
        }

        /// <summary>
        /// Creates and sends an HTTP web request, and reads back the response as a string
        /// </summary>
        /// <param name="request">The request to send</param>
        /// <param name="contentMessage">An optional string-version of the request content, used for logging</param>
        /// <param name="trace">An optional tracing source to output debugging information to</param>
        /// <returns>The response from the service</returns>
        /// 
        /// <exception cref="ServiceException">Thrown when an exception occurred within the multiplayer service</exception>
        /// <exception cref="WebProtocolException">Thrown when the service returns a generic protocol error</exception>
        /// <exception cref="WebException">Thrown when the transaction could not be completed</exception>
        public static string ExecuteServiceRequest(HttpWebRequest request, string contentMessage, TraceSource trace)
        {
            if (trace == null)
                trace = WebHelper.Tracer;

            //Log the headers and content of the request
            string fullRequest = GetInformation(request) + contentMessage;
            trace.TraceEvent(TraceEventType.Verbose, 0, fullRequest);

            //Prepare to read the response as a string
            Func<Stream, string> responseReader = delegate(Stream stream)
            {
                using (StreamReader reader = new StreamReader(stream))
                    return reader.ReadToEnd();
            };

            //Send the request and read out the response
            string response = ExecuteWebRequest<string>(request, responseReader, trace);

            return response;
        }


        /// <summary>
        /// Sends an HTTP request and reads the response back using the specified function
        /// </summary>
        /// <typeparam name="T">The type of data contained in the content of the response</typeparam>
        /// <param name="request">The request to send</param>
        /// <param name="responseReader">A function used to read the response stream and convert it to the output type</param>
        /// <param name="trace">An optional tracing source to output debugging information to</param>
        /// <returns>If the request was a success, returns the value produced by the supplied reader function</returns>
        /// 
        /// <exception cref="ServiceException">Thrown when an exception occurred within the multiplayer service</exception>
        /// <exception cref="WebProtocolException">Thrown when the service returns a generic protocol error</exception>
        /// <exception cref="WebException">Thrown when the transaction could not be completed</exception>
        public static T ExecuteWebRequest<T>(HttpWebRequest request, Func<Stream, T> responseReader, TraceSource trace)
        {
            if (trace == null)
                trace = WebHelper.Tracer;

            T responseData = default(T);
            
            try
            {
                Stopwatch stopwatch = Stopwatch.StartNew();
                //Send the request and read out the response
                using (HttpWebResponse response = (HttpWebResponse)request.GetResponse())
                {
                    //Log latency
                    stopwatch.Stop();
                    trace.TraceEvent(TraceEventType.Information, 1, "Response obtained in {0}ms", stopwatch.ElapsedMilliseconds);

                    //Log the headers from the response
                    trace.TraceEvent(TraceEventType.Verbose, 0, GetInformation(response));

                    using (Stream responseStream = response.GetResponseStream())
                    {
                        //Used the supplied reader to examine the response contents
                        responseData = responseReader(responseStream);

                        //Log the response contents
                        trace.TraceEvent(TraceEventType.Verbose, 0, responseData.ToString() + Environment.NewLine);
                    }
                }
            }
            catch (WebException webErr)
            {
                //If we have a protocol error, we can read the error's response to figure out
                //what happened and rethrow with a customized exception.
                if (webErr.Status == WebExceptionStatus.ProtocolError)
                {
                    HandleProtocolError(webErr, trace);
                }
                else
                {
                    throw;
                }
            }

            return responseData;
        }

        #endregion

        #region WebException handling

        /// <summary>
        /// Attempts to read the contents of a web exception's response and turn them into
        /// a customized exception, which is then thrown
        /// </summary>
        /// <param name="webException">The exception to examine</param>
        /// <param name="trace">The output for any diagnostic information</param>
        /// 
        /// <exception cref="ServiceException">Thrown when the error was thrown by an internal multiplayer service</exception>
        /// <exception cref="WebProtocolException">Thrown in any other case</exception>
        private static void HandleProtocolError(WebException webException, TraceSource trace)
        {
            using (WebResponse response = webException.Response)
            {
                //Log the headers of the error message
                trace.TraceEvent(TraceEventType.Error, 0, GetInformation(response));

                using (StreamReader errReader = new StreamReader(response.GetResponseStream()))
                {
                    //Just read the response content as a string
                    string errorData = errReader.ReadToEnd();

                    //Log the content of the error message
                    trace.TraceEvent(TraceEventType.Error, 0, errorData + Environment.NewLine);

                    //Attempt to turn the result into a useful exception
                    ThrowCustomWebException(webException, errorData, trace);
                }
            }
        }

        /// <summary>
        /// Turns the contents of a web exception caused by protocol error into a more useful exception
        /// </summary>
        /// <param name="originalException"></param>
        /// <param name="errorResponse"></param>
        /// <param name="trace">The output for diagnostic information</param>
        /// <exception cref="ServiceException">Thrown when the error was thrown by an internal multiplayer service</exception>
        /// <exception cref="WebProtocolException">Thrown in any other case</exception>
        private static void ThrowCustomWebException(WebException originalException, string errorResponse, TraceSource trace)
        {
            //Since we've read out the response data and the stream is closed so we can't do that again, we should
            //make a pretty exception containing the data
            ServiceErrorMessage errorMsg = null;
            try
            {
                errorMsg = SerializationHelper.DeserializeDataContract<ServiceErrorMessage>(errorResponse);
            }
            catch (Exception)
            {
                trace.TraceInformation("Could not read a service error message from the response. This may mean that " +
                "either the error response was not a service error, or that we tried to parse it incorrectly.");
            }

            if (errorMsg != null)
                throw new ServiceException(errorMsg, originalException);
            else
                throw new WebProtocolException(errorResponse, originalException);
        }

        #endregion

        #region Logging Helpers

        /// <summary>
        /// Retrieves the method, headers, and other metadata about a web request
        /// </summary>
        /// <param name="request">The request to extract data from</param>
        /// <returns>A formatted string containing the information</returns>
        public static string GetInformation(WebRequest request)
        {
            StringBuilder sb = new StringBuilder();

            sb.AppendLine("Request: ");

            HttpWebRequest httpRequest = request as HttpWebRequest;
            if (httpRequest != null)
            {
                sb.AppendFormat("{0} {1} HTTP/{2}", httpRequest.Method, httpRequest.RequestUri, httpRequest.ProtocolVersion.ToString());
            }
            else
            {
                sb.AppendFormat("{0} {1}", request.Method, request.RequestUri);
            }

            sb.AppendLine();
            foreach (string header in request.Headers)
            {
                sb.AppendFormat("{0}: {1}", header, request.Headers[header]);
                sb.AppendLine();
            }

            return sb.ToString();
        }

        /// <summary>
        /// Retrieves the method, headers, and other metadata about a web response
        /// </summary>
        /// <param name="response">The response to extract data from</param>
        /// <returns>A formatted string containing the information</returns>
        public static string GetInformation(WebResponse response)
        {
            StringBuilder sb = new StringBuilder();

            sb.AppendLine("Response: ");

            HttpWebResponse httpResponse = response as HttpWebResponse;
            if (httpResponse != null)
            {
                sb.AppendFormat("HTTP/{0} {1} {2}", httpResponse.ProtocolVersion, (int)httpResponse.StatusCode, httpResponse.StatusDescription);
            }

            sb.AppendLine();
            foreach (string header in response.Headers)
            {
                sb.AppendFormat("{0}: {1}", header, response.Headers[header]);
                sb.AppendLine();
            }
            
            return sb.ToString();
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardFramework\Cache\INotificationSystem.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using AsyncMultiplayer.NotificationService;
using OneCardFramework.Services;

namespace OneCardFramework.Cache
{
    /// <summary>
    /// Interface for a notifications storage and tracking system. Consumers
    /// should be aware that events may be fired on background threads.
    /// </summary>
    public interface INotificationSystem
    {
        /// <summary>
        /// Raised when a notification is added to the local cache
        /// </summary>
        event EventHandler<NotificationEventArgs> NotificationAdded;

        /// <summary>
        /// Raised when new data arrives for an existing notification
        /// </summary>
        event EventHandler<NotificationEventArgs> NotificationUpdated;

        /// <summary>
        /// Raised when a notification is removed from the local cache
        /// </summary>
        event EventHandler<NotificationEventArgs> NotificationRemoved;

        /// <summary>
        /// Load a set of notifications into the local cache starting at the given ID
        /// </summary>
        /// <param name="lastID">The ID of the notification to start at, non-inclusive</param>
        /// <param name="maxCount">The maximum number of notifications to return</param>
        void LoadNotificationsChunk(string lastID, int maxCount);

        /// <summary>
        /// Load all notifications into the local cache 
        /// </summary>
        void LoadAllNotifications();

        /// <summary>
        /// Gets the current local cache of notifications. Does not perform any loading.
        /// </summary>
        /// <returns></returns>
        ICollection<Notification> GetAllNotifications();

        /// <summary>
        /// Checks whether a notification is contained in the local cache
        /// </summary>
        /// <param name="notification"></param>
        /// <returns></returns>
        bool ContainsNotification(Notification notification);

        /// <summary>
        /// Deletes a notification from the server and the local cache
        /// </summary>
        /// <param name="notification"></param>
        void Delete(Notification notification);
    }

    public class NotificationEventArgs : EventArgs
    {
        public Notification Notification { get; private set; }

        public NotificationEventArgs(Notification notif)
        {
            Notification = notif;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardFramework\Cache\ISessionSystem.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using AsyncMultiplayer.SessionCommon;
using OneCardFramework.Game;

namespace OneCardFramework.Cache
{
    /// <summary>
    /// Interface for a session data storage and tracking system.
    /// </summary>
    public interface ISessionSystem
    {
        event EventHandler<SessionSummaryEventArgs> SummaryAdded;
        event EventHandler<SessionSummaryEventArgs> SummaryUpdated;
        event EventHandler<SessionSummaryEventArgs> SummaryRemoved;
        event EventHandler<SessionDetailEventArgs> DetailAdded;
        event EventHandler<SessionDetailEventArgs> DetailUpdated;
        event EventHandler<SessionDetailEventArgs> DetailRemoved;
        event EventHandler<GameEventArgs> GameAdded;
        event EventHandler<GameEventArgs> GameRemoved;
        event EventHandler<GameEventArgs> PlayRequested;

        
        void LoadSummariesChunk(string lastID, int maxCount);
        void LoadAllSummaries();

        ICollection<SessionEntry> GetAllSummaries(bool refresh);
        SessionState GetDetail(string sessionID, bool refresh);

        /// <summary>
        /// Checks whether we support a game configuration object of a given type
        /// </summary>
        /// <param name="type">The type of the configuration object</param>
        /// <returns>True if supported. False otherwise.</returns>
        bool SupportsConfig(Type type);

        /// <summary>
        /// Creates a game session using the supplied config
        /// </summary>
        /// <param name="config">The object to use for configuration</param>
        /// <returns>The session ID of the created session</returns>
        string CreateSession(object config);

        void JoinSession(string sessionID);
        void JoinSession(string sessionID, int seatIndex, byte[] seatParameters);
        void RequestPlay(string sessionID);
        void RequestLeave(string sessionID, bool notifyGame);

        bool SupportsGame(Type type);
        IGame AcquireGame(string sessionID);

        /// <summary>
        /// Gets whether the session system is currently pulling down summary data
        /// </summary>
        bool IsLoadingSummaries { get; }
    }
    


    public class SessionSummaryEventArgs : EventArgs
    {
        public SessionEntry Summary { get; private set; }

        public SessionSummaryEventArgs(SessionEntry entry)
        {
            Summary = entry;
        }
    }

    public class SessionDetailEventArgs : EventArgs
    {
        public SessionState Detail { get; private set; }

        public SessionDetailEventArgs(SessionState detail)
        {
            Detail = detail;
        }
    }

    public class GameSessionEventArgs : EventArgs
    {
        public GameSession Session { get; private set; }

        public GameSessionEventArgs(GameSession session)
        {
            Session = session;
        }
    }

    public class GameEventArgs : EventArgs
    {
        public IGame Game { get; private set; }

        public GameEventArgs(IGame game)
        {
            Game = game;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardFramework\Cache\NotificationStore.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using OneCardFramework.Services;
using OneCardFramework.Extensions;
using OneCardFramework.Configuration;
using AsyncMultiplayer.NotificationService;
using System.Diagnostics;
using System.Timers;
using System.Threading;
using OneCardFramework.Events;

namespace OneCardFramework.Cache
{
    /// <summary>
    /// A thread-safe local cache of notifications retrieved from the notification
    /// service
    /// </summary>
    public class NotificationStore : INotificationSystem
    {
        public static readonly TraceSource NotificationTrace = new TraceSource("OneCardFramework.Cache.NotificationTrace", SourceLevels.Verbose);

        #region Events
        /// <summary>
        /// Fired when a notification is added to the local cache. May occur on a background thread.
        /// Uses weak events internally.
        /// </summary>
        public event EventHandler<NotificationEventArgs> NotificationAdded
        {
            //Use weak events
            add { _notificationAdded += value.MakeWeak(n => _notificationAdded -= n); }
            remove { EventManager.Remove(ref _notificationAdded, value); }
        }
        private EventHandler<NotificationEventArgs> _notificationAdded;

        /// <summary>
        /// Fired when data for a notification is re-downloaded. May occur on a background thread.
        /// Uses weak events internally.
        /// </summary>
        public event EventHandler<NotificationEventArgs> NotificationUpdated
        {
            //Use weak events
            add { _notificationUpdated += value.MakeWeak(n => _notificationUpdated -= n); }
            remove { EventManager.Remove(ref _notificationUpdated, value); }
        }
        private EventHandler<NotificationEventArgs> _notificationUpdated;

        /// <summary>
        /// Fired when a notification is removed from the local cache. May occur on a background thread.
        /// Uses weak events internally.
        /// </summary>
        public event EventHandler<NotificationEventArgs> NotificationRemoved
        {
            //Use weak events
            add { _notificationRemoved += value.MakeWeak(n => _notificationRemoved -= n); }
            remove { EventManager.Remove(ref _notificationRemoved, value); }
        }
        private EventHandler<NotificationEventArgs> _notificationRemoved;
        #endregion

        #region Members

        //Cache notifications by ID
        private Dictionary<string, Notification> _notifCache;
        private readonly object _cacheLock;

        //Data necessary for service communication
        private User _user;
        private MultiplayerServiceConfig _serviceConfig;

        //Auto-load timer
        private AutoLoader _autoLoader;

        //Ensure that only one service operation (load/delete/etc) happens at a time,
        //so that we don't have conflicting data
        private readonly object _operationLock;

        //We queue up events so that they get fired in the correct order
        //regardless of threading
        private OperationQueue _eventQueue;

        #endregion

        /// <summary>
        /// Creates the store
        /// </summary>
        /// <param name="user">The user whose notification we are tracking</param>
        /// <param name="config">The configuration needed to reach the notifications service</param>
        public NotificationStore(User user, MultiplayerServiceConfig config)
        {
            _user = user;
            _serviceConfig = config;

            _notifCache = new Dictionary<string, Notification>();
            _cacheLock = new object();
            _operationLock = new object();

            //Setup the notifications polling system
            _autoLoader = new AutoLoader("Notifications Auto-Load", LoadAllNotifications);

            //Startup the event consumer thread, which will run indefinitely
            _eventQueue = new OperationQueue("Notification Events");            
        }



        #region Helpers

        #region Loading

        /// <summary>
        /// Gets a stream of all available notifications, cal