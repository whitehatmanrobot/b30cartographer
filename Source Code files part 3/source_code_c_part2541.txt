UTTON3CHG      0x0400
#define JOY_BUTTON4CHG      0x0800

/* constants used with JOYINFOEX */
#define JOY_BUTTON5         0x00000010l
#define JOY_BUTTON6         0x00000020l
#define JOY_BUTTON7         0x00000040l
#define JOY_BUTTON8         0x00000080l
#define JOY_BUTTON9         0x00000100l
#define JOY_BUTTON10        0x00000200l
#define JOY_BUTTON11        0x00000400l
#define JOY_BUTTON12        0x00000800l
#define JOY_BUTTON13        0x00001000l
#define JOY_BUTTON14        0x00002000l
#define JOY_BUTTON15        0x00004000l
#define JOY_BUTTON16        0x00008000l
#define JOY_BUTTON17        0x00010000l
#define JOY_BUTTON18        0x00020000l
#define JOY_BUTTON19        0x00040000l
#define JOY_BUTTON20        0x00080000l
#define JOY_BUTTON21        0x00100000l
#define JOY_BUTTON22        0x00200000l
#define JOY_BUTTON23        0x00400000l
#define JOY_BUTTON24        0x00800000l
#define JOY_BUTTON25        0x01000000l
#define JOY_BUTTON26        0x02000000l
#define JOY_BUTTON27        0x04000000l
#define JOY_BUTTON28        0x08000000l
#define JOY_BUTTON29        0x10000000l
#define JOY_BUTTON30        0x20000000l
#define JOY_BUTTON31        0x40000000l
#define JOY_BUTTON32        0x80000000l

/* constants used with JOYINFOEX structure */
#define JOY_POVCENTERED		(WORD) -1
#define JOY_POVFORWARD		0
#define JOY_POVRIGHT		9000
#define JOY_POVBACKWARD		18000
#define JOY_POVLEFT		27000

#define JOY_RETURNX		0x00000001l
#define JOY_RETURNY		0x00000002l
#define JOY_RETURNZ		0x00000004l
#define JOY_RETURNR		0x00000008l
#define JOY_RETURNU		0x00000010l	/* axis 5 */
#define JOY_RETURNV		0x00000020l	/* axis 6 */
#define JOY_RETURNPOV		0x00000040l
#define JOY_RETURNBUTTONS	0x00000080l
#define JOY_RETURNRAWDATA	0x00000100l
#define JOY_RETURNPOVCTS	0x00000200l
#define JOY_RETURNCENTERED	0x00000400l
#define JOY_USEDEADZONE		0x00000800l
#define JOY_RETURNALL		(JOY_RETURNX | JOY_RETURNY | JOY_RETURNZ | \
				 JOY_RETURNR | JOY_RETURNU | JOY_RETURNV | \
				 JOY_RETURNPOV | JOY_RETURNBUTTONS)
#define JOY_CAL_READALWAYS	0x00010000l
#define JOY_CAL_READXYONLY	0x00020000l
#define JOY_CAL_READ3		0x00040000l
#define JOY_CAL_READ4		0x00080000l
#define JOY_CAL_READXONLY	0x00100000l
#define JOY_CAL_READYONLY	0x00200000l
#define JOY_CAL_READ5		0x00400000l
#define JOY_CAL_READ6		0x00800000l
#define JOY_CAL_READZONLY	0x01000000l
#define JOY_CAL_READRONLY	0x02000000l
#define JOY_CAL_READUONLY	0x04000000l
#define JOY_CAL_READVONLY	0x08000000l

/* joystick ID constants */
#define JOYSTICKID1         0
#define JOYSTICKID2         1

/* joystick driver capabilites */
#define JOYCAPS_HASZ		0x0001
#define JOYCAPS_HASR		0x0002
#define JOYCAPS_HASU		0x0004
#define JOYCAPS_HASV		0x0008
#define JOYCAPS_HASPOV		0x0010
#define JOYCAPS_POV4DIR		0x0020
#define JOYCAPS_POVCTS		0x0040

/* joystick device capabilities data structure */
#ifdef _WIN32

typedef struct tagJOYCAPSA {
    WORD    wMid;                /* manufacturer ID */
    WORD    wPid;                /* product ID */
    CHAR    szPname[MAXPNAMELEN];/* product name (NULL terminated string) */
    UINT    wXmin;               /* minimum x position value */
    UINT    wXmax;               /* maximum x position value */
    UINT    wYmin;               /* minimum y position value */
    UINT    wYmax;               /* maximum y position value */
    UINT    wZmin;               /* minimum z position value */
    UINT    wZmax;               /* maximum z position value */
    UINT    wNumButtons;         /* number of buttons */
    UINT    wPeriodMin;          /* minimum message period when captured */
    UINT    wPeriodMax;          /* maximum message period when captured */
#if (WINVER >= 0x0400)
    UINT    wRmin;               /* minimum r position value */
    UINT    wRmax;               /* maximum r position value */
    UINT    wUmin;               /* minimum u (5th axis) position value */
    UINT    wUmax;               /* maximum u (5th axis) position value */
    UINT    wVmin;               /* minimum v (6th axis) position value */
    UINT    wVmax;               /* maximum v (6th axis) position value */
    UINT    wCaps;	 	 /* joystick capabilites */
    UINT    wMaxAxes;	 	 /* maximum number of axes supported */
    UINT    wNumAxes;	 	 /* number of axes in use */
    UINT    wMaxButtons;	 /* maximum number of buttons supported */
    CHAR    szRegKey[MAXPNAMELEN];/* registry key */
    CHAR    szOEMVxD[MAX_JOYSTICKOEMVXDNAME]; /* OEM VxD in use */
#endif
} JOYCAPSA, *PJOYCAPSA, *NPJOYCAPSA, *LPJOYCAPSA;
typedef struct tagJOYCAPSW {
    WORD    wMid;                /* manufacturer ID */
    WORD    wPid;                /* product ID */
    WCHAR   szPname[MAXPNAMELEN];/* product name (NULL terminated string) */
    UINT    wXmin;               /* minimum x position value */
    UINT    wXmax;               /* maximum x position value */
    UINT    wYmin;               /* minimum y position value */
    UINT    wYmax;               /* maximum y position value */
    UINT    wZmin;               /* minimum z position value */
    UINT    wZmax;               /* maximum z position value */
    UINT    wNumButtons;         /* number of buttons */
    UINT    wPeriodMin;          /* minimum message period when captured */
    UINT    wPeriodMax;          /* maximum message period when captured */
#if (WINVER >= 0x0400)
    UINT    wRmin;               /* minimum r position value */
    UINT    wRmax;               /* maximum r position value */
    UINT    wUmin;               /* minimum u (5th axis) position value */
    UINT    wUmax;               /* maximum u (5th axis) position value */
    UINT    wVmin;               /* minimum v (6th axis) position value */
    UINT    wVmax;               /* maximum v (6th axis) position value */
    UINT    wCaps;	 	 /* joystick capabilites */
    UINT    wMaxAxes;	 	 /* maximum number of axes supported */
    UINT    wNumAxes;	 	 /* number of axes in use */
    UINT    wMaxButtons;	 /* maximum number of buttons supported */
    WCHAR   szRegKey[MAXPNAMELEN];/* registry key */
    WCHAR   szOEMVxD[MAX_JOYSTICKOEMVXDNAME]; /* OEM VxD in use */
#endif
} JOYCAPSW, *PJOYCAPSW, *NPJOYCAPSW, *LPJOYCAPSW;
#ifdef UNICODE
typedef JOYCAPSW JOYCAPS;
typedef PJOYCAPSW PJOYCAPS;
typedef NPJOYCAPSW NPJOYCAPS;
typedef LPJOYCAPSW LPJOYCAPS;
#else
typedef JOYCAPSA JOYCAPS;
typedef PJOYCAPSA PJOYCAPS;
typedef NPJOYCAPSA NPJOYCAPS;
typedef LPJOYCAPSA LPJOYCAPS;
#endif // UNICODE

#else
typedef struct joycaps_tag {
    WORD wMid;                  /* manufacturer ID */
    WORD wPid;                  /* product ID */
    char szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    UINT wXmin;                 /* minimum x position value */
    UINT wXmax;                 /* maximum x position value */
    UINT wYmin;                 /* minimum y position value */
    UINT wYmax;                 /* maximum y position value */
    UINT wZmin;                 /* minimum z position value */
    UINT wZmax;                 /* maximum z position value */
    UINT wNumButtons;           /* number of buttons */
    UINT wPeriodMin;            /* minimum message period when captured */
    UINT wPeriodMax;            /* maximum message period when captured */
#if (WINVER >= 0x0400)
    UINT wRmin;                 /* minimum r position value */
    UINT wRmax;                 /* maximum r position value */
    UINT wUmin;                 /* minimum u (5th axis) position value */
    UINT wUmax;                 /* maximum u (5th axis) position value */
    UINT wVmin;                 /* minimum v (6th axis) position value */
    UINT wVmax;                 /* maximum v (6th axis) position value */
    UINT wCaps;                 /* joystick capabilites */
    UINT wMaxAxes;	 	/* maximum number of axes supported */
    UINT wNumAxes;	 	/* number of axes in use */
    UINT wMaxButtons;	 	/* maximum number of buttons supported */
    char szRegKey[MAXPNAMELEN]; /* registry key */
    char szOEMVxD[MAX_JOYSTICKOEMVXDNAME]; /* OEM VxD in use */
#endif
} JOYCAPS, *PJOYCAPS, NEAR *NPJOYCAPS, FAR *LPJOYCAPS;
#endif

/* joystick information data structure */
typedef struct joyinfo_tag {
    UINT wXpos;                 /* x position */
    UINT wYpos;                 /* y position */
    UINT wZpos;                 /* z position */
    UINT wButtons;              /* button states */
} JOYINFO, *PJOYINFO, NEAR *NPJOYINFO, FAR *LPJOYINFO;

#if(WINVER >= 0x0400)
typedef struct joyinfoex_tag {
    DWORD dwSize;		 /* size of structure */
    DWORD dwFlags;		 /* flags to indicate what to return */
    DWORD dwXpos;                /* x position */
    DWORD dwYpos;                /* y position */
    DWORD dwZpos;                /* z position */
    DWORD dwRpos;		 /* rudder/4th axis position */
    DWORD dwUpos;		 /* 5th axis position */
    DWORD dwVpos;		 /* 6th axis position */
    DWORD dwButtons;             /* button states */
    DWORD dwButtonNumber;        /* current button number pressed */
    DWORD dwPOV;                 /* point of view state */
    DWORD dwReserved1;		 /* reserved for communication between winmm & driver */
    DWORD dwReserved2;		 /* reserved for future expansion */
} JOYINFOEX, *PJOYINFOEX, NEAR *NPJOYINFOEX, FAR *LPJOYINFOEX;
#endif /* WINVER >= 0x0400 */

#ifndef _WIN32_VXD

/* joystick function prototypes */
WINMMAPI UINT WINAPI joyGetNumDevs(void);
#ifdef _WIN32

WINMMAPI MMRESULT WINAPI joyGetDevCapsA(UINT uJoyID, LPJOYCAPSA pjc, UINT cbjc);
WINMMAPI MMRESULT WINAPI joyGetDevCapsW(UINT uJoyID, LPJOYCAPSW pjc, UINT cbjc);
#ifdef UNICODE
#define joyGetDevCaps  joyGetDevCapsW
#else
#define joyGetDevCaps  joyGetDevCapsA
#endif // !UNICODE

#else
MMRESULT WINAPI joyGetDevCaps(UINT uJoyID, LPJOYCAPS pjc, UINT cbjc);
#endif
WINMMAPI MMRESULT WINAPI joyGetPos(UINT uJoyID, LPJOYINFO pji);

#if(WINVER >= 0x0400)
WINMMAPI MMRESULT WINAPI joyGetPosEx(UINT uJoyID, LPJOYINFOEX pji);
#endif /* WINVER >= 0x0400 */

WINMMAPI MMRESULT WINAPI joyGetThreshold(UINT uJoyID, LPUINT puThreshold);
WINMMAPI MMRESULT WINAPI joyReleaseCapture(UINT uJoyID);
WINMMAPI MMRESULT WINAPI joySetCapture(HWND hwnd, UINT uJoyID, UINT uPeriod,
    BOOL fChanged);
WINMMAPI MMRESULT WINAPI joySetThreshold(UINT uJoyID, UINT uThreshold);

#endif /* ifndef _WIN32_VXD */

#endif  /* ifndef MMNOJOY */

#ifndef MMNOMMIO
#ifndef _WIN32_VXD
/****************************************************************************

			Multimedia File I/O support

****************************************************************************/

/* MMIO error return values */
#define MMIOERR_BASE                256
#define MMIOERR_FILENOTFOUND        (MMIOERR_BASE + 1)  /* file not found */
#define MMIOERR_OUTOFMEMORY         (MMIOERR_BASE + 2)  /* out of memory */
#define MMIOERR_CANNOTOPEN          (MMIOERR_BASE + 3)  /* cannot open */
#define MMIOERR_CANNOTCLOSE         (MMIOERR_BASE + 4)  /* cannot close */
#define MMIOERR_CANNOTREAD          (MMIOERR_BASE + 5)  /* cannot read */
#define MMIOERR_CANNOTWRITE         (MMIOERR_BASE + 6)  /* cannot write */
#define MMIOERR_CANNOTSEEK          (MMIOERR_BASE + 7)  /* cannot seek */
#define MMIOERR_CANNOTEXPAND        (MMIOERR_BASE + 8)  /* cannot expand file */
#define MMIOERR_CHUNKNOTFOUND       (MMIOERR_BASE + 9)  /* chunk not found */
#define MMIOERR_UNBUFFERED          (MMIOERR_BASE + 10) /*  */
#define MMIOERR_PATHNOTFOUND        (MMIOERR_BASE + 11) /* path incorrect */
#define MMIOERR_ACCESSDENIED        (MMIOERR_BASE + 12) /* file was protected */
#define MMIOERR_SHARINGVIOLATION    (MMIOERR_BASE + 13) /* file in use */
#define MMIOERR_NETWORKERROR        (MMIOERR_BASE + 14) /* network not responding */
#define MMIOERR_TOOMANYOPENFILES    (MMIOERR_BASE + 15) /* no more file handles  */
#define MMIOERR_INVALIDFILE         (MMIOERR_BASE + 16) /* default error file error */

/* MMIO constants */
#define CFSEPCHAR       '+'             /* compound file name separator char. */

/* MMIO data types */
typedef DWORD           FOURCC;         /* a four character code */
typedef char _huge *    HPSTR;          /* a huge version of LPSTR */
DECLARE_HANDLE(HMMIO);                  /* a handle to an open file */
typedef LRESULT (CALLBACK MMIOPROC)(LPSTR lpmmioinfo, UINT uMsg,
	    LPARAM lParam1, LPARAM lParam2);
typedef MMIOPROC FAR *LPMMIOPROC;

/* general MMIO information data structure */
typedef struct _MMIOINFO
{
	/* general fields */
	DWORD           dwFlags;        /* general status flags */
	FOURCC          fccIOProc;      /* pointer to I/O procedure */
	LPMMIOPROC      pIOProc;        /* pointer to I/O procedure */
	UINT            wErrorRet;      /* place for error to be returned */
	HTASK           htask;          /* alternate local task */

	/* fields maintained by MMIO functions during buffered I/O */
	LONG            cchBuffer;      /* size of I/O buffer (or 0L) */
	HPSTR           pchBuffer;      /* start of I/O buffer (or NULL) */
	HPSTR           pchNext;        /* pointer to next byte to read/write */
	HPSTR           pchEndRead;     /* pointer to last valid byte to read */
	HPSTR           pchEndWrite;    /* pointer to last byte to write */
	LONG            lBufOffset;     /* disk offset of start of buffer */

	/* fields maintained by I/O procedure */
	LONG            lDiskOffset;    /* disk offset of next read or write */
	DWORD           adwInfo[3];     /* data specific to type of MMIOPROC */

	/* other fields maintained by MMIO */
	DWORD           dwReserved1;    /* reserved for MMIO use */
	DWORD           dwReserved2;    /* reserved for MMIO use */
	HMMIO           hmmio;          /* handle to open file */
} MMIOINFO, *PMMIOINFO, NEAR *NPMMIOINFO, FAR *LPMMIOINFO;
typedef const MMIOINFO FAR *LPCMMIOINFO;

/* RIFF chunk information data structure */
typedef struct _MMCKINFO
{
	FOURCC          ckid;           /* chunk ID */
	DWORD           cksize;         /* chunk size */
	FOURCC          fccType;        /* form type or list type */
	DWORD           dwDataOffset;   /* offset of data portion of chunk */
	DWORD           dwFlags;        /* flags used by MMIO functions */
} MMCKINFO, *PMMCKINFO, NEAR *NPMMCKINFO, FAR *LPMMCKINFO;
typedef const MMCKINFO *LPCMMCKINFO;

/* bit field masks */
#define MMIO_RWMODE     0x00000003      /* open file for reading/writing/both */
#define MMIO_SHAREMODE  0x00000070      /* file sharing mode number */

/* constants for dwFlags field of MMIOINFO */
#define MMIO_CREATE     0x00001000      /* create new file (or truncate file) */
#define MMIO_PARSE      0x00000100      /* parse new file returning path */
#define MMIO_DELETE     0x00000200      /* create new file (or truncate file) */
#define MMIO_EXIST      0x00004000      /* checks for existence of file */
#define MMIO_ALLOCBUF   0x00010000      /* mmioOpen() should allocate a buffer */
#define MMIO_GETTEMP    0x00020000      /* mmioOpen() should retrieve temp name */

#define MMIO_DIRTY      0x10000000      /* I/O buffer is dirty */

/* read/write mode numbers (bit field MMIO_RWMODE) */
#define MMIO_READ       0x00000000      /* open file for reading only */
#define MMIO_WRITE      0x00000001      /* open file for writing only */
#define MMIO_READWRITE  0x00000002      /* open file for reading and writing */

/* share mode numbers (bit field MMIO_SHAREMODE) */
#define MMIO_COMPAT     0x00000000      /* compatibility mode */
#define MMIO_EXCLUSIVE  0x00000010      /* exclusive-access mode */
#define MMIO_DENYWRITE  0x00000020      /* deny writing to other processes */
#define MMIO_DENYREAD   0x00000030      /* deny reading to other processes */
#define MMIO_DENYNONE   0x00000040      /* deny nothing to other processes */

/* various MMIO flags */
#define MMIO_FHOPEN             0x0010  /* mmioClose: keep file handle open */
#define MMIO_EMPTYBUF           0x0010  /* mmioFlush: empty the I/O buffer */
#define MMIO_TOUPPER            0x0010  /* mmioStringToFOURCC: to u-case */
#define MMIO_INSTALLPROC    0x00010000  /* mmioInstallIOProc: install MMIOProc */
#define MMIO_GLOBALPROC     0x10000000  /* mmioInstallIOProc: install globally */
#define MMIO_REMOVEPROC     0x00020000  /* mmioInstallIOProc: remove MMIOProc */
#define MMIO_UNICODEPROC    0x01000000  /* mmioInstallIOProc: Unicode MMIOProc */
#define MMIO_FINDPROC       0x00040000  /* mmioInstallIOProc: find an MMIOProc */
#define MMIO_FINDCHUNK          0x0010  /* mmioDescend: find a chunk by ID */
#define MMIO_FINDRIFF           0x0020  /* mmioDescend: find a LIST chunk */
#define MMIO_FINDLIST           0x0040  /* mmioDescend: find a RIFF chunk */
#define MMIO_CREATERIFF         0x0020  /* mmioCreateChunk: make a LIST chunk */
#define MMIO_CREATELIST         0x0040  /* mmioCreateChunk: make a RIFF chunk */

/* message numbers for MMIOPROC I/O procedure functions */
#define MMIOM_READ      MMIO_READ       /* read */
#define MMIOM_WRITE    MMIO_WRITE       /* write */
#define MMIOM_SEEK              2       /* seek to a new position in file */
#define MMIOM_OPEN              3       /* open file */
#define MMIOM_CLOSE             4       /* close file */
#define MMIOM_WRITEFLUSH        5       /* write and flush */

#if (WINVER >= 0x030a)
#define MMIOM_RENAME            6       /* rename specified file */
#endif /* ifdef WINVER >= 0x030a */

#define MMIOM_USER         0x8000       /* beginning of user-defined messages */

/* standard four character codes */
#define FOURCC_RIFF     mmioFOURCC('R', 'I', 'F', 'F')
#define FOURCC_LIST     mmioFOURCC('L', 'I', 'S', 'T')

/* four character codes used to identify standard built-in I/O procedures */
#define FOURCC_DOS      mmioFOURCC('D', 'O', 'S', ' ')
#define FOURCC_MEM      mmioFOURCC('M', 'E', 'M', ' ')

/* flags for mmioSeek() */
#ifndef SEEK_SET
#define SEEK_SET        0               /* seek to an absolute position */
#define SEEK_CUR        1               /* seek relative to current position */
#define SEEK_END        2               /* seek relative to end of file */
#endif  /* ifndef SEEK_SET */

/* other constants */
#define MMIO_DEFAULTBUFFER      8192    /* default buffer size */

/* MMIO macros */
#ifndef mmioFOURCC
#define mmioFOURCC(ch0, ch1, ch2, ch3)  MAKEFOURCC(ch0, ch1, ch2, ch3)
#endif

/* MMIO function prototypes */
#ifdef _WIN32

WINMMAPI FOURCC WINAPI mmioStringToFOURCCA(LPCSTR sz, UINT uFlags);
WINMMAPI FOURCC WINAPI mmioStringToFOURCCW(LPCWSTR sz, UINT uFlags);
#ifdef UNICODE
#define mmioStringToFOURCC  mmioStringToFOURCCW
#else
#define mmioStringToFOURCC  mmioStringToFOURCCA
#endif // !UNICODE
WINMMAPI LPMMIOPROC WINAPI mmioInstallIOProcA(FOURCC fccIOProc, LPMMIOPROC pIOProc, DWORD dwFlags);
WINMMAPI LPMMIOPROC WINAPI mmioInstallIOProcW(FOURCC fccIOProc, LPMMIOPROC pIOProc, DWORD dwFlags);
#ifdef UNICODE
#define mmioInstallIOProc  mmioInstallIOProcW
#else
#define mmioInstallIOProc  mmioInstallIOProcA
#endif // !UNICODE
WINMMAPI HMMIO WINAPI mmioOpenA(LPSTR pszFileName, LPMMIOINFO pmmioinfo, DWORD fdwOpen);
WINMMAPI HMMIO WINAPI mmioOpenW(LPWSTR pszFileName, LPMMIOINFO pmmioinfo, DWORD fdwOpen);
#ifdef UNICODE
#define mmioOpen  mmioOpenW
#else
#define mmioOpen  mmioOpenA
#endif // !UNICODE
WINMMAPI MMRESULT WINAPI mmioRenameA(LPCSTR pszFileName, LPCSTR pszNewFileName, LPCMMIOINFO pmmioinfo, DWORD fdwRename);
WINMMAPI MMRESULT WINAPI mmioRenameW(LPCWSTR pszFileName, LPCWSTR pszNewFileName, LPCMMIOINFO pmmioinfo, DWORD fdwRename);
#ifdef UNICODE
#define mmioRename  mmioRenameW
#else
#define mmioRename  mmioRenameA
#endif // !UNICODE
#else
FOURCC WINAPI mmioStringToFOURCC(LPCSTR sz, UINT uFlags);
LPMMIOPROC WINAPI mmioInstallIOProc(FOURCC fccIOProc, LPMMIOPROC pIOProc, DWORD dwFlags);
HMMIO WINAPI mmioOpen(LPSTR pszFileName, LPMMIOINFO pmmioinfo, DWORD fdwOpen);
#if (WINVER >= 0x030a)
MMRESULT WINAPI mmioRename(LPCSTR pszFileName, LPCSTR pszNewFileName, const MMIOINFO FAR* pmmioinfo, DWORD fdwRename);
#endif /* ifdef WINVER >= 0x030a */
#endif

WINMMAPI MMRESULT WINAPI mmioClose(HMMIO hmmio, UINT fuClose);
WINMMAPI LONG WINAPI mmioRead(HMMIO hmmio, HPSTR pch, LONG cch);
WINMMAPI LONG WINAPI mmioWrite(HMMIO hmmio, const char _huge* pch, LONG cch);
WINMMAPI LONG WINAPI mmioSeek(HMMIO hmmio, LONG lOffset, int iOrigin);
WINMMAPI MMRESULT WINAPI mmioGetInfo(HMMIO hmmio, LPMMIOINFO pmmioinfo, UINT fuInfo);
WINMMAPI MMRESULT WINAPI mmioSetInfo(HMMIO hmmio, LPCMMIOINFO pmmioinfo, UINT fuInfo);
WINMMAPI MMRESULT WINAPI mmioSetBuffer(HMMIO hmmio, LPSTR pchBuffer, LONG cchBuffer,
    UINT fuBuffer);
WINMMAPI MMRESULT WINAPI mmioFlush(HMMIO hmmio, UINT fuFlush);
WINMMAPI MMRESULT WINAPI mmioAdvance(HMMIO hmmio, LPMMIOINFO pmmioinfo, UINT fuAdvance);
WINMMAPI LRESULT WINAPI mmioSendMessage(HMMIO hmmio, UINT uMsg,
    LPARAM lParam1, LPARAM lParam2);
WINMMAPI MMRESULT WINAPI mmioDescend(HMMIO hmmio, LPMMCKINFO pmmcki,
    const MMCKINFO FAR* pmmckiParent, UINT fuDescend);
WINMMAPI MMRESULT WINAPI mmioAscend(HMMIO hmmio, LPMMCKINFO pmmcki, UINT fuAscend);
WINMMAPI MMRESULT WINAPI mmioCreateChunk(HMMIO hmmio, LPMMCKINFO pmmcki, UINT fuCreate);

#endif  /* ifndef _WIN32_VXD */
#endif  /* ifndef MMNOMMIO */

#ifndef MMNOMCI
#ifndef _WIN32_VXD
/****************************************************************************

			    MCI support

****************************************************************************/

#ifndef _MCIERROR_              /* MCIERROR is defined in some post 3.1 apps */
#define _MCIERROR_
typedef DWORD   MCIERROR;       /* error return code, 0 means no error */
#endif

#ifndef _MCIDEVICEID_           /* Same with MCIDEVICEID */
#define _MCIDEVICEID_
typedef UINT    MCIDEVICEID;    /* MCI device ID type */
#endif

typedef UINT (CALLBACK *YIELDPROC)(MCIDEVICEID mciId, DWORD dwYieldData);

/* MCI function prototypes */
#ifdef _WIN32

WINMMAPI MCIERROR WINAPI mciSendCommandA(MCIDEVICEID mciId, UINT uMsg, DWORD dwParam1, DWORD dwParam2);
WINMMAPI MCIERROR WINAPI mciSendCommandW(MCIDEVICEID mciId, UINT uMsg, DWORD dwParam1, DWORD dwParam2);
#ifdef UNICODE
#define mciSendCommand  mciSendCommandW
#else
#define mciSendCommand  mciSendCommandA
#endif // !UNICODE
WINMMAPI MCIERROR  WINAPI mciSendStringA(LPCSTR lpstrCommand, LPSTR lpstrReturnString, UINT uReturnLength, HWND hwndCallback);
WINMMAPI MCIERROR  WINAPI mciSendStringW(LPCWSTR lpstrCommand, LPWSTR lpstrReturnString, UINT uReturnLength, HWND hwndCallback);
#ifdef UNICODE
#define mciSendString  mciSendStringW
#else
#define mciSendString  mciSendStringA
#endif // !UNICODE
WINMMAPI MCIDEVICEID WINAPI mciGetDeviceIDA(LPCSTR pszDevice);
WINMMAPI MCIDEVICEID WINAPI mciGetDeviceIDW(LPCWSTR pszDevice);
#ifdef UNICODE
#define mciGetDeviceID  mciGetDeviceIDW
#else
#define mciGetDeviceID  mciGetDeviceIDA
#endif // !UNICODE
WINMMAPI MCIDEVICEID WINAPI mciGetDeviceIDFromElementIDA(DWORD dwElementID, LPCSTR lpstrType );
WINMMAPI MCIDEVICEID WINAPI mciGetDeviceIDFromElementIDW(DWORD dwElementID, LPCWSTR lpstrType );
#ifdef UNICODE
#define mciGetDeviceIDFromElementID  mciGetDeviceIDFromElementIDW
#else
#define mciGetDeviceIDFromElementID  mciGetDeviceIDFromElementIDA
#endif // !UNICODE
WINMMAPI BOOL WINAPI mciGetErrorStringA(MCIERROR mcierr, LPSTR pszText, UINT cchText);
WINMMAPI BOOL WINAPI mciGetErrorStringW(MCIERROR mcierr, LPWSTR pszText, UINT cchText);
#ifdef UNICODE
#define mciGetErrorString  mciGetErrorStringW
#else
#define mciGetErrorString  mciGetErrorStringA
#endif // !UNICODE

#else
MCIERROR WINAPI mciSendCommand(MCIDEVICEID mciId, UINT uMsg, DWORD dwParam1, DWORD dwParam2);
MCIERROR  WINAPI mciSendString(LPCSTR lpstrCommand, LPSTR lpstrReturnString, UINT uReturnLength, HWND hwndCallback);
MCIDEVICEID WINAPI mciGetDeviceID(LPCSTR pszDevice);
BOOL WINAPI mciGetErrorString(MCIERROR mcierr, LPSTR pszText, UINT cchText);
#endif

WINMMAPI BOOL WINAPI mciSetYieldProc(MCIDEVICEID mciId, YIELDPROC fpYieldProc,
    DWORD dwYieldData);

#if (WINVER >= 0x030a)
WINMMAPI HTASK WINAPI mciGetCreatorTask(MCIDEVICEID mciId);
WINMMAPI YIELDPROC WINAPI mciGetYieldProc(MCIDEVICEID mciId, LPDWORD pdwYieldData);
#endif /* ifdef WINVER >= 0x030a */

#if (WINVER < 0x030a)
WINMMAPI BOOL WINAPI mciExecute(LPCSTR pszCommand);
#endif /* ifdef WINVER < 0x030a */

/* MCI error return values */
#define MCIERR_INVALID_DEVICE_ID        (MCIERR_BASE + 1)
#define MCIERR_UNRECOGNIZED_KEYWORD     (MCIERR_BASE + 3)
#define MCIERR_UNRECOGNIZED_COMMAND     (MCIERR_BASE + 5)
#define MCIERR_HARDWARE                 (MCIERR_BASE + 6)
#define MCIERR_INVALID_DEVICE_NAME      (MCIERR_BASE + 7)
#define MCIERR_OUT_OF_MEMORY            (MCIERR_BASE + 8)
#define MCIERR_DEVICE_OPEN              (MCIERR_BASE + 9)
#define MCIERR_CANNOT_LOAD_DRIVER       (MCIERR_BASE + 10)
#define MCIERR_MISSING_COMMAND_STRING   (MCIERR_BASE + 11)
#define MCIERR_PARAM_OVERFLOW           (MCIERR_BASE + 12)
#define MCIERR_MISSING_STRING_ARGUMENT  (MCIERR_BASE + 13)
#define MCIERR_BAD_INTEGER              (MCIERR_BASE + 14)
#define MCIERR_PARSER_INTERNAL          (MCIERR_BASE + 15)
#define MCIERR_DRIVER_INTERNAL          (MCIERR_BASE + 16)
#define MCIERR_MISSING_PARAMETER        (MCIERR_BASE + 17)
#define MCIERR_UNSUPPORTED_FUNCTION     (MCIERR_BASE + 18)
#define MCIERR_FILE_NOT_FOUND           (MCIERR_BASE + 19)
#define MCIERR_DEVICE_NOT_READY         (MCIERR_BASE + 20)
#define MCIERR_INTERNAL                 (MCIERR_BASE + 21)
#define MCIERR_DRIVER                   (MCIERR_BASE + 22)
#define MCIERR_CANNOT_USE_ALL           (MCIERR_BASE + 23)
#define MCIERR_MULTIPLE                 (MCIERR_BASE + 24)
#define MCIERR_EXTENSION_NOT_FOUND      (MCIERR_BASE + 25)
#define MCIERR_OUTOFRANGE               (MCIERR_BASE + 26)
#define MCIERR_FLAGS_NOT_COMPATIBLE     (MCIERR_BASE + 28)
#define MCIERR_FILE_NOT_SAVED           (MCIERR_BASE + 30)
#define MCIERR_DEVICE_TYPE_REQUIRED     (MCIERR_BASE + 31)
#define MCIERR_DEVICE_LOCKED            (MCIERR_BASE + 32)
#define MCIERR_DUPLICATE_ALIAS          (MCIERR_BASE + 33)
#define MCIERR_BAD_CONSTANT             (MCIERR_BASE + 34)
#define MCIERR_MUST_USE_SHAREABLE       (MCIERR_BASE + 35)
#define MCIERR_MISSING_DEVICE_NAME      (MCIERR_BASE + 36)
#define MCIERR_BAD_TIME_FORMAT          (MCIERR_BASE + 37)
#define MCIERR_NO_CLOSING_QUOTE         (MCIERR_BASE + 38)
#define MCIERR_DUPLICATE_FLAGS          (MCIERR_BASE + 39)
#define MCIERR_INVALID_FILE             (MCIERR_BASE + 40)
#define MCIERR_NULL_PARAMETER_BLOCK     (MCIERR_BASE + 41)
#define MCIERR_UNNAMED_RESOURCE         (MCIERR_BASE + 42)
#define MCIERR_NEW_REQUIRES_ALIAS       (MCIERR_BASE + 43)
#define MCIERR_NOTIFY_ON_AUTO_OPEN      (MCIERR_BASE + 44)
#define MCIERR_NO_ELEMENT_ALLOWED       (MCIERR_BASE + 45)
#define MCIERR_NONAPPLICABLE_FUNCTION   (MCIERR_BASE + 46)
#define MCIERR_ILLEGAL_FOR_AUTO_OPEN    (MCIERR_BASE + 47)
#define MCIERR_FILENAME_REQUIRED        (MCIERR_BASE + 48)
#define MCIERR_EXTRA_CHARACTERS         (MCIERR_BASE + 49)
#define MCIERR_DEVICE_NOT_INSTALLED     (MCIERR_BASE + 50)
#define MCIERR_GET_CD                   (MCIERR_BASE + 51)
#define MCIERR_SET_CD                   (MCIERR_BASE + 52)
#define MCIERR_SET_DRIVE                (MCIERR_BASE + 53)
#define MCIERR_DEVICE_LENGTH            (MCIERR_BASE + 54)
#define MCIERR_DEVICE_ORD_LENGTH        (MCIERR_BASE + 55)
#define MCIERR_NO_INTEGER               (MCIERR_BASE + 56)

#define MCIERR_WAVE_OUTPUTSINUSE        (MCIERR_BASE + 64)
#define MCIERR_WAVE_SETOUTPUTINUSE      (MCIERR_BASE + 65)
#define MCIERR_WAVE_INPUTSINUSE         (MCIERR_BASE + 66)
#define MCIERR_WAVE_SETINPUTINUSE       (MCIERR_BASE + 67)
#define MCIERR_WAVE_OUTPUTUNSPECIFIED   (MCIERR_BASE + 68)
#define MCIERR_WAVE_INPUTUNSPECIFIED    (MCIERR_BASE + 69)
#define MCIERR_WAVE_OUTPUTSUNSUITABLE   (MCIERR_BASE + 70)
#define MCIERR_WAVE_SETOUTPUTUNSUITABLE (MCIERR_BASE + 71)
#define MCIERR_WAVE_INPUTSUNSUITABLE    (MCIERR_BASE + 72)
#define MCIERR_WAVE_SETINPUTUNSUITABLE  (MCIERR_BASE + 73)

#define MCIERR_SEQ_DIV_INCOMPATIBLE     (MCIERR_BASE + 80)
#define MCIERR_SEQ_PORT_INUSE           (MCIERR_BASE + 81)
#define MCIERR_SEQ_PORT_NONEXISTENT     (MCIERR_BASE + 82)
#define MCIERR_SEQ_PORT_MAPNODEVICE     (MCIERR_BASE + 83)
#define MCIERR_SEQ_PORT_MISCERROR       (MCIERR_BASE + 84)
#define MCIERR_SEQ_TIMER                (MCIERR_BASE + 85)
#define MCIERR_SEQ_PORTUNSPECIFIED      (MCIERR_BASE + 86)
#define MCIERR_SEQ_NOMIDIPRESENT        (MCIERR_BASE + 87)

#define MCIERR_NO_WINDOW                (MCIERR_BASE + 90)
#define MCIERR_CREATEWINDOW             (MCIERR_BASE + 91)
#define MCIERR_FILE_READ                (MCIERR_BASE + 92)
#define MCIERR_FILE_WRITE               (MCIERR_BASE + 93)

#define MCIERR_NO_IDENTITY              (MCIERR_BASE + 94)

/* all custom device driver errors must be >= than this value */
#define MCIERR_CUSTOM_DRIVER_BASE       (MCIERR_BASE + 256)

#define MCI_FIRST                       DRV_MCI_FIRST   /* 0x0800 */
/* MCI command message identifiers */
#define MCI_OPEN                        0x0803
#define MCI_CLOSE                       0x0804
#define MCI_ESCAPE                      0x0805
#define MCI_PLAY                        0x0806
#define MCI_SEEK                        0x0807
#define MCI_STOP                        0x0808
#define MCI_PAUSE                       0x0809
#define MCI_INFO                        0x080A
#define MCI_GETDEVCAPS                  0x080B
#define MCI_SPIN                        0x080C
#define MCI_SET                         0x080D
#define MCI_STEP                        0x080E
#define MCI_RECORD                      0x080F
#define MCI_SYSINFO                     0x0810
#define MCI_BREAK                       0x0811
#define MCI_SAVE                        0x0813
#define MCI_STATUS                      0x0814
#define MCI_CUE                         0x0830
#define MCI_REALIZE                     0x0840
#define MCI_WINDOW                      0x0841
#define MCI_PUT                         0x0842
#define MCI_WHERE                       0x0843
#define MCI_FREEZE                      0x0844
#define MCI_UNFREEZE                    0x0845
#define MCI_LOAD                        0x0850
#define MCI_CUT                         0x0851
#define MCI_COPY                        0x0852
#define MCI_PASTE                       0x0853
#define MCI_UPDATE                      0x0854
#define MCI_RESUME                      0x0855
#define MCI_DELETE                      0x0856

/* all custom MCI command messages must be >= than this value */
#define MCI_USER_MESSAGES               (DRV_MCI_FIRST + 0x400)
#define MCI_LAST                        0x0FFF

/* device ID for "all devices" */
#define MCI_ALL_DEVICE_ID               ((MCIDEVICEID)-1)

/* constants for predefined MCI device types */
#define MCI_DEVTYPE_VCR                 513 /* (MCI_STRING_OFFSET + 1) */
#define MCI_DEVTYPE_VIDEODISC           514 /* (MCI_STRING_OFFSET + 2) */
#define MCI_DEVTYPE_OVERLAY             515 /* (MCI_STRING_OFFSET + 3) */
#define MCI_DEVTYPE_CD_AUDIO            516 /* (MCI_STRING_OFFSET + 4) */
#define MCI_DEVTYPE_DAT                 517 /* (MCI_STRING_OFFSET + 5) */
#define MCI_DEVTYPE_SCANNER             518 /* (MCI_STRING_OFFSET + 6) */
#define MCI_DEVTYPE_ANIMATION           519 /* (MCI_STRING_OFFSET + 7) */
#define MCI_DEVTYPE_DIGITAL_VIDEO       520 /* (MCI_STRING_OFFSET + 8) */
#define MCI_DEVTYPE_OTHER               521 /* (MCI_STRING_OFFSET + 9) */
#define MCI_DEVTYPE_WAVEFORM_AUDIO      522 /* (MCI_STRING_OFFSET + 10) */
#define MCI_DEVTYPE_SEQUENCER           523 /* (MCI_STRING_OFFSET + 11) */

#define MCI_DEVTYPE_FIRST               MCI_DEVTYPE_VCR
#define MCI_DEVTYPE_LAST                MCI_DEVTYPE_SEQUENCER

#define MCI_DEVTYPE_FIRST_USER          0x1000
/* return values for 'status mode' command */
#define MCI_MODE_NOT_READY              (MCI_STRING_OFFSET + 12)
#define MCI_MODE_STOP                   (MCI_STRING_OFFSET + 13)
#define MCI_MODE_PLAY                   (MCI_STRING_OFFSET + 14)
#define MCI_MODE_RECORD                 (MCI_STRING_OFFSET + 15)
#define MCI_MODE_SEEK                   (MCI_STRING_OFFSET + 16)
#define MCI_MODE_PAUSE                  (MCI_STRING_OFFSET + 17)
#define MCI_MODE_OPEN                   (MCI_STRING_OFFSET + 18)

/* constants used in 'set time format' and 'status time format' commands */
#define MCI_FORMAT_MILLISECONDS         0
#define MCI_FORMAT_HMS                  1
#define MCI_FORMAT_MSF                  2
#define MCI_FORMAT_FRAMES               3
#define MCI_FORMAT_SMPTE_24             4
#define MCI_FORMAT_SMPTE_25             5
#define MCI_FORMAT_SMPTE_30             6
#define MCI_FORMAT_SMPTE_30DROP         7
#define MCI_FORMAT_BYTES                8
#define MCI_FORMAT_SAMPLES              9
#define MCI_FORMAT_TMSF                 10

/* MCI time format conversion macros */
#define MCI_MSF_MINUTE(msf)             ((BYTE)(msf))
#define MCI_MSF_SECOND(msf)             ((BYTE)(((WORD)(msf)) >> 8))
#define MCI_MSF_FRAME(msf)              ((BYTE)((msf)>>16))

#define MCI_MAKE_MSF(m, s, f)           ((DWORD)(((BYTE)(m) | \
						  ((WORD)(s)<<8)) | \
						 (((DWORD)(BYTE)(f))<<16)))

#define MCI_TMSF_TRACK(tmsf)            ((BYTE)(tmsf))
#define MCI_TMSF_MINUTE(tmsf)           ((BYTE)(((WORD)(tmsf)) >> 8))
#define MCI_TMSF_SECOND(tmsf)           ((BYTE)((tmsf)>>16))
#define MCI_TMSF_FRAME(tmsf)            ((BYTE)((tmsf)>>24))

#define MCI_MAKE_TMSF(t, m, s, f)       ((DWORD)(((BYTE)(t) | \
						  ((WORD)(m)<<8)) | \
						 (((DWORD)(BYTE)(s) | \
						   ((WORD)(f)<<8))<<16)))

#define MCI_HMS_HOUR(hms)               ((BYTE)(hms))
#define MCI_HMS_MINUTE(hms)             ((BYTE)(((WORD)(hms)) >> 8))
#define MCI_HMS_SECOND(hms)             ((BYTE)((hms)>>16))

#define MCI_MAKE_HMS(h, m, s)           ((DWORD)(((BYTE)(h) | \
						  ((WORD)(m)<<8)) | \
						 (((DWORD)(BYTE)(s))<<16)))

/* flags for wParam of MM_MCINOTIFY message */
#define MCI_NOTIFY_SUCCESSFUL           0x0001
#define MCI_NOTIFY_SUPERSEDED           0x0002
#define MCI_NOTIFY_ABORTED              0x0004
#define MCI_NOTIFY_FAILURE              0x0008

/* common flags for dwFlags parameter of MCI command messages */
#define MCI_NOTIFY                      0x00000001L
#define MCI_WAIT                        0x00000002L
#define MCI_FROM                        0x00000004L
#define MCI_TO                          0x00000008L
#define MCI_TRACK                       0x00000010L

/* flags for dwFlags parameter of MCI_OPEN command message */
#define MCI_OPEN_SHAREABLE              0x00000100L
#define MCI_OPEN_ELEMENT                0x00000200L
#define MCI_OPEN_ALIAS                  0x00000400L
#define MCI_OPEN_ELEMENT_ID             0x00000800L
#define MCI_OPEN_TYPE_ID                0x00001000L
#define MCI_OPEN_TYPE                   0x00002000L

/* flags for dwFlags parameter of MCI_SEEK command message */
#define MCI_SEEK_TO_START               0x00000100L
#define MCI_SEEK_TO_END                 0x00000200L

/* flags for dwFlags parameter of MCI_STATUS command message */
#define MCI_STATUS_ITEM                 0x00000100L
#define MCI_STATUS_START                0x00000200L

/* flags for dwItem field of the MCI_STATUS_PARMS parameter block */
#define MCI_STATUS_LENGTH               0x00000001L
#define MCI_STATUS_POSITION             0x00000002L
#define MCI_STATUS_NUMBER_OF_TRACKS     0x00000003L
#define MCI_STATUS_MODE                 0x00000004L
#define MCI_STATUS_MEDIA_PRESENT        0x00000005L
#define MCI_STATUS_TIME_FORMAT          0x00000006L
#define MCI_STATUS_READY                0x00000007L
#define MCI_STATUS_CURRENT_TRACK        0x00000008L

/* flags for dwFlags parameter of MCI_INFO command message */
#define MCI_INFO_PRODUCT                0x00000100L
#define MCI_INFO_FILE                   0x00000200L
#define MCI_INFO_MEDIA_UPC              0x00000400L
#define MCI_INFO_MEDIA_IDENTITY         0x00000800L
#define MCI_INFO_NAME                   0x00001000L
#define MCI_INFO_COPYRIGHT              0x00002000L

/* flags for dwFlags parameter of MCI_GETDEVCAPS command message */
#define MCI_GETDEVCAPS_ITEM             0x00000100L

/* flags for dwItem field of the MCI_GETDEVCAPS_PARMS parameter block */
#define MCI_GETDEVCAPS_CAN_RECORD       0x00000001L
#define MCI_GETDEVCAPS_HAS_AUDIO        0x00000002L
#define MCI_GETDEVCAPS_HAS_VIDEO        0x00000003L
#define MCI_GETDEVCAPS_DEVICE_TYPE      0x00000004L
#define MCI_GETDEVCAPS_USES_FILES       0x00000005L
#define MCI_GETDEVCAPS_COMPOUND_DEVICE  0x00000006L
#define MCI_GETDEVCAPS_CAN_EJECT        0x00000007L
#define MCI_GETDEVCAPS_CAN_PLAY         0x00000008L
#define MCI_GETDEVCAPS_CAN_SAVE         0x00000009L

/* flags for dwFlags parameter of MCI_SYSINFO command message */
#define MCI_SYSINFO_QUANTITY            0x00000100L
#define MCI_SYSINFO_OPEN                0x00000200L
#define MCI_SYSINFO_NAME                0x00000400L
#define MCI_SYSINFO_INSTALLNAME         0x00000800L

/* flags for dwFlags parameter of MCI_SET command message */
#define MCI_SET_DOOR_OPEN               0x00000100L
#define MCI_SET_DOOR_CLOSED             0x00000200L
#define MCI_SET_TIME_FORMAT             0x00000400L
#define MCI_SET_AUDIO                   0x00000800L
#define MCI_SET_VIDEO                   0x00001000L
#define MCI_SET_ON                      0x00002000L
#define MCI_SET_OFF                     0x00004000L

/* flags for dwAudio field of MCI_SET_PARMS or MCI_SEQ_SET_PARMS */
#define MCI_SET_AUDIO_ALL               0x00000000L
#define MCI_SET_AUDIO_LEFT              0x00000001L
#define MCI_SET_AUDIO_RIGHT             0x00000002L

/* flags for dwFlags parameter of MCI_BREAK command message */
#define MCI_BREAK_KEY                   0x00000100L
#define MCI_BREAK_HWND                  0x00000200L
#define MCI_BREAK_OFF                   0x00000400L

/* flags for dwFlags parameter of MCI_RECORD command message */
#define MCI_RECORD_INSERT               0x00000100L
#define MCI_RECORD_OVERWRITE            0x00000200L

/* flags for dwFlags parameter of MCI_SAVE command message */
#define MCI_SAVE_FILE                   0x00000100L

/* flags for dwFlags parameter of MCI_LOAD command message */
#define MCI_LOAD_FILE                   0x00000100L

/* generic parameter block for MCI command messages with no special parameters */
typedef struct tagMCI_GENERIC_PARMS {
    DWORD   dwCallback;
} MCI_GENERIC_PARMS, *PMCI_GENERIC_PARMS, FAR *LPMCI_GENERIC_PARMS;

/* parameter block for MCI_OPEN command message */
#ifdef _WIN32

typedef struct tagMCI_OPEN_PARMSA {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCSTR     lpstrDeviceType;
    LPCSTR     lpstrElementName;
    LPCSTR     lpstrAlias;
} MCI_OPEN_PARMSA, *PMCI_OPEN_PARMSA, *LPMCI_OPEN_PARMSA;
typedef struct tagMCI_OPEN_PARMSW {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCWSTR    lpstrDeviceType;
    LPCWSTR    lpstrElementName;
    LPCWSTR    lpstrAlias;
} MCI_OPEN_PARMSW, *PMCI_OPEN_PARMSW, *LPMCI_OPEN_PARMSW;
#ifdef UNICODE
typedef MCI_OPEN_PARMSW MCI_OPEN_PARMS;
typedef PMCI_OPEN_PARMSW PMCI_OPEN_PARMS;
typedef LPMCI_OPEN_PARMSW LPMCI_OPEN_PARMS;
#else
typedef MCI_OPEN_PARMSA MCI_OPEN_PARMS;
typedef PMCI_OPEN_PARMSA PMCI_OPEN_PARMS;
typedef LPMCI_OPEN_PARMSA LPMCI_OPEN_PARMS;
#endif // UNICODE

#else
typedef struct tagMCI_OPEN_PARMS {
    DWORD       dwCallback;
    MCIDEVICEID wDeviceID;
    WORD        wReserved0;
    LPCSTR      lpstrDeviceType;
    LPCSTR      lpstrElementName;
    LPCSTR      lpstrAlias;
} MCI_OPEN_PARMS, FAR *LPMCI_OPEN_PARMS;
#endif

/* parameter block for MCI_PLAY command message */
typedef struct tagMCI_PLAY_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_PLAY_PARMS, *PMCI_PLAY_PARMS, FAR *LPMCI_PLAY_PARMS;

/* parameter block for MCI_SEEK command message */
typedef struct tagMCI_SEEK_PARMS {
    DWORD   dwCallback;
    DWORD   dwTo;
} MCI_SEEK_PARMS, *PMCI_SEEK_PARMS, FAR *LPMCI_SEEK_PARMS;

/* parameter block for MCI_STATUS command message */
typedef struct tagMCI_STATUS_PARMS {
    DWORD   dwCallback;
    DWORD   dwReturn;
    DWORD   dwItem;
    DWORD   dwTrack;
} MCI_STATUS_PARMS, *PMCI_STATUS_PARMS, FAR * LPMCI_STATUS_PARMS;

/* parameter block for MCI_INFO command message */
#ifdef _WIN32

typedef struct tagMCI_INFO_PARMSA {
    DWORD   dwCallback;
    LPSTR   lpstrReturn;
    DWORD   dwRetSize;
} MCI_INFO_PARMSA, * LPMCI_INFO_PARMSA;
typedef struct tagMCI_INFO_PARMSW {
    DWORD   dwCallback;
    LPWSTR  lpstrReturn;
    DWORD   dwRetSize;
} MCI_INFO_PARMSW, * LPMCI_INFO_PARMSW;
#ifdef UNICODE
typedef MCI_INFO_PARMSW MCI_INFO_PARMS;
typedef LPMCI_INFO_PARMSW LPMCI_INFO_PARMS;
#else
typedef MCI_INFO_PARMSA MCI_INFO_PARMS;
typedef LPMCI_INFO_PARMSA LPMCI_INFO_PARMS;
#endif // UNICODE

#else
typedef struct tagMCI_INFO_PARMS {
    DWORD   dwCallback;
    LPSTR   lpstrReturn;
    DWORD   dwRetSize;
} MCI_INFO_PARMS, FAR * LPMCI_INFO_PARMS;
#endif

/* parameter block for MCI_GETDEVCAPS command message */
typedef struct tagMCI_GETDEVCAPS_PARMS {
    DWORD   dwCallback;
    DWORD   dwReturn;
    DWORD   dwItem;
} MCI_GETDEVCAPS_PARMS, *PMCI_GETDEVCAPS_PARMS, FAR * LPMCI_GETDEVCAPS_PARMS;

/* parameter block for MCI_SYSINFO command message */
#ifdef _WIN32

typedef struct tagMCI_SYSINFO_PARMSA {
    DWORD   dwCallback;
    LPSTR   lpstrReturn;
    DWORD   dwRetSize;
    DWORD   dwNumber;
    UINT    wDeviceType;
} MCI_SYSINFO_PARMSA, *PMCI_SYSINFO_PARMSA, * LPMCI_SYSINFO_PARMSA;
typedef struct tagMCI_SYSINFO_PARMSW {
    DWORD   dwCallback;
    LPWSTR  lpstrReturn;
    DWORD   dwRetSize;
    DWORD   dwNumber;
    UINT    wDeviceType;
} MCI_SYSINFO_PARMSW, *PMCI_SYSINFO_PARMSW, * LPMCI_SYSINFO_PARMSW;
#ifdef UNICODE
typedef MCI_SYSINFO_PARMSW MCI_SYSINFO_PARMS;
typedef PMCI_SYSINFO_PARMSW PMCI_SYSINFO_PARMS;
typedef LPMCI_SYSINFO_PARMSW LPMCI_SYSINFO_PARMS;
#else
typedef MCI_SYSINFO_PARMSA MCI_SYSINFO_PARMS;
typedef PMCI_SYSINFO_PARMSA PMCI_SYSINFO_PARMS;
typedef LPMCI_SYSINFO_PARMSA LPMCI_SYSINFO_PARMS;
#endif // UNICODE
#else
typedef struct tagMCI_SYSINFO_PARMS {
    DWORD   dwCallback;
    LPSTR   lpstrReturn;
    DWORD   dwRetSize;
    DWORD   dwNumber;
    WORD    wDeviceType;
    WORD    wReserved0;
} MCI_SYSINFO_PARMS, FAR * LPMCI_SYSINFO_PARMS;
#endif

/* parameter block for MCI_SET command message */
typedef struct tagMCI_SET_PARMS {
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
} MCI_SET_PARMS, *PMCI_SET_PARMS, FAR *LPMCI_SET_PARMS;

/* parameter block for MCI_BREAK command message */
typedef struct tagMCI_BREAK_PARMS {
    DWORD   dwCallback;
#ifdef _WIN32
    int     nVirtKey;
    HWND    hwndBreak;
#else
    short   nVirtKey;
    WORD    wReserved0;             /* padding for Win 16 */
    HWND    hwndBreak;
    WORD    wReserved1;             /* padding for Win 16 */
#endif
} MCI_BREAK_PARMS, *PMCI_BREAK_PARMS, FAR * LPMCI_BREAK_PARMS;

/* parameter block for MCI_SAVE command message */
#ifdef _WIN32

typedef struct tagMCI_SAVE_PARMSA {
    DWORD    dwCallback;
    LPCSTR    lpfilename;
} MCI_SAVE_PARMSA, *PMCI_SAVE_PARMSA, * LPMCI_SAVE_PARMSA;
typedef struct tagMCI_SAVE_PARMSW {
    DWORD    dwCallback;
    LPCWSTR   lpfilename;
} MCI_SAVE_PARMSW, *PMCI_SAVE_PARMSW, * LPMCI_SAVE_PARMSW;
#ifdef UNICODE
typedef MCI_SAVE_PARMSW MCI_SAVE_PARMS;
typedef PMCI_SAVE_PARMSW PMCI_SAVE_PARMS;
typedef LPMCI_SAVE_PARMSW LPMCI_SAVE_PARMS;
#else
typedef MCI_SAVE_PARMSA MCI_SAVE_PARMS;
typedef PMCI_SAVE_PARMSA PMCI_SAVE_PARMS;
typedef LPMCI_SAVE_PARMSA LPMCI_SAVE_PARMS;
#endif // UNICODE

#else
typedef struct tagMCI_SAVE_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpfilename;
} MCI_SAVE_PARMS, FAR * LPMCI_SAVE_PARMS;
#endif

/* parameter block for MCI_LOAD command message */
#ifdef _WIN32

typedef struct tagMCI_LOAD_PARMSA {
    DWORD    dwCallback;
    LPCSTR      lpfilename;
} MCI_LOAD_PARMSA, *PMCI_LOAD_PARMSA, * LPMCI_LOAD_PARMSA;
typedef struct tagMCI_LOAD_PARMSW {
    DWORD    dwCallback;
    LPCWSTR     lpfilename;
} MCI_LOAD_PARMSW, *PMCI_LOAD_PARMSW, * LPMCI_LOAD_PARMSW;
#ifdef UNICODE
typedef MCI_LOAD_PARMSW MCI_LOAD_PARMS;
typedef PMCI_LOAD_PARMSW PMCI_LOAD_PARMS;
typedef LPMCI_LOAD_PARMSW LPMCI_LOAD_PARMS;
#else
typedef MCI_LOAD_PARMSA MCI_LOAD_PARMS;
typedef PMCI_LOAD_PARMSA PMCI_LOAD_PARMS;
typedef LPMCI_LOAD_PARMSA LPMCI_LOAD_PARMS;
#endif // UNICODE

#else
typedef struct tagMCI_LOAD_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpfilename;
} MCI_LOAD_PARMS, FAR * LPMCI_LOAD_PARMS;
#endif

/* parameter block for MCI_RECORD command message */
typedef struct tagMCI_RECORD_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_RECORD_PARMS, FAR *LPMCI_RECORD_PARMS;

/* MCI extensions for videodisc devices */

/* flag for dwReturn field of MCI_STATUS_PARMS */
/* MCI_STATUS command, (dwItem == MCI_STATUS_MODE) */
#define MCI_VD_MODE_PARK                (MCI_VD_OFFSET + 1)

/* flag for dwReturn field of MCI_STATUS_PARMS */
/* MCI_STATUS command, (dwItem == MCI_VD_STATUS_MEDIA_TYPE) */
#define MCI_VD_MEDIA_CLV                (MCI_VD_OFFSET + 2)
#define MCI_VD_MEDIA_CAV                (MCI_VD_OFFSET + 3)
#define MCI_VD_MEDIA_OTHER              (MCI_VD_OFFSET + 4)

#define MCI_VD_FORMAT_TRACK             0x4001

/* flags for dwFlags parameter of MCI_PLAY command message */
#define MCI_VD_PLAY_REVERSE             0x00010000L
#define MCI_VD_PLAY_FAST                0x00020000L
#define MCI_VD_PLAY_SPEED               0x00040000L
#define MCI_VD_PLAY_SCAN                0x00080000L
#define MCI_VD_PLAY_SLOW                0x00100000L

/* flag for dwFlags parameter of MCI_SEEK command message */
#define MCI_VD_SEEK_REVERSE             0x00010000L

/* flags for dwItem field of MCI_STATUS_PARMS parameter block */
#define MCI_VD_STATUS_SPEED             0x00004002L
#define MCI_VD_STATUS_FORWARD           0x00004003L
#define MCI_VD_STATUS_MEDIA_TYPE        0x00004004L
#define MCI_VD_STATUS_SIDE              0x00004005L
#define MCI_VD_STATUS_DISC_SIZE         0x00004006L

/* flags for dwFlags parameter of MCI_GETDEVCAPS command message */
#define MCI_VD_GETDEVCAPS_CLV           0x00010000L
#define MCI_VD_GETDEVCAPS_CAV           0x00020000L

#define MCI_VD_SPIN_UP                  0x00010000L
#define MCI_VD_SPIN_DOWN                0x00020000L

/* flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block */
#define MCI_VD_GETDEVCAPS_CAN_REVERSE   0x00004002L
#define MCI_VD_GETDEVCAPS_FAST_RATE     0x00004003L
#define MCI_VD_GETDEVCAPS_SLOW_RATE     0x00004004L
#define MCI_VD_GETDEVCAPS_NORMAL_RATE   0x00004005L

/* flags for the dwFlags parameter of MCI_STEP command message */
#define MCI_VD_STEP_FRAMES              0x00010000L
#define MCI_VD_STEP_REVERSE             0x00020000L

/* flag for the MCI_ESCAPE command message */
#define MCI_VD_ESCAPE_STRING            0x00000100L

/* parameter block for MCI_PLAY command message */
typedef struct tagMCI_VD_PLAY_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
    DWORD   dwSpeed;
} MCI_VD_PLAY_PARMS, *PMCI_VD_PLAY_PARMS, FAR *LPMCI_VD_PLAY_PARMS;

/* parameter block for MCI_STEP command message */
typedef struct tagMCI_VD_STEP_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrames;
} MCI_VD_STEP_PARMS, *PMCI_VD_STEP_PARMS, FAR *LPMCI_VD_STEP_PARMS;

/* parameter block for MCI_ESCAPE command message */
#ifdef _WIN32

typedef struct tagMCI_VD_ESCAPE_PARMSA {
    DWORD   dwCallback;
    LPCSTR      lpstrCommand;
} MCI_VD_ESCAPE_PARMSA, *PMCI_VD_ESCAPE_PARMSA, *LPMCI_VD_ESCAPE_PARMSA;
typedef struct tagMCI_VD_ESCAPE_PARMSW {
    DWORD   dwCallback;
    LPCWSTR     lpstrCommand;
} MCI_VD_ESCAPE_PARMSW, *PMCI_VD_ESCAPE_PARMSW, *LPMCI_VD_ESCAPE_PARMSW;
#ifdef UNICODE
typedef MCI_VD_ESCAPE_PARMSW MCI_VD_ESCAPE_PARMS;
typedef PMCI_VD_ESCAPE_PARMSW PMCI_VD_ESCAPE_PARMS;
typedef LPMCI_VD_ESCAPE_PARMSW LPMCI_VD_ESCAPE_PARMS;
#else
typedef MCI_VD_ESCAPE_PARMSA MCI_VD_ESCAPE_PARMS;
typedef PMCI_VD_ESCAPE_PARMSA PMCI_VD_ESCAPE_PARMS;
typedef LPMCI_VD_ESCAPE_PARMSA LPMCI_VD_ESCAPE_PARMS;
#endif // UNICODE

#else
typedef struct tagMCI_VD_ESCAPE_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpstrCommand;
} MCI_VD_ESCAPE_PARMS, FAR *LPMCI_VD_ESCAPE_PARMS;
#endif

/* MCI extensions for CD audio devices */

/* flags for the dwItem field of the MCI_STATUS_PARMS parameter block */
#define MCI_CDA_STATUS_TYPE_TRACK       0x00004001L

/* flags for the dwReturn field of MCI_STATUS_PARMS parameter block */
/* MCI_STATUS command, (dwItem == MCI_CDA_STATUS_TYPE_TRACK) */
#define MCI_CDA_TRACK_AUDIO             (MCI_CD_OFFSET + 0)
#define MCI_CDA_TRACK_OTHER             (MCI_CD_OFFSET + 1)

/* MCI extensions for waveform audio devices */

#define MCI_WAVE_PCM                    (MCI_WAVE_OFFSET + 0)
#define MCI_WAVE_MAPPER                 (MCI_WAVE_OFFSET + 1)

/* flags for the dwFlags parameter of MCI_OPEN command message */
#define MCI_WAVE_OPEN_BUFFER            0x00010000L

/* flags for the dwFlags parameter of MCI_SET command message */
#define MCI_WAVE_SET_FORMATTAG          0x00010000L
#define MCI_WAVE_SET_CHANNELS           0x00020000L
#define MCI_WAVE_SET_SAMPLESPERSEC      0x00040000L
#define MCI_WAVE_SET_AVGBYTESPERSEC     0x00080000L
#define MCI_WAVE_SET_BLOCKALIGN         0x00100000L
#define MCI_WAVE_SET_BITSPERSAMPLE      0x00200000L

/* flags for the dwFlags parameter of MCI_STATUS, MCI_SET command messages */
#define MCI_WAVE_INPUT                  0x00400000L
#define MCI_WAVE_OUTPUT                 0x00800000L

/* flags for the dwItem field of MCI_STATUS_PARMS parameter block */
#define MCI_WAVE_STATUS_FORMATTAG       0x00004001L
#define MCI_WAVE_STATUS_CHANNELS        0x00004002L
#define MCI_WAVE_STATUS_SAMPLESPERSEC   0x00004003L
#define MCI_WAVE_STATUS_AVGBYTESPERSEC  0x00004004L
#define MCI_WAVE_STATUS_BLOCKALIGN      0x00004005L
#define MCI_WAVE_STATUS_BITSPERSAMPLE   0x00004006L
#define MCI_WAVE_STATUS_LEVEL           0x00004007L

/* flags for the dwFlags parameter of MCI_SET command message */
#define MCI_WAVE_SET_ANYINPUT           0x04000000L
#define MCI_WAVE_SET_ANYOUTPUT          0x08000000L

/* flags for the dwFlags parameter of MCI_GETDEVCAPS command message */
#define MCI_WAVE_GETDEVCAPS_INPUTS      0x00004001L
#define MCI_WAVE_GETDEVCAPS_OUTPUTS     0x00004002L

/* parameter block for MCI_OPEN command message */
#ifdef _WIN32

typedef struct tagMCI_WAVE_OPEN_PARMSA {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCSTR      lpstrDeviceType;
    LPCSTR      lpstrElementName;
    LPCSTR      lpstrAlias;
    DWORD   dwBufferSeconds;
} MCI_WAVE_OPEN_PARMSA, *PMCI_WAVE_OPEN_PARMSA, *LPMCI_WAVE_OPEN_PARMSA;
typedef struct tagMCI_WAVE_OPEN_PARMSW {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCWSTR     lpstrDeviceType;
    LPCWSTR     lpstrElementName;
    LPCWSTR     lpstrAlias;
    DWORD   dwBufferSeconds;
} MCI_WAVE_OPEN_PARMSW, *PMCI_WAVE_OPEN_PARMSW, *LPMCI_WAVE_OPEN_PARMSW;
#ifdef UNICODE
typedef MCI_WAVE_OPEN_PARMSW MCI_WAVE_OPEN_PARMS;
typedef PMCI_WAVE_OPEN_PARMSW PMCI_WAVE_OPEN_PARMS;
typedef LPMCI_WAVE_OPEN_PARMSW LPMCI_WAVE_OPEN_PARMS;
#else
typedef MCI_WAVE_OPEN_PARMSA MCI_WAVE_OPEN_PARMS;
typedef PMCI_WAVE_OPEN_PARMSA PMCI_WAVE_OPEN_PARMS;
typedef LPMCI_WAVE_OPEN_PARMSA LPMCI_WAVE_OPEN_PARMS;
#endif // UNICODE

#else
typedef struct tagMCI_WAVE_OPEN_PARMS {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    WORD        wReserved0;
    LPCSTR      lpstrDeviceType;
    LPCSTR      lpstrElementName;
    LPCSTR      lpstrAlias;
    DWORD       dwBufferSeconds;
} MCI_WAVE_OPEN_PARMS, FAR *LPMCI_WAVE_OPEN_PARMS;
#endif

/* parameter block for MCI_DELETE command message */
typedef struct tagMCI_WAVE_DELETE_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_WAVE_DELETE_PARMS, *PMCI_WAVE_DELETE_PARMS, FAR *LPMCI_WAVE_DELETE_PARMS;

/* parameter block for MCI_SET command message */
typedef struct tagMCI_WAVE_SET_PARMS {
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
#ifdef _WIN32
    UINT    wInput;
    UINT    wOutput;
#else
    WORD    wInput;
    WORD    wReserved0;
    WORD    wOutput;
    WORD    wReserved1;
#endif
    WORD    wFormatTag;
    WORD    wReserved2;
    WORD    nChannels;
    WORD    wReserved3;
    DWORD   nSamplesPerSec;
    DWORD   nAvgBytesPerSec;
    WORD    nBlockAlign;
    WORD    wReserved4;
    WORD    wBitsPerSample;
    WORD    wReserved5;
} MCI_WAVE_SET_PARMS, *PMCI_WAVE_SET_PARMS, FAR * LPMCI_WAVE_SET_PARMS;

/* MCI extensions for MIDI sequencer devices */

/* flags for the dwReturn field of MCI_STATUS_PARMS parameter block */
/* MCI_STATUS command, (dwItem == MCI_SEQ_STATUS_DIVTYPE) */
#define     MCI_SEQ_DIV_PPQN            (0 + MCI_SEQ_OFFSET)
#define     MCI_SEQ_DIV_SMPTE_24        (1 + MCI_SEQ_OFFSET)
#define     MCI_SEQ_DIV_SMPTE_25        (2 + MCI_SEQ_OFFSET)
#define     MCI_SEQ_DIV_SMPTE_30DROP    (3 + MCI_SEQ_OFFSET)
#define     MCI_SEQ_DIV_SMPTE_30        (4 + MCI_SEQ_OFFSET)

/* flags for the dwMaster field of MCI_SEQ_SET_PARMS parameter block */
/* MCI_SET command, (dwFlags == MCI_SEQ_SET_MASTER) */
#define     MCI_SEQ_FORMAT_SONGPTR      0x4001
#define     MCI_SEQ_FILE                0x4002
#define     MCI_SEQ_MIDI                0x4003
#define     MCI_SEQ_SMPTE               0x4004
#define     MCI_SEQ_NONE                65533
#define     MCI_SEQ_MAPPER              65535

/* flags for the dwItem field of MCI_STATUS_PARMS parameter block */
#define MCI_SEQ_STATUS_TEMPO            0x00004002L
#define MCI_SEQ_STATUS_PORT             0x00004003L
#define MCI_SEQ_STATUS_SLAVE            0x00004007L
#define MCI_SEQ_STATUS_MASTER           0x00004008L
#define MCI_SEQ_STATUS_OFFSET           0x00004009L
#define MCI_SEQ_STATUS_DIVTYPE          0x0000400AL
#define MCI_SEQ_STATUS_NAME             0x0000400BL
#define MCI_SEQ_STATUS_COPYRIGHT        0x0000400CL

/* flags for the dwFlags parameter of MCI_SET command message */
#define MCI_SEQ_SET_TEMPO               0x00010000L
#define MCI_SEQ_SET_PORT                0x00020000L
#define MCI_SEQ_SET_SLAVE               0x00040000L
#define MCI_SEQ_SET_MASTER              0x00080000L
#define MCI_SEQ_SET_OFFSET              0x01000000L

/* parameter block for MCI_SET command message */
typedef struct tagMCI_SEQ_SET_PARMS {
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
    DWORD   dwTempo;
    DWORD   dwPort;
    DWORD   dwSlave;
    DWORD   dwMaster;
    DWORD   dwOffset;
} MCI_SEQ_SET_PARMS, *PMCI_SEQ_SET_PARMS, FAR * LPMCI_SEQ_SET_PARMS;

/* MCI extensions for animation devices */

/* flags for dwFlags parameter of MCI_OPEN command message */
#define MCI_ANIM_OPEN_WS                0x00010000L
#define MCI_ANIM_OPEN_PARENT            0x00020000L
#define MCI_ANIM_OPEN_NOSTATIC          0x00040000L

/* flags for dwFlags parameter of MCI_PLAY command message */
#define MCI_ANIM_PLAY_SPEED             0x00010000L
#define MCI_ANIM_PLAY_REVERSE           0x00020000L
#define MCI_ANIM_PLAY_FAST              0x00040000L
#define MCI_ANIM_PLAY_SLOW              0x00080000L
#define MCI_ANIM_PLAY_SCAN              0x00100000L

/* flags for dwFlags parameter of MCI_STEP command message */
#define MCI_ANIM_STEP_REVERSE           0x00010000L
#define MCI_ANIM_STEP_FRAMES            0x00020000L

/* flags for dwItem field of MCI_STATUS_PARMS parameter block */
#define MCI_ANIM_STATUS_SPEED           0x00004001L
#define MCI_ANIM_STATUS_FORWARD         0x00004002L
#define MCI_ANIM_STATUS_HWND            0x00004003L
#define MCI_ANIM_STATUS_HPAL            0x00004004L
#define MCI_ANIM_STATUS_STRETCH         0x00004005L

/* flags for the dwFlags parameter of MCI_INFO command message */
#define MCI_ANIM_INFO_TEXT              0x00010000L

/* flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block */
#define MCI_ANIM_GETDEVCAPS_CAN_REVERSE 0x00004001L
#define MCI_ANIM_GETDEVCAPS_FAST_RATE   0x00004002L
#define MCI_ANIM_GETDEVCAPS_SLOW_RATE   0x00004003L
#define MCI_ANIM_GETDEVCAPS_NORMAL_RATE 0x00004004L
#define MCI_ANIM_GETDEVCAPS_PALETTES    0x00004006L
#define MCI_ANIM_GETDEVCAPS_CAN_STRETCH 0x00004007L
#define MCI_ANIM_GETDEVCAPS_MAX_WINDOWS 0x00004008L

/* flags for the MCI_REALIZE command message */
#define MCI_ANIM_REALIZE_NORM           0x00010000L
#define MCI_ANIM_REALIZE_BKGD           0x00020000L

/* flags for dwFlags parameter of MCI_WINDOW command message */
#define MCI_ANIM_WINDOW_HWND            0x00010000L
#define MCI_ANIM_WINDOW_STATE           0x00040000L
#define MCI_ANIM_WINDOW_TEXT            0x00080000L
#define MCI_ANIM_WINDOW_ENABLE_STRETCH  0x00100000L
#define MCI_ANIM_WINDOW_DISABLE_STRETCH 0x00200000L

/* flags for hWnd field of MCI_ANIM_WINDOW_PARMS parameter block */
/* MCI_WINDOW command message, (dwFlags == MCI_ANIM_WINDOW_HWND) */
#define MCI_ANIM_WINDOW_DEFAULT         0x00000000L

/* flags for dwFlags parameter of MCI_PUT command message */
#define MCI_ANIM_RECT                   0x00010000L
#define MCI_ANIM_PUT_SOURCE             0x00020000L
#define MCI_ANIM_PUT_DESTINATION        0x00040000L

/* flags for dwFlags parameter of MCI_WHERE command message */
#define MCI_ANIM_WHERE_SOURCE           0x00020000L
#define MCI_ANIM_WHERE_DESTINATION      0x00040000L

/* flags for dwFlags parameter of MCI_UPDATE command message */
#define MCI_ANIM_UPDATE_HDC             0x00020000L

/* parameter block for MCI_OPEN command message */
#ifdef _WIN32

typedef struct tagMCI_ANIM_OPEN_PARMSA {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCSTR      lpstrDeviceType;
    LPCSTR      lpstrElementName;
    LPCSTR      lpstrAlias;
    DWORD   dwStyle;
    HWND    hWndParent;
} MCI_ANIM_OPEN_PARMSA, *PMCI_ANIM_OPEN_PARMSA, *LPMCI_ANIM_OPEN_PARMSA;
typedef struct tagMCI_ANIM_OPEN_PARMSW {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCWSTR     lpstrDeviceType;
    LPCWSTR     lpstrElementName;
    LPCWSTR     lpstrAlias;
    DWORD   dwStyle;
    HWND    hWndParent;
} MCI_ANIM_OPEN_PARMSW, *PMCI_ANIM_OPEN_PARMSW, *LPMCI_ANIM_OPEN_PARMSW;
#ifdef UNICODE
typedef MCI_ANIM_OPEN_PARMSW MCI_ANIM_OPEN_PARMS;
typedef PMCI_ANIM_OPEN_PARMSW PMCI_ANIM_OPEN_PARMS;
typedef LPMCI_ANIM_OPEN_PARMSW LPMCI_ANIM_OPEN_PARMS;
#else
typedef MCI_ANIM_OPEN_PARMSA MCI_ANIM_OPEN_PARMS;
typedef PMCI_ANIM_OPEN_PARMSA PMCI_ANIM_OPEN_PARMS;
typedef LPMCI_ANIM_OPEN_PARMSA LPMCI_ANIM_OPEN_PARMS;
#endif // UNICODE

#else
typedef struct tagMCI_ANIM_OPEN_PARMS {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    WORD        wReserved0;
    LPCSTR      lpstrDeviceType;
    LPCSTR      lpstrElementName;
    LPCSTR      lpstrAlias;
    DWORD       dwStyle;
    HWND        hWndParent;
    WORD        wReserved1;
} MCI_ANIM_OPEN_PARMS, FAR *LPMCI_ANIM_OPEN_PARMS;
#endif

/* parameter block for MCI_PLAY command message */
typedef struct tagMCI_ANIM_PLAY_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
    DWORD   dwSpeed;
} MCI_ANIM_PLAY_PARMS, *PMCI_ANIM_PLAY_PARMS, FAR *LPMCI_ANIM_PLAY_PARMS;

/* parameter block for MCI_STEP command message */
typedef struct tagMCI_ANIM_STEP_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrames;
} MCI_ANIM_STEP_PARMS, *PMCI_ANIM_STEP_PARMS, FAR *LPMCI_ANIM_STEP_PARMS;

/* parameter block for MCI_WINDOW command message */
#ifdef _WIN32

typedef struct tagMCI_ANIM_WINDOW_PARMSA {
    DWORD   dwCallback;
    HWND    hWnd;
    UINT    nCmdShow;
    LPCSTR     lpstrText;
} MCI_ANIM_WINDOW_PARMSA, *PMCI_ANIM_WINDOW_PARMSA, * LPMCI_ANIM_WINDOW_PARMSA;
typedef struct tagMCI_ANIM_WINDOW_PARMSW {
    DWORD   dwCallback;
    HWND    hWnd;
    UINT    nCmdShow;
    LPCWSTR    lpstrText;
} MCI_ANIM_WINDOW_PARMSW, *PMCI_ANIM_WINDOW_PARMSW, * LPMCI_ANIM_WINDOW_PARMSW;
#ifdef UNICODE
typedef MCI_ANIM_WINDOW_PARMSW MCI_ANIM_WINDOW_PARMS;
typedef PMCI_ANIM_WINDOW_PARMSW PMCI_ANIM_WINDOW_PARMS;
typedef LPMCI_ANIM_WINDOW_PARMSW LPMCI_ANIM_WINDOW_PARMS;
#else
typedef MCI_ANIM_WINDOW_PARMSA MCI_ANIM_WINDOW_PARMS;
typedef PMCI_ANIM_WINDOW_PARMSA PMCI_ANIM_WINDOW_PARMS;
typedef LPMCI_ANIM_WINDOW_PARMSA LPMCI_ANIM_WINDOW_PARMS;
#endif // UNICODE

#else
typedef struct tagMCI_ANIM_WINDOW_PARMS {
    DWORD   dwCallback;
    HWND    hWnd;
    WORD    wReserved1;
    WORD    nCmdShow;
    WORD    wReserved2;
    LPCSTR  lpstrText;
} MCI_ANIM_WINDOW_PARMS, FAR * LPMCI_ANIM_WINDOW_PARMS;
#endif

/* parameter block for MCI_PUT, MCI_UPDATE, MCI_WHERE command messages */
typedef struct tagMCI_ANIM_RECT_PARMS {
    DWORD   dwCallback;
#ifdef MCI_USE_OFFEXT
    POINT   ptOffset;
    POINT   ptExtent;
#else   /* ifdef MCI_USE_OFFEXT */
    RECT    rc;
#endif  /* ifdef MCI_USE_OFFEXT */
} MCI_ANIM_RECT_PARMS;
typedef MCI_ANIM_RECT_PARMS * PMCI_ANIM_RECT_PARMS;
typedef MCI_ANIM_RECT_PARMS FAR * LPMCI_ANIM_RECT_PARMS;

/* parameter block for MCI_UPDATE PARMS */
typedef struct tagMCI_ANIM_UPDATE_PARMS {
    DWORD   dwCallback;
    RECT    rc;
    HDC     hDC;
} MCI_ANIM_UPDATE_PARMS, *PMCI_ANIM_UPDATE_PARMS, FAR * LPMCI_ANIM_UPDATE_PARMS;

/* MCI extensions for video overlay devices */

/* flags for dwFlags parameter of MCI_OPEN command message */
#define MCI_OVLY_OPEN_WS                0x00010000L
#define MCI_OVLY_OPEN_PARENT            0x00020000L

/* flags for dwFlags parameter of MCI_STATUS command message */
#define MCI_OVLY_STATUS_HWND            0x00004001L
#define MCI_OVLY_STATUS_STRETCH         0x00004002L

/* flags for dwFlags parameter of MCI_INFO command message */
#define MCI_OVLY_INFO_TEXT              0x00010000L

/* flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block */
#define MCI_OVLY_GETDEVCAPS_CAN_STRETCH 0x00004001L
#define MCI_OVLY_GETDEVCAPS_CAN_FREEZE  0x00004002L
#define MCI_OVLY_GETDEVCAPS_MAX_WINDOWS 0x00004003L

/* flags for dwFlags parameter of MCI_WINDOW command message */
#define MCI_OVLY_WINDOW_HWND            0x00010000L
#define MCI_OVLY_WINDOW_STATE           0x00040000L
#define MCI_OVLY_WINDOW_TEXT            0x00080000L
#define MCI_OVLY_WINDOW_ENABLE_STRETCH  0x00100000L
#define MCI_OVLY_WINDOW_DISABLE_STRETCH 0x00200000L

/* flags for hWnd parameter of MCI_OVLY_WINDOW_PARMS parameter block */
#define MCI_OVLY_WINDOW_DEFAULT         0x00000000L

/* flags for dwFlags parameter of MCI_PUT command message */
#define MCI_OVLY_RECT                   0x00010000L
#define MCI_OVLY_PUT_SOURCE             0x00020000L
#define MCI_OVLY_PUT_DESTINATION        0x00040000L
#define MCI_OVLY_PUT_FRAME              0x00080000L
#define MCI_OVLY_PUT_VIDEO              0x00100000L

/* flags for dwFlags parameter of MCI_WHERE command message */
#define MCI_OVLY_WHERE_SOURCE           0x00020000L
#define MCI_OVLY_WHERE_DESTINATION      0x00040000L
#define MCI_OVLY_WHERE_FRAME            0x00080000L
#define MCI_OVLY_WHERE_VIDEO            0x00100000L

/* parameter block for MCI_OPEN command message */
#ifdef _WIN32

typedef struct tagMCI_OVLY_OPEN_PARMSA {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCSTR      lpstrDeviceType;
    LPCSTR      lpstrElementName;
    LPCSTR      lpstrAlias;
    DWORD   dwStyle;
    HWND    hWndParent;
} MCI_OVLY_OPEN_PARMSA, *PMCI_OVLY_OPEN_PARMSA, *LPMCI_OVLY_OPEN_PARMSA;
typedef struct tagMCI_OVLY_OPEN_PARMSW {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCWSTR     lpstrDeviceType;
    LPCWSTR     lpstrElementName;
    LPCWSTR     lpstrAlias;
    DWORD   dwStyle;
    HWND    hWndParent;
} MCI_OVLY_OPEN_PARMSW, *PMCI_OVLY_OPEN_PARMSW, *LPMCI_OVLY_OPEN_PARMSW;
#ifdef UNICODE
typedef MCI_OVLY_OPEN_PARMSW MCI_OVLY_OPEN_PARMS;
typedef PMCI_OVLY_OPEN_PARMSW PMCI_OVLY_OPEN_PARMS;
typedef LPMCI_OVLY_OPEN_PARMSW LPMCI_OVLY_OPEN_PARMS;
#else
typedef MCI_OVLY_OPEN_PARMSA MCI_OVLY_OPEN_PARMS;
typedef PMCI_OVLY_OPEN_PARMSA PMCI_OVLY_OPEN_PARMS;
typedef LPMCI_OVLY_OPEN_PARMSA LPMCI_OVLY_OPEN_PARMS;
#endif // UNICODE

#else
typedef struct tagMCI_OVLY_OPEN_PARMS {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    WORD        wReserved0;
    LPCSTR      lpstrDeviceType;
    LPCSTR      lpstrElementName;
    LPCSTR      lpstrAlias;
    DWORD       dwStyle;
    HWND        hWndParent;
    WORD        wReserved1;
} MCI_OVLY_OPEN_PARMS, FAR *LPMCI_OVLY_OPEN_PARMS;
#endif

/* parameter block for MCI_WINDOW command message */
#ifdef _WIN32

typedef struct tagMCI_OVLY_WINDOW_PARMSA {
    DWORD   dwCallback;
    HWND    hWnd;
    UINT    nCmdShow;
    LPCSTR      lpstrText;
} MCI_OVLY_WINDOW_PARMSA, *PMCI_OVLY_WINDOW_PARMSA, * LPMCI_OVLY_WINDOW_PARMSA;
typedef struct tagMCI_OVLY_WINDOW_PARMSW {
    DWORD   dwCallback;
    HWND    hWnd;
    UINT    nCmdShow;
    LPCWSTR     lpstrText;
} MCI_OVLY_WINDOW_PARMSW, *PMCI_OVLY_WINDOW_PARMSW, * LPMCI_OVLY_WINDOW_PARMSW;
#ifdef UNICODE
typedef MCI_OVLY_WINDOW_PARMSW MCI_OVLY_WINDOW_PARMS;
typedef PMCI_OVLY_WINDOW_PARMSW PMCI_OVLY_WINDOW_PARMS;
typedef LPMCI_OVLY_WINDOW_PARMSW LPMCI_OVLY_WINDOW_PARMS;
#else
typedef MCI_OVLY_WINDOW_PARMSA MCI_OVLY_WINDOW_PARMS;
typedef PMCI_OVLY_WINDOW_PARMSA PMCI_OVLY_WINDOW_PARMS;
typedef LPMCI_OVLY_WINDOW_PARMSA LPMCI_OVLY_WINDOW_PARMS;
#endif // UNICODE
#else
typedef struct tagMCI_OVLY_WINDOW_PARMS {
    DWORD   dwCallback;
    HWND    hWnd;
    WORD    wReserved1;
    UINT    nCmdShow;
    WORD    wReserved2;
    LPCSTR  lpstrText;
} MCI_OVLY_WINDOW_PARMS, FAR * LPMCI_OVLY_WINDOW_PARMS;
#endif

/* parameter block for MCI_PUT, MCI_UPDATE, and MCI_WHERE command messages */
typedef struct tagMCI_OVLY_RECT_PARMS {
    DWORD   dwCallback;
#ifdef MCI_USE_OFFEXT
    POINT   ptOffset;
    POINT   ptExtent;
#else   /* ifdef MCI_USE_OFFEXT */
    RECT    rc;
#endif  /* ifdef MCI_USE_OFFEXT */
} MCI_OVLY_RECT_PARMS, *PMCI_OVLY_RECT_PARMS, FAR * LPMCI_OVLY_RECT_PARMS;

/* parameter block for MCI_SAVE command message */
#ifdef _WIN32

typedef struct tagMCI_OVLY_SAVE_PARMSA {
    DWORD   dwCallback;
    LPCSTR      lpfilename;
    RECT    rc;
} MCI_OVLY_SAVE_PARMSA, *PMCI_OVLY_SAVE_PARMSA, * LPMCI_OVLY_SAVE_PARMSA;
typedef struct tagMCI_OVLY_SAVE_PARMSW {
    DWORD   dwCallback;
    LPCWSTR     lpfilename;
    RECT    rc;
} MCI_OVLY_SAVE_PARMSW, *PMCI_OVLY_SAVE_PARMSW, * LPMCI_OVLY_SAVE_PARMSW;
#ifdef UNICODE
typedef MCI_OVLY_SAVE_PARMSW MCI_OVLY_SAVE_PARMS;
typedef PMCI_OVLY_SAVE_PARMSW PMCI_OVLY_SAVE_PARMS;
typedef LPMCI_OVLY_SAVE_PARMSW LPMCI_OVLY_SAVE_PARMS;
#else
typedef MCI_OVLY_SAVE_PARMSA MCI_OVLY_SAVE_PARMS;
typedef PMCI_OVLY_SAVE_PARMSA PMCI_OVLY_SAVE_PARMS;
typedef LPMCI_OVLY_SAVE_PARMSA LPMCI_OVLY_SAVE_PARMS;
#endif // UNICODE
#else
typedef struct tagMCI_OVLY_SAVE_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpfilename;
    RECT    rc;
} MCI_OVLY_SAVE_PARMS, FAR * LPMCI_OVLY_SAVE_PARMS;
#endif

/* parameter block for MCI_LOAD command message */
#ifdef _WIN32

typedef struct tagMCI_OVLY_LOAD_PARMSA {
    DWORD   dwCallback;
    LPCSTR      lpfilename;
    RECT    rc;
} MCI_OVLY_LOAD_PARMSA, *PMCI_OVLY_LOAD_PARMSA, * LPMCI_OVLY_LOAD_PARMSA;
typedef struct tagMCI_OVLY_LOAD_PARMSW {
    DWORD   dwCallback;
    LPCWSTR     lpfilename;
    RECT    rc;
} MCI_OVLY_LOAD_PARMSW, *PMCI_OVLY_LOAD_PARMSW, * LPMCI_OVLY_LOAD_PARMSW;
#ifdef UNICODE
typedef MCI_OVLY_LOAD_PARMSW MCI_OVLY_LOAD_PARMS;
typedef PMCI_OVLY_LOAD_PARMSW PMCI_OVLY_LOAD_PARMS;
typedef LPMCI_OVLY_LOAD_PARMSW LPMCI_OVLY_LOAD_PARMS;
#else
typedef MCI_OVLY_LOAD_PARMSA MCI_OVLY_LOAD_PARMS;
typedef PMCI_OVLY_LOAD_PARMSA PMCI_OVLY_LOAD_PARMS;
typedef LPMCI_OVLY_LOAD_PARMSA LPMCI_OVLY_LOAD_PARMS;
#endif // UNICODE
#else
typedef struct tagMCI_OVLY_LOAD_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpfilename;
    RECT    rc;
} MCI_OVLY_LOAD_PARMS, FAR * LPMCI_OVLY_LOAD_PARMS;
#endif

#endif  /* ifndef _WIN32_VXD */
#endif  /* ifndef MMNOMCI */

/****************************************************************************

			DISPLAY Driver extensions

****************************************************************************/

#ifndef NEWTRANSPARENT
    #define NEWTRANSPARENT  3           /* use with SetBkMode() */

    #define QUERYROPSUPPORT 40          /* use to determine ROP support */
#endif  /* ifndef NEWTRANSPARENT */

/****************************************************************************

			DIB Driver extensions

****************************************************************************/

#define SELECTDIB       41                      /* DIB.DRV select dib escape */
#define DIBINDEX(n)     MAKELONG((n),0x10FF)

/****************************************************************************

			ScreenSaver support

    The current application will receive a syscommand of SC_SCREENSAVE just
    before the screen saver is invoked.  If the app wishes to prevent a
    screen save, return non-zero value, otherwise call DefWindowProc().

****************************************************************************/

#ifndef SC_SCREENSAVE

    #define SC_SCREENSAVE   0xF140

#endif  /* ifndef SC_SCREENSAVE */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#ifdef _WIN32
#include <poppack.h>
#else
#ifndef RC_INVOKED
#pragma pack()
#endif
#endif

#endif  /* _INC_MMSYSTEM */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmband\bandtrk.cpp ===
//
// bandtrk.cpp
// 
// Copyright (c) 1997-2000 Microsoft Corporation
//
//

#include "pchdmband.h"

extern long g_cComponent;

//////////////////////////////////////////////////////////////////////
// Class CBandTrk

//////////////////////////////////////////////////////////////////////
// CBandTrk::CBandTrk

CBandTrk::CBandTrk() :
m_dwValidate(0),
#ifdef DXAPI
m_bAutoDownload(false),
m_fLockAutoDownload(false),
#endif
m_dwFlags(0),
m_cRef(1),
m_fCSInitialized(FALSE),
m_MemTrack(DMTRACK_BAND_TRACK)
{
    IncrementDLLCount();

    // Do this first since it can throw an exception
    //
    INITIALIZE_CRITICAL_SECTION(&m_CriticalSection);
    m_fCSInitialized = TRUE;

}

//////////////////////////////////////////////////////////////////////
// CBandTrk::~CBandTrk

CBandTrk::~CBandTrk()
{
    if (m_fCSInitialized)
    {
#ifdef DXAPI
        m_MidiModeList.CleanUp();
#endif
        while(!BandList.IsEmpty())
        {
            CBand* pBand = BandList.RemoveHead();
            pBand->Release();
        }
        
        DELETE_CRITICAL_SECTION(&m_CriticalSection);
    }
    
    DecrementDLLCount();
}

//////////////////////////////////////////////////////////////////////
// IUnknown

//////////////////////////////////////////////////////////////////////
// CBandTrk::QueryInterface

STDMETHODIMP CBandTrk::QueryInterface(const IID &iid, void **ppv)
{
    V_INAME(CBandTrk::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    if(iid == IID_IUnknown || iid == IID_IDirectMusicTrack || iid == IID_IDirectMusicTrack8)
    {
        *ppv = static_cast<IDirectMusicTrack8*>(this);
    } 
    else if(iid == IID_IDirectMusicBandTrk)
    {
        *ppv = static_cast<IDirectMusicBandTrk*>(this);
    }
    else if(iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else if(iid == IID_IPersist)
    {
        *ppv = static_cast<IPersist*>(this);
    }
    else
    {
        Trace(4,"Warning: Request to query unknown interface on Band Track object\n");
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::AddRef

STDMETHODIMP_(ULONG) CBandTrk::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::Release

STDMETHODIMP_(ULONG) CBandTrk::Release()
{
    if(!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CBandTrk::GetClassID( CLSID* pClassID )
{
    V_INAME(CBandTrk::GetClassID);
    V_PTR_WRITE(pClassID, CLSID); 
    *pClassID = CLSID_DirectMusicBandTrack;
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// IPersistStream

//////////////////////////////////////////////////////////////////////
// CBandTrk::Load

STDMETHODIMP CBandTrk::Load(IStream* pIStream)
{
    V_INAME(CBandTrk::Load);
    V_PTR_READ(pIStream, IStream);

    HRESULT hrDLS = S_OK;

    ENTER_CRITICAL_SECTION(&m_CriticalSection);
#ifdef DXAPI
    m_MidiModeList.CleanUp();
#endif
    // If we have been previously loaded, cleanup bands
    if(!BandList.IsEmpty())
    {
#ifdef DXAPI
        m_bAutoDownload = true;
#endif
        while(!BandList.IsEmpty())
        {
            CBand* pBand = BandList.RemoveHead();
            pBand->Release();
        }
        
        ++m_dwValidate;
    }   

    CRiffParser Parser(pIStream);
    RIFFIO ckMain;
    HRESULT hr = S_OK;

    Parser.EnterList(&ckMain);  
    if (Parser.NextChunk(&hr))
    { 
        if ((ckMain.ckid == FOURCC_RIFF) && 
            (ckMain.fccType == DMUS_FOURCC_BANDTRACK_FORM))
        {
            RIFFIO ckNext;    // Descends into the children chunks.
            Parser.EnterList(&ckNext);
            while (Parser.NextChunk(&hr))
            {
                switch(ckNext.ckid)
                {
#ifdef DXAPI
                case DMUS_FOURCC_BANDTRACK_CHUNK:
                    DMUS_IO_BAND_TRACK_HEADER ioDMBndTrkHdr;
                    hr = Parser.Read(&ioDMBndTrkHdr, sizeof(DMUS_IO_BAND_TRACK_HEADER));
                    if(SUCCEEDED(hr))
                    {
                        m_bAutoDownload = ioDMBndTrkHdr.bAutoDownload ? true : false;
                        m_fLockAutoDownload = true;
                    }
                    break;
#endif
                case FOURCC_LIST:
                    switch(ckNext.fccType)
                    {
                    case  DMUS_FOURCC_BANDS_LIST:
                        hr = BuildDirectMusicBandList(&Parser);
                        if (hr != S_OK)
                        {
                            hrDLS = hr;
                        }
                        break;
                    }
                }
            }
            Parser.LeaveList();
        }
    }
    Parser.LeaveList();
    
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);

    if (hr == S_OK && hrDLS != S_OK)
    {
        hr = hrDLS;
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack

//////////////////////////////////////////////////////////////////////
// CBandTrk::Init

STDMETHODIMP CBandTrk::Init(IDirectMusicSegment* pSegment)
{
    V_INAME(CBandTrk::Init);
    V_INTERFACE(pSegment);

    HRESULT hr = S_OK;
    DWORD dwNumPChannels = 0;
    DWORD *pdwPChannels = NULL;

    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    
    CBand* pBand = BandList.GetHead();
    for(; pBand; pBand = pBand->GetNext())
    {
        dwNumPChannels += pBand->GetPChannelCount();
    }

    if(dwNumPChannels > 0)
    {
        pdwPChannels = new DWORD[dwNumPChannels];
        if(pdwPChannels)
        {
            pBand = BandList.GetHead();
            for(DWORD dwPos = 0; pBand; pBand = pBand->GetNext())
            {
                DWORD dwNumWritten;
                pBand->GetPChannels(pdwPChannels + dwPos, &dwNumWritten);
                dwPos += dwNumWritten;
            }       
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
        
        if(SUCCEEDED(hr))
        {
            hr = pSegment->SetPChannelsUsed(dwNumPChannels, pdwPChannels);
        }

        delete [] pdwPChannels;
    }

    LEAVE_CRITICAL_SECTION(&m_CriticalSection);

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::InitPlay

STDMETHODIMP CBandTrk::InitPlay(IDirectMusicSegmentState* pSegmentState,
                                           IDirectMusicPerformance* pPerformance,
                                           void** ppStateData,
                                           DWORD dwVirtualTrackID,
                                           DWORD dwFlags)
{
    V_INAME(CBandTrk::InitPlay);
    V_INTERFACE(pSegmentState);
    V_INTERFACE(pPerformance);
    assert(ppStateData);

    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    
    CBandTrkStateData* pBandTrkStateData = new CBandTrkStateData;
    
    // If we can not allocate the memory we need to set ppStateData to NULL
    // and return S_OK since the caller always expects S_OK;
    *ppStateData = pBandTrkStateData;
    if(pBandTrkStateData == NULL)
    {
        LEAVE_CRITICAL_SECTION(&m_CriticalSection);
        return E_OUTOFMEMORY;
    }

    // Need to save State Data
    pBandTrkStateData->m_pSegmentState = pSegmentState;
    pBandTrkStateData->m_pPerformance = pPerformance;
    pBandTrkStateData->m_dwVirtualTrackID = dwVirtualTrackID; // Determines instance of Band Track 

    CBand* pBand = BandList.GetHead();
    pBandTrkStateData->m_pNextBandToSPE = pBand;

#ifdef DXAPI
    BOOL fGlobal; // if the performance has been set with an autodownload preference,
                // use that. otherwise, assume autodownloading is off, unless it has
                // been locked (i.e. specified on the band track.)
    if( SUCCEEDED( pPerformance->GetGlobalParam( GUID_PerfAutoDownload, &fGlobal, sizeof(BOOL) )))
    {
        if( !m_fLockAutoDownload )
        {
            // it might seem like we can just assign m_bAutoDownload = fGlobal, 
            // but that's bitten me before, so I'm being paranoid today. (markburt)
            if( fGlobal )
            {
                m_bAutoDownload = true;
            }
            else
            {
                m_bAutoDownload = false;
            }
        }
    }
    else if( !m_fLockAutoDownload )
    {
        m_bAutoDownload = false;
    }
    // Call SetParam to download all instruments used by the track's bands
    // This is the auto-download feature that can be turned off with a call to SetParam
    if(m_bAutoDownload)
    {
        IDirectMusicAudioPath *pPath = NULL;
        IDirectMusicSegmentState8 *pState8;
        if (SUCCEEDED(pSegmentState->QueryInterface(IID_IDirectMusicSegmentState8,(void **)&pState8)))
        {
            pState8->GetObjectInPath(0,DMUS_PATH_AUDIOPATH,0,GUID_NULL,0,
                                                    IID_IDirectMusicAudioPath,(void **) &pPath);
            pState8->Release();
        }
        if (pPath) 
        {
            SetParam(GUID_DownloadToAudioPath,0,(void *)pPath);
            pPath->Release();
        }
        else 
        {
            SetParam(GUID_DownloadToAudioPath, 0, (void *)pPerformance);
        }
    }
#endif
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::EndPlay

STDMETHODIMP CBandTrk::EndPlay(void* pStateData)
{
    assert(pStateData);

    ENTER_CRITICAL_SECTION(&m_CriticalSection);

    // Call SetParam to unload all instruments used by the track's bands
    // This is the auto-unload feature that can be turned off with a call to SetParam
#ifdef DXAPI
    if(m_bAutoDownload)
    {
        IDirectMusicPerformance *pPerformance = ((CBandTrkStateData *)pStateData)->m_pPerformance;
        IDirectMusicSegmentState *pSegmentState = ((CBandTrkStateData *)pStateData)->m_pSegmentState;
        IDirectMusicAudioPath *pPath = NULL;
        IDirectMusicSegmentState8 *pState8;
        if (SUCCEEDED(pSegmentState->QueryInterface(IID_IDirectMusicSegmentState8,(void **)&pState8)))
        {
            pState8->GetObjectInPath(0,DMUS_PATH_AUDIOPATH,0,GUID_NULL,0,
                                                    IID_IDirectMusicAudioPath,(void **) &pPath);
            pState8->Release();
        }
        if (pPath) 
        {
            SetParam(GUID_UnloadFromAudioPath,0,(void *)pPath);
            pPath->Release();
        }
        else 
        {
            SetParam(GUID_UnloadFromAudioPath, 0, (void *)pPerformance);
        }
    }
#endif
    if(pStateData)
    {
        delete ((CBandTrkStateData *)pStateData);
    }
    
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::PlayEx

STDMETHODIMP CBandTrk::PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf,
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) 
{
    HRESULT hr;
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    if (dwFlags & DMUS_TRACKF_CLOCK)
    {
        // Convert all reference times to millisecond times. Then, just use same MUSIC_TIME
        // variables.
        hr = PlayMusicOrClock(pStateData,(MUSIC_TIME)(rtStart / REF_PER_MIL),(MUSIC_TIME)(rtEnd / REF_PER_MIL),
            (MUSIC_TIME)(rtOffset / REF_PER_MIL),rtOffset,dwFlags,pPerf,pSegSt,dwVirtualID,TRUE);
    }
    else
    {
        hr = PlayMusicOrClock(pStateData,(MUSIC_TIME)rtStart,(MUSIC_TIME)rtEnd,
            (MUSIC_TIME)rtOffset,0,dwFlags,pPerf,pSegSt,dwVirtualID,FALSE);
    }
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    return hr;

}

//////////////////////////////////////////////////////////////////////
// CBandTrk::Play

STDMETHODIMP CBandTrk::Play( 
    void *pStateData,   
    MUSIC_TIME mtStart, 
    MUSIC_TIME mtEnd,
    MUSIC_TIME mtOffset,
    DWORD dwFlags,  
    IDirectMusicPerformance* pPerf,
    IDirectMusicSegmentState* pSegSt,   
    DWORD dwVirtualID)
{
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    HRESULT hr = PlayMusicOrClock(pStateData,mtStart,mtEnd,mtOffset,0,dwFlags,pPerf,pSegSt,dwVirtualID,FALSE);
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    return hr;
}

HRESULT CBandTrk::PlayMusicOrClock(
    void *pStateData,   
    MUSIC_TIME mtStart, 
    MUSIC_TIME mtEnd,
    MUSIC_TIME mtOffset,
    REFERENCE_TIME rtOffset,
    DWORD dwFlags,      
    IDirectMusicPerformance* pPerf, 
    IDirectMusicSegmentState* pSegSt,
    DWORD dwVirtualID,
    bool fClockTime)
{
    assert(pPerf);
    assert(pSegSt);
    assert(pStateData);

    // Caller expects S_OK or S_END. Since we have no state info we can not do anything
    if(pStateData == NULL)
    {
        return DMUS_S_END;  
    }

    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    if( dwFlags & (DMUS_TRACKF_SEEK | DMUS_TRACKF_FLUSH | DMUS_TRACKF_DIRTY |
        DMUS_TRACKF_LOOP) )
    {
        // need to reset the PChannel Map in case of any of these flags.
        CBand* pBand = BandList.GetHead();
        DWORD dwGroupBits = 0xffffffff;
        IDirectMusicSegment* pSeg;
        if( SUCCEEDED(pSegSt->GetSegment(&pSeg)))
        {
            pSeg->GetTrackGroup(this, &dwGroupBits);
            pSeg->Release();
        }
        
        for(; pBand; pBand = pBand->GetNext())
        {
            pBand->m_PChMap.Reset();
            pBand->m_dwGroupBits = dwGroupBits;
        }
    }

    CBandTrkStateData* pBandTrkStateData = (CBandTrkStateData *)pStateData;

    // Seek if we're starting, looping, or if we've been reloaded
    if ((dwFlags & DMUS_TRACKF_LOOP) || (dwFlags & DMUS_TRACKF_START) || (pBandTrkStateData->dwValidate != m_dwValidate))
    {
        // When we start playing a segment, we need to catch up with all the band changes
        // that happened before the start point.  The instruments that sound when we start
        // playing in the middle of a segment should sound the same as if we had played the
        // segment to that point from the beginning.
        pBandTrkStateData->m_fPlayPreviousInSeek = !!(dwFlags & DMUS_TRACKF_START);

        Seek(pBandTrkStateData, mtStart, mtOffset, rtOffset, fClockTime);

        pBandTrkStateData->dwValidate = m_dwValidate; // if we were reloading, we're now adjusted
    }

    // Send all Patch changes between mtStart & mtEnd
    // If any fail try next one
    CBand* pBand = (CBand *)(pBandTrkStateData->m_pNextBandToSPE);
    
    for( ; pBand && pBand->m_lTimeLogical < mtEnd;
            pBand = pBand->GetNext())
    {
        pBand->SendMessages(pBandTrkStateData, mtOffset, rtOffset, fClockTime);
    }

    // Save position for next time
    pBandTrkStateData->m_pNextBandToSPE = pBand;

    LEAVE_CRITICAL_SECTION(&m_CriticalSection);

    return pBand == NULL ? DMUS_S_END : S_OK;
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::GetParam

STDMETHODIMP CBandTrk::GetParam(REFGUID rguidDataType,
                                           MUSIC_TIME mtTime, 
                                           MUSIC_TIME* pmtNext,
                                           void* pData)
{
    V_INAME(CBandTrk::GetParam);
    V_PTR_WRITE_OPT(pmtNext,MUSIC_TIME);
    V_PTR_WRITE(pData,1);
    V_REFGUID(rguidDataType);

    HRESULT hr = S_OK;
    ENTER_CRITICAL_SECTION( &m_CriticalSection );
#ifdef DXAPI
    if (rguidDataType == GUID_BandParam)
    {
        CBand* pScan = BandList.GetHead();
        if (pScan)
        {
            CBand* pBand = pScan;
            for (pScan = pScan->GetNext(); pScan; pScan = pScan->GetNext())
            {
                if (mtTime < pScan->m_lTimeLogical) break;
                pBand = pScan;
            }
            // make a copy of the band found
            CBand *pNewBand = new CBand;

            if (pNewBand)
            {
                CBandInstrument* pBandInstrument = pBand->m_BandInstrumentList.GetHead();
                for(; pBandInstrument && SUCCEEDED(hr); pBandInstrument = pBandInstrument->GetNext())
                {
                    hr = pNewBand->Load(pBandInstrument);
                }
                if (FAILED(hr))
                {
                    // Don't leak.
                    delete pNewBand;
                }
                else
                {
                    pNewBand->m_lTimeLogical = pBand->m_lTimeLogical;
                    pNewBand->m_lTimePhysical = pBand->m_lTimePhysical;

                    pNewBand->m_dwFlags |= DMB_LOADED;
                    pNewBand->m_dwMidiMode = pBand->m_dwMidiMode;
                }

            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
            if (SUCCEEDED(hr))
            {
                IDirectMusicBand* pIDMBand = NULL;
                pNewBand->QueryInterface(IID_IDirectMusicBand, (void**)&pIDMBand);
                // The constructor initialized the ref countto 1, so release the QI 
                pNewBand->Release();
                DMUS_BAND_PARAM *pBandParam = reinterpret_cast<DMUS_BAND_PARAM *>(pData);
                pBandParam->pBand = pIDMBand;
                pBandParam->mtTimePhysical = pBand->m_lTimePhysical;
                if (pmtNext)
                {
                    *pmtNext = (pScan != NULL) ? pScan->m_lTimeLogical : 0;
                }
                hr = S_OK;
            }
        }
        else 
        {
            Trace(4,"Warning: Band Track unable to find Band for GetParam call.\n");
            hr = DMUS_E_NOT_FOUND;
        }
    }
    else
#endif
    {
        hr = DMUS_E_GET_UNSUPPORTED;
    }
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return hr;

}

//////////////////////////////////////////////////////////////////////
// CBandTrk::SetParam

STDMETHODIMP CBandTrk::SetParam(REFGUID rguidDataType, 
                                           MUSIC_TIME mtTime, 
                                           void* pData)
{
    V_INAME(CBandTrk::SetParam);
    V_REFGUID(rguidDataType);

#ifdef DXAPI
    HRESULT hr = S_OK;
    if((pData == NULL)
       && (rguidDataType != GUID_Enable_Auto_Download) 
       && (rguidDataType != GUID_Disable_Auto_Download)
       && (rguidDataType != GUID_IgnoreBankSelectForGM)
       && (rguidDataType != GUID_Clear_All_Bands)
       )
    {
        Trace(1,"Error: Invalid NULL pointer passed to Band Track for SetParam call.\n");
        return E_POINTER;   
    }
    
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    if(rguidDataType == GUID_DownloadToAudioPath)
    {
        IDirectMusicAudioPath* pPath = (IDirectMusicAudioPath*)pData;
        V_INTERFACE(pPath);
        HRESULT hrFail = S_OK;
        DWORD dwSuccess = 0;
        CBand* pBand = BandList.GetHead();
        for(; pBand; pBand = pBand->GetNext())
        {
            if (FAILED(hr = pBand->DownloadEx(pPath))) // If not S_OK, download is only partial.
            {
                hrFail = hr;
            }
            else
            {
                dwSuccess++;
            }
        }
        // If we had a failure, return it if we had no successes.
        // Else return S_FALSE for partial success.
        if (FAILED(hrFail) && dwSuccess)
        {
            hr = S_FALSE;
        }
    }
    else if(rguidDataType == GUID_UnloadFromAudioPath)
    {
        IDirectMusicAudioPath* pPath = (IDirectMusicAudioPath*)pData;
        V_INTERFACE(pPath);
        CBand* pBand = BandList.GetHead();
        for(; pBand; pBand = pBand->GetNext())
        {
            pBand->UnloadEx(pPath);
        }
    }
    else if(rguidDataType == GUID_Download)
    {
        IDirectMusicPerformance* pPerf = (IDirectMusicPerformance*)pData;
        V_INTERFACE(pPerf);
        CBand* pBand = BandList.GetHead();
        for(; pBand; pBand = pBand->GetNext())
        {
            if (pBand->DownloadEx(pPerf) != S_OK) // If not S_OK, download is only partial.
            {
                hr = S_FALSE;
            }
        }
    }
    else if(rguidDataType == GUID_Unload)
    {
        IDirectMusicPerformance* pPerf = (IDirectMusicPerformance*)pData;
        V_INTERFACE(pPerf);
        CBand* pBand = BandList.GetHead();
        for(; pBand; pBand = pBand->GetNext())
        {
            pBand->UnloadEx(pPerf);
        }
    }
    else if(rguidDataType == GUID_Enable_Auto_Download)
    {
        m_bAutoDownload = true;
        m_fLockAutoDownload = true;
    }
    else if(rguidDataType == GUID_Disable_Auto_Download)
    {
        m_bAutoDownload = false;
        m_fLockAutoDownload = true;
    }
    else if(rguidDataType == GUID_Clear_All_Bands)
    {
        while(!BandList.IsEmpty())
        {
            CBand* pBand = BandList.RemoveHead();
            pBand->Release();
        }
    }
    else if(rguidDataType == GUID_BandParam)
    {
        DMUS_BAND_PARAM *pBandParam = reinterpret_cast<DMUS_BAND_PARAM *>(pData);
        IDirectMusicBand *pBand = pBandParam->pBand;
        V_INTERFACE(pBand);
        // If you can QI pData for private interface IDirectMusicBandPrivate 
        // pBand is of type CBand.
        IDirectMusicBandPrivate *pBandPrivate = NULL;
        hr = pBand->QueryInterface(IID_IDirectMusicBandPrivate, (void **)&pBandPrivate);
        
        if(FAILED(hr))
        {
            LEAVE_CRITICAL_SECTION(&m_CriticalSection);
            return hr;
        }
        
        pBandPrivate->Release();

        CBand *pBandObject = static_cast<CBand *>(pBand);
        pBandObject->m_lTimeLogical = mtTime;
        pBandObject->m_lTimePhysical = pBandParam->mtTimePhysical;
        
        hr = AddBand(pBand);
    }
    else if(rguidDataType == GUID_IDirectMusicBand)
    {
        IDirectMusicBand *pBand = (IDirectMusicBand *)pData;
        V_INTERFACE(pBand);
        // If you can QI pData for private interface IDirectMusicBandPrivate 
        // pData is of type CBand.
        IDirectMusicBandPrivate *pBandPrivate = NULL;
        hr = pBand->QueryInterface(IID_IDirectMusicBandPrivate, (void **)&pBandPrivate);
        
        if(FAILED(hr))
        {
            LEAVE_CRITICAL_SECTION(&m_CriticalSection);
            return hr;
        }
        
        pBandPrivate->Release();

        CBand *pBandObject = static_cast<CBand *>(pBand);
        pBandObject->m_lTimeLogical = mtTime;
        pBandObject->m_lTimePhysical = pBandObject->m_lTimeLogical;
        
        hr = AddBand(pBand);
    }
    else if(rguidDataType == GUID_IgnoreBankSelectForGM)
    {
        CBand* pBand = BandList.GetHead();
        for(; pBand; pBand = pBand->GetNext())
        {
            pBand->MakeGMOnly();
        }
    }
    else if(rguidDataType == GUID_ConnectToDLSCollection)
    {
        IDirectMusicCollection* pCollect = (IDirectMusicCollection*)pData;
        V_INTERFACE(pData);
        CBand* pBand = BandList.GetHead();
        for(; pBand; pBand = pBand->GetNext())
        {
            pBand->ConnectToDLSCollection(pCollect);
        }
    }
    else
    {
        Trace(3,"Warning: Invalid SetParam call on Band Track, GUID is unknown.\n");
        hr = DMUS_E_TYPE_UNSUPPORTED;
    }

    LEAVE_CRITICAL_SECTION(&m_CriticalSection);

    return hr;
#else
    return DMUS_E_TYPE_UNSUPPORTED;
#endif

}

//////////////////////////////////////////////////////////////////////
// CBandTrk::GetParamEx

STDMETHODIMP CBandTrk::GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) 
{
    HRESULT hr;
    MUSIC_TIME mtNext;
    if (dwFlags & DMUS_TRACK_PARAMF_CLOCK)
    {
        hr = GetParam(rguidType,(MUSIC_TIME) (rtTime / REF_PER_MIL), &mtNext, pParam);
        if (prtNext)
        {
            *prtNext = mtNext * REF_PER_MIL;
        }
    }
    else
    {
        hr = GetParam(rguidType,(MUSIC_TIME) rtTime, &mtNext, pParam);
        if (prtNext)
        {
            *prtNext = mtNext;
        }
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::SetParamEx

STDMETHODIMP CBandTrk::SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,
                                      void* pParam, void * pStateData, DWORD dwFlags)
{
    if (dwFlags & DMUS_TRACK_PARAMF_CLOCK)
    {
        rtTime /= REF_PER_MIL;
    }
    return SetParam(rguidType, (MUSIC_TIME) rtTime, pParam);
}
    
//////////////////////////////////////////////////////////////////////
// CBandTrk::IsParamSupported
    
STDMETHODIMP CBandTrk::IsParamSupported(REFGUID rguidDataType)
{
    V_INAME(CBandTrk::IsParamSupported);
    V_REFGUID(rguidDataType);

    // Return S_OK if the object supports the GUID and S_FALSE otherwise
#ifdef DXAPI
    if(rguidDataType == GUID_Download ||
       rguidDataType == GUID_Unload ||
       rguidDataType == GUID_DownloadToAudioPath ||
       rguidDataType == GUID_UnloadFromAudioPath ||
       rguidDataType == GUID_Enable_Auto_Download ||
       rguidDataType == GUID_Disable_Auto_Download ||
       rguidDataType == GUID_IgnoreBankSelectForGM ||
       rguidDataType == GUID_ConnectToDLSCollection ||
       rguidDataType == GUID_Clear_All_Bands ||
       rguidDataType == GUID_IDirectMusicBand ||
       rguidDataType == GUID_BandParam)
    {
        return S_OK;
    }
    else
#endif
    {
        return DMUS_E_TYPE_UNSUPPORTED;
    }
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::AddNotificationType

STDMETHODIMP CBandTrk::AddNotificationType(REFGUID rguidNotify)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::RemoveNotificationType

STDMETHODIMP CBandTrk::RemoveNotificationType(REFGUID rguidNotify)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::Clone

STDMETHODIMP CBandTrk::Clone(MUSIC_TIME mtStart, 
                                        MUSIC_TIME mtEnd,
                                        IDirectMusicTrack** ppTrack)
{
    V_INAME(CBandTrk::Clone);
    V_PTRPTR_WRITE(ppTrack);

    if ((mtStart < 0 ) || (mtStart > mtEnd))
    {
        Trace(1,"Error: Invalid range %ld to %ld sent to Band Track Clone command.\n",mtStart,mtEnd);
        return E_INVALIDARG;
    }
    HRESULT hr = E_OUTOFMEMORY;
    IDirectMusicBandTrk *pBandTrack = NULL;
    CBandTrk *pNew = new CBandTrk;
    if (pNew)
    {
        hr = pNew->QueryInterface(IID_IDirectMusicBandTrk,(void**)&pBandTrack);
        if(SUCCEEDED(hr))
        {
            hr = LoadClone(pBandTrack, mtStart, mtEnd);
            if(SUCCEEDED(hr))
            {
                hr = pBandTrack->QueryInterface(IID_IDirectMusicTrack, (void **)ppTrack);
                if (SUCCEEDED(hr))
                {
                    pBandTrack->Release();
                }
            }
            pBandTrack->Release();
        }
        if (FAILED(hr))
        {
            delete pNew;
        }
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicCommon

//////////////////////////////////////////////////////////////////////
// CBandTrk::GetName

STDMETHODIMP CBandTrk::GetName(BSTR* pbstrName)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicBandTrk

//////////////////////////////////////////////////////////////////////
// CBandTrk::AddBand
#ifdef DXAPI
STDMETHODIMP CBandTrk::AddBand(DMUS_IO_PATCH_ITEM* pPatchEvent)
{
    if(pPatchEvent == NULL)
    {
        return E_POINTER;
    }
    
    CBand *pNewBand = new CBand;

    HRESULT hr;

    if(pNewBand == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = pNewBand->Load(*pPatchEvent);
    }
    
    if(SUCCEEDED(hr))
    {
        hr = InsertBand(pNewBand);
    }
    
    if(FAILED(hr) && pNewBand)
    {
        delete pNewBand;        
    }

    return hr;
}
#endif
//////////////////////////////////////////////////////////////////////
// CBandTrk::AddBand

HRESULT CBandTrk::AddBand(IDirectMusicBand* pIDMBand)
{
    if(pIDMBand == NULL)
    {
        return E_POINTER;
    }

    // If you can QI pIDMBand for private interface IDirectMusicBandPrivate 
    // pIDMBand is of type CBand.
    IDirectMusicBandPrivate* pIDMBandP = NULL;
    HRESULT hr = pIDMBand->QueryInterface(IID_IDirectMusicBandPrivate, (void **)&pIDMBandP);

    if(SUCCEEDED(hr))
    {
        pIDMBandP->Release();

        CBand *pNewBand = (CBand *) pIDMBand;
        pNewBand->AddRef();

        HRESULT hr = InsertBand(pNewBand);
    
        if(FAILED(hr))
        {
            pNewBand->Release();
        }
    }
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// Internal

//////////////////////////////////////////////////////////////////////
// CBandTrk::BuildDirectMusicBandList
// This method loads all of the bands. 

HRESULT CBandTrk::BuildDirectMusicBandList(CRiffParser *pParser)
{
    RIFFIO ckNext;

    HRESULT hrDLS = S_OK;

    HRESULT hr = S_OK;
    pParser->EnterList(&ckNext);  
    while (pParser->NextChunk(&hr))
    {
        switch(ckNext.ckid)
        {
        case FOURCC_LIST :
            switch(ckNext.fccType)
            {
            case DMUS_FOURCC_BAND_LIST:
                hr = ExtractBand(pParser);
                if (hr != S_OK)
                {
                    hrDLS = hr;
                }
                break;
            }
            break;
        }
    }
    pParser->LeaveList();
    if (hr == S_OK && hrDLS != S_OK)
    {
        hr = hrDLS;
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::ExtractBand

HRESULT 
CBandTrk::ExtractBand(CRiffParser *pParser)
{
    HRESULT hrDLS = S_OK;

    RIFFIO ckNext;
    CBand *pBand = new CBand;
    if(pBand == NULL)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = S_OK;
    bool fFoundChunk2 = false;
    pParser->EnterList(&ckNext);  
    while (pParser->NextChunk(&hr))
    {
        switch(ckNext.ckid)
        {
        case DMUS_FOURCC_BANDITEM_CHUNK2:
            fFoundChunk2 = true;
            DMUS_IO_BAND_ITEM_HEADER2 ioDMBndItemHdr2;
            hr = pParser->Read(&ioDMBndItemHdr2, sizeof(DMUS_IO_BAND_ITEM_HEADER2));
            if(SUCCEEDED(hr))
            {
                pBand->m_lTimeLogical = ioDMBndItemHdr2.lBandTimeLogical;
                pBand->m_lTimePhysical = ioDMBndItemHdr2.lBandTimePhysical;
            }
            break;
        case DMUS_FOURCC_BANDITEM_CHUNK:
            // if there is both a CHUNK and a CHUNK2, use the info from CHUNK2
            if (fFoundChunk2)
                break;
            DMUS_IO_BAND_ITEM_HEADER ioDMBndItemHdr;
            hr = pParser->Read(&ioDMBndItemHdr, sizeof(DMUS_IO_BAND_ITEM_HEADER));
            if(SUCCEEDED(hr))
            {
                pBand->m_lTimeLogical = ioDMBndItemHdr.lBandTime;
                pBand->m_lTimePhysical = pBand->m_lTimeLogical;
            }
            break;
        case FOURCC_RIFF:
            switch(ckNext.fccType)
            {
            case DMUS_FOURCC_BAND_FORM:
                pParser->SeekBack();
                hr = LoadBand(pParser->GetStream(), pBand);
                pParser->SeekForward();
                if (hr != S_OK)
                {
                    hrDLS = hr;
                }
                break;
            }
            break;
        default:
            break;

        }
    
    }
    pParser->LeaveList();

    if(SUCCEEDED(hr))
    {
        hr = AddBand(pBand);
    }

    pBand->Release();

    if (hr == S_OK && hrDLS != S_OK)
    {
        hr = hrDLS;
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::LoadBand

HRESULT CBandTrk::LoadBand(IStream *pIStream, CBand* pBand)
{
    assert(pIStream);
    assert(pBand);

    IPersistStream *pIPersistStream = NULL;
    
    HRESULT hr = pBand->QueryInterface(IID_IPersistStream, (void **)&pIPersistStream);

    if(SUCCEEDED(hr))
    {
        hr = pIPersistStream->Load(pIStream);
        pIPersistStream->Release();
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::LoadClone

HRESULT CBandTrk::LoadClone(IDirectMusicBandTrk* pBandTrack,
                                       MUSIC_TIME mtStart, 
                                       MUSIC_TIME mtEnd)
{
    assert(pBandTrack);
    assert(mtStart <= mtEnd);

    ENTER_CRITICAL_SECTION(&m_CriticalSection);

    HRESULT hr = S_OK;

    if (mtStart > 0)
    {
        // We will take all the bands before the start time and create a single new band
        // at logical time zero, physical time either -1 or one tick before the physical time 
        // of the first band after the start time, that accumulates all the instrument changes 
        // from the earlier bands.

        TList<SeekEvent> SEList; // Build a list of all the instrument changes for the new band
        DWORD dwLastMidiMode = 0; // Keep track of the MIDI mode of the last band we encounter
        
        for( CBand* pBand = BandList.GetHead();
                pBand && pBand->m_lTimeLogical < mtStart;
                pBand = pBand->GetNext())
        {
            for(CBandInstrument* pInstrument = (pBand->m_BandInstrumentList).GetHead();
                    pInstrument && SUCCEEDED(hr);
                    pInstrument = pInstrument->GetNext())
            {
                // replace if we already have an entry on that channel
                hr = FindSEReplaceInstr(SEList,
                                        pInstrument->m_dwPChannel,
                                        pInstrument);

                // otherwise add an entry
                if(hr == S_FALSE)
                {
                    TListItem<SeekEvent>* pSEListItem = new TListItem<SeekEvent>;
                    if(pSEListItem)
                    {
                        SeekEvent& rSeekEvent = pSEListItem->GetItemValue();
                        rSeekEvent.m_dwPChannel = pInstrument->m_dwPChannel;
                        rSeekEvent.m_pInstrument = pInstrument;
                        rSeekEvent.m_pParentBand = pBand;
                        dwLastMidiMode = pBand->m_dwMidiMode;
                        SEList.AddHead(pSEListItem);
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }   
                }
            }
        }

        // Make sure the physical time of the new band is less than any bands being cloned.
        MUSIC_TIME mtNewPhysicalTime = -1;
        if (pBand && pBand->m_lTimePhysical <= mtStart)
        {
            mtNewPhysicalTime = (pBand->m_lTimePhysical - mtStart) - 1;
        }

        // Create the new band from the instrument list
        TListItem<SeekEvent>* pSEListItem = SEList.GetHead();
        if(SUCCEEDED(hr) && pSEListItem)
        {
            CBand *pNewBand = new CBand;

            if(pNewBand)
            {
                for(; pSEListItem && SUCCEEDED(hr); pSEListItem = pSEListItem->GetNext())
                {
                    SeekEvent& rSeekEvent = pSEListItem->GetItemValue();
                    hr = pNewBand->Load(rSeekEvent.m_pInstrument);
                }
                
                pNewBand->m_lTimeLogical = 0;
                pNewBand->m_lTimePhysical = mtNewPhysicalTime;
                pNewBand->m_dwFlags |= DMB_LOADED;
                pNewBand->m_dwMidiMode = dwLastMidiMode;

                if(SUCCEEDED(hr))
                {
                    hr = pBandTrack->AddBand(pNewBand);
                }

                pNewBand->Release();
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    // Copy all the bands between the start and the end time
    if(SUCCEEDED(hr))
    {
        for(CBand* pBand = BandList.GetHead();
                pBand && SUCCEEDED(hr);
                pBand = pBand->GetNext())
        {
            // If mtStart is 0, accept bands with negative times.
            if ((!mtStart || (pBand->m_lTimeLogical >= mtStart)) && pBand->m_lTimeLogical < mtEnd)
            {
                CBand *pNewBand = new CBand;

                if (pNewBand)
                {
                    CBandInstrument* pBandInstrument = pBand->m_BandInstrumentList.GetHead();
                    for(; pBandInstrument && SUCCEEDED(hr); pBandInstrument = pBandInstrument->GetNext())
                    {
                        hr = pNewBand->Load(pBandInstrument);
                    }
                    
                    pNewBand->m_lTimeLogical = pBand->m_lTimeLogical - mtStart;
                    pNewBand->m_lTimePhysical = pBand->m_lTimePhysical - mtStart;

                    pNewBand->m_dwFlags |= DMB_LOADED;
                    pNewBand->m_dwMidiMode = pBand->m_dwMidiMode;

                    if(SUCCEEDED(hr))
                    {
                        hr = pBandTrack->AddBand(pNewBand);
                    }

                    pNewBand->Release();
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }
    }

    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::Seek

HRESULT CBandTrk::Seek(CBandTrkStateData* pBandTrkStateData,
                       MUSIC_TIME mtStart,
                       MUSIC_TIME mtOffset,
                       REFERENCE_TIME rtOffset,
                       bool fClockTime)
{
    assert(pBandTrkStateData);

    ENTER_CRITICAL_SECTION(&m_CriticalSection);

    HRESULT hr = S_OK;

    CBand *pBand;

    int iPrevBandCount = 0; // count how many bands before mtStart
    for (pBand = BandList.GetHead();
            pBand && pBand->m_lTimeLogical < mtStart;
            pBand = pBand->GetNext())
    {
        ++iPrevBandCount;
    }

    // pBand now holds the first band >= mtStart (or NULL if none)
    // This is the next band that will be played.
    assert(!pBand || pBand->m_lTimeLogical >= mtStart);

    if (pBandTrkStateData->m_fPlayPreviousInSeek)
    {
        // When this flag is on not only do we need to find the first band, but we also
        // need to play all the bands before the start point and schedule them to play
        // in the correct order just beforehand.

        // (Note that we're going to order them according to their logical times.  If
        //  two bands's logical/physical times cross each other we'll play them in
        //  incorrect order in terms of physical time.  That's OK because giving
        //  band A with a logical time before band B, yet giving A a physical time
        //  after B is considered an authoring inconsistency.  We'll play band A first.)

        // We will line up the bands just before the following time...
        MUSIC_TIME mtPrevBandQueueStart =
            (pBand && pBand->m_lTimePhysical < mtStart)
                ? pBand->m_lTimePhysical    // put previous bands before next band to play if (due to anticipation) its physical time precedes the start time we're seeking
                : mtStart;                  // otherwise put them just before the start time
        
        for (pBand = BandList.GetHead();
                pBand && pBand->m_lTimeLogical < mtStart;
                pBand = pBand->GetNext())
        {
            CBandInstrument* pInstrument = (pBand->m_BandInstrumentList).GetHead();
            for (; pInstrument && SUCCEEDED(hr); pInstrument = pInstrument->GetNext())
            {
                pBand->SendInstrumentAtTime(pInstrument, pBandTrkStateData, mtPrevBandQueueStart - iPrevBandCount, mtOffset, rtOffset, fClockTime);
            }
            --iPrevBandCount;
        }
        assert(iPrevBandCount == 0);
    }
    
    if(SUCCEEDED(hr))
    {
        // Set the state data to the next band to play
        assert(!pBand || pBand->m_lTimeLogical >= mtStart);
        pBandTrkStateData->m_pNextBandToSPE = pBand;
    }
    
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::FindSEReplaceInstr

// If SEList contains an entry on channel dwPChannel, replace the instrument with pInstrument and return S_OK
// Otherwise return S_FALSE
HRESULT CBandTrk::FindSEReplaceInstr(TList<SeekEvent>& SEList,
                                                DWORD dwPChannel,
                                                CBandInstrument* pInstrument)
{
    assert(pInstrument);

    ENTER_CRITICAL_SECTION(&m_CriticalSection);

    TListItem<SeekEvent>* pSEListItem = SEList.GetHead();
    
    for( ; pSEListItem; pSEListItem = pSEListItem->GetNext())
    {
        SeekEvent& rSeekEvent = pSEListItem->GetItemValue();
        if(rSeekEvent.m_dwPChannel == dwPChannel)
        {
            rSeekEvent.m_pInstrument = pInstrument;
            LEAVE_CRITICAL_SECTION(&m_CriticalSection);
            return S_OK;
        }
    }

    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    
    return S_FALSE;
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::InsertBand

HRESULT CBandTrk::InsertBand(CBand* pNewBand)
{
    if (!pNewBand) return E_POINTER;

    ENTER_CRITICAL_SECTION(&m_CriticalSection);
#ifdef DXAPI
    TListItem<StampedGMGSXG>* pPair = m_MidiModeList.GetHead();
    for ( ; pPair; pPair = pPair->GetNext() )
    {
        StampedGMGSXG& rPair = pPair->GetItemValue();
        if (rPair.mtTime > pNewBand->m_lTimeLogical)
        {
            break;
        }
        pNewBand->SetGMGSXGMode(rPair.dwMidiMode);
    }
#endif
    CBand* pBand = BandList.GetHead();
    CBand* pPrevBand = NULL;
    
    if(pBand == NULL)
    {
        // Handles case where there is no band in the list
        BandList.AddHead(pNewBand);
    }
    else
    {
        while(pBand != NULL && pNewBand->m_lTimeLogical > pBand->m_lTimeLogical)
        {
            pPrevBand = pBand;
            pBand = pBand->GetNext();
        }
        
        if(pPrevBand)
        {
            // Handles the cases of inserting a band in the middle of list 
            // and at the end
            CBand* pTemp = pPrevBand->GetNext();
            pPrevBand->SetNext(pNewBand);
            pNewBand->SetNext(pTemp);
        }
        else
        {
            // Handles case where pNewBand->m_lTimeLogical < all pBand->m_lTimeLogical in list
            BandList.AddHead(pNewBand);
        }
    }

    LEAVE_CRITICAL_SECTION(&m_CriticalSection);

    return S_OK;
}


STDMETHODIMP CBandTrk::Compose(
        IUnknown* pContext, 
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) 
{
    return E_NOTIMPL;
}

STDMETHODIMP CBandTrk::Join(
        IDirectMusicTrack* pNewTrack,
        MUSIC_TIME mtJoin,
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) 
{
    V_INAME(IDirectMusicTrack::Join);
    V_INTERFACE(pNewTrack);
    V_INTERFACE_OPT(pContext);
    V_PTRPTR_WRITE_OPT(ppResultTrack);

    HRESULT hr = S_OK;
    ENTER_CRITICAL_SECTION(&m_CriticalSection);

    if (ppResultTrack)
    {
        hr = Clone(0, mtJoin, ppResultTrack);
        if (SUCCEEDED(hr))
        {
            hr = ((CBandTrk*)*ppResultTrack)->JoinInternal(pNewTrack, mtJoin, dwTrackGroup);
        }
    }
    else
    {
        hr = JoinInternal(pNewTrack, mtJoin, dwTrackGroup);
    }

    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    return hr;
}

HRESULT CBandTrk::JoinInternal(
        IDirectMusicTrack* pNewTrack,
        MUSIC_TIME mtJoin,
        DWORD dwTrackGroup) 
{
    HRESULT hr = S_OK;
    CBandTrk* pOtherTrack = (CBandTrk*)pNewTrack;
    for(CBand* pBand = pOtherTrack->BandList.GetHead();
            pBand && SUCCEEDED(hr);
            pBand = pBand->GetNext())
    {
        CBand *pNewBand = new CBand;
        if (pNewBand)
        {
            CBandInstrument* pBandInstrument = pBand->m_BandInstrumentList.GetHead();
            for(; pBandInstrument && SUCCEEDED(hr); pBandInstrument = pBandInstrument->GetNext())
            {
                hr = pNewBand->Load(pBandInstrument);
            }
            
            pNewBand->m_lTimeLogical = pBand->m_lTimeLogical + mtJoin;
            pNewBand->m_lTimePhysical = pBand->m_lTimePhysical + mtJoin;
            pNewBand->m_dwFlags |= DMB_LOADED;
            pNewBand->m_dwMidiMode = pBand->m_dwMidiMode;

            if(SUCCEEDED(hr))
            {
                hr = AddBand(pNewBand);
            }

            pNewBand->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmcompos\aariff.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1998 Microsoft Corporation
//
//  File:       aariff.h
//
//--------------------------------------------------------------------------

//
// aariff.h
//

#ifndef __AARIFF__
#define __AARIFF__

#ifdef XBOX
#include <xtl.h>
#else // XBOX
#include <windows.h>
#include <objbase.h>
#endif // XBOX


#include <mmsystem.h>
#define FixBytes(a1,a2)

// {0D5057E1-8889-11CF-B9DA-00AA00C08146}
DEFINE_GUID( IID_IAARIFFStream, 0xd5057e1, 0x8889, 0x11cf, 0xb9, 0xda, 0x0, 0xaa, 0x0, 0xc0, 0x81, 0x46 );
#undef INTERFACE
#define INTERFACE IAARIFFStream
DECLARE_INTERFACE_(IAARIFFStream, IUnknown)
{
    // IUnknown members
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // IMKRIFFStream members
    STDMETHOD_(UINT, Descend)(LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags) PURE;
    STDMETHOD_(UINT, Ascend)(LPMMCKINFO lpck, UINT wFlags) PURE;
    STDMETHOD_(UINT, CreateChunk)(LPMMCKINFO lpck, UINT wFlags) PURE;
    STDMETHOD(SetStream)(LPSTREAM pStream) PURE;
    STDMETHOD_(LPSTREAM, GetStream)() PURE;
};

struct CRIFFStream : IAARIFFStream
{
///// object state
    ULONG       m_cRef;         // object reference count
    IStream*    m_pStream;      // stream to operate on

///// construction and destruction
    CRIFFStream(IStream* pStream)
    {
        m_cRef = 1;
		// replaced a call to SetStream with the following to avoid releasing an
		// unallocated stream
        m_pStream = pStream;
        if( m_pStream != NULL )
        {
            m_pStream->AddRef();
        }
    }
    ~CRIFFStream()
    {
        if( m_pStream != NULL )
        {
            m_pStream->Release();
        }
    }

///// IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj)
    {
        if( IsEqualIID( riid, IID_IUnknown ) ||
            IsEqualIID( riid, IID_IAARIFFStream ) )
        {
            *ppvObj = (IAARIFFStream*)this;
            AddRef();
            return NOERROR;
        }
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    STDMETHODIMP_(ULONG) AddRef()
    {
        return ++m_cRef;
    }
    STDMETHODIMP_(ULONG) Release()
    {
        if( --m_cRef == 0L )
        {
            delete this;
            return 0;
        }
        return m_cRef;
    }

// IAARIFFStream methods
    STDMETHODIMP_(UINT) Descend( LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags );
    STDMETHODIMP_(UINT) Ascend( LPMMCKINFO lpck, UINT wFlags );
    STDMETHODIMP_(UINT) CreateChunk( LPMMCKINFO lpck, UINT wFlags );
    STDMETHOD(SetStream)(LPSTREAM pStream)
    {
        if( m_pStream != NULL )
        {
            m_pStream->Release();
        }
        m_pStream = pStream;
        if( m_pStream != NULL )
        {
            m_pStream->AddRef();
        }
        return S_OK;
    }
    STDMETHOD_(LPSTREAM, GetStream)()
    {
        if( m_pStream != NULL )
        {
            m_pStream->AddRef();
        }
        return m_pStream;
    }

// private methods
    long MyRead( void *pv, long cb );
    long MyWrite( const void *pv, long cb );
    long MySeek( long lOffset, int iOrigin );
};

// seeks to a 32-bit position in a stream.
HRESULT __inline StreamSeek( LPSTREAM pStream, long lSeekTo, DWORD dwOrigin )
{
	LARGE_INTEGER li;

	if( lSeekTo < 0 )
	{
		li.HighPart = -1;
	}
	else
	{
        li.HighPart = 0;
	}
	li.LowPart = lSeekTo;
	return pStream->Seek( li, dwOrigin, NULL );
}

// returns the current 32-bit position in a stream.
DWORD __inline StreamTell( LPSTREAM pStream )
{
	LARGE_INTEGER li;
    ULARGE_INTEGER ul;
#ifdef DBG
    HRESULT hr;
#endif

    li.HighPart = 0;
    li.LowPart = 0;
#ifdef DBG
    hr = pStream->Seek( li, STREAM_SEEK_CUR, &ul );
    if( FAILED( hr ) )
#else
    if( FAILED( pStream->Seek( li, STREAM_SEEK_CUR, &ul ) ) )
#endif
    {
        return 0;
    }
    return ul.LowPart;
}

// this function gets a long that is formatted the correct way
// i.e. the motorola way as opposed to the intel way
BOOL __inline GetMLong( LPSTREAM pStream, DWORD& dw )
{
    union uLong
	{
		unsigned char buf[4];
        DWORD dw;
	} u;
    unsigned char ch;

    if( FAILED( pStream->Read( u.buf, 4, NULL ) ) )
    {
        return FALSE;
    }

#ifndef _MAC
    // swap bytes
    ch = u.buf[0];
    u.buf[0] = u.buf[3];
    u.buf[3] = ch;

    ch = u.buf[1];
    u.buf[1] = u.buf[2];
    u.buf[2] = ch;
#endif

    dw = u.dw;
    return TRUE;
}

BOOL __inline IsGUIDZero( REFGUID guid )
{
    GUID g;

    memset( &g, 0, sizeof( g ) );
    return IsEqualGUID( g, guid );
}

// misc function prototypes

STDAPI AllocRIFFStream( IStream* pStream, IAARIFFStream** ppRiff );

#endif  // __AARIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmband\dmband.cpp ===
//
// dmband.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation
//

#include "pchdmband.h"

extern long g_cComponent;

//////////////////////////////////////////////////////////////////////
// Class CBand

//////////////////////////////////////////////////////////////////////
// CBand::CBand

CBand::CBand() : m_MemTrack(DMTRACK_BAND)
{
    m_lTimeLogical = 0;
    m_lTimePhysical = 0;
    m_dwFlags = 0;
    m_dwGroupBits = 0xffffffff;
    m_dwMidiMode = 0;
    m_cRef = 1;
    m_fCSInitialized = FALSE;
	IncrementDLLCount();
    // Do this first since it can throw an exception
    //
	InitializeCriticalSection(&m_CriticalSection);
    m_fCSInitialized = TRUE;
//    m_dwValidData = 0;
}

//////////////////////////////////////////////////////////////////////
// CBand::~CBand

CBand::~CBand()
{
    if (m_fCSInitialized)
    {
    	m_BandInstrumentList.Clear();
	    DeleteCriticalSection(&m_CriticalSection);	
    }
	
	DecrementDLLCount();
}

void CBandInstrumentList::Clear()

{
    CBandInstrument* pBandInstrument;
	while(pBandInstrument = RemoveHead())
	{
		delete pBandInstrument;
	}
}

//////////////////////////////////////////////////////////////////////
// IUnknown

//////////////////////////////////////////////////////////////////////
// CBand::QueryInterface

STDMETHODIMP 
CBand::QueryInterface(const IID &iid, void **ppv)
{
	V_INAME(CBand::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

	*ppv = NULL;

	if(iid == IID_IUnknown || iid == IID_IDirectMusicBand)
	{
		*ppv = static_cast<IDirectMusicBand*>(this);
	} 
#ifdef DXAPI
	else if(iid == IID_IDirectMusicBandP)
	{
		*ppv = static_cast<IDirectMusicBandP*>(this);
	}
#endif
	else if(iid == IID_IDirectMusicBandPrivate)
	{
		*ppv = static_cast<IDirectMusicBandPrivate*>(this);
	}
	else if(iid == IID_IDirectMusicObject)
	{
		*ppv = static_cast<IDirectMusicObject*>(this);
	}
	else if(iid == IID_IPersistStream)
	{
		*ppv = static_cast<IPersistStream*>(this);
	}
	else if(iid == IID_IPersist)
	{
		*ppv = static_cast<IPersist*>(this);
	}

	if (*ppv == NULL)
		return E_NOINTERFACE;
    
	reinterpret_cast<IUnknown*>(this)->AddRef();
    
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CBand::AddRef

STDMETHODIMP_(ULONG)
CBand::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CBand::Release

STDMETHODIMP_(ULONG)
CBand::Release()
{
    if (!InterlockedDecrement(&m_cRef)) 
	{
		m_cRef = 100; // artificial reference count to prevent reentrency due to COM aggregation
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// IPersistStream

//////////////////////////////////////////////////////////////////////
// CBand::Load

STDMETHODIMP CBand::Load(IStream* pStream)
{
	V_INAME(CBand::Load);
	V_PTR_READ(pStream, IStream);

    // Get the loader from stream if it has one
	// so we can open required collections
	IDirectMusicLoader* pIDMLoader = NULL;
	IDirectMusicGetLoader *pIDMGetLoader = NULL;
	
	if (SUCCEEDED(pStream->QueryInterface(IID_IDirectMusicGetLoader,(void **)&pIDMGetLoader)))
	{
		pIDMGetLoader->GetLoader(&pIDMLoader);
		pIDMGetLoader->Release();
	}
    else
    {
        Trace(1,"Error: Band unable to reference DLS Collections because IStream does not support Loader.\n");
        return DMUS_E_UNSUPPORTED_STREAM;
    }

	EnterCriticalSection(&m_CriticalSection);

	// If we have been previously loaded, clean up instruments
	if(m_dwFlags & DMB_LOADED)
	{
        m_Info.Init();
		m_BandInstrumentList.Clear();
		m_lTimeLogical = 0;
		m_lTimePhysical = 0;
		m_dwFlags = 0;
	}

    RIFFIO ckMain;
    HRESULT hr = S_OK;

    CRiffParser Parser(pStream);
    Parser.EnterList(&ckMain);  
    if (Parser.NextChunk(&hr))
    {
		if(ckMain.fccType == DMUS_FOURCC_BAND_FORM)
		{
			hr = LoadDirectMusicBand(&Parser, pIDMLoader);
		}
#ifdef DXAPI
        else if (ckMain.fccType == FOURCC_BAND_FORM)
        {
			hr = LoadLegacyBand(&Parser, pIDMLoader);		
		}
#endif
		else
		{
            Trace(1,"Error: Failure Parsing Band - invalid chunk ID.\n");
			hr = DMUS_E_INVALID_BAND;
		}
	}
	
	if(FAILED(hr))
	{
		m_BandInstrumentList.Clear();
	}
	
	if(pIDMLoader)
	{
		pIDMLoader->Release();
	}
	
	LeaveCriticalSection(&m_CriticalSection);

	return hr;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicBand

//////////////////////////////////////////////////////////////////////
// CBand::CreateSegment

STDMETHODIMP CBand::CreateSegment(IDirectMusicSegment** ppSegment)   
{
	V_INAME(IDirectMusicBand::CreateSegment);
	V_PTRPTR_WRITE(ppSegment);

    HRESULT hr = DirectMusicCreateInstance(CLSID_DirectMusicSegment,NULL,
                                            IID_IDirectMusicSegment,
                                            (void **) &ppSegment);
	if(SUCCEEDED(hr))
	{
		IDirectMusicTrack* pDMTrack = NULL;
        CBandTrk *pBandTrack;

		// Create Band track

        pBandTrack = new CBandTrk;

        if (pBandTrack)
        {
            pBandTrack->QueryInterface(IID_IDirectMusicTrack,(void**)&pDMTrack);
    		// Add band to track
			m_lTimePhysical--; // Subtract one from the time when creating the segment.  This is somewhat arbitrary.  (See NT5 bug 226848.)
			hr = pBandTrack->AddBand(static_cast<IDirectMusicBand*>(this));
			m_lTimePhysical++; // add the one back in
#ifdef DXAPI
    		// Set Auto-download to off
            pBandTrack->m_bAutoDownload	= false;
		    pBandTrack->m_fLockAutoDownload = true;
#endif
    		// Insert track into segment
			hr = (*ppSegment)->InsertTrack(pDMTrack, 1);
			pDMTrack->Release();
            pBandTrack->Release(); // We don't need the original count created by the constructor.
		}
        else
        {
            hr = E_OUTOFMEMORY;
        }
	}

	if(FAILED(hr))
	{
		if(*ppSegment)
		{
			(*ppSegment)->Release();
			*ppSegment = NULL;
		}
	}

	return hr;
}

#ifdef DXAPI
HRESULT CBandInstrument::Download(IDirectMusicPerformanceP *pPerformance, 
                                  IDirectMusicAudioPath *pPath,
                                  DWORD dwMidiMode)

{
    DWORD dwPChannel;
    HRESULT hr = S_OK;
    // First, if there is an audiopath, convert the band's pchannel to performance pchannel.
    if (pPath) 
    {
        hr = pPath->ConvertPChannel(m_dwPChannel,&dwPChannel);
        if (FAILED(hr))
        {
            Trace(1,"Error: Couldn't download to Audiopath because pchannel %ld is out of bounds\n",m_dwPChannel);
            // Not a valid pchannel on this audiopath.
            return hr;
        }
    }
    else
    {
        dwPChannel = m_dwPChannel;
    }

    // We need to get the port we will be downloading to. 
    IDirectMusicPort *pPort = NULL;
    DWORD dwGMFlags;
    BOOL fDownload = TRUE;

    hr = pPerformance->GetPortAndFlags(dwPChannel,&pPort,&dwGMFlags);

    // Once we know the port, we can find out whether a download has
    // already occured. And, if not, we'll use that to do the download.
    if (SUCCEEDED(hr))
    {
        CDownloadedInstrument* pDLInstrument = m_DownloadList.GetHead();

        for(; pDLInstrument; pDLInstrument = pDLInstrument->GetNext())
        {
	        if (pDLInstrument->m_pPort == pPort)
	        {
                // Increment reference counter and leave.
                pDLInstrument->m_cRef++;
                pPort->Release();
                return S_OK;
	        }
        }

        // Okay, didn't find it, so we need to create a download record and download it. 

        if(m_fNotInFile && !m_fGMOnly)
		{
			// Unless we've set the GMOnly flag, don't download an instrument 
            // that was automatically generated from the midi
			// parsing to give a patchless channel an instrument.
            fDownload = FALSE;
		}

		else if (m_pIDMCollection == NULL)
		{
			// Can not download this instrument but still want to add a record and continue with others.
			// If instrument is a GM and GS instrument it may still play if GM or GS is supported in hardware.
            fDownload = FALSE;
			Trace(2,"Warning: No collection, unable to download instrument %lx on PChannel %ld\n",m_dwPatch,m_dwPChannel);
		}

        if (m_dwFlags & DMUS_IO_INST_GS)
        {
            // If this is a GS instrument, determine whether it needs to be downloaded.
            if ((dwGMFlags & DM_PORTFLAGS_GM) && (m_dwFlags & DMUS_IO_INST_GM))
		    {
                // The synth has a GM set in ROM, and this is a GM instrument,
                // and the instrument does not specifically requests that it use the
                // DLS version in gm.dls.
                if (!(m_dwFlags & DMUS_IO_INST_USE_DEFAULT_GM_SET) )
                {
			        fDownload = FALSE;
                }
		    }
		    else if (dwGMFlags & DM_PORTFLAGS_GS)
		    {
                // If the synth has a GS set, the problem is simpler, since it is going to be very similar to our 
                // gm.dls set, so it is okay to use it.
			    fDownload = FALSE;
		    }
        }

		if( dwMidiMode ) // if this is anything, it indicates we were loaded from a midi file
		{
			// if we're not an XG file, make sure channel 9 is drums
			if( (dwMidiMode != DMUS_MIDIMODEF_XG) &&
				(m_dwPChannel == 9) )
			{
				m_dwPatch |= 0x80000000;
			}
		}

        // Okay, ready to download...

        if (fDownload)
        {
        	hr = DownloadAddRecord(pPort);
			// Use fallbacks for XG mode
			if( FAILED(hr) && dwMidiMode == DMUS_MIDIMODEF_XG )
			{
			    DWORD dwOldPatch = m_dwPatch;
			    DWORD dwOldFlags = m_dwFlags;
			    DWORD dwOldAssignPatch = m_dwAssignPatch;
				// If this band failed, try clearing the MSB. If it was an XG or GS instrument,
				// and the collection doesn't have the instrument, clearing the MSB is a
				// good fallback. If that doesn't work, try clearing the LSB.
				// Also, if this band is XG see if it is on the drum channel. If so, 
				// try setting the drum bit.
				if( (m_dwPatch & 0x00ff0000) == 0x007f0000 )
				{
					// XG drums. Try GM drums instead, but keep program change
					m_dwPatch &= 0xff0000ff; // clear MSB and LSB
					m_dwPatch |= 0x80000000; // set drum bit
					m_dwFlags |= DMUS_IO_INST_ASSIGN_PATCH;
					m_dwAssignPatch = dwOldPatch & 0x00ffffff;
					hr = DownloadAddRecord(pPort);
					if( FAILED(hr) )
					{
						// If that didn't work, try unsetting the program change
						m_dwPatch = 0x80000000;
						hr = DownloadAddRecord(pPort);
					}
				}
				else
				{
					if( (m_dwPatch & 0x00ff0000) != 0x007e0000 )
					{
						m_dwPatch &= 0xffff00ff; // clear LSB
						hr = DownloadAddRecord(pPort);
						if( FAILED(hr) )
						{
							if( m_dwPatch & 0x0000ff00 )
							{
								m_dwPatch &= 0xff0000ff; // clear MSB & LSB
								hr = DownloadAddRecord(pPort);
							}
						}
					}
				}
                if (FAILED(hr))
                {
                    // Revert back to original values
   				    m_dwPatch = dwOldPatch;
				    m_dwFlags = dwOldFlags;
				    m_dwAssignPatch = dwOldAssignPatch;
                }
			}
        }
        pPort->Release();
    }
    else
    {
        Trace(1,"Error: Unable to download to Performance because pchannel %ld is not initialized on the performance.\n",m_dwPChannel);
    }
    return hr;
}



//////////////////////////////////////////////////////////////////////
// CBand::DownloadEx

STDMETHODIMP
CBand::DownloadEx(IUnknown *pAudioPath)  
{
	V_INAME(CBand::DownloadEx);
	V_PTR_READ(pAudioPath, IUnknown);
	IDirectMusicPerformance *pPerformance = NULL;
    IDirectMusicAudioPath *pPath = NULL;

    // If the band doesn't have any instruments, return immediately with S_FALSE.
    if (m_BandInstrumentList.IsEmpty())
	{
        Trace(2,"Warning: Trying to download an empty band\n");
    	return S_FALSE;
	}
    HRESULT hr = pAudioPath->QueryInterface(IID_IDirectMusicAudioPath,(void **)&pPath);
    if (SUCCEEDED(hr))
    {
        hr = pPath->GetObjectInPath(0,DMUS_PATH_PERFORMANCE,0,CLSID_DirectMusicPerformance,0,IID_IDirectMusicPerformance,(void **)&pPerformance);
    }
    else
    {
        hr = pAudioPath->QueryInterface(IID_IDirectMusicPerformance,(void **)&pPerformance);
    }
    if (SUCCEEDED(hr))
    {
	    EnterCriticalSection(&m_CriticalSection);
        IDirectMusicPerformanceP *pPerfp;
		hr = pPerformance->QueryInterface(IID_IDirectMusicPerformanceP, (void **)&pPerfp);
        if (SUCCEEDED(hr))
        {
            DWORD dwSuccess = 0;
            HRESULT hrTemp = S_OK;
            CBandInstrument* pBandInstrument = m_BandInstrumentList.GetHead();
		    for( ; SUCCEEDED(hr) && pBandInstrument != NULL; pBandInstrument = pBandInstrument->GetNext())
            {
                hr = pBandInstrument->Download(pPerfp,pPath,m_dwMidiMode);
                if (FAILED(hr))
                {
                    if (hr == DMUS_E_NOT_INIT)
                    {
                        Trace(1,"Error: Performance is not initialized - Band download terminated.\n");
                        // Performance is not initialized. Leave now.
                        break;
                    }
                    hrTemp = hr;
                    hr = S_FALSE;
                }
                else
                {
                    // At least one succeeded.
                    dwSuccess++;
                }
            }
#ifdef DXAPI
            // If we had a failure but it was not performance not initialized and we did have at least one
            // successful download, return a partial download success code.
            if (FAILED(hrTemp))
            {
                // Was this a partial download?
                if ((hr != DMUS_E_NOT_INIT) &&  dwSuccess)
                {
                    hr = DMUS_S_PARTIALDOWNLOAD;
                }
                // Otherwise, make sure we don't return S_FALSE for hr!
                else
                {
                    hr = hrTemp;
                }
            }
#endif
            pPerfp->Release();
        }
        LeaveCriticalSection(&m_CriticalSection);
    }
    if (pPath) pPath->Release();
    if (pPerformance) pPerformance->Release();
    return hr;
}

STDMETHODIMP
CBand::Download(
    IDirectMusicPerformance* pPerformance)  // @parm Performance to download instruments
                                            // to. The performance manages the mapping
                                            // of PChannels to DirectMusic ports.
{
	V_INAME(CBand::Download);
	V_PTR_READ(pPerformance, IDirectMusicPerformance);
    return DownloadEx(pPerformance);
}

HRESULT CBandInstrument::Unload(IDirectMusicPerformanceP *pPerformance, IDirectMusicAudioPath *pPath)

{
    DWORD dwPChannel;
    HRESULT hr = S_OK;
    // First, if there is an audiopath, convert the band's pchannel to performance pchannel.
    if (pPath) 
    {
        hr = pPath->ConvertPChannel(m_dwPChannel,&dwPChannel);
        if (FAILED(hr))
        {
            Trace(1,"Error: Couldn't download to Audiopath because pchannel %ld is out of bounds\n",m_dwPChannel);
            // Not a valid pchannel on this audiopath.
            return hr;
        }
    }
    else
    {
        dwPChannel = m_dwPChannel;
    }

    // We need to get the port we will be unloading from.
    IDirectMusicPort *pPort = NULL;
    DWORD dwGMFlags;

    hr = pPerformance->GetPortAndFlags(dwPChannel,&pPort,&dwGMFlags);

    if (SUCCEEDED(hr))
    {
        hr = S_FALSE; // Just in case we don't find the download record.
        CDownloadedInstrument* pDLInstrument = m_DownloadList.GetHead();

        for(; pDLInstrument; pDLInstrument = pDLInstrument->GetNext())
        {
	        if (pDLInstrument->m_pPort == pPort)
	        {
                pDLInstrument->m_cRef--;
				if(!pDLInstrument->m_cRef)
				{
					m_DownloadList.Remove(pDLInstrument);
                    if (FAILED(pPort->UnloadInstrument(pDLInstrument->m_pDLInstrument)))
                    {
                        Trace(1, "Error: UnloadInstrument %ld failed\n",m_dwPatch);    
                    }
                    pDLInstrument->m_pDLInstrument->Release();
                    pDLInstrument->m_pDLInstrument = NULL;
					delete pDLInstrument;
				}
                hr = S_OK;
                break;
	        }
        }
        pPort->Release();
    } 
    else if (!pPath && m_DownloadList.GetCount() == 1)
    {
        CDownloadedInstrument* pDLInstrument = m_DownloadList.GetHead();

        pDLInstrument->m_cRef--;

        if (!pDLInstrument->m_cRef)
        {
            m_DownloadList.Remove(pDLInstrument);
            if (FAILED(pDLInstrument->m_pPort->UnloadInstrument(pDLInstrument->m_pDLInstrument)))
            {
                Trace(1, "Error: UnloadInstrument %ld failed\n",m_dwPatch);    
            }
            pDLInstrument->m_pDLInstrument->Release();
            pDLInstrument->m_pDLInstrument = NULL;
            delete pDLInstrument;
        }
        hr = S_OK;
    }

    return hr;        
}



//////////////////////////////////////////////////////////////////////
// CBand::UnloadEx

STDMETHODIMP
CBand::UnloadEx(IUnknown *pAudioPath)  

{
	V_INAME(CBand::UnloadEx);
	V_PTR_READ(pAudioPath, IUnknown);

	IDirectMusicPerformance *pPerformance = NULL;
    IDirectMusicAudioPath *pPath = NULL;

    HRESULT hr = pAudioPath->QueryInterface(IID_IDirectMusicAudioPath,(void **)&pPath);
    if (SUCCEEDED(hr))
    {
        hr = pPath->GetObjectInPath(0,DMUS_PATH_PERFORMANCE,0,CLSID_DirectMusicPerformance,0,IID_IDirectMusicPerformance,(void **)&pPerformance);
    }
    else
    {
        hr = pAudioPath->QueryInterface(IID_IDirectMusicPerformance,(void **)&pPerformance);
    }

    if (SUCCEEDED(hr))
    {
        hr = S_FALSE; // Returns this for empty band.
	    EnterCriticalSection(&m_CriticalSection);
        IDirectMusicPerformanceP *pPerfp;
		hr = pPerformance->QueryInterface(IID_IDirectMusicPerformanceP, (void **)&pPerfp);
        if (SUCCEEDED(hr))
        {
	        CBandInstrument* pBandInstrument = m_BandInstrumentList.GetHead();
	        
	        for( ; pBandInstrument != NULL; pBandInstrument = pBandInstrument->GetNext())
	        {
                hr = pBandInstrument->Unload(pPerfp,pPath);
	        }
            pPerfp->Release();
        }
        LeaveCriticalSection(&m_CriticalSection);
    }
    if (pPath) pPath->Release();
    if (pPerformance) pPerformance->Release();
	return hr;
}

STDMETHODIMP
CBand::Unload(
    IDirectMusicPerformance* pPerformance)  // @parm Performance to unload instruments
                                            // from. The performance manages the mapping
         
											// of PChannels to DirectMusic ports.
{
	V_INAME(CBand::Unload);
	V_PTR_READ(pPerformance, IDirectMusicPerformance);
	return UnloadEx(pPerformance);
}
#endif

//////////////////////////////////////////////////////////////////////
// IDirectMusicObject

//////////////////////////////////////////////////////////////////////
// CBand::GetDescriptor

STDMETHODIMP CBand::GetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
	V_INAME(CBand::GetDescriptor);
    V_PTR_WRITE(pDesc, DMUS_OBJECTDESC);

    return (m_Info.GetDescriptor(pDesc,CLSID_DirectMusicBand));
}

//////////////////////////////////////////////////////////////////////
// CBand::SetDescriptor

STDMETHODIMP CBand::SetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
	// Argument validation
	V_INAME(CBand::SetDescriptor);
    V_PTR_READ(pDesc, DMUS_OBJECTDESC);

    return (m_Info.SetDescriptor(pDesc));
}

//////////////////////////////////////////////////////////////////////
// CBand::ParseDescriptor

STDMETHODIMP CBand::ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc) 
{
    V_INAME(CBand::ParseDescriptor);
    V_INTERFACE(pStream);
    V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);
#ifdef DXAPI	
    RIFFIO ckMain;
    HRESULT hr = S_OK;

    CRiffParser Parser(pStream);
    Parser.EnterList(&ckMain);  
    if (Parser.NextChunk(&hr))
    {
	    pDesc->guidClass = CLSID_DirectMusicBand;
	    pDesc->dwValidData |= DMUS_OBJ_CLASS;
        if (ckMain.fccType == FOURCC_BAND_FORM)
        {
			hr = ParseLegacyDescriptor(&Parser, pDesc);				
		}
		else if(ckMain.fccType == DMUS_FOURCC_BAND_FORM)
		{
			hr = ParseDirectMusicDescriptor(&Parser, pDesc);
		}
		else
		{
            Trace(2,"Warning: ParseDescriptor failed because this is not a Band file.\n"); 
			hr = DMUS_E_INVALID_BAND;
		}
	}
	return hr;
#else
    return (m_Info.ParseDescriptor(pStream,pDesc,DMUS_FOURCC_BAND_FORM,CLSID_DirectMusicBand));
#endif
}

//////////////////////////////////////////////////////////////////////
// Internal

//////////////////////////////////////////////////////////////////////
// CBand::ParseLegacyDescriptor
#ifdef DXAPI
HRESULT CBand::ParseLegacyDescriptor(CRiffParser *pParser, LPDMUS_OBJECTDESC pDesc)
{
	RIFFIO ckNext;
    HRESULT hr = S_OK;

    pParser->EnterList(&ckNext);
	while(pParser->NextChunk(&hr))
	{
		if (ckNext.ckid == FOURCC_BAND)
        {
            ioBandLegacy Band;
	        hr = pParser->Read( &Band, sizeof(Band) );
	        if( SUCCEEDED(hr) )
	        {
                pDesc->dwValidData |= DMUS_OBJ_NAME;
		        wcscpy(pDesc->wszName, Band.wstrName);
	        }
        }
    }
	return hr;
}


//////////////////////////////////////////////////////////////////////
// CBand::ParseDirectMusicDescriptor
HRESULT CBand::ParseDirectMusicDescriptor(CRiffParser *pParser, LPDMUS_OBJECTDESC pDesc)
{
	RIFFIO ckNext;
    RIFFIO ckUNFO;
    HRESULT hr = S_OK;
    DWORD dwValidData = pDesc->dwValidData;

    pParser->EnterList(&ckNext);
	while(pParser->NextChunk(&hr))
	{
		switch(ckNext.ckid)
		{
        case DMUS_FOURCC_GUID_CHUNK:
			hr = pParser->Read( &pDesc->guidObject, sizeof(GUID) );
			dwValidData |= DMUS_OBJ_OBJECT;
			break;
        case DMUS_FOURCC_VERSION_CHUNK:
			hr = pParser->Read( &pDesc->vVersion, sizeof(DMUS_VERSION) );
			dwValidData |= DMUS_OBJ_VERSION;
			break;
		case DMUS_FOURCC_CATEGORY_CHUNK:
			hr = pParser->Read( &pDesc->wszCategory, sizeof(pDesc->wszCategory) );
			dwValidData |= DMUS_OBJ_CATEGORY;
		case DMUS_FOURCC_DATE_CHUNK:
			hr = pParser->Read( &pDesc->ftDate, sizeof(FILETIME) );
			dwValidData |= DMUS_OBJ_DATE;
			break;
		case FOURCC_LIST:
			switch(ckNext.fccType)
			{
            case DMUS_FOURCC_UNFO_LIST:
                pParser->EnterList(&ckUNFO);
                while (pParser->NextChunk(&hr))
				{
					if (( ckUNFO.ckid == DMUS_FOURCC_UNAM_CHUNK ) || 
                        (ckUNFO.ckid == mmioFOURCC('I','N','A','M')))
                    {
						hr = pParser->Read(&pDesc->wszName, sizeof(pDesc->wszName));
						dwValidData |= DMUS_OBJ_NAME;
					}
				}
                pParser->LeaveList();
				break;            
			}
			break;
		}
    }
    if (SUCCEEDED(hr))
    {
        pDesc->dwValidData = dwValidData;
    }
	return hr;
}

//////////////////////////////////////////////////////////////////////
// CBand::LoadLegacyBand

HRESULT CBand::LoadLegacyBand(CRiffParser *pParser, IDirectMusicLoader* pIDMLoader)
{
	RIFFIO ckNext;
    HRESULT hr = S_OK;

    pParser->EnterList(&ckNext);
	while(pParser->NextChunk(&hr))
	{
		if (ckNext.ckid == FOURCC_BAND)
        {
            ioBandLegacy Band;
			hr = pParser->Read( &Band, sizeof(Band) );
			if( SUCCEEDED(hr) )
			{
			    wcscpy(m_wszName, Band.wstrName);
                m_dwValidData |= DMUS_OBJ_NAME;
			    hr = BuildLegacyInstrumentList(Band, pIDMLoader);
                if (SUCCEEDED(hr))
                {
                    m_dwFlags |= DMB_LOADED;
               	    if(Band.fDefault)
                    {
	                    m_dwFlags |= DMB_DEFAULT;
                    }
                }
        	}
        }
    }
	return hr;
}
#endif
//////////////////////////////////////////////////////////////////////
// CBand::LoadDirectMusicBand

HRESULT CBand::LoadDirectMusicBand(CRiffParser *pParser, IDirectMusicLoader *pIDMLoader)
{
	HRESULT hrDLS = S_OK;

	RIFFIO ckNext;
    RIFFIO ckChild;
    HRESULT hr = S_OK;

    pParser->EnterList(&ckNext);
	while(pParser->NextChunk(&hr))
	{
		switch(ckNext.ckid)
		{
        case DMUS_FOURCC_GUID_CHUNK:
        case DMUS_FOURCC_VERSION_CHUNK:
        case DMUS_FOURCC_CATEGORY_CHUNK:
        case DMUS_FOURCC_DATE_CHUNK:
            hr = m_Info.ReadChunk(pParser,ckNext.ckid);
			break;
		case FOURCC_LIST:
			switch(ckNext.fccType)
			{
#ifdef DXAPI
            case DMUS_FOURCC_UNFO_LIST:
                pParser->EnterList(&ckChild);
                while (pParser->NextChunk(&hr))
				{
					if (( ckChild.ckid == DMUS_FOURCC_UNAM_CHUNK ) || 
                        (ckChild.ckid == mmioFOURCC('I','N','A','M')))
                    {
						hr = pParser->Read(&m_wszName, sizeof(m_wszName));
						m_dwValidData |= DMUS_OBJ_NAME;
					}
				}
                pParser->LeaveList();
				break;
#else
            case DMUS_FOURCC_UNFO_LIST:
                hr = m_Info.ReadChunk(pParser,ckNext.fccType);
				break;
#endif
            case DMUS_FOURCC_INSTRUMENTS_LIST:
	            pParser->EnterList(&ckChild);
                while (pParser->NextChunk(&hr))
                {
		            if ((ckChild.ckid == FOURCC_LIST) && 
                        (ckChild.fccType == DMUS_FOURCC_INSTRUMENT_LIST))
                    {
			            hr = ExtractBandInstrument(pParser, pIDMLoader);
			            if (hr != S_OK)
			            {
				            hrDLS = hr;
			            }
		            }
	            }
                pParser->LeaveList();
				break;
			}
		}
    }
    pParser->LeaveList();

    if (hr == S_OK && hrDLS != S_OK)
	{
		hr = hrDLS;
	}

	return hr;
}

//////////////////////////////////////////////////////////////////////
// CBand::BuildLegacyInstrumentList
#ifdef DXAPI
HRESULT CBand::BuildLegacyInstrumentList(const ioBandLegacy& iob,
											IDirectMusicLoader* pIDMLoader)
{
	// Legacy band channel to pchannel translation table
	static char sj_translation_table[] = { -1, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3 };

	HRESULT hrGM = S_OK;
	HRESULT hr = S_OK;

	EnterCriticalSection(&m_CriticalSection);
	
	char szCollection[DM_LEGACY_BAND_COLLECTION_NAME_LEN];
	
	for(DWORD i = 0; SUCCEEDED(hr) && i < DMBAND_NUM_LEGACY_INSTRUMENTS; i++)
	{
		CBandInstrument* pBandInstrument = new CBandInstrument();
		if(pBandInstrument)
		{
			if(iob.awDLSBank[i] & 0x8000) 
			{
				// We have a plain old GM collection where MSB & LSB are both zero
				pBandInstrument->m_dwPatch = 0;
				pBandInstrument->m_dwPatch |= (iob.abPatch[i] & 0x7F);
				pBandInstrument->m_dwFlags |= (DMUS_IO_INST_GM | DMUS_IO_INST_GS);
			}
			else
			{
				if(iob.awDLSBank[i] & 0x4000)
				{
					// We has a GS collection with valid MSB and LSB numbers
					pBandInstrument->m_dwPatch = 0;
					pBandInstrument->m_dwPatch |= (iob.abDLSPatch[i] & 0x7F);
					pBandInstrument->m_dwPatch |= (iob.awDLSBank[i] & 0x7F) << 8; // Set LSB
					pBandInstrument->m_dwPatch |= ((iob.awDLSBank[i] >> 7) & 0x7F) << 16; // Set MSB
					pBandInstrument->m_dwFlags |= (DMUS_IO_INST_BANKSELECT | DMUS_IO_INST_GS | DMUS_IO_INST_GM);
				}
				else
				{
					if(iob.szCollection[0] == '\0')
					{
						// We have no unique DLS file so we will assume GM
						pBandInstrument->m_dwPatch = 0;
						pBandInstrument->m_dwPatch |= (iob.abPatch[i] & 0x7F);
						pBandInstrument->m_dwFlags |= (DMUS_IO_INST_GM | DMUS_IO_INST_GS);
					}
					else
					{
						// We have a unique DLS file
						pBandInstrument->m_dwPatch = 0;
						pBandInstrument->m_dwPatch |= (iob.abDLSPatch[i] & 0x7F);
						pBandInstrument->m_dwPatch |= (iob.awDLSBank[i] & 0x7F) << 8; // Set LSB
						pBandInstrument->m_dwPatch |= ((iob.awDLSBank[i] >> 7) & 0x7F) << 16; // Set MSB
						pBandInstrument->m_dwFlags |= (DMUS_IO_INST_BANKSELECT);
						lstrcpy(szCollection, iob.szCollection);
					}
				}
			}
			
			pBandInstrument->m_dwFlags |= (DMUS_IO_INST_TRANSPOSE | DMUS_IO_INST_PAN | DMUS_IO_INST_VOLUME | DMUS_IO_INST_PATCH);
            pBandInstrument->m_bPan = iob.abPan[i];
            pBandInstrument->m_bVolume = iob.abVolume[i];
			pBandInstrument->m_dwPChannel = sj_translation_table[i + 1];
			// Set drum-kit bit if a drum-kit
			if(pBandInstrument->m_dwPChannel % 16 == 9)
			{
				pBandInstrument->m_dwPatch |= 0x80000000;
			}

			pBandInstrument->m_nTranspose = iob.achOctave[i];
			
			pBandInstrument->m_pIDMCollection = NULL;

			// We will try to load the collection but if we can not we will continure
			// and use the default GM on the card
			
			if(pIDMLoader && (pBandInstrument->m_dwFlags & DMUS_IO_INST_GM || pBandInstrument->m_dwFlags & DMUS_IO_INST_GS))
			{
				HRESULT hrTemp = LoadCollection(&(pBandInstrument->m_pIDMCollection),
									NULL,
									pIDMLoader);
				if (FAILED(hrTemp))
				{
					hrGM = hrTemp;
				}
			}
			else if(pIDMLoader)
			{
				HRESULT hrTemp = LoadCollection(&(pBandInstrument->m_pIDMCollection),
									szCollection,
									pIDMLoader);
				if (FAILED(hrTemp))
				{
					hrGM = hrTemp;
				}
			}
			
			m_BandInstrumentList.AddHead(pBandInstrument);
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}

	LeaveCriticalSection(&m_CriticalSection);

	// This function expects the caller to cleanup m_BandInstrumentList on any errors
	if (SUCCEEDED(hrGM) || hr != S_OK)
	{
		return hr;
	}
	else
	{
		return DMUS_S_PARTIALLOAD;
	}
}
#endif
//////////////////////////////////////////////////////////////////////
// CBand::ExtractBandInstrument

HRESULT CBand::ExtractBandInstrument(CRiffParser *pParser,
                                    IDirectMusicLoader* pIDMLoader)
{
	CBandInstrument* pBandInstrument = new CBandInstrument();
	
	if(pBandInstrument == NULL)
	{
		return E_OUTOFMEMORY;
	}


    RIFFIO ckNext;
	HRESULT hrGM = S_OK;
    HRESULT hr = S_OK;
    
    pParser->EnterList(&ckNext);
    while (pParser->NextChunk(&hr))
    {
		switch(ckNext.ckid)
		{
        case  DMUS_FOURCC_INSTRUMENT_CHUNK:
            {
                DMUS_IO_INSTRUMENT ioDMInst;
				ZeroMemory( &ioDMInst, sizeof(DMUS_IO_INSTRUMENT) );
				hr = pParser->Read(&ioDMInst, sizeof(DMUS_IO_INSTRUMENT));
				if(SUCCEEDED(hr))
				{
					pBandInstrument->m_dwPatch = ioDMInst.dwPatch;
					pBandInstrument->m_dwAssignPatch = ioDMInst.dwAssignPatch;
					pBandInstrument->m_bPan = ioDMInst.bPan;
					pBandInstrument->m_bVolume = ioDMInst.bVolume;
					pBandInstrument->m_dwPChannel = ioDMInst.dwPChannel;
					pBandInstrument->m_nTranspose = ioDMInst.nTranspose;
					pBandInstrument->m_dwFlags = ioDMInst.dwFlags;
					pBandInstrument->m_dwChannelPriority = ioDMInst.dwChannelPriority;
					pBandInstrument->m_nPitchBendRange = ioDMInst.nPitchBendRange;

					CopyMemory(&(pBandInstrument->m_dwNoteRanges[0]),
							   &(ioDMInst.dwNoteRanges[0]),
							   (sizeof(DWORD) * 4));
					
					pBandInstrument->m_pIDMCollection = NULL;

				}
            }
			break;
        case FOURCC_LIST :
			switch(ckNext.fccType)
			{
            case DMUS_FOURCC_REF_LIST:
#ifdef DXAPI
				HRESULT hrTemp = GetCollectionRefAndLoad(pParser,pIDMLoader,pBandInstrument);
				if (FAILED(hrTemp))
				{
					hrGM = hrTemp;
				}
#else
                if (pBandInstrument->m_dwFlags & DMUS_IO_INST_PATCH)
                {
				    hr = GetCollectionRefAndLoad(pParser,pIDMLoader,pBandInstrument);
                }
#endif
    			break;
			}
			break;
		}
	}
    pParser->LeaveList();

	if(SUCCEEDED(hr))
	{
		if(pBandInstrument->m_pIDMCollection == NULL &&
		   (pBandInstrument->m_dwFlags & (DMUS_IO_INST_GM | DMUS_IO_INST_GS | DMUS_IO_INST_XG)) )
		{
#ifdef DXAPI
			HRESULT hrTemp = LoadCollection(&(pBandInstrument->m_pIDMCollection),
								NULL,
								pIDMLoader);
			if (FAILED(hrTemp))
			{
				hrGM = hrTemp;
			}
#else
            if (pBandInstrument->m_dwFlags & DMUS_IO_INST_PATCH)
            {
			    hr = LoadCollection(&(pBandInstrument->m_pIDMCollection),
								    NULL,
								    pIDMLoader);
            }
#endif
        }
	}
    if (SUCCEEDED(hr))
    {
		m_BandInstrumentList.AddHead(pBandInstrument);
    }
    else
    {
        delete pBandInstrument;
    }
#ifdef DXAPI
	if (SUCCEEDED(hrGM) || hr != S_OK)
	{
		return hr;
	}
	else
	{
		return DMUS_S_PARTIALLOAD;
	}
#else
    return hr;
#endif
}

//////////////////////////////////////////////////////////////////////
// CBand::GetCollectionRefAndLoad

HRESULT CBand::GetCollectionRefAndLoad(CRiffParser *pParser,
                                        IDirectMusicLoader *pIDMLoader, 
                                        CBandInstrument *pBandInstrument)
{
	DMUS_OBJECTDESC desc;
    CLinkParser LinkParser;
    HRESULT hr = LinkParser.ReadReference(pParser,&desc);
/*    desc.dwValidData = 0;
	desc.dwSize = sizeof(desc);

	RIFFIO ckNext;
    HRESULT hr = S_OK;
    pParser->EnterList(&ckNext);
    while (pParser->NextChunk(&hr))
	{
		switch(ckNext.ckid)
		{
		case  DMUS_FOURCC_REF_CHUNK:
			DMUS_IO_REFERENCE ioDMRef;
			hr = pParser->Read(&ioDMRef, sizeof(DMUS_IO_REFERENCE));
			desc.guidClass = ioDMRef.guidClassID;
			desc.dwValidData |= ioDMRef.dwValidData;
			desc.dwValidData |= DMUS_OBJ_CLASS;
			break;
		case DMUS_FOURCC_GUID_CHUNK:
			hr = pParser->Read(&(desc.guidObject), sizeof(GUID));
			desc.dwValidData |=  DMUS_OBJ_OBJECT;
			break;
		case DMUS_FOURCC_DATE_CHUNK:
			hr = pParser->Read(&(desc.ftDate), sizeof(FILETIME));
			desc.dwValidData |=  DMUS_OBJ_DATE;
			break;
		case DMUS_FOURCC_NAME_CHUNK:
			hr = pParser->Read(desc.wszName, sizeof(desc.wszName));
			desc.dwValidData |=  DMUS_OBJ_NAME;
			break;
		case DMUS_FOURCC_FILE_CHUNK:
			hr = pParser->Read(desc.wszFileName, sizeof(desc.wszFileName));
			desc.dwValidData |=  DMUS_OBJ_FILENAME;
			break;
		case DMUS_FOURCC_CATEGORY_CHUNK:
			hr = pParser->Read(desc.wszCategory, sizeof(desc.wszCategory));
			desc.dwValidData |=  DMUS_OBJ_CATEGORY;
			break;
		case DMUS_FOURCC_VERSION_CHUNK:
			DMUS_IO_VERSION dmioVer;
			hr = pParser->Read(&dmioVer, sizeof(DMUS_IO_VERSION));
			desc.vVersion.dwVersionMS = dmioVer.dwVersionMS;
			desc.vVersion.dwVersionLS = dmioVer.dwVersionLS;
			desc.dwValidData |= DMUS_OBJ_VERSION;
			break;
		}
	}
    pParser->LeaveList();
*/
	if(SUCCEEDED(hr))
	{
		hr = pIDMLoader->GetObject(&desc,IID_IDirectMusicCollection, (void**)&(pBandInstrument->m_pIDMCollection));
	}
#ifdef DBG
    if (FAILED(hr))
    {
        if (desc.dwValidData &  DMUS_OBJ_FILENAME)
        {
            Trace(1,"Error: Unable to load DLS Collection from file %ls for instrument %lx\n",
                desc.wszFileName, pBandInstrument->m_dwPatch);
        }
        else if (desc.dwValidData & DMUS_OBJ_NAME)
        {
            Trace(1,"Error: Unable to load DLS Collection %ls for instrument %lx\n",
                desc.wszName, pBandInstrument->m_dwPatch);
        }
        else
        {
            Trace(1,"Error: Unable to load DLS Collection for instrument %lx\n",
                pBandInstrument->m_dwPatch);
        }
    }
#endif
	return hr;
}

//////////////////////////////////////////////////////////////////////
// CBand::Load
#ifdef DXAPI
HRESULT CBand::Load(DMUS_IO_PATCH_ITEM& rPatchEvent)
{
	// This method is used to load PatchEvents generated by the parsing of a MIDI file.
	// Each PatchEvent represents a program change and possibly a bank select. Using 
	// this information this method will generate a band with one instrument.

	HRESULT hr = S_OK;

	EnterCriticalSection(&m_CriticalSection);
	
	CBandInstrument* pBandInstrument = NULL;

	pBandInstrument = new CBandInstrument();
		
	if(pBandInstrument)
	{
		pBandInstrument->m_dwFlags |= rPatchEvent.dwFlags;

		if(pBandInstrument->m_dwFlags & DMUS_IO_INST_PATCH)
		{
			pBandInstrument->m_dwPatch |= (rPatchEvent.byPChange & 0x7F); // Program change
		}

		if(pBandInstrument->m_dwFlags & DMUS_IO_INST_BANKSELECT)
		{
			pBandInstrument->m_dwPatch |= (rPatchEvent.byLSB & 0x7F) << 8; // Set LSB
			pBandInstrument->m_dwPatch |= (rPatchEvent.byMSB & 0x7F) << 16; // Set MSB
		}

		if(IsGS(rPatchEvent))
		{
			pBandInstrument->m_dwFlags |= DMUS_IO_INST_GS;
			if( (rPatchEvent.byLSB == 0) && (rPatchEvent.byMSB == 0) )
			{
				pBandInstrument->m_dwFlags |= DMUS_IO_INST_GM;
			}
		}

		pBandInstrument->m_dwPChannel = (rPatchEvent.byStatus & 0xF);
		pBandInstrument->m_pIDMCollection = rPatchEvent.pIDMCollection;
		pBandInstrument->m_fNotInFile = rPatchEvent.fNotInFile;
		if(pBandInstrument->m_pIDMCollection)
		{
			(pBandInstrument->m_pIDMCollection)->AddRef();
		}
		
		// Set the time for the band. Since this band will have only one instrument in
		// it we use the time for PatchEvent as the time for the band
		m_lTimeLogical = rPatchEvent.lTime;
		m_lTimePhysical = m_lTimeLogical;
		
		m_BandInstrumentList.AddHead(pBandInstrument);
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}
	
	if(SUCCEEDED(hr))
	{
		m_dwFlags |= DMB_LOADED;
	}
	else
	{
		if(pBandInstrument)
		{
			delete pBandInstrument;
		}
	}

	LeaveCriticalSection(&m_CriticalSection);
	
	return hr;
}
#endif
//////////////////////////////////////////////////////////////////////
// CBand::Load

HRESULT CBand::Load(CBandInstrument* pInstrument)
{
	HRESULT hr = S_OK;

	EnterCriticalSection(&m_CriticalSection);
	
	CBandInstrument* pBandInstrument = NULL;

	pBandInstrument = new CBandInstrument();
		
	if(pBandInstrument)
	{
		pBandInstrument->m_dwPatch = pInstrument->m_dwPatch;
		pBandInstrument->m_dwAssignPatch = pInstrument->m_dwAssignPatch;
		pBandInstrument->m_dwPChannel = pInstrument->m_dwPChannel;
		pBandInstrument->m_dwFlags = pInstrument->m_dwFlags;
		pBandInstrument->m_bPan = pInstrument->m_bPan;
		pBandInstrument->m_bVolume = pInstrument->m_bVolume;
		pBandInstrument->m_nTranspose = pInstrument->m_nTranspose;
		pBandInstrument->m_pIDMCollection = pInstrument->m_pIDMCollection;

		CopyMemory(pBandInstrument->m_dwNoteRanges, pInstrument->m_dwNoteRanges, sizeof(pInstrument->m_dwNoteRanges)); 
		if(pBandInstrument->m_pIDMCollection)
		{
			(pBandInstrument->m_pIDMCollection)->AddRef();
		}

		m_BandInstrumentList.AddHead(pBandInstrument);
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}

	if(SUCCEEDED(hr))
	{
		m_dwFlags |= DMB_LOADED;
	}
	else
	{
		if(pBandInstrument)
		{
			delete pBandInstrument;
		}
	}

	LeaveCriticalSection(&m_CriticalSection);
	
	return hr;
}

//////////////////////////////////////////////////////////////////////
// CBand::SendMessages

HRESULT CBand::SendMessages(CBandTrkStateData* pBTStateData,
							   MUSIC_TIME mtOffset,
							   REFERENCE_TIME rtOffset,
							   bool fClockTime)
{
	if(pBTStateData == NULL)
	{	
		return E_POINTER;
	}
	HRESULT hr = S_OK;

	EnterCriticalSection(&m_CriticalSection);

	CBandInstrument* pInstrument = m_BandInstrumentList.GetHead();
	for( ; pInstrument && SUCCEEDED(hr); pInstrument = pInstrument->GetNext())
	{
		if( pInstrument->m_fNotInFile && !pInstrument->m_fGMOnly )
		{
			// don't send program changes for instruments that were automatically
			// generated by midi file parsing, unless we've set GMOnly.
			continue;
		}
		hr = SendInstrumentAtTime(pInstrument, pBTStateData, m_lTimePhysical, mtOffset, rtOffset, fClockTime);
	}
	
	LeaveCriticalSection(&m_CriticalSection);

	return hr;
}

HRESULT CBand::AllocPMsgFromGenericTemplate(
	DWORD dwType,
	IDirectMusicPerformance *pPerformance,
	DMUS_PMSG **ppMsg,
	ULONG cb,
	DMUS_PMSG *pMsgGenericFields)
{
	HRESULT hr = pPerformance->AllocPMsg(cb, ppMsg);
	if (SUCCEEDED(hr))
	{
		DWORD dwSize = (*ppMsg)->dwSize; // Remember the size.
		assert(dwSize == cb);
		ZeroMemory(*ppMsg, cb); // Clear it - ensures we zero the non-DMUS_PMSG_PART fields.
		CopyMemory(*ppMsg, pMsgGenericFields, sizeof(*pMsgGenericFields)); // Copy the DMUS_PMSG_PART fields.

		// Fill in the correct size and type
		(*ppMsg)->dwSize = dwSize;
		(*ppMsg)->dwType = dwType;
	}
	return hr;
}

HRESULT CBand::StampSendFreePMsg(
				IDirectMusicPerformance *pPerformance,
				IDirectMusicGraph *pGraph,
				DMUS_PMSG *pMsg)
{
	// Let the graph set the delivery parameters.
	HRESULT hr = pGraph->StampPMsg(pMsg);
	if (SUCCEEDED(hr))
		hr = pPerformance->SendPMsg(pMsg);
	if (FAILED(hr))
		hr = pPerformance->FreePMsg(pMsg);
	return hr;
}

HRESULT CBand::SendInstrumentAtTime(CBandInstrument* pInstrument, 
									   CBandTrkStateData* pBTStateData, 
									   MUSIC_TIME mtTimeToPlay,
									   MUSIC_TIME mtOffset,
									   REFERENCE_TIME rtOffset,
									   bool fClockTime)
{
	if(pInstrument == NULL || pBTStateData == NULL)
	{
		return E_POINTER;
	}

    IDirectMusicGraph *pGraph = NULL;
    IDirectMusicPerformance *pPerformance = pBTStateData->m_pPerformance;
    DWORD dwVirtualTrackID = pBTStateData->m_dwVirtualTrackID;
    DWORD dwPatch = 0;
    BOOL fMute;
	DWORD dwPChannel;

	// Get the mute/pchannel reassignment.
	MUSIC_TIME mtParam = ( m_lTimeLogical < 0 ) ? 0 : m_lTimeLogical;
	m_PChMap.GetInfo( pInstrument->m_dwPChannel, mtParam, mtOffset, m_dwGroupBits,
		pPerformance, &fMute, &dwPChannel, fClockTime );
	if( fMute )
		return S_OK;

	HRESULT hr = pBTStateData->m_pSegmentState->QueryInterface(IID_IDirectMusicGraph,
															   reinterpret_cast<void**>(&pGraph));
	if(FAILED(hr))
		return hr;

	EnterCriticalSection(&m_CriticalSection);

	DMUS_PMSG pmsgGeneric; // template for stamping out the common fields in the various specific kinds of messages
	ZeroMemory(&pmsgGeneric, sizeof(pmsgGeneric));
	if (fClockTime)
	{
		pmsgGeneric.rtTime =  mtTimeToPlay * REF_PER_MIL + rtOffset;
		pmsgGeneric.dwFlags |= DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME;
	}
	else
	{
		pmsgGeneric.mtTime =  mtTimeToPlay + mtOffset;
		pmsgGeneric.dwFlags |= DMUS_PMSGF_MUSICTIME;
	}
	pmsgGeneric.dwPChannel = dwPChannel;
	pmsgGeneric.dwVirtualTrackID = dwVirtualTrackID;
	pmsgGeneric.dwGroupID = m_dwGroupBits;

	if(pInstrument->m_dwFlags & DMUS_IO_INST_PATCH)
	{
	    if(pInstrument->m_dwFlags & DMUS_IO_INST_BANKSELECT)
	    {
		    if(pInstrument->m_dwFlags & DMUS_IO_INST_ASSIGN_PATCH)
		    {
			    dwPatch = pInstrument->m_dwAssignPatch & 0x007F7F00;			
		    }
		    else
		    {
			    dwPatch = pInstrument->m_dwPatch & 0x007F7F00;
#ifdef DXAPI
			    // if the m_fGMOnly flag is set, and either we're GS or we're XG and
			    // the instument's port supports XG, use the full patch
                if (pInstrument->m_fGMOnly || (pInstrument->m_dwFlags & DMUS_IO_INST_XG))
                {
                    bool fXG = XGInHardware(pPerformance,pBTStateData->m_pSegmentState,pInstrument->m_dwPChannel);
                    if(pInstrument->m_fGMOnly)
                    {
	                    if ( m_dwMidiMode & DMUS_MIDIMODEF_GS )
	                    {
		                    dwPatch = pInstrument->m_dwFullPatch & 0x007F7F00;
	                    }
	                    if ( (m_dwMidiMode & DMUS_MIDIMODEF_XG) && fXG )
	                    {
		                    dwPatch = pInstrument->m_dwFullPatch & 0x007F7F00;
	                    }
                    }
                    // If the instrument is an XG instrument and the hardware doesn't support
                    // XG, strip off the bank selects.
                    if ( (pInstrument->m_dwFlags & DMUS_IO_INST_XG) && !fXG)
                    {
	                    dwPatch = 0;
                    }
                }
#endif
		    }
	    }

        // Now, get the program change.
		if(pInstrument->m_dwFlags & DMUS_IO_INST_ASSIGN_PATCH)
		{
            dwPatch |= pInstrument->m_dwAssignPatch & 0x7f;	
		}
		else
		{
            dwPatch |= pInstrument->m_dwPatch & 0x7f;	
		}

		DMUS_PATCH_PMSG *pMsg = NULL;
		hr = AllocPMsgFromGenericTemplate(DMUS_PMSGT_PATCH, pPerformance, reinterpret_cast<DMUS_PMSG**>(&pMsg), sizeof(*pMsg), &pmsgGeneric);
		if(SUCCEEDED(hr))
		{
			// DMUS_PATCH_PMSG members that need to be initialized 
			pMsg->byInstrument = (BYTE) dwPatch & 0x7F;
			pMsg->byMSB = (BYTE) ((dwPatch >> 16) & 0x7F);
			pMsg->byLSB = (BYTE) ((dwPatch >> 8) & 0x7F);

			hr = StampSendFreePMsg(pPerformance, pGraph, reinterpret_cast<DMUS_PMSG*>(pMsg));
		}
	}

	if(pInstrument->m_dwFlags & DMUS_IO_INST_TRANSPOSE)
	{
		DMUS_TRANSPOSE_PMSG *pMsg = NULL;
		hr = AllocPMsgFromGenericTemplate(DMUS_PMSGT_TRANSPOSE, pPerformance, reinterpret_cast<DMUS_PMSG**>(&pMsg), sizeof(*pMsg), &pmsgGeneric);
		if(SUCCEEDED(hr))
		{
			// DMUS_TRANSPOSE_PMSG members that need to be initialized 
			pMsg->nTranspose = pInstrument->m_nTranspose;

			hr = StampSendFreePMsg(pPerformance, pGraph, reinterpret_cast<DMUS_PMSG*>(pMsg));
        }
	}

	if(pInstrument->m_dwFlags & DMUS_IO_INST_VOLUME)
	{
		// Set Volume
        DMUS_MIDI_PMSG* pMsg = NULL;
		hr = AllocPMsgFromGenericTemplate(DMUS_PMSGT_MIDI, pPerformance, reinterpret_cast<DMUS_PMSG**>(&pMsg), sizeof(*pMsg), &pmsgGeneric);

		if(SUCCEEDED(hr))
		{
			// DMUS_MIDI_PMSG members that need to be initialized 
			pMsg->bStatus = MIDI_CONTROL_CHANGE;
			pMsg->bByte1 = MIDI_CC_VOLUME;
			pMsg->bByte2 = pInstrument->m_bVolume;

			hr = StampSendFreePMsg(pPerformance, pGraph, reinterpret_cast<DMUS_PMSG*>(pMsg));
        }
	}

	if(pInstrument->m_dwFlags & DMUS_IO_INST_PAN)
	{
		// Set Pan
        DMUS_MIDI_PMSG* pMsg = NULL;
		hr = AllocPMsgFromGenericTemplate(DMUS_PMSGT_MIDI, pPerformance, reinterpret_cast<DMUS_PMSG**>(&pMsg), sizeof(*pMsg), &pmsgGeneric);

		if(SUCCEEDED(hr))
		{
			// DMUS_MIDI_PMSG members that need to be initialized 
			pMsg->bStatus = MIDI_CONTROL_CHANGE;
			pMsg->bByte1 = MIDI_CC_PAN;
			pMsg->bByte2 = pInstrument->m_bPan;

			hr = StampSendFreePMsg(pPerformance, pGraph, reinterpret_cast<DMUS_PMSG*>(pMsg));
        }
	}

	if(pInstrument->m_dwFlags & DMUS_IO_INST_CHANNEL_PRIORITY)
	{
		DMUS_CHANNEL_PRIORITY_PMSG *pMsg = NULL;
		hr = AllocPMsgFromGenericTemplate(DMUS_PMSGT_CHANNEL_PRIORITY, pPerformance, reinterpret_cast<DMUS_PMSG**>(&pMsg), sizeof(*pMsg), &pmsgGeneric);
		if(SUCCEEDED(hr))
		{
			// DMUS_CHANNEL_PRIORITY_PMSG members that need to be initialized 
			pMsg->dwChannelPriority = pInstrument->m_dwChannelPriority;

			hr = StampSendFreePMsg(pPerformance, pGraph, reinterpret_cast<DMUS_PMSG*>(pMsg));
        }
	}

	if(pInstrument->m_dwFlags & DMUS_IO_INST_PITCHBENDRANGE)
	{
		DMUS_CURVE_PMSG *pMsg = NULL;
		hr = AllocPMsgFromGenericTemplate(DMUS_PMSGT_CURVE, pPerformance, reinterpret_cast<DMUS_PMSG**>(&pMsg), sizeof(*pMsg), &pmsgGeneric);
		if(SUCCEEDED(hr))
		{
			pMsg->dwFlags |= DMUS_PMSGF_DX8; // pitch band is a DX8-only flag

			// DMUS_CURVE_PMSG members that need to be initialized 
			pMsg->nEndValue = pInstrument->m_nPitchBendRange << 7;
			pMsg->nOffset = static_cast<short>(m_lTimePhysical - m_lTimeLogical);
			pMsg->bType = DMUS_CURVET_RPNCURVE;
			pMsg->bCurveShape = DMUS_CURVES_INSTANT;
			pMsg->wParamType = RPN_PITCHBEND;
			// Leave as zero: mtDuration, mtOriginalStart, mtResetDuration, nStartValue, nResetValue,
			//                wMeasure, bBeat, bGrid, wMergeIndex

			hr = StampSendFreePMsg(pPerformance, pGraph, reinterpret_cast<DMUS_PMSG*>(pMsg));
		}
	}

	pGraph->Release();
	
	LeaveCriticalSection(&m_CriticalSection);

	return hr;
}


//////////////////////////////////////////////////////////////////////
// CBand::LoadCollection

HRESULT CBand::LoadCollection(IDirectMusicCollection** ppIDMCollection,
								 char* pszCollection,
								 IDirectMusicLoader* pIDMLoader)
{
	// Any changes made to this function should also be made to LoadCollection
	// in dmime.dll

	assert(ppIDMCollection);
	assert(pIDMLoader);

	DMUS_OBJECTDESC desc;
	ZeroMemory(&desc, sizeof(desc));
	desc.dwSize = sizeof(desc);

	desc.guidClass = CLSID_DirectMusicCollection;

	if(pszCollection == NULL)
	{
		desc.guidObject = GUID_DefaultGMCollection;
		desc.dwValidData |= (DMUS_OBJ_CLASS | DMUS_OBJ_OBJECT);
	}
	else
	{
		MultiByteToWideChar(CP_ACP, 0, pszCollection, -1, desc.wszName, DMUS_MAX_NAME);
		desc.dwValidData |= (DMUS_OBJ_CLASS | DMUS_OBJ_NAME);
	}

	HRESULT hr = pIDMLoader->GetObject(&desc,IID_IDirectMusicCollection, (void**)ppIDMCollection);
#ifdef DBG
    if (FAILED(hr) && !pszCollection)
    {
        Trace(1,"Error: Unable to access General MIDI instrument (probably should be removed from Band.)\n");
    }
#endif
	return hr;
}

//////////////////////////////////////////////////////////////////////
// CBand::GetPChannelCount

DWORD CBand::GetPChannelCount()
{
	EnterCriticalSection(&m_CriticalSection);

	DWORD dwCount = 0;
	CBandInstrument* pInstrument = m_BandInstrumentList.GetHead();
	for( ; pInstrument; pInstrument = pInstrument->GetNext())
	{
		dwCount++;
	}
	
	LeaveCriticalSection(&m_CriticalSection);

	return dwCount;
}

//////////////////////////////////////////////////////////////////////
// CBand::GetPChannels

HRESULT CBand::GetPChannels(DWORD *pdwPChannels, DWORD *pdwNumWritten)
{
	assert(pdwPChannels);
	assert(pdwNumWritten);

	EnterCriticalSection(&m_CriticalSection);
	
	*pdwNumWritten = 0;

	CBandInstrument* pInstrument = m_BandInstrumentList.GetHead();
	for(; pInstrument; pInstrument = pInstrument->GetNext())
	{
		*pdwPChannels++ = pInstrument->m_dwPChannel;
		(*pdwNumWritten)++;
	}

	LeaveCriticalSection(&m_CriticalSection);

	return S_OK;
}
#ifdef DXAPI
HRESULT CBandInstrument::BuildNoteRangeArray(DWORD *pNoteRangeMap, DMUS_NOTERANGE **ppNoteRanges, DWORD *pdwNumNoteRanges)
{
	const int c_iIn = 0;
	const int c_iOut = 1;

	HRESULT hr = S_OK;

	// Count the number of DMUS_NOTERANGE structures we need to allocate
	DWORD dwNRNum = 0;
	int nState = c_iOut;
    int nIndex;
	for(nIndex = 0; nIndex < 4; nIndex++)
	{
		DWORD dwTemp = pNoteRangeMap[nIndex];
		DWORD dwBitPos = 0;
		while(dwBitPos < 32)
		{
			if(dwTemp & 0x1ul)
			{
				if(nState == c_iOut)
				{
					nState = c_iIn;
					dwNRNum++;
				}
			}
			else
			{
				nState = c_iOut;
			}
			
			dwTemp = dwTemp >> 1;
			dwBitPos++;
		}	
	}

	// If the NoteRangeMap is empty or full we do nothing
	// since this will cause NULL to be returned which means we 
	// want to download the complete instrument
	if(dwNRNum && dwNRNum < 128)
	{
		*ppNoteRanges = new DMUS_NOTERANGE[dwNRNum];
		if(*ppNoteRanges)
		{
            DWORD dwNRIdx = 0;

            for(dwNRIdx = 0; dwNRIdx < dwNRNum; dwNRIdx++)
            {
			    (*ppNoteRanges)[dwNRIdx].dwLowNote = 0;
                (*ppNoteRanges)[dwNRIdx].dwHighNote = 127;
            }

			dwNRIdx = 0;
            nState = c_iOut;
			for(nIndex = 0; nIndex < 4; nIndex++)
			{
                DWORD dwTemp = pNoteRangeMap[nIndex];
				DWORD dwBitPos = 0;
				while(dwBitPos < 32)
				{
					if(dwTemp & 0x1ul)
					{
						if(nState == c_iOut)
						{
							nState = c_iIn;
							(*ppNoteRanges)[dwNRIdx].dwLowNote = dwBitPos + (nIndex * 32);
						}
					}
					else if(nState == c_iIn)
					{
						(*ppNoteRanges)[dwNRIdx].dwHighNote = dwBitPos + (nIndex * 32) - 1;
                        nState = c_iOut;
                        dwNRIdx++;
					}
					
					dwTemp = dwTemp >> 1;
					dwBitPos++;
				}	
			}

            assert(nState == c_iIn ? dwNRIdx == dwNRNum - 1 : dwNRIdx == dwNRNum);

			*pdwNumNoteRanges = dwNRNum;
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}
	else
	{
		*ppNoteRanges = NULL;
		*pdwNumNoteRanges = 0;
	}
	
	return hr;	
}


//////////////////////////////////////////////////////////////////////
// CBand::IsGS

bool CBand::IsGS(DMUS_IO_PATCH_ITEM& rPatchEvent)
{
	BYTE	bMSB = 0;
	BYTE	bPatch = 0;

	if( rPatchEvent.dwFlags & DMUS_IO_INST_BANKSELECT )
	{
		if( rPatchEvent.byLSB != 0 ) return FALSE; // LSB must be 0 for GS
		bMSB = rPatchEvent.byMSB;
	}
	if( rPatchEvent.dwFlags & DMUS_IO_INST_PATCH )
	{
		bPatch = rPatchEvent.byPChange & 0x7F;
	}

	if( bMSB == 0)
	{
		// If this is a drum kit (on MIDI channel 10)
		if( (rPatchEvent.byStatus  & 0xF) == 10 )
		{
			if ((bPatch == 0x0)  ||
				(bPatch == 0x08) ||
				(bPatch == 0x10) ||
				(bPatch == 0x18) ||
				(bPatch == 0x19) ||
				(bPatch == 0x20) ||
				(bPatch == 0x28) ||
				(bPatch == 0x30) || 
				(bPatch == 0x38) )
			{
				return  true;
			}
			else
				return false;
		}
		else return true;//is GM
	}
	// check for GS
	switch (bMSB)
	{
		case 6:
		case 7:
			if (bPatch == 0x7D) return true;
			break;
		case 24:
			if ((bPatch == 0x04) || (bPatch == 0x06)) return true;
			break;
		case 9:
			if ((bPatch == 0x0E) || (bPatch == 0x76) || (bPatch == 0x7D)) return true;
			break;
		case 2:
			if ( (bPatch == 0x66) || (bPatch == 0x78) || ((bPatch > 0x79)&&(bPatch < 0x80) )) return true;
			break;
		case 3:
			if ((bPatch > 0x79) && (bPatch < 0x80)) return true;
			break;
		case 4:
		case 5:
			if ( (bPatch == 0x7A) || ((bPatch > 0x7B)&&(bPatch < 0x7F) )) return true;
			break;
		case 32:
			if ((bPatch == 0x10) ||
				(bPatch == 0x11) ||
				(bPatch == 0x18) ||
				(bPatch == 0x34) ) return true;
			break;
		case 1:
			if ((bPatch == 0x26) ||
				(bPatch == 0x39) ||
				(bPatch == 0x3C) ||
				(bPatch == 0x50) ||
				(bPatch == 0x51) ||
				(bPatch == 0x62) ||
				(bPatch == 0x66) ||
				(bPatch == 0x68) ||
				((bPatch > 0x77) && (bPatch < 0x80))) return true;
				break;
		case 16:
			switch (bPatch)
			{
				case 0x00:
					return true;
					break;
				case 0x04:
					return true;
					break;
				case 0x05:
					return true;
					break;
				case 0x06:
					return true;
					break;
				case 0x10:
					return true;
					break;
				case 0x13:
					return true;
					break;
				case 0x18:
					return true;
					break;
				case 0x19:
					return true;
					break;
				case 0x1C:
					return true;
					break;
				case 0x27:
					return true;
					break;
				case 0x3E:
					return true;
					break;
				case 0x3F:
					return true;
					break;
				default:
					return false;
			}
			break;
		case 8:
			if ((bPatch < 0x07) || ((bPatch == 0x7D)))
			{
				return true;
			}
			else if ((bPatch > 0x3F) && (bPatch < 0x50))
			{
				return false;
			}
			else if ((bPatch > 0x4F) && (bPatch < 0x72)  )
			{
				if ((bPatch == 0x50) || 
					(bPatch == 0x51) ||
					(bPatch == 0x6B))
				{
					return true;
				}
				return false;
			}
			else if ((bPatch > 0x1F) && (bPatch < 0x40))
			{
				if ((bPatch > 0x25) && (bPatch < 0x29) ||
					(bPatch > 0x3C)  ||
					(bPatch == 0x30) || 
					(bPatch == 0x32) )
				{
					return true;
				}
				return false;
			}
			else if ((bPatch > 0x0A) && (bPatch < 0x12) && 
				     (bPatch != 0x0D) && (bPatch != 0x0F))
			{
				return true;
			}
			else if ((bPatch > 0x0F) && (bPatch < 0x20))
			{
				if (bPatch > 0x17)
				{
					return true;
				}
				else if ( (bPatch == 0x13) || (bPatch == 0x15) )
					return true;
				else
					return false;
			}
			break;
		default:
			return false;
	}
	return false;
}

HRESULT CBandInstrument::DownloadAddRecord(IDirectMusicPort *pPort)

{
	IDirectMusicInstrument* pInstrument = NULL;
	
	HRESULT hr = m_pIDMCollection->GetInstrument(m_dwPatch, &pInstrument);
	
    if (FAILED(hr) && (m_dwFlags & (DMUS_IO_INST_GM | DMUS_IO_INST_GS | DMUS_IO_INST_XG)))
    {
        // If drums, set to standard drums.
        if (m_dwPatch & 0x80000000)
        {
            m_dwPatch = 0;
        }
        // Else make this a GM melodic instrument.
        else
        {
            m_dwPatch &= 0x7F;
        }
        hr = m_pIDMCollection->GetInstrument(m_dwPatch, &pInstrument);
    }

	if(SUCCEEDED(hr) && m_dwFlags & DMUS_IO_INST_ASSIGN_PATCH)
	{
		hr = pInstrument->SetPatch(m_dwAssignPatch);
	}
	
	if(SUCCEEDED(hr))
	{
		CDownloadedInstrument* pDLInstrument = new CDownloadedInstrument;

		if(pDLInstrument)
		{
			pDLInstrument->m_pPort = pPort;
            pPort->AddRef();
			pDLInstrument->m_cRef = 1;

			DMUS_NOTERANGE *pNoteRanges = NULL;
			DWORD dwNumNoteRanges = 0;
			if(m_dwFlags & DMUS_IO_INST_NOTERANGES)
			{
				BuildNoteRangeArray(m_dwNoteRanges, &pNoteRanges, &dwNumNoteRanges);
			}
			hr = pPort->DownloadInstrument( pInstrument, 
                                            &pDLInstrument->m_pDLInstrument, 
                                            pNoteRanges, 
                                            dwNumNoteRanges );
            if (pNoteRanges)
            {
                delete [] pNoteRanges;
            }

			if(SUCCEEDED(hr))
			{
				m_DownloadList.AddHead(pDLInstrument);				
			}
			else
			{
				delete pDLInstrument;
#ifdef DBG
                if (hr == DMUS_E_NOT_INIT)
                {
				    Trace(0,"Error: Download failed because performance not initialized\n"); 
                }
                else
                {
//				    Trace(1,"Error: Unable to download instrument %lx to PChannel %ld\n",
//                        m_dwPatch,m_dwPChannel); 
                }
#endif
			}
		}
		else
		{
			hr = E_OUTOFMEMORY;
			Trace(0,"Error: Memory allocation failure - Unable to download instrument\n"); 
		}
	}
    else
    {
//        Trace(1,"Error: Unable to download instrument %lx; not in dls collection\n",m_dwPatch);
    }

    if (pInstrument)
    {
        pInstrument->Release();
    }
	
	return hr;
}

//////////////////////////////////////////////////////////////////////
// CBand::XGInHardware

bool CBand::XGInHardware(
			IDirectMusicPerformance *pPerformance,
            IDirectMusicSegmentState *pSegState,
			DWORD dwPChannel)
{
	DWORD dwGMFlags = 0;		
    // If this is playing via an audiopath, we need to access the audiopath to 
    // convert the pchannels so we can use them to access the right port.
    IDirectMusicSegmentState8 *pState8;
    if (SUCCEEDED(pSegState->QueryInterface(IID_IDirectMusicSegmentState8,(void **) &pState8)))
    {
        IDirectMusicAudioPath *pAudioPath;
        if (SUCCEEDED(pState8->GetObjectInPath(DMUS_PCHANNEL_ALL,DMUS_PATH_AUDIOPATH,0,
            GUID_All_Objects,0,IID_IDirectMusicAudioPath,(void **) &pAudioPath)))
        {
    		pAudioPath->ConvertPChannel(dwPChannel, &dwPChannel);
            pAudioPath->Release();
	    }
        pState8->Release();
    }
    // Now, use the PChannel and the performance to read the flags.
	IDirectMusicPort *pPort = NULL;
    IDirectMusicPerformanceP *pPerfp;
    if (SUCCEEDED(pPerformance->QueryInterface(IID_IDirectMusicPerformanceP, (void **)&pPerfp)))
    {
        if (SUCCEEDED(pPerfp->GetPortAndFlags(dwPChannel,&pPort,&dwGMFlags)))
        {
            pPort->Release();
        }
        pPerfp->Release();
    }
	return ((dwGMFlags & DM_PORTFLAGS_XG) && TRUE);
}


//////////////////////////////////////////////////////////////////////
// CBand::MakeGMOnly

HRESULT CBand::MakeGMOnly()
{
	EnterCriticalSection(&m_CriticalSection);

	CBandInstrument* pBandInstrument = m_BandInstrumentList.GetHead();

	for( ; pBandInstrument != NULL; pBandInstrument = pBandInstrument->GetNext())
	{
		pBandInstrument->m_fGMOnly = true;
		pBandInstrument->m_dwFullPatch = pBandInstrument->m_dwPatch;

		DWORD dwTemp = pBandInstrument->m_dwPatch;
		pBandInstrument->m_dwPatch = (dwTemp & 0x7F);

		// If a drum kit set drum kit flag
		if( m_dwMidiMode == DMUS_MIDIMODEF_XG )
		{
			if( (dwTemp & 0x00ff0000) == 0x007f0000 )
			{
				// XG drums. Keep this msb, as it is taken care of in the :Download function.
				pBandInstrument->m_dwPatch |= 0x007f0000;
			}
		}
		if(dwTemp & 0x80000000)
		{
			pBandInstrument->m_dwPatch |= 0x80000000;
		}
	}
	
	LeaveCriticalSection(&m_CriticalSection);

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CBand::ConnectToDLSCollection

HRESULT CBand::ConnectToDLSCollection(IDirectMusicCollection *pCollection)
{
	assert(pCollection);

	EnterCriticalSection(&m_CriticalSection);

	CBandInstrument* pBandInstrument = m_BandInstrumentList.GetHead();

	for( ; pBandInstrument != NULL; pBandInstrument = pBandInstrument->GetNext())
	{
		if(pBandInstrument->m_pIDMCollection == NULL)
		{
			pCollection->AddRef();
			pBandInstrument->m_pIDMCollection = pCollection;
		}
		else
		{
			if( m_dwMidiMode ) // if this is anything, it indicates we were loaded from a midi file
			{
				// if we're not an XG file, make sure channel 9 is drums
				if( (m_dwMidiMode != DMUS_MIDIMODEF_XG) &&
					(pBandInstrument->m_dwPChannel == 9) )
				{
					pBandInstrument->m_dwPatch |= 0x80000000;
				}
			}
			// if we get an instrument from this collection, set the band's collection
			// pointer to it instead.
			IDirectMusicInstrument* pInstrument = NULL;
			
			if( SUCCEEDED( pCollection->GetInstrument(pBandInstrument->m_dwPatch, &pInstrument)))
			{
				pBandInstrument->m_pIDMCollection->Release();
				pBandInstrument->m_pIDMCollection = pCollection;
				pCollection->AddRef();
				pInstrument->Release();
			}
		}
	}

	LeaveCriticalSection(&m_CriticalSection);	
	
	return S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmband\sources.inc ===
!include ..\..\sources.inc

TARGETNAME = dmband$(LIBEXT)
TARGETTYPE = LIBRARY
TARGETPATH = ..\..\obj

USE_MAPSYM = 1
NTDBGFILES = 1

!if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
C_DEFINES = $(C_DEFINES) -DDEBUG=1
!endif

C_DEFINES = $(C_DEFINES) -DXBOX -DUNICODE

INCLUDES = $(INCLUDES);\
    $(PRIVATE_INC_PATH);\
           ..\..\shared; \
           ..\..\xprivate; \
           ..

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\pchdmband.h
PRECOMPILED_PCH=pchdmband.pch
PRECOMPILED_OBJ=pchdmband.obj

SOURCES = bandinst.cpp\
          bandtrk.cpp\
          dmband.cpp\
          dmbdll.cpp\
          pchmap.cpp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmband\pchdmband.h ===
#ifdef XBOX
#include <xtl.h>
#include "..\shared\critsec.h"
#include "..\shared\xcreate.h"
#include "PChMap.h"
#include "dmksctrl.h"
#include "dmusicc.h"
#include "dmusicip.h"
#include "dmusicf.h"
#include "..\shared\dmstrm.h"
#include "..\shared\validate.h"
#include "dmbandp.h"
#include "bandtrk.h"
#include "debug.h"
#include "..\shared\xsoundp.h" // For GUID_All_Objects
#else
#include <objbase.h>
#include "..\shared\critsec.h"
#include "PChMap.h"
#include "dmksctrl.h"
#include "dmusicc.h"
#include "dmusici.h"
#include "dmusicf.h"
#include "..\shared\dmstrm.h"
#include "..\shared\validate.h"
#include "dmbandp.h"
#include "bandtrk.h"
#include "debug.h"
#include "..\shared\oledll.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmband\dmbdll.cpp ===
//
// dmbdll.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Note: Dll entry points as well IDirectMusicBandFactory & 
// IDirectMusicBandTrkFactory implementations.
// Originally written by Robert K. Amenn with significant parts
// stolen from code written by Jim Geist
//

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)
#include "pchdmband.h"

//////////////////////////////////////////////////////////////////////
// Globals

#ifndef XBOX
// Registry Info (band)
TCHAR g_szBandFriendlyName[]    = TEXT("DirectMusicBand");
TCHAR g_szBandVerIndProgID[]    = TEXT("Microsoft.DirectMusicBand");
TCHAR g_szBandProgID[]          = TEXT("Microsoft.DirectMusicBand.1");

// Registry Info (band track)
TCHAR g_szBandTrackFriendlyName[]    = TEXT("DirectMusicBandTrack");
TCHAR g_szBandTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicBandTrack");
TCHAR g_szBandTrackProgID[]          = TEXT("Microsoft.DirectMusicBandTrack.1");

// Dll's hModule
HMODULE g_hModule = NULL;

// Count of active components and class factory server locks
long g_cComponent = 0;
long g_cLock = 0;
#endif // XBOX

//////////////////////////////////////////////////////////////////////
// Standard calls needed to be an inproc server

//////////////////////////////////////////////////////////////////////
// DllCanUnloadNow

#ifndef XBOX
STDAPI DllCanUnloadNow()
{
    if(g_cComponent || g_cLock) 
	{
		return S_FALSE;
    }

    return S_OK;
}
#endif // XBOX

//////////////////////////////////////////////////////////////////////
// DllGetClassObject

#ifndef XBOX
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
	IUnknown* pIUnknown = NULL;
    DWORD dwTypeID = 0;
    if(clsid == CLSID_DirectMusicBand)
    {
        dwTypeID = CLASS_BAND;
    }
    else if(clsid == CLSID_DirectMusicBandTrack) 
    {
        dwTypeID = CLASS_BANDTRACK;
    }
    else
    {
		return CLASS_E_CLASSNOTAVAILABLE;
	}
    pIUnknown = static_cast<IUnknown*> (new CClassFactory(dwTypeID));
    if(pIUnknown) 
    {
        HRESULT hr = pIUnknown->QueryInterface(iid, ppv);
        pIUnknown->Release();
        return hr;
    }
	return E_OUTOFMEMORY;
}
#endif // XBOX


//////////////////////////////////////////////////////////////////////
// DllUnregisterServer

#ifndef XBOX
STDAPI DllUnregisterServer()
{
	HRESULT hr = UnregisterServer(CLSID_DirectMusicBand,
								  g_szBandFriendlyName,
								  g_szBandVerIndProgID,
								  g_szBandProgID);

	if(SUCCEEDED(hr))
	{
		hr = UnregisterServer(CLSID_DirectMusicBandTrack,
							  g_szBandTrackFriendlyName,
							  g_szBandTrackVerIndProgID,
							  g_szBandTrackProgID);  
	}

	return hr;

}
#endif // XBOX

//////////////////////////////////////////////////////////////////////
// DllRegisterServer

#ifndef XBOX
STDAPI DllRegisterServer()
{
	HRESULT hr = RegisterServer(g_hModule,
								CLSID_DirectMusicBand,
								g_szBandFriendlyName,
								g_szBandVerIndProgID,
								g_szBandProgID);
	if(SUCCEEDED(hr))
	{
		hr = RegisterServer(g_hModule,
							CLSID_DirectMusicBandTrack,
							g_szBandTrackFriendlyName,
							g_szBandTrackVerIndProgID,
							g_szBandTrackProgID);
	}

	return hr;
}

//////////////////////////////////////////////////////////////////////
// Standard Win32 DllMain

//////////////////////////////////////////////////////////////////////
// DllMain

#ifdef DBG
static char* aszReasons[] =
{
    "DLL_PROCESS_DETACH",
    "DLL_PROCESS_ATTACH",
    "DLL_THREAD_ATTACH",
    "DLL_THREAD_DETACH"
};
const DWORD nReasons = (sizeof(aszReasons) / sizeof(char*));
#endif

BOOL APIENTRY DllMain(HINSTANCE hModule,
				      DWORD dwReason,
				      void *lpReserved)
{
	static int nReferenceCount = 0;

#ifdef DBG
    if(dwReason < nReasons)
    {
		Trace(DM_DEBUG_STATUS, "DllMain: %s\n", (LPSTR)aszReasons[dwReason]);
    }
    else
    {
		Trace(DM_DEBUG_STATUS, "DllMain: Unknown dwReason <%u>\n", dwReason);
    }
#endif

    switch(dwReason)
    {
		case DLL_PROCESS_ATTACH:
		    if(++nReferenceCount == 1)
			{

			#ifdef DBG
				DebugInit();
			#endif


				if(!DisableThreadLibraryCalls(hModule))
				{
					Trace(DM_DEBUG_STATUS, "DisableThreadLibraryCalls failed.\n");
				}

				g_hModule = hModule;
			}
			break;

#ifdef DBG
		case DLL_PROCESS_DETACH:
		    if(--nReferenceCount == 0)
			{
				TraceI(-1, "Unloading g_cLock %d  g_cComponent %d\n", g_cLock, g_cComponent);
                // Assert if we still have some objects hanging around
                assert(g_cComponent == 0);
                assert(g_cLock == 0);
			}
			break;
#endif
    }
	
    return TRUE;
}
#endif // XBOX

// CClassFactory::QueryInterface
//
#ifndef XBOX
HRESULT __stdcall
CClassFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

CClassFactory::CClassFactory(DWORD dwClassType)

{
	m_cRef = 1;
    m_dwClassType = dwClassType;
	InterlockedIncrement(&g_cLock);
}

CClassFactory::~CClassFactory()

{
	InterlockedDecrement(&g_cLock);
}

// CClassFactory::AddRef
//
ULONG __stdcall
CClassFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

// CClassFactory::Release
//
ULONG __stdcall
CClassFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

// CClassFactory::CreateInstance
//
//
HRESULT __stdcall
CClassFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

    if (pUnknownOuter) 
    {
         return CLASS_E_NOAGGREGATION;
    }
    if(ppv == NULL)
	{
		return E_POINTER;
	}

    switch (m_dwClassType)
    {
    case CLASS_BAND:
        {
            CBand *pDMB;
    
            try
            {
                pDMB = new CBand;
            }
            catch( ... )
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            if(pDMB == NULL) 
	        {
		        hr = E_OUTOFMEMORY;
                break;
            }

            hr = pDMB->QueryInterface(iid, ppv);
            pDMB->Release();
        }
        break;
    case CLASS_BANDTRACK:
        {
            CBandTrk *pDMBT;

            try 
            {
                pDMBT = new CBandTrk;
            } 
            catch( ... )
            {
                hr = E_OUTOFMEMORY;
                break;
            }
    
	        if(pDMBT == NULL) 
	        {
		        hr = E_OUTOFMEMORY;
                break;
            }

            hr = pDMBT->QueryInterface(iid, ppv);
    
            pDMBT->Release();
        }
        break;
    }
    return hr;
}

// CClassFactory::LockServer
//
HRESULT __stdcall
CClassFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}
#endif // XBOX

#ifdef XBOX

STDAPI DirectMusicBandCreate(REFIID iid, void ** ppBand)
{
    CBand *pDMB;
    HRESULT hr;

    if(!(pDMB = new CBand))
	{
		return E_OUTOFMEMORY;
    }

    hr = pDMB->QueryInterface(iid, (LPVOID *)ppBand);

    pDMB->Release();

    return hr;
}

STDAPI DirectMusicBandTrackCreate(REFIID iid, void ** ppDMT )
{
    CBandTrk *pDMBT;
    HRESULT hr;

    if(!(pDMBT = new CBandTrk))
	{
		return E_OUTOFMEMORY;
    }

    hr = pDMBT->QueryInterface(iid, (LPVOID *)ppDMT);

    pDMBT->Release(); // Since this is initialized to 1 by constructor.

    return hr;
}

#endif // XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmcompos\dmpers.h ===
// DMPers.h : Declaration of the CDMPers
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// @doc EXTERNAL
//

#ifndef __DMPERS_H_
#define __DMPERS_H_

#include "dmusicip.h"
#include "DMCompos.h"

const short MAX_PALETTE = 24;

struct DMPersonalityStruct
{
	void ResolveConnections( LPPERSONALITY personality, short nCount );
	bool					m_fLoaded;			// is the personality loaded in memory?
	GUID					m_guid;
	//DWORD					m_dwVersionMS;
	//DWORD					m_dwVersionLS;
	String					m_strName;			// Name of the personality
	//String					m_strCategory;			// Category of the personality
	DWORD					m_dwScalePattern;	// Scale for the personality
	DWORD					m_dwChordMapFlags;			// Flags (?)
	TList<DMChordData>		m_aChordPalette[MAX_PALETTE];	// chord palette
	TList<DMChordEntry>		m_ChordMap;			// Chord map DAG (adjacency list)
	TList<DMSignPost>		m_SignPostList;		// List of sign posts
};

/*
@interface IDirectMusicPersonality | 
The <i IDirectMusicPersonality> interface provides methods for manipulating personalities.
Personalities provide the Composer (<i IDirectMusicComposer>) with the information it 
needs to compose chord progressions, which it uses to build section segments and automatic 
transitions, as wells as to change the chords in an existing segment as it plays.

It also supports the <i IPersistStream> and <i IDirectMusicObject> interfaces for loading 
its data.

@base public | IUnknown

@meth HRESULT | GetScale | Returns the scale of the personality.

*/

/////////////////////////////////////////////////////////////////////////////
// CDMPers
class CDMPers : 
	public IDMPers,
	public IDirectMusicChordMap,
	public IDirectMusicObject,
	public IPersistStream
{
public:
	CDMPers();
	~CDMPers();

    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

// IDMPers
public:
	void CleanUp();
	HRESULT LoadPersonality( LPSTREAM pStream, DWORD dwSize );
	HRESULT DM_ParseDescriptor( IAARIFFStream* pIRiffStream, MMCKINFO* pckMain, LPDMUS_OBJECTDESC pDesc  );
	HRESULT DM_LoadPersonality( IAARIFFStream* pIRiffStream, MMCKINFO* pckMain );
	HRESULT DM_LoadSignPost( IAARIFFStream* pIRiffStream, MMCKINFO* pckParent, DMExtendedChord** apChordDB );
	HRESULT DM_LoadChordEntry( 
		IAARIFFStream* pIRiffStream, MMCKINFO* pckParent, DMExtendedChord** apChordDB, short& nMax );
	HRESULT STDMETHODCALLTYPE GetPersonalityStruct(void** ppPersonality);

// IDirectMusicPersonality
public:
HRESULT STDMETHODCALLTYPE GetScale(DWORD* pdwScale);

//HRESULT STDMETHODCALLTYPE GetName(BSTR* pdwName);

// IDirectMusicObject methods
	HRESULT STDMETHODCALLTYPE GetDescriptor(LPDMUS_OBJECTDESC pDesc) ;
	HRESULT STDMETHODCALLTYPE SetDescriptor(LPDMUS_OBJECTDESC pDesc) ;
	HRESULT STDMETHODCALLTYPE ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc) ;

// IPersist
public:
    STDMETHOD(GetClassID)(THIS_ LPCLSID pclsid);

// IPersistStream
public:
    // Determines if the Style has been modified by simply checking the Style's m_fDirty flag.  This flag is cleared
    // when a Style is saved or has just been created.
    STDMETHOD(IsDirty)(THIS);
    // Loads a Style from a stream.
    STDMETHOD(Load)(THIS_ LPSTREAM pStream);
    // Saves a Style to a stream in RIFF format.
    STDMETHOD(Save)(THIS_ LPSTREAM pStream, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(THIS_ ULARGE_INTEGER FAR* pcbSize);

protected: // attributes
    long m_cRef;
    CMemTrack               m_MemTrack;             // For debug memory tracking.
	BOOL					m_fDirty;				// has the style been modified?
    CRITICAL_SECTION		m_CriticalSection;		// for i/o
    BOOL                    m_fCSInitialized;
	DMPersonalityStruct		m_PersonalityInfo;		// The details of the personality
};

#endif //__DMPERS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmcompos\dmcomp2.cpp ===
// Dx8Comp.cpp : Further Implementation of CDMCompos
//
// Copyright (c) 1999-1999 Microsoft Corporation
//
// @doc EXTERNAL
//
// 
//

#include "pchcompos.h"

V_INAME(DMCompose)

void CDMCompos::ChordConnections2(TList<DMChordEntry>& ChordMap, 
							 CompositionCommand& rCommand,
							 SearchInfo *pSearch,
							 short nBPM,
							 DMChordData *pCadence1,
							 DMChordData *pCadence2)

{
    int mint, maxt, top, bottom, total;
    short oldbeats = pSearch->m_nBeats;
    //, error;
    TListItem<PlayChord> *pChord;
    SearchInfo tempSearch;
    // Compose a chord list.
    pSearch->m_nMinBeats = 0;
    pSearch->m_nMaxBeats = 0;
    pSearch->m_nChords = 0;
    pSearch->m_Fail.m_nTooManybeats = 0;
    pSearch->m_Fail.m_nTooFewbeats = 0;
    pSearch->m_Fail.m_nTooManychords = 0;
    pSearch->m_Fail.m_nTooFewchords = 0;
    if (pCadence1 || pCadence2)
    {
        pSearch->m_nMinBeats++;
        pSearch->m_nMaxBeats = nBPM;
        pSearch->m_nChords++;
		if (pCadence1 && pCadence2)
		{
			pSearch->m_nMinBeats++;
			pSearch->m_nChords++;
		}
    }
    tempSearch = *pSearch;
    rCommand.m_PlayList.RemoveAll();
    Compose(ChordMap, pSearch, rCommand);
    pChord = rCommand.m_PlayList.GetHead();
	/////////
    *pSearch = tempSearch;
    pSearch->m_nBeats = oldbeats;
    // Tally the min and max beats.
    mint = 0;
    maxt = 0;
    for (; pChord; pChord = pChord->GetNext())
    {
        mint += pChord->GetItemValue().m_nMinbeats;
        maxt += pChord->GetItemValue().m_nMaxbeats;
    }
    pChord = rCommand.m_PlayList.GetHead();
    // If no chord connection was found, create one.
    if (!pChord)
    {
        int nextDuration = oldbeats;
        pChord = AddCadence(rCommand.m_PlayList, &pSearch->m_Start, 0);
        if (pChord)
        {
            pChord->GetItemValue().m_nMinbeats = 0;
        }
        if (pCadence1)
        {
            AddCadence(rCommand.m_PlayList, pCadence1, nextDuration);
            mint++;
            maxt += nextDuration;
            nextDuration = nBPM + 1;
        }
        if (pCadence2)
        {
            AddCadence(rCommand.m_PlayList, pCadence2, nextDuration);
            mint++;
            maxt += nextDuration;
            nextDuration = nBPM + 1;
        }
        AddCadence(rCommand.m_PlayList, &pSearch->m_Start, nextDuration);
        mint++;
        maxt += nextDuration;
    }
    else
    {
        int chordCount = (int) rCommand.m_PlayList.GetCount();
        int avMax;
        if (chordCount > 1) chordCount--;
        avMax = maxt / chordCount;
        if (avMax < 1) avMax = 1;
        if (pCadence1)
        {
            if (pCadence2)
            {
                AddCadence(rCommand.m_PlayList, pCadence2, avMax);
                maxt += avMax;
                mint++;
            }
            AddCadence(rCommand.m_PlayList, &pSearch->m_End, avMax);
            maxt += avMax;
            mint++;
        }
        else if (pCadence2)
        {
            AddCadence(rCommand.m_PlayList, &pSearch->m_End, avMax);
            maxt += avMax;
            mint++;
        }
    }
    // Prepare a ratio to apply to each connection.
    top = pSearch->m_nBeats - mint;
    bottom = maxt - mint;
    if (bottom <= 0) bottom = 1;
    // Assign each connection a time based on the ratio.
    total = 0;
    pChord = rCommand.m_PlayList.GetHead();
    for (; pChord; pChord = pChord->GetNext())
    {
		PlayChord& rChord = pChord->GetItemValue();
        int beat = rChord.m_nMaxbeats - rChord.m_nMinbeats;
        beat *= top;
        beat += (bottom >> 1);
        beat /= bottom;
        if (beat < rChord.m_nMinbeats) beat = rChord.m_nMinbeats;
        if (beat > rChord.m_nMaxbeats) beat = rChord.m_nMaxbeats;
        total += beat;
        rChord.m_nBeat = (short)total;
    }
    // We should now have a close approximation of the correct time.
    // Stretch or shrink the range to fit exactly.  Err on the side
    // of too long, since jostleback will scrunch them back in place.
	// But DON'T violate min/max for each chord.
    pChord = rCommand.m_PlayList.GetHead();
	int lastbeat = 0;
    for (; pChord; pChord = pChord->GetNext())
    {
		PlayChord& rChord = pChord->GetItemValue();
        int newbeat = (rChord.m_nBeat * pSearch->m_nBeats) + total - 1;
        newbeat /= total;
        if ((newbeat - lastbeat) < rChord.m_nMinbeats) newbeat = lastbeat + rChord.m_nMinbeats;
        if ((newbeat - lastbeat) > rChord.m_nMaxbeats) newbeat = lastbeat + rChord.m_nMaxbeats;
        rChord.m_nBeat = (short)newbeat;
		lastbeat = newbeat;
        if (!pChord->GetNext()) total = rChord.m_nBeat;
    }
    // Now we should have times close to the real thing.
    pChord = rCommand.m_PlayList.GetItem(rCommand.m_PlayList.GetCount() - 1);
    if (pChord)
    {
        JostleBack(rCommand.m_PlayList, pChord, pSearch->m_nBeats - total);
    }
    // Now, add the starting time offset to each chord.
    // And, remove the straggler last chord.
    AlignChords(rCommand.m_PlayList.GetHead(), 0, nBPM);
    pChord = rCommand.m_PlayList.GetHead();
    for (; pChord; )
    {
        pChord->GetItemValue().m_nMeasure = 
			(short)( ( pChord->GetItemValue().m_nBeat / nBPM ) + rCommand.m_nMeasure );
        pChord->GetItemValue().m_nBeat %= nBPM;
        if (pChord->GetNext())
        {
            pChord = pChord->GetNext();
        }
        else
        {
            rCommand.m_PlayList.Remove(pChord);
            delete pChord;
            break;
        }
    }
}

void CDMCompos::ComposePlayList2(TList<PlayChord>& PlayList, 
							IDirectMusicStyle* pStyle,	
							IDirectMusicChordMap* pPersonality,
							TList<TemplateCommand>& rCommandList)
{
	// Extract the style's time signature.
	DMUS_TIMESIGNATURE TimeSig;
	pStyle->GetTimeSignature(&TimeSig);
	short nBPM = TimeSig.bBeatsPerMeasure;
	IDMPers* pDMP;
	pPersonality->QueryInterface(IID_IDMPers, (void**)&pDMP);
	DMPersonalityStruct* pPers;
	pDMP->GetPersonalityStruct((void**)&pPers);
	TList<DMChordEntry> &ChordMap = pPers->m_ChordMap;
	TList<DMSignPost> &SignPostList = pPers->m_SignPostList;
    TListItem<DMSignPost> *pSign = SignPostList.GetHead();
    for (; pSign; pSign = pSign->GetNext())
    {
        pSign->GetItemValue().m_dwTempFlags = 0;
    }
    // Assign specific root sign posts, then letter based sign posts.
	TList<CompositionCommand> CommandList;
	TListItem<TemplateCommand>* pTC = rCommandList.GetHead();
	for(; pTC; pTC = pTC->GetNext())
	{
		TemplateCommand& rTC = pTC->GetItemValue();
		TListItem<CompositionCommand>* pNew = new TListItem<CompositionCommand>;
		if (pNew)
		{
			CompositionCommand& rNew = pNew->GetItemValue();
			rNew.m_nMeasure = rTC.m_nMeasure;
			rNew.m_Command = rTC.m_Command;
			rNew.m_dwChord = rTC.m_dwChord;
			rNew.m_pSignPost = NULL;
			rNew.m_pFirstChord = NULL;
			CommandList.AddTail(pNew);
		}
	}
    ChooseSignPosts(SignPostList.GetHead(), CommandList.GetHead(),DMUS_SIGNPOSTF_ROOT, false);
    ChooseSignPosts(SignPostList.GetHead(), CommandList.GetHead(),DMUS_SIGNPOSTF_LETTER, false);
    ChooseSignPosts(SignPostList.GetHead(), CommandList.GetHead(),DMUS_SIGNPOSTF_ROOT, true);
    ChooseSignPosts(SignPostList.GetHead(), CommandList.GetHead(),DMUS_SIGNPOSTF_LETTER, true);
   // Now, we should have a chord assigned for each node in the template.
	TListItem<CompositionCommand>* pCommand = CommandList.GetHead();
    for (; pCommand; pCommand = pCommand->GetNext())
    {
		CompositionCommand& rCommand = pCommand->GetItemValue();
		if (rCommand.m_dwChord == 0) continue;   // Only command, no chord.
		if (rCommand.m_pSignPost)
        {
            TListItem<CompositionCommand>* pNext = GetNextChord(pCommand);
            if (pNext)
            {
				CompositionCommand& rNext = pNext->GetItemValue();
                SearchInfo *pSearch = &rCommand.m_SearchInfo;
                DMChordData *pCadence1 = NULL;
                DMChordData *pCadence2 = NULL;
                pSearch->m_Start = rCommand.m_pSignPost->GetItemValue().m_ChordData;
                if (rNext.m_dwChord & DMUS_SIGNPOSTF_CADENCE)
                {
                    TListItem<DMSignPost> *pSign = rNext.m_pSignPost;
					DMSignPost& rSign = pSign->GetItemValue();
                    if (rSign.m_dwFlags & DMUS_SPOSTCADENCEF_1)
                    {
                        pSearch->m_End = rSign.m_aCadence[0];
                        pCadence1 = &rSign.m_aCadence[0];
                        if (rSign.m_dwFlags & DMUS_SPOSTCADENCEF_2)
                        {
                            pCadence2 = &rSign.m_aCadence[1];
                        }
                    }
                    else if (rSign.m_dwFlags & DMUS_SPOSTCADENCEF_2)
                    {
                        pSearch->m_End = rSign.m_aCadence[1];
                        pCadence2 = &rSign.m_aCadence[1];
                    }
                    else
                    {
                        pSearch->m_End = rSign.m_ChordData;
                    }
                }
                else
                {
                    pSearch->m_End = rNext.m_pSignPost->GetItemValue().m_ChordData;
                }
                //**********pSearch->m_nActivity = (short) wActivity;
                pSearch->m_nBeats = (short)( (rNext.m_nMeasure - rCommand.m_nMeasure) * nBPM );
                pSearch->m_nMaxChords = (short)( pSearch->m_nBeats  );
                pSearch->m_nMinChords = 0;  // should be 1?
                FindEarlierSignpost(CommandList.GetHead(), pCommand, pSearch);
				// rCommand holds the playlist and the measure used by ChordConnections
				// (it should be passed by reference since the playlist changes)
                ChordConnections2(ChordMap, rCommand, pSearch, nBPM, pCadence1, pCadence2);
			}
            else
            {
                AddChord(rCommand.m_PlayList, &rCommand.m_pSignPost->GetItemValue().m_ChordData,
					rCommand.m_nMeasure,0);
            }
        }
    }
    // Take all the Chord references and fold 'em into one list.
	pCommand = CommandList.GetHead();
    for (; pCommand; pCommand = pCommand->GetNext())
    {
        PlayList.Cat(pCommand->GetItemValue().m_PlayList.GetHead());
        pCommand->GetItemValue().m_PlayList.RemoveAll();
    }
    CleanUpBreaks(PlayList, CommandList.GetHead());
	pDMP->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmcompos\composin.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       composin.h
//
//--------------------------------------------------------------------------

// ComposIn.h --- include file for the composition engine

#ifndef __COMPOSINH__
#define __COMPOSINH__

#include "dmusicip.h"
#include "dmusicf.h"
#include "str.h"
#include "tlist.h"

#include "aariff.h"
#include "templats.h"

#include "sjpers.h"

#include "debug.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmcompos\dmcompos.cpp ===
// DMCompos.cpp : Implementation of CDMCompos
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// @doc EXTERNAL
//
// 
//

#include "pchcompos.h"

#ifdef XBOX
#define CreateStreamOnHGlobal DMusic_CreateStreamOnHGlobal
STDAPI DMusic_CreateStreamOnHGlobal(HANDLE hGlobal, BOOL fDeleteOnRelease,
        LPSTREAM FAR* ppstm);
#endif

// default scale is C Major
const DWORD DEFAULT_SCALE_PATTERN = 0xab5ab5;
// default chord is major 7
const DWORD DEFAULT_CHORD_PATTERN = 0x891;

BOOL Less(TemplateCommand& TC1, TemplateCommand& TC2)
{ return TC1.m_nMeasure < TC2.m_nMeasure; }

BOOL Less(PlayChord& PC1, PlayChord& PC2)
{ return PC1.m_nMeasure < PC2.m_nMeasure ||
         (PC1.m_nMeasure == PC2.m_nMeasure && PC1.m_nBeat < PC2.m_nBeat); 
}

static void Free(TListItem<DMExtendedChord*>*& pSubChord)
{
    TListItem<DMExtendedChord*> *pScan = pSubChord;
    for (; pScan; pScan = pScan->GetNext())
    {
        pScan->GetItemValue()->Release();
        pScan->GetItemValue() = NULL;
    }
    TListItem<DMExtendedChord*>::Delete(pSubChord);
    pSubChord = NULL;
}

TListItem<DMExtendedChord*>* Copy(TListItem<DMExtendedChord*>* pChord)
{
    if (!pChord) return NULL;
    TListItem<DMExtendedChord*>* pNext = new TListItem<DMExtendedChord*>;
    if (pNext)
    {
        DMExtendedChord* pNew = new DMExtendedChord;
        if (pNew)
        {
            DMExtendedChord*& rChord = pChord->GetItemValue();
            DMExtendedChord*& rNext = pNext->GetItemValue();
            rNext = pNew;
            rNext->m_dwChordPattern = rChord->m_dwChordPattern; 
            rNext->m_dwScalePattern = rChord->m_dwScalePattern;
            rNext->m_dwInvertPattern = rChord->m_dwInvertPattern;
            rNext->m_bRoot = rChord->m_bRoot;
            rNext->m_bScaleRoot = rChord->m_bScaleRoot;
            rNext->m_wCFlags = rChord->m_wCFlags;
            rNext->m_dwParts = rChord->m_dwParts;
            rNext->m_nRefCount = 1;
            pNext->SetNext(Copy(pChord->GetNext()));
        }
        else
        {
            delete pNext;
            pNext = NULL;
        }
    }
    return pNext;
}

DMChordData::DMChordData(DMChordData& rChordData)
{
    m_strName = rChordData.m_strName;
    m_pSubChords = Copy(rChordData.m_pSubChords);
}

DMChordData::DMChordData(DMUS_CHORD_PARAM& DMC)
{
    m_strName = DMC.wszName;
    m_pSubChords = NULL;
    for (BYTE n = 0; n < DMC.bSubChordCount; n++)
    {
        TListItem<DMExtendedChord*>* pSub = new TListItem<DMExtendedChord*>;
        if( pSub )
        {
            DMExtendedChord* pNew = new DMExtendedChord;
            if (pNew)
            {
                memset( pNew, 0, sizeof( *pNew) );
                DMExtendedChord*& rSubChord = pSub->GetItemValue();
                rSubChord = pNew;
                rSubChord->AddRef();
                rSubChord->m_dwChordPattern = DMC.SubChordList[n].dwChordPattern;
                rSubChord->m_dwScalePattern = DMC.SubChordList[n].dwScalePattern;
                rSubChord->m_dwInvertPattern = DMC.SubChordList[n].dwInversionPoints;
                rSubChord->m_dwParts = DMC.SubChordList[n].dwLevels;
                rSubChord->m_bRoot = DMC.SubChordList[n].bChordRoot;    
                rSubChord->m_bScaleRoot = DMC.SubChordList[n].bScaleRoot;
                m_pSubChords = m_pSubChords->Cat(pSub);
            }
            else
            {
                delete pSub;
                // no need continuing in the loop if we ran out of memory
                break;
            }
        }
    }
}

// At the moment, this assumes that the pattern of the chord is the pattern of the
// first subchord in the chord's subchord list.
DWORD DMChordData::GetChordPattern()
{
    if (m_pSubChords)
    {
        return m_pSubChords->GetItemValue()->m_dwChordPattern;
    }
    else return 0;
}

// At the moment, this assumes that the root of the chord is the root of the
// first subchord in the chord's subchord list.
char DMChordData::GetRoot()
{
    if (m_pSubChords)
    {
        return m_pSubChords->GetItemValue()->m_bRoot;
    }
    else return 0;
}

// At the moment, this assumes that the root of the chord is the root of the
// first subchord in the chord's subchord list.
void DMChordData::SetRoot(char chNewRoot)
{
    if (m_pSubChords)
    {
        m_pSubChords->GetItemValue()->m_bRoot = chNewRoot;
    }
}


void DMChordData::Release()
{
    Free(m_pSubChords);
}

// Two chords are equal if they have the same number of subchords and each 
// corresponding subchord is equal
BOOL DMChordData::Equals(DMChordData& rhsChord)
{
    TListItem<DMExtendedChord*> *pLeft = m_pSubChords;
    TListItem<DMExtendedChord*> *pRight = rhsChord.m_pSubChords;
    for(; pLeft; pLeft = pLeft->GetNext(), pRight = pRight->GetNext())
    {
        if (pRight == NULL || !pLeft->GetItemValue()->Equals(*pRight->GetItemValue())) 
            return FALSE;
    }
    return pRight == NULL;
}


BOOL DMExtendedChord::Equals(DMExtendedChord& rhsChord)
{
    char a = m_bRoot;
    char b = rhsChord.m_bRoot;
    while (a > 11) a -= 12;
    while (b > 11) b -= 12;
    return ((m_dwChordPattern == rhsChord.m_dwChordPattern) && (a == b));
}

BOOL DMChordLink::Walk(SearchInfo *pSearch)
{
    BOOL fResult = FALSE;
    if (m_pChord)
    {
        pSearch->m_nMinBeats = (short)( pSearch->m_nMinBeats + m_wMinBeats );
        pSearch->m_nMaxBeats = (short)( pSearch->m_nMaxBeats + m_wMaxBeats );
        pSearch->m_nChords++;
        fResult = m_pChord->GetItemValue().Walk(pSearch);
        pSearch->m_nChords--;
        pSearch->m_nMinBeats = (short)( pSearch->m_nMinBeats - m_wMinBeats );
        pSearch->m_nMaxBeats = (short)( pSearch->m_nMaxBeats - m_wMaxBeats );
    }
    return(fResult);
}

TListItem<DMChordLink> *DMChordEntry::ChooseNextChord()

{
    int total = 0;
    int choice;
    TListItem<DMChordLink> *pNext = m_Links.GetHead();
    for (; pNext; pNext = pNext->GetNext())
    {
        if (!(pNext->GetItemValue().m_dwFlags & NC_NOPATH))
        {
            if (pNext->GetItemValue().m_pChord) total += pNext->GetItemValue().m_wWeight;
        }
    }
    if (!total) return(NULL);
    choice = dm_rand() % total;
    pNext = m_Links.GetHead();
    for (; pNext; pNext = pNext->GetNext())
    {
        if (!(pNext->GetItemValue().m_dwFlags & NC_NOPATH))
        {
            if (pNext->GetItemValue().m_pChord) choice -= pNext->GetItemValue().m_wWeight;
            if (choice < 0) return(pNext);
        }
    }
    return(NULL);
}

BOOL DMChordEntry::Walk(SearchInfo *pSearch)
{
    TListItem<DMChordLink> *pNext = m_Links.GetHead();
    if (pSearch->m_nChords > pSearch->m_nMaxChords)
    {
        pSearch->m_Fail.m_nTooManychords++;
        return (FALSE);
    }
    for (; pNext; pNext = pNext->GetNext())
    {
        pNext->GetItemValue().m_dwFlags &= ~(NC_PATH | NC_NOPATH);
    }
    if ((m_dwFlags & CE_END) && (m_ChordData.Equals(pSearch->m_End)))
    {
        if (pSearch->m_nChords >= pSearch->m_nMinChords)
        {
            if (pSearch->m_nBeats <= pSearch->m_nMaxBeats)
            {
                if (pSearch->m_nBeats >= pSearch->m_nMinBeats)
                {
                    m_dwFlags |= CE_PATH;
                    return(TRUE);
                }
                else pSearch->m_Fail.m_nTooManybeats++;
            }
            else pSearch->m_Fail.m_nTooFewbeats++;
        }
        else
        {
            pSearch->m_Fail.m_nTooFewchords++;
        }
    }
    m_dwFlags &= ~CE_PATH;
    if (pSearch->m_pPlayChord)
    {
        pSearch->m_pPlayChord = pSearch->m_pPlayChord->GetNext();
    }
    if (pSearch->m_pPlayChord)
    {
        TListItem<PlayChord> *pPlay = pSearch->m_pPlayChord;
        if (pPlay->GetItemValue().m_pChord)
        {
            TListItem<DMChordLink>* pNext = pPlay->GetItemValue().m_pNext;
            if (pNext)
            {
                if (pNext->GetItemValue().Walk(pSearch))
                {
                    pNext->GetItemValue().m_dwFlags |= NC_PATH;
                    m_dwFlags |= CE_PATH;
                    return(TRUE);
                }
                else
                {
                    pNext->GetItemValue().m_dwFlags |= NC_NOPATH;
                    pSearch->m_pPlayChord = NULL;
                }
            }
        }
    }
    while( ( pNext = ChooseNextChord() ) != NULL )
    {
        if (pNext->GetItemValue().Walk(pSearch))
        {
            pNext->GetItemValue().m_dwFlags |= NC_PATH;
            m_dwFlags |= CE_PATH;
            return(TRUE);
        }
        else
        {
            pNext->GetItemValue().m_dwFlags |= NC_NOPATH;
        }
    }
    return (FALSE);
}

HRESULT PlayChord::Save( IAARIFFStream* pRIFF, DMUS_TIMESIGNATURE& rTimeSig )
{
    IStream*    pStream;
    MMCKINFO    ck;
    DWORD       cb;
    DMUS_IO_CHORD   iChord;
    DMUS_IO_SUBCHORD    iSubChord;
    DWORD        dwSize;
    HRESULT hr = E_FAIL;

    if ( !m_pChord || !m_pChord->m_pSubChords )
    {
        Trace(1, "ERROR: Attempt to save an empty chord list.\n");
        return E_FAIL;
    }
    pStream = pRIFF->GetStream();
    ck.ckid = mmioFOURCC('c','r','d','b');
    if( pRIFF->CreateChunk( &ck, 0 ) == 0 )
    {
        memset( &iChord, 0, sizeof( iChord ) );
        if (m_pChord->m_strName)
        {
            wcscpy( iChord.wszName, m_pChord->m_strName );
        }
        iChord.mtTime = ClocksPerBeat(rTimeSig) * m_nBeat + ClocksPerMeasure(rTimeSig) * m_nMeasure;
        iChord.wMeasure = m_nMeasure;
        iChord.bBeat = (BYTE)m_nBeat;
        iChord.bFlags = 0;
        if (m_fSilent) iChord.bFlags |= DMUS_CHORDKEYF_SILENT;
        dwSize = sizeof( iChord );
        hr = pStream->Write( &dwSize, sizeof( dwSize ), &cb );
        if( SUCCEEDED(hr) &&
            SUCCEEDED( pStream->Write( &iChord, sizeof( iChord), &cb ) ) &&
            cb == sizeof( iChord) )
        {
            {
                DWORD dwCount = (WORD) m_pChord->m_pSubChords->GetCount();
                hr = pStream->Write( &dwCount, sizeof( dwCount ), &cb );
                if( FAILED( hr ) || cb != sizeof( dwSize ) )
                {
                    pStream->Release();
                    return E_FAIL;
                }
                dwSize = sizeof( iSubChord );
                hr = pStream->Write( &dwSize, sizeof( dwSize ), &cb );
                if( FAILED( hr ) || cb != sizeof( dwSize ) )
                {
                    pStream->Release();
                    return E_FAIL;
                }
                for (TListItem<DMExtendedChord*>* pSub = m_pChord->m_pSubChords; pSub != NULL; pSub = pSub->GetNext())
                {
                    DMExtendedChord*& rSubChord = pSub->GetItemValue();
                    memset( &iSubChord, 0, sizeof( iSubChord ) );
                    iSubChord.dwChordPattern = rSubChord->m_dwChordPattern;
                    iSubChord.dwScalePattern = rSubChord->m_dwScalePattern;
                    iSubChord.dwInversionPoints = rSubChord->m_dwInvertPattern;
                    iSubChord.dwLevels = rSubChord->m_dwParts;
                    iSubChord.bChordRoot = rSubChord->m_bRoot;
                    iSubChord.bScaleRoot = rSubChord->m_bScaleRoot;
                    if( FAILED( pStream->Write( &iSubChord, sizeof( iSubChord ), &cb ) ) ||
                        cb != sizeof( iSubChord ) )
                    {
                        break;
                    }
                }
                // ascend from chord body chunk
                if( pSub == NULL &&
                    pRIFF->Ascend( &ck, 0 ) != 0 )
                {
                    hr = S_OK;
                }
            }
        }
    }
    pStream->Release();
    return hr;
}

char PlayChord::GetRoot()
{
    if (m_pChord)
    {
        return m_pChord->GetRoot();
    }
    else return 0;
}

void PlayChord::SetRoot(char chNewRoot)
{
    if (m_pChord)
    {
        m_pChord->SetRoot(chNewRoot);
    }
}



HRESULT LoadChordChunk(LPSTREAM pStream, PlayChord& rChord)
{
    DWORD           dwChordSize;
    DWORD           dwSubChordSize;
    DWORD           dwSubChordCount;
    DWORD           cb;
    HRESULT         hr;
    DMUS_IO_CHORD       iChord;
    DMUS_IO_SUBCHORD    iSubChord;

    memset(&iChord , 0, sizeof(iChord));
    memset(&iSubChord , 0, sizeof(iSubChord));

    hr = pStream->Read( &dwChordSize, sizeof( dwChordSize ), &cb );
    if (FAILED(hr) || cb != sizeof( dwChordSize ) ) 
    {
        return E_FAIL;
    }
    if( dwChordSize <= sizeof( DMUS_IO_CHORD ) )
    {
        pStream->Read( &iChord, dwChordSize, NULL );
    }
    else
    {
        pStream->Read( &iChord, sizeof( DMUS_IO_CHORD ), NULL );
        StreamSeek( pStream, dwChordSize - sizeof( DMUS_IO_CHORD ), STREAM_SEEK_CUR );
    }
    memset( &rChord, 0, sizeof( rChord) );
    rChord.m_nMeasure = iChord.wMeasure;
    rChord.m_nBeat = iChord.bBeat;
    rChord.m_fSilent = (iChord.bFlags & DMUS_CHORDKEYF_SILENT) ? true : false;
    rChord.m_pChord = new DMChordData;
    if (!rChord.m_pChord) return E_OUTOFMEMORY;
    rChord.m_pChord->m_strName = iChord.wszName;
    rChord.m_pChord->m_pSubChords = NULL;
    hr = pStream->Read( &dwSubChordCount, sizeof( dwSubChordCount ), &cb );
    if (FAILED(hr) || cb != sizeof( dwSubChordCount ) )
    {
        return E_FAIL;
    }
    hr = pStream->Read( &dwSubChordSize, sizeof( dwSubChordSize ), &cb );
    if (FAILED(hr) || cb != sizeof( dwSubChordSize ) )
    {
        return E_FAIL;
    }
    for (; dwSubChordCount > 0; dwSubChordCount--)
    {
        if( dwSubChordSize <= sizeof( DMUS_IO_SUBCHORD ) )
        {
            pStream->Read( &iSubChord, dwSubChordSize, NULL );
        }
        else
        {
            pStream->Read( &iSubChord, sizeof( DMUS_IO_SUBCHORD ), NULL );
            StreamSeek( pStream, dwSubChordSize - sizeof( DMUS_IO_SUBCHORD ), STREAM_SEEK_CUR );
        }
        TListItem<DMExtendedChord*>* pSub = new TListItem<DMExtendedChord*>;
        if( pSub )
        {
            DMExtendedChord* pNew = new DMExtendedChord;
            if (pNew)
            {
                memset( pNew, 0, sizeof( *pNew) );
                DMExtendedChord*& rSubChord = pSub->GetItemValue();
                rSubChord = pNew;
                rSubChord->AddRef();
                rSubChord->m_dwChordPattern = iSubChord.dwChordPattern;
                rSubChord->m_dwScalePattern = iSubChord.dwScalePattern;
                rSubChord->m_dwInvertPattern = iSubChord.dwInversionPoints;
                rSubChord->m_dwParts = iSubChord.dwLevels;
                rSubChord->m_bRoot = iSubChord.bChordRoot;  
                rSubChord->m_bScaleRoot = iSubChord.bScaleRoot;
                rChord.m_pChord->m_pSubChords = rChord.m_pChord->m_pSubChords->Cat(pSub);
            }
            else
            {
                delete pSub;
                pSub = NULL;
            }
        }
        if (!pSub) 
        {
            return E_OUTOFMEMORY;
        }
    }
    return S_OK;
}

HRESULT LoadChordList(TList<PlayChord>& ChordList, LPSTREAM pStream,
                      BYTE &bRoot, DWORD &dwScalePattern)
{
    long lFileSize = 0;
    DWORD dwChunkSize;
    MMCKINFO        ckMain;
    MMCKINFO        ck;
    MMCKINFO        ckHeader;
    IAARIFFStream*  pRIFF;
    HRESULT         hr = E_FAIL;
    DWORD dwPos;

    dwPos = StreamTell( pStream );
    StreamSeek( pStream, dwPos, STREAM_SEEK_SET );

   
    if( SUCCEEDED( AllocRIFFStream( pStream, &pRIFF ) ) )
    {
        ckMain.fccType = DMUS_FOURCC_CHORDTRACK_LIST;
        if( pRIFF->Descend( &ckMain, NULL, MMIO_FINDLIST ) == 0)
        {
            lFileSize = ckMain.cksize - 4; // subtract off the list type
            DWORD dwScale;
            DWORD cb;
            if (pRIFF->Descend(&ckHeader, &ckMain, 0) == 0 &&
                ckHeader.ckid == DMUS_FOURCC_CHORDTRACKHEADER_CHUNK )
            {
                lFileSize -= 8;  // chunk id + chunk size: double words
                lFileSize -= ckHeader.cksize;
                hr = pStream->Read( &dwScale, sizeof( dwScale ), &cb );
                if (FAILED(hr) || cb != sizeof( dwScale ) ) 
                {
                    if (SUCCEEDED(hr)) hr = E_FAIL;
                    pRIFF->Ascend( &ckHeader, 0 );
                    pRIFF->Release();
                    return hr;
                }
                hr = pRIFF->Ascend( &ckHeader, 0 );
                if (FAILED(hr))
                {
                    return hr;
                }
            }
            bRoot = (BYTE) (dwScale >> 24);
            dwScalePattern = dwScale & 0xffffff;
            while (lFileSize > 0)
            {
                if (pRIFF->Descend(&ck, &ckMain, 0) == 0 &&
                    ck.ckid == mmioFOURCC('c','r','d','b') )
                {
                    dwChunkSize = ck.cksize;
                    TListItem<PlayChord>* pChord = new TListItem<PlayChord>;
                    if (!pChord) break;
                    PlayChord& rChord = pChord->GetItemValue();
                    if (FAILED(LoadChordChunk(pStream, rChord))) break;
                    ChordList.AddTail(pChord);
                    if (pRIFF->Ascend( &ck, 0 ) != 0) break;
                    lFileSize -= 8;  // chunk id + chunk size: double words
                    lFileSize -= dwChunkSize;
                }
                else break;
            }
            if (lFileSize == 0 &&
                pRIFF->Ascend( &ck, 0 ) == 0)
            {
                hr = S_OK;
            }
        }
    }
    ChordList.MergeSort(Less);
    pRIFF->Release();
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CDMCompos

CDMCompos::CDMCompos( )
  : m_cRef(1),
    m_dwFlags(0),
    m_MemTrack(DMTRACK_COMPOSER)
{
    IncrementDLLCount();
    // Do this first since it might throw an exception
    //
    INITIALIZE_CRITICAL_SECTION( &m_CriticalSection );
    m_fCSInitialized = TRUE;

    dm_srand((unsigned int)time(NULL));
    m_pChords = NULL;
}

CDMCompos::~CDMCompos()
{
    if (m_fCSInitialized)
    {
        CleanUp();
        DELETE_CRITICAL_SECTION( &m_CriticalSection );
    }
    DecrementDLLCount();
}

void CDMCompos::CleanUp()
{
    TListItem<DMChordData*>* pScan = m_pChords;
    for(; pScan; pScan = pScan->GetNext())
    {
        pScan->GetItemValue()->Release();
        delete pScan->GetItemValue();
    }
    if (m_pChords)
    {
        TListItem<DMChordData*>::Delete(m_pChords);
        m_pChords = NULL;
    }
}

void CDMCompos::AddChord(DMChordData* pChord)
{
    TListItem<DMChordData*>* pNew = new TListItem<DMChordData*>(pChord);
    if (pNew)
    {
        pNew->SetNext(m_pChords);
        m_pChords = pNew;
    }
}


void CDMCompos::ChooseSignPosts(TListItem<DMSignPost> *pSignPostHead,
                            TListItem<CompositionCommand> *pTempCommand, DWORD dwType,
                            bool fSecondPass)

{
    //TempCommand *ptcom = tclist->GetHead();
    TListItem<DMSignPost> *pSignPost;
    for (;pTempCommand; pTempCommand = pTempCommand->GetNext())
    {
        CompositionCommand& rTempCommand = pTempCommand->GetItemValue();
        short nTotal = 0;
        if ((rTempCommand.m_dwChord & dwType) == 0)
        {
            continue;   // Only command, no chord.
        }
        pSignPost = pSignPostHead;
        for (; pSignPost; pSignPost = pSignPost->GetNext())
        { 
            DMSignPost& rSignPost = pSignPost->GetItemValue();
            if (rSignPost.m_dwTempFlags & rTempCommand.m_dwChord & dwType)
            {
                break;
            }
            else
            {
                if (rSignPost.m_dwChords & rTempCommand.m_dwChord & dwType)
                {
                    if (!rSignPost.m_dwTempFlags || fSecondPass) nTotal++;
                }
            }
        }
        if (!pSignPost)
        {
            if (nTotal) nTotal = dm_rand() % nTotal;
            else nTotal = 0;
            nTotal++;
            pSignPost = pSignPostHead;
            for (; pSignPost; pSignPost = pSignPost->GetNext())
            {
                DMSignPost& rSignPost = pSignPost->GetItemValue();
                if (rSignPost.m_dwChords & rTempCommand.m_dwChord & dwType)
                {
                    if (!rSignPost.m_dwTempFlags || fSecondPass)
                    {
                        nTotal--;
                        if (!nTotal)
                        {
                            break;
                        }
                    }
                }
            }
        }
        if (pSignPost && !rTempCommand.m_pSignPost)
        {
            pSignPost->GetItemValue().m_dwTempFlags |= rTempCommand.m_dwChord;
            rTempCommand.m_pSignPost = pSignPost;
        }
    }
}

TListItem<CompositionCommand> *CDMCompos::GetNextChord(TListItem<CompositionCommand> *pCommand)

{
    if (pCommand) pCommand = pCommand->GetNext();
    for (; pCommand; pCommand = pCommand->GetNext())
    {
        if (pCommand->GetItemValue().m_dwChord == 0) continue;   // Only command, no chord.
        if (pCommand->GetItemValue().m_pSignPost) break;
    }
    return(pCommand);
}

void CDMCompos::FindEarlierSignpost(TListItem<CompositionCommand> *pCommand, 
                         TListItem<CompositionCommand> *pThis,
                         SearchInfo *pSearch)

{
    CompositionCommand& rThis = pThis->GetItemValue();
    TListItem<CompositionCommand> *pBest = NULL;
    pSearch->m_pPlayChord = NULL;
    pSearch->m_pFirstChord = NULL;
    for (; pCommand; pCommand = pCommand->GetNext())
    {
        CompositionCommand& rCommand = pCommand->GetItemValue();
        if (pCommand == pThis) break;
        if (!UsingDX8() || rCommand.m_dwChord == rThis.m_dwChord)
        {
            if (rCommand.m_pSignPost == rThis.m_pSignPost)
            {
                if (rCommand.m_SearchInfo.m_End.Equals(
                    rThis.m_SearchInfo.m_End))
                {
                        pSearch->m_pPlayChord = rCommand.m_PlayList.GetHead();
                        pSearch->m_pFirstChord = rCommand.m_pFirstChord;
                        return;
                }
                pBest = pCommand;
            }
        }
    }
    if (pBest)
    {
        pSearch->m_pPlayChord = pBest->GetItemValue().m_PlayList.GetHead();
        pSearch->m_pFirstChord = pBest->GetItemValue().m_pFirstChord;
    }
}


static void ClearChordFlags(TList<DMChordEntry>& ChordMap, DWORD dwFlag)
{
    TListItem<DMChordEntry> *pChord = ChordMap.GetHead();
    for (; pChord; pChord = pChord->GetNext())
    {
        pChord->GetItemValue().m_dwFlags &= ~dwFlag;
    }
}

static void ClearNextFlags(TList<DMChordEntry>& ChordMap, DWORD dwFlag)

{
    TListItem<DMChordEntry> *pChord = ChordMap.GetHead();
    for (; pChord; pChord = pChord->GetNext())
    {
        TListItem<DMChordLink> *pScan = pChord->GetItemValue().m_Links.GetHead();
        for (; pScan; pScan = pScan->GetNext())
        {
            pScan->GetItemValue().m_dwFlags &= ~dwFlag;
        }
    }
}

// rCommand will hold the first chord and playlist
BOOL CDMCompos::Compose(TList<DMChordEntry>& ChordMap, SearchInfo *pSearch, CompositionCommand& rCommand)

{
    TListItem<PlayChord> *pDupe;
    TListItem<DMChordEntry> *pChord = NULL;
    SearchInfo tempSearch;
    FailSearch tempFail;
    tempSearch = *pSearch;
    int i = 0;
    // First, if we have a previous instance with the same starting point,
    // try to come up with a solution using its path.
    if (pSearch->m_pPlayChord && pSearch->m_pFirstChord)
    {
        pChord = pSearch->m_pFirstChord;
        ClearNextFlags(ChordMap, NC_PATH);
        ClearChordFlags(ChordMap, CE_PATH);
        if (pChord->GetItemValue().Walk(pSearch))
        {
        }
        else
        {
            pChord = NULL;
        }
    }
    if (!pChord)
    {
        pChord = ChordMap.GetHead();
        for (; pChord; pChord = pChord->GetNext())
        {
            DMChordEntry& rChord = pChord->GetItemValue();
            if (rChord.m_dwFlags & CE_START)
            {
                if (rChord.m_ChordData.Equals(pSearch->m_Start))
                {
                    ClearNextFlags(ChordMap, NC_PATH);
                    ClearChordFlags(ChordMap, CE_PATH);
                    tempFail = pSearch->m_Fail;
                    *pSearch = tempSearch;
                    pSearch->m_Fail = tempFail;
                    if (rChord.Walk(pSearch)) break;
                }
            }
        }
    }
    if (!pChord)
    {
        return(FALSE);
    }
    pDupe = new TListItem<PlayChord>;
    if (pDupe)
    {
        PlayChord& rDupe = pDupe->GetItemValue();
        rDupe.m_fSilent = false;
        rDupe.m_pChord = &pChord->GetItemValue().m_ChordData;
        rDupe.m_nMeasure = (short)i++;
        rDupe.m_nMinbeats = rDupe.m_nMaxbeats = 0;
        rDupe.m_pNext = NULL;
        pDupe->SetNext(NULL);
        rCommand.m_pFirstChord = pChord;
        rCommand.m_PlayList.AddTail(pDupe);
    }
    for (; pChord; )
    {
        TListItem<DMChordLink> *pNext = pChord->GetItemValue().m_Links.GetHead();
        for (; pNext; )
        {
            DMChordLink& rNext = pNext->GetItemValue();
            if (rNext.m_dwFlags & NC_PATH)
            {
                pDupe = new TListItem<PlayChord>;
                if (pDupe)
                {
                    PlayChord& rDupe = pDupe->GetItemValue();
                    rDupe.m_fSilent = false;
                    rDupe.m_pChord = &rNext.m_pChord->GetItemValue().m_ChordData;
                    rDupe.m_nMeasure = (short)i++;
                    rDupe.m_nMinbeats = (short)rNext.m_wMinBeats;
                    rDupe.m_nMaxbeats = (short)rNext.m_wMaxBeats;
                    rDupe.m_pNext = pNext;
                    pDupe->SetNext(NULL);
                    rCommand.m_PlayList.AddTail(pDupe);
                }
                break;
            }
            else
            {
                pNext = pNext->GetNext();
            }
        }
        if (pNext)
        {
            pChord = pNext->GetItemValue().m_pChord;
        }
        else pChord = NULL;
    }
    return(TRUE);
}

TListItem<PlayChord> *CDMCompos::AddChord(TList<PlayChord>& rList, DMChordData *pChord,
                    int nMeasure,int nBeat)

{
    if (pChord->m_pSubChords)
    {
        TListItem<PlayChord> *pNext = new TListItem<PlayChord>;
        if (pNext)
        {
            pNext->GetItemValue().m_pChord = new DMChordData(*pChord);
            if (pNext->GetItemValue().m_pChord)
            {
                AddChord(pNext->GetItemValue().m_pChord);
                pNext->GetItemValue().m_fSilent = false;
                pNext->GetItemValue().m_nMeasure = (short)nMeasure;
                pNext->GetItemValue().m_nBeat = (short)nBeat;
                pNext->GetItemValue().m_nMinbeats = 1;
                pNext->GetItemValue().m_pNext = NULL;
                rList.AddTail(pNext);
            }
            else
            {
                delete pNext;
                pNext = NULL;
            }
        }
        return (pNext);
    }
    else return NULL;
}

TListItem<PlayChord> *CDMCompos::AddCadence(TList<PlayChord>& rList, DMChordData *pChord, int nMax)

{
    TListItem<PlayChord> *pNext = AddChord(rList, pChord, 0, 0);
    if (pNext)
    {
        pNext->GetItemValue().m_nMaxbeats = (short)nMax;
    }
    return (pNext);
}

void CDMCompos::JostleBack(TList<PlayChord>& rList, TListItem<PlayChord> *pChord, int nBeats)

{
    PlayChord& rChord = pChord->GetItemValue();
    TListItem<PlayChord> *pLast = rList.GetPrev(pChord);
    if (nBeats && pLast)
    {
        int distance;
        rChord.m_nBeat = (short)( rChord.m_nBeat + nBeats );
        distance = rChord.m_nBeat - pLast->GetItemValue().m_nBeat;
        if (distance > rChord.m_nMaxbeats)
        {
            JostleBack(rList, pLast, distance - rChord.m_nMaxbeats);
        }
        else if (distance < rChord.m_nMinbeats)
        {
            JostleBack(rList, pLast, distance - rChord.m_nMinbeats);
        }
    }
}

static BOOL inline InRange(TListItem<PlayChord> *pChord,int nLastbeat)

{
    PlayChord& rChord = pChord->GetItemValue();
    int time = rChord.m_nBeat - nLastbeat;
    return ((time >= rChord.m_nMinbeats) && (time <= rChord.m_nMaxbeats));
}

BOOL CDMCompos::AlignChords(TListItem<PlayChord> *pChord,int nLastbeat,int nRes)

{
    if (pChord)
    {
        PlayChord& rChord = pChord->GetItemValue();
        if (!(pChord->GetNext()))
        {
            return (InRange(pChord, nLastbeat));
        }
        if ((rChord.m_nBeat % nRes) == 0)
        {
            if (InRange(pChord, nLastbeat))
            {
                return(AlignChords(pChord->GetNext(), rChord.m_nBeat, nRes));
            }
            return(FALSE);
        }
        BOOL tryright = dm_rand() % 2;
        int old = rChord.m_nBeat;
        rChord.m_nBeat = (short)( ( rChord.m_nBeat / nRes ) * nRes );
        if (tryright) rChord.m_nBeat = (short)( rChord.m_nBeat + nRes );
        if (InRange(pChord, nLastbeat))
        {
            if (AlignChords(pChord->GetNext(), rChord.m_nBeat, nRes))
                return(TRUE);
        }
        if (tryright) rChord.m_nBeat = (short)( rChord.m_nBeat - nRes );
        else rChord.m_nBeat = (short)( rChord.m_nBeat + nRes );
        if (InRange(pChord, nLastbeat))
        {
            if (AlignChords(pChord->GetNext(), rChord.m_nBeat, nRes))
                return(TRUE);
        }
        if (!tryright) rChord.m_nBeat = (short)( rChord.m_nBeat - nRes );
        rChord.m_nBeat = (short)( rChord.m_nBeat + ( ( nRes + 1 ) >> 1 ) );
        if (InRange(pChord, nLastbeat))
        {
            if (AlignChords(pChord->GetNext(), rChord.m_nBeat, nRes))
                return(TRUE);
        }
        rChord.m_nBeat = (short)old;
        if (InRange(pChord, nLastbeat))
        {
            return(AlignChords(pChord->GetNext(), rChord.m_nBeat, nRes));
        }
    }
    return (FALSE);
}

void CDMCompos::ChordConnections(TList<DMChordEntry>& ChordMap, 
                             CompositionCommand& rCommand,
                             SearchInfo *pSearch,
                             short nBPM,
                             DMChordData *pCadence1,
                             DMChordData *pCadence2)

{
    int mint, maxt, top, bottom, total;
    short oldbeats = pSearch->m_nBeats;
    //, error;
    TListItem<PlayChord> *pChord;
    SearchInfo tempSearch;
    // Compose a chord list.
    pSearch->m_nMinBeats = 0;
    pSearch->m_nMaxBeats = 0;
    pSearch->m_nChords = 0;
    pSearch->m_Fail.m_nTooManybeats = 0;
    pSearch->m_Fail.m_nTooFewbeats = 0;
    pSearch->m_Fail.m_nTooManychords = 0;
    pSearch->m_Fail.m_nTooFewchords = 0;
    if (pCadence1)
    {
        pSearch->m_nMinBeats++;
        pSearch->m_nMaxBeats = (short)( pSearch->m_nMaxBeats + ((nBPM + 1) >> 1) );
        pSearch->m_nChords++;
    }
    if (pCadence2)
    {
        pSearch->m_nMinBeats++;
        pSearch->m_nMaxBeats = (short)( pSearch->m_nMaxBeats + ((nBPM + 1) >> 1) );
        pSearch->m_nChords++;
    }
    tempSearch = *pSearch;
    for (total = 0;total < 4;total++)
    {
        rCommand.m_PlayList.RemoveAll();
        Compose(ChordMap, pSearch, rCommand);
        pChord = rCommand.m_PlayList.GetHead();
        if (pChord) break;
        if (pSearch->m_Fail.m_nTooManybeats > pSearch->m_Fail.m_nTooFewbeats)
        {
            tempSearch.m_nBeats = (short)( tempSearch.m_nBeats >> 1 );
        }
        else if (pSearch->m_Fail.m_nTooManybeats < pSearch->m_Fail.m_nTooFewbeats)
        {
            tempSearch.m_nBeats = (short)( tempSearch.m_nBeats << 1 );
        }
        else if (pSearch->m_Fail.m_nTooManychords > pSearch->m_Fail.m_nTooFewchords)
        {
            break;      // Can't possibly get better.  Use Cadence.
        }
        else if (pSearch->m_Fail.m_nTooManychords < pSearch->m_Fail.m_nTooFewchords)
        {
            tempSearch.m_nMinChords = (short)( tempSearch.m_nMinChords >> 1 );
        }
        else break;
        *pSearch = tempSearch;
    }
    pSearch->m_nBeats = oldbeats;
    // Tally the min and max beats.
    mint = 0;
    maxt = 0;
    for (; pChord; pChord = pChord->GetNext())
    {
        mint += pChord->GetItemValue().m_nMinbeats;
        maxt += pChord->GetItemValue().m_nMaxbeats;
    }
    pChord = rCommand.m_PlayList.GetHead();
    // If no chord connection was found, create one.
    if (!pChord)
    {
        int nextDuration = oldbeats;
        pChord = AddCadence(rCommand.m_PlayList, &pSearch->m_Start, 0);
        if (pChord)
        {
            pChord->GetItemValue().m_nMinbeats = 0;
        }
        if (pCadence1)
        {
            AddCadence(rCommand.m_PlayList, pCadence1, nextDuration);
            mint++;
            maxt += nextDuration;
            nextDuration = nBPM + 1;
        }
        if (pCadence2)
        {
            AddCadence(rCommand.m_PlayList, pCadence2, nextDuration);
            mint++;
            maxt += nextDuration;
            nextDuration = nBPM + 1;
        }
        AddCadence(rCommand.m_PlayList, &pSearch->m_Start, nextDuration);
        mint++;
        maxt += nextDuration;
    }
    else
    {
        int chordCount = (int) rCommand.m_PlayList.GetCount();
        int avMax;
        if (chordCount > 1) chordCount--;
        avMax = maxt / chordCount;
        if (avMax < 1) avMax = 1;
        if (pCadence1)
        {
            if (pCadence2)
            {
                AddCadence(rCommand.m_PlayList, pCadence2, avMax);
                maxt += avMax;
                mint++;
            }
            AddCadence(rCommand.m_PlayList, &pSearch->m_End, avMax);
            maxt += avMax;
            mint++;
        }
        else if (pCadence2)
        {
            AddCadence(rCommand.m_PlayList, &pSearch->m_End, avMax);
            maxt += avMax;
            mint++;
        }
    }
    // Prepare a ratio to apply to each connection.
    top = pSearch->m_nBeats - mint;
    bottom = maxt - mint;
    if (bottom <= 0) bottom = 1;
    // Assign each connection a time based on the ratio.
    total = 0;
    pChord = rCommand.m_PlayList.GetHead();
    for (; pChord; pChord = pChord->GetNext())
    {
        PlayChord& rChord = pChord->GetItemValue();
        int beat = rChord.m_nMaxbeats - rChord.m_nMinbeats;
        beat *= top;
        beat += (bottom >> 1);
        beat /= bottom;
        if (beat < rChord.m_nMinbeats) beat = rChord.m_nMinbeats;
        if (beat > rChord.m_nMaxbeats) beat = rChord.m_nMaxbeats;
        total += beat;
        rChord.m_nBeat = (short)total;
    }
    // It should not be the case that total is 0 after this loop, but it is possible.
    // (particularly if the playlist contains a single chord).  If this happens, give
    // total a value of 1 to make the computations in the following loop work correctly.
    if (!total) total = 1;
    // We should now have a close approximation of the correct time.
    // Stretch or shrink the range to fit exactly.  Err on the side
    // of too long, since jostleback will scrunch them back in place.
    pChord = rCommand.m_PlayList.GetHead();
    for (; pChord; pChord = pChord->GetNext())
    {
        PlayChord& rChord = pChord->GetItemValue();
        int newbeat = (rChord.m_nBeat * pSearch->m_nBeats) + total - 1;
        newbeat /= total;
        rChord.m_nBeat = (short)newbeat;
        if (!pChord->GetNext()) total = rChord.m_nBeat;
    }
    // Now we should have times close to the real thing.
    pChord = rCommand.m_PlayList.GetItem(rCommand.m_PlayList.GetCount() - 1);
    if (pChord && (int)pSearch->m_nBeats >= total)
    {
        JostleBack(rCommand.m_PlayList, pChord, pSearch->m_nBeats - total);
    }
    // Now, add the starting time offset to each chord.
    // And, remove the straggler last chord.
    AlignChords(rCommand.m_PlayList.GetHead(), 0, nBPM);
    pChord = rCommand.m_PlayList.GetHead();
    for (; pChord; )
    {
        pChord->GetItemValue().m_nMeasure = 
            (short)( ( pChord->GetItemValue().m_nBeat / nBPM ) + rCommand.m_nMeasure );
        pChord->GetItemValue().m_nBeat %= nBPM;
        if (pChord->GetNext())
        {
            pChord = pChord->GetNext();
        }
        else
        {
            rCommand.m_PlayList.Remove(pChord);
            delete pChord;
            break;
        }
    }
}

static TListItem<PlayChord> *FindChordInMeasure(TList<PlayChord>& PlayList,int nMeasure)

{
    TListItem<PlayChord> *pChord = PlayList.GetHead();
    for (; pChord; pChord = pChord->GetNext())
    {
        PlayChord& rChord = pChord->GetItemValue();
        if (rChord.m_nMeasure > nMeasure) break;
        if (rChord.m_nMeasure == nMeasure)
        {
            if (rChord.m_nBeat) return(pChord);
        }
    }
    return(NULL);
}

void CDMCompos::CleanUpBreaks(TList<PlayChord>& PlayList, TListItem<CompositionCommand> *pCommand)
{
    for (; pCommand; pCommand = pCommand->GetNext())
    {
        CompositionCommand& rCommand = pCommand->GetItemValue();
        if ((rCommand.m_Command.bCommand == DMUS_COMMANDT_BREAK) ||
            (rCommand.m_Command.bCommand == DMUS_COMMANDT_END) ||
            (rCommand.m_Command.bCommand == DMUS_COMMANDT_INTRO) )
        {
            TListItem<PlayChord> *pChord;

            while( ( pChord = FindChordInMeasure( PlayList, rCommand.m_nMeasure ) ) != NULL )
            {
                PlayList.Remove(pChord);
                delete pChord;
            }
        }
    }
}

static void LoadCommandList(TList<TemplateCommand>& CommandList, LPSTREAM pCStream)
{
    HRESULT         hr = E_FAIL;
    IAARIFFStream*  pRIFF;
    MMCKINFO        ck;
    long lFileSize = 0;
    DWORD dwNodeSize;
    DWORD       cb;

    StreamSeek(pCStream, 0, STREAM_SEEK_SET);

    if( SUCCEEDED( AllocRIFFStream( pCStream, &pRIFF ) ) &&
        pRIFF->Descend( &ck, NULL, 0 ) == 0 &&
        ck.ckid == FOURCC_COMMAND)
    {
        DMUS_IO_COMMAND iCommand;
        lFileSize = ck.cksize;
        hr = pCStream->Read( &dwNodeSize, sizeof( dwNodeSize ), &cb );
        if( SUCCEEDED( hr ) && cb == sizeof( dwNodeSize ) )
        {
            lFileSize -= 4; // for the size dword
            TListItem<TemplateCommand>* pCommand;
            if (lFileSize % dwNodeSize)
            {
                hr = E_FAIL;
            }
            else
            {
                while( lFileSize > 0 )
                {
                    pCommand = new TListItem<TemplateCommand>;
                    if( pCommand )
                    {
                        TemplateCommand& rCommand = pCommand->GetItemValue();
                        if( dwNodeSize <= sizeof( DMUS_IO_COMMAND ) )
                        {
                            pCStream->Read( &iCommand, dwNodeSize, NULL );
                        }
                        else
                        {
                            pCStream->Read( &iCommand, sizeof( DMUS_IO_COMMAND ), NULL );
                            StreamSeek( pCStream, lFileSize - sizeof( DMUS_IO_COMMAND ), STREAM_SEEK_CUR );
                        }
                        memset( &rCommand, 0, sizeof( rCommand ) );
                        rCommand.m_nMeasure = iCommand.wMeasure;
                        rCommand.m_Command.bCommand = iCommand.bCommand;
                        rCommand.m_Command.bGrooveLevel = iCommand.bGrooveLevel;
                        rCommand.m_Command.bGrooveRange = iCommand.bGrooveRange;
                        rCommand.m_Command.bRepeatMode = iCommand.bRepeatMode;
                        rCommand.m_dwChord = 0;
                        CommandList.AddTail(pCommand);
                        lFileSize -= dwNodeSize;
                    }
                    else break;
                }
            }
        }
        if( lFileSize == 0 &&
            pRIFF->Ascend( &ck, 0 ) == 0 )
        {
            hr = S_OK;
        }
    }
    pRIFF->Release();
}

static void LoadCommandList(TList<TemplateCommand>& CommandList, LPSTREAM pSPStream, LPSTREAM pCStream)
{
    TList<DMSignPostStruct> SignPostList;
    HRESULT         hr = E_FAIL;
    DWORD dwPos;
    IAARIFFStream*  pRIFF = NULL;

    dwPos = StreamTell( pSPStream );
    StreamSeek( pSPStream, dwPos, STREAM_SEEK_SET );
    MMCKINFO        ck;
    long lFileSize = 0;
    DWORD dwNodeSize;
    DWORD       cb;
    DMUS_IO_SIGNPOST        iSignPost;
 
    if( SUCCEEDED( AllocRIFFStream( pSPStream, &pRIFF ) ) &&
        pRIFF->Descend( &ck, NULL, 0 ) == 0 &&
        ck.ckid == DMUS_FOURCC_SIGNPOST_TRACK_CHUNK)
    {
        lFileSize = ck.cksize;
        hr = pSPStream->Read( &dwNodeSize, sizeof( dwNodeSize ), &cb );
        if( SUCCEEDED( hr ) && cb == sizeof( dwNodeSize ) )
        {
            lFileSize -= 4; // for the size dword
            TListItem<DMSignPostStruct>* pSignPost;
            if (lFileSize % dwNodeSize)
            {
                hr = E_FAIL;
            }
            else
            {
                while( lFileSize > 0 )
                {
                    pSignPost = new TListItem<DMSignPostStruct>;
                    if( pSignPost )
                    {
                        DMSignPostStruct& rSignPost = pSignPost->GetItemValue();
                        if( dwNodeSize <= sizeof( iSignPost ) )
                        {
                            pSPStream->Read( &iSignPost, dwNodeSize, NULL );
                        }
                        else
                        {
                            pSPStream->Read( &iSignPost, sizeof( iSignPost ), NULL );
                            StreamSeek( pSPStream, lFileSize - sizeof( iSignPost ), STREAM_SEEK_CUR );
                        }
                        memset( &rSignPost, 0, sizeof( rSignPost ) );
                        rSignPost.m_mtTime = iSignPost.mtTime;
                        rSignPost.m_wMeasure = iSignPost.wMeasure;
                        rSignPost.m_dwChords = iSignPost.dwChords;
                        SignPostList.AddTail(pSignPost);
                        lFileSize -= dwNodeSize;
                    }
                    else break;
                }
            }
        }
        if( lFileSize == 0 &&
            pRIFF->Ascend( &ck, 0 ) == 0 )
        {
            hr = S_OK;
        }
    }
    if (pRIFF)
    {
        pRIFF->Release();
        pRIFF = NULL;
    }

    // If a command stream exists, load the commands into the command list.
    if (pCStream)
    {
        StreamSeek(pCStream, 0, STREAM_SEEK_SET);

        if( SUCCEEDED( AllocRIFFStream( pCStream, &pRIFF ) ) &&
            pRIFF->Descend( &ck, NULL, 0 ) == 0 &&
            ck.ckid == FOURCC_COMMAND)
        {
            DMUS_IO_COMMAND iCommand;
            lFileSize = ck.cksize;
            hr = pCStream->Read( &dwNodeSize, sizeof( dwNodeSize ), &cb );
            if( SUCCEEDED( hr ) && cb == sizeof( dwNodeSize ) )
            {
                lFileSize -= 4; // for the size dword
                TListItem<TemplateCommand>* pCommand;
                if (lFileSize % dwNodeSize)
                {
                    hr = E_FAIL;
                }
                else
                {
                    while( lFileSize > 0 )
                    {
                        pCommand = new TListItem<TemplateCommand>;
                        if( pCommand )
                        {
                            TemplateCommand& rCommand = pCommand->GetItemValue();
                            if( dwNodeSize <= sizeof( DMUS_IO_COMMAND ) )
                            {
                                pCStream->Read( &iCommand, dwNodeSize, NULL );
                            }
                            else
                            {
                                pCStream->Read( &iCommand, sizeof( DMUS_IO_COMMAND ), NULL );
                                StreamSeek( pCStream, lFileSize - sizeof( DMUS_IO_COMMAND ), STREAM_SEEK_CUR );
                            }
                            memset( &rCommand, 0, sizeof( rCommand ) );
                            rCommand.m_nMeasure = iCommand.wMeasure;
                            rCommand.m_Command.bCommand = iCommand.bCommand;
                            rCommand.m_Command.bGrooveLevel = iCommand.bGrooveLevel;
                            rCommand.m_Command.bGrooveRange = iCommand.bGrooveRange;
                            rCommand.m_Command.bRepeatMode = iCommand.bRepeatMode;
                            CommandList.AddTail(pCommand);
                            lFileSize -= dwNodeSize;
                        }
                        else break;
                    }
                }
            }
            if( lFileSize == 0 &&
                pRIFF->Ascend( &ck, 0 ) == 0 )
            {
                hr = S_OK;
            }
        }
        if (pRIFF) pRIFF->Release();
    }

    // Now, go through the signpost list, making sure that every signpost has a corresponding
    // command.  If this is not the case for some signpost, insert a groove with the last
    // current groove level into the list (default this to 67).  Give each command's m_dwChord
    // the m_dwChords value from the corresponding signpost.
    BYTE bGrooveLevel = 62;
    TListItem<DMSignPostStruct>* pSignPost = SignPostList.GetHead();
    for( ; pSignPost; pSignPost = pSignPost->GetNext())
    {
        bool fFoundInList = false;
        DMSignPostStruct& rSignPost = pSignPost->GetItemValue();
        TListItem<TemplateCommand>* pPrevious = NULL;
        TListItem<TemplateCommand>* pCommand = CommandList.GetHead();
        for ( ; pCommand; pCommand = pCommand->GetNext())
        {
            TemplateCommand& rCommand = pCommand->GetItemValue();
            if (rSignPost.m_wMeasure == rCommand.m_nMeasure)
            {
                rCommand.m_dwChord = rSignPost.m_dwChords;
                fFoundInList = true;
                break;
            }
            else if (rSignPost.m_wMeasure < rCommand.m_nMeasure)
            {
                // We went too far in the command list, so break out
                break;
            }
            if (rCommand.m_Command.bGrooveLevel)
            {
                bGrooveLevel = rCommand.m_Command.bGrooveLevel;
            }
            pPrevious = pCommand;
        }
        if ( !fFoundInList )
        {
            // We need to create a new command and stick it between pPrevious and pCommand
            TListItem<TemplateCommand>* pNew = new TListItem<TemplateCommand>;
            if( pNew )
            {
                TemplateCommand& rNew = pNew->GetItemValue();
                memset( &rNew, 0, sizeof( rNew ) );
                rNew.m_nMeasure = rSignPost.m_wMeasure;
                rNew.m_Command.bCommand = DMUS_COMMANDT_GROOVE;
                rNew.m_Command.bGrooveLevel = bGrooveLevel;
                rNew.m_Command.bGrooveRange = 0;
                rNew.m_Command.bRepeatMode = DMUS_PATTERNT_RANDOM;
                rNew.m_dwChord = rSignPost.m_dwChords;
                if (pPrevious)
                {
                    pPrevious->SetNext(pNew);
                    pNew->SetNext(pCommand);
                }
                else
                {
                    CommandList.AddHead(pNew);
                }
            }
        }
    }
}

HRESULT CDMCompos::SaveChordList( IAARIFFStream* pRIFF,  TList<PlayChord>& rPlayList,
                             BYTE bRoot, DWORD dwScale, DMUS_TIMESIGNATURE& rTimeSig)
{
    IStream*    pStream;
    MMCKINFO    ck;
    MMCKINFO    ckHeader;
    HRESULT     hr;
    TListItem<PlayChord>*   pChord;
    DWORD cb;


    pStream = pRIFF->GetStream();

    ck.fccType = DMUS_FOURCC_CHORDTRACK_LIST;
    hr = pRIFF->CreateChunk(&ck,MMIO_CREATELIST);
    if (SUCCEEDED(hr))
    {

        DWORD dwRoot = bRoot;
        dwScale |= (dwRoot << 24);

        ckHeader.ckid = DMUS_FOURCC_CHORDTRACKHEADER_CHUNK;
        hr = pRIFF->CreateChunk(&ckHeader, 0);
        if (SUCCEEDED(hr))
        {
            hr = pStream->Write( &dwScale, sizeof( dwScale ), &cb );
            if (SUCCEEDED(hr))
            {
                hr = pRIFF->Ascend( &ckHeader, 0 );
                if (hr == 0)
                {
                    pChord = rPlayList.GetHead();
                    for( ; pChord != NULL ; pChord = pChord->GetNext() )
                    {
                        hr = pChord->GetItemValue().Save(pRIFF, rTimeSig);
                        if (FAILED(hr))
                        {
                            pStream->Release();
                            return hr;
                        }
                    }
                    if( pChord == NULL &&
                        pRIFF->Ascend( &ck, 0 ) == 0 )
                    {
                        hr = S_OK;
                    }
                }

            }
        }
    }

    pStream->Release();
    return hr;
}

static HRESULT SaveCommandList( IAARIFFStream* pRIFF,  TList<TemplateCommand>& rCommandList,
                               DMUS_TIMESIGNATURE& rTimeSig)
{
    IStream*    pStream;
    MMCKINFO    ck;
    HRESULT     hr;
    DWORD       cb;
    DWORD        dwSize;
    DMUS_IO_COMMAND   iCommand;
    TListItem<TemplateCommand>* pCommand;

    pStream = pRIFF->GetStream();
    hr = E_FAIL;
    ck.ckid = FOURCC_COMMAND;
    if( pRIFF->CreateChunk( &ck, 0 ) == 0 )
    {
        dwSize = sizeof( DMUS_IO_COMMAND );
        hr = pStream->Write( &dwSize, sizeof( dwSize ), &cb );
        if( FAILED( hr ) || cb != sizeof( dwSize ) )
        {
            pStream->Release( );
            return E_FAIL;
        }
        for( pCommand = rCommandList.GetHead(); pCommand != NULL ; pCommand = pCommand->GetNext() )
        {
            TemplateCommand& rCommand = pCommand->GetItemValue();
            memset( &iCommand, 0, sizeof( iCommand ) );
            iCommand.mtTime = ClocksPerMeasure(rTimeSig) * rCommand.m_nMeasure;
            iCommand.wMeasure = rCommand.m_nMeasure;
            iCommand.bBeat = 0;
            iCommand.bCommand = rCommand.m_Command.bCommand;
            iCommand.bGrooveLevel = rCommand.m_Command.bGrooveLevel;
            iCommand.bGrooveRange = rCommand.m_Command.bGrooveRange;
            iCommand.bRepeatMode = rCommand.m_Command.bRepeatMode;
            if( FAILED( pStream->Write( &iCommand, sizeof( iCommand ), &cb ) ) ||
                cb != sizeof( iCommand ) )
            {
                break;
            }
        }
        if( pCommand == NULL &&
            pRIFF->Ascend( &ck, 0 ) == 0 )
        {
            hr = S_OK;
        }
    }

    pStream->Release( );
    return hr;
}

static HRESULT SaveStartMarkers( IAARIFFStream* pRIFF,  TemplateCommand& rCommand,
                               IDMStyle* pStyle)
{
    IStream*    pStream;
    MMCKINFO    ckMain;
    MMCKINFO    ck;
    HRESULT     hr;
    DWORD       cb;
    DWORD        dwSize;
    DMUS_IO_VALID_START oValidStart;
    bool fWroteOne = false;

    pStream = pRIFF->GetStream();
    hr = E_FAIL;
    ckMain.ckid = FOURCC_LIST;
    ckMain.fccType = DMUS_FOURCC_MARKERTRACK_LIST;
    if( pRIFF->CreateChunk( &ckMain, MMIO_CREATELIST ) == 0 )
    {
        ck.ckid = DMUS_FOURCC_VALIDSTART_CHUNK;
        if( pRIFF->CreateChunk( &ck, 0 ) == 0 )
        {
            dwSize = sizeof( DMUS_IO_VALID_START );
            hr = pStream->Write( &dwSize, sizeof( dwSize ), &cb );
            if( FAILED( hr ) || cb != sizeof( dwSize ) )
            {
                pStream->Release( );
                return E_FAIL;
            }
            DWORD dwIndex = 0;
            MUSIC_TIME mtTime = 0;
            while(S_OK == (hr = pStyle->EnumStartTime(dwIndex, &rCommand.m_Command, &mtTime)))
            {
                memset( &oValidStart, 0, sizeof( oValidStart ) );
                oValidStart.mtTime = mtTime;
                if( FAILED( hr = pStream->Write( &oValidStart, sizeof( oValidStart ), &cb ) ) ||
                    cb != sizeof( oValidStart ) )
                {
                    if (SUCCEEDED(hr)) hr = E_FAIL;
                    break;
                }
                fWroteOne = true;
                dwIndex++;
            }
            if( SUCCEEDED(hr) && pRIFF->Ascend( &ck, 0 ) == 0 )
            {
                hr = S_OK;
            }
        }
        if( SUCCEEDED(hr) && pRIFF->Ascend( &ck, 0 ) == 0 )
        {
            hr = S_OK;
        }
    }
    if (!fWroteOne) hr = E_FAIL;

    pStream->Release( );
    return hr;
}

void CDMCompos::ComposePlayList(TList<PlayChord>& PlayList, 
                            IDirectMusicStyle* pStyle,  
                            IDirectMusicChordMap* pPersonality,
                            TList<TemplateCommand>& rCommandList,
                            WORD wActivity)
{
    // Extract the style's time signature.
    DMUS_TIMESIGNATURE TimeSig;
    pStyle->GetTimeSignature(&TimeSig);
    if ((short)wActivity < 0) wActivity = 0;
    if (wActivity > 3) wActivity = 3;
    short nBPM = TimeSig.bBeatsPerMeasure;
    IDMPers* pDMP;
    pPersonality->QueryInterface(IID_IDMPers, (void**)&pDMP);
    DMPersonalityStruct* pPers;
    pDMP->GetPersonalityStruct((void**)&pPers);
    TList<DMChordEntry> &ChordMap = pPers->m_ChordMap;
    TList<DMSignPost> &SignPostList = pPers->m_SignPostList;
    TListItem<DMSignPost> *pSign = SignPostList.GetHead();
    for (; pSign; pSign = pSign->GetNext())
    {
        pSign->GetItemValue().m_dwTempFlags = 0;
    }
    // Assign specific root sign posts, then letter based sign posts.
    TList<CompositionCommand> CommandList;
    TListItem<TemplateCommand>* pTC = rCommandList.GetHead();
    for(; pTC; pTC = pTC->GetNext())
    {
        TemplateCommand& rTC = pTC->GetItemValue();
        TListItem<CompositionCommand>* pNew = new TListItem<CompositionCommand>;
        if (pNew)
        {
            CompositionCommand& rNew = pNew->GetItemValue();
            rNew.m_nMeasure = rTC.m_nMeasure;
            rNew.m_Command = rTC.m_Command;
            rNew.m_dwChord = rTC.m_dwChord;
            rNew.m_pSignPost = NULL;
            rNew.m_pFirstChord = NULL;
            CommandList.AddTail(pNew);
        }
    }
    ChooseSignPosts(SignPostList.GetHead(), CommandList.GetHead(),DMUS_SIGNPOSTF_ROOT, false);
    ChooseSignPosts(SignPostList.GetHead(), CommandList.GetHead(),DMUS_SIGNPOSTF_LETTER, false);
    ChooseSignPosts(SignPostList.GetHead(), CommandList.GetHead(),DMUS_SIGNPOSTF_ROOT, true);
    ChooseSignPosts(SignPostList.GetHead(), CommandList.GetHead(),DMUS_SIGNPOSTF_LETTER, true);
   // Now, we should have a chord assigned for each node in the template.
    TListItem<CompositionCommand>* pCommand = CommandList.GetHead();
    for (; pCommand; pCommand = pCommand->GetNext())
    {
        CompositionCommand& rCommand = pCommand->GetItemValue();
        if (rCommand.m_dwChord == 0) continue;   // Only command, no chord.
        if (rCommand.m_pSignPost)
        {
            TListItem<CompositionCommand>* pNext = GetNextChord(pCommand);
            if (pNext)
            {
                CompositionCommand& rNext = pNext->GetItemValue();
                SearchInfo *pSearch = &rCommand.m_SearchInfo;
                DMChordData *pCadence1 = NULL;
                DMChordData *pCadence2 = NULL;
                pSearch->m_Start = rCommand.m_pSignPost->GetItemValue().m_ChordData;
                if (rNext.m_dwChord & DMUS_SIGNPOSTF_CADENCE)
                {
                    TListItem<DMSignPost> *pSign = rNext.m_pSignPost;
                    DMSignPost& rSign = pSign->GetItemValue();
                    if (rSign.m_dwFlags & DMUS_SPOSTCADENCEF_1)
                    {
                        pSearch->m_End = rSign.m_aCadence[0];
                        pCadence1 = &rSign.m_aCadence[0];
                        if (rSign.m_dwFlags & DMUS_SPOSTCADENCEF_2)
                        {
                            pCadence2 = &rSign.m_aCadence[1];
                        }
                    }
                    else if (rSign.m_dwFlags & DMUS_SPOSTCADENCEF_2)
                    {
                        pSearch->m_End = rSign.m_aCadence[1];
                        pCadence2 = &rSign.m_aCadence[1];
                    }
                    else
                    {
                        pSearch->m_End = rSign.m_ChordData;
                    }
                }
                else
                {
                    pSearch->m_End = rNext.m_pSignPost->GetItemValue().m_ChordData;
                }
                pSearch->m_nActivity = (short) wActivity;
                pSearch->m_nBeats = (short)( (rNext.m_nMeasure - rCommand.m_nMeasure) * nBPM );
                pSearch->m_nMaxChords = (short)( pSearch->m_nBeats >> wActivity );
                pSearch->m_nMinChords = (short)( pSearch->m_nBeats >> (wActivity + 1) );
                FindEarlierSignpost(CommandList.GetHead(), pCommand, pSearch);
                // rCommand holds the playlist and the measure used by ChordConnections
                // (it should be passed by reference since the playlist changes)
                ChordConnections(ChordMap, rCommand, pSearch, nBPM, pCadence1, pCadence2);
            }
            else
            {
                AddChord(rCommand.m_PlayList, &rCommand.m_pSignPost->GetItemValue().m_ChordData,
                    rCommand.m_nMeasure,0);
            }
        }
    }
    // Take all the Chord references and fold 'em into one list.
    pCommand = CommandList.GetHead();
    for (; pCommand; pCommand = pCommand->GetNext())
    {
        PlayList.Cat(pCommand->GetItemValue().m_PlayList.GetHead());
        pCommand->GetItemValue().m_PlayList.RemoveAll();
    }
    CleanUpBreaks(PlayList, CommandList.GetHead());
    pDMP->Release();
}

HRESULT CDMCompos::ExtractCommandList(TList<TemplateCommand>& CommandList,
                                      IDirectMusicTrack*    pSignPostTrack,
                                      IDirectMusicTrack*    pCommandTrack,
                                      DWORD dwGroupBits)    
{
    HRESULT             hr              = S_OK;
    IPersistStream*     pPS1            = NULL;
    IPersistStream*     pPS2            = NULL;
    IStream*            pStream1        = NULL;
    IStream*            pStream2        = NULL;
    
    // First, get the signpost track from the template segment and persist it to a stream
    if (!pSignPostTrack)
    {
        Trace(1, "ERROR: No signpost track to use for chord composition.\n");
        hr = E_POINTER;
        goto ON_END;
    }
    hr = pSignPostTrack->QueryInterface(IID_IPersistStream, (void**)&pPS1);
    if (hr != S_OK) goto ON_END;
    hr = CreateStreamOnHGlobal(NULL, TRUE, &pStream1);
    if (hr != S_OK) goto ON_END;
    hr = pPS1->Save(pStream1, FALSE);
    if (hr != S_OK) goto ON_END;
    StreamSeek(pStream1, 0, STREAM_SEEK_SET);


    // Next, get the command track from the template segment and persist it to a stream.
    // If there is no command track, we'll just use a NULL stream.
    if (pCommandTrack)
    {
        hr = pCommandTrack->QueryInterface(IID_IPersistStream, (void**)&pPS2);
        if (hr != S_OK) goto ON_END;
        hr = CreateStreamOnHGlobal(NULL, TRUE, &pStream2);
        if (hr != S_OK) goto ON_END;
        hr = pPS2->Save(pStream2, FALSE);
        if (hr != S_OK) goto ON_END;
        StreamSeek(pStream2, 0, STREAM_SEEK_SET);
    }

    // Finally, call LoadCommandList, passing in the two streams.
    LoadCommandList(CommandList, pStream1, pStream2);

ON_END:
    if (pPS1) pPS1->Release();
    if (pPS2) pPS2->Release();
    if (pStream1) pStream1->Release();
    if (pStream2) pStream2->Release();
    return hr;
}

// This will modify an existing segment by adding *only* a chord track to it.
// Any existing chord tracks with conflicting group bits will be removed.
HRESULT CDMCompos::AddToSegment(IDirectMusicSegment* pTempSeg,
                           TList<PlayChord>& PlayList,
                           IDirectMusicStyle* pStyle,
                           DWORD dwGroupBits,
                           BYTE bRoot, DWORD dwScale)
{
    HRESULT                 hr                      = S_OK;
    IDirectMusicTrack*      pIChordTrack            = NULL;
    IAARIFFStream*          pChordRIFF              = NULL;
    IStream*                pIChordStream           = NULL;
    IPersistStream*         pIChordTrackStream      = NULL;

    /////////////////////////////////////////////////////////////
    // Extract the style's time signature.
    DMUS_TIMESIGNATURE TimeSig;
    pStyle->GetTimeSignature(&TimeSig);
    // Convert PlayList into a Chord Track
    if (PlayList.GetHead())
    {
        // if there exists a chord track with these group bits, reload these chords into that
        // track (use the first track that's found).  Otherwise, create a new chord track
        // to load these chords into.
        hr = pTempSeg->GetTrack(CLSID_DirectMusicChordTrack, dwGroupBits, 0, &pIChordTrack);
        if (S_OK != hr)
        {
            // create a new chord track
            hr = DirectMusicCreateInstance(CLSID_DirectMusicChordTrack,NULL,
                                IID_IDirectMusicTrack,
                                (void **) &pIChordTrack);
            if (!SUCCEEDED(hr)) goto ON_END;
            // insert the new chord track.
            pTempSeg->InsertTrack(pIChordTrack, dwGroupBits);
        }
        hr = CreateStreamOnHGlobal(NULL, TRUE, &pIChordStream);
        if (S_OK != hr) goto ON_END;
        hr = AllocRIFFStream( pIChordStream, &pChordRIFF);
        if (S_OK != hr) goto ON_END;
        SaveChordList(pChordRIFF, PlayList, bRoot, dwScale, TimeSig);
        hr = pIChordTrack->QueryInterface(IID_IPersistStream, (void**)&pIChordTrackStream);
        if (!SUCCEEDED(hr)) goto ON_END;
        StreamSeek(pIChordStream, 0, STREAM_SEEK_SET);
        hr = pIChordTrackStream->Load(pIChordStream);
        if (!SUCCEEDED(hr)) goto ON_END;
    }

ON_END:
    if (pIChordTrack) pIChordTrack->Release();
    if (pChordRIFF) pChordRIFF->Release();
    if (pIChordStream) pIChordStream->Release();
    if (pIChordTrackStream) pIChordTrackStream->Release();
    return hr;
}

HRESULT CDMCompos::CopySegment(IDirectMusicSegment* pTempSeg,
                           IDirectMusicSegment** ppSectionSeg,
                           TList<PlayChord>& PlayList,
                           IDirectMusicStyle* pStyle,
                           IDirectMusicChordMap* pChordMap,
                           BOOL fStyleFromTrack,
                           BOOL fChordMapFromTrack,
                           DWORD dwGroupBits,
                           BYTE bRoot, DWORD dwScale)
{
    if (!ppSectionSeg) return E_INVALIDARG;

    HRESULT                 hr                      = S_OK;
    IDirectMusicTrack*      pIChordTrack            = NULL;
    IAARIFFStream*          pChordRIFF              = NULL;
    IStream*                pIChordStream           = NULL;
    IPersistStream*         pIChordTrackStream      = NULL;
    IDirectMusicTrack*      pIStyleTrack            = NULL;
    IDirectMusicTrack*      pIChordMapTrack         = NULL;
    IDirectMusicTrack*      pDMTrack                = NULL;
    IDirectMusicTrack*      pBandTrack              = NULL;
    IDirectMusicBand*       pBand                   = NULL;
    long                    nClocks                 = 0;
    DMUS_BAND_PARAM         DMBandParam;

    DWORD dwStyleGroupBits = 1;
    if (UsingDX8(pStyle, pChordMap))
    {
        for (int i = 0; i < 32; i++)
        {
            if (dwGroupBits & (1 << i))
            {
                dwStyleGroupBits = 1 << i;
                break;
            }
        }
    }
    else
    {
        dwGroupBits = 1;
    }

    pTempSeg->GetLength(&nClocks);
    /////////////////////////////////////////////////////////////
    // clone the template segment to get a section segment
    hr = pTempSeg->Clone(0, nClocks, ppSectionSeg);
    if (!SUCCEEDED(hr)) goto ON_END;
    // Extract the style's time signature.
    DMUS_TIMESIGNATURE TimeSig;
    pStyle->GetTimeSignature(&TimeSig);
    // Convert PlayList into a Chord Track
    if (PlayList.GetHead())
    {
        hr = DirectMusicCreateInstance(CLSID_DirectMusicChordTrack,NULL,
                            IID_IDirectMusicTrack,
                            (void **) &pIChordTrack);
        if (!SUCCEEDED(hr)) goto ON_END;
        hr = CreateStreamOnHGlobal(NULL, TRUE, &pIChordStream);
        if (S_OK != hr) goto ON_END;
        hr = AllocRIFFStream( pIChordStream, &pChordRIFF);
        if (S_OK != hr) goto ON_END;
        SaveChordList(pChordRIFF, PlayList, bRoot, dwScale, TimeSig);
        hr = pIChordTrack->QueryInterface(IID_IPersistStream, (void**)&pIChordTrackStream);
        if (!SUCCEEDED(hr)) goto ON_END;
        StreamSeek(pIChordStream, 0, STREAM_SEEK_SET);
        hr = pIChordTrackStream->Load(pIChordStream);
        if (!SUCCEEDED(hr)) goto ON_END;
        (*ppSectionSeg)->InsertTrack(pIChordTrack, dwGroupBits);
    }

    // If the passed-in Style is not from the template segment, 
    // remove all style tracks from the new segment and add a new Style track.
    if (!fStyleFromTrack)
    {
        do
        {
            hr = (*ppSectionSeg)->GetTrack(CLSID_DirectMusicStyleTrack, ALL_TRACK_GROUPS, 0, &pIStyleTrack);
            if (S_OK == hr)
            {
                (*ppSectionSeg)->RemoveTrack(pIStyleTrack);
                pIStyleTrack->Release();
            }
        } while (S_OK == hr);
        hr = DirectMusicCreateInstance(CLSID_DirectMusicStyleTrack,NULL,IID_IDirectMusicTrack,(void**)&pIStyleTrack);
        if (FAILED(hr)) goto ON_END;
        pIStyleTrack->SetParam(GUID_IDirectMusicStyle, 0, (void*)pStyle);
        (*ppSectionSeg)->InsertTrack(pIStyleTrack, dwStyleGroupBits);
    }

    // If the passed-in ChordMap is not from the template segment, 
    // remove all ChordMap tracks from the new segment and add a new ChordMap track.
    if (!fChordMapFromTrack)
    {
        do
        {
            hr = (*ppSectionSeg)->GetTrack(CLSID_DirectMusicChordMapTrack, ALL_TRACK_GROUPS, 0, &pIChordMapTrack);
            if (S_OK == hr)
            {
                (*ppSectionSeg)->RemoveTrack(pIChordMapTrack);
                pIChordMapTrack->Release();
            }
        } while (S_OK == hr);
        hr = DirectMusicCreateInstance(CLSID_DirectMusicChordMapTrack,NULL,IID_IDirectMusicTrack,(void**)&pIChordMapTrack);
        if (FAILED(hr)) goto ON_END;
        pIChordMapTrack->SetParam(GUID_IDirectMusicChordMap, 0, (void*)pChordMap);
        (*ppSectionSeg)->InsertTrack(pIChordMapTrack, dwGroupBits);
    }

    // if there's no tempo track in the template segment, create one and add it
    if (FAILED(pTempSeg->GetTrack(CLSID_DirectMusicTempoTrack, ALL_TRACK_GROUPS, 0, &pDMTrack)))
    {
        // Create a Tempo Track in which to store the tempo events
        DMUS_TEMPO_PARAM tempo;
        tempo.mtTime = 0; //ConvertTime( dwTime );

        pStyle->GetTempo(&tempo.dblTempo);
        if( SUCCEEDED( DirectMusicCreateInstance( CLSID_DirectMusicTempoTrack,NULL,
            IID_IDirectMusicTrack,(void**)&pDMTrack )))
        {
            if ( SUCCEEDED(pDMTrack->SetParam(GUID_TempoParam, 0, &tempo)) )
            {
                (*ppSectionSeg)->InsertTrack( pDMTrack, dwGroupBits );
            }
        }
    }
    // if there's no band track in the template segment, create one and add it
    if (FAILED(pTempSeg->GetTrack(CLSID_DirectMusicBandTrack, ALL_TRACK_GROUPS, 0, &pBandTrack)))
    {
        // Create band track
        hr = DirectMusicCreateInstance(CLSID_DirectMusicBandTrack,NULL,IID_IDirectMusicTrack,(void**)&pBandTrack);
        
        if(!SUCCEEDED(hr)) goto ON_END;
        
        // Load default band from style into track
        // If for some reason the style doesn't have a default band (could happend
        // if the style came from a pattern track), don't make a band track.
        if (pStyle->GetDefaultBand(&pBand) == S_OK)
        {
            DMBandParam.mtTimePhysical = -64;
            DMBandParam.pBand = pBand;
            hr = pBandTrack->SetParam(GUID_BandParam, 0, (void*)&DMBandParam);
            if (!SUCCEEDED(hr)) goto ON_END;
            (*ppSectionSeg)->InsertTrack(pBandTrack, dwGroupBits);
        }
    }

    // Initialize the segment
    (*ppSectionSeg)->SetRepeats(0); // still needed for dx7
    TraceI(4, "Segment Length: %d\n", nClocks);
    (*ppSectionSeg)->SetLength(nClocks);
    if (UsingDX8(pStyle, pChordMap))
    {
        DWORD dwLoopRepeats = 0;
        pTempSeg->GetRepeats( &dwLoopRepeats );
        (*ppSectionSeg)->SetRepeats( dwLoopRepeats );
        MUSIC_TIME mtLoopStart = 0, mtLoopEnd = 0;
        pTempSeg->GetLoopPoints( &mtLoopStart, &mtLoopEnd );
        (*ppSectionSeg)->SetLoopPoints( mtLoopStart, mtLoopEnd );
    }

ON_END:
    if (pIChordTrack) pIChordTrack->Release();
    if (pChordRIFF) pChordRIFF->Release();
    if (pIChordStream) pIChordStream->Release();
    if (pIChordTrackStream) pIChordTrackStream->Release();
    if (pDMTrack)
    {
        // This releases the Addref made either by GetTrack or (if GetTrack failed)
        // by CreateInstance
        pDMTrack->Release();
    }
    if (pBandTrack)
    {
        // This releases the Addref made either by GetTrack or (if GetTrack failed)
        // by CreateInstance
        pBandTrack->Release();
    }
    if (pIStyleTrack) pIStyleTrack->Release();
    if (pIChordMapTrack) pIChordMapTrack->Release();
    if (pBand) pBand->Release();
    return hr;
}

HRESULT CDMCompos::BuildSegment(TList<TemplateCommand>& CommandList,
                            TList<PlayChord>& PlayList, 
                            IDirectMusicStyle* pStyle,
                            IDirectMusicChordMap* pChordMap,
                            long lMeasures,
                            IDirectMusicSegment** ppSectionSeg,
                            BYTE bRoot, DWORD dwScale, 
                            double* pdblTempo,
                            IDirectMusicBand* pCurrentBand,
                            bool fAlign,
                            IDirectMusicGraph* pGraph,
                            IUnknown* pPath)
{
    if (!ppSectionSeg) return E_INVALIDARG;

    HRESULT                 hr                      = S_OK;
    IDirectMusicTrack*      pIChordTrack            = NULL;
    IAARIFFStream*          pChordRIFF              = NULL;
    IStream*                pIChordStream           = NULL;
    IPersistStream*         pIChordTrackStream      = NULL;
    IDirectMusicTrack*      pICommandTrack          = NULL;
    IAARIFFStream*          pCommandRIFF            = NULL;
    IStream*                pICommandStream         = NULL;
    IPersistStream*         pICommandTrackStream    = NULL;
    IDirectMusicTrack*      pIMarkerTrack           = NULL;
    IAARIFFStream*          pMarkerRIFF             = NULL;
    IStream*                pIMarkerStream          = NULL;
    IPersistStream*         pIMarkerTrackStream     = NULL;
    IDirectMusicTrack*      pIStyleTrack            = NULL;
    IDirectMusicTrack*      pIChordMapTrack         = NULL;
    IDirectMusicTrack*      pDMTrack                = NULL;
    IDirectMusicTrack*      pBandTrack              = NULL;
    IDirectMusicBand*       pBand                   = NULL;
    long                    nClocks                 = 0;
    DMUS_BAND_PARAM         DMBandParam;

    // create a section segment
    hr = DirectMusicCreateInstance(CLSID_DirectMusicSegment,NULL,
                                    IID_IDirectMusicSegment,
                                    (void **) ppSectionSeg);
    if (!SUCCEEDED(hr)) goto ON_END;
    // Extract the style's time signature.
    DMUS_TIMESIGNATURE TimeSig;
    pStyle->GetTimeSignature(&TimeSig);
    nClocks = (lMeasures) * TimeSig.bBeatsPerMeasure * (DMUS_PPQ * 4 / TimeSig.bBeat);
    // Convert PlayList into a Chord Track
    if (PlayList.GetHead())
    {
        hr = DirectMusicCreateInstance(CLSID_DirectMusicChordTrack,NULL,
                            IID_IDirectMusicTrack,
                            (void **) &pIChordTrack);
        if (!SUCCEEDED(hr)) goto ON_END;
        hr = CreateStreamOnHGlobal(NULL, TRUE, &pIChordStream);
        if (S_OK != hr) goto ON_END;
        hr = AllocRIFFStream( pIChordStream, &pChordRIFF);
        if (S_OK != hr) goto ON_END;
        SaveChordList(pChordRIFF, PlayList, bRoot, dwScale, TimeSig);
        hr = pIChordTrack->QueryInterface(IID_IPersistStream, (void**)&pIChordTrackStream);
        if (!SUCCEEDED(hr)) goto ON_END;
        StreamSeek(pIChordStream, 0, STREAM_SEEK_SET);
        hr = pIChordTrackStream->Load(pIChordStream);
        if (!SUCCEEDED(hr)) goto ON_END;
    }
    // Convert CommandList into a Command Track
    hr = DirectMusicCreateInstance(CLSID_DirectMusicCommandTrack,NULL,IID_IDirectMusicTrack,(void**)&pICommandTrack);
    if (!SUCCEEDED(hr)) goto ON_END;
    hr = CreateStreamOnHGlobal(NULL, TRUE, &pICommandStream);
    if (S_OK != hr) goto ON_END;
    hr = AllocRIFFStream( pICommandStream, &pCommandRIFF);
    if (S_OK != hr) goto ON_END;
    SaveCommandList(pCommandRIFF, CommandList, TimeSig);
    hr = pICommandTrack->QueryInterface(IID_IPersistStream, (void**)&pICommandTrackStream);
    if (!SUCCEEDED(hr)) goto ON_END;
    StreamSeek(pICommandStream, 0, STREAM_SEEK_SET);
    hr = pICommandTrackStream->Load(pICommandStream);
    if (!SUCCEEDED(hr)) goto ON_END;

    // If the align flag's been set, create a marker track
    if (fAlign)
    {
        TListItem<TemplateCommand>* pCommandItem = CommandList.GetHead();
        IDMStyle* pDMStyle = NULL;
        if (pCommandItem && 
            pStyle && 
            SUCCEEDED(pStyle->QueryInterface(IID_IDMStyle, (void**) &pDMStyle)))
        {
            hr = DirectMusicCreateInstance(CLSID_DirectMusicMarkerTrack,NULL,IID_IDirectMusicTrack,(void**)&pIMarkerTrack);
            if (!SUCCEEDED(hr))
            {
                pDMStyle->Release();
                goto ON_END;
            }
            hr = CreateStreamOnHGlobal(NULL, TRUE, &pIMarkerStream);
            if (S_OK != hr)            
            {
                pDMStyle->Release();
                goto ON_END;
            }
            hr = AllocRIFFStream( pIMarkerStream, &pMarkerRIFF);
            if (S_OK != hr)            
            {
                pDMStyle->Release();
                goto ON_END;
            }
            hr = SaveStartMarkers(pMarkerRIFF, pCommandItem->GetItemValue(), pDMStyle);
            // If the above fails, it means the style doesn't have any markers, so just
            // continue without creating a marker track.
            if (SUCCEEDED(hr)) 
            {
                hr = pIMarkerTrack->QueryInterface(IID_IPersistStream, (void**)&pIMarkerTrackStream);
                if (!SUCCEEDED(hr))
                {
                    pDMStyle->Release();
                    goto ON_END;
                }
                StreamSeek(pIMarkerStream, 0, STREAM_SEEK_SET);
                hr = pIMarkerTrackStream->Load(pIMarkerStream);
                if (!SUCCEEDED(hr))            
                {
                    pDMStyle->Release();
                    goto ON_END;
                }
            }
            pDMStyle->Release();
        }
    }

    // Use the passed-in Style to create a Style Track
    hr = DirectMusicCreateInstance(CLSID_DirectMusicStyleTrack,NULL,IID_IDirectMusicTrack,(void**)&pIStyleTrack);
    if (FAILED(hr)) goto ON_END;
    pIStyleTrack->SetParam(GUID_IDirectMusicStyle, 0, (void*)pStyle);

    // Use the passed-in ChordMap to create a ChordMap Track
    hr = DirectMusicCreateInstance(CLSID_DirectMusicChordMapTrack,NULL,IID_IDirectMusicTrack,(void**)&pIChordMapTrack);
    if (FAILED(hr)) goto ON_END;
    if (pChordMap)
    {
        pIChordMapTrack->SetParam(GUID_IDirectMusicChordMap, 0, (void*)pChordMap);
    }

    // Create a Tempo Track in which to store the tempo events
    ////////////////////////////////////////////////////////////
    DMUS_TEMPO_PARAM tempo;
    tempo.mtTime = 0; //ConvertTime( dwTime );

    if (!pdblTempo)
    {
        pStyle->GetTempo(&tempo.dblTempo);
    }
    else
    {
        tempo.dblTempo = *pdblTempo;
    }
    ////////////////////////////////////////////////////////////
    if( SUCCEEDED( DirectMusicCreateInstance( CLSID_DirectMusicTempoTrack,NULL,
        IID_IDirectMusicTrack,(void**)&pDMTrack )))
    {
        if ( SUCCEEDED(pDMTrack->SetParam(GUID_TempoParam, 0, &tempo)) )
        {
            (*ppSectionSeg)->InsertTrack( pDMTrack, 1 );
        }
    }
    // Create a new band track. 
    hr = DirectMusicCreateInstance(CLSID_DirectMusicBandTrack,NULL,IID_IDirectMusicTrack,(void**)&pBandTrack);
        
    if(!SUCCEEDED(hr)) goto ON_END;
        
    // Add either the band passed in, or the style's default band.
    if (pCurrentBand)
    {
        pBand = pCurrentBand;
        pBand->AddRef(); // Needed because we release the band before returning
    }
    else
    {
        hr = pStyle->GetDefaultBand(&pBand);
    }
    DMBandParam.mtTimePhysical = -64;
    DMBandParam.pBand = pBand;
    hr = pBandTrack->SetParam(GUID_BandParam, 0, (void*)&DMBandParam);
    if (!SUCCEEDED(hr)) goto ON_END;

    // Initialize the segment and insert the above tracks
    (*ppSectionSeg)->SetRepeats(0);
    (*ppSectionSeg)->SetLength(nClocks);
    (*ppSectionSeg)->InsertTrack(pBandTrack, 1);
    (*ppSectionSeg)->InsertTrack(pIStyleTrack, 1);
    (*ppSectionSeg)->InsertTrack(pIChordMapTrack, 1);
    (*ppSectionSeg)->InsertTrack(pICommandTrack, 1);
    if (pIMarkerTrack)
    {
        (*ppSectionSeg)->InsertTrack(pIMarkerTrack, 1);
    }
    if (pIChordTrack)
    {
        (*ppSectionSeg)->InsertTrack(pIChordTrack, 1);
    }
    // Add the graph
    if (pGraph)
    {
        (*ppSectionSeg)->SetGraph(pGraph);
    }
    // Add the Audio Path
    if (pPath)
    {
        IDirectMusicSegment8P* pSegP = NULL;
        if (SUCCEEDED((*ppSectionSeg)->QueryInterface(IID_IDirectMusicSegment8P, (void**)&pSegP)))
        {
            pSegP->SetAudioPathConfig(pPath);
            pSegP->Release();
        }
    }

ON_END:
    if (pIChordTrack) pIChordTrack->Release();
    if (pChordRIFF) pChordRIFF->Release();
    if (pIChordStream) pIChordStream->Release();
    if (pIChordTrackStream) pIChordTrackStream->Release();
    if (pICommandTrack) pICommandTrack->Release();
    if (pCommandRIFF) pCommandRIFF->Release();
    if (pICommandStream) pICommandStream->Release();
    if (pICommandTrackStream) pICommandTrackStream->Release();
    if (pDMTrack) pDMTrack->Release();
    if (pBandTrack) pBandTrack->Release();
    if (pIStyleTrack) pIStyleTrack->Release();
    if (pIMarkerTrack) pIMarkerTrack->Release();
    if (pMarkerRIFF) pMarkerRIFF->Release();
    if (pIMarkerStream) pIMarkerStream->Release();
    if (pIMarkerTrackStream) pIMarkerTrackStream->Release();
    if (pIChordMapTrack) pIChordMapTrack->Release();
    if (pBand) pBand->Release();
    return hr;
}

void ChangeCommand(DMUS_COMMAND_PARAM& rResult, DMUS_COMMAND_PARAM& rCommand, int nDirection)

{
    BYTE bGrooveLevel = 0;
    BYTE bRiff = 0;

    if (nDirection > 0)
    {
        while (nDirection > 0)
        {
            switch (rCommand.bGrooveLevel)
            {
                case 12 : bGrooveLevel = 37; break;
                case 37 : bGrooveLevel = 62; break;
                case 62 : bGrooveLevel = 87; break;
                case 87 : bGrooveLevel = 87; break;
                default: bGrooveLevel = rCommand.bGrooveLevel;
            }
            switch (rCommand.bCommand)
            {
                case DMUS_COMMANDT_FILL : bRiff = DMUS_COMMANDT_FILL; break;
                case DMUS_COMMANDT_BREAK : bRiff = DMUS_COMMANDT_FILL; break;
                default: bRiff = rCommand.bCommand;
            }
            rResult.bGrooveLevel = bGrooveLevel;
            rResult.bCommand = bRiff;
            nDirection--;
        }
    }
    else if (nDirection == 0)
    {
        rResult.bGrooveLevel = rCommand.bGrooveLevel;
        rResult.bCommand = rCommand.bCommand;
    }
    else if (nDirection < 0)
    {
        while (nDirection < 0)
        {
            switch (rCommand.bGrooveLevel)
            {
                case 12 : bGrooveLevel = 12; break;
                case 37 : bGrooveLevel = 12; break;
                case 62 : bGrooveLevel = 37; break;
                case 87 : bGrooveLevel = 62; break;
                default: bGrooveLevel = rCommand.bGrooveLevel;
            }
            switch (rCommand.bCommand)
            {
                case DMUS_COMMANDT_FILL : bRiff = DMUS_COMMANDT_BREAK; break;
                case DMUS_COMMANDT_BREAK : bRiff = DMUS_COMMANDT_BREAK; break;
                default: bRiff = rCommand.bCommand;
           }
            rResult.bGrooveLevel = bGrooveLevel;
            rResult.bCommand = bRiff;
            nDirection++;
        }
    }
}

static void InsertStuff(int nMeasure,
        TListItem<TemplateCommand> *pCommands,
        TListItem<PlayChord> *pPlayChord,
        TList<TemplateCommand> &rCommandList,
        TList<PlayChord> &rChordList,
        int nDirection)

{
    for(; pCommands; pCommands = pCommands->GetNext())
    {
        TemplateCommand& rCommand = pCommands->GetItemValue();
        TListItem<TemplateCommand> *pNew = new TListItem<TemplateCommand>;
        if (pNew)
        {
            TemplateCommand& rNew = pNew->GetItemValue();
            rNew.m_nMeasure = rCommand.m_nMeasure + (short)nMeasure;
            ChangeCommand(rNew.m_Command, rCommand.m_Command, nDirection);
            rNew.m_dwChord = rCommand.m_dwChord;
            rCommandList.AddHead(pNew);
        }
    }
    for (; pPlayChord; pPlayChord = pPlayChord->GetNext())
    {
        PlayChord& rChord = pPlayChord->GetItemValue();
        TListItem<PlayChord>* pNew = new TListItem<PlayChord>;
        if (pNew)
        {
            PlayChord& rNew = pNew->GetItemValue();
            rNew.m_fSilent = rChord.m_fSilent;
            rNew.m_pChord = rChord.m_pChord;
            rNew.m_pNext = rChord.m_pNext;
            rNew.m_dwFlags = rChord.m_dwFlags;
            rNew.m_nMeasure = rChord.m_nMeasure + (short)nMeasure;
            rNew.m_nBeat = rChord.m_nBeat;
            rNew.m_nMinbeats = rChord.m_nMinbeats;
            rNew.m_nMaxbeats = rChord.m_nMaxbeats;
            rChordList.AddHead(pNew);
        }
    }
}

void InsertCommand(int nMeasure, int nLength, TList<TemplateCommand> &rCommandList, BYTE bCommand)

{
    // insert nLength bars before nMeasure
    nMeasure -= nLength;
    TListItem<TemplateCommand> *pTarget = NULL;
    TListItem<TemplateCommand> *pCommand = rCommandList.GetHead();
    for (; pCommand; pCommand = pCommand->GetNext())
    {
        TemplateCommand& rCommand = pCommand->GetItemValue();
        if (rCommand.m_nMeasure == nMeasure)
        {
            pTarget = pCommand;
        }
        // return if another command would interupt this one
        else if ( (rCommand.m_Command.bCommand || rCommand.m_Command.bGrooveLevel) &&
                  (rCommand.m_nMeasure > nMeasure) && 
                  (rCommand.m_nMeasure < nMeasure + nLength) )
        {
            return;
        }
    }
    if (pTarget)
    {
        pTarget->GetItemValue().m_Command.bCommand = bCommand;
    }
    else
    {
        pCommand = new TListItem<TemplateCommand>;
        if (pCommand)
        {
            TemplateCommand& rCommand = pCommand->GetItemValue();
            rCommand.m_nMeasure = (short)nMeasure;
            rCommand.m_Command.bCommand = bCommand;
            rCommandList.AddHead(pCommand);
        }
    }
}

int WeightedRand(int nRange);

HRESULT CDMCompos::ComposePlayListFromShape(
                    long                    lNumMeasures,
                    WORD                    wShape,
                    BOOL                    fComposeIntro,
                    BOOL                    fComposeEnding,
                    int                     nIntroLength,
                    int                     nFillLength,
                    int                     nBreakLength,
                    int                     nEndLength,
                    IDirectMusicStyle*          pStyle, 
                    WORD                        wActivity,
                    IDirectMusicChordMap*   pPersonality,
                    TList<TemplateCommand>& CommandList,
                    TList<PlayChord>&       PlayList
                )
{
    HRESULT hr = S_OK;
    TListItem<TemplateCommand>* pCommand = NULL;

    int nOriginalMeasures = 0;
    if (fComposeIntro)
    {
        lNumMeasures -= nIntroLength;
        if (lNumMeasures < 1)
        {
            lNumMeasures = 1;
        }
    }
    if (fComposeEnding)
    {
        int nLength = nEndLength;
        nOriginalMeasures = (int)lNumMeasures;
        lNumMeasures -= (nLength - 1);
        if (lNumMeasures < 1)
        {
            lNumMeasures = 1;
        }
    }
    TemplateStruct Template;
    TemplateStruct* apTempl[8] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };
    if ((wShape != DMUS_SHAPET_SONG) || (lNumMeasures <= 24))
    {
        if (wShape == DMUS_SHAPET_LOOPABLE) lNumMeasures++;
        Template.m_nMeasures = (short)lNumMeasures;
        Template.CreateSignPosts();
        Template.CreateEmbellishments(wShape, nFillLength, nBreakLength);
        if (wShape == DMUS_SHAPET_LOOPABLE)
        {
            lNumMeasures--;
            Template.m_nMeasures = (short)lNumMeasures;
        }
        ComposePlayList(PlayList, pStyle, pPersonality, Template.m_CommandList, wActivity);
    }
    else
    {
        short nShortestLength = 12; // initialized to longest value in sanLengths
        TListItem<TemplateCommand> *apCommands[8];
        TList<PlayChord> aPlayList[8];
        TListItem<PlayChord>* apChords[8];
        int anLengths[8];
        int anGrooveLevel[8];
        int anPlayCount[8];
        BYTE abLeadins[8];
        int nTypeCount = 2;
        unsigned int nSize = (unsigned int) lNumMeasures >> 5;
        int nTypeIndex;
        int nMeasure;
        int nChoice, nLastChoice;
        while (nSize)
        {
            nTypeCount++;
            nSize = nSize >> 1;
            if (nTypeCount >= 8) break;
        }
        for (nTypeIndex = 1; nTypeIndex < nTypeCount; nTypeIndex++)
        {
            static WORD awShapes[8] = {
                DMUS_SHAPET_FALLING, DMUS_SHAPET_LEVEL, DMUS_SHAPET_LOUD, DMUS_SHAPET_QUIET,
                DMUS_SHAPET_RANDOM, DMUS_SHAPET_RANDOM, DMUS_SHAPET_RANDOM, DMUS_SHAPET_RANDOM };
            static int anInitGroovels[8] = { 0,-1,0,0,1,-1,2,-2 };
            static BYTE abRiffs[8] = {
                DMUS_COMMANDT_FILL, DMUS_COMMANDT_BREAK, DMUS_COMMANDT_FILL, DMUS_COMMANDT_BREAK,
                DMUS_COMMANDT_FILL, DMUS_COMMANDT_FILL, DMUS_COMMANDT_BREAK, DMUS_COMMANDT_FILL };
            static short sanLengths[10] = { 8,8,8,8,6,12,8,8,10,6 };
            short nLength = sanLengths[dm_rand() % 10];

            apTempl[nTypeIndex] = new TemplateStruct;
            if (!apTempl[nTypeIndex])
            {
                hr = E_OUTOFMEMORY;
                goto ON_END;
            }

            apTempl[nTypeIndex]->m_nMeasures = nLength;
            anLengths[nTypeIndex] = nLength;
            if (nLength)
            {
                if (nShortestLength > nLength) nShortestLength = nLength;
                apTempl[nTypeIndex]->CreateSignPosts();
                apTempl[nTypeIndex]->CreateEmbellishments(awShapes[nTypeIndex], nFillLength, nBreakLength);
                ComposePlayList(
                    aPlayList[nTypeIndex], pStyle, pPersonality, apTempl[nTypeIndex]->m_CommandList, wActivity);
                apCommands[nTypeIndex] = apTempl[nTypeIndex]->m_CommandList.GetHead();
                apChords[nTypeIndex] = aPlayList[nTypeIndex].GetHead();
                anPlayCount[nTypeIndex] = 0;
                anGrooveLevel[nTypeIndex] = anInitGroovels[nTypeIndex];
                if (dm_rand() % 4) abLeadins[nTypeIndex] = abRiffs[nTypeIndex];
                else abLeadins[nTypeIndex] = 0;
            }
            else
            {
                apCommands[nTypeIndex] = NULL;
            }
        }
        anPlayCount[0] = 1;
        anGrooveLevel[0] = 0;
        Template.m_nMeasures = (short)lNumMeasures;
        nMeasure = 0;
        nChoice = 1;
        nLastChoice = 0;
        for (; nMeasure < lNumMeasures; )
        {
            int nGroove;
            int nNewChoice;

            if ((lNumMeasures - nMeasure) <= nShortestLength)
            {
                nChoice = 0;
                short nLength = (short) (lNumMeasures - nMeasure);
                apTempl[0] = new TemplateStruct;
                if (!apTempl[0])
                {
                    hr = E_OUTOFMEMORY;
                    goto ON_END;
                }
                apTempl[0]->m_nMeasures = nLength;
                anLengths[0] = nLength;
                apTempl[0]->CreateSignPosts();
                apTempl[0]->CreateEmbellishments(DMUS_SHAPET_FALLING, nFillLength, nBreakLength);
                ComposePlayList(
                    aPlayList[0], pStyle, pPersonality, apTempl[0]->m_CommandList, wActivity);
                apCommands[0] = apTempl[0]->m_CommandList.GetHead();
                apChords[0] = aPlayList[0].GetHead();
                anPlayCount[0] = 0;
                anGrooveLevel[0] = 0;
                if (dm_rand() % 4) abLeadins[0] = DMUS_COMMANDT_FILL;
                else abLeadins[0] = 0;
            }
            nGroove = anGrooveLevel[nChoice];
            InsertStuff(nMeasure, apCommands[nChoice], apChords[nChoice],
                Template.m_CommandList, PlayList, nGroove);
            if ( (abLeadins[nChoice] == DMUS_COMMANDT_FILL && nMeasure >= nFillLength) )
            {
                InsertCommand(nMeasure, nFillLength, Template.m_CommandList, abLeadins[nChoice]);
            }
            else if ( (abLeadins[nChoice] == DMUS_COMMANDT_BREAK && nMeasure >= nBreakLength) )
            {
                InsertCommand(nMeasure, nBreakLength, Template.m_CommandList, abLeadins[nChoice]);
            }
            if (anGrooveLevel[nChoice] < 0) anGrooveLevel[nChoice]++;
            else
            {
                if (dm_rand() % 3)
                {
                    if (dm_rand() % 2)
                    {
                        anGrooveLevel[nChoice]++;
                    }
                    else
                    {
                        anGrooveLevel[nChoice]--;
                    }
                }
            }
            anPlayCount[nChoice]++;
            nMeasure += anLengths[nChoice];
            nNewChoice = WeightedRand(nTypeCount - 1) + 1;
            if ((nNewChoice == nChoice) && (nNewChoice == nLastChoice))
            {
                nNewChoice = WeightedRand(nTypeCount - 1) + 1;
            }
            if (nNewChoice == nChoice)
            {
                nNewChoice = WeightedRand(nTypeCount - 1) + 1;
            }
            // If there are enough measures for some but not all of the
            // patterns, find a pattern that fits
            if ((lNumMeasures - nMeasure) > nShortestLength)
            {
                while ((lNumMeasures - nMeasure) < anLengths[nNewChoice])
                {
                    nNewChoice = WeightedRand(nTypeCount - 1) + 1;
                }
            }
            nLastChoice = nChoice;
            nChoice = nNewChoice;
        }
        Template.m_CommandList.MergeSort(Less);
        PlayList.MergeSort(Less);
    }
    if (fComposeEnding)
    {
        int nLength = nEndLength;
        if (lNumMeasures != nOriginalMeasures)
        {
            Template.m_nMeasures = (short)nOriginalMeasures;
        }
        if (nLength > nOriginalMeasures)
        {
            nLength = nOriginalMeasures;
        }
        Template.AddEnd(nLength);
    }
    if (fComposeIntro)
    {
        Template.AddIntro(PlayList, nIntroLength);
    }
    pCommand = Template.m_CommandList.GetHead();
    for(; pCommand; pCommand = pCommand->GetNext())
    {
        TemplateCommand& rCommand = pCommand->GetItemValue();
        if (rCommand.m_Command.bCommand || rCommand.m_Command.bGrooveLevel)
        {
            TListItem<TemplateCommand>* pNew = new TListItem<TemplateCommand>;
            if (!pNew)
            {
                hr = E_OUTOFMEMORY;
                goto ON_END;
            }
            pNew->GetItemValue().m_nMeasure = rCommand.m_nMeasure; 
            pNew->GetItemValue().m_Command = rCommand.m_Command;
            pNew->GetItemValue().m_dwChord = rCommand.m_dwChord;
            CommandList.AddTail(pNew);
        }
    }

ON_END:
    for (short n = 0; n < 8; n++)
    {
        if (apTempl[n])
        {
            delete apTempl[n];
        }
    }
    return hr;
}

            
static short ChordMisses(DWORD dwScalePattern, DWORD dwChordPattern, char chRoot)

{
    short nErrors = 0;
    dwScalePattern &= 0xFFF;
    dwScalePattern |= (dwScalePattern << 12);
    while (chRoot < 0) chRoot += 12;
    while (chRoot > 11) chRoot -= 12;
    dwChordPattern = dwChordPattern << chRoot;
    for (short index = 0;index < 24;index++)
    {
        DWORD dwScaleBit = dwScalePattern & 1;
        DWORD dwChordBit = dwChordPattern & 1;
        dwScalePattern = dwScalePattern >> 1;
        dwChordPattern = dwChordPattern >> 1;
        if (dwChordBit && !dwScaleBit) nErrors++;
    }
    return(nErrors);
}

static short CompareSPToChord(DMSignPost& rSign,
                                DWORD dwLastScale, 
                                DMChordData& rNextChord, 
                                char chLastRoot)

{
    BYTE bLastRoot = chLastRoot % 12;
    short nResult = 50;
    if (rNextChord.Equals(rSign.m_ChordData))
    {
        nResult = 0;
    }
    else if (rSign.m_dwChords & DMUS_SIGNPOSTF_1)
    {
        nResult = 25;
    }

    if (rSign.m_dwFlags & DMUS_SPOSTCADENCEF_1)
    {
        DMChordData& rChord = rSign.m_aCadence[0];
        BYTE bOffset = rChord.GetRoot();
        if (bOffset < bLastRoot) bOffset += 12;
        nResult += ChordMisses(dwLastScale, rChord.GetChordPattern(), (bOffset - bLastRoot) % 12);
    }
    else if (rSign.m_dwFlags & DMUS_SPOSTCADENCEF_2)
    {
        DMChordData& rChord = rSign.m_aCadence[1];
        BYTE bOffset = rChord.GetRoot();
        if (bOffset < bLastRoot) bOffset += 12;
        nResult += ChordMisses(dwLastScale, rChord.GetChordPattern(), (bOffset - bLastRoot) % 12);
    }
    else nResult += 30;

    return (nResult);
}

static HRESULT ChordListFromSegment(TList<PlayChord>& ChordList, IDirectMusicSegment* pSeg,
                                 BYTE &bRoot, DWORD &dwScale)
{
    HRESULT             hr          = S_OK;
    IDirectMusicTrack*  pChordTrack = NULL;
    IPersistStream*     pPS         = NULL;
    IStream*            pStream     = NULL;

    // Get the segment's chord track.
    hr = pSeg->GetTrack(CLSID_DirectMusicChordTrack, ALL_TRACK_GROUPS, 0, &pChordTrack);
    if (S_OK != hr) goto ON_END;

    // Write the track to a stream, and read from the stream into a chord list.
    hr = CreateStreamOnHGlobal(NULL, TRUE, &pStream);
    if (S_OK != hr) goto ON_END;
    hr = pChordTrack->QueryInterface(IID_IPersistStream, (void**)&pPS);
    if (S_OK != hr) goto ON_END;    
    hr = pPS->Save(pStream, FALSE);
    if (S_OK != hr) goto ON_END;
    StreamSeek(pStream, 0, STREAM_SEEK_SET);
    LoadChordList(ChordList, pStream, bRoot, dwScale);

ON_END:
    if (pStream) pStream->Release();
    if (pChordTrack) pChordTrack->Release();
    if (pPS) pPS->Release();
    return hr;
}

static void Clear(TList<PlayChord>& ChordList)
{
    for (TListItem<PlayChord>* pChord = ChordList.GetHead(); pChord; pChord = pChord->GetNext())
    {
        pChord->GetItemValue().m_pChord->Release();
        delete pChord->GetItemValue().m_pChord;
    }
}

static char TwelveToScale(DWORD dwPattern, char chRoot, char *pchOffset)

{
    char i;
    *pchOffset = 0;
    char chResult = -1;
    while (chRoot < 0) chRoot += 12;
    while (chRoot >= 24) chRoot -= 12;
    for (i=0;i<24;i++)
    {
        if ((dwPattern >> i) & 1)
        {
            chResult++;
            *pchOffset = 0;
        }
        else
        {
            *pchOffset = (char)( *pchOffset + 1 );
        }
        if (i == chRoot)
        {
            return(chResult);
        }
    }
    return(0);
}

static char ScaleToTwelve(DWORD dwPattern, char chRoot, char chOffset)

{
    char i;
    char chResult = 0;
    while (chRoot < 0) chRoot += 7;
    while (chRoot >= 14) chRoot -= 7;
    for (i=0;i<24;i++)
    {
        if ((dwPattern >> i) & 1)
        {
            if (chResult == chRoot) break;
            chResult++;
        }
    }
    i = (char)( i + chOffset );
    while (i >= 24) i -= 12;    // RSW: fix for bug 173304
    return(i);
}

/*HRESULT CDMCompos::GetStyle(IDirectMusicSegment* pFromSeg, MUSIC_TIME mt, DWORD dwGroupBits, IDirectMusicStyle*& rpStyle, bool fTryPattern)
{
    HRESULT hr = S_OK;
    // Get the segment's style track.
    IDirectMusicTrack* pStyleTrack;
    hr = pFromSeg->GetTrack(CLSID_DirectMusicStyleTrack, dwGroupBits, 0, &pStyleTrack);
    if (S_OK != hr && fTryPattern)
    {
        hr = pFromSeg->GetTrack(CLSID_DirectMusicPatternTrack, dwGroupBits, 0, &pStyleTrack);
    }
    if (S_OK != hr) return hr;
    // Get the style from the style track
    hr = pStyleTrack->GetParam(GUID_IDirectMusicStyle, mt, NULL, (void*) &rpStyle);
    pStyleTrack->Release();
    return hr;
}*/

HRESULT CDMCompos::GetStyle(IDirectMusicSegment* pFromSeg, MUSIC_TIME mt, DWORD dwGroupBits, IDirectMusicStyle*& rpStyle, bool fTryPattern)
{
    HRESULT hr = pFromSeg->GetParam(GUID_IDirectMusicStyle, dwGroupBits, 0, mt, NULL, &rpStyle);
    if (S_OK != hr && fTryPattern)
    {
        hr = pFromSeg->GetParam(GUID_IDirectMusicPatternStyle, dwGroupBits, 0, mt, NULL, &rpStyle);
    }
    return hr;
}

HRESULT CDMCompos::GetPersonality(IDirectMusicSegment* pFromSeg, MUSIC_TIME mt, DWORD dwGroupBits, IDirectMusicChordMap*& rpPers)
{
    HRESULT hr = S_OK;
    // Get the segment's personality track.
    IDirectMusicTrack* pPersTrack;
    hr = pFromSeg->GetTrack(CLSID_DirectMusicChordMapTrack, dwGroupBits, 0, &pPersTrack);
    if (S_OK != hr) return hr;
    // Get the personality from the personality track
    hr = pPersTrack->GetParam(GUID_IDirectMusicChordMap, mt, NULL, (void*) &rpPers);
    pPersTrack->Release();
    return hr;
}

HRESULT GetTempo(IDirectMusicSegment* pFromSeg, MUSIC_TIME mt, double* pdblTempo)
{
    HRESULT hr = S_OK;
    // Get the segment's tempo track.
    IDirectMusicTrack* pTempoTrack;
    hr = pFromSeg->GetTrack(CLSID_DirectMusicTempoTrack, ALL_TRACK_GROUPS, 0, &pTempoTrack);
    if (S_OK != hr) return hr;
    // Get the tempo from the tempo track
    DMUS_TEMPO_PARAM Tempo;
    hr = pTempoTrack->GetParam(GUID_TempoParam, mt, NULL, (void*) &Tempo);
    pTempoTrack->Release();
    if (SUCCEEDED(hr))
    {
        *pdblTempo = Tempo.dblTempo;
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// IDirectMusicComposer

/* 
@method:(EXTERNAL) HRESULT | IDirectMusicComposer | ComposeSegmentFromTemplate | Creates an
original section segment from a style, ChordMap, and template.

@rdesc Returns:

@flag S_OK | Success
@flag E_POINTER | One or both of <p pTempSeg> and
<p ppSectionSeg> is an invalid pointer.
@flag E_INVALIDARG | Either <p pStyle> is NULL and there is no Style track, or <p pChordMap>
is NULL and there is no ChordMap track.

@comm If <p pStyle> is non-NULL, it is used in composing the segment; if it is NULL, 
a Style is retrieved from <p pTempSeg>'s Style track.
Similarly, if <p pChordMap> is non-NULL, it is used in composing the segment; if it is
NULL, a ChordMap is retrieved from <p pTempSeg>'s ChordMap track. 
The length of the section segment is equal to the length of the template section
passed in.
*/

/*
DX8 changes in track group bits, etc. (activated by dx8 content)
0. The signpost track is used to determine dwCompositionGroupBits.
1. Composed chords are placed in track groups dwCompositionGroupBits.
2. If a style is passed in, all style ref tracks in the composed segment are removed (as before).
   The new style is placed in the track group with the lowest value matching dwCompositionGroupBits.
   If a chord map is passed in, all chord map ref tracks in the composed segment are removed (as 
   before).  The new chord map is placed in track groups dwCompositionGroupBits.
3. If the Style is pulled from a StyleRef track, the StyleRef tracks are copied from the template
   segment.  Ditto for chord maps.  The StyleRef track used is the first one that matches
   dwCompositionGroupBits.  Ditto for chord maps.
4. The groove track used is the first one that matches dwCompositionGroupBits.
5. The time signature of the style chosen to compose with is the one used to determine chord
   placement.
6. If there are no tempo tracks in the template segment, one is created in track groups
   dwCompositionGroupBits and the style's tempo is set to play at time 0.
7. If there are no band tracks in the template segment, one is created in track groups
   dwCompositionGroupBits and the style's default band is set to play at physical time -64,
   logical time 0.
8. Loops are handled correctly.
NOTE: Leaving other Composition methods as they are (they put everything in track group 1).  It's
easy enough to change things programmatically, and since these segments are all created from scratch,
they don't rely on existing behavior in segments.
*/

HRESULT CDMCompos::ComposeSegmentFromTemplate(
                    IDirectMusicStyle*          pStyle, // @parm The style from which to create the section segment.
                    IDirectMusicSegment*        pTempSeg, // @parm The template from which to create the section segment.
                    WORD                        wActivity, // @parm Specifies the rate of harmonic motion; valid values are 0 through 3.
                    IDirectMusicChordMap*   pChordMap, // @parm The ChordMap from which to create the section segment.
                    IDirectMusicSegment**       ppSectionSeg // @parm Returns the created section segment.
            )
{
    return ComposeSegmentFromTemplateEx(
                pStyle,
                pTempSeg,
                (DMUS_COMPOSE_TEMPLATEF_ACTIVITY | DMUS_COMPOSE_TEMPLATEF_CLONE),
                wActivity,
                pChordMap,
                ppSectionSeg
        );

}

/////////////////////////////////////////////////////////////////////////////
// IDirectMusicComposer

/* 
@method:(EXTERNAL) HRESULT | IDirectMusicComposer | ComposeSegmentFromTemplate | Creates an
original section segment from a style, ChordMap, and template.

@rdesc Returns:

@flag S_OK | Success
@flag E_POINTER | One or both of <p pTempSeg> and
<p ppSectionSeg> is an invalid pointer.
@flag E_INVALIDARG | Either <p pStyle> is NULL and there is no Style track, or <p pChordMap>
is NULL and there is no ChordMap track.

@comm If <p pStyle> is non-NULL, it is used in composing the segment; if it is NULL, 
a Style is retrieved from <p pTempSeg>'s Style track.
Similarly, if <p pChordMap> is non-NULL, it is used in composing the segment; if it is
NULL, a ChordMap is retrieved from <p pTempSeg>'s ChordMap track. 
The length of the section segment is equal to the length of the template section
passed in.
*/

HRESULT CDMCompos::ComposeSegmentFromTemplateEx(
                    IDirectMusicStyle*      pStyle, // @parm The style from which to create the section segment.
                    IDirectMusicSegment*    pTempSeg, // @parm The template from which to create the section segment.
                    DWORD                   dwFlags, // @parm Various composition options.
                    DWORD                   dwActivity, // @parm Specifies the rate of harmonic motion; valid values are 0 through 3.
                    IDirectMusicChordMap*   pChordMap, // @parm The ChordMap from which to create the section segment.
                    IDirectMusicSegment**   ppSectionSeg // @parm Returns the created section segment.
            )
{
    V_INAME(IDirectMusicComposer::ComposeSegmentFromTemplateEx)
    V_PTR_WRITE_OPT(pStyle, 1);
    V_PTR_WRITE_OPT(pChordMap, 1);
    V_PTR_WRITE(pTempSeg, 1);
    V_PTRPTR_WRITE_OPT(ppSectionSeg);
    if ((dwFlags & DMUS_COMPOSE_TEMPLATEF_CLONE) && !ppSectionSeg)
    {
        Trace(1, "ERROR (ComposeSegmentFromTemplateEx): CLONE flag set but ppSectionSeg is NULL\n");
        return E_POINTER;
    }

    bool fUseActivity = (dwFlags & DMUS_COMPOSE_TEMPLATEF_ACTIVITY) ? true : false;
    bool fCloneSegment = (dwFlags & DMUS_COMPOSE_TEMPLATEF_CLONE) ? true : false;

    HRESULT hr = S_OK;
    DWORD dwGroupBitsRead = ALL_TRACK_GROUPS; // fallback to dx7 behavior
    DWORD dwGroupBitsWrite = 1; // fallback to dx7 behavior
    IDirectMusicTrack* pSignPostTrack = NULL;
    IDirectMusicTrack* pCommandTrack = NULL;
    IDirectMusicTrack* pChordMapTrack = NULL;

    ENTER_CRITICAL_SECTION( &m_CriticalSection );

    // Look for a style and chord map, just to determine DX8 content
    BOOL fStyleFromTrack = FALSE;
    BOOL fPersFromTrack = FALSE;
    if (!pStyle)
    {
        if (FAILED(GetStyle(pTempSeg, 0, ALL_TRACK_GROUPS, pStyle, true)))
        {
            Trace(1, "ERROR (ComposeSegmentFromTemplateEx): Failed to get a style.\n");
            hr = E_INVALIDARG;
        }
        else fStyleFromTrack = TRUE;
    }
    if (SUCCEEDED(hr) && !pChordMap)
    {
        if (FAILED(GetPersonality(pTempSeg, 0, ALL_TRACK_GROUPS, pChordMap)))
        {
            Trace(1, "ERROR (ComposeSegmentFromTemplateEx): Failed to get a chord map.\n");
            hr = E_INVALIDARG;
        }
        else fPersFromTrack = TRUE;
    }

    // Get track group bits from the signpost track
    if (SUCCEEDED(hr))
    {
        HRESULT hrTemp = pTempSeg->GetTrack(CLSID_DirectMusicSignPostTrack, ALL_TRACK_GROUPS, 0, &pSignPostTrack);
        if (hrTemp == S_OK && UsingDX8(pStyle, pChordMap))
        {
            hrTemp = pTempSeg->GetTrackGroup(pSignPostTrack, &dwGroupBitsWrite);
            if (hrTemp != S_OK) dwGroupBitsWrite = ALL_TRACK_GROUPS; // now read, write are both ALL
            else dwGroupBitsRead = dwGroupBitsWrite;
        }
        else if (UsingDX8(pStyle, pChordMap)) // no signpost track, DX8 content
        {
            dwGroupBitsWrite = ALL_TRACK_GROUPS; // now read, write are both ALL
        }
    }

    // Now that we know the group bits, get a style and chord map that match them.
    if (SUCCEEDED(hr) && fStyleFromTrack)
    {
        pStyle->Release();
        pStyle = NULL;
        if (FAILED(GetStyle(pTempSeg, 0, dwGroupBitsRead, pStyle, true)))
        {
            Trace(1, "ERROR (ComposeSegmentFromTemplateEx): Failed to get a style.\n");
            hr = E_INVALIDARG;
        }
    }
    if (SUCCEEDED(hr) && fPersFromTrack)
    {
        pChordMap->Release();
        pChordMap = NULL;
        if (FAILED(pTempSeg->GetTrack(CLSID_DirectMusicChordMapTrack, dwGroupBitsRead, 0, &pChordMapTrack)))
        {
            Trace(1, "ERROR (ComposeSegmentFromTemplateEx): Failed to get a chordmap.\n");
            hr = E_INVALIDARG;
        }
    }
    if (SUCCEEDED(hr))
    {
        if (FAILED(pTempSeg->GetTrack(CLSID_DirectMusicCommandTrack, dwGroupBitsRead, 0, &pCommandTrack)))
        {
            // If there is no command track, use a NULL command track for ExtractCommandList
            pCommandTrack = NULL;
        }
    }

    if (SUCCEEDED(hr))
    {
        MUSIC_TIME mtLength = 0;
        pTempSeg->GetLength(&mtLength);
        TList<PlayChord> PlayList;
        BYTE bRoot = 0;
        DWORD dwScale = 0;
        hr = ComposePlayListFromTemplate(
            pStyle, pChordMap, pChordMapTrack, pSignPostTrack, pCommandTrack, dwGroupBitsRead,
            mtLength, fUseActivity, dwActivity, PlayList, bRoot, dwScale);

        if (SUCCEEDED(hr))
        {
            // Build a section segment from the playlist and command list.
            if (fCloneSegment)
            {
                hr = CopySegment(pTempSeg, ppSectionSeg, PlayList, pStyle, pChordMap, fStyleFromTrack, fPersFromTrack, dwGroupBitsWrite, bRoot, dwScale);
            }
            else
            {
                hr = AddToSegment(pTempSeg, PlayList, pStyle, dwGroupBitsWrite, bRoot, dwScale);
            }
            if (!PlayList.GetHead() && UsingDX8(pStyle, pChordMap)) 
            {
                hr = S_FALSE; 
            }
        }
    }
    CleanUp();
    if (pSignPostTrack) pSignPostTrack->Release();
    if (pCommandTrack) pCommandTrack->Release();
    if (pChordMapTrack) pChordMapTrack->Release();
    if (fStyleFromTrack && pStyle) pStyle->Release();
    if (fPersFromTrack && pChordMap) pChordMap->Release();
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return hr;
}

HRESULT CDMCompos::ComposePlayListFromTemplate(IDirectMusicStyle* pStyle,
                                               IDirectMusicChordMap* pChordMap,
                                               IDirectMusicTrack* pChordMapTrack,
                                               IDirectMusicTrack* pSignPostTrack,
                                               IDirectMusicTrack* pCommandTrack,
                                               DWORD dwGroupBits,
                                               MUSIC_TIME mtLength,
                                               bool fUseActivity,
                                               DWORD dwActivity,
                                               TList<PlayChord>& rPlayList,
                                               BYTE& rbRoot,
                                               DWORD& rdwScale)
{
    HRESULT hr = S_OK;
    // Note: assumes time signature doesn't change.
    DMUS_TIMESIGNATURE TimeSig;
    pStyle->GetTimeSignature(&TimeSig);
    if (!TimeSig.bBeatsPerMeasure) TimeSig.bBeatsPerMeasure = 4;
    if (!TimeSig.bBeat) TimeSig.bBeat = 4;
    // tics  per bar
    MUSIC_TIME mtBar = ( DMUS_PPQ * 4 * TimeSig.bBeatsPerMeasure ) / TimeSig.bBeat;
    // To find the beat to place a second chord in a measure, divide by 2 and round up
    int nSecondBeat = TimeSig.bBeatsPerMeasure / 2;
    if (nSecondBeat * 2 != TimeSig.bBeatsPerMeasure) nSecondBeat++;
    // Get the command list from the template segment.
    TList<TemplateCommand> CommandList;
    ExtractCommandList(CommandList, pSignPostTrack, pCommandTrack, dwGroupBits);
    // For each chordmap in the chordmap track, compose a playlist from only the commands
    // in the range of the chordmap
    MUSIC_TIME mtNow = 0;
    MUSIC_TIME mtNext = 0;
    HRESULT hrChordMap = S_OK;
    IDirectMusicChordMap* pLastChordMap = NULL;
    while (SUCCEEDED(hrChordMap) && SUCCEEDED(hr) && mtNext < mtLength)
    {
        bool fChordMapPassedIn = false;
        if (!pChordMap)
        {
            if (pChordMapTrack)
            {
                hrChordMap = pChordMapTrack->GetParam(GUID_IDirectMusicChordMap, mtNow, &mtNext, (void*) &pChordMap);
                if (!mtNext) mtNext = mtLength;
                else mtNext += mtNow;
            }
            else
            {
                Trace(1, "ERROR: No chord map track to use for chord composition.\n");
                hr = hrChordMap = E_POINTER;
            }
        }
        else // a chordmap got passed in; make sure it's the only one we use
        {
            mtNext = mtLength;
            fChordMapPassedIn = true;
        }
        if (SUCCEEDED(hrChordMap))
        {
            if (!mtNow)
            {
                pChordMap->GetScale(&rdwScale);
                rbRoot = (BYTE) (rdwScale >> 24);
                rdwScale &= 0xffffff;
            }
            // get the commands in the range of this chordmap.
            TList<TemplateCommand> CurrentCommandList;
            TListItem<TemplateCommand>* pScan = CommandList.GetHead();
            for (; pScan; pScan = pScan->GetNext())
            {
                TemplateCommand& rScan = pScan->GetItemValue();
                MUSIC_TIME mtScanBar = rScan.m_nMeasure * mtBar;
                if ( mtScanBar >= mtNow && mtScanBar < mtNext )
                {
                    TListItem<TemplateCommand>* pNew = new  TListItem<TemplateCommand>;
                    if (pNew)
                    {
                        pNew->GetItemValue() = rScan;
                        CurrentCommandList.AddTail(pNew);
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
            if (SUCCEEDED(hr))
            {
                // Compose a playlist for this chordmap.
                TList<PlayChord> CurrentPlayList; // playlist for this chordmap.
                if (fUseActivity)
                {
                    ComposePlayList(CurrentPlayList, pStyle, pChordMap, CurrentCommandList, (WORD)dwActivity);
                }
                else
                {
                    ComposePlayList2(CurrentPlayList, pStyle, pChordMap, CurrentCommandList);
                }
                // if we're past the first bar, compose a cadence to the first chord
                // of the current playlist via a call to ChooseSignPost (using the last
                // chordmap) and add it to the current playlist.  
                int nCurrentBar = mtNow / mtBar;
                if (rPlayList.GetHead() && nCurrentBar &&  pLastChordMap)
                {
                    DWORD dwScale = 0;
                    pLastChordMap->GetScale(&dwScale);
                    BYTE bRoot = (BYTE) (dwScale >> 24);
                    dwScale &= 0xffffff;
                    int nBar = nCurrentBar - 1;
                    bool fCadence1 = false;
                    bool fCadence2 = false;
                    TListItem<DMSignPost> *pSignChoice = NULL;
                    if (CurrentPlayList.GetHead())
                    {
                        DMChordData* pFirstChord = CurrentPlayList.GetHead()->GetItemValue().m_pChord;
                        pSignChoice = ChooseSignPost(pChordMap, pFirstChord, false, dwScale, bRoot);
                    }
                    else
                    {
                        pSignChoice = ChooseSignPost(pChordMap, NULL, true, dwScale, bRoot);
                    }
                    if (pSignChoice)
                    {
                        DMSignPost& rSignChoice = pSignChoice->GetItemValue();
                        fCadence1 = (rSignChoice.m_dwFlags & DMUS_SPOSTCADENCEF_1) ? true : false;
                        fCadence2 = (rSignChoice.m_dwFlags & DMUS_SPOSTCADENCEF_2) ? true : false;
                        if (fCadence1)
                        {
                            AddChord( CurrentPlayList, &rSignChoice.m_aCadence[0], nBar, 0 );
                        }
                        if (fCadence2)
                        {
                            int nBeat = fCadence1 ? nSecondBeat : 0;
                            AddChord( CurrentPlayList, &rSignChoice.m_aCadence[1], nBar, nBeat );
                        }
                    }
                }
                // Add the current playlist to the end of the master playlist.
                rPlayList.AddTail(CurrentPlayList.GetHead());
                CurrentPlayList.RemoveAll();
            }
            // clear out the chord map for the next iteration
            if (pLastChordMap) pLastChordMap->Release();
            pLastChordMap = pChordMap;
            if (pLastChordMap) pLastChordMap->AddRef();
            if (!fChordMapPassedIn) pChordMap->Release();
            pChordMap = NULL;
        }
        mtNow = mtNext;
    }
    if (pLastChordMap) pLastChordMap->Release();
    return hr;
}
    
    
/* 
@method:(EXTERNAL) HRESULT | IDirectMusicComposer | ComposeSegmentFromShape |  Creates
an original section segment from a style and ChordMap based on a predefined shape.

@rdesc Returns:

@flag S_OK | Success
@flag E_POINTER | One or more of <p pStyle>, <p pChordMap>, and <p ppSectionSeg>
is an invalid pointer.

@comm Creates an original section segment from a style and a ChordMap based on a
predefined shape.  Shapes (passed in <p wShape>) represent the way chords and embellishments
occur over time across the section.  There are nine shapes:

  @flag DMUS_SHAPET_FALLING | The section gets quieter over time.
  @flag DMUS_SHAPET_LEVEL   | The section remains at the same level.
  @flag DMUS_SHAPET_LOOPABLE | The section is arranged to loop back to its beginning.
  @flag DMUS_SHAPET_LOUD    | The section remains loud.
  @flag DMUS_SHAPET_QUIET   | The section remains quiet.
  @flag DMUS_SHAPET_PEAKING | The section peaks.
  @flag DMUS_SHAPET_RANDOM | The section is random.
  @flag DMUS_SHAPET_RISING | The section builds over time.
  @flag DMUS_SHAPET_SONG | The section is in a song form.

*/

HRESULT CDMCompos::ComposeSegmentFromShape(
                    IDirectMusicStyle*          pStyle, // @parm The style from which to compose the section segment.
                    WORD                        wNumMeasures, // @parm The length, in measures, to compose the section segment.
                    WORD                        wShape, // @parm The shape to compose the section segment.
                    WORD                        wActivity, // @parm Specifies the rate of harmonic motion; valid values are 0 through 3.
                    BOOL                        fComposeIntro, // @parm TRUE if an intro is to be composed for the section segment.
                    BOOL                        fComposeEnding, // @parm TRUE if an ending is to be composed for the section segment.
                    IDirectMusicChordMap*   pChordMap, // @parm The ChordMap from which to create the section segment.
                    IDirectMusicSegment**       ppSectionSeg // @parm Returns the created section segment.
            )
{
    V_INAME(IDirectMusicComposer::ComposeSegmentFromShape)
    V_PTR_WRITE(pStyle, 1);
    V_PTR_WRITE(pChordMap, 1);
    V_PTRPTR_WRITE(ppSectionSeg);

    ENTER_CRITICAL_SECTION( &m_CriticalSection );

    int nIntroLength = 1;
    int nFillLength = 1;
    int nBreakLength = 1;
    int nEndLength = 1;

    // Get the maximum ending length from the style.
    DWORD dwMin, dwMax;
    HRESULT hr = pStyle->GetEmbellishmentLength(DMUS_COMMANDT_END, 0, &dwMin, &dwMax);
    if (FAILED(hr)) // remain consistent with old behavior and fail.
    {
        LEAVE_CRITICAL_SECTION( &m_CriticalSection );
        return hr;
    }
    if (hr == S_OK) nEndLength = (int) dwMax;
    if ( UsingDX8(pStyle) )
    {
        hr = pStyle->GetEmbellishmentLength(DMUS_COMMANDT_INTRO, 0, &dwMin, &dwMax);
        if (hr == S_OK) nIntroLength = (int) dwMax;
        hr = pStyle->GetEmbellishmentLength(DMUS_COMMANDT_FILL, 0, &dwMin, &dwMax);
        if (hr == S_OK) nFillLength = (int) dwMax;
        hr = pStyle->GetEmbellishmentLength(DMUS_COMMANDT_BREAK, 0, &dwMin, &dwMax);
        if (hr == S_OK) nBreakLength = (int) dwMax;
    }

    if (wNumMeasures & 0x8000 || wNumMeasures == 0)  wNumMeasures = 1;
    int nNumMeasures = wNumMeasures;
    if (wShape != DMUS_SHAPET_FALLING &&
        wShape != DMUS_SHAPET_LEVEL &&
        wShape != DMUS_SHAPET_LOOPABLE &&
        wShape != DMUS_SHAPET_LOUD &&
        wShape != DMUS_SHAPET_QUIET &&
        wShape != DMUS_SHAPET_PEAKING &&
        wShape != DMUS_SHAPET_RANDOM &&
        wShape != DMUS_SHAPET_RISING &&
        wShape != DMUS_SHAPET_SONG)
    {
        wShape = DMUS_SHAPET_RANDOM;
    }

    if (fComposeIntro)
    {
        if (nIntroLength <= 0) nIntroLength = 1;
        if ( nIntroLength >= nNumMeasures ) 
        {
            nNumMeasures = nIntroLength;
        }
    }
    if (fComposeEnding)
    {
        if (nEndLength <= 0) nEndLength = 1;
        if ( nEndLength >= nNumMeasures ) 
        {
            nNumMeasures = nEndLength;
            if (fComposeIntro) nNumMeasures += nIntroLength;
        }
    }

    // Compose playlists for sections of the segment.
    TList<TemplateCommand> CommandList;
    TList<PlayChord> PlayList;
    hr = ComposePlayListFromShape(
        nNumMeasures, wShape, fComposeIntro, fComposeEnding, 
        nIntroLength, nFillLength, nBreakLength, nEndLength, pStyle, wActivity, 
        pChordMap, CommandList, PlayList);
    if (SUCCEEDED(hr))
    {
        // Build a segment from the resulting command lists and playlists.
        BYTE bRoot = 0;
        DWORD dwScale;
        pChordMap->GetScale(&dwScale);
        bRoot = (BYTE) (dwScale >> 24);
        dwScale &= 0xffffff;
        hr = BuildSegment(CommandList, PlayList, pStyle, pChordMap, nNumMeasures, ppSectionSeg, bRoot, dwScale);
        CleanUp();
    }
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return hr;
}

HRESULT GetCommandList(IDirectMusicSegment* pFromSeg, TList<TemplateCommand>& CommandList)
{
    HRESULT hr = S_OK;
    IDirectMusicTrack* pCommandTrack;
    hr = pFromSeg->GetTrack(CLSID_DirectMusicCommandTrack, ALL_TRACK_GROUPS, 0, &pCommandTrack);
    if (S_OK != hr) return hr;
    // Write the track to a stream, and read from the stream into a command list.
    IPersistStream* pPS;
    IStream *pStream;
    hr = CreateStreamOnHGlobal(NULL, TRUE, &pStream);
    if (S_OK == hr)
    {
        hr = pCommandTrack->QueryInterface(IID_IPersistStream, (void**)&pPS);
        if (S_OK == hr)
        {
            hr = pPS->Save(pStream, FALSE);
            if (S_OK == hr)
            {
                StreamSeek(pStream, 0, STREAM_SEEK_SET);
                LoadCommandList(CommandList, pStream);
            }
            pPS->Release();
        }
        pStream->Release();
    }
    pCommandTrack->Release();
    return hr;
}

// New flags: 
// DMUS_COMPOSEF_ENTIRE_TRANSITION: play the transition pattern in its entirety.
// DMUS_COMPOSEF_1BAR_TRANSITION: play one bar of the the transition pattern.
// the following two are ignored unless DMUS_COMPOSEF_LONG is set:
// DMUS_COMPOSEF_ENTIRE_ADDITION: play the additional pattern in its entirety.
// DMUS_COMPOSEF_1BAR_ADDITION: play one bar of the additional pattern.
// Default behavior will be the same as dx7:
// DMUS_COMPOSEF_1BAR_TRANSITION unless pattern is an ending
// DMUS_COMPOSEF_1BAR_ADDITION always

// Used by both ComposeTransition and AutoTransition
// Used by both ComposeTransition and AutoTransition
HRESULT CDMCompos::TransitionCommon(
    IDirectMusicStyle*      pFromStyle,
    IDirectMusicBand*       pCurrentBand,
    double*                 pdblFromTempo,
    DMUS_COMMAND_PARAM_2&   rFromCommand,
    DMUS_CHORD_PARAM&       rLastChord,
    DMUS_CHORD_PARAM&       rNextChord,

    IDirectMusicSegment*    pToSeg,
    WORD                    wCommand,
    DWORD                   dwFlags,
    IDirectMusicChordMap*   pChordMap,
    IDirectMusicGraph*      pFromGraph,
    IDirectMusicGraph*      pToGraph,
    IUnknown*               pFromPath,
    IUnknown*               pToPath,
    IDirectMusicSegment**   ppSectionSeg
            )
{
    IDirectMusicGraph* pGraph = NULL;
    IUnknown* pPath = NULL;
    BYTE bRoot = rLastChord.bKey;
    DWORD dwScale = rLastChord.dwScale;
    DMChordData LastChord = rLastChord;
    DMChordData NextChord = rNextChord;
    HRESULT hr = S_OK;

    bool fLong = (dwFlags & DMUS_COMPOSEF_LONG) ? true : false;
    bool fModulate = (dwFlags & DMUS_COMPOSEF_MODULATE) ? true : false;
    bool fEnding = wCommand == DMUS_COMMANDT_END  || wCommand == DMUS_COMMANDT_ENDANDINTRO;
    bool fHasIntro = wCommand == DMUS_COMMANDT_INTRO || wCommand == DMUS_COMMANDT_ENDANDINTRO;
    bool fEntireTransition = false;
    if ((dwFlags & DMUS_COMPOSEF_ENTIRE_TRANSITION) || 
        (fEnding && !(dwFlags & DMUS_COMPOSEF_1BAR_TRANSITION)))
    {
        fEntireTransition = true;
    }
    bool fEntireAddition = (dwFlags & DMUS_COMPOSEF_ENTIRE_ADDITION) ? true : false;
    bool fAlign = (dwFlags & DMUS_COMPOSEF_ALIGN) ? true : false;
    
    // Get the ending segment's style
    IDirectMusicStyle* pToStyle = NULL;
    if (pToSeg)
    {
        hr = GetStyle(pToSeg, 0, ALL_TRACK_GROUPS, pToStyle, false);
        if (FAILED(hr)) pToStyle = NULL;
    }
    if (!pToStyle && !pFromStyle) // Not much to do...
    {
        *ppSectionSeg = NULL;
        return S_OK;
    }

    // Get tempo from the end segment.  This will be passed into BuildSegment.
    double dblFromTempo = 120.0;
    double dblToTempo = 120.0;
    double* pdblToTempo = &dblToTempo;
    if (pdblFromTempo)
    {
        dblFromTempo = *pdblFromTempo;
    }
    // If there is no To tempo, set it to the From tempo (or keep it at the fallback).
    if (!pToSeg || FAILED(GetTempo(pToSeg, 0, &dblToTempo)))
    {
        if (pdblFromTempo) dblToTempo = dblFromTempo; // otherwise use fallback of 120
    }
    // If there is no From tempo, set it to the To tempo.
    if (!pdblFromTempo)
    {
        dblFromTempo = dblToTempo;
        pdblFromTempo = &dblFromTempo;
    }

    ENTER_CRITICAL_SECTION( &m_CriticalSection );

    // Extract the starting style's time signature.
    DMUS_TIMESIGNATURE FromTimeSig;
    if (pFromStyle)
    {
        pFromStyle->GetTimeSignature(&FromTimeSig);
    }
    else
    {
        FromTimeSig.bBeat = 4;
        FromTimeSig.bBeatsPerMeasure = 4;
        FromTimeSig.wGridsPerBeat = 4;
        FromTimeSig.mtTime = 0;
    }
    // Extract the ending style's time signature.
    DMUS_TIMESIGNATURE ToTimeSig;
    if (pToStyle)
    {
        pToStyle->GetTimeSignature(&ToTimeSig);
    }
    else
    {
        ToTimeSig.bBeat = 4;
        ToTimeSig.bBeatsPerMeasure = 4;
        ToTimeSig.wGridsPerBeat = 4;
        ToTimeSig.mtTime = 0;
    }
    if (!ToTimeSig.bBeatsPerMeasure) ToTimeSig.bBeatsPerMeasure = 4;
    // To find the beat to place a second chord in a measure, divide by 2 and round up
    int nSecondBeat = ToTimeSig.bBeatsPerMeasure / 2;
    if (nSecondBeat * 2 != ToTimeSig.bBeatsPerMeasure) nSecondBeat++;
    MUSIC_TIME mtIntro = 0;
    TList<PlayChord> PlayList;
    TListItem<TemplateCommand> *pCommand = new TListItem<TemplateCommand>;
    if (!pCommand)
    {
        LEAVE_CRITICAL_SECTION( &m_CriticalSection );
        return E_OUTOFMEMORY;
    }
    TListItem<TemplateCommand> *pLast = pCommand;
    // Intros get their chords when adding commands
    if (wCommand != DMUS_COMMANDT_INTRO) 
    {
        if ( fModulate )
        {
            bool fCadence1 = false;
            bool fCadence2 = false;
            TListItem<DMSignPost> *pSignChoice = ChooseSignPost(pChordMap, &NextChord, fEnding, dwScale, bRoot);
            if (pSignChoice)
            {
                fCadence1 = (pSignChoice->GetItemValue().m_dwFlags & DMUS_SPOSTCADENCEF_1) ? true : false;
                fCadence2 = (pSignChoice->GetItemValue().m_dwFlags & DMUS_SPOSTCADENCEF_2) ? true : false;
            }
            if (fCadence1 || fCadence2)
            {
                if ( fCadence1 && (fLong || !fEnding || !fCadence2) )
                {
                    AddChord( PlayList, &pSignChoice->GetItemValue().m_aCadence[0], 0, 0 );
                }
                else
                {
                    AddChord( PlayList, &pSignChoice->GetItemValue().m_aCadence[1], 0, 0 );
                }
                if (fCadence1 && fCadence2)
                {
                    if (fLong == fEnding)
                    {
                        AddChord( PlayList, &pSignChoice->GetItemValue().m_aCadence[1], 0, nSecondBeat );
                    }
                    if (fLong && !fEnding)
                    {
                        AddChord( PlayList, &pSignChoice->GetItemValue().m_aCadence[1], 1, 0 );
                    }
                }
                if ( fEnding )
                {
                    if (fLong)
                    {
                        AddChord( PlayList, &pSignChoice->GetItemValue().m_ChordData, 1, 0 );
                    }
                    else
                    {
                        AddChord( PlayList, &pSignChoice->GetItemValue().m_ChordData, 0, nSecondBeat );
                    }
                }
            }
            else
            {
                AddChord( PlayList, &LastChord, 0 , 0 );
            }
        }
        else
        {
            AddChord( PlayList, &LastChord, 0 , 0 );
        }
    }
    int nLength = 0;
    int nPreIntro = 0;
    if (pCommand)
    {
        DWORD dwMax = 1;
        DWORD dwMin;
        TemplateCommand& rCommand = pCommand->GetItemValue();
        rCommand.m_Command.bCommand = rFromCommand.bCommand;
        rCommand.m_Command.bGrooveLevel = rFromCommand.bGrooveLevel;
        rCommand.m_Command.bGrooveRange = rFromCommand.bGrooveRange;
        rCommand.m_Command.bRepeatMode = rFromCommand.bRepeatMode;
        rCommand.m_nMeasure = 0;
        if (pFromStyle)
        {
            if (wCommand != DMUS_COMMANDT_INTRO)
            {
                WORD wTempCommand = wCommand;
                if ( wCommand == DMUS_COMMANDT_END || wCommand == DMUS_COMMANDT_ENDANDINTRO )
                {
                    wTempCommand = DMUS_COMMANDT_END;
                }
                if (fEntireTransition)
                {
                    HRESULT hr = pFromStyle->GetEmbellishmentLength(wTempCommand, rFromCommand.bGrooveLevel, &dwMin, &dwMax);
                    if (hr != S_OK) dwMax = 1;
                    nLength = dwMax;
                }
                else
                {
                    nLength = 1;
                }
            }
            if ( fLong )
            {
                if (fEntireAddition)
                {
                    HRESULT hr = pFromStyle->GetEmbellishmentLength(DMUS_COMMANDT_GROOVE, rFromCommand.bGrooveLevel, &dwMin, &dwMax);
                    if (hr != S_OK) dwMax = 1;
                }
                else
                {
                    dwMax = 1;
                }
                nLength += dwMax;
                if (wCommand == DMUS_COMMANDT_GROOVE && UsingDX8(pFromStyle)) // Just have one long groove.
                {
                    rCommand.m_Command.bCommand = DMUS_COMMANDT_GROOVE;
                }
                else if (wCommand != DMUS_COMMANDT_INTRO)
                {
                    TListItem<TemplateCommand> *pSecond = new TListItem<TemplateCommand>;
                    if (pSecond)
                    {
                        TemplateCommand& rSecond = pSecond->GetItemValue();
                        rSecond.m_nMeasure = (short) dwMax;
                        if (wCommand == DMUS_COMMANDT_ENDANDINTRO)
                        {
                            rSecond.m_Command.bCommand = DMUS_COMMANDT_END;
                        }
                        else
                        {
                            rSecond.m_Command.bCommand = (BYTE)wCommand;
                        }
                        rSecond.m_Command.bGrooveLevel = 0;
                        rSecond.m_Command.bGrooveRange = 0;
                        rSecond.m_Command.bRepeatMode = DMUS_PATTERNT_RANDOM;
                        pLast->SetNext(pSecond);
                        pLast = pSecond;
                    }
                }
            }
            else if (wCommand != DMUS_COMMANDT_INTRO)
            {
                if (wCommand == DMUS_COMMANDT_ENDANDINTRO)
                {
                    rCommand.m_Command.bCommand = DMUS_COMMANDT_END;
                }
                else
                {
                    rCommand.m_Command.bCommand = (BYTE)wCommand;
                }
            }
        }
        if ( pToStyle && fHasIntro)
        {
            nPreIntro = nLength;
            if (fEntireTransition)
            {
                // Check that this is the correct thing to do if pFromStyle is NULL.
                HRESULT hr = pToStyle->GetEmbellishmentLength(DMUS_COMMANDT_INTRO, rFromCommand.bGrooveLevel, &dwMin, &dwMax);
                if (hr != S_OK) dwMax = 1;
                nLength += dwMax;
            }
            else
            {
                nLength++;
            }
            AddChord( PlayList, &NextChord, nPreIntro , 0 );
            if ( nPreIntro > 0 )
            {
                if (wCommand == DMUS_COMMANDT_INTRO) AddChord( PlayList, &LastChord, 0 , 0 );
                TListItem<TemplateCommand> *pSecond = new TListItem<TemplateCommand>;
                if (pSecond)
                {
                    TemplateCommand& rSecond = pSecond->GetItemValue();
                    rSecond.m_nMeasure = (short)nPreIntro;
                    rSecond.m_Command.bCommand = DMUS_COMMANDT_INTRO;
                    rSecond.m_Command.bGrooveLevel = 0;
                    rSecond.m_Command.bGrooveRange = 0;
                    rSecond.m_Command.bRepeatMode = DMUS_PATTERNT_RANDOM;
                    pLast->SetNext(pSecond);
                }
            }
            else
            {
                rCommand.m_Command.bCommand = DMUS_COMMANDT_INTRO;
            }
        }
    }
    TList<TemplateCommand> CommandList2;
    CommandList2.Cat(pCommand);
    *ppSectionSeg = NULL;
    if (fHasIntro && !fEnding && UsingDX8(pToStyle))
    {
        pGraph = pToGraph;
        pPath = pToPath;
    }
    else if (UsingDX8(pFromStyle))
    {
        pGraph = pFromGraph;
        pPath = pFromPath;
    }
    if (fHasIntro)
    {
        if (pFromStyle)
        {
            hr = BuildSegment(CommandList2, PlayList, pFromStyle, pChordMap, nLength, ppSectionSeg, bRoot, dwScale, pdblFromTempo, pCurrentBand, fAlign, pGraph, pPath);
            if (SUCCEEDED(hr) && pToStyle)
            {
                mtIntro = ClocksPerMeasure(FromTimeSig) * nPreIntro;
                IDirectMusicTrack* pStyleTrack;
                hr = (*ppSectionSeg)->GetTrack(CLSID_DirectMusicStyleTrack, ALL_TRACK_GROUPS, 0, &pStyleTrack);
                if (SUCCEEDED(hr))
                {
                    pStyleTrack->SetParam(GUID_IDirectMusicStyle, mtIntro, (void*) pToStyle);
                    pStyleTrack->Release();
                }
                IDirectMusicTrack* pTempoTrack;
                hr = (*ppSectionSeg)->GetTrack(CLSID_DirectMusicTempoTrack, ALL_TRACK_GROUPS, 0, &pTempoTrack);
                if (SUCCEEDED(hr))
                {
                    DMUS_TEMPO_PARAM tempo;
                    tempo.mtTime = mtIntro;
                    tempo.dblTempo = dblToTempo;
                    pTempoTrack->SetParam(GUID_TempoParam, mtIntro, (void*) &tempo);
                    pTempoTrack->Release();
                }
                // I also need to add a band (from the To segment) to the band track at the appropriate time...
                if ( UsingDX8(pToStyle) )
                {
                    if (mtIntro == 0) // Intro is the first thing to play; don't need any other bands
                    {
                        (*ppSectionSeg)->SetParam(GUID_Clear_All_Bands, ALL_TRACK_GROUPS, 0, 0, NULL);
                    }
                    DMUS_BAND_PARAM DMBand;
                    if (pToSeg && SUCCEEDED(pToSeg->GetParam(GUID_BandParam, ALL_TRACK_GROUPS, DMUS_SEG_ANYTRACK, 0, NULL, (void*)&DMBand)))
                    {
                        DMBand.mtTimePhysical = mtIntro;
                        (*ppSectionSeg)->SetParam(GUID_BandParam, ALL_TRACK_GROUPS, 0, mtIntro, (void*)&DMBand);
                        DMBand.pBand->Release();
                    }
                }
                // readjust the length to account for differences in the two styles's time signatures
                if ( nLength > nPreIntro && (UsingDX8(pFromStyle) || UsingDX8(pToStyle)) )
                {
                    MUSIC_TIME mtNewLength = mtIntro + ((nLength - nPreIntro) * ClocksPerMeasure(ToTimeSig));
                    (*ppSectionSeg)->SetLength(mtNewLength);
                }
            }
        }
        else if (pToStyle)
        {
            hr = BuildSegment(CommandList2, PlayList, pToStyle, pChordMap, nLength, ppSectionSeg, bRoot, dwScale, pdblToTempo, pCurrentBand, fAlign, pGraph, pPath);
        }
    }
    else if (pFromStyle)
    {
        hr = BuildSegment(CommandList2, PlayList, pFromStyle, pChordMap, nLength, ppSectionSeg, bRoot, dwScale, pdblFromTempo, pCurrentBand, fAlign, pGraph, pPath);
    }
    else
    {
        hr = S_OK; // don't build anything, but return OK
    }
    CommandList2.RemoveAll();
    TListItem<TemplateCommand>::Delete(pCommand);
    if (pToStyle) pToStyle->Release();
    CleanUp();
    NextChord.Release();
    LastChord.Release();
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return hr;
}

TListItem<DMSignPost>* CDMCompos::ChooseSignPost(
            IDirectMusicChordMap* pChordMap,
            DMChordData* pNextChord,
            bool fEnding,
            DWORD dwScale,
            BYTE bRoot)
{
    if (!fEnding && !pNextChord) return NULL;
    DMPersonalityStruct* pPers = NULL;
    if (pChordMap)
    {
        IDMPers* pDMP;
        if (FAILED(pChordMap->QueryInterface(IID_IDMPers, (void**)&pDMP))) return NULL;
        pDMP->GetPersonalityStruct((void**)&pPers);
        pDMP->Release();
    }
    if (!pPers) return NULL;

    TList<DMSignPost> &SignPostList = pPers->m_SignPostList;
    TListItem<DMSignPost> *pSign = SignPostList.GetHead();
    TListItem<DMSignPost> *pSignChoice = pSign;
    int nMin = 100;
    int nHit = 100;
    int nMatches = 0;
    if (fEnding)
    {
        for (;pSign; pSign = pSign->GetNext())
        {   
            if ( (pSign->GetItemValue().m_dwChords & DMUS_SIGNPOSTF_1) )
            {
                pSignChoice = pSign;
                nMatches = 0;
                for (; pSign; pSign = pSign->GetNext()) 
                {
                    if (pSign->GetItemValue().m_dwChords & DMUS_SIGNPOSTF_1) nMatches++;
                }
                break;
            }
        }
    }
    else
    {
        DMChordData& rNextChord = *pNextChord;
        for (;pSign; pSign = pSign->GetNext())
        {   
            nHit = CompareSPToChord(pSign->GetItemValue(), dwScale, rNextChord, (char) bRoot);
            if (nHit == nMin) nMatches++; 
            else if (nHit < nMin)
            {
                nMin = nHit;
                pSignChoice = pSign;
                nMatches = 1;
            }
        }
    }
    // Pick a winning signpost at random
    pSign = pSignChoice;
    if (nMatches) nMatches = dm_rand() % nMatches;
    for (int i = 0; i <= nMatches && pSign; pSign = pSign->GetNext())
    {
        if (fEnding)
        {
            if (pSign->GetItemValue().m_dwChords & DMUS_SIGNPOSTF_1)
            {
                i++;
                pSignChoice = pSign;
            }
        }
        else
        {
            DMChordData& rNextChord = *pNextChord;
            nHit = CompareSPToChord(pSign->GetItemValue(), dwScale, rNextChord, (char) bRoot);
            if (nHit == nMin)
            {
                i++;
                pSignChoice = pSign;
            }
        }
    }
    // If the signpost that was found doesn't match the chord we're going to, discard it
    if (!fEnding && 
        pSignChoice && 
        (!(*pNextChord).Equals(pSignChoice->GetItemValue().m_ChordData)))
    {
        pSignChoice = NULL;
    }
    return pSignChoice;
}

IDirectMusicGraph* CDMCompos::CloneSegmentGraph(IDirectMusicSegment* pSegment)
{
    if (!pSegment)
    {
        return NULL;
    }
    IDirectMusicGraph* pGraph = NULL;
    HRESULT hr = pSegment->GetGraph(&pGraph);
    if (FAILED(hr) || !pGraph)
    {
        return NULL;
    }
    IGraphClone *pGraph8 = NULL;
    hr = pGraph->QueryInterface(IID_IGraphClone, (void**)&pGraph8);
    pGraph->Release();
    if (FAILED(hr) || !pGraph8)
    {
        return NULL;
    }
    hr = pGraph8->Clone(&pGraph);
    pGraph8->Release();
    if (SUCCEEDED(hr))
    {
        return pGraph;
    }
    else
    {
        return NULL;
    }
}

IUnknown* CDMCompos::GetSegmentAudioPath(IDirectMusicSegment* pSegment, DWORD dwFlags, DWORD* pdwAudioPath)
{
    if (!pSegment)
    {
        return NULL;
    }
    if (!(dwFlags & DMUS_COMPOSEF_USE_AUDIOPATH))
    {
        DWORD dwDefault = 0;
        pSegment->GetDefaultResolution(&dwDefault);
        if ( pdwAudioPath && (dwDefault & DMUS_SEGF_USE_AUDIOPATH) )
        {
            *pdwAudioPath = DMUS_SEGF_USE_AUDIOPATH;
        }
        return NULL;
    }
    IUnknown* pPath = NULL;
    IDirectMusicSegment8* pSeg8 = NULL;
    HRESULT hr = pSegment->QueryInterface(IID_IDirectMusicSegment8, (void**)&pSeg8);
    if (FAILED(hr)) return NULL;
    hr = pSeg8->GetAudioPathConfig(&pPath);
    pSeg8->Release();
    if (FAILED(hr) || !pPath)
    {
        return NULL;
    }
    else
    {
        return pPath;
    }
}

HRESULT CDMCompos::ComposeTransition(
    IDirectMusicSegment*    pFromSeg, // @parm 
                            // The section from which to compose the transition.
    IDirectMusicSegment*    pToSeg,  // @parm
                            // The section to which the transition should smoothly flow.
    MUSIC_TIME              mtTime, // @parm
                            // The time in <p pFromSeg> from which to compose the transition.
    WORD                    wCommand, // @parm
                            // The embellishment to use when composing the transition.
                            // DMUS_COMMANDT_ENDANDINTRO means compose a segment containing
                            // an end to <p pFromSeg> and an intro to <p pToSeg>.
    DWORD                   dwFlags, // @parm
                            // Various composition options.
    IDirectMusicChordMap* pChordMap, // @parm
                             // The ChordMap to be used when composing the transition.
    IDirectMusicSegment**   ppSectionSeg // @parm
                            // Returns the created section segment.
            )
{
    V_INAME(IDirectMusicComposer::ComposeTransition)
    V_PTR_WRITE_OPT(pToSeg, 1);
    V_PTR_WRITE_OPT(pFromSeg, 1);
    V_PTR_WRITE_OPT(pChordMap, 1);
    V_PTRPTR_WRITE(ppSectionSeg);
    HRESULT hr = S_OK;
    bool fHaveChordMap = pChordMap ? true : false;

    DWORD dwGroupBits = ALL_TRACK_GROUPS;
    DWORD dwIndex = DMUS_SEG_ANYTRACK;

    bool fLong = (dwFlags & DMUS_COMPOSEF_LONG) ? true : false;
    bool fModulate = (dwFlags & DMUS_COMPOSEF_MODULATE) ? true : false;
    bool fEnding = wCommand == DMUS_COMMANDT_END  || wCommand == DMUS_COMMANDT_ENDANDINTRO;
    bool fHasIntro = wCommand == DMUS_COMMANDT_INTRO || wCommand == DMUS_COMMANDT_ENDANDINTRO;
    if (!pToSeg && !fEnding && fModulate)
    {
        Trace(1, "ERROR (ComposeTransition): Invalid modulation.\n");
        return E_INVALIDARG;
    }

    // Get Tool graphs from the To and From segments
    IDirectMusicGraph* pFromGraph = CloneSegmentGraph(pFromSeg);
    IDirectMusicGraph* pToGraph = CloneSegmentGraph(pToSeg);

    // Get Audiopaths from the To and From segments
    IUnknown* pFromPath = GetSegmentAudioPath(pFromSeg, dwFlags);
    IUnknown* pToPath = GetSegmentAudioPath(pToSeg, dwFlags);

    // Get the starting segment's style
    IDirectMusicStyle* pFromStyle = NULL;
    if (pFromSeg)
    {
        hr = GetStyle(pFromSeg, mtTime, ALL_TRACK_GROUPS, pFromStyle, false);
        if (FAILED(hr)) pFromStyle = NULL;
    }

    // if no ChordMap is passed in, try to get one from the segments (first the
    // TO segment, then the FROM segment).  If these both fail, use the current chord
    // as the chord for the transition.  (if we're composing an ending, skip the TO segment)
    hr = S_OK;
    if (!pChordMap)
    {
        if (fEnding || !pToSeg || FAILED(GetPersonality(pToSeg, 0, ALL_TRACK_GROUPS, pChordMap)))
        {
            if (!pFromSeg || FAILED(GetPersonality(pFromSeg, mtTime, ALL_TRACK_GROUPS, pChordMap))) 
                pChordMap = NULL;
        }
    }

    // Get a tempo from the From segment.
    double dblFromTempo = 120.0;
    double* pdblFromTempo = NULL;
    if (pFromSeg && SUCCEEDED(GetTempo(pFromSeg, mtTime, &dblFromTempo)))
    {
        pdblFromTempo = &dblFromTempo;
    }

    DMUS_COMMAND_PARAM_2 Command;
    if (!pFromSeg || FAILED(pFromSeg->GetParam(GUID_CommandParam2, dwGroupBits, dwIndex, mtTime, NULL, (void*) &Command)))
    {
        Command.mtTime = 0;
        Command.bCommand = DMUS_COMMANDT_GROOVE;
        Command.bGrooveLevel = 62;
        Command.bGrooveRange = 0;
        Command.bRepeatMode = DMUS_PATTERNT_RANDOM;
    }
    DMUS_CHORD_PARAM NextChord;
    DMUS_CHORD_PARAM LastChord;
    if (!pFromSeg || FAILED(pFromSeg->GetParam(GUID_ChordParam, dwGroupBits, dwIndex, mtTime, NULL, (void*) &LastChord)))
    {
        wcscpy(LastChord.wszName, L"M7");
        LastChord.wMeasure = 0;
        LastChord.bBeat = 0;
        LastChord.bSubChordCount = 1;
        LastChord.bKey = 12;
        LastChord.dwScale = DEFAULT_SCALE_PATTERN;
        LastChord.SubChordList[0].dwChordPattern = DEFAULT_CHORD_PATTERN;
        LastChord.SubChordList[0].dwScalePattern = DEFAULT_SCALE_PATTERN;
        LastChord.SubChordList[0].dwInversionPoints = 0xffffff;
        LastChord.SubChordList[0].dwLevels = 0xffffffff;
        LastChord.SubChordList[0].bChordRoot = 12; // 2C
        LastChord.SubChordList[0].bScaleRoot = 0;
    }
    if ((fModulate || fHasIntro) && pToSeg)
    {
        hr = pToSeg->GetParam(GUID_ChordParam, dwGroupBits, dwIndex, 0, NULL, (void*) &NextChord);
    }
    else if (pFromSeg)
    {
        hr = pFromSeg->GetParam(GUID_ChordParam, dwGroupBits, dwIndex, 0, NULL, (void*) &NextChord);
    }
    else
    {
        hr = E_FAIL;
    }
    if (FAILED(hr))
    {
        wcscpy(NextChord.wszName, L"M7");
        NextChord.wMeasure = 0;
        NextChord.bBeat = 0;
        NextChord.bSubChordCount = 1;
        NextChord.bKey = 12;
        NextChord.dwScale = DEFAULT_SCALE_PATTERN;
        NextChord.SubChordList[0].dwChordPattern = DEFAULT_CHORD_PATTERN;
        NextChord.SubChordList[0].dwScalePattern = DEFAULT_SCALE_PATTERN;
        NextChord.SubChordList[0].dwInversionPoints = 0xffffff;
        NextChord.SubChordList[0].dwLevels = 0xffffffff;
        NextChord.SubChordList[0].bChordRoot = 12; // 2C
        NextChord.SubChordList[0].bScaleRoot = 0;
    }

    hr = TransitionCommon(pFromStyle, NULL, pdblFromTempo, Command, LastChord, NextChord,
                pToSeg, wCommand, dwFlags, pChordMap, pFromGraph, pToGraph, pFromPath, pToPath, ppSectionSeg);

    if (pFromStyle) pFromStyle->Release();
    if (!fHaveChordMap && pChordMap) pChordMap->Release();
    if (pFromGraph) pFromGraph->Release();
    if (pToGraph) pToGraph->Release();
    if (pFromPath) pFromPath->Release();
    if (pToPath) pToPath->Release();

    return hr;
}

/* 
@method:(EXTERNAL) HRESULT | IDirectMusicComposer | AutoTransition |  Composes a
transition from inside a performance's primary segment to another segment, and then 
queues the transition and the second segment to play.

@rdesc Returns:

@flag S_OK | Success
@flag E_POINTER | One or more of <p pPerformance>, <p pToSeg>, <p pChordMap>,
<p ppTransSeg>, <p ppToSegState>, and <p ppTransSegState> is not a valid pointer.

@comm Allowable values for <p dwFlags> include all values allowed for
<om IDirectMusicComposer::ComposeTransition>.  Additionally, the following values are
allowed:

  @flag DMUS_COMPOSEF_IMMEDIATE | Start transition on music or reference time boundary.
  @flag DMUS_COMPOSEF_GRID | Start transition on grid boundary.
  @flag DMUS_COMPOSEF_BEAT | Start transition on beat boundary.
  @flag DMUS_COMPOSEF_MEASURE | Start transition on measure boundary.
  @flag DMUS_COMPOSEF_AFTERPREPARETIME | Use the DMUS_SEGF_AFTERPREPARETIME flag when
     queueing the transition.


  <p ppTransSeg may be NULL.  In this case, the transition segment is not returned.
  <p pToSeg> may be NULL as long as <p dwFlags> does not include DMUS_COMPOSEF_MODULATE.
  If <p pToSeg> is NULL or doesn't contain a style track, intro embellishments are not valid.
  If the currently playing segment is NULL or doesn't contain a style track,
  fill, break, end, and groove embellishments are not valid.
  Note that the above implies that it is possible for both the currently playing segment and
  <p pToSeg> to be NULL or to be
  segments that don't contain style tracks.  If so, all embellishments are invalid.  When all
  embellishments are invalid, no transition occurs between the currently playing segment
  and <p pToSeg>.
  <p pChordMap> may be NULL.  If so, an attempt is made to obtain a ChordMap from a
  ChordMap track, first from <p pToSeg>, and then from the performance's primary segment.
  If neither of these
  segments contains a ChordMap track, the chord occuring at <p mtTime> in the primary 
  segment is 
  used as the chord in the transition. 
*/

HRESULT CDMCompos::AutoTransition(
    IDirectMusicPerformance*    pPerformance,   // @parm 
                                // The performance in which to do the transition.
    IDirectMusicSegment*        pToSeg,         // @parm 
                                // The section to which the transition should smoothly flow.    
    WORD                        wCommand,       // @parm 
                                // The embellishment to use when composing the transition.
    DWORD                       dwFlags,        // @parm 
                                // Various composition options.
    IDirectMusicChordMap*       pChordMap,  // @parm 
                                // The ChordMap to be used when composing the transition.
    IDirectMusicSegment**       ppTransSeg,     // @parm 
                                // Returns the created section segment.
    IDirectMusicSegmentState**  ppToSegState,   // @parm 
                                // Returns the segment state for the transition segment.
    IDirectMusicSegmentState**  ppTransSegState // @parm
                                // Returns the segment state for the segment following the transition.
            )
{
    // ppToSegState and ppTransSegState are checked in Performance::PlaySegment,
    // BUT I need to check them here as well.
    V_INAME(IDirectMusicComposer::AutoTransition)
    V_PTR_WRITE_OPT(pToSeg, 1);
    V_PTR_WRITE_OPT(pChordMap, 1);
    V_PTR_WRITE(pPerformance, 1);
    V_PTR_WRITE_OPT(ppTransSeg, 1);
    V_PTR_WRITE_OPT(ppToSegState, 1);
    V_PTR_WRITE_OPT(ppTransSegState, 1);

    DWORD dwGroupBits = 0xffffffff;
    DWORD dwIndex = DMUS_SEG_ANYTRACK;

    DWORD dwResolution;
    if (dwFlags & DMUS_COMPOSEF_MEASURE) dwResolution = DMUS_SEGF_MEASURE;
    else if (dwFlags & DMUS_COMPOSEF_BEAT) dwResolution = DMUS_SEGF_BEAT;
    else if (dwFlags & DMUS_COMPOSEF_GRID) dwResolution = DMUS_SEGF_GRID;
    else if (dwFlags & DMUS_COMPOSEF_DEFAULT) dwResolution = DMUS_SEGF_DEFAULT;
    else if (dwFlags & DMUS_COMPOSEF_IMMEDIATE) dwResolution = 0;
    else dwResolution = DMUS_SEGF_MEASURE;

    if (dwFlags & DMUS_COMPOSEF_ALIGN) dwResolution |= DMUS_SEGF_ALIGN;
    if (dwFlags & DMUS_COMPOSEF_VALID_START_MEASURE) dwResolution |= DMUS_SEGF_VALID_START_MEASURE;
    if (dwFlags & DMUS_COMPOSEF_VALID_START_BEAT) dwResolution |= DMUS_SEGF_VALID_START_BEAT;
    if (dwFlags & DMUS_COMPOSEF_VALID_START_GRID) dwResolution |= DMUS_SEGF_VALID_START_GRID;
    if (dwFlags & DMUS_COMPOSEF_VALID_START_TICK) dwResolution |= DMUS_SEGF_VALID_START_TICK;

    if (dwFlags & DMUS_COMPOSEF_AFTERPREPARETIME) dwResolution |= DMUS_SEGF_AFTERPREPARETIME;
    if (dwFlags & DMUS_COMPOSEF_NOINVALIDATE) dwResolution |= DMUS_SEGF_NOINVALIDATE;
    if (dwFlags & DMUS_COMPOSEF_INVALIDATE_PRI) dwResolution |= DMUS_SEGF_INVALIDATE_PRI;
    if (dwFlags & DMUS_COMPOSEF_USE_AUDIOPATH) dwResolution |= DMUS_SEGF_USE_AUDIOPATH;

    DWORD dwUseAudioPath = dwResolution & DMUS_SEGF_USE_AUDIOPATH;

    IDirectMusicSegment* pTransSeg = NULL;
    if (!ppTransSeg)
    {
        ppTransSeg = &pTransSeg;
    }

    IDirectMusicChordMap* pFromChordMap = NULL;
    bool bReleaseFromChordMap = false;
    double dblFromTempo = 120.0;
    double* pdblFromTempo = NULL;
    IDirectMusicStyle* pFromStyle = NULL;
    IDirectMusicBand* pBand = NULL;
    IDirectMusicSegmentState* pSegState = NULL;
    IDirectMusicSegment* pFromSegment = NULL;
    bool fModulate = (dwFlags & DMUS_COMPOSEF_MODULATE) ? true : false;
    bool fEnding = wCommand == DMUS_COMMANDT_END  || wCommand == DMUS_COMMANDT_ENDANDINTRO;
    bool fHasIntro = wCommand == DMUS_COMMANDT_INTRO || wCommand == DMUS_COMMANDT_ENDANDINTRO;
    if (!pToSeg && !fEnding && fModulate)
    {
        Trace(1, "ERROR (AutoTransition): Invalid modulation.\n");
        return E_INVALIDARG;
    }
    MUSIC_TIME mtTime, mt;
    MUSIC_TIME mtStart;
    REFERENCE_TIME rt, rtResolved;
#ifdef DXAPI
    HRESULT hr = pPerformance->GetQueueTime(&rt);
#else
    HRESULT hr = pPerformance->GetTime(&rt,NULL);
#endif
    if (SUCCEEDED(hr)) hr = pPerformance->GetResolvedTime(rt, &rtResolved, dwResolution);
    if (SUCCEEDED(hr)) hr = pPerformance->ReferenceToMusicTime(rtResolved, &mtTime);
    if (SUCCEEDED(hr)) hr = pPerformance->ReferenceToMusicTime(rt, &mt);

    if (!SUCCEEDED(hr)) return hr;
    if (rtResolved > rt) mtTime--;
    hr = pPerformance->GetSegmentState(&pSegState, mtTime);
    if (SUCCEEDED(hr))
    {
        hr = pSegState->GetStartTime(&mtStart);
        TraceI(3, "Time: %d Resolved Time: %d\n", mt - mtStart, mtTime - mtStart);
        if (!SUCCEEDED(hr))
        {
            goto ON_END;
        }
        hr = pSegState->GetSegment(&pFromSegment);
        if (!SUCCEEDED(hr))
        {
            goto ON_END;
        }
        if (dwFlags & DMUS_COMPOSEF_SEGMENTEND)
        {
            MUSIC_TIME mtLength;
            if( SUCCEEDED( pFromSegment->GetLength( &mtLength ) ) )
            {
                mtTime = mtLength - 1;
                mtStart = 0;
            }
        }
    }
    else pSegState = NULL;

    // Get the starting segment's style
    if (pPerformance)
    {
        hr = pPerformance->GetParam(GUID_IDirectMusicStyle, dwGroupBits, dwIndex, mtTime, NULL, (void*)&pFromStyle);
        if (FAILED(hr)) pFromStyle = NULL;
    }

    // if no ChordMap is passed in, try to get one (first from the TO segment,
    // then the FROM segment).  If these both fail, use the current chord
    // as the chord for the transition.  (if we're composing an ending, skip the TO segment)
    hr = S_OK;
    if (!pChordMap)
    {
        if (fEnding || !pToSeg || FAILED(GetPersonality(pToSeg, 0, dwGroupBits, pFromChordMap)))
        {
            if (!pFromSegment || FAILED(GetPersonality(pFromSegment, 0, dwGroupBits, pFromChordMap))) 
            {
                pFromChordMap = NULL;
            }
        }
        if(pFromChordMap)
        {
            bReleaseFromChordMap = true;
        }

    }
    else
    {
        pFromChordMap = pChordMap;
    }

    DMUS_COMMAND_PARAM_2 Command;
    if (FAILED(pPerformance->GetParam(GUID_CommandParam2, dwGroupBits, dwIndex, mtTime, NULL, (void*) &Command)))
    {
        Command.mtTime = 0;
        Command.bCommand = DMUS_COMMANDT_GROOVE;
        Command.bGrooveLevel = 62;
        Command.bGrooveRange = 0;
        Command.bRepeatMode = DMUS_PATTERNT_RANDOM;
    }
    DMUS_CHORD_PARAM NextChord;
    DMUS_CHORD_PARAM LastChord;
    if (FAILED(pPerformance->GetParam(GUID_ChordParam, dwGroupBits, dwIndex, mtTime, NULL, (void*) &LastChord)))
    {
        wcscpy(LastChord.wszName, L"M7");
        LastChord.wMeasure = 0;
        LastChord.bBeat = 0;
        LastChord.bSubChordCount = 1;
        LastChord.bKey = 12;
        LastChord.dwScale = DEFAULT_SCALE_PATTERN;
        LastChord.SubChordList[0].dwChordPattern = DEFAULT_CHORD_PATTERN;
        LastChord.SubChordList[0].dwScalePattern = DEFAULT_SCALE_PATTERN;
        LastChord.SubChordList[0].dwInversionPoints = 0xffffff;
        LastChord.SubChordList[0].dwLevels = 0xffffffff;
        LastChord.SubChordList[0].bChordRoot = 12; // 2C
        LastChord.SubChordList[0].bScaleRoot = 0;
    }
    if ((fModulate || fHasIntro) && pToSeg)
    {
        hr = pToSeg->GetParam(GUID_ChordParam, dwGroupBits, dwIndex, 0, NULL, (void*) &NextChord);
    }
    else
    {
        // Check that this is the correct thing to do if pFromSegment is NULL.
        hr = pFromSegment ? pFromSegment->GetParam(GUID_ChordParam, dwGroupBits, dwIndex, 0, NULL, (void*) &NextChord) : E_FAIL;
    }
    if (FAILED(hr))
    {
        wcscpy(NextChord.wszName, L"M7");
        NextChord.wMeasure = 0;
        NextChord.bBeat = 0;
        NextChord.bSubChordCount = 1;
        LastChord.bKey = 12;
        NextChord.dwScale = DEFAULT_SCALE_PATTERN;
        NextChord.SubChordList[0].dwChordPattern = DEFAULT_CHORD_PATTERN;
        NextChord.SubChordList[0].dwScalePattern = DEFAULT_SCALE_PATTERN;
        NextChord.SubChordList[0].dwInversionPoints = 0xffffff;
        NextChord.SubChordList[0].dwLevels = 0xffffffff;
        NextChord.SubChordList[0].bChordRoot = 12; // 2C
        NextChord.SubChordList[0].bScaleRoot = 0;
    }
    // If < DX8 content for From segment (or playing transition from segment end),
    // call ComposeTransition; otherwise, call TransitionCommon
    if (!UsingDX8(pFromStyle, pFromChordMap, pFromSegment, &Command, &LastChord) ||
        (dwFlags & DMUS_COMPOSEF_SEGMENTEND) )
    {
        if (pSegState)
        {
            hr = ComposeTransition(pFromSegment, pToSeg, mtTime - mtStart, wCommand, dwFlags, pChordMap, ppTransSeg);
        }
        else
        {
            hr = ComposeTransition(NULL, pToSeg, 0, wCommand, dwFlags, pChordMap, ppTransSeg);
        }
    }
    else
    {
        // Get Tool graphs from the To and From segments
        IDirectMusicGraph* pFromGraph = CloneSegmentGraph(pFromSegment);
        IDirectMusicGraph* pToGraph = CloneSegmentGraph(pToSeg);

        // Get Audiopaths from the To and From segments
        IUnknown* pFromPath = GetSegmentAudioPath(pFromSegment, dwFlags);
        IUnknown* pToPath = GetSegmentAudioPath(pToSeg, dwFlags, &dwUseAudioPath);

        // Get a tempo from the performance.
        DMUS_TEMPO_PARAM Tempo;
        if (SUCCEEDED(pPerformance->GetParam(GUID_TempoParam, dwGroupBits, dwIndex, mtTime, NULL, (void*)&Tempo)))
        {
            dblFromTempo = Tempo.dblTempo;
            pdblFromTempo = &dblFromTempo;
        }

        // Get the currently playing band
        DMUS_BAND_PARAM DMBand;
        if (SUCCEEDED(pPerformance->GetParam(GUID_BandParam, dwGroupBits, dwIndex, mtTime, NULL, (void*)&DMBand)))
        {
            pBand = DMBand.pBand;
        }

        hr = TransitionCommon(pFromStyle, pBand, pdblFromTempo, Command, LastChord, NextChord,
                    pToSeg, wCommand, dwFlags, pFromChordMap, pFromGraph, pToGraph,  pFromPath, pToPath, ppTransSeg);
        if (pFromGraph) pFromGraph->Release();
        if (pToGraph) pToGraph->Release();
        if (pFromPath) pFromPath->Release();
        if (pToPath) pToPath->Release();
    }

    if (SUCCEEDED(hr))
    {
        if (*ppTransSeg && pToSeg)
        {
            DMUS_COMMAND_PARAM_2 CommandParam;
            if (SUCCEEDED(pToSeg->GetParam(GUID_CommandParam2, dwGroupBits, dwIndex, 0, NULL, (void*) &CommandParam)))
            {
                (*ppTransSeg)->SetParam(GUID_CommandParamNext, dwGroupBits, 0, 0, (void*) &CommandParam);
            }
        }

        if (dwFlags & DMUS_COMPOSEF_SEGMENTEND) dwResolution |= DMUS_SEGF_SEGMENTEND;
        if (dwFlags & DMUS_COMPOSEF_MARKER) dwResolution |= DMUS_SEGF_MARKER;
        DWORD dwQueueResolution = DMUS_SEGF_QUEUE | dwUseAudioPath;

        hr = S_OK;
        if (*ppTransSeg)
        {
#ifdef DXAPI
            hr = pPerformance->PlaySegment(*ppTransSeg, dwResolution, 0, ppTransSegState);
            if (SUCCEEDED(hr) && pToSeg)
            {
                hr = pPerformance->PlaySegment(pToSeg, dwQueueResolution, 0, ppToSegState);
            }
#else
            hr = pPerformance->PlaySegmentEx(*ppTransSeg, NULL, NULL, dwResolution, 0, ppTransSegState, NULL, NULL);
            if (SUCCEEDED(hr) && pToSeg)
            {
                hr = pPerformance->PlaySegmentEx(pToSeg, NULL, NULL, DMUS_SEGF_QUEUE, 0, ppToSegState, NULL, NULL);
            }
#endif
        }
        else
        {
            if (!pToSeg)
            {
                if (!(dwFlags & DMUS_COMPOSEF_SEGMENTEND))
                {
#ifdef DXAPI
                    hr = pPerformance->Stop(pFromSegment, NULL, 0, dwResolution);
#else
                    hr = pPerformance->StopEx(pFromSegment, 0, dwResolution);
#endif
                }
            }
            else
            {
#ifdef DXAPI
                hr = pPerformance->PlaySegment(pToSeg, dwResolution, 0, ppToSegState);
#else
                hr = pPerformance->PlaySegmentEx(pToSeg, NULL, NULL, dwResolution, 0, ppToSegState, NULL, NULL);
#endif
            }
        }
    }

ON_END:
    if (pFromStyle) pFromStyle->Release();
    if (pBand) pBand->Release();
    if (pTransSeg) pTransSeg->Release();
    if (pSegState) pSegState->Release();
    if (pFromSegment) pFromSegment->Release();
    if (bReleaseFromChordMap) pFromChordMap->Release();
    return hr;
}

/* 
@method:(EXTERNAL) HRESULT | IDirectMusicComposer | ComposeTemplateFromShape |  Creates
a new template segment based on a predefined shape.

@rdesc Returns:

@flag S_OK | Success
@flag E_POINTER | <p ppTempSeg> is not a valid pointer.
@flag E_OUTOFMEMORY | An attempt to allocate memory failed.
@flag E_INVALIDARG | <p wNumMeasures> is 0, or <p fComposeEnding> is TRUE and either
  <p wEndLength> is 0 or <p wEndLength> is greater than the number of non-intro measures.

@comm Shapes (passed in <p wShape>) represent the way chords and embellishments
occur over time across the section.  There are nine shapes:

  @flag DMUS_SHAPET_FALLING | The section gets quieter over time.
  @flag DMUS_SHAPET_LEVEL   | The section remains at the same level.
  @flag DMUS_SHAPET_LOOPABLE | The section is arranged to loop back to its beginning.
  @flag DMUS_SHAPET_LOUD    | The section remains loud.
  @flag DMUS_SHAPET_QUIET   | The section remains quiet.
  @flag DMUS_SHAPET_PEAKING | The section peaks.
  @flag DMUS_SHAPET_RANDOM | The section is random.
  @flag DMUS_SHAPET_RISING | The section builds over time.
  @flag DMUS_SHAPET_SONG | The section is in a song form.

*/
HRESULT CDMCompos::ComposeTemplateFromShape(
                    WORD                    wNumMeasures, // @parm The length, in measures, to compose the section segment
                    WORD                    wShape,// @parm The shape to compose the section segment.
                    BOOL                    fComposeIntro,// @parm TRUE if an intro is to be composed for the section segment.
                    BOOL                    fComposeEnding,// @parm TRUE if an ending is to be composed for the section segment.
                    WORD                    wEndLength, // @parm Length in measures of the ending, if one is to be composed.
                    IDirectMusicSegment**   ppTempSeg   // @parm Returns the created template segment.
            )
{
    V_INAME(IDirectMusicComposer::ComposeTemplateFromShape)
    V_PTRPTR_WRITE(ppTempSeg);
    return ComposeTemplateFromShapeInternal(wNumMeasures, wShape, fComposeIntro, fComposeEnding,
        1, 1, 1, (int)wEndLength, ppTempSeg);
}

HRESULT CDMCompos::ComposeTemplateFromShapeEx(
                WORD wNumMeasures,                  // Number of measures in template
                WORD wShape,                        // Shape for composition
                BOOL fIntro,                        // Compose an intro?
                BOOL fEnd,                          // Compose an ending?
                IDirectMusicStyle* pStyle,          // Style used for embellishment lengths
                IDirectMusicSegment** ppTemplate    // Template containing chord and command tracks
            )
{
    V_INAME(IDirectMusicComposer::ComposeTemplateFromShapeEx)
    V_PTRPTR_WRITE(ppTemplate);
    V_PTR_WRITE_OPT(pStyle, 1);
    HRESULT hr = S_OK;

    int nIntroLength = 1;
    int nFillLength = 1;
    int nBreakLength = 1;
    int nEndLength = 1;
    if (pStyle)
    {
        DWORD dwMin, dwMax;

        hr = pStyle->GetEmbellishmentLength(DMUS_COMMANDT_INTRO, 0, &dwMin, &dwMax);
        if (hr == S_OK) nIntroLength = (int) dwMax;
        hr = pStyle->GetEmbellishmentLength(DMUS_COMMANDT_FILL, 0, &dwMin, &dwMax);
        if (hr == S_OK) nFillLength = (int) dwMax;
        hr = pStyle->GetEmbellishmentLength(DMUS_COMMANDT_BREAK, 0, &dwMin, &dwMax);
        if (hr == S_OK) nBreakLength = (int) dwMax;
        hr = pStyle->GetEmbellishmentLength(DMUS_COMMANDT_END, 0, &dwMin, &dwMax);
        if (hr == S_OK) nEndLength = (int) dwMax;
    }
    return ComposeTemplateFromShapeInternal(wNumMeasures, wShape, fIntro, fEnd, 
        nIntroLength, nFillLength, nBreakLength, nEndLength, ppTemplate);
}

HRESULT CDMCompos::ComposeTemplateFromShapeInternal(
                    WORD                    wNumMeasures,
                    WORD                    wShape,
                    BOOL                    fComposeIntro,
                    BOOL                    fComposeEnding,
                    int                     nIntroLength,
                    int                     nFillLength,
                    int                     nBreakLength,
                    int                     nEndLength,
                    IDirectMusicSegment**   ppTempSeg
            )
{
    HRESULT hr;
    if ( !wNumMeasures || 
         (fComposeEnding && !nEndLength) ||
         (fComposeIntro && !nIntroLength) ||
         (fComposeEnding && fComposeIntro && (nEndLength + nIntroLength) > wNumMeasures) ||
         (fComposeEnding && (nEndLength > wNumMeasures)) ||
         (fComposeIntro && (nIntroLength > wNumMeasures)) )
    {
        Trace(1, "ERROR (ComposeTemplateFromShape): Invalid template length.\n");
        return E_INVALIDARG;
    }

    if (wNumMeasures & 0x8000 || wNumMeasures == 0) wNumMeasures = 1;
    int nNumMeasures = (int)wNumMeasures;
    if (fComposeEnding)
    {
        if (nEndLength <= 0) nEndLength = 1;
    }
    if (wShape != DMUS_SHAPET_FALLING &&
        wShape != DMUS_SHAPET_LEVEL &&
        wShape != DMUS_SHAPET_LOOPABLE &&
        wShape != DMUS_SHAPET_LOUD &&
        wShape != DMUS_SHAPET_QUIET &&
        wShape != DMUS_SHAPET_PEAKING &&
        wShape != DMUS_SHAPET_RANDOM &&
        wShape != DMUS_SHAPET_RISING &&
        wShape != DMUS_SHAPET_SONG)
    {
        wShape = DMUS_SHAPET_RANDOM;
    }


    int nOriginalMeasures = 0;
    bool f1Bar = false;
    if (fComposeIntro)
    {
        nNumMeasures -= nIntroLength;
        if (nNumMeasures < nIntroLength)
        {
            f1Bar = true;
            nNumMeasures = nIntroLength;
        }
    }
    if (fComposeEnding)
    {
        int nLength = nEndLength;
        nOriginalMeasures = nNumMeasures;
        nNumMeasures -= (nLength - 1);
        if (nNumMeasures < 1)
        {
            nNumMeasures = 1;
        }
    }
    TemplateStruct* pTemplate = new TemplateStruct;
    if (!pTemplate) return E_OUTOFMEMORY;
    TemplateStruct* apTempl[8] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };
    if ((wShape != DMUS_SHAPET_SONG) || (nNumMeasures <= 24))
    {
        if (wShape == DMUS_SHAPET_LOOPABLE) nNumMeasures++;
        pTemplate->m_nMeasures = (short)nNumMeasures;
        pTemplate->CreateSignPosts();
        pTemplate->CreateEmbellishments(wShape, nFillLength, nBreakLength);
        if (wShape == DMUS_SHAPET_LOOPABLE)
        {
            nNumMeasures--;
            pTemplate->m_nMeasures = (short)nNumMeasures;
        }
    }
    else
    {
        short nShortestLength = 12; // initialized to longest value in sanLengths
        int anLengths[8];
        int anGrooveLevel[8];
        BYTE abLeadins[8];
        int nTypeCount = 2;
        unsigned int nSize = (unsigned int) nNumMeasures >> 5;
        int nTypeIndex;
        int nMeasure;
        int nChoice, nLastChoice;
        while (nSize)
        {
            nTypeCount++;
            nSize = nSize >> 1;
            if (nTypeCount >= 8) break;
        }
        for (nTypeIndex = 1; nTypeIndex < nTypeCount; nTypeIndex++)
        {
            apTempl[nTypeIndex] = new TemplateStruct;
            if (!apTempl[nTypeIndex])
            {
                hr = E_OUTOFMEMORY;
                goto ON_END;
            }
            static WORD awShapes[8] = {
                DMUS_SHAPET_FALLING, DMUS_SHAPET_LEVEL, DMUS_SHAPET_LOUD, DMUS_SHAPET_QUIET,
                DMUS_SHAPET_RANDOM, DMUS_SHAPET_RANDOM, DMUS_SHAPET_RANDOM, DMUS_SHAPET_RANDOM };
            static int anInitGroovels[8] = { 0,-1,0,0,1,-1,2,-2 };
            static BYTE abRiffs[8] = {
                DMUS_COMMANDT_FILL, DMUS_COMMANDT_BREAK, DMUS_COMMANDT_FILL, DMUS_COMMANDT_BREAK,
                DMUS_COMMANDT_FILL, DMUS_COMMANDT_FILL, DMUS_COMMANDT_BREAK, DMUS_COMMANDT_FILL };
            static short sanLengths[10] = { 8,8,8,8,6,12,8,8,10,6 };
            short nLength = sanLengths[dm_rand() % 10];

            apTempl[nTypeIndex]->m_nMeasures = nLength;
            anLengths[nTypeIndex] = nLength;
            if (nLength)
            {
                if (nShortestLength > nLength) nShortestLength = nLength;
                apTempl[nTypeIndex]->CreateSignPosts();
                apTempl[nTypeIndex]->CreateEmbellishments(awShapes[nTypeIndex], nFillLength, nBreakLength);
                anGrooveLevel[nTypeIndex] = anInitGroovels[nTypeIndex];
                if (dm_rand() % 4) abLeadins[nTypeIndex] = abRiffs[nTypeIndex];
                else abLeadins[nTypeIndex] = 0;
            }
        }
        anGrooveLevel[0] = 0;
        pTemplate->m_nMeasures = (short)nNumMeasures;
        nMeasure = 0;
        nChoice = 1;
        nLastChoice = 0;
        for (; nMeasure < nNumMeasures; )
        {
            int nGroove;
            int nNewChoice;

            if ((nNumMeasures - nMeasure) <= nShortestLength)
            {
                nChoice = 0;
                short nLength = nNumMeasures - nMeasure;
                apTempl[0] = new TemplateStruct;
                if (!apTempl[0])
                {
                    hr = E_OUTOFMEMORY;
                    goto ON_END;
                }
                apTempl[0]->m_nMeasures = nLength;
                anLengths[0] = nLength;
                apTempl[0]->CreateSignPosts();
                apTempl[0]->CreateEmbellishments(DMUS_SHAPET_FALLING, nFillLength, nBreakLength);
                anGrooveLevel[0] = 0;
                if (dm_rand() % 4) abLeadins[0] = DMUS_COMMANDT_FILL;
                else abLeadins[0] = 0;
            }
            nGroove = anGrooveLevel[nChoice];
            pTemplate->IncorporateTemplate((short)nMeasure, apTempl[nChoice], (short)nGroove);
            if ( (abLeadins[nChoice] == DMUS_COMMANDT_FILL && nMeasure >= nFillLength) )
            {
                InsertCommand(nMeasure, nFillLength, pTemplate->m_CommandList, abLeadins[nChoice]);
            }
            else if ( (abLeadins[nChoice] == DMUS_COMMANDT_BREAK && nMeasure >= nBreakLength) )
            {
                InsertCommand(nMeasure, nBreakLength, pTemplate->m_CommandList, abLeadins[nChoice]);
            }
            if (anGrooveLevel[nChoice] < 0) anGrooveLevel[nChoice]++;
            else
            {
                if (dm_rand() % 3)
                {
                    if (dm_rand() % 2)
                    {
                        anGrooveLevel[nChoice]++;
                    }
                    else
                    {
                        anGrooveLevel[nChoice]--;
                    }
                }
            }
            nMeasure += anLengths[nChoice];
            nNewChoice = WeightedRand(nTypeCount - 1) + 1;
            if ((nNewChoice == nChoice) && (nNewChoice == nLastChoice))
            {
                nNewChoice = WeightedRand(nTypeCount - 1) + 1;
            }
            if (nNewChoice == nChoice)
            {
                nNewChoice = WeightedRand(nTypeCount - 1) + 1;
            }
            // If there are enough measures for some but not all of the
            // patterns, find a pattern that fits
            if ((nNumMeasures - nMeasure) > nShortestLength)
            {
                while ((nNumMeasures - nMeasure) < anLengths[nNewChoice])
                {
                    nNewChoice = WeightedRand(nTypeCount - 1) + 1;
                }
            }
            nLastChoice = nChoice;
            nChoice = nNewChoice;
        }
        pTemplate->m_CommandList.MergeSort(Less);
    }
    if (fComposeEnding)
    {
        int nLength = nEndLength;
        if (nNumMeasures != nOriginalMeasures)
        {
            pTemplate->m_nMeasures = (short)nOriginalMeasures;
        }
        if (nLength > nOriginalMeasures)
        {
            nLength = nOriginalMeasures;
        }
        pTemplate->AddEnd(nLength);
    }
    if (fComposeIntro)
    {
        pTemplate->AddIntro(f1Bar, nIntroLength);
    }
    // build the template segment...
    IDMTempl* pITemplate;
    hr = S_OK;
    hr = DirectMusicCreateInstance(CLSID_DMTempl,NULL,IID_IDMTempl,(void**)&pITemplate);
    if (SUCCEEDED(hr))
    {
        pITemplate->Init(pTemplate);
        hr = DirectMusicCreateInstance(CLSID_DirectMusicSegment,NULL,
                                    IID_IDirectMusicSegment,
                                    (void **) &ppTempSeg);
        if (SUCCEEDED(hr))
        {
            pITemplate->CreateSegment(*ppTempSeg);
        }
        pITemplate->Release();
    }
ON_END:
    for (short n = 0; n < 8; n++)
    {
        if (apTempl[n])
        {
            delete apTempl[n];
        }
    }
    return hr;
}

inline char ShiftRoot(DWORD dwScale, BYTE bRoot)
{
    switch (dwScale & 0xfff)
    {
    case 0x56b: bRoot += 1; break;  // C#
    case 0xad6: bRoot += 2; break;  // D
    case 0x5ad: bRoot += 3; break;  // D#

    case 0xb5a: bRoot += 4; break;  // E
    case 0x6b5: bRoot += 5; break;  // F
    case 0xd6a: bRoot += 6; break;  // F#
    case 0xad5: bRoot += 7; break;  // G

    case 0x5ab: bRoot += 8; break;  // G#
    case 0xb56: bRoot += 9; break;  // A
    case 0x6ad: bRoot += 10; break; // A#
    case 0xd5a: bRoot += 11; break; // B
    }

    return (char) (bRoot %= 12);
}

/* 
@method:(EXTERNAL) HRESULT | IDirectMusicComposer | ChangeChordMap |  Modifies the chords
and scale pattern of an existing section segment to reflect the new ChordMap.

@rdesc Returns:

@flag S_OK | Success.
@flag E_POINTER | Either <p pSectionSeg> or <p pChordMap> is not a valid pointer.

@comm 
*/
HRESULT CDMCompos::ChangeChordMap(
                    IDirectMusicSegment*        pSectionSeg, // @parm The section to change the ChordMap upon.
                    BOOL                        fTrackScale, // @parm If TRUE, does scale tracking.
                    IDirectMusicChordMap*   pChordMap // @parm The ChordMap to change the section.
            )
{
    V_INAME(IDirectMusicComposer::ChangeChordMap)
    V_PTR_WRITE(pSectionSeg, 1);
    V_PTR_WRITE(pChordMap, 1);

    HRESULT                 hr              = S_OK;
    IDMPers*                pDMP            = NULL;
    IDirectMusicTrack*      pChordTrack     = NULL;
    IDirectMusicStyle*      pStyle          = NULL;
    IPersistStream*         pPS             = NULL;
    IStream*                pStream         = NULL;
    IAARIFFStream*          pChordRIFF      = NULL;
    TList<PlayChord>        ChordList;
    BYTE                    bSectionRoot    = 0;
    DWORD                   dwSectionScale  = 0;
    TListItem<PlayChord>*   pChords         = NULL;
    DMPersonalityStruct*    pPers           = NULL;
    BYTE                    bNewRoot        = 0;
    DWORD                   dwNewScale      = 0;
    char                    chOffset        = 0;
    
    ENTER_CRITICAL_SECTION( &m_CriticalSection );
    pChordMap->QueryInterface(IID_IDMPers, (void**)&pDMP);
    pDMP->GetPersonalityStruct((void**)&pPers);
    if (!pPers)
    {
        Trace(1, "ERROR (ChangeChordMap): Chord map not properly initialized.\n");
        hr = DMUS_E_NOT_INIT;
        goto ON_END;
    }
    // Get the segment's chord track.
    hr = pSectionSeg->GetTrack(CLSID_DirectMusicChordTrack, ALL_TRACK_GROUPS, 0, &pChordTrack);
    if (S_OK != hr) goto ON_END;
    // Write the track to a stream, and read from the stream into a chord list.
    hr = CreateStreamOnHGlobal(NULL, TRUE, &pStream);
    if (S_OK != hr) goto ON_END;
    hr = pChordTrack->QueryInterface(IID_IPersistStream, (void**)&pPS);
    if (S_OK != hr) goto ON_END;    
    hr = pPS->Save(pStream, FALSE);
    if (S_OK != hr) goto ON_END;
    StreamSeek(pStream, 0, STREAM_SEEK_SET);
    LoadChordList(ChordList, pStream, bSectionRoot, dwSectionScale);
    bSectionRoot %= 24;

    pChordMap->GetScale(&dwNewScale);
    bNewRoot = (BYTE) (dwNewScale >> 24);
    dwNewScale &= 0xffffff;
    if (pPers->m_dwChordMapFlags & DMUS_CHORDMAPF_VERSION8)
    {
        BYTE bTempRoot = bSectionRoot % 12;
        if (bNewRoot < bTempRoot) bNewRoot += 12;
        chOffset = (bNewRoot - bTempRoot) % 12;
    }
    else
    {
        chOffset = ShiftRoot(dwNewScale, bNewRoot) - ShiftRoot(dwSectionScale, bSectionRoot);
    }
    // Modify the chords in the chord list to match the new personality's chord palette.
    for (pChords = ChordList.GetHead(); pChords; pChords = pChords->GetNext())
    {
        PlayChord& rChord = pChords->GetItemValue();
        char chRoot = rChord.GetRoot();
        if (fTrackScale)
        {
            chRoot += chOffset;
        }
        TListItem<DMChordData> *pPalette;
        char chNewRoot = chRoot - bSectionRoot;
        while (chNewRoot < 0) chNewRoot += 12;
        while (chNewRoot > 23) chNewRoot -= 12;
        pPalette = pPers->m_aChordPalette[chNewRoot].GetHead();
        if (!pPalette)
        {
            Trace(1, "ERROR (ChangeChordMap): No Chord Pallette for root %d.\n", chNewRoot);
            hr = E_POINTER;
            goto ON_END;
        }
        if (rChord.m_pChord)
        {
            rChord.m_pChord->Release();
            delete rChord.m_pChord;
        }
        rChord.m_pChord = new DMChordData(pPalette->GetItemValue());
        if (!rChord.m_pChord)
        {
            hr = E_OUTOFMEMORY;
            goto ON_END;
        }
    }
    pStream->Release();
    hr = CreateStreamOnHGlobal(NULL, TRUE, &pStream);
    if (S_OK != hr) goto ON_END;
    hr = AllocRIFFStream( pStream, &pChordRIFF);
    if (S_OK != hr) goto ON_END;
    // Get the segment's first style
    hr = GetStyle(pSectionSeg, 0, ALL_TRACK_GROUPS, pStyle, true);
    if (FAILED(hr)) goto ON_END;
    // Extract the style's time signature.
    DMUS_TIMESIGNATURE TimeSig;
    pStyle->GetTimeSignature(&TimeSig);
    SaveChordList(pChordRIFF, ChordList, bNewRoot, dwNewScale, TimeSig);
    pPS->Release();
    pPS = NULL;
    // Load the modified chord list into the chord track
    hr = pChordTrack->QueryInterface(IID_IPersistStream, (void**)&pPS);
    if (!SUCCEEDED(hr)) goto ON_END;
    StreamSeek(pStream, 0, STREAM_SEEK_SET);
    hr = pPS->Load(pStream);
ON_END:
    //ChordList.RemoveAll();
    Clear(ChordList);
    if (pPS)
    {
        pPS->Release();
    }
    if (pChordTrack)
    {
        pChordTrack->Release();
    }
    if (pChordRIFF)
    {
        pChordRIFF->Release();
    }
    if (pStyle)
    {
        pStyle->Release();
    }
    if (pStream) 
    {
        pStream->Release();
    }
    if (pDMP)
    {
        pDMP->Release();
    }
    CleanUp();
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return hr;
}

STDMETHODIMP CDMCompos::QueryInterface(
    const IID &iid, 
    void **ppv) 
{
    V_INAME(CDMCompos::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    *ppv = NULL;
    if (iid == IID_IUnknown || iid == IID_IDirectMusicComposer)
    {
        *ppv = static_cast<IDirectMusicComposer*>(this);
    }
    else if (iid == IID_IDirectMusicComposer8)
    {
        *ppv = static_cast<IDirectMusicComposer8*>(this);
        m_dwFlags |= COMPOSEF_USING_DX8;
    }
    else if (iid == IID_IDirectMusicComposer8P)
    {
        *ppv = static_cast<IDirectMusicComposer8P*>(this);
    }

    if (*ppv == NULL)
        return E_NOINTERFACE;

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CDMCompos::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CDMCompos::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        m_cRef = 100; // artificial reference count to prevent reentrency due to COM aggregation
        delete this;
        return 0;
    }

    return m_cRef;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmcompos\dmcompos.h ===
// DMCompos.h : Declaration of the CDMCompos
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// @doc EXTERNAL
//
// 

#ifndef __DMCOMPOS_H_
#define __DMCOMPOS_H_

#include "ComposIn.h"
#include "DMCompP.h"
#include "..\dmstyle\dmstyleP.h"
#include "..\shared\dmusicp.h"

#define SUBCHORD_STANDARD_CHORD 1
#define SUBCHORD_BASS 0

#define NC_SELECTED 1               // This is the active connector.
#define NC_PATH     2               // For walking the tree.
#define NC_NOPATH   4               // Failed tree walk.
#define NC_TREE     8               // For displaying a tree.

#define COMPOSEF_USING_DX8  1

inline WORD ClocksPerBeat(DMUS_TIMESIGNATURE& TimeSig)
{ return DMUS_PPQ * 4 / TimeSig.bBeat; }

inline DWORD ClocksPerMeasure(DMUS_TIMESIGNATURE& TimeSig)
{ return ClocksPerBeat(TimeSig) * TimeSig.bBeatsPerMeasure; }

inline WORD ClocksToMeasure(DWORD dwTotalClocks, DMUS_TIMESIGNATURE& TimeSig)
{ return (WORD) (dwTotalClocks / ClocksPerMeasure(TimeSig)); }

struct DMSignPostStruct
{
    MUSIC_TIME  m_mtTime;
    DWORD       m_dwChords;
    WORD        m_wMeasure;
};

struct DMExtendedChord
{
    DMExtendedChord() { m_nRefCount = 0; }
    void AddRef() { m_nRefCount++; }
    BOOL Release() { m_nRefCount--; if (m_nRefCount <= 0) { delete this; return TRUE; } else return FALSE; }
    BOOL    Equals(DMExtendedChord& rhsChord);  

    DWORD   m_dwChordPattern;
    DWORD   m_dwScalePattern;
    DWORD   m_dwInvertPattern;
    BYTE    m_bRoot;
    BYTE    m_bScaleRoot;
    WORD    m_wCFlags;
    DWORD   m_dwParts;
    int     m_nRefCount;
};

struct DMChordData
{
    DMChordData() : m_pSubChords(NULL) {}   // Default constructor
    DMChordData(DMChordData& rChord);       // Copy constructor
    DMChordData(DMUS_CHORD_PARAM& DMC);         // conversion from DMUS_CHORD_PARAM
    HRESULT Read(IAARIFFStream* pIRiffStream, MMCKINFO* pckParent, DMExtendedChord** apChordDB);
    void    Release();
    BOOL    Equals(DMChordData& rhsChord);  
    DWORD   GetChordPattern();
    char    GetRoot();
    void    SetRoot(char chNewRoot);

    String                          m_strName;      // Name of the chord
    TListItem<DMExtendedChord*>*        m_pSubChords;   // List of pointers to subchords of the chord
};

struct DMChordEntry;
struct SearchInfo; 

struct DMChordLink
{
    BOOL                        Walk(SearchInfo *pSearch);

    TListItem<DMChordEntry>*    m_pChord;   // pointer to an entry in the Chord Map list
    DWORD                       m_dwFlags;  // (?) 
    short                       m_nID;  // ID for matching up pointers
    WORD                        m_wWeight;      
    WORD                        m_wMinBeats;
    WORD                        m_wMaxBeats;
};

struct DMChordEntry
{
    TListItem<DMChordLink>* ChooseNextChord();
    BOOL                Walk(SearchInfo *pSearch);

    DWORD               m_dwFlags;      // Flags (first chord in path, last chord in path, etc.)
    short               m_nID;          // ID for matching up pointers
    DMChordData         m_ChordData;    // Chord body
    TList<DMChordLink>  m_Links;        // List of links from this chord
};

struct DMSignPost
{
    DWORD               m_dwChords; // Which kinds of signposts are supported.
    DWORD               m_dwFlags;
    DWORD               m_dwTempFlags;
    DMChordData         m_ChordData;
    DMChordData         m_aCadence[2];
};

struct PlayChord
{
    HRESULT Save(IAARIFFStream* pRIFF, DMUS_TIMESIGNATURE& rTimeSig);
    char GetRoot();
    void SetRoot(char chNewRoot);

    DMChordData*                m_pChord;       // Chord to perform.
    TListItem<DMChordLink>*     m_pNext;        // Next chord
    DWORD                       m_dwFlags;
    short                       m_nMeasure;
    short                       m_nBeat;
    short                       m_nMinbeats;
    short                       m_nMaxbeats;
    bool                        m_fSilent;
};

struct FailSearch
{
    FailSearch() : 
        m_nTooManybeats(0), m_nTooFewbeats(0), m_nTooManychords(0), m_nTooFewchords(0)
    {}

    short   m_nTooManybeats;
    short   m_nTooFewbeats;
    short   m_nTooManychords;
    short   m_nTooFewchords;
};

struct SearchInfo 
{
    SearchInfo() : m_pFirstChord(NULL), m_pPlayChord(NULL) {}

    //DMChordEntry              m_Start;
    //DMChordEntry              m_End;
    DMChordData                 m_Start;
    DMChordData                 m_End;
    TListItem<PlayChord>*       m_pPlayChord;
    TListItem<DMChordEntry>*    m_pFirstChord;
    short                       m_nBeats;
    short                       m_nMinBeats;
    short                       m_nMaxBeats;
    short                       m_nChords;
    short                       m_nMinChords;
    short                       m_nMaxChords;
    short                       m_nActivity;
    FailSearch                  m_Fail;
};

struct TemplateCommand
{
    TemplateCommand() : m_nMeasure(0), m_dwChord(0)
    { 
        m_Command.bCommand = m_Command.bGrooveLevel = m_Command.bGrooveRange = 0;
        m_Command.bRepeatMode = DMUS_PATTERNT_RANDOM;
    }
    short           m_nMeasure;    // Which measure
    DMUS_COMMAND_PARAM m_Command;    // Command type
    DWORD           m_dwChord;     // Signpost flags
};

struct CompositionCommand : TemplateCommand
{
    TListItem<DMSignPost>*      m_pSignPost;
    TListItem<DMChordEntry>*    m_pFirstChord;
    TList<PlayChord>            m_PlayList;
    SearchInfo                  m_SearchInfo;
};

/*
@interface IDirectMusicComposer | 
The <i IDirectMusicComposer> interface permits access to the Direct Music composition 
engine which 
composes chord progression to generate section segments. In addition to building new 
section segments from templates and personalities, it can generate transition segments to 
transition between different section segments. And, it can apply a ChordMap to an 
existing section segment to convert the chord progression to match the harmonic behavior 
of the ChordMap, a great way to alter the mood of a section while it plays.

The composition engine uses template segments or predefined shapes to determine the 
structure of the composed section segment and personalities to determine the content of 
the segment.


@base public | IUnknown

@meth HRESULT | ComposeSegmentFromTemplate | Creates an original section segment from a 
style, ChordMap and template.
@meth HRESULT | ComposeSegmentFromShape | Creates an original section segment from a 
style and ChordMap based on a predefined shape. 
@meth HRESULT | ComposeTransition |  Composes a transition from a measure inside one 
Section Segment to another.
@meth HRESULT | AutoTransition | Composes and performs a transition from one
Section Segment to another.
@meth HRESULT | ComposeTemplateFromShape | Allocates and composes a new template segment 
based on a predefined shape.
@meth HRESULT | ChangeChordMap | Modifies the chords and scale pattern of an existing 
section segment to reflect the new ChordMap.

*/

/////////////////////////////////////////////////////////////////////////////
// CDMCompos
class CDMCompos : 
    public IDirectMusicComposer8,
    public IDirectMusicComposer8P
{
friend class CSPstTrk;
public:
    CDMCompos();
    ~CDMCompos();

    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // IDirectMusicComposer
    HRESULT STDMETHODCALLTYPE ComposeSegmentFromTemplate(
                    IDirectMusicStyle*          pStyle, 
                    IDirectMusicSegment*        pTempSeg,   
                    WORD                        wActivity,
                    IDirectMusicChordMap*   pChordMap,
                    IDirectMusicSegment**       ppSectionSeg
            );

    HRESULT STDMETHODCALLTYPE ComposeSegmentFromShape(
                    IDirectMusicStyle*          pStyle, 
                    WORD                        wNumMeasures,
                    WORD                        wShape,
                    WORD                        wActivity,
                    BOOL                        fComposeIntro,
                    BOOL                        fComposeEnding,
                    IDirectMusicChordMap*   pChordMap,
                    IDirectMusicSegment**       ppSectionSeg
            );

    HRESULT STDMETHODCALLTYPE ComposeTransition(
                    IDirectMusicSegment*    pFromSeg, 
                    IDirectMusicSegment*    pToSeg,     
                    MUSIC_TIME              mtTime,
                    WORD                    wCommand,
                    DWORD                   dwFlags,
                    IDirectMusicChordMap*   pChordMap,
                    IDirectMusicSegment**   ppSectionSeg
            );

    HRESULT STDMETHODCALLTYPE AutoTransition(
                    IDirectMusicPerformance*    pPerformance,
                    IDirectMusicSegment*    pToSeg,     
                    WORD                    wCommand,
                    DWORD                   dwFlags,
                    IDirectMusicChordMap*   pChordMap,
                    IDirectMusicSegment**   ppTransSeg,
                    IDirectMusicSegmentState**  ppToSegState,
                    IDirectMusicSegmentState**  ppTransSegState
            );

    HRESULT STDMETHODCALLTYPE ComposeTemplateFromShape(
                    WORD                    wNumMeasures,
                    WORD                    wShape,
                    BOOL                    fComposeIntro,
                    BOOL                    fComposeEnding,
                    WORD                    wEndLength,
                    IDirectMusicSegment**   ppTempSeg   
            );

    HRESULT STDMETHODCALLTYPE ChangeChordMap(
                    IDirectMusicSegment*        pSectionSeg,
                    BOOL                        fTrackScale,
                    IDirectMusicChordMap*   pChordMap
            );

    // IDirectMusicComposer8
    HRESULT STDMETHODCALLTYPE ComposeSegmentFromTemplateEx(
                    IDirectMusicStyle*      pStyle, 
                    IDirectMusicSegment*    pTempSeg, 
                    DWORD                   dwFlags, // are we using activity levels?  
                                                     // Are we creating a new seg. or composing into the current one?
                    DWORD                   dwActivity,
                    IDirectMusicChordMap*   pChordMap, 
                    IDirectMusicSegment**   ppSectionSeg
            );

    HRESULT STDMETHODCALLTYPE ComposeTemplateFromShapeEx(
                WORD wNumMeasures,                  // Number of measures in template
                WORD wShape,                        // Shape for composition
                BOOL fIntro,                        // Compose an intro?
                BOOL fEnd,                          // Compose an ending?
                IDirectMusicStyle* pStyle,          // Style used for embellishment lengths
                IDirectMusicSegment** ppTemplate    // Template containing chord and command tracks
            );

protected: // member functions
    void CleanUp();
    void AddChord(DMChordData* pChord);
    TListItem<PlayChord> *AddChord(TList<PlayChord>& rList, DMChordData *pChord, int nMeasure,int nBeat);
    TListItem<PlayChord> *AddCadence(TList<PlayChord>& rList, DMChordData *pChord, int nMax);
    void ChordConnections(TList<DMChordEntry>& ChordMap, 
                             CompositionCommand& rCommand,
                             SearchInfo *pSearch,
                             short nBPM,
                             DMChordData *pCadence1,
                             DMChordData *pCadence2);
    void ChordConnections2(TList<DMChordEntry>& ChordMap, 
                             CompositionCommand& rCommand,
                             SearchInfo *pSearch,
                             short nBPM,
                             DMChordData *pCadence1,
                             DMChordData *pCadence2);
    void ComposePlayList(TList<PlayChord>& PlayList, 
                            IDirectMusicStyle* pStyle,  
                            IDirectMusicChordMap* pPersonality,
                            TList<TemplateCommand>& rCommandList,
                            WORD wActivity);
    void ComposePlayList2(TList<PlayChord>& PlayList, 
                            IDirectMusicStyle* pStyle,  
                            IDirectMusicChordMap* pPersonality,
                            TList<TemplateCommand>& rCommandList);
    HRESULT ComposePlayListFromShape(
                    long                    lNumMeasures,
                    WORD                    wShape,
                    BOOL                    fComposeIntro,
                    BOOL                    fComposeEnding,
                    int                     nIntroLength,
                    int                     nFillLength,
                    int                     nBreakLength,
                    int                     nEndLength,
                    IDirectMusicStyle*          pStyle, 
                    WORD                        wActivity,
                    IDirectMusicChordMap*   pPersonality,
                    TList<TemplateCommand>& CommandList,
                    TList<PlayChord>&       PlayList
                );
    BOOL Compose(TList<DMChordEntry>& ChordMap, 
                SearchInfo *pSearch, 
                CompositionCommand& rCommand);

    void JostleBack(TList<PlayChord>& rList, TListItem<PlayChord> *pChord, int nBeats);

    BOOL AlignChords(TListItem<PlayChord> *pChord,int nLastbeat,int nRes);

    void ChooseSignPosts(TListItem<DMSignPost> *pSignPostHead,
                            TListItem<CompositionCommand> *pTempCommand, DWORD dwType,
                            bool fSecondPass);

    TListItem<CompositionCommand> *GetNextChord(TListItem<CompositionCommand> *pCommand);

    void FindEarlierSignpost(TListItem<CompositionCommand> *pCommand, 
                         TListItem<CompositionCommand> *pThis,
                         SearchInfo *pSearch);

    void CleanUpBreaks(TList<PlayChord>& PlayList, TListItem<CompositionCommand> *pCommand);

    HRESULT GetStyle(IDirectMusicSegment* pFromSeg, MUSIC_TIME mt, DWORD dwGroupBits, IDirectMusicStyle*& rpStyle, bool fTryPattern);

    HRESULT GetPersonality(IDirectMusicSegment* pFromSeg, MUSIC_TIME mt, DWORD dwGroupBits, IDirectMusicChordMap*& rpPers);

    HRESULT ExtractCommandList(TList<TemplateCommand>& CommandList,
                               IDirectMusicTrack*   pSignPostTrack,
                               IDirectMusicTrack*   pCommandTrack,
                               DWORD dwGroupBits);

    HRESULT AddToSegment(IDirectMusicSegment* pTempSeg,
                           TList<PlayChord>& PlayList,
                           IDirectMusicStyle* pStyle,
                           DWORD dwGroupBits,
                           BYTE bRoot, DWORD dwScale);

    HRESULT CopySegment(IDirectMusicSegment* pTempSeg,
                           IDirectMusicSegment** ppSectionSeg,
                           TList<PlayChord>& PlayList,
                           IDirectMusicStyle* pStyle,
                           IDirectMusicChordMap* pChordMap,
                           BOOL fStyleFromTrack,
                           BOOL fChordMapFromTrack,
                           DWORD dwGroupBits,
                           BYTE bRoot, DWORD dwScale);

    HRESULT BuildSegment(TList<TemplateCommand>& CommandList,
                            TList<PlayChord>& PlayList, 
                            IDirectMusicStyle* pStyle,
                            IDirectMusicChordMap* pChordMap,
                            long lMeasures,
                            IDirectMusicSegment** ppSectionSeg,
                            BYTE bRoot, DWORD dwScale, 
                            double* pdblTempo = NULL,
                            IDirectMusicBand* pCurrentBand = NULL,
                            bool fAlign = false,
                            IDirectMusicGraph* pGraph = NULL,
                            IUnknown* pPath = NULL);

    HRESULT SaveChordList( IAARIFFStream* pRIFF,  TList<PlayChord>& rPlayList,
                             BYTE bRoot, DWORD dwScale, DMUS_TIMESIGNATURE& rTimeSig);
    HRESULT TransitionCommon(
                IDirectMusicStyle*      pFromStyle,
                IDirectMusicBand*       pCurrentBand,
                double*                 pdblFromTempo,
                DMUS_COMMAND_PARAM_2&   rFromCommand,
                DMUS_CHORD_PARAM&       rLastChord,
                DMUS_CHORD_PARAM&       rNextChord,

                IDirectMusicSegment*    pToSeg,
                WORD                    wCommand,
                DWORD                   dwFlags,
                IDirectMusicChordMap*   pChordMap,
                IDirectMusicGraph*      pFromGraph,
                IDirectMusicGraph*      pToGraph,
                IUnknown*               pFromPath,
                IUnknown*               pToPath,
                IDirectMusicSegment**   ppSectionSeg
            );

    HRESULT ComposeTemplateFromShapeInternal(
                    WORD                    wNumMeasures,
                    WORD                    wShape,
                    BOOL                    fComposeIntro,
                    BOOL                    fComposeEnding,
                    int                     nIntroLength,
                    int                     nBreakLength,
                    int                     nFillLength,
                    int                     nEndLength,
                    IDirectMusicSegment**   ppTempSeg
            );

    bool HasDX8Content(IDirectMusicStyle* pFromStyle, 
                    IDirectMusicChordMap* pFromChordMap = NULL, 
                    IDirectMusicSegment* pFromSegment = NULL,
                    DMUS_COMMAND_PARAM_2* pCommand = NULL,
                    DMUS_CHORD_PARAM* pLastChord = NULL)
    {
        // Currently this will return true if the Style is DX8.  Should be sufficient (when called from
        // AutoTransition, at least), since the style is primarily responsible for the way the transition 
        // will sound.
        bool fResult = false;
        IDMStyle* pDMStyle = NULL;
        if (pFromStyle && SUCCEEDED(pFromStyle->QueryInterface(IID_IDMStyle, (void**) &pDMStyle)))
        {
            if (pDMStyle->IsDX8() == S_OK) fResult = true;
            pDMStyle->Release();
        }
        return fResult;
    }

    bool UsingDX8(IDirectMusicStyle* pFromStyle = NULL, 
                    IDirectMusicChordMap* pFromChordMap = NULL, 
                    IDirectMusicSegment* pFromSegment = NULL,
                    DMUS_COMMAND_PARAM_2* pCommand = NULL,
                    DMUS_CHORD_PARAM* pLastChord = NULL)
    {
        return 
            (m_dwFlags & COMPOSEF_USING_DX8) || 
            HasDX8Content(pFromStyle, pFromChordMap, pFromSegment, pCommand, pLastChord);
    }

    TListItem<DMSignPost>* ChooseSignPost(
            IDirectMusicChordMap* pChordMap,
            DMChordData* pNextChord,
            bool fEnding,
            DWORD dwScale,
            BYTE bRoot);

    HRESULT ComposePlayListFromTemplate(IDirectMusicStyle* pStyle,
                                        IDirectMusicChordMap* pChordMap,
                                        IDirectMusicTrack* pChordMapTrack,
                                        IDirectMusicTrack* pSignPostTrack,
                                        IDirectMusicTrack* pCommandTrack,
                                        DWORD dwGroupBits,
                                        MUSIC_TIME mtLength,
                                        bool fUseActivity,
                                        DWORD dwActivity,
                                        TList<PlayChord>& rPlayList,
                                        BYTE& rbRoot,
                                        DWORD& rdwScale);

    IDirectMusicGraph* CloneSegmentGraph(IDirectMusicSegment* pSegment);
    IUnknown* GetSegmentAudioPath(IDirectMusicSegment* pSegment, DWORD dwFlags, DWORD* pdwAudioPath = NULL);


protected: // attributes
    long m_cRef;
    CMemTrack               m_MemTrack;             // For debug memory tracking.
    TListItem<DMChordData*>* m_pChords;
    DWORD                   m_dwFlags;              // variaous flags
    CRITICAL_SECTION        m_CriticalSection;      // for i/o
    BOOL                    m_fCSInitialized;
};

void ChangeCommand(DMUS_COMMAND_PARAM& rResult, DMUS_COMMAND_PARAM& rCommand, int nDirection);

#endif //__DMCOMPOS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmcompos\dmtempl.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       dmtempl.h
//
//--------------------------------------------------------------------------

// DMTempl.h : Declaration of the CDMTempl

#ifndef __DMTEMPL_H_
#define __DMTEMPL_H_

#include "DMCompos.h"

struct TemplateStruct
{
	void AddIntro(bool f1Bar, int nLength);
	void AddIntro(TList<PlayChord>& PlayList, int nIntroLength);
	void AddEnd(int nLength);
	void InsertCommand(TListItem<TemplateCommand> *pCommand, BOOL fIsCommand);
	void AddChord(int nMeasure, DWORD dwChord);
	void AddCommand(int nMeasure, DWORD dwCommand);
	void CreateSignPosts();
    void CreateEmbellishments(WORD shape, int nFillLength, int nBreakLength);
	void IncorporateTemplate(short nMeasure, TemplateStruct* pTemplate, short nDirection);
	void FillInGrooveLevels();

	String					m_strName;
	String					m_strType;
	short					m_nMeasures;
	TList<TemplateCommand>	m_CommandList;
};

/////////////////////////////////////////////////////////////////////////////
// CDMTempl
class CDMTempl : 
	public IDMTempl,
	public IPersistStream
{
public:
	CDMTempl();
	~CDMTempl();
	void CleanUp();
	HRESULT SaveCommandList( IAARIFFStream* pRIFF, DMUS_TIMESIGNATURE&	TimeSig );
	HRESULT SaveSignPostList( IAARIFFStream* pRIFF, DMUS_TIMESIGNATURE&	TimeSig );
	HRESULT LoadTemplate( LPSTREAM pStream, DWORD dwSize );
	HRESULT Init(TemplateStruct* pTemplate);

    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

// IDMTempl
public:
	HRESULT STDMETHODCALLTYPE CreateSegment(IDirectMusicSegment* pSegment);
	HRESULT STDMETHODCALLTYPE Init(void* pTemplate);

// IPersist
public:
    STDMETHOD(GetClassID)(THIS_ LPCLSID pclsid);

// IPersistStream
public:
    // Determines if the Style has been modified by simply checking the Style's m_fDirty flag.  This flag is cleared
    // when a Style is saved or has just been created.
    STDMETHOD(IsDirty)(THIS);
    // Loads a Style from a stream.
    STDMETHOD(Load)(THIS_ LPSTREAM pStream);
    // Saves a Style to a stream in RIFF format.
    STDMETHOD(Save)(THIS_ LPSTREAM pStream, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(THIS_ ULARGE_INTEGER FAR* pcbSize);

public: // attributes
    long m_cRef;
    CMemTrack               m_MemTrack;             // For debug memory tracking.
	BOOL					m_fDirty;				// has this been modified?
    CRITICAL_SECTION		m_CriticalSection;		// for i/o
    BOOL                    m_fCSInitialized;
	TemplateStruct*			m_pTemplateInfo;
};

#endif //__DMTEMPL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmcompos\iodmcomp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       iodmcomp.h
//
//--------------------------------------------------------------------------

#ifndef PERSONALITYRIFF_H
#define PERSONALITYRIFF_H


// runtime chunks
#define FOURCC_PERSONALITY	mmioFOURCC('D','M','P','R')
#define FOURCC_IOPERSONALITY		mmioFOURCC('p','e','r','h')
#define DM_FOURCC_GUID_CHUNK        mmioFOURCC('g','u','i','d')
#define DM_FOURCC_INFO_LIST	        mmioFOURCC('I','N','F','O')
#define DM_FOURCC_VERSION_CHUNK     mmioFOURCC('v','e','r','s')
#define FOURCC_SUBCHORD				mmioFOURCC('c','h','d','t')
#define FOURCC_CHORDENTRY			mmioFOURCC('c','h','e','h')
#define FOURCC_SUBCHORDID			mmioFOURCC('s','b','c','n')
#define FOURCC_IONEXTCHORD			mmioFOURCC('n','c','r','d')
#define FOURCC_NEXTCHORDSEQ		  mmioFOURCC('n','c','s','q')
#define FOURCC_IOSIGNPOST			mmioFOURCC('s','p','s','h')
#define FOURCC_CHORDNAME			mmioFOURCC('I','N','A','M')

// runtime list chunks
#define FOURCC_LISTCHORDENTRY		mmioFOURCC('c','h','o','e')
#define FOURCC_LISTCHORDMAP			mmioFOURCC('c','m','a','p')
#define FOURCC_LISTCHORD			mmioFOURCC('c','h','r','d')
#define FOURCC_LISTCHORDPALETTE		mmioFOURCC('c','h','p','l')
#define FOURCC_LISTCADENCE			mmioFOURCC('c','a','d','e')
#define FOURCC_LISTSIGNPOSTITEM			mmioFOURCC('s','p','s','t')

#define FOURCC_SIGNPOSTLIST		mmioFOURCC('s','p','s','q')


// constants
const int MaxSubChords = 4;

// simple riff read/writers
inline HRESULT ReadWord(IAARIFFStream* pIRiffStream, WORD& val)
{
	assert(pIRiffStream);
	IStream* pIStream = pIRiffStream->GetStream();
	assert(pIStream);
	if(pIStream)
	{
		HRESULT hr = pIStream->Read(&val, sizeof(WORD), 0);
		pIStream->Release();
		return hr;
	}
	else
	{
		return E_FAIL;
	}
}

class ReadChunk
{
	MMCKINFO m_ck;
	MMCKINFO* m_pckParent;
	IAARIFFStream* m_pRiffStream;
	HRESULT m_hr;
public:
	ReadChunk(IAARIFFStream* pRiffStream, MMCKINFO* pckParent) : m_pRiffStream(pRiffStream)
	{
		m_pckParent = pckParent;
		m_hr = pRiffStream->Descend( &m_ck,  m_pckParent, 0 );
	}
	~ReadChunk()
	{
		if(m_hr == 0)
		{
			m_hr = m_pRiffStream->Ascend(&m_ck, 0);
		}
	}
	HRESULT	State(MMCKINFO* pck=0)
	{
		if(pck)
		{
			memcpy(pck, &m_ck, sizeof(MMCKINFO));
		}
		return m_hr;
	}
	FOURCC Id()
	{
		if(m_ck.ckid = FOURCC_LIST)
		{
			return m_ck.fccType;
		}
		else
		{
			return m_ck.ckid;
		}
	}
};


// run time data structs
struct ioPersonality
{
	char	szLoadName[20];
	DWORD	dwScalePattern;
	DWORD	dwFlags;
};

struct ioSubChord
{
	DWORD	dwChordPattern;
	DWORD	dwScalePattern;
	DWORD	dwInvertPattern;
	BYTE	bChordRoot;
	BYTE	bScaleRoot;
	WORD	wCFlags;
	DWORD	dwLevels;	// parts or which subchord levels this chord supports
};

struct ioChordEntry
{
	DWORD	dwFlags;
	WORD	wConnectionID;	// replaces runtime "pointer to this"
};

struct ioNextChord
{
	DWORD	dwFlags;
	WORD	nWeight;
	WORD	wMinBeats;
	WORD	wMaxBeats;
	WORD	wConnectionID;	// points to an ioChordEntry
};

struct ioSignPost
{
	DWORD	dwChords;	// 1bit per group
	DWORD	dwFlags;
};

/*
RIFF
(
	'DMPR'
	<perh-ck>			// Personality header chunk
	[<guid-ck>]			// guid chunk
	[<vers-ck>]			// version chunk (two DWORDS)
	<INFO-list>		  // standard MS Info chunk
	<chdt-ck>		   // subchord database
	<chpl-list>			// chord palette
	<cmap-list>		  // chord map
	<spst-list>			// signpost list
	[<ceed-ck>]		// optional chordmap position data
 )

 <chdt> ::= chdt(<cbChordSize::WORD>  <ioSubChord> ... )

<chpl-list> ::= LIST('chpl' 
								<chrd-list> ... // chord definition
							 )

<chrd-list> ::= LIST('chrd' 
								<INAM-ck> // name of chord in wide char format
								<sbcn-ck>	// list of subchords composing chord
								[<ched-ck>]   //  optional chord edit flags
								)

<cmap-list> ::= LIST('cmap' <choe-list> )

<choe-list> ::= LIST('choe'
								<cheh-ck>	// chord entry data
								<chrd-list>	// chord definition
								<ncsq-ck>	// connecting(next) chords
								)

<spst-list> ::= LIST('spst'
							 <spsh-ck>
							 <chrd-list>
							 [<cade-list>]
							 )

<cade-list> ::= LIST('cade' <chrd-list> ...)
								
<sbcn-ck> ::= sbcn(<cSubChordID:WORD>)

<ceed-ck> ::= ceed(ioChordEntryEdit)

<ched-ck> ::= ched(DMChordEdit)

<cheh-ck> ::= cheh(i<ioChordEntry>)

<ncrd-ck> ::= ncrd(<ioNextChord>)

<ncsq-ck> ::= ncsq(<wNextChordSize:WORD> <ioNextChord>...)

<spsh-ck> ::= spsh(<ioSignPost>)

*/

struct ioDMSignPost
{
	MUSIC_TIME	m_mtTime;
	DWORD		m_dwChords;
	WORD		m_wMeasure;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmcompos\dmcmpdll.cpp ===
//
// dmcmpdll.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Note: Dll entry points as well as Class Factory implementations.
//

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

#include "pchcompos.h"

//////////////////////////////////////////////////////////////////////
// Globals

#ifdef DXAPI

// Version information 
//
TCHAR g_szComposerFriendlyName[]    = TEXT("DirectMusicComposer");
TCHAR g_szComposerVerIndProgID[]    = TEXT("Microsoft.DirectMusicComposer");
TCHAR g_szComposerProgID[]          = TEXT("Microsoft.DirectMusicComposer.1");

TCHAR g_szChordMapFriendlyName[]    = TEXT("DirectMusicChordMap");
TCHAR g_szChordMapVerIndProgID[]    = TEXT("Microsoft.DirectMusicChordMap");
TCHAR g_szChordMapProgID[]          = TEXT("Microsoft.DirectMusicChordMap.1");

TCHAR g_szChordMapTrackFriendlyName[]    = TEXT("DirectMusicChordMapTrack");
TCHAR g_szChordMapTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicChordMapTrack");
TCHAR g_szChordMapTrackProgID[]          = TEXT("Microsoft.DirectMusicChordMapTrack.1");

TCHAR g_szSignPostTrackFriendlyName[]    = TEXT("DirectMusicSignPostTrack");
TCHAR g_szSignPostTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicSignPostTrack");
TCHAR g_szSignPostTrackProgID[]          = TEXT("Microsoft.DirectMusicSignPostTrack.1");

TCHAR g_szTemplateFriendlyName[]    = TEXT("DirectMusicTemplate");
TCHAR g_szTemplateVerIndProgID[]    = TEXT("Microsoft.DirectMusicTemplate");
TCHAR g_szTemplateProgID[]          = TEXT("Microsoft.DirectMusicTemplate.1");

// Dll's hModule
//
HMODULE g_hModule = NULL;

// Count of active components and class factory server locks
//
long g_cComponent = 0;
long g_cLock = 0;

//////////////////////////////////////////////////////////////////////
// CDirectMusicPersonalityFactory::QueryInterface

HRESULT __stdcall
CDirectMusicPersonalityFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    V_INAME(CDirectMusicPersonalityFactory::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPersonalityFactory::AddRef

ULONG __stdcall
CDirectMusicPersonalityFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPersonalityFactory::Release

ULONG __stdcall
CDirectMusicPersonalityFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPersonalityFactory::CreateInstance

HRESULT __stdcall
CDirectMusicPersonalityFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    CDMPers *pDM;
    
    try
    {    
        pDM = new CDMPers;
    }
    catch( ... )
    {
        return E_OUTOFMEMORY;
    }
    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(iid, ppv);
    pDM->Release();
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPersonalityFactory::LockServer

HRESULT __stdcall
CDirectMusicPersonalityFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicComposerFactory::QueryInterface

HRESULT __stdcall
CDirectMusicComposerFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    V_INAME(CDirectMusicComposerFactory::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicComposerFactory::AddRef

ULONG __stdcall
CDirectMusicComposerFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicComposerFactory::Release

ULONG __stdcall
CDirectMusicComposerFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicComposerFactory::CreateInstance

HRESULT __stdcall
CDirectMusicComposerFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

//    DebugBreak();
    
    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    CDMCompos *pDM = new CDMCompos;
    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(iid, ppv);
    pDM->Release();
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicComposerFactory::LockServer

HRESULT __stdcall
CDirectMusicComposerFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicTemplateFactory::QueryInterface

HRESULT __stdcall
CDirectMusicTemplateFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    V_INAME(CDirectMusicTemplateFactory::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicTemplateFactory::AddRef

ULONG __stdcall
CDirectMusicTemplateFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicTemplateFactory::Release

ULONG __stdcall
CDirectMusicTemplateFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicTemplateFactory::CreateInstance

HRESULT __stdcall
CDirectMusicTemplateFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

//    DebugBreak();
    
    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    CDMTempl *pDM;

    try
    {
        pDM = new CDMTempl;
    }
    catch( ... )
    {
        return E_OUTOFMEMORY;
    }
    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(iid, ppv);
    pDM->Release();
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicTemplateFactory::LockServer

HRESULT __stdcall
CDirectMusicTemplateFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicSignPostTrackFactory::QueryInterface

HRESULT __stdcall
CDirectMusicSignPostTrackFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    V_INAME(CDirectMusicSignPostTrackFactory::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicSignPostTrackFactory::AddRef

ULONG __stdcall
CDirectMusicSignPostTrackFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicSignPostTrackFactory::Release

ULONG __stdcall
CDirectMusicSignPostTrackFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicSignPostTrackFactory::CreateInstance

HRESULT __stdcall
CDirectMusicSignPostTrackFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    CSPstTrk *pDM;

    try
    {
        pDM = new CSPstTrk;
    }
    catch( ... )
    {
        return E_OUTOFMEMORY;
    }
    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(iid, ppv);
    pDM->Release();
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicSignPostTrackFactory::LockServer

HRESULT __stdcall
CDirectMusicSignPostTrackFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPersonalityTrackFactory::QueryInterface

HRESULT __stdcall
CDirectMusicPersonalityTrackFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    V_INAME(CDirectMusicPersonalityTrackFactory::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPersonalityTrackFactory::AddRef

ULONG __stdcall
CDirectMusicPersonalityTrackFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPersonalityTrackFactory::Release

ULONG __stdcall
CDirectMusicPersonalityTrackFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPersonalityFactory::CreateInstance

HRESULT __stdcall
CDirectMusicPersonalityTrackFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    CPersonalityTrack *pDM;

    try
    {
        pDM = new CPersonalityTrack;
    }
    catch( ... )
    {
        return E_OUTOFMEMORY;
    }
    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(iid, ppv);
    pDM->Release();
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPersonalityTrackFactory::LockServer

HRESULT __stdcall
CDirectMusicPersonalityTrackFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}
#else
//////////////////////////////////////////////////////////////////////
// DirectMusicChordMapTrackCreate

STDAPI DirectMusicChordMapTrackCreate(REFIID iid, void ** ppDMT )
{
    HRESULT hr;
    CPersonalityTrack *pDM = new CPersonalityTrack;
    if (!pDM) 
    {
        return E_OUTOFMEMORY;
    }
    hr = pDM->QueryInterface(iid, ppDMT);
    pDM->Release();
    return hr;

}

//////////////////////////////////////////////////////////////////////
// DirectMusicChordMapCreate

STDAPI DirectMusicChordMapCreate(REFIID iid, void ** ppChordMap )
{
    HRESULT hr;
    CDMPers *pDM = new CDMPers;
    if (!pDM ) 
    {
        return E_OUTOFMEMORY;
    }
    hr = pDM->QueryInterface(iid, ppChordMap);
    pDM->Release();
    return hr;
}

//////////////////////////////////////////////////////////////////////
// DirectMusicSignPostTrackCreate

STDAPI DirectMusicSignPostTrackCreate(REFIID iid, void ** ppChordMap )
{
    HRESULT hr;
    CSPstTrk *pDM = new CSPstTrk;
    if (!pDM) 
    {
        return E_OUTOFMEMORY;
    }
    hr = pDM->QueryInterface(iid, ppChordMap);
    pDM->Release();
    return hr;
}

//////////////////////////////////////////////////////////////////////
// DirectMusicTemplCreate

STDAPI DirectMusicTemplCreate(REFIID iid, void ** ppDMTempl )
{
    HRESULT hr;
    CDMTempl *pDM = new CDMTempl;
    if (!pDM) 
    {
        return E_OUTOFMEMORY;
    }
    hr = pDM->QueryInterface(iid, ppDMTempl);
    pDM->Release();
    return hr;
}

//////////////////////////////////////////////////////////////////////
// DirectMusicComposerCreate

STDAPI DirectMusicComposerCreate(REFIID iid, void ** ppDMComp8 )
{
    HRESULT hr;
    CDMCompos *pDM = new CDMCompos;
    if (!pDM) 
    {
        return E_OUTOFMEMORY;
    }
    hr = pDM->QueryInterface(iid, ppDMComp8);
    pDM->Release();
    return hr;
}

#endif

#ifdef DXAPI

//////////////////////////////////////////////////////////////////////
// Standard calls needed to be an inproc server

//////////////////////////////////////////////////////////////////////
// DllCanUnloadNow

STDAPI DllCanUnloadNow()
{
    if (g_cComponent || g_cLock) {
        return S_FALSE;
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// DllGetClassObject

STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
	IUnknown* pIUnknown = NULL;

    if(clsid == CLSID_DirectMusicChordMap)
    {

		pIUnknown = static_cast<IUnknown*> (new CDirectMusicPersonalityFactory);
        if(!pIUnknown) 
        {
			return E_OUTOFMEMORY;
        }
    }
    else if(clsid == CLSID_DirectMusicComposer) 
    {
        pIUnknown = static_cast<IUnknown*> (new CDirectMusicComposerFactory);
        if(!pIUnknown) 
        {
			return E_OUTOFMEMORY;
        }
    }
    else if(clsid == CLSID_DMTempl) 
    {
        pIUnknown = static_cast<IUnknown*> (new CDirectMusicTemplateFactory);
        if(!pIUnknown) 
        {
			return E_OUTOFMEMORY;
        }
    }
    else if(clsid == CLSID_DirectMusicSignPostTrack) 
    {
        pIUnknown = static_cast<IUnknown*> (new CDirectMusicSignPostTrackFactory);
        if(!pIUnknown) 
        {
			return E_OUTOFMEMORY;
        }
    }
    else if(clsid == CLSID_DirectMusicChordMapTrack) 
    {
        pIUnknown = static_cast<IUnknown*> (new CDirectMusicPersonalityTrackFactory);
        if(!pIUnknown) 
        {
			return E_OUTOFMEMORY;
        }
    }
    else
    {
		return CLASS_E_CLASSNOTAVAILABLE;
	}

    HRESULT hr = pIUnknown->QueryInterface(iid, ppv);
    pIUnknown->Release();

    return hr;
}

//////////////////////////////////////////////////////////////////////
// DllUnregisterServer

STDAPI DllUnregisterServer()
{
    UnregisterServer(CLSID_DirectMusicChordMap,
                     g_szChordMapFriendlyName,
                     g_szChordMapVerIndProgID,
                     g_szChordMapProgID);

    UnregisterServer(CLSID_DirectMusicComposer,
                     g_szComposerFriendlyName,
                     g_szComposerVerIndProgID,
                     g_szComposerProgID);

    UnregisterServer(CLSID_DMTempl,
                     g_szTemplateFriendlyName,
                     g_szTemplateVerIndProgID,
                     g_szTemplateProgID);

    UnregisterServer(CLSID_DirectMusicSignPostTrack,
                     g_szSignPostTrackFriendlyName,
                     g_szSignPostTrackVerIndProgID,
                     g_szSignPostTrackProgID);
 
	UnregisterServer(CLSID_DirectMusicChordMapTrack,
                     g_szChordMapTrackFriendlyName,
                     g_szChordMapTrackVerIndProgID,
                     g_szChordMapTrackProgID);


    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// DllRegisterServer

STDAPI DllRegisterServer()
{
    RegisterServer(g_hModule,
                   CLSID_DirectMusicChordMap,
                     g_szChordMapFriendlyName,
                     g_szChordMapVerIndProgID,
                     g_szChordMapProgID);

    RegisterServer(g_hModule,
                   CLSID_DirectMusicComposer,
                     g_szComposerFriendlyName,
                     g_szComposerVerIndProgID,
                     g_szComposerProgID);

    RegisterServer(g_hModule,
                   CLSID_DMTempl,
                     g_szTemplateFriendlyName,
                     g_szTemplateVerIndProgID,
                     g_szTemplateProgID);

    RegisterServer(g_hModule,
                   CLSID_DirectMusicSignPostTrack,
                     g_szSignPostTrackFriendlyName,
                     g_szSignPostTrackVerIndProgID,
                     g_szSignPostTrackProgID);

    RegisterServer(g_hModule,
                   CLSID_DirectMusicChordMapTrack,
                     g_szChordMapTrackFriendlyName,
                     g_szChordMapTrackVerIndProgID,
                     g_szChordMapTrackProgID);

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Standard Win32 DllMain

//////////////////////////////////////////////////////////////////////
// DllMain

#ifdef DBG
static char* aszReasons[] =
{
    "DLL_PROCESS_DETACH",
    "DLL_PROCESS_ATTACH",
    "DLL_THREAD_ATTACH",
    "DLL_THREAD_DETACH"
};
const DWORD nReasons = (sizeof(aszReasons) / sizeof(char*));
#endif

BOOL APIENTRY DllMain(HINSTANCE hModule,
                      DWORD dwReason,
                      void *lpReserved)
{
    static int nReferenceCount = 0;

#ifdef DBG
    if (dwReason < nReasons)
    {
        TraceI(0, "DllMain: %s\n", (LPSTR)aszReasons[dwReason]);
    }
    else
    {
        TraceI(0, "DllMain: Unknown dwReason <%u>\n", dwReason);
    }
#endif

    switch(dwReason)
    {
        case DLL_PROCESS_ATTACH:
            if (++nReferenceCount == 1)
            {
                #ifdef DBG
                    DebugInit();
                #endif

                if (!DisableThreadLibraryCalls(hModule))
                {
                    TraceI(0, "DisableThreadLibraryCalls failed.\n");
                }

                g_hModule = hModule;

            }
			break;


#ifdef DBG
        case DLL_PROCESS_DETACH:
            if (--nReferenceCount == 0)
            {
                TraceI(-1, "Unloading g_cLock %d  g_cComponent %d\n", g_cLock, g_cComponent);
                
                // Assert if we still have some objects hanging around
                assert(g_cComponent == 0);
                assert(g_cLock == 0);
            }

            break;
#endif  
            
    }
        
    return TRUE;
}

#endif // !XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmcompos\memstm.h ===
//
//  Based on source from Win2k ole32.dll
//

#pragma once

#include <sem.hxx>

/*
 * MemStm APIs
 */

STDAPI_(void) 		ReleaseMemStm(LPHANDLE phMem, BOOL fInternalOnly);

//+-------------------------------------------------------------------------
//
//  Class:  	MEMSTM
//
//  Purpose:    A structure to describe the global memroy
//
//  Interface:
//
//  History:    dd-mmm-yy Author    Comment
//		09-Nov-93 alexgo    32bit port
//
//  Notes:
//
// cRef counts all CMemStm pointers to this MEMSTM plus the number of times
// a hMem handle to MEMSTM had been returned
//
//--------------------------------------------------------------------------

struct MEMSTM
{     	// Data in shared memory
    	DWORD  cb;              // Size of hGlobal
    	DWORD  cRef;            // See below
#ifdef NOTSHARED
    	HANDLE hGlobal;         // The data
#else
	BYTE * m_pBuf;
	HANDLE hGlobal;
#endif
	
	BOOL   fDeleteOnRelease;
};

#define STREAM_SIG (0x4d525453L)

//+-------------------------------------------------------------------------
//
//  Class: 	CMemStm
//
//  Purpose:    IStream on memory (shared mem for win16)
//
//  Interface:  IStream
//
//  History:    dd-mmm-yy Author    Comment
//		02-Dec-93 alexgo    32bit port
//
//  Notes:
//
// CMemStm is a stream implementation on top of global shared memory MEMSTM
//
// CMemStm
// +---------+
// + pvtf    +    Shared  memory
// +---------+   +--------------+
// + m_pMem  +-->|cb            |
// +---------+   |cRef          |
//               |hGlobal       |--->+--------------+
//               +--------------+	 | Actual Data	|
// CMemStm             MEMSTM		 +--------------+
//--------------------------------------------------------------------------
class FAR CMemStm : public IStream
{
public:
	STDMETHOD(QueryInterface) (REFIID iidInterface, void **ppvObj);
    	STDMETHOD_(ULONG,AddRef) (void);
    	STDMETHOD_(ULONG,Release) (void);
    	STDMETHOD(Read) (VOID HUGEP* pv, ULONG cb, ULONG FAR* pcbRead);
	STDMETHOD(Write) (VOID const HUGEP* pv, ULONG cb, ULONG *pcbWritten);
    	STDMETHOD(Seek) (LARGE_INTEGER dlibMove, DWORD dwOrigin,
			 ULARGE_INTEGER *plibNewPosition);
    	STDMETHOD(SetSize) (ULARGE_INTEGER cb);
	STDMETHOD(CopyTo) (IStream *pstm, ULARGE_INTEGER cb,
			ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
    	STDMETHOD(Commit) (DWORD grfCommitFlags);
    	STDMETHOD(Revert) (void);
    	STDMETHOD(LockRegion) (ULARGE_INTEGER libOffset, ULARGE_INTEGER cb,
    			DWORD dwLockType);
    	STDMETHOD(UnlockRegion) (ULARGE_INTEGER libOffset, ULARGE_INTEGER cb,
    			DWORD dwLockType);
	STDMETHOD(Stat) (STATSTG *pstatstg, DWORD statflag);
	STDMETHOD(Clone)(IStream **ppstm);

    	static CMemStm FAR* Create(HANDLE hMem);

	CMemStm();
	~CMemStm();

private:
 	DWORD 		m_dwSig;	// Signature indicating this is our
					// implementation of
					// IStream: STREAM_SIG
    	ULONG 		m_refs;  	// Number of references to this CmemStm
    	ULONG 		m_pos;   	// Seek pointer for Read/Write
    	HANDLE 		m_hMem; 	// Memory Handle passed on creation
    	MEMSTM 		FAR* m_pData;   // Pointer to that memroy
	CMutexSem	m_mxs;		// mutex for MultiThread protection
};


=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmcompos\oledll.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       oledll.h
//
//--------------------------------------------------------------------------

//
//
//
#ifndef _OLEDLL_
#define _OLEDLL_

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID);

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID);

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue);
				 
HRESULT CLSIDToStr(const CLSID &clsid,
				   TCHAR *szStr,
				   int cbStr);

HRESULT StrToCLSID(TCHAR *szStr,
				   CLSID &clsid,
				   int cbStr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmcompos\pchcompos.h ===
#include "DMCompos.h"
#include "debug.h"
#include "DMPers.h"
#ifdef XBOX
#include <xtl.h>
#else
#include <objbase.h>
#endif
#include <ole2.h>
#include "memstm.h"
#include "..\shared\critsec.h"
#include "..\shared\validate.h"
#include "..\shared\dmscriptautguids.h"
#include <time.h>   // to seed random number generator
#include "debug.h"
#include "..\shared\oledll.h"
#include "dmusicip.h"
#include "DMCompP.h"
#include "dmpers.h"
#include "dmcompos.h"
#include "dmtempl.h"
#include "spsttrk.h"
#include "perstrk.h"
#include "..\dmstyle\iostru.h"
#include "..\dmime\dmgraph.h"
#include "..\shared\xcreate.h"
#include "..\shared\Validate.h"
#include "..\shared\miscutil.h"
#include "..\dmstyle\dmstyleP.h"
#include "..\dmime\dmgraph.h"
#include "dmusicf.h"
#include "str.h"

#ifdef XBOX
#define CreateStreamOnHGlobal DMusic_CreateStreamOnHGlobal
STDAPI DMusic_CreateStreamOnHGlobal(HANDLE hGlobal, BOOL fDeleteOnRelease,
        LPSTREAM FAR* ppstm);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmcompos\perstrk.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       perstrk.h
//
//--------------------------------------------------------------------------

// PersTrk.h : Declaration of the CPersonalityTrack

#ifndef __PERSONALITYTRACK_H_
#define __PERSONALITYTRACK_H_

#include "dmusicip.h"
#include "DMCompos.h"

struct StampedPersonality
{
	StampedPersonality() { m_pPersonality = NULL; }
	~StampedPersonality() { if (m_pPersonality) m_pPersonality->Release(); }
	MUSIC_TIME				m_mtTime;
	IDirectMusicChordMap*	m_pPersonality;
};

/////////////////////////////////////////////////////////////////////////////
// CPersonalityTrack
class CPersonalityTrack : 
	public IPersistStream,
	public IDirectMusicTrack8
{
public:
	CPersonalityTrack();
	CPersonalityTrack(const CPersonalityTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd);
	~CPersonalityTrack();
	HRESULT LoadPersRefList( IAARIFFStream* pIRiffStream, MMCKINFO* pckParent );
	HRESULT LoadPersRef( IAARIFFStream* pIRiffStream, MMCKINFO* pckParent );
	HRESULT LoadReference(IStream *pStream,
						  IAARIFFStream *pIRiffStream,
						  MMCKINFO& ckParent,
						  IDirectMusicChordMap** ppPersonality);

public:
    // IUnknown
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

// IDirectMusicTrack Methods
HRESULT STDMETHODCALLTYPE Init(
				/*[in]*/  IDirectMusicSegment*		pSegment
			);

HRESULT STDMETHODCALLTYPE InitPlay(
				/*[in]*/  IDirectMusicSegmentState*	pSegmentState,
				/*[in]*/  IDirectMusicPerformance*	pPerformance,
				/*[out]*/ void**					ppStateData,
				/*[in]*/  DWORD						dwTrackID,
                /*[in]*/  DWORD                     dwFlags
			);

HRESULT STDMETHODCALLTYPE EndPlay(
				/*[in]*/  void*						pStateData
			);

HRESULT STDMETHODCALLTYPE Play(
				/*[in]*/  void*						pStateData, 
				/*[in]*/  MUSIC_TIME				mtStart, 
				/*[in]*/  MUSIC_TIME				mtEnd, 
				/*[in]*/  MUSIC_TIME				mtOffset,
						  DWORD						dwFlags,
						  IDirectMusicPerformance*	pPerf,
						  IDirectMusicSegmentState*	pSegState,
						  DWORD						dwVirtualID
			);

HRESULT STDMETHODCALLTYPE GetPriority( 
				/*[out]*/ DWORD*					pPriority 
			);

HRESULT STDMETHODCALLTYPE GetParam(
				REFGUID						rCommandGuid,
				MUSIC_TIME					mtTime, 
				MUSIC_TIME*					pmtNext,
				void*						pData
			);

	HRESULT STDMETHODCALLTYPE SetParam( 
		/* [in] */ REFGUID						rCommandGuid,
		/* [in] */ MUSIC_TIME mtTime,
		/* [out] */ void __RPC_FAR *pData);

	HRESULT STDMETHODCALLTYPE AddNotificationType(
				/* [in] */  REFGUID						rGuidNotify
			);

	HRESULT STDMETHODCALLTYPE RemoveNotificationType(
				/* [in] */  REFGUID						rGuidNotify
			);

	HRESULT STDMETHODCALLTYPE Clone(
		MUSIC_TIME mtStart,
		MUSIC_TIME mtEnd,
		IDirectMusicTrack** ppTrack);

// IDirectMusicCommon Methods
HRESULT STDMETHODCALLTYPE GetName(
				/*[out]*/  BSTR*		pbstrName
			);

HRESULT STDMETHODCALLTYPE IsParamSupported(
				/*[in]*/ REFGUID						rGuid
			);

// IPersist methods
 HRESULT STDMETHODCALLTYPE GetClassID( LPCLSID pclsid );

// IPersistStream methods
 HRESULT STDMETHODCALLTYPE IsDirty();

HRESULT STDMETHODCALLTYPE Save( LPSTREAM pStream, BOOL fClearDirty );

HRESULT STDMETHODCALLTYPE GetSizeMax( ULARGE_INTEGER* /*pcbSize*/ );

HRESULT STDMETHODCALLTYPE Load( LPSTREAM pStream );

// IDirectMusicTrack8 Methods
    STDMETHODIMP PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf, 
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) ; 
    STDMETHODIMP GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) ; 
    STDMETHODIMP SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,void* pParam, void * pStateData, DWORD dwFlags) ;
    STDMETHODIMP Compose(IUnknown* pContext, 
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;
    STDMETHODIMP Join(IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;

protected:
// internal methods
/*
	HRESULT SendNotification(MUSIC_TIME mtTime,
						 IDirectMusicPerformance*	pPerf,
						 IDirectMusicSegment* pSegment,
						 IDirectMusicSegmentState*	pSegState,
						 DWORD dwFlags);
*/

    HRESULT JoinInternal(IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		DWORD dwTrackGroup);

// attributes
    long m_cRef;
	TList<StampedPersonality>	m_PersonalityList;
    CRITICAL_SECTION			m_CriticalSection; // for load and GetParam
    BOOL                        m_fCSInitialized;
//  BOOL                        m_fNotifyRecompose;

	BYTE						m_bRequiresSave;
    CMemTrack                   m_MemTrack;             // For debug memory tracking.
};

#endif //__PERSONALITYTRACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmcompos\dmpers.cpp ===
// DMPers.cpp : Implementation of CDMPers
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// @doc EXTERNAL
//
// 
//

#include "pchcompos.h"


V_INAME(DMCompose)

/////////////////////////////////////////////////////////////////////////////
// ReadMBSfromWCS

void ReadMBSfromWCS( IStream* pIStream, DWORD dwSize, String& pstrText )
{
    HRESULT     hr = S_OK;
    wchar_t*    wstrText = NULL;
    DWORD       dwBytesRead;
    
    pstrText = "";
    
    wstrText = new wchar_t[dwSize];
    if( wstrText == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto ON_ERR;
    }

    hr = pIStream->Read( wstrText, dwSize, &dwBytesRead );
    if( FAILED( hr )
    ||  dwBytesRead != dwSize )
    {
        goto ON_ERR;
    }

    pstrText = wstrText;
    
ON_ERR:
    if( wstrText )
        delete [] wstrText;
}

/////////// Utility functions for chords //////////////////

static BYTE setchordbits( long lPattern )
{
LONG    i;
short   count = 0;
BYTE bBits = 0;

    for( i=0L ;  i<32L ;  i++ )
    {
        if( lPattern & (1L << i) )
            count++;
    }
    bBits |= CHORD_INVERT;
    if( count > 3 )
        bBits |= CHORD_FOUR;
    if( lPattern & (15L << 18L) )
        bBits |= CHORD_UPPER;
    bBits &= ~CHORD_COUNT;
    bBits |= count;
    return bBits;
}

// returns TRUE if the chord pattern represents a multichord, FALSE otherwise
inline BOOL MultiChord(DWORD dwPattern)
{
    BYTE bBits = setchordbits( dwPattern );
    short nChordCount = bBits & CHORD_COUNT;
    return !((bBits & CHORD_FOUR && nChordCount <= 4) || 
             (!(bBits & CHORD_FOUR) && nChordCount <= 3));
}

TListItem<DMExtendedChord*>* ConvertChord(
    DWORD dwChordPattern, BYTE bChordRoot, DWORD dwScalePattern, BYTE bScaleRoot)
{ 
    BYTE bBits = setchordbits( dwChordPattern );
    short nChordCount = bBits & CHORD_COUNT;
    // The root of the lower chord is the input chord's root, 
    // relative to the scale root.
    bChordRoot -= bScaleRoot;
    if (bChordRoot < 0) bChordRoot += 12;
    if ((bBits & CHORD_FOUR && nChordCount <= 4) || 
        (!(bBits & CHORD_FOUR) && nChordCount <= 3))
    {
        // single subchord with all info from input chord
        TListItem<DMExtendedChord*>* pSubChord = new TListItem<DMExtendedChord*>;
        if ( pSubChord == NULL ) return NULL;
        DMExtendedChord* pNew = new DMExtendedChord;
        if (!pNew) return NULL;
        DMExtendedChord*& rSubChord = pSubChord->GetItemValue();
        rSubChord = pNew;
        rSubChord->m_dwChordPattern = dwChordPattern;
        rSubChord->m_dwScalePattern = dwScalePattern;
        rSubChord->m_dwInvertPattern = 0xffffff;    // default: inversions everywhere
        rSubChord->m_bRoot = bChordRoot;
        rSubChord->m_bScaleRoot = bScaleRoot;
        rSubChord->m_wCFlags = 0;
        // A single subchord can be used as either a bass or standard chord
        rSubChord->m_dwParts = (1 << SUBCHORD_BASS) | (1 << SUBCHORD_STANDARD_CHORD);
        rSubChord->AddRef();
        return pSubChord;
    }
    else
    {
        // two subchords both with scale and roots from input chord, and:
        // 1st chord: chord pattern from lower n notes of input chord
        // 2nd chord: chord pattern from upper n notes of input chord
        DWORD dwLowerSubChord = 0L;
        DWORD dwUpperSubChord = 0L;
        BYTE bUpperRoot = bChordRoot;
        DWORD dwPattern = dwChordPattern;
        short nIgnoreHigh = (bBits & CHORD_FOUR) ? 4 : 3;
        short nIgnoreLow = (bBits & CHORD_FOUR) ? nChordCount - 4 : nChordCount - 3;
        short nLowestUpper = 0;
        for (short nPos = 0, nCount = 0; nPos < 24; nPos++)
        {
            if (dwPattern & 1)
            {
                if (nCount < nIgnoreHigh)
                {
                    dwLowerSubChord |= 1L << nPos;
                }
                if (nCount >= nIgnoreLow)
                {
                    if (!nLowestUpper)
                    {
                        nLowestUpper = nPos;
                        bUpperRoot = (bUpperRoot + (BYTE) nLowestUpper);
                    }
                    dwUpperSubChord |= 1L << (nPos - nLowestUpper);
                }
                nCount++;
                if (nCount >= nChordCount)
                    break;
            }
            dwPattern >>= 1L;
        }
        // now, create the two subchords.
        TListItem<DMExtendedChord*>* pLowerSubChord = new TListItem<DMExtendedChord*>;
        if ( pLowerSubChord == NULL ) return NULL;
        DMExtendedChord* pLower = new DMExtendedChord;
        if (!pLower) return NULL;
        DMExtendedChord*& rLowerSubChord = pLowerSubChord->GetItemValue();
        rLowerSubChord = pLower;
        rLowerSubChord->m_dwChordPattern = dwLowerSubChord;
        rLowerSubChord->m_dwScalePattern = dwScalePattern;
        rLowerSubChord->m_dwInvertPattern = 0xffffff;   // default: inversions everywhere
        rLowerSubChord->m_bRoot = bChordRoot;
        rLowerSubChord->m_bScaleRoot = bScaleRoot;
        rLowerSubChord->m_wCFlags = 0;
        rLowerSubChord->m_dwParts = (1 << SUBCHORD_BASS); // the lower chord is the bass chord
        TListItem<DMExtendedChord*>* pUpperSubChord = new TListItem<DMExtendedChord*>;
        if ( pUpperSubChord == NULL ) return NULL;
        DMExtendedChord* pUpper = new DMExtendedChord;
        if (!pUpper) return NULL;
        DMExtendedChord*& rUpperSubChord = pUpperSubChord->GetItemValue();
        rUpperSubChord = pUpper;
        rUpperSubChord->m_dwChordPattern = dwUpperSubChord;
        rUpperSubChord->m_dwScalePattern = dwScalePattern;
        rUpperSubChord->m_dwInvertPattern = 0xffffff;   // default: inversions everywhere
        rUpperSubChord->m_bRoot = bUpperRoot % 24;
        while (rUpperSubChord->m_bRoot < rLowerSubChord->m_bRoot)
            rUpperSubChord->m_bRoot += 12;
        rUpperSubChord->m_bScaleRoot = bScaleRoot;  
        rUpperSubChord->m_wCFlags = 0;
        rUpperSubChord->m_dwParts = (1 << SUBCHORD_STANDARD_CHORD); // the upper chord is the standard chord
        rLowerSubChord->AddRef();
        rUpperSubChord->AddRef();
        return pLowerSubChord->Cat(pUpperSubChord);
    }
}

/////////////////////////////////////////////////////////////////////////////
// CDMPers

CDMPers::CDMPers( ) : m_cRef(1), m_fCSInitialized(FALSE), m_MemTrack(DMTRACK_CHORDMAP)
{
    IncrementDLLCount();

    // Do this first since it might throw an exception
    //
    INITIALIZE_CRITICAL_SECTION( &m_CriticalSection );
    m_fCSInitialized = TRUE;

    m_PersonalityInfo.m_fLoaded = false;
    ZeroMemory(&m_PersonalityInfo.m_guid, sizeof(GUID));
}

CDMPers::~CDMPers()
{
    if (m_fCSInitialized)
    {
        CleanUp();
        DELETE_CRITICAL_SECTION( &m_CriticalSection );
    }

    DecrementDLLCount();
}

void CDMPers::CleanUp()
{
    m_PersonalityInfo.m_fLoaded = false;
    ZeroMemory(&m_PersonalityInfo.m_guid, sizeof(GUID));
    TListItem<DMChordEntry>* pEntry = m_PersonalityInfo.m_ChordMap.GetHead(); 
    for(; pEntry; pEntry=pEntry->GetNext())
    {
        pEntry->GetItemValue().m_ChordData.Release();
    }
    m_PersonalityInfo.m_ChordMap.CleanUp();
    for (short i = 0; i < 24; i++)
    {
        TListItem<DMChordData>* pData = m_PersonalityInfo.m_aChordPalette[i].GetHead(); 
        for(; pData; pData=pData->GetNext())
        {
            pData->GetItemValue().Release();
        }
        m_PersonalityInfo.m_aChordPalette[i].CleanUp();
    }
    TListItem<DMSignPost>* pSignPost = m_PersonalityInfo.m_SignPostList.GetHead();
    for (; pSignPost != NULL; pSignPost = pSignPost->GetNext())
    {
        DMSignPost& rSignPost = pSignPost->GetItemValue();
        rSignPost.m_ChordData.Release();
        rSignPost.m_aCadence[0].Release();
        rSignPost.m_aCadence[1].Release();
    }
    m_PersonalityInfo.m_SignPostList.CleanUp();
}

STDMETHODIMP CDMPers::QueryInterface(
    const IID &iid, 
    void **ppv) 
{
    V_INAME(CDMPers::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    *ppv = NULL;
    if (iid == IID_IUnknown || iid == IID_IDirectMusicChordMap)
    {
        *ppv = static_cast<IDirectMusicChordMap*>(this);
    }
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else if (iid == IID_IDirectMusicObject)
    {
        *ppv = static_cast<IDirectMusicObject*>(this);
    }
    else if (iid == IID_IDMPers)
    {
        *ppv = static_cast<IDMPers*>(this);
    }

    if (*ppv == NULL)
        return E_NOINTERFACE;

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CDMPers::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CDMPers::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        m_cRef = 100; // artificial reference count to prevent reentrency due to COM aggregation
        delete this;
        return 0;
    }

    return m_cRef;
}


HRESULT CDMPers::GetPersonalityStruct(void** ppPersonality)
{
    if (ppPersonality)
        *ppPersonality = &m_PersonalityInfo;
    return S_OK;
}

HRESULT CDMPers::GetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CDMPers::GetDescriptor);
    V_PTR_WRITE(pDesc, DMUS_OBJECTDESC); 

    ENTER_CRITICAL_SECTION( &m_CriticalSection );
    ZeroMemory(pDesc, sizeof(DMUS_OBJECTDESC));
    pDesc->dwSize = sizeof(DMUS_OBJECTDESC);
    pDesc->dwValidData = DMUS_OBJ_CLASS;
    pDesc->guidClass = CLSID_DirectMusicChordMap;
    if (m_PersonalityInfo.m_fLoaded)
    {
        pDesc->dwValidData |= DMUS_OBJ_LOADED;
    }
    if (m_PersonalityInfo.m_guid.Data1 || m_PersonalityInfo.m_guid.Data2)
    {
        pDesc->dwValidData |= DMUS_OBJ_OBJECT;
        pDesc->guidObject = m_PersonalityInfo.m_guid;
    }
    if (m_PersonalityInfo.m_strName)
    {
        pDesc->dwValidData |= DMUS_OBJ_NAME;
        wcscpy(pDesc->wszName, m_PersonalityInfo.m_strName);
        //MultiByteToWideChar( CP_ACP, 0, m_PersonalityInfo.m_strName, -1, pDesc->wszName, DMUS_MAX_NAME);
    }
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return S_OK;
}

HRESULT CDMPers::SetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CDMPers::SetDescriptor);
    V_PTR_WRITE(pDesc, DMUS_OBJECTDESC); 

    HRESULT hr = E_INVALIDARG;
    DWORD dw = 0;

    ENTER_CRITICAL_SECTION( &m_CriticalSection );
    if( pDesc->dwSize >= sizeof(DMUS_OBJECTDESC) )
    {
        if( pDesc->dwValidData & DMUS_OBJ_OBJECT )
        {
            m_PersonalityInfo.m_guid = pDesc->guidObject;
            dw |= DMUS_OBJ_OBJECT;
        }
        if( pDesc->dwValidData & DMUS_OBJ_NAME )
        {
            m_PersonalityInfo.m_strName = pDesc->wszName;
            dw |= DMUS_OBJ_NAME;
        }
        if( pDesc->dwValidData & (~dw) )
        {
            Trace(2, "WARNING: SetDescriptor (chord map): Descriptor contains fields that were not set.\n");
            hr = S_FALSE; // there were extra fields we didn't parse;
            pDesc->dwValidData = dw;
        }
        else
        {
            hr = S_OK;
        }
    }
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return hr;
}

HRESULT CDMPers::ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CDMPers::ParseDescriptor);
    V_INTERFACE(pStream);
    V_PTR_WRITE(pDesc, DMUS_OBJECTDESC); 

    IAARIFFStream*  pIRiffStream;
    MMCKINFO        ckMain;
    HRESULT hr = S_OK;
    DWORD dwPos;

    dwPos = StreamTell( pStream );

    BOOL fFoundFormat = FALSE;

    // Check for Direct Music format
    hr = AllocRIFFStream( pStream, &pIRiffStream );
    if( SUCCEEDED( hr ) )
    {
        ckMain.fccType = DMUS_FOURCC_CHORDMAP_FORM;

        if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
        {
            hr = DM_ParseDescriptor( pIRiffStream, &ckMain, pDesc );
            fFoundFormat = TRUE;
        }
        pIRiffStream->Release();
    }
    else
    {
        return hr;
    }
#ifdef DXAPI
    // Check for IMA 2.5 format
    if( !fFoundFormat )
    {
        FOURCC      id;
        Prsonality  personality;
        DWORD       dwSize;
        StreamSeek( pStream, dwPos, STREAM_SEEK_SET );
        if( FAILED( pStream->Read( &id, sizeof( FOURCC ), NULL ) ) ||
            !GetMLong( pStream, dwSize ) )
        {
            Trace(1, "ERROR: ParseDescriptor (chord map): File does not contain a valid chord map.\n");
            return DMUS_E_CHUNKNOTFOUND;
        }
        if( id != mmioFOURCC( 'R', 'E', 'P', 's' ) )
        {
            Trace(1, "ERROR: ParseDescriptor (chord map): File does not contain a valid chord map.\n");
            return DMUS_E_CHUNKNOTFOUND;
        }

        pDesc->dwValidData = DMUS_OBJ_CLASS;
        pDesc->guidClass = CLSID_DirectMusicChordMap;

        GetMLong( pStream, dwSize );
        if( SUCCEEDED( pStream->Read( &personality, min( sizeof(Prsonality), dwSize ), NULL ) ) )
        {
            MultiByteToWideChar( CP_ACP, 0, personality.name, -1, pDesc->wszName, DMUS_MAX_NAME);
            if (pDesc->wszName[0])
            {
                pDesc->dwValidData |= DMUS_OBJ_NAME;
            }
        }
    }
#endif
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IDirectMusicPersonality

/* 
@method:(EXTERNAL) HRESULT | IDirectMusicPersonality | GetScale | Retrieves the scale
associated with the personality.

@rdesc Returns:

@flag S_OK | Success.
@flag E_POINTER | <p pdwScale> is not a valid pointer.

@comm The scale is defined by the bits in a DWORD, split into a scale pattern (lower 24 bits)
and a root (upper 8 bits) For the scale pattern, the low bit (0x0001) is the lowest note in the
scale, the next higher (0x0002) is a semitone higher, etc. for two octaves.  The root is
represented as a number between 0 and 23, where 0 represents a low C, 1 represents the
C# above that, etc. for two octaves.

*/
 
HRESULT CDMPers::GetScale(
                    DWORD *pdwScale // @parm The scale value to be returned.
                )
{
    V_PTR_WRITE(pdwScale, sizeof(DWORD) );
    *pdwScale = m_PersonalityInfo.m_dwScalePattern;
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CDMPers::GetClassID( LPCLSID pclsid )
{
    if ( pclsid == NULL ) return E_INVALIDARG;
    *pclsid = CLSID_DirectMusicChordMap;
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// IPersistStream

HRESULT CDMPers::IsDirty()
{
    return ( m_fDirty ) ? S_OK : S_FALSE;
}

HRESULT CDMPers::Save( LPSTREAM /*pStream*/, BOOL /*fClearDirty*/ )
{
    return E_NOTIMPL;
}

HRESULT CDMPers::GetSizeMax( ULARGE_INTEGER FAR* /*pcbSize*/ )
{
    return E_NOTIMPL;
}

HRESULT CDMPers::Load( LPSTREAM pStream )
{
    DWORD dwPos;
    IAARIFFStream*  pIRiffStream;
    MMCKINFO        ckMain;
    HRESULT hr = E_FAIL;

    if ( pStream == NULL ) return E_INVALIDARG;
    ENTER_CRITICAL_SECTION( &m_CriticalSection );
    CleanUp();

    dwPos = StreamTell( pStream );

    BOOL fFoundFormat = FALSE;

    // Check for Direct Music format
    if( SUCCEEDED( AllocRIFFStream( pStream, &pIRiffStream ) ) )
    {
        ckMain.fccType = DMUS_FOURCC_CHORDMAP_FORM;

        if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
        {
            hr = DM_LoadPersonality( pIRiffStream, &ckMain );
            fFoundFormat = TRUE;
        }
        pIRiffStream->Release();
    }
#ifdef DXAPI
    // Check for IMA 2.5 format
    if( !fFoundFormat )
    {
        FOURCC id;
        DWORD dwSize;
        StreamSeek( pStream, dwPos, STREAM_SEEK_SET );
        if( FAILED( pStream->Read( &id, sizeof( FOURCC ), NULL ) ) ||
            !GetMLong( pStream, dwSize ) )
        {
            Trace(1, "ERROR: Load (chord map): File does not contain a valid chord map.\n");
            hr = DMUS_E_CHUNKNOTFOUND;
            goto end;
        }
        if( id != mmioFOURCC( 'R', 'E', 'P', 's' ) )
        {
            Trace(1, "ERROR: Load (chord map): File does not contain a valid chord map.\n");
            hr = DMUS_E_CHUNKNOTFOUND;
            goto end;
        }
        hr = LoadPersonality( pStream, dwSize );
    }
end:
#endif
    if (SUCCEEDED(hr)) m_PersonalityInfo.m_fLoaded = true;
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return hr;
}

static LPSINEPOST loadasignpost( LPSTREAM pStream, DWORD dwSize )
{
    LPSINEPOST signpost;

    signpost = new SinePost;
    if( signpost == NULL )
    {
        StreamSeek( pStream, dwSize, STREAM_SEEK_CUR );
        return NULL;
    }

    if( dwSize > sizeof(SinePost) )
    {
        pStream->Read( signpost, sizeof(SinePost), NULL );
        FixBytes( FBT_SINEPOST, signpost );
        StreamSeek( pStream, dwSize - sizeof(SinePost), STREAM_SEEK_CUR );
    }
    else
    {
        pStream->Read( signpost, dwSize, NULL );
        FixBytes( FBT_SINEPOST, signpost );
    }
    signpost->pNext = 0;
    signpost->chord.pNext      = 0;
    signpost->cadence[0].pNext = 0;
    signpost->cadence[1].pNext = 0;

    return signpost;
}


static LPNEXTCHRD loadnextchords( LPSTREAM pStream, DWORD dwSiz )
{
    HRESULT hr = S_OK;
    LPNEXTCHRD nextchordlist = NULL;
    LPNEXTCHRD nextchord;
    DWORD      nodesize = 0;
    long lSize = dwSiz;

    if (!GetMLong( pStream, nodesize ))
    {
        StreamSeek( pStream, lSize, STREAM_SEEK_CUR );
        return NULL;
    }

    lSize -= 4;

    while( lSize > 0 )
    {
        nextchord = new NextChrd;
        if( nextchord == NULL )
        {
            StreamSeek( pStream, lSize, STREAM_SEEK_CUR );
            break;
        }

        if( nodesize > NEXTCHORD_SIZE )
        {
            hr = pStream->Read( &nextchord->dwflags, NEXTCHORD_SIZE, NULL );
            FixBytes( FBT_NEXTCHRD, nextchord );
            StreamSeek( pStream, nodesize - NEXTCHORD_SIZE, STREAM_SEEK_CUR );
        }
        else
        {
            pStream->Read( &nextchord->dwflags, nodesize, NULL );
            FixBytes( FBT_NEXTCHRD, nextchord );
        }
        lSize -= nodesize;

        if (SUCCEEDED(hr))
        {
            nextchord->pNext = 0;
            nextchordlist = List_Cat( nextchordlist, nextchord );
        }
        else 
        {
            delete nextchord;
            StreamSeek( pStream, lSize, STREAM_SEEK_CUR );
            break;
        }
    }

    return nextchordlist;
}

static LPCHRDENTRY loadachordentry( LPSTREAM pStream, DWORD dwSiz )
{
    LPCHRDENTRY chordentry;
    DWORD       csize = 0;
    DWORD       segsize = 0;
    DWORD       id;
    long lSize = dwSiz;

    chordentry = new ChrdEntry;
    if( chordentry == NULL )
    {
        StreamSeek( pStream, lSize, STREAM_SEEK_CUR );
        return NULL;
    }

    if (!GetMLong( pStream, csize ))
    {
        StreamSeek( pStream, lSize, STREAM_SEEK_CUR );
        delete chordentry;
        return NULL;
    }
    
    lSize -= 4;
    if( csize > CHORDENTRY_SIZE )
    {
        pStream->Read( &chordentry->chord.time, CHORDENTRY_SIZE, NULL );
        FixBytes( FBT_CHRDENTRY, chordentry );
        StreamSeek( pStream, csize - CHORDENTRY_SIZE, STREAM_SEEK_CUR );
    }
    else
    {
        pStream->Read( &chordentry->chord.time, csize, NULL );
        FixBytes( FBT_CHRDENTRY, chordentry );
    }
    lSize -= csize;
    chordentry->pNext = 0;
    chordentry->nextchordlist = 0;
    chordentry->chord.pNext    = 0;

    while( lSize > 0 )
    {
        pStream->Read( &id, sizeof(id), NULL );
        if (!GetMLong( pStream, segsize ))
        {
            StreamSeek( pStream, lSize, STREAM_SEEK_CUR );
            break;
        }

        lSize   -= 8;

        switch( id )
        {
        case mmioFOURCC( 'L', 'X', 'N', 's' ):
            chordentry->nextchordlist = loadnextchords( pStream, segsize );
            break;
        default:
            StreamSeek( pStream, segsize, STREAM_SEEK_CUR );
            break;
        }

        lSize -= segsize;
    }

    return chordentry;
}

void DMPersonalityStruct::ResolveConnections( LPPERSONALITY personality, short nCount )
{
    LPCHRDENTRY entry;
    LPNEXTCHRD  nextchord;

    if (nCount == 0)
    {
        return;
    }
    // nCount is the largest index, so the array needs to be one more than that
    TListItem<DMChordEntry> **ChordMap = new TListItem<DMChordEntry> *[nCount + 1]; 
    if (!ChordMap) return;

    for( entry=personality->chordlist ;  entry ;  entry=entry->pNext )
    {
        TListItem<DMChordEntry>* pEntry = new TListItem<DMChordEntry>;
        if (!pEntry)
        {
            delete [] ChordMap;
            return;
        }
        DMChordEntry& rEntry = pEntry->GetItemValue();
        rEntry.m_dwFlags = entry->dwflags;
        rEntry.m_ChordData.m_strName = entry->chord.name;
        rEntry.m_ChordData.m_pSubChords = ConvertChord(
            entry->chord.pattern, entry->chord.root, entry->chord.scalepattern, 0);
        m_ChordMap.AddHead(pEntry);
        ChordMap[entry->nid] = pEntry;
        nextchord = entry->nextchordlist;
        for( ;  nextchord ;  nextchord=nextchord->pNext )
        {
            if( nextchord->nid )
            {
                TListItem<DMChordLink>* pLink = new TListItem<DMChordLink>;
                if (!pLink)
                {
                    delete [] ChordMap;
                    return;
                }
                DMChordLink& rLink = pLink->GetItemValue();
                rLink.m_wWeight = nextchord->nweight;       
                rLink.m_wMinBeats = nextchord->nminbeats;
                rLink.m_wMaxBeats = nextchord->nmaxbeats;
                rLink.m_dwFlags = nextchord->dwflags;
                rLink.m_nID = nextchord->nid;
                rEntry.m_Links.AddHead(pLink);
            }
        }
    }

    for(TListItem<DMChordEntry>* pEntry=m_ChordMap.GetHead(); pEntry; pEntry=pEntry->GetNext())
    {
        TListItem<DMChordLink>* pLink = pEntry->GetItemValue().m_Links.GetHead();
        for( ;  pLink ;  pLink = pLink->GetNext() )
        {
            DMChordLink& rLink = pLink->GetItemValue();
            if( rLink.m_nID )
            {
                rLink.m_pChord = ChordMap[rLink.m_nID];
            }
        }
    }
    delete [] ChordMap;
}

HRESULT CDMPers::LoadPersonality( LPSTREAM pStream, DWORD dwSiz )
{
    short         i;
    LPPERSONALITY personality;
    LPCHRDENTRY   chordentry;
    LPSINEPOST    signpost;
    DWORD         csize = 0;
    DWORD         segsize = 0;
    FOURCC        id;
    short         nCount = 0;
    long lSize = dwSiz;
    HRESULT hr = S_OK;

    if ( pStream == NULL ) return E_INVALIDARG;
    personality = new Prsonality;
    if( personality == NULL )
    {
        StreamSeek( pStream, lSize, STREAM_SEEK_CUR );
        return E_OUTOFMEMORY;
    }
    if (!GetMLong( pStream, csize ))
    {
        StreamSeek( pStream, lSize, STREAM_SEEK_CUR );
        delete personality;
        return E_FAIL;
    }

    lSize -= 4;
    if( csize > sizeof(Prsonality) )
    {
        pStream->Read( personality, sizeof(Prsonality), NULL );
        FixBytes( FBT_PRSONALITY, personality );
        StreamSeek( pStream, csize - sizeof(Prsonality), STREAM_SEEK_CUR );
    }
    else
    {
        pStream->Read( personality, csize, NULL );
        FixBytes( FBT_PRSONALITY, personality );
    }
    lSize -= csize;
    m_PersonalityInfo.m_strName = personality->name;
    m_PersonalityInfo.m_dwScalePattern = personality->scalepattern;
    personality->pNext         = NULL;
    personality->dwAA         = 0;
    personality->chordlist    = NULL;
    personality->signpostlist = NULL;
    personality->playlist     = 0;
    personality->firstchord   = NULL;
    for( i=0 ;  i<24 ;  i++ )
    {
        TListItem<DMChordData>* pPaletteEntry = new TListItem<DMChordData>;
        if (!pPaletteEntry)
        {
            hr = E_OUTOFMEMORY;
            StreamSeek( pStream, lSize, STREAM_SEEK_CUR );
            break;
        }
        DMChordData& rChordData = pPaletteEntry->GetItemValue();
        rChordData.m_strName = personality->chord[i].achName;
        rChordData.m_pSubChords = ConvertChord(
            personality->chord[i].lPattern, personality->chord[i].chRoot, 
            personality->chord[i].lScalePattern, 0);
        m_PersonalityInfo.m_aChordPalette[i].AddTail(pPaletteEntry);
        personality->chord[i].pNext = 0;
    }

    if (SUCCEEDED(hr))
    {
        while( lSize > 0 )
        {
            pStream->Read( &id, sizeof(id), NULL );
            if (!GetMLong( pStream, segsize ))
            {
                StreamSeek( pStream, lSize, STREAM_SEEK_CUR );
                break;
            }

            lSize   -= 8;

            switch( id )
            {
            case mmioFOURCC( 'N', 'E', 'C', 's' ):
                chordentry = loadachordentry( pStream, segsize );
                if( chordentry )
                {
                    personality->chordlist = List_Cat( personality->chordlist, chordentry );
                    if (chordentry->nid > nCount)
                        nCount = chordentry->nid;
                }
                break;

            case mmioFOURCC( 'P', 'N', 'S', 's' ):
                signpost = loadasignpost( pStream, segsize );
                if( signpost )
                {
                    personality->signpostlist = List_Cat( personality->signpostlist, signpost );
                    TListItem<DMSignPost>* pSignPost = new TListItem<DMSignPost>;
                    if (!pSignPost)
                    {
                        hr = E_OUTOFMEMORY;
                        StreamSeek( pStream, segsize, STREAM_SEEK_CUR );
                        break;
                    }
                    DMSignPost& rSignPost = pSignPost->GetItemValue();
                    rSignPost.m_dwChords = signpost->chords;
                    rSignPost.m_dwFlags = signpost->flags;
                    rSignPost.m_dwTempFlags = signpost->tempflags;
                    rSignPost.m_ChordData.m_strName = signpost->chord.name;
                    rSignPost.m_ChordData.m_pSubChords = ConvertChord(
                        signpost->chord.pattern, signpost->chord.root, 
                        signpost->chord.scalepattern, 0);
                    rSignPost.m_aCadence[0].m_strName = signpost->cadence[0].name;
                    rSignPost.m_aCadence[0].m_pSubChords = ConvertChord(
                        signpost->cadence[0].pattern, signpost->cadence[0].root, 
                        signpost->cadence[0].scalepattern, 0);
                    rSignPost.m_aCadence[1].m_strName = signpost->cadence[1].name;
                    rSignPost.m_aCadence[1].m_pSubChords = ConvertChord(
                        signpost->cadence[1].pattern, signpost->cadence[1].root, 
                        signpost->cadence[1].scalepattern, 0);
                    m_PersonalityInfo.m_SignPostList.AddTail(pSignPost);
               }
                break;

            default:
                StreamSeek( pStream, segsize, STREAM_SEEK_CUR );
                break;
            }

            lSize   -= segsize;
        }
    }

    if (SUCCEEDED(hr))
    {
        m_PersonalityInfo.ResolveConnections( personality, nCount );
    }

    // free up all the old format data structures
    LPCHRDENTRY pChord;
    LPNEXTCHRD  pNextChord;
    LPNEXTCHRD  pNextNextChord;
    for( pChord = personality->chordlist ; pChord != NULL ; pChord = pChord->pNext )
    {
        for( pNextChord = pChord->nextchordlist ; pNextChord != NULL ;  pNextChord = pNextNextChord )
        {
            pNextNextChord = pNextChord->pNext;
            delete pNextChord;
        }
    }
    List_Free( personality->chordlist );
    List_Free( personality->signpostlist );
    delete personality;

    return hr;
}

HRESULT CDMPers::DM_ParseDescriptor( IAARIFFStream* pIRiffStream, MMCKINFO* pckMain, LPDMUS_OBJECTDESC pDesc  )
{
    IStream*            pIStream;
    MMCKINFO            ck;
    DWORD               dwByteCount;
    DWORD               dwSize;
    HRESULT             hr = S_OK;

    pIStream = pIRiffStream->GetStream();
    if ( pIStream == NULL ) return E_FAIL;

    pDesc->dwValidData = DMUS_OBJ_CLASS;
    pDesc->guidClass = CLSID_DirectMusicChordMap;

    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
    {
        switch( ck.ckid )
        {
            case DMUS_FOURCC_IOCHORDMAP_CHUNK:
            {
                DMUS_IO_CHORDMAP iPersonality;
                dwSize = min( ck.cksize, sizeof( DMUS_IO_CHORDMAP ) );
                hr = pIStream->Read( &iPersonality, dwSize, &dwByteCount );
                if( FAILED( hr ) ||  dwByteCount != dwSize )
                {
                    Trace(1, "ERROR: ParseDescriptor (chord map): DMUS_FOURCC_IOCHORDMAP_CHUNK chunk does not contain a valid DMUS_IO_CHORDMAP.\n");
                    hr = DMUS_E_CHUNKNOTFOUND;
                    goto ON_END;
                }
                wcscpy(pDesc->wszName, iPersonality.wszLoadName);
                if(pDesc->wszName[0])
                {
                    pDesc->dwValidData |= DMUS_OBJ_NAME;
                    pDesc->wszName[16] = 0;
                }
                break;
            }

            case DMUS_FOURCC_GUID_CHUNK:
                dwSize = min( ck.cksize, sizeof( GUID ) );
                hr = pIStream->Read( &pDesc->guidObject, dwSize, &dwByteCount );
                if( FAILED( hr ) ||  dwByteCount != dwSize )
                {
                    Trace(1, "ERROR: ParseDescriptor (chord map): DMUS_FOURCC_GUID_CHUNK chunk does not contain a valid GUID.\n");
                    hr = DMUS_E_CHUNKNOTFOUND;
                    goto ON_END;

                }
                pDesc->dwValidData |= DMUS_OBJ_OBJECT;
                break;
        }

        pIRiffStream->Ascend( &ck, 0 );
    }

ON_END:
    pIStream->Release();
    return hr;
}

HRESULT CDMPers::DM_LoadPersonality( IAARIFFStream* pIRiffStream, MMCKINFO* pckMain )
{
    IStream*            pIStream;
    MMCKINFO            ck;
    MMCKINFO            ck1;
    MMCKINFO            ckList;
    DWORD               dwByteCount;
    DWORD               dwSize;
    DWORD               dwPos;
    HRESULT             hr = S_OK;
    DMExtendedChord**   apChordDB = NULL;
    short nCount = 0;

    pIStream = pIRiffStream->GetStream();
    if ( pIStream == NULL ) return E_FAIL;

    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
    {
        switch( ck.ckid )
        {
            case DMUS_FOURCC_IOCHORDMAP_CHUNK:
            {
                DMUS_IO_CHORDMAP iPersonality;
                ZeroMemory(&iPersonality, sizeof(DMUS_IO_CHORDMAP));
                iPersonality.dwScalePattern = 0xffffffff;
                dwSize = min( ck.cksize, sizeof( DMUS_IO_CHORDMAP ) );
                hr = pIStream->Read( &iPersonality, dwSize, &dwByteCount );
                if( FAILED( hr ) ||  dwByteCount != dwSize )
                {
                    Trace(1, "ERROR: Load (chord map): DMUS_FOURCC_IOCHORDMAP_CHUNK chunk does not contain a valid DMUS_IO_CHORDMAP.\n");
                    if (SUCCEEDED(hr)) hr = DMUS_E_CANNOTREAD;
                    goto ON_END;
                }
                if( iPersonality.dwFlags & 0xffff0000 )
                {
                    // the scale was not properly initialized
                    Trace(2, "WARNING: Load (chord map): The chord map's flags are not properly initialized; clearing flags.\n");
                    iPersonality.dwFlags = 0;
                }
                if( !(iPersonality.dwFlags & DMUS_CHORDMAPF_VERSION8) && 
                    iPersonality.dwScalePattern >> 24 )
                {
                    // the scale was not properly initialized
                    Trace(1, "ERROR: Load (chord map): The chord map's scale is not properly initialized.\n");
                    hr = DMUS_E_NOT_INIT;
                    goto ON_END;
                }
                m_PersonalityInfo.m_strName = iPersonality.wszLoadName;
                m_PersonalityInfo.m_dwScalePattern = iPersonality.dwScalePattern;
                m_PersonalityInfo.m_dwChordMapFlags = iPersonality.dwFlags;
                break;
            }

            case DMUS_FOURCC_GUID_CHUNK:
                dwSize = min( ck.cksize, sizeof( GUID ) );
                hr = pIStream->Read( &m_PersonalityInfo.m_guid, dwSize, &dwByteCount );
                if( FAILED( hr ) ||  dwByteCount != dwSize )
                {
                    Trace(1, "ERROR: Load (chord map): DMUS_FOURCC_GUID_CHUNK chunk does not contain a valid GUID.\n");
                    if (SUCCEEDED(hr)) hr = DMUS_E_CANNOTREAD;
                    goto ON_END;
                }
                break;

            case DMUS_FOURCC_SUBCHORD_CHUNK:
            {
                long lFileSize = ck.cksize;
                WORD wSize;
                DWORD cb;
                hr = pIStream->Read( &wSize, sizeof( wSize ), &cb );
                if (FAILED(hr) || cb != sizeof( wSize ) ) 
                {
                    Trace(1, "ERROR: Load (chord map): DMUS_FOURCC_SUBCHORD_CHUNK chunk does not contain a valid size DWORD.\n");
                    if (SUCCEEDED(hr)) hr = DMUS_E_CANNOTREAD;
                    pIRiffStream->Ascend( &ck, 0 );
                    goto ON_END;
                }
                lFileSize -= cb;
                TList<DMExtendedChord*> ChordList;
                while (lFileSize > 0)
                {
                    DMUS_IO_PERS_SUBCHORD iSubChord;
                    hr = pIStream->Read( &iSubChord, wSize, &cb );
                    if (FAILED(hr) || cb !=  wSize ) 
                    {
                        Trace(1, "ERROR: Load (chord map): DMUS_FOURCC_SUBCHORD_CHUNK chunk does not contain a valid DMUS_IO_PERS_SUBCHORD.\n");
                        if (SUCCEEDED(hr)) hr = DMUS_E_CANNOTREAD;
                        pIRiffStream->Ascend( &ck, 0 );
                        goto ON_END;
                    }
                    // stuff the data into a subchord struct and add it to the chord list
                    // (in reverse order)
                    TListItem<DMExtendedChord*>* pChordItem = new TListItem<DMExtendedChord*>;
                    if (pChordItem)
                    {
                        DMExtendedChord*& rpChord = pChordItem->GetItemValue();
                        rpChord = new DMExtendedChord;
                        if (rpChord)
                        {
                            rpChord->m_dwChordPattern = iSubChord.dwChordPattern;
                            rpChord->m_dwScalePattern = iSubChord.dwScalePattern;
                            rpChord->m_dwInvertPattern = iSubChord.dwInvertPattern;
                            rpChord->m_bRoot = iSubChord.bChordRoot;
                            rpChord->m_bScaleRoot = iSubChord.bScaleRoot;
                            rpChord->m_wCFlags = iSubChord.wCFlags;
                            rpChord->m_dwParts = iSubChord.dwLevels;
                            nCount++;
                            ChordList.AddHead(pChordItem);
                        }
                        else
                        {
                            delete pChordItem;
                            pChordItem = NULL;
                        }
                    }
                    if (!pChordItem)
                    {
                        hr = E_OUTOFMEMORY;
                        goto ON_END;
                    }
                    lFileSize -= wSize;
                }
                if (lFileSize != 0 )
                {
                    hr = E_FAIL;
                    pIRiffStream->Ascend( &ck, 0 );
                    goto ON_END;
                }
                // now that the chord list is complete, transfer the pointers into the
                // chord db (back to front to reinstate original order)
                apChordDB = new DMExtendedChord*[nCount];
                if (apChordDB)
                {
                    TListItem<DMExtendedChord*>* pScan = ChordList.GetHead();
                    for (short nChord = nCount - 1; nChord >= 0; nChord--)
                    {
                        apChordDB[nChord] = pScan->GetItemValue();
                        pScan = pScan->GetNext();
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                    pIRiffStream->Ascend( &ck, 0 );
                    goto ON_END;
                }
                break;
            }
            case FOURCC_LIST:
                ck1 = ck;
                ckList = ck;
                switch( ck1.fccType )
                {
                case DMUS_FOURCC_CHORDPALETTE_LIST:
                    for( int nChord = 0; pIRiffStream->Descend( &ck1, &ckList, 0 ) == 0 && nChord < 24; nChord++ )
                    {
                        if ( ck1.ckid == FOURCC_LIST && ck1.fccType == DMUS_FOURCC_CHORD_LIST )
                        {
                            TListItem<DMChordData>* pChordData = new TListItem<DMChordData>;
                            if (pChordData)
                            {
                                m_PersonalityInfo.m_aChordPalette[nChord].AddHead(pChordData);
                                hr = pChordData->GetItemValue().Read(pIRiffStream, &ck1, apChordDB);
                            }
                        }
                        pIRiffStream->Ascend( &ck1, 0 );
                    }
                    break;
                case DMUS_FOURCC_CHORDMAP_LIST:
                {
                    short nMapMax = 0;
                    while ( pIRiffStream->Descend( &ck1, &ckList, 0 ) == 0 )
                    {
                        if ( ck1.ckid == FOURCC_LIST && ck1.fccType == DMUS_FOURCC_CHORDENTRY_LIST )
                        {
                            DM_LoadChordEntry(pIRiffStream, &ck1, apChordDB, nMapMax);
                        }
                        pIRiffStream->Ascend( &ck1, 0 );
                    }
                    TListItem<DMChordEntry>** aChordArray = new TListItem<DMChordEntry>*[nMapMax + 1];
                    if (!aChordArray)
                    {
                        hr = E_OUTOFMEMORY;
                        pIRiffStream->Ascend( &ck, 0 );
                        goto ON_END;
                    }
                    TListItem<DMChordEntry>* pScan = m_PersonalityInfo.m_ChordMap.GetHead();
                    for(; pScan; pScan = pScan->GetNext())
                    {
                        if (pScan->GetItemValue().m_nID < 0)
                        {
                            // the connection id was not properly initialized
                            Trace(1, "ERROR: Load (chord map): DMUS_FOURCC_CHORDMAP_LIST chunk contains an improperly initialized connection ID.\n");
                            hr = DMUS_E_NOT_INIT;
                            pIRiffStream->Ascend( &ck, 0 );
                            delete [] aChordArray;
                            goto ON_END;
                        }
                        aChordArray[pScan->GetItemValue().m_nID] = pScan;
                    }
                    pScan = m_PersonalityInfo.m_ChordMap.GetHead();
                    for (; pScan; pScan = pScan->GetNext())
                    {
                        TListItem<DMChordLink>* pLink = pScan->GetItemValue().m_Links.GetHead();
                        for (; pLink; pLink = pLink->GetNext())
                        {
                            DMChordLink& rLink = pLink->GetItemValue();
                            if (rLink.m_nID < 0)
                            {
                                // the connection id was not properly initialized
                                Trace(1, "ERROR: Load (chord map): DMUS_FOURCC_CHORDMAP_LIST chunk contains an improperly initialized connection ID.\n");
                                hr = DMUS_E_NOT_INIT;
                                pIRiffStream->Ascend( &ck, 0 );
                                delete [] aChordArray;
                                goto ON_END;
                            }
                            rLink.m_pChord = aChordArray[rLink.m_nID];
                        }
                    }
                    delete [] aChordArray;
                    break;
                }
                    
                case DMUS_FOURCC_SIGNPOST_LIST:
                    while ( pIRiffStream->Descend( &ck1, &ckList, 0 ) == 0 )
                    {
                        if ( ck1.ckid == FOURCC_LIST && ck1.fccType == DMUS_FOURCC_SIGNPOSTITEM_LIST )
                        {
                            DM_LoadSignPost(pIRiffStream, &ck1, apChordDB);
                        }
                        pIRiffStream->Ascend( &ck1, 0 );
                    }
                    break;

                }
                break;
        }

        pIRiffStream->Ascend( &ck, 0 );
    }

ON_END:
    if (apChordDB) delete [] apChordDB;
    pIStream->Release();
    return hr;
}

HRESULT CDMPers::DM_LoadChordEntry( 
    IAARIFFStream* pIRiffStream, MMCKINFO* pckParent, DMExtendedChord** apChordDB, short& nMax )
{
    HRESULT hr = S_OK;
    if (!pIRiffStream || !pckParent) return E_INVALIDARG;
    MMCKINFO ck;
    IStream* pIStream = pIRiffStream->GetStream();
    if(!pIStream) return E_FAIL;

    TListItem<DMChordEntry>* pChordEntry = new TListItem<DMChordEntry>;
    if (!pChordEntry) return E_OUTOFMEMORY;
    DMChordEntry& rChordEntry = pChordEntry->GetItemValue();
    rChordEntry.m_ChordData.m_strName = "";
    m_PersonalityInfo.m_ChordMap.AddHead(pChordEntry);
    while(pIRiffStream->Descend(&ck, pckParent, 0) == 0 && hr == S_OK)
    {
        switch(ck.ckid)
        {
        case DMUS_FOURCC_CHORDENTRY_CHUNK:
            {
                DMUS_IO_CHORDENTRY iChordEntry;
                DWORD cb;
                hr = pIStream->Read( &iChordEntry, sizeof(iChordEntry), &cb );
                if (FAILED(hr) || cb !=  sizeof(iChordEntry) ) 
                {
                    if (SUCCEEDED(hr)) hr = E_FAIL;
                    pIRiffStream->Ascend( &ck, 0 );
                    goto ON_END;
                }
                rChordEntry.m_dwFlags = iChordEntry.dwFlags;
                rChordEntry.m_nID = iChordEntry.wConnectionID;
                if (rChordEntry.m_nID > nMax) nMax = rChordEntry.m_nID;
            }
            break;
        case FOURCC_LIST:
            if (ck.fccType == DMUS_FOURCC_CHORD_LIST)
            {
                hr = rChordEntry.m_ChordData.Read(pIRiffStream, &ck, apChordDB);
            }
            break;
        case DMUS_FOURCC_NEXTCHORDSEQ_CHUNK:
            {
                long lFileSize = ck.cksize;
                WORD wSize;
                DWORD cb;
                hr = pIStream->Read( &wSize, sizeof( wSize ), &cb );
                if (FAILED(hr) || cb != sizeof( wSize ) ) 
                {
                    if (SUCCEEDED(hr)) hr = E_FAIL;
                    pIRiffStream->Ascend( &ck, 0 );
                    goto ON_END;
                }
                lFileSize -= cb;
                while (lFileSize > 0)
                {
                    DMUS_IO_NEXTCHORD iNextChord;
                    hr = pIStream->Read( &iNextChord, wSize, &cb );
                    if (FAILED(hr) || cb !=  wSize ) 
                    {
                        if (SUCCEEDED(hr)) hr = E_FAIL;
                        pIRiffStream->Ascend( &ck, 0 );
                        goto ON_END;
                    }
                    if (iNextChord.wConnectionID)
                    {
                        TListItem<DMChordLink>* pItem = new TListItem<DMChordLink>;
                        if (!pItem ) 
                        {
                            hr = E_OUTOFMEMORY;
                            pIRiffStream->Ascend( &ck, 0 );
                            goto ON_END;
                        }
                        DMChordLink& rLink = pItem->GetItemValue();
                        rLink.m_dwFlags = iNextChord.dwFlags;
                        rLink.m_nID = iNextChord.wConnectionID;
                        rLink.m_wWeight = iNextChord.nWeight;
                        rLink.m_wMinBeats = iNextChord.wMinBeats;
                        rLink.m_wMaxBeats = iNextChord.wMaxBeats;
                        rChordEntry.m_Links.AddHead(pItem);
                    }
                    lFileSize -= wSize;
                }
                if (lFileSize != 0 )
                {
                    hr = E_FAIL;
                    pIRiffStream->Ascend( &ck, 0 );
                    goto ON_END;
                }
            }
            break;
        }
        pIRiffStream->Ascend(&ck, 0);
    }
ON_END:
    if (pIStream) pIStream->Release();
    return hr;
}

HRESULT CDMPers::DM_LoadSignPost( IAARIFFStream* pIRiffStream, MMCKINFO* pckParent, DMExtendedChord** apChordDB )
{
    HRESULT hr = S_OK;
    if (!pIRiffStream || !pckParent) return E_INVALIDARG;
    MMCKINFO ck;
    IStream* pIStream = pIRiffStream->GetStream();
    if(!pIStream) return E_FAIL;

    TListItem<DMSignPost>* pSignPost = new TListItem<DMSignPost>;
    if (!pSignPost) return E_OUTOFMEMORY;
    DMSignPost& rSignPost = pSignPost->GetItemValue();
    m_PersonalityInfo.m_SignPostList.AddTail(pSignPost);
    while(pIRiffStream->Descend(&ck, pckParent, 0) == 0 && hr == S_OK)
    {
        switch(ck.ckid)
        {
        case DMUS_FOURCC_IOSIGNPOST_CHUNK:
            {
                DMUS_IO_PERS_SIGNPOST iSignPost;
                DWORD cb;
                hr = pIStream->Read( &iSignPost, sizeof(iSignPost), &cb );
                if (FAILED(hr) || cb !=  sizeof(iSignPost) ) 
                {
                    if (SUCCEEDED(hr)) hr = E_FAIL;
                    pIRiffStream->Ascend( &ck, 0 );
                    goto ON_END;
                }
                rSignPost.m_dwChords = iSignPost.dwChords;
                rSignPost.m_dwFlags = iSignPost.dwFlags;
            }
            break;
        case FOURCC_LIST:
            switch(ck.fccType)
            {
            case DMUS_FOURCC_CHORD_LIST:
                hr = rSignPost.m_ChordData.Read(pIRiffStream, &ck, apChordDB);
                break;
            case DMUS_FOURCC_CADENCE_LIST:
                {
                    MMCKINFO ckCadence = ck;
                    MMCKINFO ck1 = ck;
                    for (short n = 0;
                         pIRiffStream->Descend(&ck1, &ckCadence, 0) == 0 && hr == S_OK && n < 2;
                        n++)
                    {
                        if (ck1.fccType == DMUS_FOURCC_CHORD_LIST)
                        {
                            short n2 = n;
                            if ( !(rSignPost.m_dwFlags & DMUS_SPOSTCADENCEF_1) &&
                                 (rSignPost.m_dwFlags & DMUS_SPOSTCADENCEF_2) )
                            {
                                // if all we have is cadence 2, put it in location 1
                                n2 = 1;
                            }
                            hr = rSignPost.m_aCadence[n2].Read(pIRiffStream, &ck1, apChordDB);
                        }
                        pIRiffStream->Ascend(&ck1, 0);
                    }
                }
                break;
            }
            break;
        }
        pIRiffStream->Ascend(&ck, 0);
    }
ON_END:
    if (pIStream) pIStream->Release();
    return hr;
}

HRESULT DMChordData::Read(
    IAARIFFStream* pIRiffStream, MMCKINFO* pckParent, DMExtendedChord** apChordDB)
{
    HRESULT hr1, hr2;
    if (!pIRiffStream || !pckParent) return E_INVALIDARG;
    if (!apChordDB) return E_POINTER;
    MMCKINFO ck;
    wchar_t wzName[12];
    WORD awSubIds[4];

    IStream* pIStream = pIRiffStream->GetStream();
    if(!pIStream) return E_FAIL;

    while(pIRiffStream->Descend(&ck, pckParent, 0) == 0)
    {
        TListItem<DMExtendedChord*>* pChord = NULL;
        switch(ck.ckid)
        {
        case DMUS_FOURCC_CHORDNAME_CHUNK:
            hr1 = pIStream->Read(wzName, sizeof(wzName), 0);
            if (SUCCEEDED(hr1)) m_strName = wzName;
            break;
        case DMUS_FOURCC_SUBCHORDID_CHUNK:
            hr2 = pIStream->Read(awSubIds, sizeof(awSubIds), 0);
            // now use the ids to set up pointers to subchords
            if (m_pSubChords) Release();
            pChord = new TListItem<DMExtendedChord*>(apChordDB[awSubIds[3]]);
            if (pChord)
            {
                pChord->GetItemValue()->AddRef();
                for (short n = 2; n >= 0; n--)
                {
                    TListItem<DMExtendedChord*>* pNew = new TListItem<DMExtendedChord*>(apChordDB[awSubIds[n]]);
                    if (pNew)
                    {
                        pNew->GetItemValue()->AddRef();
                        pNew->SetNext(pChord);
                        pChord = pNew;
                    }
                }
            }
            m_pSubChords = pChord;
            break;
        }
        pIRiffStream->Ascend(&ck, 0);
    }
    pIStream->Release();
    return (hr1 == S_OK && hr2 == S_OK) ? S_OK : E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmcompos\dmtempl.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       dmtempl.cpp
//
//--------------------------------------------------------------------------

// DMTempl.cpp : Implementation of CDMTempl
#include "pchcompos.h"

void TemplateStruct::AddIntro(TList<PlayChord>& PlayList, int nIntroLength)
{
    TListItem<TemplateCommand> *pCommand = new TListItem<TemplateCommand>;
    if (pCommand)
    {
        BOOL fMerge = FALSE;
        TemplateCommand& rCommand = pCommand->GetItemValue();
        rCommand.m_nMeasure = 0;
        rCommand.m_dwChord = 0;
        rCommand.m_Command.bCommand = DMUS_COMMANDT_INTRO;
        rCommand.m_Command.bGrooveLevel = 0;
        rCommand.m_Command.bGrooveRange = 0;
        rCommand.m_Command.bRepeatMode = DMUS_PATTERNT_RANDOM;
        TListItem<PlayChord> *pChord = PlayList.GetHead();
        for (; pChord; pChord = pChord->GetNext())
        {
            pChord->GetItemValue().m_nMeasure += (short)nIntroLength;
        }
        TListItem<TemplateCommand> *pScan = m_CommandList.GetHead();
        for (; pScan; pScan = pScan->GetNext())
        {
            TemplateCommand& rScan = pScan->GetItemValue();
            if (rScan.m_nMeasure >= nIntroLength || !rScan.m_dwChord)
                rScan.m_nMeasure += (short)nIntroLength;
            else if (rScan.m_Command.bGrooveLevel != 0 || rScan.m_Command.bCommand == DMUS_COMMANDT_END)
            {
                rCommand.m_dwChord = rScan.m_dwChord;
                rScan.m_dwChord = 0;
                rScan.m_nMeasure += (short)nIntroLength;
            }
            else // merge with existing command
            {
                rScan.m_Command.bCommand = DMUS_COMMANDT_INTRO;
                rScan.m_Command.bGrooveLevel = 0;
                rScan.m_Command.bGrooveRange = 0;
                rScan.m_Command.bRepeatMode = DMUS_PATTERNT_RANDOM;
                fMerge = TRUE;
            }
        }
        m_nMeasures += (short)nIntroLength;
        if (fMerge)
            delete pCommand;
        else
            m_CommandList.AddHead(pCommand);
    }
}

void TemplateStruct::AddIntro(bool f1Bar, int nLength)
{
    TListItem<TemplateCommand> *pCommand = new TListItem<TemplateCommand>;
    if (pCommand)
    {
        BOOL fMerge = FALSE;
        TemplateCommand& rCommand = pCommand->GetItemValue();
        rCommand.m_nMeasure = 0;
        rCommand.m_dwChord = 0;
        rCommand.m_Command.bCommand = DMUS_COMMANDT_INTRO;
        rCommand.m_Command.bGrooveLevel = 0;
        rCommand.m_Command.bGrooveRange = 0;
        rCommand.m_Command.bRepeatMode = DMUS_PATTERNT_RANDOM;
        TListItem<TemplateCommand> *pScan = m_CommandList.GetHead();
        for (; pScan; pScan = pScan->GetNext())
        {
            TemplateCommand& rScan = pScan->GetItemValue();
            if (rScan.m_nMeasure > 0 || !rScan.m_dwChord)
                rScan.m_nMeasure += (short)nLength;
            else if ( !f1Bar &&
                        (rScan.m_Command.bGrooveLevel != 0 ||
                         rScan.m_Command.bCommand != DMUS_COMMANDT_GROOVE) )
            {
                rCommand.m_dwChord = rScan.m_dwChord;
                rScan.m_dwChord = 0;
                rScan.m_nMeasure += (short)nLength;
            }
            else // merge with existing command
            {
                rScan.m_Command.bCommand = DMUS_COMMANDT_INTRO;
                rScan.m_Command.bGrooveLevel = 0;
                rScan.m_Command.bGrooveRange = 0;
                rScan.m_Command.bRepeatMode = DMUS_PATTERNT_RANDOM;
                fMerge = TRUE;
            }
        }
        if (!f1Bar) m_nMeasures += (short)nLength;
        if (fMerge)
            delete pCommand;
        else
            m_CommandList.AddHead(pCommand);
    }
}

void TemplateStruct::AddEnd(int nLength)
{
    TListItem<TemplateCommand> *pCommand;
    TListItem<TemplateCommand> *pScan = m_CommandList.GetHead();
    for (; pScan; pScan = pScan->GetNext())
    {
        if (m_nMeasures - nLength == pScan->GetItemValue().m_nMeasure) break;
    }
    pCommand = (pScan) ? pScan : new TListItem<TemplateCommand>;
    if (pCommand)
    {
        TemplateCommand& rCommand = pCommand->GetItemValue();
        rCommand.m_nMeasure = m_nMeasures - nLength;
        if (!pScan || pScan->GetItemValue().m_nMeasure > 1) // otherwise keep the existing signpost
        {
            rCommand.m_dwChord = 0;
        }
        rCommand.m_Command.bCommand = DMUS_COMMANDT_END;
        rCommand.m_Command.bGrooveLevel = 0;
        rCommand.m_Command.bGrooveRange = 0;
        rCommand.m_Command.bRepeatMode = DMUS_PATTERNT_RANDOM;
        if (!pScan) m_CommandList.AddTail(pCommand);
    }
}

void TemplateStruct::FillInGrooveLevels()
{
    BYTE bLastGrooveLevel = 62;
    TListItem<TemplateCommand>* pCommands = m_CommandList.GetHead();
    for(; pCommands; pCommands = pCommands->GetNext())
    {
        TemplateCommand& rCommand = pCommands->GetItemValue();
        if (rCommand.m_Command.bGrooveLevel == 0)
        {
            rCommand.m_Command.bGrooveLevel = bLastGrooveLevel;
        }
        else
        {
            bLastGrooveLevel = rCommand.m_Command.bGrooveLevel;
        }
    }
}


void TemplateStruct::IncorporateTemplate(
            short nMeasure, TemplateStruct* pTemplate, short nDirection)
{
    if (!pTemplate) return;
    TListItem<TemplateCommand>* pCommands = pTemplate->m_CommandList.GetHead();
    for(; pCommands; pCommands = pCommands->GetNext())
    {
        TemplateCommand& rCommand = pCommands->GetItemValue();
        TListItem<TemplateCommand> *pNew = new TListItem<TemplateCommand>;
        if (pNew)
        {
            TemplateCommand& rNew = pNew->GetItemValue();
            rNew.m_nMeasure = rCommand.m_nMeasure + (short)nMeasure;
            ChangeCommand(rNew.m_Command, rCommand.m_Command, nDirection);
            rNew.m_dwChord = rCommand.m_dwChord;
            m_CommandList.AddHead(pNew);
        }
    }
}

void TemplateStruct::InsertCommand(TListItem<TemplateCommand> *pCommand, BOOL fIsCommand)
{
    TListItem<TemplateCommand> *pScan;

    if( !pCommand )
    {
        return;
    }
    pCommand->SetNext(NULL);
    TemplateCommand& rCommand = pCommand->GetItemValue();
    pScan = m_CommandList.GetHead();
    if (pScan)
    {
        for (; pScan; pScan = pScan->GetNext())
        {
            TemplateCommand& rScan = pScan->GetItemValue();
            if (rScan.m_nMeasure == rCommand.m_nMeasure)
            {
                if (fIsCommand)
                {
                    rScan.m_dwChord = 0;
                    rScan.m_Command.bCommand = rCommand.m_Command.bCommand;
                    rScan.m_Command.bGrooveLevel = rCommand.m_Command.bGrooveLevel;
                    rScan.m_Command.bGrooveRange = rCommand.m_Command.bGrooveRange;
                    rScan.m_Command.bRepeatMode = rCommand.m_Command.bRepeatMode;
                }
                else
                {
                    rScan.m_dwChord = rCommand.m_dwChord;
                    rScan.m_Command.bCommand = DMUS_COMMANDT_GROOVE;
                    rScan.m_Command.bGrooveLevel = 0;
                    rScan.m_Command.bGrooveRange = 0;
                    rScan.m_Command.bRepeatMode = DMUS_PATTERNT_RANDOM;
                }
                delete pCommand;
                return;
            }
            if (rScan.m_nMeasure > rCommand.m_nMeasure)
            {
                m_CommandList.InsertBefore(pScan, pCommand);
                break;
            }
        }
    }
    if (!pScan)
    {
        m_CommandList.AddTail(pCommand);
    }
}

void TemplateStruct::AddCommand(int nMeasure, DWORD dwCommand)

{
    TListItem<TemplateCommand>* pCommand = new TListItem<TemplateCommand>;
    if (pCommand)
    {
        TemplateCommand& rCommand = pCommand->GetItemValue();
        rCommand.m_nMeasure = (short)nMeasure;
        rCommand.m_Command.bGrooveRange = 0;
        rCommand.m_Command.bRepeatMode = DMUS_PATTERNT_RANDOM;
        switch (dwCommand)
        {
        case PF_FILL:
            rCommand.m_Command.bCommand = DMUS_COMMANDT_FILL;
            rCommand.m_Command.bGrooveLevel = 0;
            break;
        case PF_INTRO:
            rCommand.m_Command.bCommand = DMUS_COMMANDT_INTRO;
            rCommand.m_Command.bGrooveLevel = 0;
            break;
        case PF_BREAK:
            rCommand.m_Command.bCommand = DMUS_COMMANDT_BREAK;
            rCommand.m_Command.bGrooveLevel = 0;
            break;
        case PF_END:
            rCommand.m_Command.bCommand = DMUS_COMMANDT_END;
            rCommand.m_Command.bGrooveLevel = 0;
            break;
        case PF_A:
            rCommand.m_Command.bCommand = DMUS_COMMANDT_GROOVE;
            rCommand.m_Command.bGrooveLevel = 12;
            break;
        case PF_B:
            rCommand.m_Command.bCommand = DMUS_COMMANDT_GROOVE;
            rCommand.m_Command.bGrooveLevel = 37;
            break;
        case PF_C:
            rCommand.m_Command.bCommand = DMUS_COMMANDT_GROOVE;
            rCommand.m_Command.bGrooveLevel = 62;
            break;
        case PF_D:
            rCommand.m_Command.bCommand = DMUS_COMMANDT_GROOVE;
            rCommand.m_Command.bGrooveLevel = 87;
            break;
        default:  // default to a Groove C
            rCommand.m_Command.bCommand = DMUS_COMMANDT_GROOVE;
            rCommand.m_Command.bGrooveLevel = 62;
        }
        InsertCommand( pCommand, TRUE );
    }
}

void TemplateStruct::AddChord(int nMeasure, DWORD dwChord)

{
    TListItem<TemplateCommand>* pCommand = new TListItem<TemplateCommand>;
    if (pCommand)
    {
        pCommand->GetItemValue().m_nMeasure = (short)nMeasure;
        pCommand->GetItemValue().m_dwChord = dwChord;
        InsertCommand( pCommand, FALSE );
    }
}

int WeightedRand(int nRange)

/*  This randomly chooses a number within nrange.  However, it heavily
    weights in favor of the first index, which has twice the chance
    of the second index, which has twice the chance of the third...
*/

{
    int nTotal = 0;
    int index;
    unsigned int nGuess;
    if (nRange <= 0 || nRange > 15) return(0);     // out of range.
    for (index = 0;index < nRange; index++)
    {
        nTotal += (1 << index);
    }
    nGuess = dm_rand() % nTotal;
    nGuess++;
    for (;nGuess;index--)
    {
        nGuess = nGuess >> 1;
    }
    return(index);
}

void TemplateStruct::CreateSignPosts()
{
    // First, figure out how many different sign posts we should use.
    // Should be the number of bits in measures minus two. Min is one.
    // For example, 8 measures gets us 2 sign posts.

    int nSPCount = -2;
    int nCopy = m_nMeasures;
    m_CommandList.RemoveAll();
    while (nCopy)
    {
        nSPCount++;
        nCopy = nCopy >> 1;
    }
    if (nSPCount < 1) nSPCount = 1;
    if (nSPCount > 7) nSPCount = 7;

    // Now, choose some signposts.  We choose from the following set:
    // 1, A, C, E, B, D, F. Randomly, but heavily weighted towards the start
    // of the set.

    static DWORD adwSource[7] = { DMUS_SIGNPOSTF_1, DMUS_SIGNPOSTF_A, DMUS_SIGNPOSTF_C, DMUS_SIGNPOSTF_E, DMUS_SIGNPOSTF_B, DMUS_SIGNPOSTF_D, DMUS_SIGNPOSTF_F };
    DWORD adwChoice[7];
    DWORD adwSign[7];
    int anLength[7];
    DWORD dwLastChord;

    int index;
    for (index = 0;index < 7;index++)
    {
        adwChoice[index] = adwSource[index];
        adwSign[index] = 0;
        if (dm_rand() % 3) anLength[index] = 4;
        else anLength[index] = 2;
    }
    if (dm_rand() % 2) anLength[0] = 4;
    for (index = 0;index < nSPCount;index++)
    {
        int nPosition;
        int nScan = 0;
        if (index) nPosition = WeightedRand(7 - index);
        else nPosition = WeightedRand(3);
        for (;nScan < 7;nScan++)
        {
            if (adwChoice[nScan])
            {
                if (!nPosition)
                {
                    adwSign[index] = adwChoice[nScan];
                    if (dm_rand() % 2) adwSign[index] |= DMUS_SIGNPOSTF_CADENCE;
                    adwChoice[nScan] = 0;
                    break;
                }
                nPosition--;
            }
        }
    }
    AddChord(0,dwLastChord = adwSign[0]);
    int nLast = 0;
    for (index = 0;index < m_nMeasures;)
    {
        DWORD dwCadence = 0;
        DWORD dwChord;
        index += anLength[nLast];
        if (index >= (m_nMeasures - 1))
        {
            if (dm_rand() % 3) AddChord(m_nMeasures - 1,DMUS_SIGNPOSTF_1 | dwCadence);
            else AddChord(m_nMeasures - 1,adwSign[0] | dwCadence);
            break;
        }
        dwChord = adwSign[nLast = WeightedRand(nSPCount)];
        if (dwChord == dwLastChord)
        {
            dwChord = adwSign[nLast = WeightedRand(nSPCount)];
        }
        AddChord(index,dwChord | dwCadence);
        dwLastChord = dwChord;
    }
}

static void GrooveRange(TemplateStruct *pTemplate,int nStartm,int nEndm,
            int nStartg,int nEndg,BOOL fRandom)

{
    static BYTE abGrooveLevels[4] = { 12, 37, 62, 87 };
    TListItem<TemplateCommand> *pCommand = pTemplate->m_CommandList.GetHead();
    int nRangem = nEndm - nStartm;
    int nRangeg = nEndg - nStartg;
    BYTE bLastGrooveLevel = 0;
    int nLastGroove = -1;
    int nLastMeasure = 0;
    for (; pCommand; pCommand = pCommand->GetNext())
    {
        TemplateCommand& rCommand = pCommand->GetItemValue();
        if (rCommand.m_Command.bCommand == DMUS_COMMANDT_GROOVE &&
            rCommand.m_Command.bGrooveLevel > 0)
        {
            bLastGrooveLevel = rCommand.m_Command.bGrooveLevel;
            nLastMeasure = rCommand.m_nMeasure;
        }
        if (rCommand.m_nMeasure >= nStartm)
        {
            if (rCommand.m_nMeasure >= nEndm) break;
            int nGroove;
            TListItem<TemplateCommand> *pNext = pCommand->GetNext();
            if (pNext)
            {
                nGroove = 
                    ((pNext->GetItemValue().m_nMeasure + rCommand.m_nMeasure ) >> 1) - nStartm;
            }
            else
            {
                nGroove = rCommand.m_nMeasure - nStartm;
            }
            if (fRandom)
            {
                nGroove = dm_rand() % 3;
                nGroove += nLastGroove - 1;
                if (nGroove > 3) nGroove = 2;
                if (nGroove < 0) nGroove = 1;
            }
            else
            {
                nGroove *= nRangeg;
                nGroove += (nRangem >> 1);
                nGroove /= nRangem;
                nGroove += nStartg;
            }
            if ((nGroove >= 0) && (nGroove < 4))
            {
                if (abGrooveLevels[nGroove] != bLastGrooveLevel)
                {
                    if (nLastGroove >= 0)
                    {
                        if (nLastGroove > nGroove) nGroove = nLastGroove - 1;
                        else if (nLastGroove < nGroove) nGroove = nLastGroove + 1;
                    }
                    rCommand.m_Command.bGrooveLevel = abGrooveLevels[nGroove];
                    rCommand.m_Command.bGrooveRange = 0;
                    bLastGrooveLevel = abGrooveLevels[nGroove];
                    nLastMeasure = rCommand.m_nMeasure;
                    nLastGroove = nGroove;
                }
                else if (rCommand.m_nMeasure > (nLastMeasure + 6))
                {
                    nGroove += ((dm_rand() % 3) - 1);
                    if (nGroove < 0) nGroove += 2;
                    if (nGroove > 3) nGroove -= 2;
                    if (!nRangeg)
                    {
                        if ((nGroove < nLastGroove) && (nGroove <= nStartg))
                        {
                            if (dm_rand() % 2) nGroove++;
                        }
                    }
                    if (abGrooveLevels[nGroove] != bLastGrooveLevel)
                    {
                        rCommand.m_Command.bGrooveLevel = abGrooveLevels[nGroove];
                        rCommand.m_Command.bGrooveRange = 0;
                        bLastGrooveLevel = abGrooveLevels[nGroove];
                        nLastMeasure = rCommand.m_nMeasure;
                        nLastGroove = nGroove;
                    }
                }
            }
        }
    }
}

void TemplateStruct::CreateEmbellishments(WORD shape, int nFillLength, int nBreakLength)
{
    // Put fills in. Scan forward through the list, placing fills
    // just prior to sign post changes.  Each time, move forward a
    // random count.
    TListItem<TemplateCommand> *pCommand;
    BYTE bLastGroove = 0;
    BOOL fAddMore = FALSE;
    int nStartg, nEndg;
    switch (shape)
    {
    case DMUS_SHAPET_FALLING:
        nStartg = 3;
        nEndg = 0;
        break;
    case DMUS_SHAPET_LEVEL:
        nStartg = 2;
        nEndg = 2;
        fAddMore = TRUE;
        break;
    case DMUS_SHAPET_LOOPABLE:
        nStartg = 2;
        nEndg = 2;
        fAddMore = TRUE;
        break;
    case DMUS_SHAPET_LOUD:
        nStartg = 3;
        nEndg = 3;
        fAddMore = TRUE;
        break;
    case DMUS_SHAPET_QUIET:
        nStartg = 0;
        nEndg = 1;
        fAddMore = TRUE;
        break;
    case DMUS_SHAPET_PEAKING:
        nStartg = 0;
        nEndg = 3;
        GrooveRange(this, 0, m_nMeasures >> 1, nStartg, nEndg, FALSE);
        nStartg = 3;
        nEndg = 0;
        GrooveRange(this, m_nMeasures >> 1, m_nMeasures - 1, nStartg, nEndg, FALSE);
        nStartg = 0;
        nEndg = 0;
        break;
    case DMUS_SHAPET_RANDOM:
        nStartg = 0;
        nEndg = 0;
        GrooveRange(this, 0, m_nMeasures - 1, nStartg, nEndg, TRUE);
        break;
    case DMUS_SHAPET_RISING:
        nStartg = 0;
        nEndg = 3;
        break;
    case DMUS_SHAPET_SONG:
    default:
        nStartg = 2;
        nEndg = 2;
        fAddMore = TRUE;
        break;
    }
    if (nStartg || nEndg) GrooveRange(this, 0, m_nMeasures - 1, nStartg, nEndg, FALSE);
    pCommand = m_CommandList.GetHead();
    int nLastGrooveBar = 0;
    for (; pCommand; pCommand = pCommand->GetNext())
    {
        TemplateCommand& rCommand = pCommand->GetItemValue();
        if (rCommand.m_Command.bCommand == DMUS_COMMANDT_GROOVE)
        {
            BYTE bGrooveLevel = rCommand.m_Command.bGrooveLevel;
            if (bGrooveLevel && (bGrooveLevel != bLastGroove))
            {
               if (dm_rand() % 2)
                {
                    if ( (rCommand.m_nMeasure >= nFillLength) && 
                         (rCommand.m_nMeasure - nFillLength > nLastGrooveBar) && 
                         (bGrooveLevel > 50 || bLastGroove > 75) )
                    {
                        AddCommand(rCommand.m_nMeasure - nFillLength, PF_FILL);
                    }
                    else
                    {
                        if ((rCommand.m_nMeasure >= nBreakLength) && 
                            (rCommand.m_nMeasure - nBreakLength > nLastGrooveBar) &&
                            (dm_rand() % 3) )
                        {
                            AddCommand(rCommand.m_nMeasure - nBreakLength, PF_BREAK);
                        }
                    }
                }
            }
            bLastGroove = bGrooveLevel;
            if (rCommand.m_Command.bGrooveLevel) nLastGrooveBar = rCommand.m_nMeasure;
        }
    }
    if (fAddMore)
    {
        nLastGrooveBar = 0;
        int nLastMeasure = 0;
        bLastGroove = 0;
        pCommand = m_CommandList.GetHead();
        for (; pCommand; pCommand = pCommand->GetNext())
        {
            TemplateCommand& rCommand = pCommand->GetItemValue();
            TListItem<TemplateCommand> *pNext = pCommand->GetNext();
            int nMeasure = rCommand.m_nMeasure;
            if (rCommand.m_Command.bCommand != DMUS_COMMANDT_GROOVE)
            {
                nLastMeasure = nMeasure;
                continue;
            }
            if (rCommand.m_Command.bCommand == DMUS_COMMANDT_GROOVE)
            {
                bLastGroove = rCommand.m_Command.bGrooveLevel;
            }
            if ( (nLastMeasure + nFillLength + nBreakLength + 4) < nMeasure )
            {
                if ((dm_rand() % 3) == 0)  // do something?
                {                // perhaps a fill?
                    nLastMeasure = nMeasure;
                    if ((bLastGroove > 50) && 
                        (nMeasure >= nFillLength) && 
                        (nMeasure - nFillLength > nLastGrooveBar) && 
                        (dm_rand() % 2))
                    {
                        AddCommand(nMeasure - nFillLength, PF_FILL);
                    }
                    else
                    {
                        if (pNext)
                        {
                            while (nMeasure + nBreakLength <= pNext->GetItemValue().m_nMeasure )
                            {
                                AddCommand(nMeasure, PF_BREAK);
                                nMeasure += nBreakLength;
                                if (dm_rand() % 2) break;
                            }
                        }
                    }
                }
            }
            if (bLastGroove) nLastGrooveBar = rCommand.m_nMeasure;
        }
    }
}

    /////////////////////////////////////////////////////////////////////////////
// CDMTempl

CDMTempl::CDMTempl(  ) : m_cRef(1), m_pTemplateInfo(NULL), 
    m_fCSInitialized(FALSE), m_MemTrack(DMTRACK_TEMPLATE)
{
    IncrementDLLCount();

    // Do this first since it might throw an exception
    //
    INITIALIZE_CRITICAL_SECTION( &m_CriticalSection );
    m_fCSInitialized = TRUE;
}

CDMTempl::~CDMTempl()
{
    if (m_fCSInitialized)
    {
        CleanUp();
        DELETE_CRITICAL_SECTION( &m_CriticalSection );
    }

    DecrementDLLCount();
}

void CDMTempl::CleanUp()
{
    if( m_pTemplateInfo != NULL )
    {
        delete m_pTemplateInfo;
        m_pTemplateInfo = NULL;
    }
}

STDMETHODIMP CDMTempl::QueryInterface(
    const IID &iid, 
    void **ppv) 
{
    V_INAME(CDMTempl::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IDMTempl)
    {
        *ppv = static_cast<IDMTempl*>(this);
    }
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CDMTempl::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CDMTempl::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}


HRESULT CDMTempl::SaveCommandList( IAARIFFStream* pRIFF, DMUS_TIMESIGNATURE& rTimeSig )
{
    IStream*    pStream;
    MMCKINFO    ck;
    HRESULT     hr;
    DWORD       cb;
    DWORD        dwSize;
    DMUS_IO_COMMAND   iCommand;
    TListItem<TemplateCommand>* pCommand;

    if (!m_pTemplateInfo) return E_FAIL;
    pStream = pRIFF->GetStream();
    if (!pStream) return E_FAIL;

    hr = E_FAIL;
    ck.ckid = FOURCC_COMMAND;
    if( pRIFF->CreateChunk( &ck, 0 ) == 0 )
    {
        dwSize = sizeof( DMUS_IO_COMMAND );
        hr = pStream->Write( &dwSize, sizeof( dwSize ), &cb );
        if( FAILED( hr ) || cb != sizeof( dwSize ) )
        {
            pStream->Release();
            return E_FAIL;
        }
        for( pCommand = m_pTemplateInfo->m_CommandList.GetHead(); pCommand != NULL ; pCommand = pCommand->GetNext() )
        {
            TemplateCommand& rCommand = pCommand->GetItemValue();
            if (rCommand.m_Command.bGrooveLevel || rCommand.m_Command.bCommand)
            {
                memset( &iCommand, 0, sizeof( iCommand ) );
                iCommand.mtTime = ClocksPerMeasure(rTimeSig) * rCommand.m_nMeasure;
                iCommand.wMeasure = rCommand.m_nMeasure;
                iCommand.bBeat = 0;
                iCommand.bCommand = rCommand.m_Command.bCommand;
                iCommand.bGrooveLevel = rCommand.m_Command.bGrooveLevel;
                iCommand.bGrooveRange = rCommand.m_Command.bGrooveRange;
                iCommand.bRepeatMode = rCommand.m_Command.bRepeatMode;
                if( FAILED( pStream->Write( &iCommand, sizeof( iCommand ), &cb ) ) ||
                    cb != sizeof( iCommand ) )
                {
                    break;
                }
            }
        }
        if( pCommand == NULL &&
            pRIFF->Ascend( &ck, 0 ) == 0 )
        {
            hr = S_OK;
        }
    }

    pStream->Release();
    return hr;
}

HRESULT CDMTempl::SaveSignPostList( IAARIFFStream* pRIFF, DMUS_TIMESIGNATURE&   TimeSig )
{
    IStream*        pStream;
    MMCKINFO        ck;
    HRESULT         hr;
    DWORD           cb;
    DWORD           dwSize;
    DMUS_IO_SIGNPOST    oSignPost;
    TListItem<TemplateCommand>* pCommand;
    ;

    if (!m_pTemplateInfo) return E_FAIL;
    pStream = pRIFF->GetStream();
    if (!pStream) return E_FAIL;

    hr = E_FAIL;
    ck.ckid = DMUS_FOURCC_SIGNPOST_TRACK_CHUNK;
    if( pRIFF->CreateChunk( &ck, 0 ) == 0 )
    {
        dwSize = sizeof( oSignPost );
        hr = pStream->Write( &dwSize, sizeof( dwSize ), &cb );
        if( FAILED( hr ) || cb != sizeof( dwSize ) )
        {
            pStream->Release();
            return E_FAIL;
        }
        for( pCommand = m_pTemplateInfo->m_CommandList.GetHead(); pCommand != NULL ; pCommand = pCommand->GetNext() )
        {
            TemplateCommand& rCommand = pCommand->GetItemValue();
            memset( &oSignPost, 0, sizeof( oSignPost ) );
            oSignPost.mtTime = ClocksPerMeasure(TimeSig) * rCommand.m_nMeasure;
            oSignPost.wMeasure = rCommand.m_nMeasure;
            oSignPost.dwChords = rCommand.m_dwChord;
            if( FAILED( pStream->Write( &oSignPost, sizeof( oSignPost ), &cb ) ) ||
                cb != sizeof( oSignPost ) )
            {
                break;
            }
        }
        if( pCommand == NULL &&
            pRIFF->Ascend( &ck, 0 ) == 0 )
        {
            hr = S_OK;
        }
    }
    pStream->Release();
    return hr;
}

HRESULT CDMTempl::Init(void* pTemplate)
{
    CleanUp();
    m_pTemplateInfo = (TemplateStruct*)pTemplate;
    // fix groove levels in the command list
//  m_pTemplateInfo->FillInGrooveLevels();
    return S_OK;
}

HRESULT CDMTempl::CreateSegment(IDirectMusicSegment* pISegment)
{
    if (!pISegment) return E_INVALIDARG;
    if (!m_pTemplateInfo) return E_FAIL;

    IDirectMusicTrack*  pICommandTrack          = NULL;
    IDirectMusicTrack*  pISignPostTrack         = NULL;
    IAARIFFStream*      pCommandRIFF            = NULL;
    IStream*            pICommandStream         = NULL;
    IPersistStream*     pICommandTrackStream    = NULL;
    IPersistStream*     pISignPostTrackStream   = NULL;
    IAARIFFStream*      pSignPostRIFF           = NULL;
    IStream*            pISignPostStream        = NULL;
    HRESULT             hr                      = S_OK;
    DMUS_TIMESIGNATURE  TimeSig;

    // Fill in the time sig event with default values (4/4, 16th note resolution)
    TimeSig.mtTime = 0;
    TimeSig.bBeatsPerMeasure = 4;
    TimeSig.bBeat = 4;
    TimeSig.wGridsPerBeat = 4;

    // 1. Create Command and Sign Post Tracks.
    hr = DirectMusicCreateInstance(CLSID_DirectMusicCommandTrack,NULL,IID_IDirectMusicTrack,(void**)&pICommandTrack);
    if (FAILED(hr)) goto ON_END;
    hr = DirectMusicCreateInstance(CLSID_DirectMusicSignPostTrack,NULL,IID_IDirectMusicTrack,(void**)&pISignPostTrack);
    if (FAILED(hr)) goto ON_END;

    // 2. Write the template's command list out to a stream.
    hr = CreateStreamOnHGlobal(NULL, TRUE, &pICommandStream);
    if (S_OK != hr) goto ON_END;
    AllocRIFFStream( pICommandStream, &pCommandRIFF);
    if (!pCommandRIFF)
    {
        hr = E_FAIL;
        goto ON_END;
    }
    SaveCommandList(pCommandRIFF, TimeSig);

    // 3. Use the command list stream as input to the Command Track's Load method.
    hr = pICommandTrack->QueryInterface(IID_IPersistStream, (void**)&pICommandTrackStream);
    if(FAILED(hr)) goto ON_END;
    StreamSeek(pICommandStream, 0, STREAM_SEEK_SET);
    hr = pICommandTrackStream->Load(pICommandStream);
    if(FAILED(hr)) goto ON_END;

    // 4. Write the template's sign post list out to a stream.
    hr = CreateStreamOnHGlobal(NULL, TRUE, &pISignPostStream);
    if(S_OK != hr) goto ON_END;
    AllocRIFFStream( pISignPostStream, &pSignPostRIFF);
    if (!pSignPostRIFF)
    {
        hr = E_FAIL;
        goto ON_END;
    }
    SaveSignPostList(pSignPostRIFF, TimeSig);

    // 5. Use the chord list stream as input to the Sign Post Track's Load method.
    hr = pISignPostTrack->QueryInterface(IID_IPersistStream, (void**)&pISignPostTrackStream);
    if(FAILED(hr)) goto ON_END;
    StreamSeek(pISignPostStream, 0, STREAM_SEEK_SET);
    hr = pISignPostTrackStream->Load(pISignPostStream);
    if (FAILED(hr)) goto ON_END;

    // 6. Create a Segment has been removed it is now passed in

    // 7. Initialize the segment appropriately.
    //pISegment->SetUserData(m_pTemplateInfo->m_nMeasures);
    pISegment->SetLength(ClocksPerMeasure(TimeSig) * m_pTemplateInfo->m_nMeasures);

    // 8. Insert the two Tracks into the Segment's Track list.
    pISegment->InsertTrack(pICommandTrack, 1);
    pISegment->InsertTrack(pISignPostTrack, 1);
    // Note: the segment must release the track objects...

ON_END:
    if (pICommandTrack) pICommandTrack->Release();
    if (pISignPostTrack) pISignPostTrack->Release();
    if (pCommandRIFF) pCommandRIFF->Release();
    if (pICommandStream) pICommandStream->Release();
    if (pICommandTrackStream) pICommandTrackStream->Release();
    if (pISignPostTrackStream) pISignPostTrackStream->Release();
    if (pSignPostRIFF) pSignPostRIFF->Release();
    if (pISignPostStream) pISignPostStream->Release();

    return hr;
}

HRESULT CDMTempl::GetClassID( LPCLSID pclsid )
{
    if ( pclsid == NULL ) return E_INVALIDARG;
    *pclsid = CLSID_DMTempl;
    return S_OK;
}

HRESULT CDMTempl::IsDirty()
{
    return ( m_fDirty ) ? S_OK : S_FALSE;
}

static TListItem<TemplateCommand>* loadacommand( LPSTREAM pStream, DWORD dwSize )
{
    CommandExt command;
    TListItem<TemplateCommand>* pCommand = new TListItem<TemplateCommand>;
    if( pCommand == NULL )
    {
        StreamSeek( pStream, dwSize, STREAM_SEEK_CUR );
        return NULL;
    }
    TemplateCommand& rCommand = pCommand->GetItemValue();

    if( dwSize > sizeof(CommandExt) )
    {
        pStream->Read( &command, sizeof(CommandExt), NULL );
        FixBytes( FBT_COMMANDEXT, &command );
        StreamSeek( pStream, dwSize - sizeof(CommandExt), STREAM_SEEK_CUR );
    }
    else
    {
        pStream->Read( &command, dwSize, NULL );
        FixBytes( FBT_COMMANDEXT, &command );
    }
    //rCommand.m_lTime = command->time;
    rCommand.m_nMeasure = command.measure;
    rCommand.m_Command.bGrooveRange = 0;
    rCommand.m_Command.bRepeatMode = 0;
    switch (command.command)
    {
    case PF_FILL:
        rCommand.m_Command.bCommand = DMUS_COMMANDT_FILL;
        rCommand.m_Command.bGrooveLevel = 0;
        break;
    case PF_INTRO:
        rCommand.m_Command.bCommand = DMUS_COMMANDT_INTRO;
        rCommand.m_Command.bGrooveLevel = 0;
        break;
    case PF_BREAK:
        rCommand.m_Command.bCommand = DMUS_COMMANDT_BREAK;
        rCommand.m_Command.bGrooveLevel = 0;
        break;
    case PF_END:
        rCommand.m_Command.bCommand = DMUS_COMMANDT_END;
        rCommand.m_Command.bGrooveLevel = 0;
        break;
    case PF_A:
        rCommand.m_Command.bCommand = DMUS_COMMANDT_GROOVE;
        rCommand.m_Command.bGrooveLevel = 12;
        break;
    case PF_B:
        rCommand.m_Command.bCommand = DMUS_COMMANDT_GROOVE;
        rCommand.m_Command.bGrooveLevel = 37;
        break;
    case PF_C:
        rCommand.m_Command.bCommand = DMUS_COMMANDT_GROOVE;
        rCommand.m_Command.bGrooveLevel = 62;
        break;
    case PF_D:
        rCommand.m_Command.bCommand = DMUS_COMMANDT_GROOVE;
        rCommand.m_Command.bGrooveLevel = 87;
        break;
    default:  // default to a Groove with level 0 (interpretation: use previous groove level)
        // This happens in the measure following an embellishment
        rCommand.m_Command.bCommand = DMUS_COMMANDT_GROOVE;
        rCommand.m_Command.bGrooveLevel = 0;
    }
    rCommand.m_dwChord = command.chord;

    return pCommand;
}

HRESULT CDMTempl::LoadTemplate( LPSTREAM pStream, DWORD dwSize )
{
    TListItem<TemplateCommand>*     pCommand;
    DWORD         id = 0;
    DWORD         tsize = 0;
    DWORD         segsize = 0;
    SCTtemplate* pTemplate;
    long lSize = dwSize;

    if ( pStream == NULL ) return E_INVALIDARG;
    pTemplate = new SCTtemplate;
    if( pTemplate == NULL )
    {
        StreamSeek( pStream, lSize, STREAM_SEEK_CUR );
        return E_OUTOFMEMORY;
    }

    if (!GetMLong( pStream, tsize ))
    {
        StreamSeek( pStream, lSize, STREAM_SEEK_CUR );
        delete pTemplate;
        return E_FAIL;
    }

    lSize -= 4;
    if( tsize > sizeof(SCTtemplate) )
    {
        pStream->Read( pTemplate, sizeof(SCTtemplate), NULL );
        FixBytes( FBT_SCTTEMPLATE, pTemplate );
        StreamSeek( pStream, tsize - sizeof(SCTtemplate), STREAM_SEEK_CUR );
    }
    else
    {
        pStream->Read( pTemplate, tsize, NULL );
        FixBytes( FBT_SCTTEMPLATE, pTemplate );
    }
    lSize -= tsize;

    m_pTemplateInfo = new TemplateStruct;
    if (!m_pTemplateInfo)
    {
        StreamSeek( pStream, lSize, STREAM_SEEK_CUR );
        return E_OUTOFMEMORY;
    }
    m_pTemplateInfo->m_strName = pTemplate->achName;
    m_pTemplateInfo->m_strType = pTemplate->achType;
    m_pTemplateInfo->m_nMeasures = pTemplate->nMeasures;
    delete pTemplate;
    while( lSize > 0 )
    {
        pStream->Read( &id, 4, NULL );
        if (!GetMLong( pStream, segsize ))
        {
            StreamSeek( pStream, lSize, STREAM_SEEK_CUR );
            break;
        }

        lSize   -= 8;
        switch( id )
        {
        case mmioFOURCC( 'D', 'M', 'C', 's' ):
            pCommand = loadacommand( pStream, segsize );
            if( pCommand )
            {
                m_pTemplateInfo->m_CommandList.AddTail(pCommand);
            }
            break;

        default:
            StreamSeek( pStream, segsize, STREAM_SEEK_CUR );
            break;
        }

        lSize -= segsize;
    }

    // fix groove levels in the command list
    BYTE bLastGroove = 62; 
    pCommand = m_pTemplateInfo->m_CommandList.GetHead();
    for (; pCommand; pCommand = pCommand->GetNext())
    {
        TemplateCommand& rCommand = pCommand->GetItemValue();
        if (rCommand.m_Command.bGrooveLevel == 0)
        {
            rCommand.m_Command.bGrooveLevel = bLastGroove;
        }
        else bLastGroove = rCommand.m_Command.bGrooveLevel;
    }
    return S_OK;
}

// This loads a *single* template.  I also need to handle files that contain
// *lists* of templates (but I can just load the first one in the list)
HRESULT CDMTempl::Load( LPSTREAM pStream )
{
    FOURCC id;
    DWORD dwSize;
    HRESULT hr;

    if ( pStream == NULL ) return E_INVALIDARG;
    ENTER_CRITICAL_SECTION( &m_CriticalSection );
    CleanUp();
    if( FAILED( pStream->Read( &id, sizeof( FOURCC ), NULL ) ) ||
        !GetMLong( pStream, dwSize ) )
    {
        hr = E_FAIL;
        goto end;
    }
    if( id != mmioFOURCC( 'L', 'P', 'T', 's' ) )
    {
        hr = E_FAIL;
        goto end;
    }
    hr = LoadTemplate( pStream, dwSize );
end:
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return hr;
}

HRESULT CDMTempl::Save( LPSTREAM pStream, BOOL fClearDirty )
{
    return E_NOTIMPL;
}

HRESULT CDMTempl::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmcompos\dmcompp.h ===
//
// DMCompP.H
//
// Private include for DMCompos.DLL
//
// Copyright (c) 1997-1998 Microsoft Corporation
//
//

#ifndef _DMCOMPP_
#define _DMCOMPP_

#define ALL_TRACK_GROUPS 0xffffffff

extern long g_cComponent;

// Class factory
//
class CDirectMusicPersonalityFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectMusicPersonalityFactory() : m_cRef(1) {}

    // Destructor
    // ~CDirectMusicPersonalityFactory() {} 

private:
    long m_cRef;
};

class CDirectMusicComposerFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectMusicComposerFactory() : m_cRef(1) {}

    // Destructor
    // ~CDirectMusicComposerFactory() {} 

private:
    long m_cRef;
};

class CDirectMusicTemplateFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectMusicTemplateFactory() : m_cRef(1) {}

    // Destructor
    // ~CDirectMusicTemplateFactory() {} 

private:
    long m_cRef;
};

class CDirectMusicSignPostTrackFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectMusicSignPostTrackFactory() : m_cRef(1) {}

    // Destructor
    // ~CDirectMusicSignPostTrackFactory() {} 

private:
    long m_cRef;
};

class CDirectMusicPersonalityTrackFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectMusicPersonalityTrackFactory() : m_cRef(1) {}

    // Destructor
    // ~CDirectMusicPersonalityTrackFactory() {} 

private:
    long m_cRef;
};

// private interfaces
interface IDMPers : IUnknown
{
	virtual HRESULT STDMETHODCALLTYPE GetPersonalityStruct(void** ppPersonality)=0; 
};

interface IDMTempl : IUnknown
{
	virtual HRESULT STDMETHODCALLTYPE CreateSegment(IDirectMusicSegment* pSegment)=0;
	virtual HRESULT STDMETHODCALLTYPE Init(void* pTemplate)=0;
};


// private CLSIDs and IIDs (some IIDs should no longer be needed...)
const CLSID CLSID_DMTempl = {0xD30BCC65,0x60E8,0x11D1,{0xA7,0xCE,0x00,0xA0,0xC9,0x13,0xF7,0x3C}};

const IID IID_IDMPers = {0x93BE9414,0x5C4E,0x11D1,{0xA7,0xCE,0x00,0xA0,0xC9,0x13,0xF7,0x3C}};
//const IID IID_IDMCompos = {0x6724A8C0,0x60C3,0x11D1,{0xA7,0xCE,0x00,0xA0,0xC9,0x13,0xF7,0x3C}};
const IID IID_IDMTempl = {0xD30BCC64,0x60E8,0x11D1,{0xA7,0xCE,0x00,0xA0,0xC9,0x13,0xF7,0x3C}};
//const IID IID_ISPstTrk = {0xB65019E0,0x61B6,0x11D1,{0xA7,0xCE,0x00,0xA0,0xC9,0x13,0xF7,0x3C}};

/*
// stuff that will move to dmusici.h

DEFINE_GUID(CLSID_DirectMusicPersonalityTrack, 
	0xf1edefe1, 0xae0f, 0x11d1, 0xa7, 0xce, 0x0, 0xa0, 0xc9, 0x13, 0xf7, 0x3c);

DEFINE_GUID(GUID_PersonalityTrack, 
	0xf1edefe2, 0xae0f, 0x11d1, 0xa7, 0xce, 0x0, 0xa0, 0xc9, 0x13, 0xf7, 0x3c);
	*/

/*
// stuff that will move to dmusicf.h

// personalities

// runtime chunks
#define FOURCC_PERSONALITY	mmioFOURCC('D','M','P','R')
#define FOURCC_IOPERSONALITY		mmioFOURCC('p','e','r','h')
#define DM_FOURCC_GUID_CHUNK        mmioFOURCC('g','u','i','d')
#define DM_FOURCC_INFO_LIST	        mmioFOURCC('I','N','F','O')
#define DM_FOURCC_VERSION_CHUNK     mmioFOURCC('v','e','r','s')
#define FOURCC_SUBCHORD				mmioFOURCC('c','h','d','t')
#define FOURCC_CHORDENTRY			mmioFOURCC('c','h','e','h')
#define FOURCC_SUBCHORDID			mmioFOURCC('s','b','c','n')
#define FOURCC_IONEXTCHORD			mmioFOURCC('n','c','r','d')
#define FOURCC_NEXTCHORDSEQ		  mmioFOURCC('n','c','s','q')
#define FOURCC_IOSIGNPOST			mmioFOURCC('s','p','s','h')
#define FOURCC_CHORDNAME			mmioFOURCC('I','N','A','M')

// runtime list chunks
#define FOURCC_LISTCHORDENTRY		mmioFOURCC('c','h','o','e')
#define FOURCC_LISTCHORDMAP			mmioFOURCC('c','m','a','p')
#define FOURCC_LISTCHORD			mmioFOURCC('c','h','r','d')
#define FOURCC_LISTCHORDPALETTE		mmioFOURCC('c','h','p','l')
#define FOURCC_LISTCADENCE			mmioFOURCC('c','a','d','e')
#define FOURCC_LISTSIGNPOSTITEM			mmioFOURCC('s','p','s','t')

#define FOURCC_SIGNPOSTLIST		mmioFOURCC('s','p','s','q')


// constants
const int MaxSubChords = 4;

// run time data structs
struct ioPersonality
{
	char	szLoadName[20];
	DWORD	dwScalePattern;
	DWORD	dwFlags;
};

struct ioSubChord
{
	DWORD	dwChordPattern;
	DWORD	dwScalePattern;
	DWORD	dwInvertPattern;
	BYTE	bChordRoot;
	BYTE	bScaleRoot;
	WORD	wCFlags;
	DWORD	dwLevels;	// parts or which subchord levels this chord supports
};

struct ioChordEntry
{
	DWORD	dwFlags;
	WORD	wConnectionID;	// replaces runtime "pointer to this"
};

struct ioNextChord
{
	DWORD	dwFlags;
	WORD	nWeight;
	WORD	wMinBeats;
	WORD	wMaxBeats;
	WORD	wConnectionID;	// points to an ioChordEntry
};

struct ioSignPost
{
	DWORD	dwChords;	// 1bit per group
	DWORD	dwFlags;
};

///*
RIFF
(
	'DMPR'
	<perh-ck>			// Personality header chunk
	[<guid-ck>]			// guid chunk
	[<vers-ck>]			// version chunk (two DWORDS)
	<INFO-list>		  // standard MS Info chunk
	<chdt-ck>		   // subchord database
	<chpl-list>			// chord palette
	<cmap-list>		  // chord map
	<spst-list>			// signpost list
	[<ceed-ck>]		// optional chordmap position data
 )

 <chdt> ::= chdt(<cbChordSize::WORD>  <ioSubChord> ... )

<chpl-list> ::= LIST('chpl' 
								<chrd-list> ... // chord definition
							 )

<chrd-list> ::= LIST('chrd' 
								<INAM-ck> // name of chord in wide char format
								<sbcn-ck>	// list of subchords composing chord
								[<ched-ck>]   //  optional chord edit flags
								)

<cmap-list> ::= LIST('cmap' <choe-list> )

<choe-list> ::= LIST('choe'
								<cheh-ck>	// chord entry data
								<chrd-list>	// chord definition
								<ncsq-ck>	// connecting(next) chords
								)

<spst-list> ::= LIST('spst'
							 <spsh-ck>
							 <chrd-list>
							 [<cade-list>]
							 )

<cade-list> ::= LIST('cade' <chrd-list> ...)
								
<sbcn-ck> ::= sbcn(<cSubChordID:WORD>)

<ceed-ck> ::= ceed(ioChordEntryEdit)

<ched-ck> ::= ched(DMChordEdit)

<cheh-ck> ::= cheh(i<ioChordEntry>)

<ncrd-ck> ::= ncrd(<ioNextChord>)

<ncsq-ck> ::= ncsq(<wNextChordSize:WORD> <ioNextChord>...)

<spsh-ck> ::= spsh(<ioSignPost>)

///

// Signpost tracks

#define DMUS_FOURCC_SIGNPOST_TRACK_CHUNK	 mmioFOURCC( 's', 'g', 'n', 'p' )


struct ioDMSignPost
{
	MUSIC_TIME	m_mtTime;
	DWORD		m_dwChords;
	WORD		m_wMeasure;
};

///*

	// <sgnp-list>
	'sgnp'
	(
		//sizeof ioDMSignPost, followed by a number of <ioDMSignPost>
	)

///

// Personality tracks

#define DMUS_FOURCC_PERF_TRACK_LIST mmioFOURCC('p', 'f', 't', 'r')
#define DMUS_FOURCC_PERF_REF_LIST mmioFOURCC('p', 'f', 'r', 'f')
#define DMUS_FOURCC_TIME_STAMP_CHUNK mmioFOURCC('s', 't', 'm', 'p')

///*

	// <pftr-list>
	LIST('pftr'
	(
		// some number of <pfrf-list>
	)

	// <pfrf-list>
	LIST('pfrf'
	(
		<stmp-ck>
		<DMRF>
	)

  // <stmp-ck>
  'stmp'
  (
	// time:DWORD
  )



///

*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmcompos\memstm.cpp ===
//
//  Based on source from Win2k ole32.dll
//

#include "pchcompos.h"

#undef Assert
#define Assert(x) assert(x)

# define _xmemset memset
# define _xmemcpy memcpy
# define _xmemcmp memcmp
# define _xmemmove memmove

CMemStm::CMemStm()
{
        // mutex automatically initialized
        m_hMem = NULL;
        m_pData = NULL;
        m_pos = 0;
        m_refs = 0;
}

CMemStm::~CMemStm()
{
        // empty destructor, mutex automatically cleaned up
}


STDMETHODIMP CMemStm::QueryInterface(REFIID iidInterface,
        void FAR* FAR* ppvObj)
{
        HRESULT         error;

        *ppvObj = NULL;

        // Two interfaces supported: IUnknown, IStream

        if (m_pData != NULL && (IsEqualIID(iidInterface, IID_IStream) ||
                IsEqualIID(iidInterface, IID_ISequentialStream) ||
                IsEqualIID(iidInterface, IID_IUnknown)))
        {

                AddRef();   // A pointer to this object is returned
                *ppvObj = this;
                error = NOERROR;
        }
        else
        {                 // Not accessible or unsupported interface
                *ppvObj = NULL;
                error = E_NOINTERFACE;
        }

        return error;
}

STDMETHODIMP_(ULONG) CMemStm::AddRef(void)
{
        return InterlockedIncrement((LONG *) &m_refs);
}

STDMETHODIMP_(ULONG) CMemStm::Release(void)
{
        // The reason for this here is that there is a race when releasing
        // this object. If two threads are trying to release this object
        // at the same time, there is a case where the first one dec's
        // the ref count & then loses the processor to the second thread.
        // This second thread decrements the reference count to 0 and frees
        // the memory. The first thread can no longer safely examine the
        // internal state of the object.
        ULONG ulResult = InterlockedDecrement((LONG *) &m_refs);

        if (ulResult == 0)
        {
                // this MEMSTM handle was GlobalLock'ed in ::Create
                // we unlock it here, as we no longer need it.
                GlobalUnlock(m_hMem);

                ReleaseMemStm(&m_hMem, FALSE);

                delete this;
        }

        return ulResult;
}

STDMETHODIMP CMemStm::Read(void HUGEP* pb, ULONG cb, ULONG FAR* pcbRead)
{
        HRESULT         error = NOERROR;
        ULONG           cbRead = cb;

        if(cb)
        {
            // VDATEPTROUT( pb, char);
        }

        // Single thread
        CLock lck(m_mxs);

        if (pcbRead)
        {
                // VDATEPTROUT( pcbRead, ULONG );
                *pcbRead = 0L;
        }

	// cbRead + m_pos could cause roll-over.
        if ( ( (cbRead + m_pos) > m_pData->cb) || ( (cbRead + m_pos) < m_pos) )
        {
                // Caller is asking for more bytes than we have left
                if(m_pData->cb > m_pos)
                    cbRead = m_pData->cb - m_pos;
                else
                    cbRead = 0;
        }

        if (cbRead > 0)
        {
                assert(m_pData->hGlobal);
                BYTE HUGEP* pGlobal = (BYTE HUGEP *)GlobalLock(
                        m_pData->hGlobal);
                if (NULL==pGlobal)
                {
                        // LEERROR(1, "GlobalLock Failed!");

                        return STG_E_READFAULT;
                }
                // overlap is currently considered a bug (see the discussion
                // on the Write method
                _xmemcpy(pb, pGlobal + m_pos, cbRead);
                GlobalUnlock (m_pData->hGlobal);
                m_pos += cbRead;
        }

        if (pcbRead != NULL)
        {
                *pcbRead = cbRead;
        }

        return error;
}

STDMETHODIMP CMemStm::Write(void const HUGEP* pb, ULONG cb,
        ULONG FAR* pcbWritten)
{
        HRESULT                 error = NOERROR;
        ULONG                   cbWritten = cb;
        ULARGE_INTEGER          ularge_integer;
        BYTE HUGEP*             pGlobal;

        if(cb)
        {
            // VDATEPTRIN( pb , char );
        }

        // Single thread
        CLock lck(m_mxs);

        if (pcbWritten != NULL)
        {
                *pcbWritten = 0;
        }

        if (cbWritten + m_pos > m_pData->cb)
        {
                ULISet32( ularge_integer, m_pos+cbWritten );
                error = SetSize(ularge_integer);
                if (error != NOERROR)
                {
                        goto Exit;
                }
        }

        // we don't write anything if 0 bytes are asked for for two
        // reasons: 1. optimization, 2. m_pData->hGlobal could be a
        // handle to a zero-byte memory block, in which case GlobalLock
        // will fail.

        if( cbWritten > 0 )
        {
                pGlobal = (BYTE HUGEP *)GlobalLock (m_pData->hGlobal);
                if (NULL==pGlobal)
                {
                        // LEERROR(1, "GlobalLock Failed!");

                        return ResultFromScode (STG_E_WRITEFAULT);
                }

                // we use memmove here instead of memcpy to handle the
                // overlap case.  Recall that the app originally gave
                // use the memory for the memstm.  He could (either through
                // a CopyTo or through really strange code), be giving us
                // this region to read from, so we have to handle the overlapp
                // case.  The same argument also applies for Read, but for
                // now, we'll consider overlap on Read a bug.
                _xmemmove(pGlobal + m_pos, pb, cbWritten);
                GlobalUnlock (m_pData->hGlobal);

                m_pos += cbWritten;
        }

        if (pcbWritten != NULL)
        {
                *pcbWritten = cbWritten;
        }

Exit:

        return error;
}

STDMETHODIMP CMemStm::Seek(LARGE_INTEGER dlibMoveIN, DWORD dwOrigin,
        ULARGE_INTEGER FAR* plibNewPosition)
{
        HRESULT                 error  = NOERROR;
        LONG                    dlibMove = dlibMoveIN.LowPart ;
        ULONG                   cbNewPos = dlibMove;

        // Single thread
        CLock lck(m_mxs);

        if (plibNewPosition != NULL)
        {
                // VDATEPTROUT( plibNewPosition, ULONG );
                ULISet32(*plibNewPosition, m_pos);
        }

        switch(dwOrigin)
        {

        case STREAM_SEEK_SET:
                if (dlibMove >= 0)
                {
                        m_pos = dlibMove;
                }
                else
                {
                        error = STG_E_SEEKERROR;
                }

                break;

        case STREAM_SEEK_CUR:
                if (!(dlibMove < 0 && ((ULONG) -dlibMove) > m_pos))
                {
                        m_pos += dlibMove;
                }
                else
                {
                        error = STG_E_SEEKERROR;
                }
                break;

        case STREAM_SEEK_END:
                if (!(dlibMove < 0 && ((ULONG) -dlibMove) > m_pData->cb))
                {
                        m_pos = m_pData->cb + dlibMove;
                }
                else
                {
                        error = STG_E_SEEKERROR;
                }
                break;

        default:
                error = STG_E_SEEKERROR;
        }

        if (plibNewPosition != NULL)
        {
                ULISet32(*plibNewPosition, m_pos);
        }

        return error;
}

STDMETHODIMP CMemStm::SetSize(ULARGE_INTEGER cb)
{
        HANDLE hMemNew;

        // Single thread
        CLock lck(m_mxs);

        // make sure we aren't in overflow conditions.

        assert(cb.HighPart == 0);

        if (m_pData->cb == cb.LowPart)
        {
                return NOERROR;
        }

        hMemNew = GlobalReAlloc(m_pData->hGlobal, max (cb.LowPart,1),
                        GMEM_SHARE | GMEM_MOVEABLE);

        if (hMemNew == NULL)
        {
                return E_OUTOFMEMORY;
        }

        m_pData->hGlobal = hMemNew;
        m_pData->cb = cb.LowPart;

        return NOERROR;
}

STDMETHODIMP CMemStm::CopyTo(IStream FAR *pstm, ULARGE_INTEGER cb,
        ULARGE_INTEGER FAR * pcbRead, ULARGE_INTEGER FAR * pcbWritten)
{
        ULONG   cbRead          = cb.LowPart;
        ULONG   cbWritten       = 0;
        HRESULT hresult         = NOERROR;

        // pstm cannot be NULL

        // VDATEPTRIN(pstm, LPSTREAM);

        // Single thread
        CLock lck(m_mxs);

        // the spec says that if cb is it's maximum value (all bits set,
        // since it's unsigned), then we will simply read the copy of
        // this stream

        if ( ~(cb.LowPart) == 0 && ~(cb.HighPart) == 0 )
        {
                cbRead = m_pData->cb - m_pos;
        }
        else if ( cb.HighPart > 0 )
        {
                // we assume that our memory stream cannot
                // be large enough to accomodate very large (>32bit)
                // copy to requests.  Since this is probably an error
                // on the caller's part, we assert.

                assert(0);

                // set the Read value to what's left, so that "Ignore"ing
                // the assert works properly.

                cbRead = m_pData->cb - m_pos;
        }
        else if ( cbRead + m_pos > m_pData->cb )
        {
                // more bytes were requested to read than we had left.
                // cbRead is set to the amount remaining.

                cbRead = m_pData->cb - m_pos;
        }

        // now write the data to the stream

        if ( cbRead > 0 )
        {
                BYTE HUGEP* pGlobal = (BYTE HUGEP *)GlobalLock(
                                m_pData->hGlobal);

                if( pGlobal == NULL )
                {
                        // LEERROR(1, "GlobalLock failed");

                        return STG_E_INSUFFICIENTMEMORY;
                }

                hresult = pstm->Write(pGlobal + m_pos, cbRead, &cbWritten);

                // in the error case, the spec says that the return values
                // may be meaningless, so we do not need to do any special
                // error handling here

                GlobalUnlock(m_pData->hGlobal);
        }

        // increment our seek pointer and set the out parameters

        m_pos += cbRead;

        if( pcbRead )
        {
                ULISet32(*pcbRead, cbRead);
        }

        if( pcbWritten )
        {
                ULISet32(*pcbWritten, cbWritten);
        }

        return hresult;

}

STDMETHODIMP CMemStm::Commit(DWORD grfCommitFlags)
{
        return NOERROR;
}

STDMETHODIMP CMemStm::Revert(void)
{
        return NOERROR;
}

STDMETHODIMP CMemStm::LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb,
        DWORD dwLockType)
{
        return STG_E_INVALIDFUNCTION;
}

STDMETHODIMP CMemStm::UnlockRegion(ULARGE_INTEGER libOffset,
        ULARGE_INTEGER cb, DWORD dwLockType)
{
        return STG_E_INVALIDFUNCTION;
}

STDMETHODIMP CMemStm::Stat(STATSTG FAR *pstatstg, DWORD statflag)
{
        // VDATEPTROUT( pstatstg, STATSTG );

        memset ( pstatstg, 0, sizeof(STATSTG) );

        pstatstg->type                  = STGTY_STREAM;
        pstatstg->cbSize.LowPart        = m_pData->cb;

        return NOERROR;
}

STDMETHODIMP CMemStm::Clone(IStream FAR * FAR *ppstm)
{
        CMemStm FAR*    pCMemStm;

        // VDATEPTROUT (ppstm, LPSTREAM);

        *ppstm = pCMemStm = CMemStm::Create(m_hMem);

        if (pCMemStm == NULL)
        {
                return E_OUTOFMEMORY;
        }

        pCMemStm->m_pos = m_pos;

        return NOERROR;
}

CMemStm FAR* CMemStm::Create(HANDLE hMem)
{
        CMemStm FAR* pCMemStm = NULL;
        struct MEMSTM FAR* pData;

        pData = (MEMSTM FAR*) GlobalLock(hMem);

        if (pData != NULL)
        {
                pCMemStm = new CMemStm;

                if (pCMemStm != NULL)
                {
                        // Initialize CMemStm
                        pCMemStm->m_hMem = hMem;
                        (pCMemStm->m_pData = pData)->cRef++; // AddRefMemStm
                        pCMemStm->m_refs = 1;
                        pCMemStm->m_dwSig = STREAM_SIG;
                }
                else
                {
                        // uh-oh, low on memory
                        GlobalUnlock(hMem);
                }
        }

        // we do *not* unlock the memory now, the memstm structure should
        // be locked for the lifetime of any CMemStm's that refer to it.
        // when the CMemStm is destroyed, we will release our lock on
        // hMem.

        return pCMemStm;
}


STDAPI_(void) ReleaseMemStm (LPHANDLE phMem, BOOL fInternalOnly)
{
        struct MEMSTM FAR*      pData;

        pData = (MEMSTM FAR*) GlobalLock(*phMem);

        // check for NULL pointer in case handle got freed already
        // decrement ref count and free if no refs left
        if (pData != NULL && --pData->cRef == 0)
        {
                if (pData->fDeleteOnRelease)
                {
                        Verify (0==GlobalFree (pData->hGlobal));
                }

                if (!fInternalOnly)
                {
                        GlobalUnlock(*phMem);
                        Verify (0==GlobalFree(*phMem));
                        goto End;
                }
        }

        GlobalUnlock(*phMem);
End:
        *phMem = NULL;
}

#ifdef XBOX
STDAPI DMusic_CreateStreamOnHGlobal(HANDLE hGlobal, BOOL fDeleteOnRelease,
        LPSTREAM FAR* ppstm)
#else
STDAPI CreateStreamOnHGlobal(HANDLE hGlobal, BOOL fDeleteOnRelease,
        LPSTREAM FAR* ppstm)
#endif
{
        HANDLE                  hMem      = NULL;
        struct MEMSTM FAR*      pData     = NULL;
        LPSTREAM                pstm      = NULL;
        DWORD                   cbSize;
        HRESULT hresult;

        // VDATEPTROUT_LABEL (ppstm, LPSTREAM, SafeExit, hresult);

        *ppstm = NULL;

        if (NULL==hGlobal)
        {
#ifdef XBOX
            // XBox won't allow GMEM_MOVEABLE or GMEM_DISCARDABLE. Sharing is irrelevant here.
                hGlobal = GlobalAlloc(0, 0);
#else
                hGlobal = GlobalAlloc(GMEM_SHARE | GMEM_MOVEABLE, 0);
#endif
                if (hGlobal == NULL)
                {
                        goto ErrorExit;
                }
                cbSize = 0;
        }
        else
        {
                cbSize = (ULONG) GlobalSize (hGlobal);
                // Is there a way to verify a zero-sized handle?
                // we currently do no verification for them
                if (cbSize!=0)
                {
                        // verify validity of passed-in handle
                        if (NULL==GlobalLock(hGlobal))
                        {
                                // bad handle
                                hresult = E_INVALIDARG;
                                goto SafeExit;
                        }
                        GlobalUnlock (hGlobal);
                }
        }

#ifdef XBOX
            // XBox won't allow GMEM_MOVEABLE or GMEM_DISCARDABLE. Sharing is irrelevant here.
        hMem = GlobalAlloc (0, sizeof (MEMSTM));
#else
        hMem = GlobalAlloc (GMEM_SHARE | GMEM_MOVEABLE, sizeof (MEMSTM));
#endif
        if (hMem == NULL)
        {
                goto ErrorExit;
        }

        pData = (MEMSTM FAR*) GlobalLock(hMem);

        if (pData == NULL)
        {
                GlobalUnlock(hMem);
                goto FreeMem;
        }

        pData->cRef = 0;
        pData->cb = cbSize;
        pData->fDeleteOnRelease = fDeleteOnRelease;
        pData->hGlobal = hGlobal;
        GlobalUnlock(hMem);

        pstm = CMemStm::Create(hMem);

        if (pstm == NULL)
        {
                goto FreeMem;
        }

        *ppstm = pstm;

        // CALLHOOKOBJECTCREATE(S_OK,CLSID_NULL,IID_IStream,(IUnknown **)ppstm);
        hresult = NOERROR;
        goto SafeExit;

FreeMem:
        if (hMem)
        {
            Verify(0==GlobalFree(hMem));
        }
ErrorExit:

        // LEERROR(1, "Out of memory!");

        hresult = E_OUTOFMEMORY;

SafeExit:

        // OLETRACEOUT((API_CreateStreamOnHGlobal, hresult));

        return hresult;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmcompos\spsttrk.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       spsttrk.h
//
//--------------------------------------------------------------------------

// SPstTrk.h : Declaration of the CSPstTrk

#ifndef __SPSTTRK_H_
#define __SPSTTRK_H_

#include "dmusicip.h"
#include "DMCompos.h"

/////////////////////////////////////////////////////////////////////////////
// CSPstTrk
class CSPstTrk : 
	public IPersistStream,
	public IDirectMusicTrack8
{
public:
	CSPstTrk();
	CSPstTrk(const CSPstTrk& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd);
	~CSPstTrk();

// ISPstTrk
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

// ICommandTrack Methods
HRESULT STDMETHODCALLTYPE Init(
				/*[in]*/  IDirectMusicSegment*		pSegment
			);

HRESULT STDMETHODCALLTYPE InitPlay(
				/*[in]*/  IDirectMusicSegmentState*	pSegmentState,
				/*[in]*/  IDirectMusicPerformance*	pPerformance,
				/*[out]*/ void**					ppStateData,
				/*[in]*/  DWORD						dwTrackID,
                /*[in]*/  DWORD                     dwFlags
			);

HRESULT STDMETHODCALLTYPE EndPlay(
				/*[in]*/  void*						pStateData
			);

HRESULT STDMETHODCALLTYPE Play(
				/*[in]*/  void*						pStateData, 
				/*[in]*/  MUSIC_TIME				mtStart, 
				/*[in]*/  MUSIC_TIME				mtEnd, 
				/*[in]*/  MUSIC_TIME				mtOffset,
						  DWORD						dwFlags,
						  IDirectMusicPerformance*	pPerf,
						  IDirectMusicSegmentState*	pSegState,
						  DWORD						dwVirtualID
			);

HRESULT STDMETHODCALLTYPE GetPriority( 
				/*[out]*/ DWORD*					pPriority 
			);

HRESULT STDMETHODCALLTYPE GetParam(
				REFGUID						rCommandGuid,
				MUSIC_TIME					mtTime, 
				MUSIC_TIME*					pmtNext,
				void*						pData
			);

	HRESULT STDMETHODCALLTYPE SetParam( 
		/* [in] */ REFGUID						rCommandGuid,
		/* [in] */ MUSIC_TIME mtTime,
		/* [out] */ void __RPC_FAR *pData);

	HRESULT STDMETHODCALLTYPE AddNotificationType(
				/* [in] */  REFGUID						rGuidNotify
			);

	HRESULT STDMETHODCALLTYPE RemoveNotificationType(
				/* [in] */  REFGUID						rGuidNotify
			);

	HRESULT STDMETHODCALLTYPE Clone(
		MUSIC_TIME mtStart,
		MUSIC_TIME mtEnd,
		IDirectMusicTrack** ppTrack);

// IDirectMusicCommon Methods
HRESULT STDMETHODCALLTYPE GetName(
				/*[out]*/  BSTR*		pbstrName
			);

HRESULT STDMETHODCALLTYPE IsParamSupported(
				/*[in]*/ REFGUID						rGuid
			);

// IPersist methods
 HRESULT STDMETHODCALLTYPE GetClassID( LPCLSID pclsid );

// IPersistStream methods
 HRESULT STDMETHODCALLTYPE IsDirty();

HRESULT STDMETHODCALLTYPE Save( LPSTREAM pStream, BOOL fClearDirty );

HRESULT STDMETHODCALLTYPE GetSizeMax( ULARGE_INTEGER* /*pcbSize*/ );

HRESULT STDMETHODCALLTYPE Load( LPSTREAM pStream );

// IDirectMusicTrack8 Methods
    STDMETHODIMP PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf, 
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) ; 
    STDMETHODIMP GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) ; 
    STDMETHODIMP SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,void* pParam, void * pStateData, DWORD dwFlags) ;
    STDMETHODIMP Compose(IUnknown* pContext, 
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;
    STDMETHODIMP Join(IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;

protected:
// internal methods
	HRESULT SendNotification(MUSIC_TIME mtTime,
						 IDirectMusicPerformance*	pPerf,
						 IDirectMusicSegment* pSegment,
						 IDirectMusicSegmentState*	pSegState,
						 DWORD dwFlags);

	void Clear();

// attributes
    long m_cRef;
	TList<DMSignPostStruct>		m_SignPostList;
    CRITICAL_SECTION			m_CriticalSection; // for load and SetParam
    BOOL                        m_fCSInitialized;
	IDirectMusicPerformance*	m_pPerformance; // is this necessary?
	CDMCompos*					m_pComposer; // for Segment Recompose on loop
//	IDirectMusicSegment*		m_pSegment;
    BOOL                        m_fNotifyRecompose;
    CMemTrack                   m_MemTrack;             // For debug memory tracking.
	BYTE						m_bRequiresSave;
};

#endif //__SPSTTRK_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmcompos\templats.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1998 Microsoft Corporation
//
//  File:       templats.h
//
//--------------------------------------------------------------------------

// templates.h

#ifndef __TEMPLATES_H__
#define __TEMPLATES_H__

template< class T > T* List_Cat( T* p1, T* p2 )
{
    T* pScan;

    if( p1 == NULL )
    {
        return p2;
    }
    for( pScan = p1 ; pScan->pNext != NULL ; pScan = (T*)pScan->pNext );
    pScan->pNext = p2;
    return p1;
}

template< class T > DWORD List_Len( T* p )
{
    DWORD dw;

    for( dw = 0 ; p != NULL ; p = (T*)p->pNext )
    {
         ++dw;
    }

    return dw;
}

template< class T > BOOL inlist( T* lst, T* p )
{
    if( p == NULL )
    {
        return TRUE;
    }

    for( ; lst != NULL ; lst = (T*)lst->pNext )
    {
        if( p == lst )
        {
            return TRUE;
        }
    }

    return FALSE;
}

template< class T > T* List_Index( T* lst, DWORD dwIndex )
{
    T* pScan;

    for( pScan = lst ; dwIndex > 0 && pScan != NULL && pScan->pNext != NULL ; --dwIndex, pScan = (T*)pScan->pNext );

    return pScan;
}

template< class T > T* List_Insert( T* lst, T* p, DWORD dwIndex )
{
    T* pPrev;

    if( lst == NULL || dwIndex == 0 )
    {
        p->pNext = lst;
        lst = p;
    }
    else
    {
        pPrev = List_Index( lst, dwIndex - 1 );
        p->pNext = pPrev->pNext;
        pPrev->pNext = p;
    }

    return lst;
}

template< class T > T* List_Remove( T* lst, T* p )
{
    if( lst != NULL )
    {
        if( lst == p )
        {
            lst = (T*)lst->pNext;
            p->pNext = NULL;
        }
        else
        {
            T* pScan;

            for( pScan = lst ; pScan->pNext != p && pScan->pNext != NULL ; pScan = (T*)pScan->pNext );
            if( pScan->pNext != NULL )
            {
                pScan->pNext = pScan->pNext->pNext;
                p->pNext = NULL;
            }
        }
    }

    return lst;
}

template< class T > long List_Position( T* lst, T* p )
{
    long lPos;

    lPos = 0;
    while( lst != NULL && lst != p )
    {
        lst = lst->pNext;
        ++lPos;
    }
    if( lst == NULL )
    {
        return -1;
    }

    return lPos;
}

template< class T > T* List_Clone( T* lst )
{
    T* pPrev;
    T* lstClone;
    T* pCopy;

    lstClone = NULL;
    pPrev = NULL;

    for( ; lst ; lst = (T*)lst->pNext )
    {
        pCopy = new T;
        if( pCopy != NULL )
        {
            memcpy( pCopy, lst, sizeof( T ) );
            pCopy->pNext = NULL;
            if( pPrev != NULL )
            {
                pPrev->pNext = pCopy;
            }
            else
            {
                lstClone = pCopy;
            }
            pPrev = pCopy;
        }
    }

    return lstClone;
}

template< class T > void List_Free( T* lst )
{
    T* pNext;

    for( ; lst != NULL ; lst = pNext )
    {
        pNext = (T*)lst->pNext;
        delete lst;
    }
}

template< class T > T* Clone( T* p )
{
    T* pCopy;

    pCopy = new T;
    if( pCopy != NULL )
    {
        memcpy( pCopy, p, sizeof( T ) );
        pCopy->pNext = NULL;
    }

    return pCopy;
}

#endif // __TEMPLATES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmcompos\tlist.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1998 Microsoft Corporation
//
//  File:       tlist.cpp
//
//--------------------------------------------------------------------------

//
// tlist.cpp
//

//#include "stdafx.h"
#include "tlist.h"

template <class T>
TListItem<T>::~TListItem()
{
	//if (m_pNext != NULL) { delete m_pNext; }
	// IMPORTANT: user of the list is required to delete content first!
	//ZeroMemory(&m_Tinfo, sizeof(T));
}

template <class T>
void TListItem<T>::Delete(TListItem<T>* pFirst)
{
	TListItem<T>* pScan = pFirst;
	TListItem<T>* pNext = NULL;
	while (pScan)
	{
		pNext = pScan->m_pNext;
		delete pScan;
		pScan = pNext;
	}
}

template <class T>
LONG TListItem<T>::GetCount(void) const
{
    LONG l;
    const TListItem<T> *li;

    for(l=0,li=this; li!=NULL ; li=li->m_pNext,++l);
    return l;
}

template <class T>
TListItem<T>* TListItem<T>::Cat(TListItem<T> *pItem)
{
    TListItem<T> *li;

    if(this==NULL)
        return pItem;
    for(li=this ; li->m_pNext!=NULL ; li=li->m_pNext);
    li->m_pNext=pItem;
    return this;
}

template <class T>
TListItem<T>* TListItem<T>::Remove(TListItem<T> *pItem)
{
    TListItem<T> *li,*prev;

    if(pItem==this)
        return m_pNext;
    prev=NULL;
    for(li=this; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    if(li==NULL)     // item not found in list
        return this;

//  here it is guaranteed that prev is non-NULL since we checked for
//  that condition at the very beginning

    prev->SetNext(li->m_pNext);
    li->SetNext(NULL);
    return this;
}

template <class T>
TListItem<T>* TListItem<T>::GetPrev(TListItem<T> *pItem) const
{
    const TListItem<T> *li,*prev;

    prev=NULL;
    for(li=this ; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    return (TListItem<T>*)prev;
}

template <class T>
TListItem<T> * TListItem<T>::GetItem(LONG index)

{
	TListItem<T> *scan;
	for (scan = this; scan!=NULL && index; scan = scan->m_pNext) 
	{
		index--;
	}
	return (scan);
}

template <class T>
TListItem<T>* TListItem<T>::MergeSort(BOOL (* fcnCompare) (T&, T&))
{
	if (m_pNext != NULL)
	{
		TListItem<T> *pList1, *pList2;
		Divide(pList1, pList2);
		return pList1->MergeSort(fcnCompare)->Merge(pList2->MergeSort(fcnCompare), fcnCompare);
	}
	return this;
}

template <class T>
void TListItem<T>::Divide(TListItem<T>*& pHead1, TListItem<T>*& pHead2)
{
	TListItem<T> *pCurrent = this, *pTail1 = NULL, *pTail2 = NULL;
	do
	{
		pHead1 = pCurrent;
		pCurrent = pCurrent->m_pNext;
		pHead1->m_pNext = pTail1;
		pTail1 = pHead1;
		if (pCurrent != NULL)
		{
			pHead2 = pCurrent;
			pCurrent = pCurrent->m_pNext;
			pHead2->m_pNext = pTail2;
			pTail2 = pHead2;
		}
	} while (pCurrent != NULL);
}

template <class T>
TListItem<T>* TListItem<T>::Merge(TListItem<T>* pOtherList, BOOL (* fcnCompare) (T&, T&))
{
	if (!pOtherList) return this;
	TListItem<T>
		*pThisList = this, *pResultHead = NULL, *pResultTail = NULL, *pMergeItem = NULL;
	while (pThisList && pOtherList)
	{
		if ( fcnCompare(pThisList->m_Tinfo, pOtherList->m_Tinfo) )
		{
			pMergeItem = pThisList;
			pThisList = pThisList->GetNext();
		}
		else
		{
			pMergeItem = pOtherList;
			pOtherList = pOtherList->GetNext();
		}
		pMergeItem->SetNext(NULL);
		if (!pResultTail)
		{
			pResultHead = pResultTail = pMergeItem;
		}
		else
		{
			pResultTail->SetNext(pMergeItem);
			pResultTail = pMergeItem;
		}
	}
	if (pThisList) pResultTail->SetNext(pThisList);
	else pResultTail->SetNext(pOtherList);
	return pResultHead;
}

template <class T>
void TList<T>::InsertBefore(TListItem<T> *pItem,TListItem<T> *pInsert)

{
	TListItem<T> *prev = GetPrev(pItem);
	pInsert->SetNext(pItem);
	if (prev) prev->SetNext(pInsert);
	else m_pHead = pInsert;
}

template <class T>
void TList<T>::AddTail(TListItem<T> *pItem) 

{
	m_pHead = m_pHead->AddTail(pItem);
}

template <class T>
void TList<T>::MergeSort(BOOL (* fcnCompare) (T&, T&))
{
	if (m_pHead != NULL && m_pHead->GetNext() != NULL)
		m_pHead = m_pHead->MergeSort(fcnCompare);
}

template <class T>
void TList<T>::Reverse(void)
{
	if( m_pHead )
	{
		TListItem<T>* pNewHead = m_pHead;
		TListItem<T>* pNext = m_pHead->GetNext();
		pNewHead->SetNext(NULL);
		for( m_pHead = pNext; m_pHead; m_pHead = pNext )
		{
			pNext = m_pHead->GetNext();
			m_pHead->SetNext(pNewHead);
			pNewHead = m_pHead;
		}
		m_pHead = pNewHead;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmcompos\tlist.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1998 Microsoft Corporation
//
//  File:       tlist.h
//
//--------------------------------------------------------------------------

//
// tlist.h --- template version of AList
//
#ifndef __TLIST_H__
#define __TLIST_H__

//#include "stdafx.h"

//template <class T>
//typedef BOOL (* TRelation) (T, T);

// TListItem<> contains four more members than AListItem: one additional constructor,
// a destructor, one member function, and one data member.
template <class T>
class TListItem
{
public:
    TListItem() { m_pNext=NULL; };
    ~TListItem();												// new destructor
	static void Delete(TListItem<T>* pFirst);                           // new deletion helper
    TListItem(const T& item) { m_Tinfo = item; m_pNext=NULL; };	// additional constructor.
    TListItem<T> *GetNext() const {return m_pNext;};
    void SetNext(TListItem<T> *pNext) {m_pNext=pNext;};
    LONG GetCount() const;
    TListItem<T>* Cat(TListItem<T>* pItem);
    TListItem<T>* AddTail(TListItem<T>* pItem) {return Cat(pItem);};
    TListItem<T>* Remove(TListItem<T>* pItem);
    TListItem<T>* GetPrev(TListItem<T> *pItem) const;
    TListItem<T>* GetItem(LONG index);
    T& GetItemValue() { return m_Tinfo; }  // additional member function
	TListItem<T>* MergeSort(BOOL (* fcnCompare) (T&, T&)); // Destructively mergeSorts the list items 
private:
	void Divide(TListItem<T>* &pHalf1, TListItem<T>* &pHalf2);
	TListItem<T>* Merge(TListItem<T>* pOtherList, BOOL (* fcnCompare) (T&, T&));
	T m_Tinfo;  // additional data member, but memory is the same since in AListItem 
				// you put the extra data member in the derived class 
    TListItem<T> *m_pNext;
};

// TList<> adds a destructor to AList.
template <class T>
class TList
{
public:
    TList() {m_pHead=NULL;}
	~TList()
	{ 
		//if (m_pHead != NULL) delete m_pHead;
		TListItem<T>::Delete(m_pHead);
	} // new destructor
    TListItem<T> *GetHead() const { return m_pHead;};

    void RemoveAll() { m_pHead=NULL;};
    void CleanUp() 
	{ 
		//if (m_pHead) delete m_pHead;
		if (m_pHead) TListItem<T>::Delete(m_pHead);
		m_pHead=NULL;
	}
    LONG GetCount() const {return m_pHead->GetCount();}; 
    TListItem<T> *GetItem(LONG index) { return m_pHead->GetItem(index);}; 
    void InsertBefore(TListItem<T> *pItem,TListItem<T> *pInsert);
    void Cat(TListItem<T> *pItem) {m_pHead=m_pHead->Cat(pItem);};
    void Cat(TList<T> *pList)
        {
//            assert(pList!=NULL);
            m_pHead=m_pHead->Cat(pList->GetHead());
        };
    void AddHead(TListItem<T> *pItem)
        {
//            assert(pItem!=NULL);
            pItem->SetNext(m_pHead);
            m_pHead=pItem;
        }
    void AddTail(TListItem<T> *pItem);// {m_pHead=m_pHead->AddTail(pItem);};
    void Remove(TListItem<T> *pItem) {m_pHead=m_pHead->Remove(pItem);};
    TListItem<T> *GetPrev(TListItem<T> *pItem) const {return m_pHead->GetPrev(pItem);};
    TListItem<T> *GetTail() const {return GetPrev(NULL);};
    BOOL IsEmpty(void) const {return (m_pHead==NULL);};
    TListItem<T> *RemoveHead(void)
        {
            TListItem<T> *li;
            li=m_pHead;
            if(m_pHead)
			{
                m_pHead=m_pHead->GetNext();
				li->SetNext(NULL);
			}
            return li;
        }
	void MergeSort(BOOL (* fcnCompare) (T&, T&)); // Destructively mergeSorts the list
	void Reverse(void); // Reverses the entire list

protected:
    TListItem<T> *m_pHead;
};

#include "tlist.cpp"

#endif // __TLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\alist.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
// alist.cpp
//
#include "pchime.h"

LONG AListItem::GetCount(void) const
{
    LONG l;
    const AListItem *li;

    for(l=0,li=this; li!=NULL ; li=li->m_pNext,++l);
    return l;
}

AListItem* AListItem::Cat(AListItem *pItem)
{
    AListItem *li;

    if(this==NULL)
        return pItem;
    for(li=this ; li->m_pNext!=NULL ; li=li->m_pNext);
    li->m_pNext=pItem;
    return this;
}

AListItem* AListItem::Remove(AListItem *pItem)
{
    AListItem *li,*prev;

    //treat remove(NULL) same as item not found in list
   if (pItem==NULL) 
   return this;

    if(pItem==this)
    {
        li = m_pNext;
        m_pNext = NULL;
        return li;
    }
    prev=NULL;
    for(li=this; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    if(li==NULL)     // item not found in list
        return this;

//  here it is guaranteed that prev is non-NULL since we checked for
//  that condition at the very beginning

    prev->SetNext(li->m_pNext);
    li->SetNext(NULL);

    // SetNext on pItem to NULL
    pItem->SetNext(NULL);

    return this;
}

AListItem* AListItem::GetPrev(AListItem *pItem) const
{
    const AListItem *li,*prev;

    prev=NULL;
    for(li=this ; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    return (AListItem*)prev;
}

AListItem * AListItem::GetItem(LONG index)

{
	AListItem *scan;
	for (scan = this; scan!=NULL && index; scan = scan->m_pNext) 
	{
		index--;
	}
	return (scan);
}

void AList::InsertBefore(AListItem *pItem,AListItem *pInsert)

{
	AListItem *prev = GetPrev(pItem);
	pInsert->SetNext(pItem);
	if (prev) prev->SetNext(pInsert);
	else m_pHead = pInsert;
}

void AList::AddTail(AListItem *pItem)
{
    if (m_pHead == NULL)
    {
        AddHead(pItem);
    }
    else
    {
        m_pHead = m_pHead->AddTail(pItem);
    }
}

void AList::Reverse()

{
    AList Temp;
    AListItem *pItem;
    while (pItem = RemoveHead())
    {
        Temp.AddHead(pItem);
    }
    m_pHead = Temp.GetHead();
}

BOOL AList::IsMember(AListItem *pItem)

{
    AListItem *pScan = GetHead();
    for (;pScan;pScan = pScan->GetNext())
    {
        if (pItem == pScan) return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmcompos\sjpers.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1998 Microsoft Corporation
//
//  File:       sjpers.h
//
//--------------------------------------------------------------------------

// SJPers.h  #defines and structs from SuperJam!  Used for loading personalities.

#define CM_DEFAULT  2               // Prsonality.dwflags & CM_DEFAULT

#define SP_A        1       // Use SP flags for templates
#define SP_B        2
#define SP_C        4
#define SP_D        8
#define SP_E        0x10
#define SP_F        0x20
#define SP_LETTER   (SP_A | SP_B | SP_C | SP_D | SP_E | SP_F)
#define SP_1        0x100
#define SP_2        0x200
#define SP_3        0x400
#define SP_4        0x800
#define SP_5        0x1000
#define SP_6        0x2000
#define SP_7        0x4000
#define SP_ROOT     (SP_1 | SP_2 | SP_3 | SP_4 | SP_5 | SP_6 | SP_7)
#define SP_CADENCE  0x8000

#define SPOST_CADENCE1  2   // Use the first cadence chord.
#define SPOST_CADENCE2  4   // Use the second cadence chord.

#define PF_FILL     0x0001      // Fill pattern
#define PF_START    0x0002      // May be starting pattern
#define PF_INTRO    0x0002
#define PF_WHOLE    0x0004      // Handles chords on measures
#define PF_HALF     0x0008      // Chords every two beats
#define PF_QUARTER  0x0010      // Chords on beats
#define PF_BREAK    0x0020
#define PF_END      0x0040
#define PF_A        0x0080
#define PF_B        0x0100
#define PF_C        0x0200
#define PF_D        0x0400
#define PF_E        0x0800
#define PF_F        0x1000
#define PF_G        0x2000
#define PF_H        0x10000
#define PF_STOPNOW  0x4000
#define PF_INRIFF   0x8000
#define PF_MOTIF    0x20000     // this pattern is a motif, not a regular pattern
#define PF_BEATS    ( PF_WHOLE | PF_HALF | PF_QUARTER )
#define PF_RIFF     ( PF_INTRO | PF_BREAK | PF_FILL | PF_END )
#define PF_GROOVE   ( PF_A | PF_B | PF_C | PF_D | PF_E | PF_F | PF_G | PF_H )


/*  SCTchord bBits flags ===============================================*/

#define CHORD_INVERT  0x10      /* This chord may be inverted           */
#define CHORD_FOUR    0x20      /* This should be a 4 note chord        */
#define CHORD_UPPER   0x40      /* Shift upper octave down              */
#define CHORD_SIMPLE  0x80      /* This is a simple chord               */
#define CHORD_COUNT   0x0F      /* Number of notes in chord (up to 15)  */

#pragma pack(1)

typedef struct ChordExt    FAR *LPCHORDEXT;
struct ChordExt   // Based on ChordSelection
{
    LPCHORDEXT pNext;
    long       time;
    long       pattern;      // Pattern that defines chord
    char       name[12];     // Text for display
    char       keydown;      // Currently held down
    char       root;         // Root note of chord
    char       inscale;      // Member of scale
    char       flat;         // Display with flat
    short      varflags;     // Used to select appropriate variation
    short      measure;      // What measure
    char       beat;         // What beat this falls on
    unsigned   char bits;    // Invert and item count
    long       scalepattern; // Scale Pattern for the chord
    long       melodypattern;// Melody Pattern for the chord
};

typedef struct SinePost    FAR *LPSINEPOST ;
struct SinePost
{
    LPSINEPOST      pNext ;          // The next personality in the list.
    ChordExt        chord;          // Chord for sign post.
    ChordExt        cadence[2];     // Chords for cadence.
    DWORD           chords;         // Which kinds of signpost supported.
    DWORD           flags;
    DWORD           tempflags;
};

typedef struct ChrdEntry   FAR *LPCHRDENTRY ;

typedef struct NextChrd    FAR *LPNEXTCHRD ;
struct NextChrd
{
    LPNEXTCHRD      pNext;           // List of chords to go to next.
    LPCHRDENTRY     nextchord;
    unsigned long   dwflags;
    short           nweight;        // Importance of destination chord.
    short           nminbeats;      // Min beats to wait till chord.
    short           nmaxbeats;      // Max beats to wait till chord.
    short           nid;            // ID of destination chord.
};

#define NEXTCHORD_SIZE  (sizeof(NextChrd)-sizeof(LPNEXTCHRD)-sizeof(LPCHRDENTRY))
#define CHORDENTRY_SIZE (sizeof(ChordExt)-sizeof(LPCHORDEXT)+sizeof(unsigned long)+sizeof(short))

#define CE_SELECTED 1               // This is the active chord.
#define CE_START    2
#define CE_END      4
#define CE_MEASURE  8
#define CE_PATH     16
#define CE_TREE     32

struct ChrdEntry
{
    LPCHRDENTRY     pNext ;          // The next personality in the list.
    LPNEXTCHRD      nextchordlist;  // List of chords to go to next.
    ChordExt        chord;          // Chord definition.
    unsigned long   dwflags;        // Various flags.
    short           nid;            // ID for pointer maintenance.
};

typedef struct SCTchord     FAR *LPSCTCHORD ;
struct SCTchord
{
    LPSCTCHORD      pNext;         /* The next chord in the list.      */
    long            lDLL1;          /*   Reserved for use by score.dll  */
    long            lPattern;       /* Pattern that defines chord.      */
    char            achName[12];    /* Chord name.                      */
    char            chDLL2;         /*   Reserved for use by score.dll  */
    char            chRoot;         /* Root note of chord.              */
    char            chDLL3;         /*   Reserved for use by score.dll  */
    char            chFlat;         /* Indicates root is flat.          */
    short           nDLL4;          /*   Reserved for use by score.dll  */
    short           nMeasure;       /* Measure this chord occurs.       */
    char            chBeat;         /* Beat this chord falls on.        */
    BYTE            bBits;          /* Flags used when playing chord    */
    long            lScalePattern;  /* Scale Pattern for the chord.     */
    long            lMelodyPattern; /* Melody Pattern for the chord.    */
};

typedef struct SCTpersonality FAR *LPSCTPERSONALITY ;
struct SCTpersonality
{
    LPSCTPERSONALITY pNext ;       /* Next SCTpersonality in the list. */
    char        achName[20] ;       /* Name of composition personality. */
    char        achDescription[80];/* Description of personality.      */
    char        achUserName[20];/* Description of personality.      */
    LPVOID      lpDLL1 ;            /*   Reserved for use by score.dll  */
    long        lScalePattern ;     /* Scale pattern used by personality*/
    SCTchord    chord[24] ;         /* 24 note chord palette.           */
    char        chDefault ;         /* 0=Not default. 1=Default.        */
    char        chDLL1 ;            /*  Reserved for use by score.dll   */
};

typedef struct Prsonality    FAR *LPPERSONALITY ;
struct Prsonality
{
    LPPERSONALITY   pNext ;          // The next personality in the list.
    LPCHRDENTRY     chordlist;      // All chords in the map.
    LPSINEPOST      signpostlist;   // All available sign posts.
    DWORD           dwAA;           // only valid for separately loaded personalities
    long            scalepattern;   // Scale for map.
    char            name[20];
    char            description[80];
    char            username[20];
    SCTchord        chord[24];
    unsigned long   dwflags;
    long            playlist;       // Collection of NextChords for playback.
    LPCHRDENTRY     firstchord;
    struct SCTpersonality* lpSCTpersonality;
};

typedef struct CommandExt    FAR *LPCOMMAND;
typedef struct CommandExt
{
    LPCOMMAND   pNext;
    long        time;       // Time, in clocks
    short       measure;    // Which measure
    DWORD       command;    // Command type
    DWORD       chord;      // Used by composition engine
} CommandExt;

typedef struct SCTcommand   FAR *LPSCTCOMMAND ;
typedef struct SCTcommand
{
    LPSCTCOMMAND  pNext ;    // The next command in the list.
    long          lDLL1 ;     //   Reserved for use by score.dll.
    short         nMeasure ;  // Measure this command occurs. 
    DWORD         dwCommand ; // Command type. 
    DWORD         dwChord ;   // Signpost chord.
} SCTcommand ;

typedef struct SCTtemplate  FAR *LPSCTTEMPLATE ;
typedef struct SCTtemplate
{
    LPSCTTEMPLATE pNext ;           // The next template in the list.
    char          achName[20] ;      // Template name.
    char          achType[20] ;      // Template type.
    short         nMeasures ;
    LPSCTCOMMAND  lpSCTcommandList ; // Template commands. 
} SCTtemplate ;

#pragma pack()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmcompos\sources.inc ===
!IF 0

Copyright (c) 1989-1999 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Jim Geist (JimGe) 29-Aug-97

NOTE:   Commented description of this file is in \nt\oak\bin\sources.tpl

!ENDIF

!include ..\..\sources.inc

MAJORCOMP=windows
MINORCOMP=directx

TARGETNAME=dmcompos$(LIBEXT)

!IF !$(FREEBUILD) && defined( DIRECTX_REDIST )
TARGETNAME=dmcompod
!ENDIF


TARGETTYPE = LIBRARY
TARGETPATH = ..\..\obj
USE_MAPSYM=1
USE_NOLIBS=1

!if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"

!if "$(BuildMode)" == "internal"
C_DEFINES = $(C_DEFINES) -DDEBUG=1
!else
C_DEFINES = $(C_DEFINES) -DRDEBUG=1
!endif

!endif

C_DEFINES= $(C_DEFINES) -D_WIN32 -D_MT -DXBOX -DUNICODE

MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /W3 /WX

INCLUDES=$(INCLUDES);   \
    ..\..\shared; \
    ..\..\xprivate; \
    ..

	
PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\pchcompos.h
PRECOMPILED_PCH=pchcompos.pch
PRECOMPILED_OBJ=pchcompos.obj

SOURCES=\
dmcmpdll.cpp        \
dmcompos.cpp        \
dmpers.cpp          \
dmtempl.cpp         \
spsttrk.cpp         \
str.cpp             \
perstrk.cpp         \
dmcomp2.cpp         \
memstm.cpp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmcompos\perstrk.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       perstrk.cpp
//
//--------------------------------------------------------------------------

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// INITIALIZE_CRITICAL_SECTION. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

// PersTrk.cpp : Implementation of CPersonalityTrack
#include "pchcompos.h"

/////////////////////////////////////////////////////////////////////////////
// CPersonalityTrack


CPersonalityTrack::CPersonalityTrack() : 
	m_bRequiresSave(0), 
	m_cRef(1),
    m_fCSInitialized(FALSE),
    m_MemTrack(DMTRACK_CHORDMAP_TRACK)

{
	IncrementDLLCount();

    // Do this first since it might throw an exception
    //
    INITIALIZE_CRITICAL_SECTION( &m_CriticalSection );
    m_fCSInitialized = TRUE;
}

CPersonalityTrack::CPersonalityTrack(const CPersonalityTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd)  : 
	m_bRequiresSave(0),
	m_cRef(1),
    m_fCSInitialized(FALSE),
    m_MemTrack(DMTRACK_CHORDMAP_TRACK)

{
	IncrementDLLCount();

    // Do this first since it might throw an exception
    //
    INITIALIZE_CRITICAL_SECTION( &m_CriticalSection );
    m_fCSInitialized = TRUE;
	TListItem<StampedPersonality>* pScan = rTrack.m_PersonalityList.GetHead();
	TListItem<StampedPersonality>* pPrevious = NULL;
	for(; pScan; pScan = pScan->GetNext())
	{
		StampedPersonality& rScan = pScan->GetItemValue();
		if (rScan.m_mtTime < mtStart)
		{
			pPrevious = pScan;
		}
		else if (rScan.m_mtTime < mtEnd)
		{
			if (rScan.m_mtTime == mtStart)
			{
				pPrevious = NULL;
			}
			TListItem<StampedPersonality>* pNew = new TListItem<StampedPersonality>;
			if (pNew)
			{
				StampedPersonality& rNew = pNew->GetItemValue();
				rNew.m_mtTime = rScan.m_mtTime - mtStart;
				rNew.m_pPersonality = rScan.m_pPersonality;
				if (rNew.m_pPersonality) rNew.m_pPersonality->AddRef();
				m_PersonalityList.AddTail(pNew);
			}
		}
		else break;
	}
	if (pPrevious)
	{
		TListItem<StampedPersonality>* pNew = new TListItem<StampedPersonality>;
		if (pNew)
		{
			StampedPersonality& rNew = pNew->GetItemValue();
			rNew.m_mtTime = 0;
			rNew.m_pPersonality = pPrevious->GetItemValue().m_pPersonality;
			if (rNew.m_pPersonality) rNew.m_pPersonality->AddRef();
			m_PersonalityList.AddHead(pNew);
		}
	}
}

CPersonalityTrack::~CPersonalityTrack()
{
    if (m_fCSInitialized)
    {
        DELETE_CRITICAL_SECTION( &m_CriticalSection );
    }
	DecrementDLLCount();
}

STDMETHODIMP CPersonalityTrack::QueryInterface(
    const IID &iid, 
    void **ppv) 
{
	V_INAME(CPersonalityTrack::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack || iid == IID_IDirectMusicTrack8)
    {
        *ppv = static_cast<IDirectMusicTrack*>(this);
	}
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
	}
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CPersonalityTrack::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CPersonalityTrack::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}


HRESULT CPersonalityTrack::Init(
				/*[in]*/  IDirectMusicSegment*		pSegment
			)
{
	return S_OK;
}

HRESULT CPersonalityTrack::InitPlay(
				/*[in]*/  IDirectMusicSegmentState*	pSegmentState,
				/*[in]*/  IDirectMusicPerformance*	pPerformance,
				/*[out]*/ void**					ppStateData,
				/*[in]*/  DWORD						dwTrackID,
                /*[in]*/  DWORD                     dwFlags
			)
{
	return S_OK;
}

HRESULT CPersonalityTrack::EndPlay(
				/*[in]*/  void*						pStateData
			)
{
	return S_OK;
}

HRESULT CPersonalityTrack::Play(
				/*[in]*/  void*						pStateData, 
				/*[in]*/  MUSIC_TIME				mtStart, 
				/*[in]*/  MUSIC_TIME				mtEnd, 
				/*[in]*/  MUSIC_TIME				mtOffset,
						  DWORD						dwFlags,
						  IDirectMusicPerformance*	pPerf,
						  IDirectMusicSegmentState*	pSegState,
						  DWORD						dwVirtualID
			)
{ 
	return S_OK;
}

HRESULT CPersonalityTrack::GetPriority( 
				/*[out]*/ DWORD*					pPriority 
			)
	{
		return E_NOTIMPL;
	}

HRESULT CPersonalityTrack::GetParam(
				REFGUID						rCommandGuid,
				MUSIC_TIME					mtTime, 
				MUSIC_TIME*					pmtNext,
				void*						pData
			)
{
	V_INAME(CPersonalityTrack::GetParam);
	V_PTR_WRITE_OPT(pmtNext,MUSIC_TIME);
	V_REFGUID(rCommandGuid);

	if( NULL == pData )
	{
        Trace(1, "ERROR: GetParam (chord map track): pParam is NULL.\n");
		return E_POINTER;
	}

	HRESULT hr;
	ENTER_CRITICAL_SECTION(&m_CriticalSection);
	if (rCommandGuid == GUID_IDirectMusicChordMap)
	{
		TListItem<StampedPersonality>* pScan = m_PersonalityList.GetHead();
		if (pScan)
		{
			IDirectMusicChordMap* pPersonality = pScan->GetItemValue().m_pPersonality;
			for(pScan = pScan->GetNext(); pScan; pScan = pScan->GetNext())
			{
				StampedPersonality& rScan = pScan->GetItemValue();
				if (mtTime < rScan.m_mtTime  && rScan.m_pPersonality) break;  // ignore if NULL
				if (rScan.m_pPersonality) pPersonality = rScan.m_pPersonality; // skip if NULL
			}
			if (pPersonality)
			{
				pPersonality->AddRef();
				*(IDirectMusicChordMap**)pData = pPersonality;
				if (pmtNext)
				{
					*pmtNext = (pScan != NULL) ? pScan->GetItemValue().m_mtTime - mtTime : 0;
				}
				hr = S_OK;
			}
			else
			{
                Trace(1, "ERROR: GetParam (chord map track): Chord map list item is empty.\n");
				hr = E_POINTER;
			}

		}
		else
        {
            Trace(1, "ERROR: GetParam (chord map track): Chord map track is empty.\n");
            hr = DMUS_E_NOT_FOUND;
        }
	}
	else
	{
        Trace(1, "ERROR: GetParam (chord map track): Attempt to get an unsupported parameter.\n");
		hr = DMUS_E_GET_UNSUPPORTED;
	}
	LEAVE_CRITICAL_SECTION(&m_CriticalSection);
	return hr;
} 

HRESULT CPersonalityTrack::SetParam( 
	REFGUID						rCommandGuid,
    MUSIC_TIME mtTime,
    void __RPC_FAR *pData)
{
	V_INAME(CPersonalityTrack::SetParam);
	V_REFGUID(rCommandGuid);

	HRESULT hr;
	if (!pData)
	{
        Trace(1, "ERROR: SetParam (chord map track): pParam is NULL.\n");
		return E_POINTER;
	}

	ENTER_CRITICAL_SECTION( &m_CriticalSection );
	if (rCommandGuid == GUID_IDirectMusicChordMap)
	{
		IDirectMusicChordMap* pPers = (IDirectMusicChordMap*)pData;
		TListItem<StampedPersonality>* pPersItem = m_PersonalityList.GetHead();
		TListItem<StampedPersonality>* pPrevious = NULL;
		TListItem<StampedPersonality>* pNew = new TListItem<StampedPersonality>;
		if (!pNew)
		{
			hr = E_OUTOFMEMORY;
		}
		else 
		{
			pNew->GetItemValue().m_mtTime = mtTime;
			pNew->GetItemValue().m_pPersonality = pPers;
			if (pPers) pPers->AddRef();
			for(; pPersItem != NULL; pPersItem = pPersItem->GetNext())
			{
				if (pPersItem->GetItemValue().m_mtTime >= mtTime) break;
				pPrevious = pPersItem;
			}
			if (pPrevious)
			{
				pPrevious->SetNext(pNew);
				pNew->SetNext(pPersItem);
			}
			else // pPersItem is current head of list
			{
				m_PersonalityList.AddHead(pNew);
			}
			if (pPersItem && pPersItem->GetItemValue().m_mtTime == mtTime)
			{
				// remove it
				if (pPersItem->GetItemValue().m_pPersonality)
				{
					pPersItem->GetItemValue().m_pPersonality->Release();
				}
				pPersItem->GetItemValue().m_pPersonality = NULL;
				pNew->SetNext(pPersItem->GetNext());
				pPersItem->SetNext(NULL);
				delete pPersItem;
			}
			hr = S_OK;
		}
	}
	else
	{
        Trace(1, "ERROR: SetParam (chord map track): Attempt to set an unsupported parameter.\n");
		hr = DMUS_E_SET_UNSUPPORTED;
	}
	LEAVE_CRITICAL_SECTION( &m_CriticalSection );
	return hr;
}

// IPersist methods
 HRESULT CPersonalityTrack::GetClassID( LPCLSID pClassID )
{
	V_INAME(CPersonalityTrack::GetClassID);
	V_PTR_WRITE(pClassID, CLSID); 
	*pClassID = CLSID_DirectMusicChordMapTrack;
	return S_OK;
}

// IDirectMusicCommon Methods
HRESULT CPersonalityTrack::GetName(
				/*[out]*/  BSTR*		pbstrName
			)
{
    return E_NOTIMPL;
}

HRESULT CPersonalityTrack::IsParamSupported(
				/*[in]*/ REFGUID						rGuid
			)
{
	V_INAME(CPersonalityTrack::IsParamSupported);
	V_REFGUID(rGuid);

	if (rGuid == GUID_IDirectMusicChordMap)
		return S_OK;
	else 
    {
        Trace(2, "WARNING: IsParamSupported (chord map track): The parameter is not supported.\n");
		return DMUS_E_TYPE_UNSUPPORTED;
    }
}

// IPersistStream methods
 HRESULT CPersonalityTrack::IsDirty()
{
	 return m_bRequiresSave ? S_OK : S_FALSE;
}

HRESULT CPersonalityTrack::Save( LPSTREAM pStream, BOOL fClearDirty )
{
    return E_NOTIMPL;
}

HRESULT CPersonalityTrack::GetSizeMax( ULARGE_INTEGER* /*pcbSize*/ )
{
	return E_NOTIMPL;
}


BOOL Less(StampedPersonality& SP1, StampedPersonality& SP2)
{ return SP1.m_mtTime < SP2.m_mtTime; }

HRESULT CPersonalityTrack::Load(LPSTREAM pStream )
{
	V_INAME(CPersonalityTrack::Load);
	V_INTERFACE(pStream);

    IAARIFFStream*	pIRiffStream;
    //MMCKINFO		ckMain;
	MMCKINFO		ck;
    HRESULT			hr = E_FAIL;

    if ( pStream == NULL ) return E_INVALIDARG;
    ENTER_CRITICAL_SECTION( &m_CriticalSection );
	if (m_PersonalityList.GetHead())
	{
		delete m_PersonalityList.GetHead();
		m_PersonalityList.RemoveAll();
	}

	if( SUCCEEDED( AllocRIFFStream( pStream, &pIRiffStream ) ) )
	{
		if (pIRiffStream->Descend( &ck, NULL, 0 ) == 0)
		{
			if (ck.ckid == FOURCC_LIST && ck.fccType == DMUS_FOURCC_PERS_TRACK_LIST)
			{
				hr = LoadPersRefList(pIRiffStream, &ck);
			}
			pIRiffStream->Ascend( &ck, 0 );
		}
		pIRiffStream->Release();
	}
	m_PersonalityList.MergeSort(Less);

    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return hr;
}

HRESULT CPersonalityTrack::LoadPersRefList( IAARIFFStream* pIRiffStream, MMCKINFO* pckParent )
{
	HRESULT hr = S_OK;
	if (!pIRiffStream || !pckParent) return E_INVALIDARG;
	MMCKINFO ck;

	while ( pIRiffStream->Descend( &ck, pckParent, 0 ) == 0  )
	{
		if ( ck.ckid == FOURCC_LIST && ck.fccType == DMUS_FOURCC_PERS_REF_LIST )
		{
			hr = LoadPersRef(pIRiffStream, &ck);
			pIRiffStream->Ascend( &ck, 0 );
		}
		pIRiffStream->Ascend( &ck, 0 );
	}

	return hr;
}

HRESULT CPersonalityTrack::LoadPersRef( IAARIFFStream* pIRiffStream, MMCKINFO* pckParent )
{
	HRESULT hr = S_OK;
	if (!pIRiffStream || !pckParent) return E_INVALIDARG;
	MMCKINFO ck;
	IStream* pIStream = pIRiffStream->GetStream();
	if(!pIStream) return E_FAIL;
	IDirectMusicChordMap* pPersonality = NULL;
	TListItem<StampedPersonality>* pNew = new TListItem<StampedPersonality>;
	if (!pNew) return E_OUTOFMEMORY;
	StampedPersonality& rNew = pNew->GetItemValue();
	while (pIRiffStream->Descend( &ck, pckParent, 0 ) == 0)
	{
		switch (ck.ckid)
		{
		case DMUS_FOURCC_TIME_STAMP_CHUNK:
			{
				DWORD dwTime;
				DWORD cb;
				hr = pIStream->Read( &dwTime, sizeof( dwTime ), &cb );
				if (FAILED(hr) || cb != sizeof( dwTime ) ) 
				{
					if (SUCCEEDED(hr)) hr = E_FAIL;
					pIRiffStream->Ascend( &ck, 0 );
					goto ON_END;
				}
				rNew.m_mtTime = dwTime;
			}
			break;
		case FOURCC_LIST:
			if (ck.fccType == DMUS_FOURCC_REF_LIST)
			{
				hr = LoadReference(pIStream, pIRiffStream, ck, &pPersonality);
				if (SUCCEEDED(hr))
				{
					rNew.m_pPersonality = pPersonality;
				}
			}
			break;
		}
		pIRiffStream->Ascend( &ck, 0 );
	}
	if (SUCCEEDED(hr))
	{
		m_PersonalityList.AddTail(pNew);
	}
	else
	{
		delete pNew;
	}
ON_END:
    pIStream->Release();
	return hr;
}

//////////////////////////////////////////////////////////////////////
// CPersonalityTrack::LoadReference

HRESULT CPersonalityTrack::LoadReference(IStream *pStream,
										 IAARIFFStream *pIRiffStream,
										 MMCKINFO& ckParent,
										 IDirectMusicChordMap** ppPersonality)
{
	if (!pStream || !pIRiffStream || !ppPersonality) return E_INVALIDARG;

	IDirectMusicLoader* pLoader = NULL;
	IDirectMusicGetLoader *pIGetLoader;  
	HRESULT hr = pStream->QueryInterface( IID_IDirectMusicGetLoader,(void **) &pIGetLoader );
	if (FAILED(hr)) return hr;
	hr = pIGetLoader->GetLoader(&pLoader);
	pIGetLoader->Release();
	if (FAILED(hr)) return hr;

	DMUS_OBJECTDESC desc;
	ZeroMemory(&desc, sizeof(desc));

	DWORD cbRead;
	
	MMCKINFO ckNext;
	ckNext.ckid = 0;
	ckNext.fccType = 0;
	DWORD dwSize = 0;
    	
	while( pIRiffStream->Descend( &ckNext, &ckParent, 0 ) == 0 )
	{
		switch(ckNext.ckid)
		{
			case  DMUS_FOURCC_REF_CHUNK:
				DMUS_IO_REFERENCE ioDMRef;
				hr = pStream->Read(&ioDMRef, sizeof(DMUS_IO_REFERENCE), &cbRead);
				if(SUCCEEDED(hr) && cbRead == sizeof(DMUS_IO_REFERENCE))
				{
					desc.guidClass = ioDMRef.guidClassID;
					desc.dwValidData |= ioDMRef.dwValidData;
					desc.dwValidData |= DMUS_OBJ_CLASS;
				}
				else if(SUCCEEDED(hr))
				{
					hr = E_FAIL;
				}
				break;

			case DMUS_FOURCC_GUID_CHUNK:
				hr = pStream->Read(&(desc.guidObject), sizeof(GUID), &cbRead);
				if(SUCCEEDED(hr) && cbRead == sizeof(GUID))
				{
					desc.dwValidData |=  DMUS_OBJ_OBJECT;
				}
				else if(SUCCEEDED(hr))
				{
					hr = E_FAIL;
				}
				break;

			case DMUS_FOURCC_DATE_CHUNK:
				hr = pStream->Read(&(desc.ftDate), sizeof(FILETIME), &cbRead);
				if(SUCCEEDED(hr) && cbRead == sizeof(FILETIME))
				{
					desc.dwValidData |=  DMUS_OBJ_DATE;
				}
				else if(SUCCEEDED(hr))
				{
					hr = E_FAIL;
				}
				break;

			case DMUS_FOURCC_NAME_CHUNK:
				dwSize = min(sizeof(desc.wszName), ckNext.cksize);
				hr = pStream->Read(desc.wszName, dwSize, &cbRead);
				if(SUCCEEDED(hr) && cbRead == dwSize)
				{
					desc.dwValidData |=  DMUS_OBJ_NAME;
				}
				else if(SUCCEEDED(hr))
				{
					hr = E_FAIL;
				}
				break;
			
			case DMUS_FOURCC_FILE_CHUNK:
				dwSize = min(sizeof(desc.wszFileName), ckNext.cksize);
				hr = pStream->Read(desc.wszFileName, dwSize, &cbRead);
				if(SUCCEEDED(hr) && cbRead == dwSize)
				{
					desc.dwValidData |=  DMUS_OBJ_FILENAME;
				}
				else if(SUCCEEDED(hr))
				{
					hr = E_FAIL;
				}
				break;

			case DMUS_FOURCC_CATEGORY_CHUNK:
				dwSize = min(sizeof(desc.wszCategory), ckNext.cksize);
				hr = pStream->Read(desc.wszCategory, dwSize, &cbRead);
				if(SUCCEEDED(hr) && cbRead == dwSize)
				{
					desc.dwValidData |=  DMUS_OBJ_CATEGORY;
				}
				else if(SUCCEEDED(hr))
				{
					hr = E_FAIL;
				}
				break;

			case DMUS_FOURCC_VERSION_CHUNK:
				DMUS_IO_VERSION ioDMObjVer;
				hr = pStream->Read(&ioDMObjVer, sizeof(DMUS_IO_VERSION), &cbRead);
				if(SUCCEEDED(hr) && cbRead == sizeof(DMUS_IO_VERSION))
				{
					desc.vVersion.dwVersionMS = ioDMObjVer.dwVersionMS;
					desc.vVersion.dwVersionLS = ioDMObjVer.dwVersionLS;
					desc.dwValidData |= DMUS_OBJ_VERSION;
				}
				else if(SUCCEEDED(hr))
				{
					hr = E_FAIL;
				}
				break;

			default:
				break;
		}
    
		if(SUCCEEDED(hr) && pIRiffStream->Ascend(&ckNext, 0) == 0)
		{
			ckNext.ckid = 0;
			ckNext.fccType = 0;
		}
		else if (SUCCEEDED(hr)) hr = E_FAIL;
	}
	if(SUCCEEDED(hr))
	{
		desc.dwSize = sizeof(DMUS_OBJECTDESC);
		hr = pLoader->GetObject(&desc, IID_IDirectMusicChordMap, (void**)ppPersonality);
	}

	if (pLoader)
	{
		pLoader->Release();
	}
	return hr;
}

HRESULT STDMETHODCALLTYPE CPersonalityTrack::AddNotificationType(
	/* [in] */  REFGUID						rGuidNotify)
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CPersonalityTrack::RemoveNotificationType(
	/* [in] */  REFGUID						rGuidNotify)
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CPersonalityTrack::Clone(
	MUSIC_TIME mtStart,
	MUSIC_TIME mtEnd,
	IDirectMusicTrack** ppTrack)
{
	V_INAME(CPersonalityTrack::Clone);
	V_PTRPTR_WRITE(ppTrack);

	HRESULT hr = S_OK;

	if(mtStart < 0 )
	{
        Trace(1, "ERROR: Clone (chord map track): Invalid  start time.\n");
		return E_INVALIDARG;
	}
	if(mtStart > mtEnd)
	{
        Trace(1, "ERROR: Clone (chord map track): Invalid  end time.\n");
		return E_INVALIDARG;
	}

    ENTER_CRITICAL_SECTION( &m_CriticalSection );

    CPersonalityTrack *pDM;
    
#ifndef XBOX
    try
    {
#endif
        pDM = new CPersonalityTrack(*this, mtStart, mtEnd);
#ifndef XBOX
    }
    catch( ... )
    {
        pDM = NULL;
    }
#endif
    if (pDM == NULL) {
		LEAVE_CRITICAL_SECTION( &m_CriticalSection );
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(IID_IDirectMusicTrack, (void**)ppTrack);
    pDM->Release();

    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
	return hr;
}

// IDirectMusicTrack8 Methods

// For consistency with other track types
STDMETHODIMP CPersonalityTrack::GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) 
{
    HRESULT hr;
    MUSIC_TIME mtNext;
    hr = GetParam(rguidType,(MUSIC_TIME) rtTime, &mtNext, pParam);
    if (prtNext)
    {
        *prtNext = mtNext;
    }
    return hr;
}

// For consistency with other track types
STDMETHODIMP CPersonalityTrack::SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,
                                      void* pParam, void * pStateData, DWORD dwFlags) 
{
	return SetParam(rguidType, (MUSIC_TIME) rtTime , pParam);
}

// For consistency with other track types
STDMETHODIMP CPersonalityTrack::PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf,
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) 
{
	V_INAME(IDirectMusicTrack::PlayEx);
	V_INTERFACE(pPerf);
	V_INTERFACE(pSegSt);

    HRESULT hr;
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    hr = Play(pStateData, (MUSIC_TIME)rtStart, (MUSIC_TIME)rtEnd,
          (MUSIC_TIME)rtOffset, dwFlags, pPerf, pSegSt, dwVirtualID);
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
	return hr;
}

STDMETHODIMP CPersonalityTrack::Compose(
		IUnknown* pContext, 
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) 
{
    return E_NOTIMPL;
}

STDMETHODIMP CPersonalityTrack::Join(
		IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) 
{
	V_INAME(IDirectMusicTrack::Join);
	V_INTERFACE(pNewTrack);
	V_INTERFACE_OPT(pContext);
	V_PTRPTR_WRITE_OPT(ppResultTrack);

    HRESULT hr = S_OK;
    ENTER_CRITICAL_SECTION(&m_CriticalSection);

	if (ppResultTrack)
	{
		hr = Clone(0, mtJoin, ppResultTrack);
		if (SUCCEEDED(hr))
		{
			hr = ((CPersonalityTrack*)*ppResultTrack)->JoinInternal(pNewTrack, mtJoin, dwTrackGroup);
		}
	}
	else
	{
		hr = JoinInternal(pNewTrack, mtJoin, dwTrackGroup);
	}

	LEAVE_CRITICAL_SECTION(&m_CriticalSection);
	return hr;
}

HRESULT CPersonalityTrack::JoinInternal(
		IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		DWORD dwTrackGroup) 
{
    HRESULT hr = S_OK;
	CPersonalityTrack* pOtherTrack = (CPersonalityTrack*)pNewTrack;
	TListItem<StampedPersonality>* pScan = pOtherTrack->m_PersonalityList.GetHead();
	for (; pScan; pScan = pScan->GetNext())
	{
		StampedPersonality& rScan = pScan->GetItemValue();
		TListItem<StampedPersonality>* pNew = new TListItem<StampedPersonality>;
		if (pNew)
		{
			StampedPersonality& rNew = pNew->GetItemValue();
			rNew.m_mtTime = rScan.m_mtTime + mtJoin;
			rNew.m_pPersonality = rScan.m_pPersonality;
			if (rNew.m_pPersonality) rNew.m_pPersonality->AddRef();
			m_PersonalityList.AddTail(pNew);
		}
		else
		{
			hr = E_OUTOFMEMORY;
			break;
		}
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmcompos\spsttrk.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       spsttrk.cpp
//
//--------------------------------------------------------------------------

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// INITIALIZE_CRITICAL_SECTION. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

// SPstTrk.cpp : Implementation of CSPstTrk
#include "pchcompos.h"

/////////////////////////////////////////////////////////////////////////////
// CSPstTrk


CSPstTrk::CSPstTrk() : 
	m_bRequiresSave(0), m_pPerformance(NULL),
	m_pComposer(NULL),
	m_fNotifyRecompose(FALSE),
//	m_pSegment(NULL),
	m_cRef(1),
    m_fCSInitialized(FALSE),
    m_MemTrack(DMTRACK_SIGNPOST_TRACK)

{
	IncrementDLLCount();

    // Do this first since it might throw an exception
    //
    INITIALIZE_CRITICAL_SECTION( &m_CriticalSection );
    m_fCSInitialized = TRUE;
}

// This assumes cloning on measure boundaries
CSPstTrk::CSPstTrk(const CSPstTrk& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd)  : 
	m_bRequiresSave(0), m_pPerformance(NULL),
	m_pComposer(NULL),
	m_fNotifyRecompose(FALSE),
	//m_pSegment(NULL),
	m_cRef(1),
    m_fCSInitialized(FALSE),
    m_MemTrack(DMTRACK_SIGNPOST_TRACK)
{
	IncrementDLLCount();

    // Do this first since it might throw an exception
    //
    INITIALIZE_CRITICAL_SECTION( &m_CriticalSection );
    m_fCSInitialized = TRUE;
	BOOL fStarted = FALSE;
	WORD wMeasure = 0;
	TListItem<DMSignPostStruct>* pScan = rTrack.m_SignPostList.GetHead();
	TListItem<DMSignPostStruct>* pPrevious = NULL;
	for(; pScan; pScan = pScan->GetNext())
	{
		DMSignPostStruct& rScan = pScan->GetItemValue();
		if (rScan.m_mtTime < mtStart)
		{
			pPrevious = pScan;
		}
		else if (rScan.m_mtTime < mtEnd)
		{
			if (rScan.m_mtTime == mtStart)
			{
				pPrevious = NULL;
			}
			if (!fStarted)
			{
				fStarted = TRUE;
				wMeasure = rScan.m_wMeasure;
			}
			TListItem<DMSignPostStruct>* pNew = new TListItem<DMSignPostStruct>;
			if (pNew)
			{
				DMSignPostStruct& rNew = pNew->GetItemValue();
				rNew.m_mtTime = rScan.m_mtTime - mtStart;
				rNew.m_wMeasure = rScan.m_wMeasure - wMeasure;
				rNew.m_dwChords = rScan.m_dwChords;
				m_SignPostList.AddTail(pNew);
			}
		}
		else break;
	}
	if (pPrevious)
	{
		TListItem<DMSignPostStruct>* pNew = new TListItem<DMSignPostStruct>;
		if (pNew)
		{
			DMSignPostStruct& rNew = pNew->GetItemValue();
			rNew.m_mtTime = 0;
			rNew.m_wMeasure = 0;
			rNew.m_dwChords = pPrevious->GetItemValue().m_dwChords;
			m_SignPostList.AddHead(pNew);
		}
	}
}

CSPstTrk::~CSPstTrk()
{
	if (m_pComposer)
	{
		delete m_pComposer;
	}
    if (m_fCSInitialized)
    {
        DELETE_CRITICAL_SECTION( &m_CriticalSection );
    }

	DecrementDLLCount();
}

void CSPstTrk::Clear()
{
	m_SignPostList.CleanUp();
}


STDMETHODIMP CSPstTrk::QueryInterface(
    const IID &iid, 
    void **ppv) 
{
	V_INAME(CSPstTrk::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack || iid == IID_IDirectMusicTrack8)
    {
        *ppv = static_cast<IDirectMusicTrack*>(this);
	}
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
	}
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CSPstTrk::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CSPstTrk::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}


HRESULT CSPstTrk::Init(
				/*[in]*/  IDirectMusicSegment*		pSegment
			)
{
	return S_OK; // if I return an error, dmime gives me an assertion failure
}

HRESULT CSPstTrk::InitPlay(
				/*[in]*/  IDirectMusicSegmentState*	pSegmentState,
				/*[in]*/  IDirectMusicPerformance*	pPerformance,
				/*[out]*/ void**					ppStateData,
				/*[in]*/  DWORD						dwTrackID,
                /*[in]*/  DWORD                     dwFlags
			)
{
	ENTER_CRITICAL_SECTION(&m_CriticalSection);
    // get rid of any existing composer object
    if (m_pComposer)
    {
        delete m_pComposer;
        m_pComposer = NULL;
    }

    IDirectMusicSegment* pSegment = NULL;
    HRESULT hr = pSegmentState->GetSegment(&pSegment);
    if (SUCCEEDED(hr))
    {
        m_pComposer = new CDMCompos;
        if(!m_pComposer) 
        {
            hr = E_OUTOFMEMORY;
        }
        pSegment->Release();
    }
    else
    {
        Trace(2, "WARNING: InitPlay (Signpost Track): Segment State does not contain a segment.\n");
        hr = S_OK; // Let it succeed anyway.  Just means we can't compose on the fly.
    }
	LEAVE_CRITICAL_SECTION(&m_CriticalSection);
	return hr;
}

HRESULT CSPstTrk::EndPlay(
				/*[in]*/  void*						pStateData
			)
{
	ENTER_CRITICAL_SECTION(&m_CriticalSection);
	// get rid of any existing composer object
	if (m_pComposer)
	{
		delete m_pComposer;
		m_pComposer = NULL;
	}
	LEAVE_CRITICAL_SECTION(&m_CriticalSection);
	return S_OK;
}

HRESULT CSPstTrk::Play(
				/*[in]*/  void*						pStateData, 
				/*[in]*/  MUSIC_TIME				mtStart, 
				/*[in]*/  MUSIC_TIME				mtEnd, 
				/*[in]*/  MUSIC_TIME				mtOffset,
						  DWORD						dwFlags,
						  IDirectMusicPerformance*	pPerf,
						  IDirectMusicSegmentState*	pSegState,
						  DWORD						dwVirtualID
			)
{
	bool fStart = (dwFlags & DMUS_TRACKF_START) ? true : false;
	bool fLoop = (dwFlags & DMUS_TRACKF_LOOP) ? true : false;
	bool fCompose = (dwFlags & DMUS_TRACKF_RECOMPOSE) ? true : false;
	bool fPlayOff = (dwFlags & DMUS_TRACKF_PLAY_OFF) ? true : false;
	ENTER_CRITICAL_SECTION(&m_CriticalSection);
	if ( fStart || fLoop ) 
	{
		if ( fCompose && !fPlayOff )
		{
			IDirectMusicSegment* pSegment = NULL;
			if (SUCCEEDED(pSegState->GetSegment(&pSegment)))
			{
				// call ComposeSegmentFromTemplateEx on this segment
				if (m_pComposer)
				{
					// Should an activity level be allowed if desired?
					// This could be handled via a SetParam.
					m_pComposer->ComposeSegmentFromTemplateEx(
						NULL,
						pSegment,
						0,		// ignore activity level, don't clone
						0,      // for activity level
						NULL,
						NULL
					);
					// if we recomposed, send a recompose notification
					SendNotification(mtStart + mtOffset, pPerf, pSegment, pSegState, dwFlags);
				}
				pSegment->Release();
			}
		}
	}
	LEAVE_CRITICAL_SECTION(&m_CriticalSection);
	return S_OK;
}

HRESULT CSPstTrk::SendNotification(MUSIC_TIME mtTime,
										IDirectMusicPerformance*	pPerf,
										IDirectMusicSegment* pSegment,
										IDirectMusicSegmentState*	pSegState,
										DWORD dwFlags)
{
	if (!m_fNotifyRecompose || (dwFlags & DMUS_TRACKF_NOTIFY_OFF))
	{
		return S_OK;
	}
	DMUS_NOTIFICATION_PMSG* pEvent = NULL;
	HRESULT hr = pPerf->AllocPMsg( sizeof(DMUS_NOTIFICATION_PMSG), (DMUS_PMSG**)&pEvent );
	if( SUCCEEDED( hr ))
	{
		pEvent->dwField1 = 0;
		pEvent->dwField2 = 0;
		pEvent->dwType = DMUS_PMSGT_NOTIFICATION;
		pEvent->mtTime = mtTime;
		pEvent->dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_TOOL_ATTIME;
		pSegState->QueryInterface(IID_IUnknown, (void**)&pEvent->punkUser);

		pEvent->dwNotificationOption = DMUS_NOTIFICATION_RECOMPOSE;
		pEvent->guidNotificationType = GUID_NOTIFICATION_RECOMPOSE;

		if (FAILED(pSegment->GetTrackGroup(this, &pEvent->dwGroupID)))
		{
			pEvent->dwGroupID = 0xffffffff;
		}

		IDirectMusicGraph* pGraph;
		hr = pSegState->QueryInterface( IID_IDirectMusicGraph, (void**)&pGraph );
		if( SUCCEEDED( hr ))
		{
			pGraph->StampPMsg((DMUS_PMSG*) pEvent );
			pGraph->Release();
		}
		hr = pPerf->SendPMsg((DMUS_PMSG*) pEvent );
		if( FAILED(hr) )
		{
			pPerf->FreePMsg((DMUS_PMSG*) pEvent );
		}
	}
	return hr;
}

HRESULT CSPstTrk::GetPriority( 
				/*[out]*/ DWORD*					pPriority 
			)
	{
		return E_NOTIMPL;
	}

HRESULT CSPstTrk::GetParam(
				REFGUID						rCommandGuid,
				MUSIC_TIME					mtTime, 
				MUSIC_TIME*					pmtNext,
				void*						pData
			)
{
	return E_NOTIMPL;
} 

HRESULT CSPstTrk::SetParam( 
	REFGUID						rCommandGuid,
    MUSIC_TIME mtTime,
    void __RPC_FAR *pData)
{
	return E_NOTIMPL;
}

// IPersist methods
 HRESULT CSPstTrk::GetClassID( LPCLSID pClassID )
{
	V_INAME(CSPstTrk::GetClassID);
	V_PTR_WRITE(pClassID, CLSID); 
	*pClassID = CLSID_DirectMusicSignPostTrack;
	return S_OK;
}

// IDirectMusicCommon Methods
HRESULT CSPstTrk::GetName(
				/*[out]*/  BSTR*		pbstrName
			)
{
    return E_NOTIMPL;
}

HRESULT CSPstTrk::IsParamSupported(
				/*[in]*/ REFGUID						rGuid
			)
{
    return E_NOTIMPL;
}

// IPersistStream methods
 HRESULT CSPstTrk::IsDirty()
{
	 return m_bRequiresSave ? S_OK : S_FALSE;
}

HRESULT CSPstTrk::Save( LPSTREAM pStream, BOOL fClearDirty )
{
	V_INAME(CSPstTrk::Save);
	V_INTERFACE(pStream);

	IAARIFFStream* pRIFF = NULL;
    MMCKINFO		ck;
    HRESULT			hr;
    DWORD			cb;
    DWORD			dwSize;
    DMUS_IO_SIGNPOST	oSignPost;
    TListItem<DMSignPostStruct>* pSignPost;

	ENTER_CRITICAL_SECTION( &m_CriticalSection );
	hr = AllocRIFFStream( pStream, &pRIFF );
    if ( FAILED( hr ) )
	{
		goto ON_END;
	}
    ck.ckid = DMUS_FOURCC_SIGNPOST_TRACK_CHUNK;
    if( pRIFF->CreateChunk( &ck, 0 ) == 0 )
    {
        dwSize = sizeof( oSignPost );
        hr = pStream->Write( &dwSize, sizeof( dwSize ), &cb );
        if( FAILED( hr ) || cb != sizeof( dwSize ) )
        {
			if (SUCCEEDED(hr)) hr = E_FAIL;
			goto ON_END;
        }
        for( pSignPost = m_SignPostList.GetHead(); pSignPost != NULL ; pSignPost = pSignPost->GetNext() )
        {
			DMSignPostStruct& rSignPost = pSignPost->GetItemValue();
            memset( &oSignPost, 0, sizeof( oSignPost ) );
            oSignPost.mtTime = rSignPost.m_mtTime;
            oSignPost.wMeasure = rSignPost.m_wMeasure;
			oSignPost.dwChords = rSignPost.m_dwChords;
            if( FAILED( pStream->Write( &oSignPost, sizeof( oSignPost ), &cb ) ) ||
                cb != sizeof( oSignPost ) )
            {
                break;
            }
        }
        if( pSignPost == NULL &&
            pRIFF->Ascend( &ck, 0 ) == 0 )
        {
            hr = S_OK;
        }
    }
ON_END:
	if (pRIFF) pRIFF->Release();
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
    return hr;
}

HRESULT CSPstTrk::GetSizeMax( ULARGE_INTEGER* /*pcbSize*/ )
{
	return E_NOTIMPL;
}


BOOL Less(DMSignPostStruct& SP1, DMSignPostStruct& SP2)
{ return SP1.m_wMeasure < SP2.m_wMeasure; }

HRESULT CSPstTrk::Load(LPSTREAM pStream )
{
	V_INAME(CSPstTrk::Load);
	V_INTERFACE(pStream);

	HRESULT         hr = E_FAIL;
    DWORD dwPos;
    IAARIFFStream*  pRIFF;

	ENTER_CRITICAL_SECTION( &m_CriticalSection );
	Clear();
	dwPos = StreamTell( pStream );
    StreamSeek( pStream, dwPos, STREAM_SEEK_SET );
    MMCKINFO        ck;
	long lFileSize = 0;
	DWORD dwNodeSize;
	DWORD		cb;
	DMUS_IO_SIGNPOST		iSignPost;

	ck.ckid = DMUS_FOURCC_SIGNPOST_TRACK_CHUNK;
	if( SUCCEEDED( AllocRIFFStream( pStream, &pRIFF ) ) &&
		pRIFF->Descend( &ck, NULL, MMIO_FINDCHUNK ) == 0 )
	{
		lFileSize = (long) ck.cksize;
		hr = pStream->Read( &dwNodeSize, sizeof( dwNodeSize ), &cb );
		if( SUCCEEDED( hr ) && cb == sizeof( dwNodeSize ) )
		{
			lFileSize -= 4; // for the size dword
			TListItem<DMSignPostStruct>* pSignPost;
			if (lFileSize % dwNodeSize)
			{
				hr = E_FAIL;
			}
			else
			{
				while( lFileSize > 0 )
				{
					//TraceI(0, "File size: %d\n", lFileSize);
					pSignPost = new TListItem<DMSignPostStruct>;
					if( pSignPost )
					{
						DMSignPostStruct& rSignPost = pSignPost->GetItemValue();
						if( dwNodeSize <= sizeof( iSignPost ) )
						{
							pStream->Read( &iSignPost, dwNodeSize, NULL );
						}
						else
						{
							pStream->Read( &iSignPost, sizeof( iSignPost ), NULL );
							DWORD dw = (lFileSize >= sizeof( iSignPost ) ) ? lFileSize - sizeof( iSignPost ) : 0;
							StreamSeek( pStream, dw, STREAM_SEEK_CUR );
						}
						memset( &rSignPost, 0, sizeof( rSignPost ) );
						rSignPost.m_mtTime = iSignPost.mtTime;
						rSignPost.m_wMeasure = iSignPost.wMeasure;
						rSignPost.m_dwChords = iSignPost.dwChords;
						m_SignPostList.AddTail(pSignPost);
						lFileSize -= dwNodeSize;
					}
					else break;
				}
			}
		}
		if( lFileSize == 0 &&
			pRIFF->Ascend( &ck, 0 ) == 0 )
		{
			hr = S_OK;
			m_SignPostList.MergeSort(Less);
		}
		pRIFF->Release();
	}
    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
	return hr;
}

HRESULT STDMETHODCALLTYPE CSPstTrk::AddNotificationType(
	/* [in] */  REFGUID						rGuidNotify)
{
	V_INAME(CPersonalityTrack::AddNotificationType);
	V_REFGUID(rGuidNotify);

	if( rGuidNotify == GUID_NOTIFICATION_RECOMPOSE )
	{
		m_fNotifyRecompose = TRUE;
		return S_OK;
	}
	else
	{
        Trace(2, "WARNING: AddNotificationType (signpost track): Notification type not supported.\n");
		return S_FALSE;
	}
}

HRESULT STDMETHODCALLTYPE CSPstTrk::RemoveNotificationType(
	/* [in] */  REFGUID						rGuidNotify)
{
	V_INAME(CPersonalityTrack::RemoveNotificationType);
	V_REFGUID(rGuidNotify);

	if( rGuidNotify == GUID_NOTIFICATION_RECOMPOSE )
	{
		m_fNotifyRecompose = FALSE;
		return S_OK;
	}
	else
	{
        Trace(2, "WARNING: RemoveNotificationType (signpost track): Notification type not supported.\n");
		return S_FALSE;
	}
}

HRESULT STDMETHODCALLTYPE CSPstTrk::Clone(
	MUSIC_TIME mtStart,
	MUSIC_TIME mtEnd,
	IDirectMusicTrack** ppTrack)
{
	V_INAME(CSPstTrk::Clone);
	V_PTRPTR_WRITE(ppTrack);

	HRESULT hr = S_OK;

	if(mtStart < 0 )
	{
        Trace(1, "ERROR: Clone (signpost map): Invalid  start time.\n");
		return E_INVALIDARG;
	}
	if(mtStart > mtEnd)
	{
        Trace(1, "ERROR: Clone (signpost map): Invalid  end time.\n");
		return E_INVALIDARG;
	}

    ENTER_CRITICAL_SECTION( &m_CriticalSection );
    
    CSPstTrk *pDM;

#ifndef XBOX
    try
    {
#endif
        pDM = new CSPstTrk(*this, mtStart, mtEnd);
#ifndef XBOX
    }
    catch( ... )
    {
        pDM = NULL;
    }
#endif
    if (pDM == NULL) {
		LEAVE_CRITICAL_SECTION( &m_CriticalSection );
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(IID_IDirectMusicTrack, (void**)ppTrack);
    pDM->Release();

    LEAVE_CRITICAL_SECTION( &m_CriticalSection );
	return hr;
}

// IDirectMusicTrack8 Methods

// For consistency with other track types
STDMETHODIMP CSPstTrk::GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) 
{
    HRESULT hr;
    MUSIC_TIME mtNext;
    hr = GetParam(rguidType,(MUSIC_TIME) rtTime, &mtNext, pParam);
    if (prtNext)
    {
        *prtNext = mtNext;
    }
    return hr;
}

// For consistency with other track types
STDMETHODIMP CSPstTrk::SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,
                                      void* pParam, void * pStateData, DWORD dwFlags) 
{
	return SetParam(rguidType, (MUSIC_TIME) rtTime , pParam);
}

// For consistency with other track types
STDMETHODIMP CSPstTrk::PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf,
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) 
{
	V_INAME(IDirectMusicTrack::PlayEx);
	V_INTERFACE(pPerf);
	V_INTERFACE(pSegSt);

    HRESULT hr;
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    hr = Play(pStateData, (MUSIC_TIME)rtStart, (MUSIC_TIME)rtEnd,
          (MUSIC_TIME)rtOffset, dwFlags, pPerf, pSegSt, dwVirtualID);
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
	return hr;
}

STDMETHODIMP CSPstTrk::Compose(
		IUnknown* pContext, 
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) 
{
	V_INAME(IDirectMusicTrack::Compose)

	V_INTERFACE(pContext);
	V_PTRPTR_WRITE(ppResultTrack);

    ENTER_CRITICAL_SECTION(&m_CriticalSection);
	HRESULT hr = S_OK;
	IDirectMusicTrack* pChordTrack = NULL;
	IDirectMusicTrack8* pCommandTrack = NULL;
	IDirectMusicStyle* pStyle = NULL;
	IDirectMusicTrack8* pChordMapTrack = NULL;
    IAARIFFStream*			pChordRIFF				= NULL;
	IStream*				pIChordStream			= NULL;
	IPersistStream*			pIChordTrackStream		= NULL;
	CDMCompos* pComposer = NULL;

	MUSIC_TIME mtLength = 0;

	IDirectMusicSegment* pTempSeg = NULL;
	IDirectMusicSong* pSong = NULL;
	if (FAILED(pContext->QueryInterface(IID_IDirectMusicSegment, (void**)&pTempSeg)))
	{
		if (FAILED(pContext->QueryInterface(IID_IDirectMusicSong, (void**)&pSong)))
		{
            Trace(1, "ERROR: Compose (signpost track): Missing segment or song.\n");
			hr = E_INVALIDARG;
			goto ON_END;
		}
	}

	if (pTempSeg)
	{
		if (FAILED(hr = pTempSeg->GetParam(GUID_IDirectMusicStyle, dwTrackGroup, 0, 0, NULL, (void*)&pStyle)))
        {
		    if (FAILED(hr = pTempSeg->GetParam(GUID_IDirectMusicPatternStyle, dwTrackGroup, 0, 0, NULL, (void*)&pStyle)))
            {
                goto ON_END;
            }
        }
		hr = pTempSeg->GetTrack(CLSID_DirectMusicChordMapTrack, dwTrackGroup, 0, (IDirectMusicTrack**)&pChordMapTrack);
		if (FAILED(hr)) goto ON_END;
		if (FAILED(hr = pTempSeg->GetLength(&mtLength))) goto ON_END;
		hr = pTempSeg->GetTrack(CLSID_DirectMusicCommandTrack, dwTrackGroup, 0, (IDirectMusicTrack**)&pCommandTrack);
		if (FAILED(hr)) goto ON_END;
	}
	else if (pSong)
	{
		MUSIC_TIME mtNow = 0;
		MUSIC_TIME mtNext = 0;
		while (FAILED(hr = pSong->GetParam(GUID_IDirectMusicStyle, dwTrackGroup, 0, mtNow, &mtNext, (void*)&pStyle)))
		{
		    if (SUCCEEDED(hr = pSong->GetParam(GUID_IDirectMusicPatternStyle, dwTrackGroup, 0, mtNow, NULL, (void*)&pStyle)))
            {
                break;
            }
			if (mtNext <= 0) goto ON_END;
			mtNow = mtNext;
		}
		IDirectMusicSegment* pSeg = NULL;
		DWORD dwSeg = 0;
		while (S_OK == hr)
		{
			if (FAILED(hr = pSong->EnumSegment(dwSeg, &pSeg))) goto ON_END;
			if (hr == S_OK)
			{
				HRESULT hrCommand = S_OK;
				HRESULT hrChordMap = S_OK;
				MUSIC_TIME mt = 0;
				hr = pSeg->GetLength(&mt);
				if (FAILED(hr))
				{
					pSeg->Release();
					goto ON_END;
				}

				IDirectMusicTrack8* pSegTrack = NULL;
				IDirectMusicTrack8* pSegTrack2 = NULL;
				hrCommand = pSeg->GetTrack(CLSID_DirectMusicCommandTrack, dwTrackGroup, 0, (IDirectMusicTrack**)&pSegTrack);
				hrChordMap = pSeg->GetTrack(CLSID_DirectMusicChordMapTrack, dwTrackGroup, 0, (IDirectMusicTrack**)&pSegTrack2);
				pSeg->Release();
				pSeg = NULL;
				if (SUCCEEDED(hrCommand))
				{
					if (!pCommandTrack)
					{
						hr = pSegTrack->Clone(0, 0, (IDirectMusicTrack**)&pCommandTrack);
					}
					if (SUCCEEDED(hr))
					{
						hr = pCommandTrack->Join(pSegTrack, mtLength, pSong, dwTrackGroup, NULL);
					}
					pSegTrack->Release();
				}
				if (SUCCEEDED(hrChordMap))
				{
					if (!pChordMapTrack)
					{
						hr = pSegTrack2->Clone(0, 0, (IDirectMusicTrack**)&pChordMapTrack);
					}
					if (SUCCEEDED(hr))
					{
						hr = pChordMapTrack->Join(pSegTrack2, mtLength, pSong, dwTrackGroup, NULL);
					}
					pSegTrack2->Release();
				}
				if (FAILED(hr))  goto ON_END;
				mtLength += mt;
				dwSeg++;
			}
		}
	}

	pComposer = new CDMCompos;
	if(!pComposer) 
	{
		hr = E_OUTOFMEMORY;
	}

	if (SUCCEEDED(hr))
	{
		TList<PlayChord> PlayList;
		BYTE bRoot = 0; 
		DWORD dwScale;
		hr = pComposer->ComposePlayListFromTemplate(
			pStyle, NULL, pChordMapTrack, (IDirectMusicTrack*)this, pCommandTrack, dwTrackGroup,
			mtLength, false, 0, PlayList, bRoot, dwScale);
		// create a new chord track
		DMUS_TIMESIGNATURE		TimeSig;
		// Fill in the time sig event with default values (4/4, 16th note resolution)
		TimeSig.mtTime = 0;
		TimeSig.bBeatsPerMeasure = 4;
		TimeSig.bBeat = 4;
		TimeSig.wGridsPerBeat = 4;
		hr = DirectMusicCreateInstance(CLSID_DirectMusicChordTrack,NULL,
                    IID_IDirectMusicTrack,
                    (void **) &pChordTrack);
		if (!SUCCEEDED(hr)) goto ON_END;
		hr = CreateStreamOnHGlobal(NULL, TRUE, &pIChordStream);
		if (S_OK != hr) goto ON_END;
		hr = AllocRIFFStream( pIChordStream, &pChordRIFF);
		if (S_OK != hr) goto ON_END;
		pComposer->SaveChordList(pChordRIFF, PlayList, bRoot, dwScale, TimeSig);
		hr = pChordTrack->QueryInterface(IID_IPersistStream, (void**)&pIChordTrackStream);
		if (!SUCCEEDED(hr)) goto ON_END;
		StreamSeek(pIChordStream, 0, STREAM_SEEK_SET);
		hr = pIChordTrackStream->Load(pIChordStream);
		if (!SUCCEEDED(hr)) goto ON_END;
		*ppResultTrack = pChordTrack;
	}

ON_END:
	if (pComposer) pComposer->CleanUp();
	if (pStyle) pStyle->Release();
	if (pChordRIFF) pChordRIFF->Release();
	if (pIChordStream) pIChordStream->Release();
	if (pIChordTrackStream) pIChordTrackStream->Release();
	if (pCommandTrack) pCommandTrack->Release();
	if (pChordMapTrack) pChordMapTrack->Release();
	if (pComposer) delete pComposer;
	if (pSong) pSong->Release();
	if (pTempSeg) pTempSeg->Release();

    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CSPstTrk::Join(
		IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) 
{
	V_INAME(IDirectMusicTrack::Join);
	V_INTERFACE(pNewTrack);
	V_INTERFACE(pContext);
	V_PTRPTR_WRITE_OPT(ppResultTrack);

    HRESULT hr = S_OK;
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
	TList<DMSignPostStruct> ResultList;
	CSPstTrk* pResultTrack = NULL;
	if (ppResultTrack)
	{
		hr = Clone(0, mtJoin, ppResultTrack);
		pResultTrack = (CSPstTrk*)*ppResultTrack;
		while(!pResultTrack->m_SignPostList.IsEmpty())
		{
			ResultList.AddHead(pResultTrack->m_SignPostList.RemoveHead());
		}
	}
	else
	{
		pResultTrack = this;
		while(!m_SignPostList.IsEmpty() && 
			  m_SignPostList.GetHead()->GetItemValue().m_mtTime < mtJoin)
		{
			ResultList.AddHead(m_SignPostList.RemoveHead());
		}
		m_SignPostList.CleanUp();
	}
	WORD wMeasure = 0;
	HRESULT hrTimeSig = S_OK;
	MUSIC_TIME mtTimeSig = 0;
	MUSIC_TIME mtOver = 0;
	IDirectMusicSong* pSong = NULL;
	IDirectMusicSegment* pSegment = NULL;
	if (FAILED(pContext->QueryInterface(IID_IDirectMusicSegment, (void**)&pSegment)))
	{
		if (FAILED(pContext->QueryInterface(IID_IDirectMusicSong, (void**)&pSong)))
		{
			hrTimeSig = E_FAIL;
		}
	}
	while (SUCCEEDED(hrTimeSig) && mtTimeSig < mtJoin)
	{
		DMUS_TIMESIGNATURE TimeSig;
		MUSIC_TIME mtNext = 0;
		if (pSegment)
		{
			hrTimeSig = pSegment->GetParam(GUID_TimeSignature, dwTrackGroup, 0, mtTimeSig, &mtNext, (void*)&TimeSig);
		}
		else
		{
			hrTimeSig = pSong->GetParam(GUID_TimeSignature, dwTrackGroup, 0, mtTimeSig, &mtNext, (void*)&TimeSig);
		}
		if (SUCCEEDED(hrTimeSig))
		{
			if (!mtNext) mtNext = mtJoin - mtTimeSig; // means no more time sigs
			WORD wMeasureOffset = ClocksToMeasure(mtNext + mtOver, TimeSig);
            MUSIC_TIME mtMeasureOffset = (MUSIC_TIME) wMeasureOffset;
            // The following line crashes on certain builds on certain machines.
            // mtOver = mtMeasureOffset ? (mtNext % mtMeasureOffset) : 0;
            if (mtMeasureOffset)
            {
                mtOver = mtNext % mtMeasureOffset;
            }
            else
            {
                mtOver = 0;
            }
			wMeasure += wMeasureOffset;
			mtTimeSig += mtNext;
		}
	}
	CSPstTrk* pOtherTrack = (CSPstTrk*)pNewTrack;
	TListItem<DMSignPostStruct>* pScan = pOtherTrack->m_SignPostList.GetHead();
	for (; pScan; pScan = pScan->GetNext())
	{
		TListItem<DMSignPostStruct>* pNew = new TListItem<DMSignPostStruct>(pScan->GetItemValue());
		if (pNew)
		{
			pNew->GetItemValue().m_mtTime += mtJoin;
			pNew->GetItemValue().m_wMeasure += wMeasure;
			ResultList.AddHead(pNew);
		}
		else
		{
			ResultList.CleanUp();
			hr = E_OUTOFMEMORY;
			break;
		}
	}
	if (SUCCEEDED(hr))
	{
		pResultTrack->m_SignPostList.CleanUp();
		while(!ResultList.IsEmpty() )
		{
			pResultTrack->m_SignPostList.AddHead(ResultList.RemoveHead());
		}
	}
	if (pSong) pSong->Release();
	if (pSegment) pSegment->Release();
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmcompos\str.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       str.cpp
//
//--------------------------------------------------------------------------

//
// string.cpp

#include "pchcompos.h"

WORD String::sm_wBlockSize = 16;

String::String()
{
	m_wAllocated = 0;
    m_pBuf = NULL;
    m_wLength = 0;
}

String::String( const String& str )
{
    m_wLength = str.m_wLength;
	if (m_wLength == 0)
	{
		m_wAllocated = 0;
		m_pBuf = NULL;
	}
	else
	{
		m_wAllocated = figureblocksize( m_wLength );
		m_pBuf = new WCHAR[m_wAllocated];
		if( m_pBuf != NULL )
		{
			wcscpy( m_pBuf, str.m_pBuf );
		}
		else
		{
			m_wLength = 0;
			m_wAllocated = 0;
		}
	}
}

String::String( LPCSTR pszStr )
{
    if( pszStr != NULL && pszStr[0] != '\0' )
    {
        m_wLength = static_cast<WORD>( MultiByteToWideChar( CP_ACP, 0, pszStr, -1, NULL, 0 ) );
		m_wAllocated = figureblocksize( m_wLength );
		m_pBuf = new WCHAR[m_wAllocated];

		if( m_pBuf != NULL )
		{
			MultiByteToWideChar( CP_ACP, 0, pszStr, -1, m_pBuf, m_wAllocated );
		}
		else
		{
			m_wLength = 0;
			m_wAllocated = 0;
		}
    }
    else
    {
        m_wLength = 0;
		m_wAllocated = 0;
		m_pBuf = NULL;
    }

}

String::String( LPCWSTR pszWstr )
{
    if( pszWstr != NULL && pszWstr[0] != L'\0')
    {
        m_wLength = static_cast<WORD>( wcslen(pszWstr) );
		m_wAllocated = figureblocksize( m_wLength );
		m_pBuf = new WCHAR[m_wAllocated];

		if( m_pBuf != NULL )
		{
			wcscpy(m_pBuf, pszWstr);
		}
		else
		{
			m_wLength = 0;
			m_wAllocated = 0;
		}
    }
    else
    {
        m_wLength = 0;
		m_wAllocated = 0;
		m_pBuf = NULL;
    }

}

String::~String()
{
    if (m_pBuf) delete[] m_pBuf;
}

String& String::operator=( const String& str )
{
    WORD wBlockSize;

    if( m_pBuf != str.m_pBuf )
    {
		if (!str.m_pBuf)
		{
            if (m_pBuf)
			{
				m_pBuf[0] = L'\0';
			}
            m_wLength = 0;
		}
		else
		{
			wBlockSize = figureblocksize( str.m_wLength );
			if( wBlockSize <= m_wAllocated )
			{
				m_wLength = str.m_wLength;
				wcscpy( m_pBuf, str.m_pBuf );
			}
			else
			{
				if (m_pBuf) delete [] m_pBuf;
				m_wLength = str.m_wLength;
				m_wAllocated = wBlockSize;
				m_pBuf = new WCHAR[m_wAllocated];
				if( m_pBuf != NULL )
				{
					wcscpy( m_pBuf, str.m_pBuf );
				}
				else
				{
					m_wLength = 0;
					m_wAllocated = 0;
				}
			}
		}
    }
    return *this;
}

String& String::operator=( LPCSTR pszStr )
{
    WORD wLength;
    WORD wBlockSize;

    if( pszStr == NULL )
    {
        m_wLength = 0;
        return *this;
    }

    wLength = static_cast<WORD>( MultiByteToWideChar( CP_ACP, 0, pszStr, -1, NULL, 0 ) );
    wBlockSize = figureblocksize( wLength );
    if( wBlockSize <= m_wAllocated )
    {
        m_wLength = wLength;
        MultiByteToWideChar( CP_ACP, 0, pszStr, -1, m_pBuf, m_wAllocated );
    }
    else
    {
        if (m_pBuf) delete[] m_pBuf;
        m_wLength = wLength;
        m_wAllocated = wBlockSize;
        m_pBuf = new WCHAR[m_wAllocated];
        if( m_pBuf != NULL )
        {
			MultiByteToWideChar( CP_ACP, 0, pszStr, -1, m_pBuf, m_wAllocated );
        }
        else
        {
            m_wLength = 0;
            m_wAllocated = 0;
        }
    }
    return *this;
}

String& String::operator=( LPCWSTR pszWstr )
{
    WORD wLength;
    WORD wBlockSize;

    if( pszWstr == NULL )
    {
        m_wLength = 0;
        return *this;
    }

    wLength = static_cast<WORD>( wcslen( pszWstr ) );
    wBlockSize = figureblocksize( wLength );
    if( wBlockSize <= m_wAllocated )
    {
        m_wLength = wLength;
        wcscpy(m_pBuf, pszWstr);
    }
    else
    {
        if (m_pBuf) delete[] m_pBuf;
        m_wLength = wLength;
        m_wAllocated = wBlockSize;
        m_pBuf = new WCHAR[m_wAllocated];
        if( m_pBuf != NULL )
        {
            wcscpy(m_pBuf, pszWstr);
        }
        else
        {
            m_wLength = 0;
            m_wAllocated = 0;
        }
    }
    return *this;
}

/*
#ifndef _MAC
BOOL String::LoadString( UINT nID, HINSTANCE hInstance )
{
    char szBuf[256];    // this is safe since resource strings
                        // are limited to 255 characters

    if( ::LoadString( hInstance, nID, szBuf, sizeof( szBuf ) ) == 0 )
    {
        return FALSE;
    }
    delete[] m_pBuf;
    m_wLength = static_cast<WORD>( ::lstrlen( szBuf ) );
    m_wAllocated = figureblocksize( m_wLength );
    m_pBuf = new WCHAR[m_wAllocated];
    if( m_pBuf == NULL )
    {
        m_wLength = 0;
        return FALSE;
    }
    ::lstrcpy( m_pBuf, szBuf );
    m_pBuf[m_wLength] = '\0';
    return TRUE;
}
#endif
*/

void String::TrimTrailingSpaces()
{
    while( m_wLength > 0 && m_pBuf[m_wLength - 1] == ' ' )
    {
        m_pBuf[m_wLength - 1] = '\0';
        --m_wLength;
    }
}

void String::Concat( const String& str )
{
    if( ( str.m_wLength + m_wLength + 1 ) < m_wAllocated )
    {
        m_wLength = static_cast<WORD>( m_wLength + str.m_wLength );
        wcscat( m_pBuf, str.m_pBuf );
    }
    else
    {
        WCHAR* p;

        m_wLength = static_cast<WORD>( m_wLength + str.m_wLength );
        m_wAllocated = figureblocksize( m_wLength );
        p = new WCHAR[m_wAllocated];
        if( p != NULL )
        {
            wcscpy( p, m_pBuf );
            wcscat( p, str.m_pBuf );
            if (m_pBuf) delete[] m_pBuf;
            m_pBuf = p;
        }
    }
}

void String::Concat( LPCWSTR lpwzStr )
{
    int len;

    len = wcslen( lpwzStr );
    if( ( len + m_wLength + 1 ) < m_wAllocated )
    {
        m_wLength = static_cast<WORD>( m_wLength + len );
        wcscat( m_pBuf, lpwzStr );
    }
    else
    {
        WCHAR* p;

        m_wLength = static_cast<WORD>( m_wLength + len );
        m_wAllocated = figureblocksize( m_wLength );
        p = new WCHAR[m_wAllocated];
        if( p != NULL )
        {
            wcscpy( p, m_pBuf );
            wcscat( p, lpwzStr );
            if (m_pBuf) delete[] m_pBuf;
            m_pBuf = p;
        }
    }
}

void String::Concat( WCHAR wch )
{
    WCHAR buf[2];

    buf[0] = wch;
    buf[1] = '\0';
    if( ( 1 + m_wLength + 1 ) < m_wAllocated )
    {
        m_wLength += 1;
        wcscat( m_pBuf, buf );
    }
    else
    {
        WCHAR* p;

        m_wLength += 1;
        m_wAllocated = figureblocksize( m_wLength );
        p = new WCHAR[m_wAllocated];
        if( p != NULL )
        {
            wcscpy( p, m_pBuf );
            wcscat( p, buf );
            if (m_pBuf) delete[] m_pBuf;
            m_pBuf = p;
        }
    }
}

HRESULT String::ReadWCS( LPSTREAM pStream, DWORD cSize )
{
	HRESULT		hr = S_OK;
	WCHAR*		wstrText = NULL;
	DWORD		cb;
    WORD        wBlockSize;

    wstrText = new WCHAR[cSize / sizeof( WCHAR )];
	if( NULL == wstrText )
	{
		hr = E_OUTOFMEMORY;
		goto ON_ERR;
	}
    hr = pStream->Read( reinterpret_cast<LPWSTR>( wstrText ), cSize, &cb );
    if( FAILED( hr ) || cb != cSize )
	{
        hr = E_FAIL;
        goto ON_ERR;
	}

	cSize = wcslen(wstrText);
	if (cSize == 0)
	{
        if (m_pBuf)
		{
			m_pBuf[0] = L'\0';
		}
        m_wLength = 0;
		goto ON_ERR;
	}
    wBlockSize = figureblocksize( static_cast<WORD>( cSize ) );
    m_wLength = static_cast<WORD>( cSize );
    if( wBlockSize <= m_wAllocated )
    {
        wcscpy( m_pBuf, wstrText );
    }
    else
    {
        if (m_pBuf) delete[] m_pBuf;
        m_wAllocated = wBlockSize;
        m_pBuf = new WCHAR[m_wAllocated];
        if( m_pBuf != NULL )
        {
            wcscpy( m_pBuf, wstrText );
        }
        else
        {
            hr = E_OUTOFMEMORY;
            m_wLength = 0;
            m_wAllocated = 0;
        }
    }

ON_ERR:
    if( wstrText != NULL )
    {
		delete [] wstrText;
    }
    return hr;
}

/*
HRESULT String::WriteWCS( LPSTREAM pStream )
{
    HRESULT     hr;
    wchar_t*    wstrText;
	DWORD		cb;
    DWORD       cSize;

    cSize = MultiByteToWideChar( CP_ACP, 0, m_pBuf, -1, NULL, 0 );  // get number of wide characters required

	wstrText = new wchar_t[cSize];
    if( wstrText == NULL )
	{
		hr = E_OUTOFMEMORY;
    }
    else
    {
        MultiByteToWideChar( CP_ACP, 0, m_pBuf, -1, wstrText, cSize );
        hr = pStream->Write( reinterpret_cast<LPSTR>( wstrText ), cSize * sizeof( wchar_t ), &cb );
        if( FAILED( hr ) || cb != ( cSize * sizeof( wchar_t ) ) )
        {
            hr = E_FAIL;
        }
        else
        {
            hr = S_OK;
        }
        delete [] wstrText;
    }

    return hr;
}
*/

String operator+( const String& str1, const String& str2 )
{
    String str;

    str = str1;
    str.Concat( str2 );
    return str;
}

String operator+( const String& str1, LPCSTR lpszStr )
{
    String str;

    str = str1;
    str.Concat( lpszStr );
    return str;
}

String operator+( LPCSTR lpszStr, const String& str1 )
{
    String str;

    str = lpszStr;
    str.Concat( str1 );
    return str;
}

String operator+( const String& str1, char ch )
{
    String str;

    str = str1;
    str.Concat( ch );
    return str;
}

String operator+( char ch, const String& str1 )
{
    String str;

    str.Concat( ch );
    str.Concat( str1 );
    return str;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\cclock.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation

//  clock.h
#ifndef __CCLOCK_H__
#define __CCLOCK_H__

class CAudioSink;

class CClock : public IReferenceClock
{
friend class CAudioSink;
public:

    CClock();

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    /* IReferenceClock methods */
    HRESULT STDMETHODCALLTYPE GetTime( 
        /* [out] */ REFERENCE_TIME __RPC_FAR *pTime);
    
    HRESULT STDMETHODCALLTYPE AdviseTime( 
        /* [in] */ REFERENCE_TIME baseTime,
        /* [in] */ REFERENCE_TIME streamTime,
        /* [in] */ HANDLE hEvent,
        /* [out] */ DWORD __RPC_FAR *pdwAdviseCookie);
    
    HRESULT STDMETHODCALLTYPE AdvisePeriodic( 
        /* [in] */ REFERENCE_TIME startTime,
        /* [in] */ REFERENCE_TIME periodTime,
        /* [in] */ HANDLE hSemaphore,
        /* [out] */ DWORD __RPC_FAR *pdwAdviseCookie);
    
    HRESULT STDMETHODCALLTYPE Unadvise( 
        /* [in] */ DWORD dwAdviseCookie);
private:
    CAudioSink *	m_pParent;      // Pointer to parent structure.

#ifdef XMIX
    DWORD m_dwLastPosition;
    LONGLONG m_llSampleTime;
#endif
};

#endif //__CCLOCK_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\curve.h ===
// Copyright (c) 1998 Microsoft Corporation
// curve.h

#ifndef __CURVE_H_
#define __CURVE_H_

#define CT_MAX  192 // curve table maximum
#define CT_FACTOR	100	// curve table multiplication factor
#define CT_DIVFACTOR	( ( CT_MAX ) * CT_FACTOR ) // curve division factor

// linear curves
static short ganCT_Linear[CT_MAX + 1] = {
	0,100,200,300,400,500,600,700,
	800,900,1000,1100,1200,1300,1400,1500,
	1600,1700,1800,1900,2000,2100,2200,2300,
	2400,2500,2600,2700,2800,2900,3000,3100,
	3200,3300,3400,3500,3600,3700,3800,3900,
	4000,4100,4200,4300,4400,4500,4600,4700,
	4800,4900,5000,5100,5200,5300,5400,5500,
	5600,5700,5800,5900,6000,6100,6200,6300,
	6400,6500,6600,6700,6800,6900,7000,7100,
	7200,7300,7400,7500,7600,7700,7800,7900,
	8000,8100,8200,8300,8400,8500,8600,8700,
	8800,8900,9000,9100,9200,9300,9400,9500,
	9600,9700,9800,9900,10000,10100,10200,10300,
	10400,10500,10600,10700,10800,10900,11000,11100,
	11200,11300,11400,11500,11600,11700,11800,11900,
	12000,12100,12200,12300,12400,12500,12600,12700,
	12800,12900,13000,13100,13200,13300,13400,13500,
	13600,13700,13800,13900,14000,14100,14200,14300,
	14400,14500,14600,14700,14800,14900,15000,15100,
	15200,15300,15400,15500,15600,15700,15800,15900,
	16000,16100,16200,16300,16400,16500,16600,16700,
	16800,16900,17000,17100,17200,17300,17400,17500,
	17600,17700,17800,17900,18000,18100,18200,18300,
	18400,18500,18600,18700,18800,18900,19000,19100,19200 };

// sine curves
static short ganCT_Sine[CT_MAX + 1] = {
	0,1,5,11,20,32,46,62,
	82,103,128,155,184,216,250,287,
	327,369,413,460,509,561,615,671,
	730,792,855,921,990,1060,1133,1208,
	1286,1365,1447,1531,1617,1706,1796,1889,
	1983,2080,2179,2279,2382,2486,2593,2701,
	2811,2923,3037,3153,3270,3389,3509,3632,
	3755,3881,4008,4136,4266,4397,4530,4664,
	4799,4936,5074,5213,5354,5495,5638,5781,
	5926,6071,6218,6365,6514,6663,6813,6963,
	7115,7267,7420,7573,7727,7881,8036,8191,
	8346,8502,8659,8815,8972,9128,9285,9442,
	9600,9757,9914,10071,10227,10384,10540,10697,
	10853,11008,11163,11318,11472,11626,11779,11932,
	12084,12236,12386,12536,12685,12834,12981,13128,
	13273,13418,13561,13704,13845,13986,14125,14263,
	14399,14535,14669,14802,14933,15063,15191,15318,
	15444,15567,15690,15810,15929,16046,16162,16276,
	16388,16498,16606,16713,16817,16920,17020,17119,
	17216,17310,17403,17493,17582,17668,17752,17834,
	17913,17991,18066,18139,18209,18278,18344,18407,
	18469,18528,18584,18638,18690,18739,18786,18830,
	18872,18912,18949,18983,19015,19044,19071,19096,
	19117,19137,19153,19167,19179,19188,19194,19198,19200 };

// log curve
static short ganCT_Log[CT_MAX + 1] = {
	0,381,747,1097,1432,1755,2066,2366,
	2655,2934,3205,3467,3721,3967,4207,4439,
	4666,4886,5101,5310,5515,5714,5909,6099,
	6285,6467,6645,6819,6990,7157,7321,7482,
	7640,7795,7947,8096,8243,8387,8529,8668,
	8805,8940,9073,9204,9332,9459,9584,9707,
	9828,9947,10065,10181,10295,10408,10520,10630,
	10738,10845,10951,11056,11159,11261,11361,11461,
	11559,11656,11752,11847,11941,12034,12126,12216,
	12306,12395,12483,12570,12656,12741,12826,12909,
	12992,13074,13155,13235,13315,13394,13472,13549,
	13626,13702,13777,13851,13925,13998,14071,14143,
	14214,14285,14355,14425,14494,14562,14630,14698,
	14764,14831,14896,14962,15026,15091,15154,15218,
	15280,15343,15405,15466,15527,15587,15647,15707,
	15766,15825,15883,15941,15999,16056,16113,16169,
	16225,16281,16336,16391,16446,16500,16554,16607,
	16661,16713,16766,16818,16870,16921,16973,17024,
	17074,17124,17174,17224,17273,17323,17371,17420,
	17468,17516,17564,17611,17658,17705,17752,17798,
	17844,17890,17936,17981,18026,18071,18116,18160,
	18204,18248,18292,18335,18379,18422,18464,18507,
	18549,18592,18634,18675,18717,18758,18799,18840,
	18881,18921,18962,19002,19042,19081,19121,19160,19200 };

// exponential curve
static short ganCT_Exp[CT_MAX + 1] = {
	0,40,79,119,158,198,238,279,
	319,360,401,442,483,525,566,608,
	651,693,736,778,821,865,908,952,
	996,1040,1084,1129,1174,1219,1264,1310,
	1356,1402,1448,1495,1542,1589,1636,1684,
	1732,1780,1829,1877,1927,1976,2026,2076,
	2126,2176,2227,2279,2330,2382,2434,2487,
	2539,2593,2646,2700,2754,2809,2864,2919,
	2975,3031,3087,3144,3201,3259,3317,3375,
	3434,3493,3553,3613,3673,3734,3795,3857,
	3920,3982,4046,4109,4174,4238,4304,4369,
	4436,4502,4570,4638,4706,4775,4845,4915,
	4986,5057,5129,5202,5275,5349,5423,5498,
	5574,5651,5728,5806,5885,5965,6045,6126,
	6208,6291,6374,6459,6544,6630,6717,6805,
	6894,6984,7074,7166,7259,7353,7448,7544,
	7641,7739,7839,7939,8041,8144,8249,8355,
	8462,8570,8680,8792,8905,9019,9135,9253,
	9372,9493,9616,9741,9868,9996,10127,10260,
	10395,10532,10671,10813,10957,11104,11253,11405,
	11560,11718,11879,12043,12210,12381,12555,12733,
	12915,13101,13291,13486,13685,13890,14099,14314,
	14534,14761,14993,15233,15479,15733,15995,16266,
	16545,16834,17134,17445,17768,18103,18453,18819,19200 };

#endif // __CURVE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\CMixBins.h ===
//
// CMIXBINS.H
// 
// Copyright (c) 2001 Microsoft Corporation
//
// Created by danhaff 9/24/01
//
// Class representation of a DSMIXBINS struct.  Has lots of checks in 
// debug mode to prevent screw-ups.


#pragma once

#include <xtl.h>
#include <dsound.h>

class CMIXBINS
{
public:
    CMIXBINS(void);
    LPCDSMIXBINS GetMixBins(void);
    void         CreateFromMask(DWORD dwMask);
    void         PokeMixBinVolumesBasedOnMask(DWORD dwMixBinMask, long *alVolumes);
    BOOL         operator != (CMIXBINS &p_MixBins);
    BOOL         operator == (CMIXBINS &p_MixBins);

    #ifdef _DEBUG
    ~CMIXBINS(void);
    #endif

private:
    BOOL  m_bValid;
    DSMIXBINS m_DSMixBins;
    DSMIXBINVOLUMEPAIR m_VolumePair[DSMIXBIN_ASSIGNMENT_MAX];
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\audpath.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// DMSStObj.h : Declaration of the CSegState

#ifndef __AUDIOPATH_H_
#define __AUDIOPATH_H_

#include "dmusicip.h"
#include "dmusicf.h"
#include "TrkList.h"
#include "alist.h"
#include "..\shared\dmstrm.h"
#include "dmscriptautguids.h"
#include "..\shared\dmusiccp.h"

class CPerformance;
class CSegState;
class CGraph;
class CAudioPathConfig;
class CBufferConfig;
class CBuffer;
struct IDirectSoundConnect;

class CBufferNode : public AListItem
{
friend class CBufferManager;
friend class CAudioPath;
public:
    CBufferNode();
    ~CBufferNode();
    ULONG AddRef();
    ULONG Release();
    IDirectSoundBuffer *GetBuffer() { if (m_pBuffer) m_pBuffer->AddRef(); return m_pBuffer;}
    HRESULT Activate(BOOL fActivate);
private:
    void FinalDeactivate();
    CBufferNode* GetNext() { return (CBufferNode*)AListItem::GetNext();}
    IDirectSoundBuffer *   m_pBuffer;           // DSound buffer that this manages. 
    DMUS_IO_BUFFER_ATTRIBUTES_HEADER m_BufferHeader;  // GUID that identifies this buffer and flags (can it be shared?).
    CBufferManager * m_pManager; // Pointer to parent list. 
#ifdef XBOX
    DWORD   m_dwMixBin;     // If this represents a Mix Bin instead of a buffer, which one.
    DMUS_IO_BUFFER_MIXBINS_HEADER    m_MixBinsHeader;  // If this is an array of mix bin destinations.
#endif
    long m_lActivateCount;  // How many times this has been activated.
    long m_cRef;            // How many objects point at this.
};

class CBufferManager : public AList
{    

public:
    CBufferManager(); 
    ~CBufferManager() ;
    HRESULT Init(CPerformance *pPerf, DMUS_AUDIOPARAMS *pAudioParams) ;
#ifdef DXAPI
    HRESULT InitSink();
#endif
    void AddHead(CBufferNode* pBufferNode) { AList::AddHead((AListItem*)pBufferNode);}
    CBufferNode* GetHead(){return (CBufferNode*)AList::GetHead();}
    CBufferNode* RemoveHead() {return (CBufferNode *) AList::RemoveHead();}
    void Remove(CBufferNode* pBufferNode){AList::Remove((AListItem*)pBufferNode);}
    void AddTail(CBufferNode* pBufferNode){AList::AddTail((AListItem*)pBufferNode);}
    void Clear();
    void FinalDeactivate();
    CBufferNode * GetBufferNode(REFGUID guidBufferID);
    HRESULT CreateBuffer(CBufferConfig *pConfig, CBufferConfig **pNew); 
private:
    CPerformance *m_pPerf;                  // Pointer to parent performance. 
#ifndef XBOX
    CBufferConfig *m_pFirstBuffer;          // Actual buffer created by config.
#endif
public:
#ifndef XBOX
    IDirectSoundConnect* m_pSinkConnect;    // The sink object which manages creation of buffers in dsound.
    IDirectSoundSynthSink *m_pSynthSink;    // Used to activate sink.
#endif
    DMUS_AUDIOPARAMS m_AudioParams;
};

#ifdef SILVER
#define DSMIXBIN_FRONT_LEFT         0x00000001
#define DSMIXBIN_FRONT_RIGHT        0x00000002
#define DSMIXBIN_FRONT_CENTER       0x00000004
#define DSMIXBIN_LOW_FREQUENCY      0x00000008
#define DSMIXBIN_BACK_LEFT          0x00000010
#define DSMIXBIN_BACK_RIGHT         0x00000020

#define DSMIXBIN_SPEAKER_MASK       0x0000003F

#define DSMIXBIN_XTLK_FRONT_LEFT    0x00000040
#define DSMIXBIN_XTLK_FRONT_RIGHT   0x00000080
#define DSMIXBIN_XTLK_BACK_LEFT     0x00000100
#define DSMIXBIN_XTLK_BACK_RIGHT    0x00000200
#define DSMIXBIN_XTLK_MASK          0x000003C0

#define DSMIXBIN_I3DL2              0x00000400

#define DSMIXBIN_FXSEND_0           0x00000800
#define DSMIXBIN_FXSEND_1           0x00001000
#define DSMIXBIN_FXSEND_2           0x00002000
#define DSMIXBIN_FXSEND_3           0x00004000
#define DSMIXBIN_FXSEND_4           0x00008000
#define DSMIXBIN_FXSEND_5           0x00010000
#define DSMIXBIN_FXSEND_6           0x00020000
#define DSMIXBIN_FXSEND_7           0x00040000
#define DSMIXBIN_FXSEND_8           0x00080000
#define DSMIXBIN_FXSEND_9           0x00100000
#define DSMIXBIN_FXSEND_10          0x00200000
#define DSMIXBIN_FXSEND_11          0x00400000
#define DSMIXBIN_FXSEND_12          0x00800000
#define DSMIXBIN_FXSEND_13          0x01000000
#define DSMIXBIN_FXSEND_14          0x02000000
#define DSMIXBIN_FXSEND_15          0x04000000
#define DSMIXBIN_FXSEND_16          0x08000000
#define DSMIXBIN_FXSEND_17          0x10000000
#define DSMIXBIN_FXSEND_18          0x20000000
#define DSMIXBIN_FXSEND_19          0x40000000
#define DSMIXBIN_FXSEND_MASK        0x7FFFF800
#endif

#define BUFFER_REVERB       1
#define BUFFER_ENVREVERB    2
#define BUFFER_3D           3
#define BUFFER_3D_DRY       4
#define BUFFER_MONO         6
#define BUFFER_STEREO       7
#define BUFFER_MUSIC        8
#define BUFFER_CHORUS       9
#define BUFFER_MIXBINS      10

DEFINE_GUID(GUID_Buffer_Primary,0x186cc544, 0xdb29, 0x11d3, 0x9b, 0xd1, 0x0, 0x80, 0xc7, 0x15, 0xa, 0x74);

#define DMUS_BUFFERF_PRIMARY    4   // This buffer flag is a private definition.

#define DMUS_STANDARD_PATH_DX7  20 // This is for internal use only.

#define MAX_CONNECTIONS     32  // Maximum of 32 buffers connected to one PChannel.

class CBufferConfig : public AListItem
{
public:
    CBufferConfig(DWORD dwType) ;
    ~CBufferConfig();
    void DecideType();         // Looks at embedded GUID and infers default type, if one exists.
    HRESULT Load(IStream *pStream);
    CBufferConfig* GetNext() { return (CBufferConfig*)AListItem::GetNext();}
    IUnknown *              m_pBufferConfig;     // Buffer definition. 
    CBufferNode *           m_pBufferNode;      // Manages the DSound buffer.
    DMUS_IO_BUFFER_ATTRIBUTES_HEADER m_BufferHeader;  // GUID that identifies this buffer and flags.
    DWORD                   m_dwStandardBufferID;// Optionally, one of the standard buffer types.
    HRESULT Activate(BOOL fActivate);
#ifdef XBOX
    DMUS_IO_BUFFER_MIXBINS_HEADER    m_MixBinsHeader;  // If this is an array of mix bin destinations.
#endif
};

class CBufferConfigList : public AList
{
public:
    void AddHead(CBufferConfig* pBufferConfig) { AList::AddHead((AListItem*)pBufferConfig);}
    CBufferConfig* GetHead(){return (CBufferConfig*)AList::GetHead();}
    CBufferConfig* RemoveHead() {return (CBufferConfig *) AList::RemoveHead();}
    void Remove(CBufferConfig* pBufferConfig){AList::Remove((AListItem*)pBufferConfig);}
    void AddTail(CBufferConfig* pBufferConfig){AList::AddTail((AListItem*)pBufferConfig);}
    void Clear();
    CBufferNode * GetBufferNode(REFGUID guidBufferID);
    HRESULT CreateRunTimeVersion(CBufferConfigList *pCopy, CBufferManager *pManager);
    HRESULT Activate(BOOL fActivate);
};

class CPortConfig;

class CBufferConnect : public AListItem
{
public:
    CBufferConnect() ;
    ~CBufferConnect();
    CBufferConnect *CreateRunTimeVersion(CPortConfig *pParent);
    HRESULT Load(CRiffParser *pParser);
    CBufferConnect* GetNext() { return (CBufferConnect*)AListItem::GetNext();}
    DMUS_IO_PCHANNELTOBUFFER_HEADER m_ConnectHeader;
    GUID *                          m_pguidBufferIDs;// Set of guids identifying buffers to connect to.
    CBufferNode **                  m_ppBufferNodes; // Array of equivalent Buffer nodes. 
};

class CBufferConnectList : public AList
{
public:
    void AddHead(CBufferConnect* pBufferConnect) { AList::AddHead((AListItem*)pBufferConnect);}
    CBufferConnect* GetHead(){return (CBufferConnect*)AList::GetHead();}
    CBufferConnect* RemoveHead() {return (CBufferConnect *) AList::RemoveHead();}
    void Remove(CBufferConnect* pBufferConnect){AList::Remove((AListItem*)pBufferConnect);}
    void AddTail(CBufferConnect* pBufferConnect){AList::AddTail((AListItem*)pBufferConnect);}
    HRESULT CreateRunTimeVersion(CBufferConnectList *pDestination, CPortConfig *pParent);
    void Clear();
};

class CAudioPath;

class CPortConfig : public AListItem
{
public:
    CPortConfig() ;
    ~CPortConfig();
    HRESULT CreateRunTimeVersion(CPortConfig ** ppCopy, CAudioPath *pParent,CBufferManager *pManager);
    CPortConfig* GetNext() { return (CPortConfig*)AListItem::GetNext();}
    CBufferNode * GetBufferNode(REFGUID guidBuffer);
    HRESULT Activate(BOOL fActivate);
    HRESULT CPortConfig::Load(CRiffParser *pParser);
    DMUS_IO_PORTCONFIG_HEADER   m_PortHeader; // Port configuration header, from file.
    DMUS_PORTPARAMS8            m_PortParams; // Port params for opening the port, also from file. 
    DWORD                       m_dwPortID;   // Used to track the index of a created port, once connecting.
    CBufferConnectList          m_BufferConnectList; // Pchannel to buffer mappings. 
    CBufferConfigList           m_BufferConfigList; // List of dsound buffer configurations.
    CAudioPath *                m_pParent;    // Parent audio path.
    IDirectMusicPort *         m_pPort;      // Pointer to port, if run time version.
	BOOL						m_fAlreadyHere; // Check for recursive case looking for buffer nodes.
};

class CPortConfigList : public AList
{
public:
    void AddHead(CPortConfig* pPortConfig) { AList::AddHead((AListItem*)pPortConfig);}
    CPortConfig* GetHead(){return (CPortConfig*)AList::GetHead();}
    CPortConfig* RemoveHead() {return (CPortConfig *) AList::RemoveHead();}
    void Remove(CPortConfig* pPortConfig){AList::Remove((AListItem*)pPortConfig);}
    void AddTail(CPortConfig* pPortConfig){AList::AddTail((AListItem*)pPortConfig);}
    HRESULT CreateRunTimeVersion(CPortConfigList *pDestination,CAudioPath *pParent,CBufferManager *pManager);
    void Clear();
    HRESULT Activate(BOOL fActivate);
    BOOL UsesPort(IDirectMusicPort *pPort);
};

class CAudioPath;

DEFINE_GUID(IID_CAudioPath,0xb06c0c23, 0xd3c7, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);


/*  The AudioPath represents a configuration of pchannels, ports, and buffers to play
    segments. The performance creates CAudioPath objects from CAudioPathConfig file
    objects and stores them in a linked list, which it uses to keep track of them.
*/

class CAudioPath : 
    public IDirectMusicAudioPath, 
	public IDirectMusicGraph,
    public AListItem
{
public:
    CAudioPath();
    ~CAudioPath();
    CAudioPath* GetNext() { return (CAudioPath*)AListItem::GetNext();}
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

// IDirectMusicAudioPath 
    STDMETHODIMP GetObjectInPath( DWORD dwPChannel,DWORD dwStage,DWORD dwBuffer, REFGUID guidObject,
                    DWORD dwIndex,REFGUID iidInterface, void ** ppObject);
    STDMETHODIMP Activate(BOOL fActivate) ;
    STDMETHODIMP SetVolume(long lVolume,DWORD dwDuration) ;
    STDMETHODIMP ConvertPChannel( DWORD dwPChannelIn,DWORD *pdwPChannelOut) ; 
#ifdef XBOX
    STDMETHODIMP SetPitch(long lPitch,DWORD dwDuration) ;
#endif

// IDirectMusicGraph
	STDMETHODIMP Shutdown();
    STDMETHODIMP InsertTool(IDirectMusicTool *pTool,DWORD *pdwPChannels,DWORD cPChannels,LONG lIndex);
    STDMETHODIMP GetTool(DWORD,IDirectMusicTool**);
    STDMETHODIMP RemoveTool(IDirectMusicTool*);
    STDMETHODIMP StampPMsg(DMUS_PMSG* pEvent);

    HRESULT Init(IUnknown *pSourceConfig,CPerformance *pPerf);
    HRESULT ConnectToPorts(CPerformance *pPerf,DWORD dwSampleRate);
    CBufferNode * GetBufferNode(REFGUID guidBuffer);
    void SetGraph(CGraph *pGraph);
    CGraph *GetGraph();
    void Deactivate();
    BOOL IsActive() { return m_fActive; }
    BOOL NoPorts() { return m_PortConfigList.IsEmpty(); }
    BOOL UsesPort(IDirectMusicPort *pPort) { return m_PortConfigList.UsesPort(pPort); }
private:
    CMemTrack           m_MemTrack;         // Used for tracking memory allocations.
	DWORD				m_dwTrackID;		// Each Audiopath is assigned a track id for invalidations of broadcast messages.
    REFERENCE_TIME      m_rtLastVolChange;  // End point of last volume change request.
    REFERENCE_TIME      m_rtLastPitchChange;// End point of last pitch change request.
    BOOL                m_fDeactivating;    // State variable.
//    BYTE                m_bLastVol;         // Last volume change.
    CRITICAL_SECTION    m_CriticalSection;
	BOOL				m_fActive;			// Indicates that the audio path is active.
    long			    m_cRef;             // Reference counter. 
    DWORD *             m_pdwVChannels;     // Array of source VChannels.
    DWORD *             m_pdwPChannels;     // Array of destination PChannels.
    DWORD               m_dwChannelCount;   // Size of arrays.
    CGraph *            m_pGraph;           // Route tool graph.
    CPerformance *      m_pPerformance;     // Pointer to performance, needed to release PChannels.
    CAudioPathConfig *  m_pConfig;          // Source configuration.
    CPortConfigList     m_PortConfigList;   // List of port definitions (copied from source.)
    CBufferConfigList   m_BufferConfigList; // List of DSound buffers connected to the ports.
    IUnknown *          m_pUnkDispatch;     // holds the controlling unknown of the scripting object that implements IDispatch
};

class CAudioPathList : public AList
{
public:
    void Clear();
    void AddHead(CAudioPath* pAudioPath) { AList::AddHead((AListItem*)pAudioPath);}
    CAudioPath* GetHead(){return (CAudioPath*)AList::GetHead();}
    CAudioPath* RemoveHead() {return (CAudioPath *) AList::RemoveHead();}
    void Remove(CAudioPath* pAudioPath){AList::Remove((AListItem*)pAudioPath);}
    void AddTail(CAudioPath* pAudioPath){AList::AddTail((AListItem*)pAudioPath);}
    BOOL IsMember(CAudioPath* pAudioPath){return AList::IsMember((AListItem*)pAudioPath);}
    BOOL UsesPort(IDirectMusicPort *pPort); 
    CBufferNode * GetBufferNode(REFGUID guidBufferID);
};

DEFINE_GUID(IID_CAudioPathConfig,0xe9874261, 0xab52, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);

class CAudioPathConfig : CMemTrack,
    public IPersistStream, 
    public IDirectMusicObject
{
friend class CAudioPath;
public:
    CAudioPathConfig();
    ~CAudioPathConfig();
    static CAudioPathConfig *CreateStandardConfig(DWORD dwType,DWORD dwPChannelCount,DWORD dwSampleRate);


// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

// IPersist functions
    STDMETHODIMP GetClassID( CLSID* pClsId );
// IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load( IStream* pIStream );
    STDMETHODIMP Save( IStream* pIStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER FAR* pcbSize );

// IDirectMusicObject 
	STDMETHODIMP GetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP SetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc);

    HRESULT Load( CRiffParser *pParser);

protected:
    CGraph *            m_pGraph;                   // Audio path tool graph.
    CPortConfigList     m_PortConfigList;           // List of port definitions.
    CBufferConfigList   m_BufferConfigList;         // List of global dsound buffer configurations.
    CRITICAL_SECTION    m_CriticalSection;
	long		        m_cRef;
// IDirectMusicObject variables
    CInfo               m_Info;
//	DWORD	            m_dwValidData;
//	GUID	            m_guidObject;
//	FILETIME	        m_ftDate;                       /* Last edited date of object. */
//	DMUS_VERSION	    m_vVersion;                 /* Version. */
//	WCHAR	            m_wszName[DMUS_MAX_NAME];			/* Name of object.       */
//	WCHAR	            m_wszCategory[DMUS_MAX_CATEGORY];	/* Category for object */
//	WCHAR               m_wszFileName[DMUS_MAX_FILENAME];	/* File path. */
    IUnknown *          m_pUnkDispatch; // holds the controlling unknown of the scripting object that implements IDispatch
};

#endif // __AUDIOPATH_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\audiosink.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation
//	    audiosink.h

#ifndef __AUDIO_SINK__
#define __AUDIO_SINK__

#include <math.h>
#include <mmsystem.h>
#include "dmusicc.h"
#include "dmusics.h"
#include "cclock.h"
#include "PLClock.h"
//#include "dslink.h"
#include <dsound.h>
#include <dsoundp.h>
#include <dmksctrl.h>

DEFINE_GUID(IID_CBuffer, 0xf1e13d57, 0x7c29, 0x4ae6, 0x8d, 0x77, 0x94, 0x32, 0xb6, 0x51, 0xf3, 0xa6);

class CAudioSink;

#define AUDIOSINK_MAX_CHANNELS  2           // Max number of buses connected to buffer. We're limiting to 2 for now.
#define AUDIOSINK_NULL_BUS_ID   0xFFFFFFFF  // NULL bus ID.
#define AUDIOSINK_BUS_SIZE      100         // Bus size, in milliseconds

class CBuffer : 
#ifdef SILVER
public IDirectSoundBuffer,
#endif 
    public AListItem
{
friend class CAudioSink;
public:
    // IUnknown methods
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDirectSoundBuffer methods
    STDMETHODIMP Play(DWORD dwReserved1, DWORD dwReserved2, DWORD dwFlags) ;
    STDMETHODIMP PlayEx(REFERENCE_TIME rtTimeStamp, DWORD dwFlags) ;
    STDMETHODIMP Stop() ;
    STDMETHODIMP StopEx(REFERENCE_TIME rtTimeStamp, DWORD dwFlags) ;
    STDMETHODIMP SetLoopRegion(DWORD dwLoopStart, DWORD dwLoopLength) ;
    STDMETHODIMP GetStatus(LPDWORD pdwStatus) ;
    STDMETHODIMP GetCurrentPosition(LPDWORD pdwPlayCursor, LPDWORD pdwWriteCursor) ;
    STDMETHODIMP SetCurrentPosition(DWORD dwPlayCursor) ;
    STDMETHODIMP SetBufferData(LPVOID pvBufferData, DWORD dwBufferBytes) ;
    STDMETHODIMP Lock(DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1, LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags) ;
    STDMETHODIMP SetFrequency(DWORD dwFrequency) ;
    STDMETHODIMP SetVolume(LONG lVolume) ;

#ifdef SILVER

    STDMETHODIMP SetChannelVolume(LPCDSCHANNELVOLUME pVolume) ;

#else // SILVER

    STDMETHODIMP SetPitch(LONG lPitch);
    STDMETHODIMP SetLFO(LPCDSLFODESC pLFODesc);
    STDMETHODIMP SetEG(LPCDSENVELOPEDESC pEnvelopeDesc);    
    STDMETHODIMP SetFilter(LPCDSFILTERDESC pFilterDesc);
    STDMETHODIMP SetOutputBuffer(LPDIRECTSOUNDBUFFER pOutputBuffer);
    STDMETHODIMP SetMixBins(DWORD dwMixBins);
    STDMETHODIMP SetMixBinVolumes(DWORD dwMixBins, const LONG *alVolumes);
    STDMETHODIMP SetHeadroom(THIS_ DWORD dwHeadroom);

#endif // SILVER

    // IDirectSound3DBuffer methods
    STDMETHODIMP SetAllParameters(LPCDS3DBUFFER pds3db, DWORD dwApply) ;
    STDMETHODIMP SetConeAngles(DWORD dwInsideConeAngle, DWORD dwOutsideConeAngle, DWORD dwApply) ;
    STDMETHODIMP SetConeOrientation(FLOAT x, FLOAT y, FLOAT z, DWORD dwApply) ;
    STDMETHODIMP SetConeOutsideVolume(LONG lConeOutsideVolume, DWORD dwApply) ;
    STDMETHODIMP SetMaxDistance(FLOAT flMaxDistance, DWORD dwApply) ;
    STDMETHODIMP SetMinDistance(FLOAT flMinDistance, DWORD dwApply) ;
    STDMETHODIMP SetMode(DWORD dwMode, DWORD dwApply) ;
    STDMETHODIMP SetPosition(FLOAT x, FLOAT y, FLOAT z, DWORD dwApply) ;
    STDMETHODIMP SetVelocity(FLOAT x, FLOAT y, FLOAT z, DWORD dwApply) ;

    // IDirectSoundNotify methods
    STDMETHODIMP SetNotificationPositions(DWORD dwNotifyCount, LPCDSBPOSITIONNOTIFY paNotifies) ;
    STDMETHODIMP GetObjectInPath(REFGUID rguidObject, DWORD dwIndex, REFGUID rguidInterface, LPVOID *ppObject) ;

    CBuffer(CAudioSink *pParent,LPCDSBUFFERDESC pcBufferDesc,LPDWORD pdwFuncID, DWORD dwBusIDCount,REFGUID guidBufferID);
    ~CBuffer();
    CBuffer* GetNext() { return (CBuffer*)AListItem::GetNext();}
private:
    DWORD               DBToMultiplier(long lGain);
    void                CalcVolume();
    long                m_cRef;
    CAudioSink *        m_pParentSink;                  // Pointer to parent sink that manages the buffers.
    DWORD               m_dwFrequency;                  // Buffer playback frequency.
    long                m_lPBend;                       // Equivalent pitch bend.
    long                m_lVolume;                      // Gain, in dB.
    long                m_lPan;                         // Pan.
    DWORD               m_dwLeftVolume;                 // Left volume linear multiplier.
    DWORD               m_dwRightVolume;                // Right volume linear multiplier.
    GUID                m_guidBufferID;                 // Each mixin buffer has a unique guid.
    DWORD               m_dwChannels;                   // Number of channels in buffer itself.
    DWORD               m_dwBusCount;                   // Number of buses connected to buffer. We're maxing at 2 for now.
    DWORD               m_dwFunctionIDs[AUDIOSINK_MAX_CHANNELS];  // Function ids for each bus that feeds this buffer.
    DWORD               m_dwBusIDs[AUDIOSINK_MAX_CHANNELS];       // Equivalent bus ids.
    short *             m_pBusBuffer[AUDIOSINK_MAX_CHANNELS]; // Bus buffers to feed to synth.
    static DWORD        m_sdwNextBusID;                 // Global bus id generator.
    bool                m_fActive;
    CMemTrack           m_MemTrack;             // For debug memory tracking.
};

class CBufferList : public AList
{
public:
    void Clear();
    void AddHead(CBuffer* pBuffer) { AList::AddHead((AListItem*)pBuffer);}
    CBuffer* GetHead(){return (CBuffer*)AList::GetHead();}
    CBuffer* RemoveHead() {return (CBuffer *) AList::RemoveHead();}
    void Remove(CBuffer* pBuffer){AList::Remove((AListItem*)pBuffer);}
    void AddTail(CBuffer* pBuffer){AList::AddTail((AListItem*)pBuffer);}
    BOOL IsMember(CBuffer* pBuffer){return AList::IsMember((AListItem*)pBuffer);}
};

#define PACKETDUR   37      // duration in ms for one packet
#define PACKETSIZE  (((SAMPLERATE * PACKETDUR) + 500) / 1000)  // Size in # of samples.

#ifdef XBOX
#define PACKETCOUNT 2 // Save memory, reduce latency, on Xbox
#else
#define PACKETCOUNT 3
#endif

#define PACKETLATENCY ((PACKETCOUNT - 1) * PACKETDUR)

class CAudioSink :  public IDirectSoundSynthSink, public IDirectSoundConnect, public IReferenceClock, public IKsControl
{
friend class CBuffer;
friend class CClock;
public:
    // IUnknown methods
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDirectSoundSynthSink methods
    STDMETHODIMP GetLatencyClock(IReferenceClock **ppClock) ;
    STDMETHODIMP Activate(BOOL fEnable) ;
    STDMETHODIMP SampleToRefTime(LONGLONG llSampleTime, REFERENCE_TIME *prtTime) ;
    STDMETHODIMP RefToSampleTime(REFERENCE_TIME rtTime, LONGLONG *pllSampleTime) ;
    STDMETHODIMP GetFormat(LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) ;

    // IDirectSoundConnect methods
    STDMETHODIMP AddSource(LPDIRECTSOUNDSOURCE pDSSource) ;
    STDMETHODIMP RemoveSource(LPDIRECTSOUNDSOURCE pDSSource) ;
    STDMETHODIMP SetMasterClock(IReferenceClock *pClock) ;
    STDMETHODIMP CreateSoundBuffer(LPCDSBUFFERDESC pcBufferDesc, LPDWORD pdwFuncID, DWORD dwBusIDCount,
                                           REFGUID guidBufferID, LPDIRECTSOUNDBUFFER *ppBuffer) ;
    STDMETHODIMP CreateSoundBufferFromConfig(LPUNKNOWN pConfig, LPDIRECTSOUNDBUFFER *ppBuffer) ;
    STDMETHODIMP GetSoundBuffer(DWORD dwBusID, LPDIRECTSOUNDBUFFER *ppBuffer) ;
    STDMETHODIMP GetBusCount(LPDWORD pdwCount) ;
    STDMETHODIMP GetBusIDs(LPDWORD pdwBusIDs, LPDWORD pdwFuncIDs, DWORD dwBusCount) ;
    STDMETHODIMP GetFunctionalID(DWORD dwBusID, LPDWORD pdwFuncID) ;
    STDMETHODIMP GetSoundBufferBusIDs(LPDIRECTSOUNDBUFFER pBuffer, LPDWORD pdwBusIDs, LPDWORD pdwFuncIDs, LPDWORD pdwBusCount) ;

    /* IReferenceClock methods */
    STDMETHODIMP GetTime(REFERENCE_TIME *pTime);
    STDMETHODIMP AdviseTime(REFERENCE_TIME baseTime,REFERENCE_TIME streamTime,HANDLE hEvent,DWORD *pdwAdviseCookie);
    STDMETHODIMP AdvisePeriodic(REFERENCE_TIME startTime,REFERENCE_TIME periodTime,HANDLE hSemaphore,DWORD *pdwAdviseCookie);
    STDMETHODIMP STDMETHODCALLTYPE Unadvise(DWORD dwAdviseCookie);

    /* IKsControl methods */
    STDMETHODIMP KsProperty(PKSPROPERTY Property,ULONG PropertyLength,
        LPVOID PropertyData,ULONG DataLength,ULONG* BytesReturned);
    STDMETHODIMP KsMethod(PKSMETHOD Method,ULONG MethodLength,
        LPVOID MethodData,ULONG DataLength,ULONG* BytesReturned) ;
    STDMETHODIMP KsEvent(PKSEVENT Event OPTIONAL,ULONG EventLength,
        LPVOID EventData,ULONG DataLength,ULONG* BytesReturned);

    IReferenceClock *       GetMasterClock();
    CAudioSink(WAVEFORMATEX *pwfxFormat);
    ~CAudioSink();
    void                    Render(short *pnBuffer,DWORD dwLength,LONGLONG llWritePosition, LONGLONG llPlayPosition);
    void                    RemoveBuffer(CBuffer *pBuffer);
    HRESULT                 StreamThread();
private:
    void                    ResizeBusArrays();
    void                    FillBusArrays();
#ifndef XMIX
    void                    Mix(short *pnBuffer,DWORD dwLength);
#endif

    CClock                  m_MasterClock;      // Provides clock interface for rest of system.
//    CSampleClock            m_SampleClock;
    long                    m_cRef;
	WAVEFORMATEX		    m_wfSinkFormat;     // Format for audio.
//    IReferenceClock *       m_pMasterClock;
//    IDirectSoundSinkSync *  m_pMasterClockSync; // Control back over the master clock timing.
    BOOL                    m_fActive;
    CBufferList             m_BufferList;
    DWORD *                 m_pBusIDs;          // Array of bus ids.
    DWORD *                 m_pFunctionIDs;     // Array of function ids.
    long *                  m_pPBends;          // Array of pitch bends.
    short **                m_ppBusBuffers;     // Array of bus buffers to write into.
    DWORD                   m_dwBusCount;       // Number of buses currently in use.
    IDirectSoundSource *    m_pSynthSource;     // Pointer to synth. Ultimately, we can host a list of these, but this will do for now.
	LONGLONG			    m_llAbsPlay;		// Absolute point in sample time where play head is.
	LONGLONG			    m_llAbsWrite;	    // Absolute point in sample time we've written up to.
    DWORD                   m_dwBusBufferSize;  // Size of the bus buffers, used to read from the synth.
    CRITICAL_SECTION		m_CriticalSection;	// Critical section to manage access.

    HRESULT                 InitStream();       // Initializes the output buffer and starts it streaming.
public:
    void                    DoWork(REFERENCE_TIME *prtWakeUp);           // Processes whatever needs to be processed.
private:
    void                    KillStream();       // Kills the buffer and stops output.
#ifdef XMIX
    CBuffer *               m_pDummyBuffer;     // Just to keep things running for now...
    bool                    m_bStartTimeInitialized;
    REFERENCE_TIME          m_rtStartTime; // What the AC97 Clock was when we first looked at it
#else
    short *                 m_pnBuffers[PACKETCOUNT]; // Array of buffers.
    DWORD                   m_dwStatus[PACKETCOUNT];  // Status for each buffer.
    DWORD                   m_dwCurrentBuffer;  // Index into current buffer.
    LPDIRECTSOUNDSTREAM     m_pStream;          // Pointer to stream.
#endif
    LONGLONG                m_llSampleTime;     // Position in time.
    CWorker *               m_pSinkWorker;
    HANDLE                  m_hSinkThread; 
    DWORD                   m_dwSinkThreadID;
};


#endif // __AUDIO_SINK__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\curvetrk.h ===
// Copyright (c) 1998 Microsoft Corporation
/* This file no longer needed */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\buffer.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// buffer.cpp : Implementation of CBuffer

#include "pchime.h"

DWORD CBuffer::m_sdwNextBusID = 1;

CBuffer::CBuffer(CAudioSink *pSink,LPCDSBUFFERDESC pcBufferDesc,LPDWORD pdwFuncID, DWORD dwBusIDCount, REFGUID guidBufferID) : m_MemTrack(DMTRACK_BUFFER)
{
    m_cRef = 0;
    m_pParentSink = pSink;
    m_fActive = false;
    if (pSink)
    {
        pSink->m_BufferList.AddTail(this);
    }
    m_guidBufferID = guidBufferID;
    m_dwBusCount = dwBusIDCount;
    // Make sure we don't go out of bounds.
    if (dwBusIDCount > AUDIOSINK_MAX_CHANNELS)
    {
        dwBusIDCount = AUDIOSINK_MAX_CHANNELS;
    }
    // How many channels in the buffer?
    if (pcBufferDesc && pcBufferDesc->lpwfxFormat)
    {
        m_dwChannels = pcBufferDesc->lpwfxFormat->nChannels;
    }
    else m_dwChannels = 1;
    // Fill in the bus values for the buses that we want to connect to this buffer.
    DWORD dwIndex;
    for (dwIndex = 0;dwIndex < dwBusIDCount;dwIndex++)
    {
        m_dwFunctionIDs[dwIndex] = pdwFuncID[dwIndex];
        m_dwBusIDs[dwIndex] = m_sdwNextBusID++;
        m_pBusBuffer[dwIndex] = new short[pSink->m_dwBusBufferSize];
    }
    // Remaining channels on the buffer get null bus and function ids.
    for (;dwIndex < m_dwChannels;dwIndex++)
    {
        m_dwFunctionIDs[dwIndex] = AUDIOSINK_NULL_BUS_ID;
        m_dwBusIDs[dwIndex] = AUDIOSINK_NULL_BUS_ID;
        m_pBusBuffer[dwIndex] = NULL;
    }
    m_lVolume = 0;
    m_dwFrequency = SAMPLERATE;
    m_dwLeftVolume = 0xFFFF;
    m_dwRightVolume = 0xFFFF;
    m_lPBend = 0;
    m_lPan = 0;
    CalcVolume();
}

CBuffer::~CBuffer()
{
    if (m_pParentSink)
    {
        m_pParentSink->RemoveBuffer(this);
    }
    DWORD dwIndex;
    for (dwIndex = 0;dwIndex < m_dwBusCount;dwIndex++)
    {
        delete m_pBusBuffer[dwIndex];
    }
}

DWORD CBuffer::DBToMultiplier(long lGain)
{
    if (lGain > 0) lGain = 0;
    double flTemp = lGain;
    flTemp /= 1000.0;
    flTemp = pow(10.0,flTemp);
    flTemp = pow(flTemp,0.5);   // square root.
    flTemp *= 65535.0;          // 2^16th, but avoid overflow...
    return (DWORD) flTemp;
}

void CBuffer::CalcVolume()
{
    if (m_dwChannels == 1)
    {   // Wacky dsound pan algorithm!
        long lLeft;
        long lRight;
        if(m_lPan >= 0)
        {
            lLeft = m_lVolume - m_lPan;
            lRight = m_lVolume;
        }
        else
        {
            lLeft = m_lVolume;
            lRight = m_lVolume + m_lPan;
        }

        m_dwLeftVolume = DBToMultiplier(lLeft);
        m_dwRightVolume = DBToMultiplier(lRight);
    }
    else
    {
        m_dwLeftVolume = m_dwRightVolume = DBToMultiplier(m_lVolume);
    }
}

STDMETHODIMP CBuffer::QueryInterface(const IID &iid, void **ppv)
{
#ifdef SILVER
    if(iid == IID_IUnknown || iid == IID_IDirectSoundBuffer)
    {
        *ppv = static_cast<IDirectSoundBuffer*>(this);
    } 
    else 
#endif
        if (iid == IID_CBuffer)
    {
        *ppv = this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    
    return S_OK;
}

STDMETHODIMP_(ULONG) CBuffer::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CBuffer::Release()
{
    if(!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CBuffer::Play(DWORD dwReserved1, DWORD dwPriority, DWORD dwFlags)  
{
    m_fActive = true;
    return S_OK;
}

STDMETHODIMP CBuffer::PlayEx(REFERENCE_TIME rtTimeStamp, DWORD dwFlags)
{
    m_fActive = true;
	return S_OK;
}

STDMETHODIMP CBuffer::Stop()  
{
    m_fActive = false;
    return S_OK;
}

STDMETHODIMP CBuffer::StopEx(REFERENCE_TIME rtTimeStamp, DWORD dwFlags) 
{
    m_fActive = false;
    return S_OK;
}

STDMETHODIMP CBuffer::SetPlayRegion(DWORD dwPlayStart, DWORD dwPlayLength) 
{
    Trace(0,"Error: Can not set play region on a DMusic AudioPath buffer.\n");
	return E_FAIL;
}

STDMETHODIMP CBuffer::SetLoopRegion(DWORD dwLoopStart, DWORD dwLoopLength) 
{
    Trace(0,"Error: Can not set loop region on a DMusic AudioPath buffer.\n");
	return E_FAIL;
}

STDMETHODIMP CBuffer::GetStatus(LPDWORD pdwStatus)  
{
    Trace(0,"Error: GetStatus not yet implemented on a DMusic AudioPath buffer.\n");
    return E_NOTIMPL;
}

STDMETHODIMP CBuffer::GetCurrentPosition(LPDWORD pdwCurrentPlayCursor, LPDWORD pdwCurrentWriteCursor) 
{
    Trace(0,"Error: GetCurrentPosition not valid on a DMusic AudioPath buffer.\n");
    return E_FAIL;
}

STDMETHODIMP CBuffer::SetCurrentPosition(DWORD dwNewPosition)  
{
    Trace(0,"Error: SetCurrentPosition not valid on a DMusic AudioPath buffer.\n");
    return E_FAIL;
}

STDMETHODIMP CBuffer::SetBufferData(LPVOID pvBufferData, DWORD dwBufferBytes) 

{
    Trace(0,"Error: SetBufferData not valid on a DMusic AudioPath buffer.\n");
	return E_FAIL;
}

STDMETHODIMP CBuffer::Lock(DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1,
                                           LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags)  
{
    Trace(0,"Error: Lock not valid on a DMusic AudioPath buffer.\n");
    return E_FAIL;
}

STDMETHODIMP CBuffer::SetFrequency(DWORD dwFrequency)  
{
    m_dwFrequency = dwFrequency;
    double flTemp;
    if (m_pParentSink)
    {
        flTemp = m_pParentSink->m_wfSinkFormat.nSamplesPerSec;
    }
    else flTemp = SAMPLERATE;
    flTemp = (double) dwFrequency / flTemp;
    flTemp = log10(flTemp);
    flTemp *= 1200 * 3.3219280948873623478703194294894;    // Convert from Log10 to Log2 and multiply by cents per octave.
    m_lPBend = (long) flTemp;
    if (m_pParentSink)
    {
        m_pParentSink->FillBusArrays();
    }
    return S_OK;
}

STDMETHODIMP CBuffer::SetVolume(LONG lVolume)  
{
    m_lVolume = lVolume;
    CalcVolume();
    return S_OK;
}


#ifdef SILVER

STDMETHODIMP CBuffer::SetChannelVolume(LPCDSCHANNELVOLUME pVolume)
{
    Trace(1,"Warning: SetChannelVolume not yet implemented on a DMusic AudioPath buffer.\n");
    return E_NOTIMPL;
}

#else // SILVER

STDMETHODIMP CBuffer::SetPitch(LONG lPitch)
{
    Trace(0,"Error: SetPitch not legal on a DMusic AudioPath buffer.\n");
    return E_NOTIMPL;
}

STDMETHODIMP CBuffer::SetLFO(LPCDSLFODESC pLFODesc)
{
    Trace(0,"Error: SetLFO not legal on a DMusic AudioPath buffer.\n");
    return E_NOTIMPL;
}

STDMETHODIMP CBuffer::SetEG(LPCDSENVELOPEDESC pEnvelopeDesc)
{
    Trace(0,"Error: SetEG not legal on a DMusic AudioPath buffer.\n");
    return E_NOTIMPL;
}

STDMETHODIMP CBuffer::SetFilter(LPCDSFILTERDESC pFilterDesc)
{
    Trace(1,"Warning: SetFilter not yet implemented on a DMusic AudioPath buffer.\n");
    return E_NOTIMPL;
}

STDMETHODIMP CBuffer::SetOutputBuffer(LPDIRECTSOUNDBUFFER pOutputBuffer)
{
    Trace(1,"Warning: SetOutputBuffer not yet implemented on a DMusic AudioPath buffer.\n");
    return E_NOTIMPL;
}

STDMETHODIMP CBuffer::SetMixBins(LPCDSMIXBINS pMixBins)
{
    Trace(1,"Warning: SetMixBins not yet implemented on a DMusic AudioPath buffer.\n");
    return E_NOTIMPL;
}

STDMETHODIMP CBuffer::SetMixBinVolumes(LPCDSMIXBINS pMixBins)
{
    Trace(1,"Warning: SetMixBinVolumes not yet implemented on a DMusic AudioPath buffer.\n");
    return E_NOTIMPL;
}

STDMETHODIMP CBuffer::SetHeadroom(DWORD dwHeadroom)
{
    Trace(1,"Warning: SetHeadroom not yet implemented on a DMusic AudioPath buffer.\n");
    return E_NOTIMPL;
}

#endif // SILVER

    // IDirectSound3DBuffer methods
STDMETHODIMP CBuffer::SetAllParameters(LPCDS3DBUFFER pds3db, DWORD dwApply)

{
    Trace(1,"Warning: SetAllParameters not yet implemented on a DMusic AudioPath buffer.\n");
	return E_NOTIMPL;
}

STDMETHODIMP CBuffer::SetConeAngles(DWORD dwInsideConeAngle, DWORD dwOutsideConeAngle, DWORD dwApply) 

{
    Trace(1,"Warning: SetConeAngles not yet implemented on a DMusic AudioPath buffer.\n");
	return E_NOTIMPL;
}

STDMETHODIMP CBuffer::SetConeOrientation(FLOAT x, FLOAT y, FLOAT z, DWORD dwApply) 

{
    Trace(1,"Warning: SetConeOrientation not yet implemented on a DMusic AudioPath buffer.\n");
	return E_NOTIMPL;
}

STDMETHODIMP CBuffer::SetConeOutsideVolume(LONG lConeOutsideVolume, DWORD dwApply) 

{
    Trace(1,"Warning: SetConeOutsideVolume not yet implemented on a DMusic AudioPath buffer.\n");
	return E_NOTIMPL;
}

STDMETHODIMP CBuffer::SetMaxDistance(FLOAT flMaxDistance, DWORD dwApply) 

{
    Trace(1,"Warning: SetMaxDistance not yet implemented on a DMusic AudioPath buffer.\n");
	return E_NOTIMPL;
}

STDMETHODIMP CBuffer::SetMinDistance(FLOAT flMinDistance, DWORD dwApply) 

{
    Trace(1,"Warning: SetMinDistance not yet implemented on a DMusic AudioPath buffer.\n");
	return E_NOTIMPL;
}

STDMETHODIMP CBuffer::SetMode(DWORD dwMode, DWORD dwApply) 

{
    Trace(1,"Warning: SetMode not yet implemented on a DMusic AudioPath buffer.\n");
	return E_NOTIMPL;
}

STDMETHODIMP CBuffer::SetPosition(FLOAT x, FLOAT y, FLOAT z, DWORD dwApply) 

{
    Trace(1,"Warning: SetPosition not yet implemented on a DMusic AudioPath buffer.\n");
	return E_NOTIMPL;
}

STDMETHODIMP CBuffer::SetVelocity(FLOAT x, FLOAT y, FLOAT z, DWORD dwApply) 

{
    Trace(1,"Warning: SetVelocity not yet implemented on a DMusic AudioPath buffer.\n");
	return E_NOTIMPL;
}

    // IDirectSoundNotify methods
STDMETHODIMP CBuffer::SetNotificationPositions(DWORD dwNotifyCount, LPCDSBPOSITIONNOTIFY paNotifies) 

{
    Trace(1,"Warning: SetNotificationPositions not implemented on a DMusic AudioPath buffer.\n");
	return E_NOTIMPL;
}



/*
STDMETHODIMP CBuffer::GetFormat(LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten)  
{
    pwfxFormat->cbSize = 0;
    pwfxFormat->nAvgBytesPerSec = SAMPLERATE * 2;
    pwfxFormat->nBlockAlign = 2;
    pwfxFormat->nChannels = 1;
    pwfxFormat->nSamplesPerSec = SAMPLERATE;
    pwfxFormat->wBitsPerSample = 16;
    pwfxFormat->wFormatTag = WAVE_FORMAT_PCM;
    if (pdwSizeWritten) *pdwSizeWritten = sizeof(WAVEFORMATEX);
    return S_OK;
}

STDMETHODIMP CBuffer::GetVolume(LPLONG plVolume)  
{
    *plVolume = m_lVolume;
    return S_OK;
}

STDMETHODIMP CBuffer::GetPan(LPLONG plPan)  
{
    *plPan = m_lPan;
    return S_OK;
}

STDMETHODIMP CBuffer::GetFrequency(LPDWORD pdwFrequency)  
{
    *pdwFrequency = m_dwFrequency;
    return S_OK;
}



STDMETHODIMP CBuffer::Initialize(LPDIRECTSOUND pDirectSound, LPCDSBUFFERDESC pcBufferDesc)  
{
    return S_OK;
}
*/



/*STDMETHODIMP CBuffer::SetPan(LONG lPan)  
{
    m_lPan = lPan;
    CalcVolume();
    return S_OK;
}
*/

STDMETHODIMP CBuffer::GetObjectInPath(REFGUID rguidObject, DWORD dwIndex, REFGUID rguidInterface, LPVOID *ppObject)  
{
    Trace(1,"Warning: GetObjectInPath not implemented on a DMusic AudioPath buffer.\n");
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\audiosink.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// audiosink.cpp : Implementation of CAudioSink

#include "pchime.h"

CAudioSink::CAudioSink(WAVEFORMATEX *pwfxFormat)
{
    InitializeCriticalSection( &m_CriticalSection );
    m_MasterClock.m_pParent = this;
//    m_DSLink.SetWaveFormat(pwfxFormat);
    m_cRef = 0;
//    m_pMasterClock = NULL;
//    m_pMasterClockSync = NULL;
    m_fActive = FALSE;
    m_pSynthSource = NULL;
    m_wfSinkFormat.cbSize = 0;
    m_wfSinkFormat.nAvgBytesPerSec = SAMPLERATE * 2;
    m_wfSinkFormat.nBlockAlign = 2;
    m_wfSinkFormat.nChannels = 1;
    m_wfSinkFormat.nSamplesPerSec = SAMPLERATE;
    m_wfSinkFormat.wBitsPerSample = 16;
    m_wfSinkFormat.wFormatTag = WAVE_FORMAT_PCM;
    m_llAbsPlay = 0;
    m_llAbsWrite = 0;
    m_pBusIDs = NULL;
    m_pFunctionIDs = NULL;
    m_ppBusBuffers = NULL;
    m_pPBends = NULL;
    m_dwBusCount = 0;
    m_dwBusBufferSize = (m_wfSinkFormat.nSamplesPerSec * AUDIOSINK_BUS_SIZE) / 1000;
#ifdef XMIX
/*    DWORD dwFunctions[1] = { 0 };
    m_pDummyBuffer = new CBuffer(this,NULL,dwFunctions,1,GUID_NULL);
    if (m_pDummyBuffer)
    {
        m_pDummyBuffer->AddRef();
        ResizeBusArrays();
    }*/
//    DbgPrint("XMIX defined. Using microsequencer hardware mixing.\n");
#else
    DbgPrint("XMIX undefined. Using software mixing.\n");
#endif

}

CAudioSink::~CAudioSink()
{
    Activate(false);
    if (m_pSynthSource)
    {
        m_pSynthSource->Release();
    }
    if (m_pBusIDs) delete [] m_pBusIDs;
    if (m_pFunctionIDs) delete [] m_pFunctionIDs;
    if (m_ppBusBuffers) delete [] m_ppBusBuffers;
    if (m_pPBends) delete [] m_pPBends;
	DeleteCriticalSection( &m_CriticalSection );

#ifndef XMIX
    for(int i = 0; i < PACKETCOUNT; i++){
#ifdef SILVER
        delete [] m_pnBuffers[i];
#else
        XPhysicalFree(m_pnBuffers[i]);
#endif
    }
#else
/*    if (m_pDummyBuffer)
    {
        m_pDummyBuffer->Release();
    }*/
#endif // ndef XMIX
}

STDMETHODIMP CAudioSink::QueryInterface(const IID &iid, void **ppv)
{
    if(iid == IID_IUnknown || iid == IID_IDirectSoundSynthSink)
    {
        *ppv = static_cast<IDirectSoundSynthSink*>(this);
    } 
    else if(iid == IID_IDirectSoundConnect) 
    {
        *ppv = static_cast<IDirectSoundConnect*>(this);
    } 
    else if(iid == IID_IReferenceClock) 
    {
        *ppv = static_cast<IReferenceClock*>(this);
    }
    else if(iid == IID_IKsControl) 
    {
        *ppv = static_cast<IKsControl*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    
    return S_OK;
}

STDMETHODIMP_(ULONG) CAudioSink::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CAudioSink::Release()
{
    if(!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}


STDMETHODIMP CAudioSink::AddSource(LPDIRECTSOUNDSOURCE pDSSource) 
{
/*	EnterCriticalSection( &m_CriticalSection );
    if (m_pSynthSource)
    {
        m_pSynthSource->Release();
    }
    m_pSynthSource = pDSSource;
    if (m_pSynthSource)
    {
        m_pSynthSource->AddRef();
        DWORD dwSizeWritten;
        m_pSynthSource->GetFormat(&m_wfSinkFormat,sizeof(m_wfSinkFormat),&dwSizeWritten);
        m_dwBusBufferSize = (m_wfSinkFormat.nSamplesPerSec * AUDIOSINK_BUS_SIZE) / 1000;
    }
	LeaveCriticalSection( &m_CriticalSection );*/
    return S_OK;
}

STDMETHODIMP CAudioSink::RemoveSource(LPDIRECTSOUNDSOURCE pDSSource) 
{
/*	EnterCriticalSection( &m_CriticalSection );
    if (m_pSynthSource && (m_pSynthSource == pDSSource))
    {
        m_pSynthSource->Release();
        m_pSynthSource = NULL;
    }
	LeaveCriticalSection( &m_CriticalSection );*/
    return S_OK;
}

STDMETHODIMP CAudioSink::SetMasterClock(IReferenceClock *pClock)
{
    return S_OK;
}

STDMETHODIMP CAudioSink::CreateSoundBuffer(LPCDSBUFFERDESC pcBufferDesc, LPDWORD pdwFuncID, DWORD dwBusIDCount,
                                           REFGUID guidBufferID, LPDIRECTSOUNDBUFFER *ppBuffer) 
{
/*    CBuffer *pBuffer = new CBuffer(this,pcBufferDesc,pdwFuncID,dwBusIDCount,guidBufferID);
    if (pBuffer)
    {
        pBuffer->QueryInterface(IID_IDirectSoundBuffer,(void **)ppBuffer);
        ResizeBusArrays();
        return S_OK;
    }*/
    return E_OUTOFMEMORY;
}

STDMETHODIMP CAudioSink::CreateSoundBufferFromConfig(LPUNKNOWN pConfig, LPDIRECTSOUNDBUFFER *ppBuffer)
{
    // Create a null, bogus buffer for now, since we don't have the file io code in place yet.
/*    CBuffer *pBuffer = new CBuffer(this,NULL,NULL,0,GUID_NULL);
    if (pBuffer)
    {
        pBuffer->QueryInterface(IID_IDirectSoundBuffer,(void **)ppBuffer);
        ResizeBusArrays();
        return S_OK;
    }*/
    return E_OUTOFMEMORY;
}

STDMETHODIMP CAudioSink::GetSoundBuffer(DWORD dwBusID, LPDIRECTSOUNDBUFFER *ppBuffer)
{
/*	EnterCriticalSection( &m_CriticalSection );
    CBuffer *pBuffer = m_BufferList.GetHead();
    for (;pBuffer;pBuffer = pBuffer->GetNext())
    {
        DWORD dwBus = 0; 
        for (;dwBus < pBuffer->m_dwBusCount; dwBus++)
        {
            if (pBuffer->m_dwBusIDs[dwBus] == dwBusID)
            {
              	LeaveCriticalSection( &m_CriticalSection );
                return pBuffer->QueryInterface(IID_IDirectSoundBuffer, (void **) ppBuffer);
            }
        }
    }
	LeaveCriticalSection( &m_CriticalSection );*/
    return E_FAIL; // DSERR_INVALIDPARAM;
}

STDMETHODIMP CAudioSink::GetBusCount(LPDWORD pdwCount)
{
/*	EnterCriticalSection( &m_CriticalSection );
    DWORD dwCount = 0;
    CBuffer *pBuffer = m_BufferList.GetHead();
    for (;pBuffer;pBuffer = pBuffer->GetNext())
    {
        dwCount += pBuffer->m_dwBusCount;
    }
    *pdwCount = dwCount;
	LeaveCriticalSection( &m_CriticalSection );*/
    return S_OK;
}

STDMETHODIMP CAudioSink::GetBusIDs(LPDWORD pdwBusIDs, LPDWORD pdwFuncIDs, DWORD dwBusCount)
{
/*	EnterCriticalSection( &m_CriticalSection );
    if (dwBusCount > m_dwBusCount) dwBusCount = m_dwBusCount;
    if (pdwBusIDs)
    {
        memcpy(pdwBusIDs,m_pBusIDs,dwBusCount*sizeof(DWORD));
    }
    if (pdwFuncIDs)
    {
        memcpy(pdwFuncIDs,m_pFunctionIDs,dwBusCount*sizeof(DWORD));
    }
	LeaveCriticalSection( &m_CriticalSection );*/
    return S_OK;
}

STDMETHODIMP CAudioSink::GetFunctionalID(DWORD dwBusID, LPDWORD pdwFuncID) 
{
/*	EnterCriticalSection( &m_CriticalSection );
    CBuffer *pBuffer = m_BufferList.GetHead();
    for (;pBuffer;pBuffer = pBuffer->GetNext())
    {
        DWORD dwBus = 0; 
        for (;dwBus < pBuffer->m_dwBusCount; dwBus++)
        {
            if (pBuffer->m_dwBusIDs[dwBus] == dwBusID)
            {
                *pdwFuncID = pBuffer->m_dwFunctionIDs[dwBus];
            	LeaveCriticalSection( &m_CriticalSection );
                return S_OK;
            }
        }
    }
	LeaveCriticalSection( &m_CriticalSection );*/
    return E_FAIL; // DSERR_INVALIDPARAM;
}

STDMETHODIMP CAudioSink::GetSoundBufferBusIDs(LPDIRECTSOUNDBUFFER pDSBuffer, 
                                              LPDWORD pdwBusIDs, 
                                              LPDWORD pdwFuncIDs, 
                                              LPDWORD pdwBusCount)
{
/*	EnterCriticalSection( &m_CriticalSection );
    CBuffer *pCBuffer;
    if (SUCCEEDED(pDSBuffer->QueryInterface(IID_CBuffer,(void **)&pCBuffer)))
    {
        pCBuffer->Release();
        CBuffer *pBuffer = m_BufferList.GetHead();
        for (;pBuffer;pBuffer = pBuffer->GetNext())
        {
            if (pBuffer == pCBuffer)
            {
                DWORD dwMaxBusCount = *pdwBusCount;
                if (dwMaxBusCount > pBuffer->m_dwBusCount)
                {
                    dwMaxBusCount = pBuffer->m_dwBusCount;
                }
                *pdwBusCount = 0;

                for (DWORD dwBus = 0; dwBus < dwMaxBusCount; dwBus++)
                {
                    if (pBuffer->m_dwBusIDs[dwBus] == AUDIOSINK_NULL_BUS_ID)
                        break;

                    pdwBusIDs[dwBus] = pBuffer->m_dwBusIDs[dwBus];
                    if (pdwFuncIDs)
                    {
                        pdwFuncIDs[dwBus] = pBuffer->m_dwFunctionIDs[dwBus];
                    }
                    (*pdwBusCount)++;
                }
            	LeaveCriticalSection( &m_CriticalSection );
                return DS_OK;
            }
        }
    }
   	LeaveCriticalSection( &m_CriticalSection );*/
    return E_FAIL; // DSERR_INVALIDPARAM;
}

STDMETHODIMP CAudioSink::GetLatencyClock(IReferenceClock **ppClock)
{
    return QueryInterface(IID_IReferenceClock,(void **)ppClock);
}

void TestRender(short *pnBuffer,DWORD dwLength,DWORD dwPosition)
{
    DWORD dwIndex;
/*    TRACE("Mixing %ld samples from %ld to %ld on buffer %lx\n",
        dwLength,dwPosition,dwLength+dwPosition,pnBuffer);*/
    for (dwIndex = 0;dwIndex < dwLength;dwIndex += 2)
    {
        pnBuffer[dwIndex] = (short) ((dwPosition + dwIndex) * 1000);
        pnBuffer[dwIndex+1] = (short) ((dwPosition + dwIndex) * 1000);
    }
}

HRESULT CAudioSink::InitStream()

{
#ifndef XMIX
    DWORD dwX;
    for (dwX = 0; dwX < PACKETCOUNT; dwX++)
    {
#ifdef SILVER
        m_pnBuffers[dwX] = new short[PACKETSIZE*2]; // (short *) VirtualAlloc(NULL, PACKETSIZE*4, MEM_COMMIT, PAGE_READWRITE); 
#else
        m_pnBuffers[dwX] = (short *) XPhysicalAlloc(PACKETSIZE*4, MAXULONG_PTR, 0, PAGE_READWRITE | PAGE_NOCACHE);
        __asm wbinvd;
#endif
        m_dwStatus[dwX] = S_OK;
        memset(m_pnBuffers[dwX],0,PACKETSIZE*4);
    }
#endif // dnef XMIX

    WAVEFORMATEX waveFormat;
    waveFormat.nSamplesPerSec = SAMPLERATE;
    waveFormat.nAvgBytesPerSec = waveFormat.nSamplesPerSec * 2 * 2;
    waveFormat.cbSize = 0;
    waveFormat.nBlockAlign = 4;
    waveFormat.nChannels = 2;
    waveFormat.wBitsPerSample = 16;
    waveFormat.wFormatTag = WAVE_FORMAT_PCM;
    DSSTREAMDESC            dssd;
    memset(&dssd, 0, sizeof(dssd));
#ifdef SILVER
    dssd.dwSize = sizeof(dssd);
#endif // SILVER
    dssd.dwFlags = 0;
    dssd.dwMaxAttachedPackets = PACKETCOUNT;
    dssd.lpwfxFormat = &waveFormat;
    m_llSampleTime = 0;
#ifndef XMIX
    m_dwCurrentBuffer = 0;
#endif

#ifdef SILVER

    HRESULT hr = DirectSoundCreateStream(NULL, &dssd, &m_pStream, NULL);

#else // SILVER

#ifdef XMIX
    HRESULT hr = S_OK;
    m_bStartTimeInitialized = false;
    m_rtStartTime = 0;
#else
    HRESULT hr = DirectSoundCreateStream(&dssd, &m_pStream);
#endif

#endif // SILVER
#ifdef SILVER
    REFERENCE_TIME rtWakeUp;
    DoWork(&rtWakeUp);
#endif
    return hr;
}

void CAudioSink::KillStream()
{
#ifndef XMIX
    if (m_pStream)
    {
        m_pStream->Release();
    }
#endif
}

void CAudioSink::DoWork(REFERENCE_TIME *prtWakeUp)

{
#ifdef XMIX

    DirectSoundDoWork();

    REFERENCE_TIME now;
    m_MasterClock.GetTime(&now);

    LONGLONG stNow;
    RefToSampleTime(now, &stNow);

    static const LONGLONG kMinMixSize = PACKETSIZE;
    static const LONGLONG kTargetMixAhead = 3 * PACKETSIZE;

    LONGLONG stTargetMixTime = stNow + kTargetMixAhead;
    
    while(m_llSampleTime < stTargetMixTime){
        Render(NULL,kMinMixSize,m_llSampleTime,m_llSampleTime - kMinMixSize);
        m_llSampleTime += kMinMixSize;
        DirectSoundDoWork();
    }
    m_MasterClock.GetTime(prtWakeUp);
    *prtWakeUp += PACKETDUR * 10000;

#else // ndef XMIX

#ifndef SILVER
    DirectSoundDoWork(); // Needed to make sure m_dwStatus is up-to-date if the stream has sarved.
#endif
    while (m_dwStatus[m_dwCurrentBuffer] != XMEDIAPACKET_STATUS_PENDING)
    {
        XMEDIAPACKET xmb;
        xmb.pvBuffer = m_pnBuffers[m_dwCurrentBuffer];
        xmb.dwMaxSize = PACKETSIZE*4;
        xmb.pdwCompletedSize = NULL;
        m_dwStatus[m_dwCurrentBuffer] = 0;
        xmb.pdwStatus = &m_dwStatus[m_dwCurrentBuffer];
        xmb.hCompletionEvent = NULL;
        xmb.prtTimestamp = NULL;
        Render(m_pnBuffers[m_dwCurrentBuffer],PACKETSIZE,m_llSampleTime,m_llSampleTime - PACKETSIZE);
        m_pStream->Process(&xmb, NULL);
        m_llSampleTime += PACKETSIZE;
        m_dwCurrentBuffer++;
        if (m_dwCurrentBuffer >= PACKETCOUNT)
        {
            m_dwCurrentBuffer = 0;
        }
#ifndef SILVER
        DirectSoundDoWork(); // Needed to make sure m_dwStatus is up-to-date if the stream has sarved.
#endif
    }
    m_MasterClock.GetTime(prtWakeUp);
    *prtWakeUp += PACKETDUR * 10000;

#endif // ! XMIX
}

static void WINAPI _AudioSink(LPVOID lpParam,REFERENCE_TIME *prtWakeUp)
{
    ((CAudioSink *)lpParam)->DoWork(prtWakeUp);
}

HRESULT CAudioSink::StreamThread()
{
#ifdef XMIX

    Trace(-1,"CAudioSink::StreamThread - not implemented for XMIX.\n");
    return E_FAIL; // Not implemented for XMIX

#else // ndef XMIX

    DWORD dwX;
    for (dwX = 0; dwX < PACKETCOUNT; dwX++)
    {
#ifdef SILVER
        m_pnBuffers[dwX] = new short[PACKETSIZE*2]; // (short *) VirtualAlloc(NULL, PACKETSIZE*4, MEM_COMMIT, PAGE_READWRITE); 
#else
        m_pnBuffers[dwX] = (short *) XPhysicalAlloc(PACKETSIZE*4, MAXULONG_PTR, 64, PAGE_READWRITE | PAGE_NOCACHE);
#endif
        m_dwStatus[dwX] = 0;
        memset(m_pnBuffers[dwX],0,PACKETSIZE*4);
    }
    WAVEFORMATEX waveFormat;
    waveFormat.nSamplesPerSec = SAMPLERATE;
    waveFormat.nAvgBytesPerSec = waveFormat.nSamplesPerSec * 2 * 2;
    waveFormat.cbSize = 0;
    waveFormat.nBlockAlign = 4;
    waveFormat.nChannels = 2;
    waveFormat.wBitsPerSample = 16;
    waveFormat.wFormatTag = WAVE_FORMAT_PCM;
    DbgPrint("Creating stream\n");

    DSSTREAMDESC            dssd;

    memset(&dssd, 0, sizeof(dssd));
#ifdef SILVER
    dssd.dwSize = sizeof(dssd);
#endif // SILVER
    dssd.dwFlags = 0;
    dssd.dwMaxAttachedPackets = PACKETCOUNT;
    dssd.lpwfxFormat = &waveFormat;
    m_llSampleTime = 0;
    m_dwCurrentBuffer = 0;
#ifdef SILVER

    HRESULT hr = DirectSoundCreateStream(NULL, &dssd, &m_pStream, NULL);

#else // SILVER

    HRESULT hr = DirectSoundCreateStream(&dssd, &m_pStream);

#endif // SILVER

    HANDLE hCompletionEvent = NULL;
    if(SUCCEEDED(hr))
    {
        LONGLONG llSampleTime  = 0;
        DWORD dwPacket = 0;
        hCompletionEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        for (;;dwPacket++)
        {
            XMEDIAPACKET xmb;
            xmb.pvBuffer = m_pnBuffers[m_dwCurrentBuffer];
            xmb.dwMaxSize = PACKETSIZE*4;
            xmb.pdwCompletedSize = NULL;
            m_dwStatus[m_dwCurrentBuffer] = 0;
            xmb.pdwStatus = &m_dwStatus[m_dwCurrentBuffer];
            xmb.hCompletionEvent = hCompletionEvent;
            xmb.prtTimestamp = NULL;
            Render(m_pnBuffers[m_dwCurrentBuffer],PACKETSIZE,m_llSampleTime,m_llSampleTime - PACKETSIZE);
            m_pStream->Process(&xmb, NULL);
            m_llSampleTime += PACKETSIZE;
            m_dwCurrentBuffer++;
            if (m_dwCurrentBuffer >= PACKETCOUNT)
            {
                m_dwCurrentBuffer = 0;
            }
            if (dwPacket > 0)
            {
//              DbgPrint("Waiting for end of packet\n");
                WaitForSingleObject(hCompletionEvent, INFINITE);
            }
        }
    }
    if(hCompletionEvent)
    {
        CloseHandle(hCompletionEvent);
    }

    return hr;
#endif // !defined XMIX
}

static DWORD WINAPI _SinkThread(LPVOID lpParam)
{
    ((CAudioSink *)lpParam)->StreamThread();
    return 0;
}


STDMETHODIMP CAudioSink::Activate(BOOL fEnable)
{
	EnterCriticalSection( &m_CriticalSection );
    if (m_fActive != fEnable)
    {
        if (fEnable)
        {
            if (SUCCEEDED(InitStream()))
            {
//                m_pSinkWorker = g_BossMan.InstallWorker(_AudioSink,this,30);
                m_fActive = TRUE;
            	LeaveCriticalSection( &m_CriticalSection );
                return S_OK;
            }

/*            m_hSinkThread = CreateThread(NULL, 1024, _SinkThread, this, 0, &m_dwSinkThreadID);
            if( m_hSinkThread )
            {
//                m_hRealtime = CreateEvent(NULL,FALSE,FALSE,NULL);
                SetThreadPriority( m_hSinkThread, THREAD_PRIORITY_TIME_CRITICAL );
                m_fActive = TRUE;
                return S_OK;
            }*/
        }
        else
        {
            if (m_pSinkWorker)
            {
//                m_pSinkWorker->PinkSlip();
                m_pSinkWorker = NULL;
            }
            KillStream();
//            m_DSLink.CloseDown();
        }
        m_fActive = FALSE;
    }
	LeaveCriticalSection( &m_CriticalSection );
    return S_OK;
}

#define MILS_TO_REF	10000

STDMETHODIMP CAudioSink::SampleToRefTime(LONGLONG llSampleTime, REFERENCE_TIME *prtTime)
{
	llSampleTime *= MILS_TO_REF;
	llSampleTime /= SAMPLERATE;
	llSampleTime *= 1000;
    *prtTime = llSampleTime;
    return S_OK;
}

STDMETHODIMP CAudioSink::RefToSampleTime(REFERENCE_TIME rtTime, LONGLONG *pllSampleTime) 
{
	rtTime /= 1000;
	rtTime *= SAMPLERATE;
	rtTime /= MILS_TO_REF;
    *pllSampleTime = rtTime;
    return S_OK;
}

STDMETHODIMP CAudioSink::GetFormat(LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) 
{
    if (dwSizeAllocated > sizeof(m_wfSinkFormat))
    {
        dwSizeAllocated = sizeof(m_wfSinkFormat);
    }
    memcpy(pwfxFormat,&m_wfSinkFormat,dwSizeAllocated);
    if (pdwSizeWritten) *pdwSizeWritten = dwSizeAllocated;
    return S_OK;
}

STDMETHODIMP CAudioSink::AdviseTime(REFERENCE_TIME ,REFERENCE_TIME,HANDLE,DWORD *)
{
    return E_NOTIMPL;
}

STDMETHODIMP CAudioSink::AdvisePeriodic(REFERENCE_TIME,REFERENCE_TIME,HANDLE,DWORD * )
{
    return E_NOTIMPL;
}

STDMETHODIMP CAudioSink::Unadvise( DWORD )
{
    return E_NOTIMPL;
}

STDMETHODIMP CAudioSink::GetTime(LPREFERENCE_TIME pTime)
{
    HRESULT hr = E_FAIL;

    if( pTime == NULL )
    {
        return E_INVALIDARG;
    }

	EnterCriticalSection( &m_CriticalSection );
#ifdef XMIX
    LONGLONG playTime;
    hr = m_MasterClock.GetTime(&playTime);
    if(SUCCEEDED(hr))
    {
        LONGLONG writeTime = playTime + 1 * 10000; // Write time is 1 ms ahead of play time.
        *pTime = writeTime;
    }
#else
    hr = SampleToRefTime(m_llAbsWrite, pTime);
#endif
	LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

STDMETHODIMP CAudioSink::KsProperty(PKSPROPERTY Property,ULONG PropertyLength,
        LPVOID PropertyData,ULONG DataLength,ULONG* BytesReturned)
{
    return S_OK;
}

STDMETHODIMP CAudioSink::KsMethod(PKSMETHOD Method,ULONG MethodLength,
                                  LPVOID MethodData,ULONG DataLength,ULONG* BytesReturned) 
{
    return S_OK;
}

STDMETHODIMP CAudioSink::KsEvent(PKSEVENT Event OPTIONAL,ULONG EventLength,
                                 LPVOID EventData,ULONG DataLength,ULONG* BytesReturned)
{
    return S_OK;
}


/*
void CAudioSink::ResizeBusArrays()

{
	EnterCriticalSection( &m_CriticalSection );
    GetBusCount(&m_dwBusCount);
    if (m_pBusIDs) delete [] m_pBusIDs;
    if (m_pFunctionIDs) delete [] m_pFunctionIDs;
    if (m_ppBusBuffers) delete [] m_ppBusBuffers;
    if (m_pPBends) delete [] m_pPBends;
    if (m_dwBusCount)
    {
        m_pBusIDs = new DWORD[m_dwBusCount];
        m_pFunctionIDs = new DWORD[m_dwBusCount];
        m_ppBusBuffers = new short *[m_dwBusCount];
        m_pPBends = new long[m_dwBusCount];
        FillBusArrays();
    }
    else
    {
        m_pBusIDs = NULL;
        m_pFunctionIDs = NULL;
        m_ppBusBuffers = NULL;
        m_pPBends = NULL;
    }
	LeaveCriticalSection( &m_CriticalSection );
}

void CAudioSink::FillBusArrays()
{
	EnterCriticalSection( &m_CriticalSection );
    DWORD dwIndex = 0;
    CBuffer *pBuffer = m_BufferList.GetHead();
    for (;pBuffer;pBuffer = pBuffer->GetNext())
    {
        DWORD dwBus = 0; 
        for (;dwBus < pBuffer->m_dwBusCount; dwBus++)
        {
            // Make sure we don't go beyond the array bounds.
            if (dwIndex < m_dwBusCount)
            {
                m_pBusIDs[dwIndex] = pBuffer->m_dwBusIDs[dwBus];
                m_pFunctionIDs[dwIndex] = pBuffer->m_dwFunctionIDs[dwBus];
                m_ppBusBuffers[dwIndex] = pBuffer->m_pBusBuffer[dwBus];
                m_pPBends[dwIndex++] = pBuffer->m_lPBend;
            }
        }
    }
	LeaveCriticalSection( &m_CriticalSection );
}

void CAudioSink::RemoveBuffer(CBuffer *pBuffer)

{
	EnterCriticalSection( &m_CriticalSection );
    m_BufferList.Remove(pBuffer);
    ResizeBusArrays();
	LeaveCriticalSection( &m_CriticalSection );
}
*/
#ifndef XMIX

void CAudioSink::Mix(short *pnBuffer,DWORD dwLength)

{
	EnterCriticalSection( &m_CriticalSection );
    CBuffer *pBuffer = m_BufferList.GetHead();
    for (;pBuffer;pBuffer = pBuffer->GetNext())
    {
        if (pBuffer->m_fActive && pBuffer->m_dwBusCount) // Only mix activated buffers.
        {
            DWORD dwChannel = 0;
            DWORD dwBus = 0; 
            for (;dwChannel < 2; dwChannel++)
            {
                if (dwBus >= pBuffer->m_dwBusCount)
                {
                    dwBus = pBuffer->m_dwBusCount - 1;
                }
                short *pnSource = pBuffer->m_pBusBuffer[dwBus];
                DWORD dwIndex;
                DWORD dwWrite = dwChannel;
                for (dwIndex = 0; dwIndex < dwLength; dwIndex++)
                {
                    long lAccum;
                    if (dwChannel) lAccum = pnSource[dwIndex] * pBuffer->m_dwRightVolume;
                    else lAccum = pnSource[dwIndex] * pBuffer->m_dwLeftVolume;
                    lAccum = lAccum >> 16;
                    lAccum += pnBuffer[dwWrite];
                    if (lAccum > 32767) lAccum = 32767;
                    else if (lAccum < -32767) lAccum = -32767;
                    pnBuffer[dwWrite] = (short) lAccum;
                    dwWrite += 2;
                }
                dwBus++;
            }
        }
    }
	LeaveCriticalSection( &m_CriticalSection );
}

/*void CAudioSink::Mix(short *pnBuffer,DWORD dwLength)

{
	short *pnOrigBuffer = pnBuffer;

    CBuffer *pBuffer = m_BufferList.GetHead();
    for (;pBuffer;pBuffer = pBuffer->GetNext())
    {
        if (pBuffer->m_fActive) // Only mix activated buffers.
        {
		    if( pBuffer->m_dwBusCount > 0 )
		    {
			    // Do left bus
                short *pnSource = pBuffer->m_pBusBuffer[0];
                DWORD dwIndex;

			    pnBuffer = pnOrigBuffer;

                for (dwIndex = dwLength; dwIndex > 0; dwIndex--)
                {
                    long lAccum;
				    lAccum = *pnSource * pBuffer->m_dwLeftVolume;

                    lAccum = lAccum >> 16;
                    lAccum += *pnBuffer;

                    if (lAccum > 32767) lAccum = 32767;
                    else if (lAccum < -32767) lAccum = -32767;

                    *pnBuffer = (short) lAccum;
				    pnBuffer += 2;// Assume stereo
				    pnSource++;
                }
		    }

		    if( pBuffer->m_dwBusCount > 1 )
		    {
			    // Do right bus
                short *pnSource = pBuffer->m_pBusBuffer[1]; // 1 = right bus
                DWORD dwIndex;

 			    pnBuffer = pnOrigBuffer + 1;// start with the second sample

                for (dwIndex = dwLength; dwIndex > 0; dwIndex--)
                {
                    long lAccum;
				    lAccum = *pnSource * pBuffer->m_dwRightVolume;

                    lAccum = lAccum >> 16;
                    lAccum += *pnBuffer;

                    if (lAccum > 32767) lAccum = 32767;
                    else if (lAccum < -32767) lAccum = -32767;

                    *pnBuffer = (short) lAccum;
				    pnBuffer += 2;// Assume stereo
				    pnSource++;
                }
            }
        }
    }
}*/

#endif // !XMIX

static int nBeep = 0;

/*void WINAPI DoBeep()

{
    nBeep = 2;
}*/

void CAudioSink::Render(short *pnBuffer,
                        DWORD dwLength,
                        LONGLONG llWritePosition, 
                        LONGLONG llPlayPosition)
{
	EnterCriticalSection( &m_CriticalSection );
#ifndef XMIX
    memset(pnBuffer,0,dwLength*2*2);
#endif
DWORD dwTemp = dwLength*2;
    if (m_pSynthSource && m_dwBusCount)
    {
        DWORD dwStartPoint = 0;
        while (dwLength > 0)
        {
            DWORD dwSliceSize = dwLength;
            if (dwLength > m_dwBusBufferSize)
            {
                dwLength -= m_dwBusBufferSize;
                dwSliceSize = m_dwBusBufferSize;
            }
            else
            {
                dwLength = 0;
            }
            ULONGLONG llBytesToRead = dwSliceSize * 2;
#ifndef XMIX
            DWORD dwIndex = 0;
            for (;dwIndex < m_dwBusCount;dwIndex++)
            {
                memset(m_ppBusBuffers[dwIndex],0,dwSliceSize * 2);
            }
#endif // !XMIX
            m_pSynthSource->Read((void**)m_ppBusBuffers, m_pBusIDs, m_pFunctionIDs, 
                m_pPBends,m_dwBusCount, &llBytesToRead);
#ifndef XMIX
            Mix(&pnBuffer[dwStartPoint*2],dwSliceSize);
#endif // !XMIX
            dwStartPoint += dwSliceSize;
        }
/*
        if (nBeep)
        {
            REFERENCE_TIME rtMaster;
            REFERENCE_TIME rtLatency;
            GetTime(&rtLatency);
            m_MasterClock.GetTime(&rtMaster);
            DbgPrint("Beep: Master time: %ld, Latency time: %ld, Size: %ld\n",
                (long)(rtMaster/10000),(long)(rtLatency / 10000),dwTemp);
            DWORD dwScan = 0;
            for (;dwScan < dwTemp;dwScan++)
            {
                pnBuffer[dwScan] = (short) dwScan * 4000;
            }
            nBeep--;
        }*/
    }
    m_llAbsPlay = llPlayPosition;
    m_llAbsWrite = llWritePosition;
    LeaveCriticalSection( &m_CriticalSection );
}

IReferenceClock *CAudioSink::GetMasterClock()
{
    return (IReferenceClock *) &m_MasterClock;
}

CClock::CClock(){
#ifdef XMIX
    m_dwLastPosition = 0;
    m_llSampleTime = 0;
#endif // XMIX
}


STDMETHODIMP CClock::QueryInterface(const IID &iid, void **ppv)
{
    if(iid == IID_IUnknown || iid == IID_IReferenceClock)
    {
        *ppv = static_cast<IReferenceClock*>(this);
    } 
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    
    return S_OK;
}

STDMETHODIMP_(ULONG) CClock::AddRef()
{
    return m_pParent->AddRef();
}

STDMETHODIMP_(ULONG) CClock::Release()
{
    return m_pParent->Release();
}

STDMETHODIMP CClock::AdviseTime(REFERENCE_TIME ,REFERENCE_TIME,HANDLE,DWORD *)
{
    return E_NOTIMPL;
}

STDMETHODIMP CClock::AdvisePeriodic(REFERENCE_TIME,REFERENCE_TIME,HANDLE,DWORD * )
{
    return E_NOTIMPL;
}

STDMETHODIMP CClock::Unadvise( DWORD )
{
    return E_NOTIMPL;
}

#ifdef XMIX
// Defined in dmusicp.h, but that's not convenient to include here.

EXTERN_C DWORD WINAPI DirectSoundGetSampleTime(void);

#endif

STDMETHODIMP CClock::GetTime(LPREFERENCE_TIME pTime)
{
    HRESULT hr = E_FAIL;

    if( pTime == NULL )
    {
        return E_INVALIDARG;
    }

	EnterCriticalSection( &m_pParent->m_CriticalSection );

#ifdef XMIX

    DWORD dwPosition = DirectSoundGetSampleTime();
    hr = S_OK;

    // Check to see if we looped around, which happens every 24 hours

    if(SUCCEEDED(hr)){
        LONGLONG delta;
        if(dwPosition < m_dwLastPosition){
            // This is either a loop, or a dsound bug

            if(dwPosition < 100000 && m_dwLastPosition > (1 << 30) ){
                Trace(-1, "CClock::GetTime sample time wrapped (as it should every 24 hours. Was: %u is: %u\n",
                    m_dwLastPosition, dwPosition);
                delta = ((((LONGLONG) 1) << 32) + dwPosition) - m_dwLastPosition;
            }
            else {
                Trace(-1, "CClock::GetTime stream position decreased unexpectedly. Was: %u is: %u\n",
                    m_dwLastPosition, dwPosition);
                delta = 0; // Ignore.
                m_dwLastPosition = dwPosition; // Catch up. (Sometimes DSound resets the stream on us.)
            }
        }
        else {
            delta = dwPosition - m_dwLastPosition;
        }

        m_dwLastPosition = dwPosition;

        m_llSampleTime += delta;
    }
    hr = m_pParent->SampleToRefTime(m_llSampleTime, pTime);
            
#else

    hr = m_pParent->SampleToRefTime(m_pParent->m_llAbsPlay, pTime);

#endif

	LeaveCriticalSection( &m_pParent->m_CriticalSection );
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\dmdload.cpp ===
//
// dmdload.cpp
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note: Originally written by Robert K. Amenn
//
// @doc EXTERNAL 
//

#include "debug.h"
#ifndef XBOX
#include <objbase.h>
#endif // !XBOX
#include "dmusicp.h"
#include "dmdload.h"
#include "validate.h"

#ifdef IMPLEMENT_PERFORMANCE_COUNTERS

#include <critsec.h>

static CRITICAL_SECTION gDownloadDataCounterCrSec;
static DWORD g_dwDownloadedData;

extern "C" void DMRPC_DownloadBuffer(){
    INITIALIZE_CRITICAL_SECTION(&gDownloadDataCounterCrSec);
    DMusicRegisterPerformanceCounter( "DM downloaded instrument data (bytes)",
                          DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                          &g_dwDownloadedData );
}

extern "C" void DMURPC_DownloadBuffer(){
    DMusicUnregisterPerformanceCounter( "DM downloaded instrument data (bytes)");
}


#endif

//////////////////////////////////////////////////////////////////////
// CDownloadBuffer::CDownloadBuffer

CDownloadBuffer::CDownloadBuffer() : 
m_DLHandle(NULL),
m_dwDLId(0xFFFFFFFF),
m_pvBuffer(NULL),
m_dwSize(0),
m_lDownloadCount(0),
m_cRef(1)
{
}

//////////////////////////////////////////////////////////////////////
// CDownloadBuffer::~CDownloadBuffer

CDownloadBuffer::~CDownloadBuffer()
{
	// If assert fires we have not unloaded from a port; this is a problem
	// It should never happen since the download code will have a reference
	assert(m_lDownloadCount == 0);

	delete [] m_pvBuffer;

#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
    if(m_dwSize){
        ENTER_CRITICAL_SECTION(&gDownloadDataCounterCrSec);
        g_dwDownloadedData -= m_dwHeaderSize + m_dwSize;
        LEAVE_CRITICAL_SECTION(&gDownloadDataCounterCrSec);
    }
#endif
}

//////////////////////////////////////////////////////////////////////
// IUnknown

//////////////////////////////////////////////////////////////////////
// CDownloadBuffer::QueryInterface

STDMETHODIMP CDownloadBuffer::QueryInterface(const IID &iid, void **ppv)
{
    V_INAME(IDirectMusicDownload::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);


	if(iid == IID_IUnknown || iid == IID_IDirectMusicDownload)
	{
        *ppv = static_cast<IDirectMusicDownload*>(this);
    } 
	else if(iid == IID_IDirectMusicDownloadPrivate)
	{
		*ppv = static_cast<IDirectMusicDownloadPrivate*>(this);
	}
	else
	{
        *ppv = NULL;
        return E_NOINTERFACE;
	}

    reinterpret_cast<IUnknown*>(this)->AddRef();
    
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDownloadBuffer::AddRef

STDMETHODIMP_(ULONG) CDownloadBuffer::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDownloadBuffer::Release

STDMETHODIMP_(ULONG) CDownloadBuffer::Release()
{
    if(!InterlockedDecrement(&m_cRef))
	{
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicDownload

//////////////////////////////////////////////////////////////////////
// CDownloadBuffer::GetBuffer

/*

@method HRESULT | IDirectMusicDownload | GetBuffer | 
Returns a pointer to a buffer which contains
the data buffer managed by the <i IDirectMusicDownload>
inteface. Authoring tools 
that create instruments and download them
directly to the synthesizer use this method to access the
memory and write the instrument definition into it.  

@rdesc Returned codes include:

@flag S_OK | Success.
@flag DMUS_E_BUFFERNOTAVAILABLE | Buffer is not available, probably
because data has already been downloaded to DLS device. 
@flag E_POINTER | Invalid pointer.

@xref <i IDirectMusicDownload>, <i IDirectMusicPortDownload>, 
<om IDirectMusicPortDownload::GetBuffer>

*/

STDMETHODIMP CDownloadBuffer::GetBuffer(
    void** ppvBuffer,   // @parm Pointer to store address of data buffer in.
    DWORD* pdwSize)     // @parm Size of the returned buffer, in bytes.
{
	// Argument validation
	V_INAME(IDirectMusicDownload::GetBuffer);
	V_PTRPTR_WRITE(ppvBuffer);
	V_PTR_WRITE(pdwSize, DWORD);

	if(IsDownloaded() == S_OK)
	{
		return DMUS_E_BUFFERNOTAVAILABLE;
	}

	*ppvBuffer = ((LPBYTE)m_pvBuffer) + m_dwHeaderSize;
	*pdwSize = m_dwSize;
	
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Internal

//////////////////////////////////////////////////////////////////////
// CDownloadBuffer::SetBuffer

HRESULT CDownloadBuffer::SetBuffer(void* pvBuffer, DWORD dwHeaderSize, DWORD dwSize)
{
	// Assumption validation - Debug
	// We should never have a non-NULL pvBuffer and a size of zero
#ifdef DBG
	if(pvBuffer && dwSize == 0)
	{
		assert(false);
	}
#endif

#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
    ENTER_CRITICAL_SECTION(&gDownloadDataCounterCrSec);
    if(m_dwSize){
        g_dwDownloadedData -= (m_dwHeaderSize + m_dwSize);
    }
    g_dwDownloadedData += dwHeaderSize + dwSize;
    LEAVE_CRITICAL_SECTION(&gDownloadDataCounterCrSec);
#endif

	m_pvBuffer = pvBuffer;
    m_dwHeaderSize = dwHeaderSize;
	m_dwSize = dwSize;

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDownloadBuffer::GetBuffer

HRESULT CDownloadBuffer::GetBuffer(void** ppvBuffer)
{
	// Argument validation - Debug
	assert(ppvBuffer);

	*ppvBuffer = ((LPBYTE)m_pvBuffer) + m_dwHeaderSize;
	
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDownloadBuffer::GetHeader

HRESULT CDownloadBuffer::GetHeader(void** ppvHeader, DWORD *pdwHeaderSize)
{
	// Argument validation - Debug
	assert(ppvHeader);
    assert(pdwHeaderSize);

	*ppvHeader = m_pvBuffer;
    *pdwHeaderSize = m_dwHeaderSize;
    
	
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\dmgraph.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// DMGraph.h : Declaration of the CGraph

#ifndef __DMGRAPH_H_
#define __DMGRAPH_H_

#include "alist.h"
#include "dmusicip.h"
#include "dmusicf.h"
#include "..\shared\dmstrm.h"

class CRiffParser;

class CToolRef : public AListItem
{
public:
	CToolRef()
	{
        m_fSupportsClone = FALSE;
		m_pTool = NULL;
		m_dwQueue = 0;
		m_dwMTArraySize = 0;
        m_dwPCArraySize = 0;
		m_pdwMediaTypes = NULL;
		m_pdwPChannels = NULL;
        m_guidClassID = GUID_NULL;
	};

	// the memory for pdwTracks and pidType better have been allocated with
	// something compatible with delete!!!
	~CToolRef()
	{
		if( m_pdwPChannels )
		{
			delete [] m_pdwPChannels;
		}
		if( m_pdwMediaTypes )
		{
			delete [] m_pdwMediaTypes;
		}
		if( m_pTool )
		{
			m_pTool->Release();
		}
	};
    CToolRef* GetNext()
	{
		return (CToolRef*)AListItem::GetNext();
	};

    GUID                m_guidClassID;      // Class ID of tool.
    BOOL                m_fSupportsClone;   // Indicates this is a DX8 tool with support for cloning.
	IDirectMusicTool*	m_pTool;
	DWORD	            m_dwQueue;	// type of queue the tool wants messages to be
	DWORD	            m_dwMTArraySize; // size of the pdwMediaTypes array
	DWORD*	            m_pdwMediaTypes; // types of media the tool supports
	DWORD               m_dwPCArraySize;  // size of the pdwPChannels array
	DWORD*	            m_pdwPChannels;	// array of PChannel id's - messages stamped with these id's are
						// sent to the tool

};

class CGraph;

//#undef  INTERFACE
//#define INTERFACE  IGraphClone
DECLARE_INTERFACE_(IGraphClone, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IGraphClone */
    STDMETHOD(Clone)                (THIS_ IDirectMusicGraph **ppGraph) PURE;
};

DEFINE_GUID(IID_CGraph,0xb06c0c24, 0xd3c7, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);
DEFINE_GUID(IID_IGraphClone,0xb06c0c27, 0xd3c7, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);


/////////////////////////////////////////////////////////////////////////////
// CGraph
class CGraph :
	public IDirectMusicGraph8,
	public IPersistStream,
    public IDirectMusicObject,
    public IGraphClone,
    public AList,
    public AListItem
{
public:
	CGraph();
	~CGraph();
    CToolRef* GetHead(){return (CToolRef*)AList::GetHead();};
    CToolRef* RemoveHead(){return (CToolRef*)AList::RemoveHead();};
    CToolRef* GetItem(LONG lIndex){return (CToolRef*) AList::GetItem(lIndex);};
    CGraph* GetNext() { return (CGraph*)AListItem::GetNext();}

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

// IDirectMusicGraph
    STDMETHODIMP InsertTool(IDirectMusicTool *pTool,DWORD *pdwPChannels,DWORD cPChannels,LONG lIndex);
    STDMETHODIMP GetTool(DWORD dwPosition,IDirectMusicTool** ppTool);
    STDMETHODIMP RemoveTool(IDirectMusicTool* pTool);
    STDMETHODIMP StampPMsg(DMUS_PMSG* pPMsg);
//  IGraphClone 
    STDMETHODIMP Clone(IDirectMusicGraph **ppGraph); 

// IPersist functions
    STDMETHODIMP GetClassID( CLSID* pClsId );
// IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load( IStream* pIStream );
    STDMETHODIMP Save( IStream* pIStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER FAR* pcbSize );

// IDirectMusicObject 
	STDMETHODIMP GetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP SetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc);

    HRESULT GetObjectInPath( DWORD dwPChannel,REFGUID guidObject,
                    DWORD dwIndex,REFGUID iidInterface, void ** ppObject);
    HRESULT Load(CRiffParser *pParser);
protected:
	HRESULT BuildToolList(CRiffParser *pParser);
	HRESULT LoadTool(CRiffParser *pParser);
	HRESULT CreateTool(DMUS_IO_TOOL_HEADER ioDMToolHdr, IStream *pStream, DWORD *pdwPChannels);
	HRESULT STDMETHODCALLTYPE Shutdown();
    HRESULT InsertTool(IDirectMusicTool *pTool,DWORD *pdwPChannels,
                DWORD cPChannels,LONG lIndex, GUID *pguidClassID);
    inline BOOL CheckType( DWORD dwType, CToolRef* pToolRef );
protected:
	CRITICAL_SECTION    m_CrSec;
    CMemTrack           m_MemTrack;         // Used for debugging memory leaks.
	long		        m_cRef;
    CInfo               m_Info;
public:
    DWORD               m_dwLoadID;         // Identifier, used when loaded as part of a song.
};

class CGraphList : public AList
{
public:
    void Clear();
    void AddHead(CGraph* pGraph) { AList::AddHead((AListItem*)pGraph);}
    void Insert(CGraph* pGraph);
    CGraph* GetHead(){return (CGraph*)AList::GetHead();}
    CGraph* GetItem(LONG lIndex){return (CGraph*)AList::GetItem(lIndex);}
    CGraph* RemoveHead() {return (CGraph *) AList::RemoveHead();}
    void Remove(CGraph* pGraph){AList::Remove((AListItem*)pGraph);}
    void AddTail(CGraph* pGraph){AList::AddTail((AListItem*)pGraph);}
    CGraph* GetTail(){ return (CGraph*)AList::GetTail();}
};

#endif //__DMGRAPH_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\audpath.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// audpath.cpp : Implementation of CAudioPath

#include "pchime.h"


CBufferNode::CBufferNode()

{
    m_lActivateCount = 0;
    m_cRef = 1;
    m_pBuffer = NULL;
    m_pManager = NULL;
    m_dwMixBin = 0;
#ifdef XBOX
    m_MixBinsHeader.bControllers[0] = 0;
#endif
}

CBufferNode::~CBufferNode()

{
    FinalDeactivate();
    if (m_pManager)
    {
        m_pManager->Remove(this);
    }
}

ULONG CBufferNode::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG CBufferNode::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

HRESULT CBufferNode::Activate(BOOL fActivate)

{
    HRESULT hr = S_OK;
    if (m_pBuffer)
    {
        if (fActivate)
        {
            if (!m_lActivateCount)
            {
#ifndef XBOX
                // Don't bother starting if the primary buffer.
                if (SUCCEEDED(hr) && !(m_BufferHeader.dwFlags & DMUS_BUFFERF_PRIMARY))
                {
                    TraceI(2,"Play buffer %lx\n",m_pBuffer);
                    hr = m_pBuffer->Play(0,0,DSBPLAY_LOOPING);
#ifdef DBG
                    if (FAILED(hr))
                    {
                        Trace(1,"Error: Activate on audiopath failed because buffer failed Play command.\n");
                    }
#endif
                }
#endif
            }
            if (hr == S_OK)
            {
                m_lActivateCount++;
            }
            TraceI(3,"Incrementing %lx to %ld\n",m_pBuffer,m_lActivateCount);
        }
        else
        {
            if (m_lActivateCount > 0)
            {
                m_lActivateCount--;
                if (!m_lActivateCount)
                {
#ifndef XBOX
                    // Don't bother stopping the primary buffer.
                    if (!(m_BufferHeader.dwFlags & DMUS_BUFFERF_PRIMARY))
                    {
                        TraceI(2,"Stop buffer %lx\n",m_pBuffer);
                        hr = m_pBuffer->Stop();
                    }
#endif
                }
                TraceI(3,"Decrementing %lx to %ld\n",m_pBuffer,m_lActivateCount);
                if (hr != S_OK)
                {
                    m_lActivateCount++;
                }
            }
        }
    }
    return hr;
}


void CBufferNode::FinalDeactivate()

{
    if (m_lActivateCount)
    {
        Activate(FALSE);
    }
    if (m_pBuffer)
    {
        m_pBuffer->Release();
        m_pBuffer = NULL;
    }
}

CBufferManager::CBufferManager() 
{ 
#ifdef DXAPI
    m_pFirstBuffer = NULL;
    m_pSinkConnect = NULL;
    m_pSynthSink = NULL;
#endif
    m_pPerf = NULL; 
} 

CBufferManager::~CBufferManager() 
{     
    Clear();
#ifdef DXAPI
    if (m_pSinkConnect)
    {
        m_pSinkConnect->Release();
    }
    if (m_pSynthSink)
    {
        m_pSynthSink->Release();
    }
#endif
}

HRESULT CBufferManager::Init(CPerformance *pPerf, DMUS_AUDIOPARAMS *pAudioParams) 

{ 
    m_pPerf = pPerf; 
    m_AudioParams = *pAudioParams;
#ifdef DXAPI
    HRESULT hr = S_OK;
    CBufferNode *pNode = new CBufferNode;
    if (pNode)
    {
        pNode->m_BufferHeader.guidBufferID = GUID_Buffer_Primary;
        pNode->m_BufferHeader.dwFlags = DMUS_BUFFERF_SHARED | DMUS_BUFFERF_DEFINED | DMUS_BUFFERF_PRIMARY;
        pNode->m_pManager = this;
        AddHead(pNode);
        // Create the primary buffer. This will be used for requests to access the listener.
        DSBUFFERDESC dsbdesc; 
        memset(&dsbdesc, 0, sizeof(dsbdesc));
        dsbdesc.dwSize = sizeof(dsbdesc); 
        dsbdesc.dwFlags = DSBCAPS_PRIMARYBUFFER | DSBCAPS_CTRL3D; 

        // create primary buffer
        if (SUCCEEDED(hr = pPerf->m_pDirectSound->CreateSoundBuffer(&dsbdesc, &pNode->m_pBuffer, NULL)))
        {
            WAVEFORMATEX wfPrimary; 
            memset(&wfPrimary, 0, sizeof(wfPrimary)); 

            if (SUCCEEDED(hr = pNode->m_pBuffer->GetFormat(&wfPrimary, sizeof(wfPrimary), NULL)))
            {
                assert(wfPrimary.wFormatTag == WAVE_FORMAT_PCM);

                BOOL fUpgrade = FALSE;
                if (wfPrimary.nSamplesPerSec < m_AudioParams.dwSampleRate)
                {
                    wfPrimary.nSamplesPerSec = m_AudioParams.dwSampleRate;
                    fUpgrade = TRUE;
                }
                if (wfPrimary.wBitsPerSample < 16)
                {
                    wfPrimary.wBitsPerSample = 16;
                    fUpgrade = TRUE;
                }

                if (fUpgrade)
                {
                    wfPrimary.nBlockAlign = wfPrimary.nChannels * (wfPrimary.wBitsPerSample / 8);
                    wfPrimary.nAvgBytesPerSec = wfPrimary.nSamplesPerSec * wfPrimary.nBlockAlign;

                    // the existing format is of lesser quality than we desire, so let's upgrade it
                    if (FAILED(hr = pNode->m_pBuffer->SetFormat( &wfPrimary )))
                    {
                        if (hr == DSERR_PRIOLEVELNEEDED)
                        {
                            // okay, so maybe the app doen't want us changing primary buffer
                            Trace(0, "SynthSink - SetFormat on primary buffer failed, lacking priority\n");
                        }
                        else
                        {
                            Trace(0, "SynthSink - Activation failed, couldn't set primary buffer format\n");
                        }
                    }
                }
            }
        }
    }
    return hr;
#else
    return S_OK;
#endif

}

#ifdef DXAPI
HRESULT CBufferManager::InitSink(/*WAVEFORMATEX *pSinkFormat*/)

{
    HRESULT hr = S_OK;
    // Only init the sink if it's needed. If the audiopaths will be using buffers,
    // we need the sink. If not, bypass setting it up.
    if (!m_pSinkConnect && (m_pPerf->m_AudioParams.dwFeatures & DMUS_AUDIOF_BUFFERS))
    {
        static WAVEFORMATEX sDefaultFormat = { WAVE_FORMAT_PCM,1,SAMPLERATE,SAMPLERATE*2,2,16,0 };
        sDefaultFormat.nSamplesPerSec = m_AudioParams.dwSampleRate;
        sDefaultFormat.nAvgBytesPerSec = m_AudioParams.dwSampleRate * 2;
        sDefaultFormat.cbSize = 0;
        sDefaultFormat.nBlockAlign = 2;
        sDefaultFormat.nChannels = 1;
        sDefaultFormat.wBitsPerSample = 16;
        sDefaultFormat.wFormatTag = WAVE_FORMAT_PCM;

//#ifdef DXAPI
        IDirectSoundPrivate* pDSPrivate;
        hr = m_pPerf->m_pDirectSound->QueryInterface(IID_IDirectSoundPrivate, (void**)&pDSPrivate);
        if (SUCCEEDED(hr))
        {
            hr = pDSPrivate->AllocSink(&sDefaultFormat, &m_pSinkConnect);
            pDSPrivate->Release();
        }
        if (SUCCEEDED(hr))
        {
            IReferenceClock *pClock = NULL; 
            hr = m_pPerf->m_pDirectMusic->GetMasterClock(NULL, &pClock);
            if (SUCCEEDED(hr))
            {
                hr = m_pSinkConnect->SetMasterClock(pClock);
                pClock->Release();
            }
        }
/*#else
        CAudioSink *pSink = new CAudioSink(&sDefaultFormat);
        if (pSink)
        {
            hr = S_OK;
            pSink->QueryInterface(IID_IDirectSoundConnect,(void **) &m_pSinkConnect);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
        // Note that for the non-DX implementation, we always get the master clock from the
        // sink and hand it back to the performance. This is the exact opposite of the 
        // DX implementation.
        if (SUCCEEDED(hr))
        {
            IReferenceClock *pClock = pSink->GetMasterClock();
            hr = m_pPerf->m_pDirectMusic->SetExternalMasterClock(pClock);
        }
#endif*/
        if (SUCCEEDED(hr))
        {
            hr = m_pSinkConnect->QueryInterface(IID_IDirectSoundSynthSink,(void **) &m_pSynthSink);
            if (SUCCEEDED(hr))
            {
                hr = m_pSynthSink->Activate(TRUE);
            }
        }
//#ifdef DXAPI
        if (SUCCEEDED(hr))
        {
            // Create a dummy buffer that gets activated at the start and stays active until
            // the sink closes down. This is an unfortunate patch to the "clock-hopping" bug.
            // Once we come up with a better solution for providing timing from the sink, this
            // can go away.
            CBufferConfig Config(BUFFER_MONO);
            hr = CreateBuffer(&Config,&m_pFirstBuffer);
            if (SUCCEEDED(hr))
            {
                hr = m_pFirstBuffer->Activate(TRUE);
            }
        }
//#endif
    }
    return hr;
} 
#endif

void CBufferManager::FinalDeactivate()
{
#ifdef DXAPI
    // Kill dummy buffer.
    if (m_pFirstBuffer)
    {
        m_pFirstBuffer->Activate(FALSE);
        delete m_pFirstBuffer;
        m_pFirstBuffer = NULL;
    }
#endif
    CBufferNode *pNode = GetHead();
    for (;pNode;pNode = pNode->GetNext())
    {
        pNode->FinalDeactivate();
    }
#ifdef DXAPI
    if (m_pSynthSink)
    {
        m_pSynthSink->Activate(FALSE);
        m_pSynthSink->Release();
        m_pSynthSink = NULL;
    }
    if (m_pSinkConnect)
    {
        m_pSinkConnect->SetMasterClock(NULL);
        m_pSinkConnect->Release();
        m_pSinkConnect = NULL;
    }
#endif
}

void CBufferManager::Clear()
{
    CBufferNode *pNode;
    FinalDeactivate();
    while (pNode = GetHead())
    {
        delete pNode;
    }
}

CBufferNode *CBufferManager::GetBufferNode(REFGUID guidBufferID)

{
    CBufferNode *pNode = GetHead();
    for (;pNode;pNode = pNode->GetNext())
    {
        if (pNode->m_BufferHeader.guidBufferID == guidBufferID)
        {
            pNode->AddRef();
            break;
        }
    }
    return pNode;
}


HRESULT CBufferManager::CreateBuffer(CBufferConfig *pConfig, CBufferConfig ** ppNew)

{
    HRESULT hr = S_OK;
    if (m_AudioParams.dwFeatures & DMUS_AUDIOF_BUFFERS)
    {
//        ASSERT(m_pSinkConnect);
        CBufferConfig *pNew = new CBufferConfig(pConfig->m_dwStandardBufferID);
        if (pNew)
        {
            *ppNew = pNew;
            pNew->m_BufferHeader = pConfig->m_BufferHeader;
            if (pConfig->m_BufferHeader.dwFlags & DMUS_BUFFERF_SHARED)
            {
                // Check to see if there already is a buffer in the list with this GUID.
                CBufferNode *pNode = GetHead();
                for (;pNode;pNode = pNode->GetNext())
                {
                    if (pNode->m_BufferHeader.dwFlags & DMUS_BUFFERF_SHARED)
                    {
                        if (pNode->m_BufferHeader.guidBufferID == pConfig->m_BufferHeader.guidBufferID)
                        {
                            pNew->m_pBufferNode = pNode;
                            pNode->AddRef();
                            TraceI(2,"Found shared Buffer %lx\n",pNode->m_pBuffer);
                            return S_OK;
                        }
                    }
                }
            }
            // Either the buffer does not already exist, or it is not to be shared, so
            // create a new buffer node and requested buffer.
            CBufferNode *pNode = new CBufferNode;
            if (pNode)
            {
                pNode->m_BufferHeader = pConfig->m_BufferHeader;
#ifdef XBOX
                pNode->m_MixBinsHeader = pConfig->m_MixBinsHeader;
#endif
#ifndef XBOX
                // Predefined buffer type?
                if (pConfig->m_BufferHeader.dwFlags & DMUS_BUFFERF_DEFINED)
                {
                    // Must be a standard type. Create by hand.
                    CBufferNode *pSendNode = NULL;
                    DSBUFFERDESC BufferDesc;
                    WAVEFORMATEX WaveFormat;
                    DWORD dwFunctionIDs[2];
                    CLSID clsidDMO;
                    BOOL fDMO = FALSE;
                    DWORD dwNumFunctionIDs;
                    memset(&BufferDesc, 0, sizeof(BufferDesc));
                    BufferDesc.dwSize  = sizeof(BufferDesc);
                    BufferDesc.lpwfxFormat = &WaveFormat;
                    BufferDesc.dwBufferBytes = 0;
                    BufferDesc.dwFlags = 0;
                    memset(&WaveFormat,0,sizeof(WaveFormat));
                    WaveFormat.nChannels = 2;
                    switch (pConfig->m_dwStandardBufferID)
                    {
                    case BUFFER_REVERB :
                    case BUFFER_CHORUS :
                        dwFunctionIDs[0] = DSBUSID_REVERB_SEND;
                        dwNumFunctionIDs = 1;
                        WaveFormat.nChannels = 2;
                        BufferDesc.dwFlags = DSBCAPS_GLOBALFOCUS | DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLPAN | DSBCAPS_LOCDEFER;
                        clsidDMO = GUID_DSFX_WAVES_REVERB;
                        fDMO = TRUE;
                        break;
                    case BUFFER_ENVREVERB :
                        dwNumFunctionIDs = 0;
                        WaveFormat.nChannels = 2;
                        BufferDesc.dwFlags = DSBCAPS_MIXIN | DSBCAPS_GLOBALFOCUS | DSBCAPS_CTRLPAN | DSBCAPS_CTRLVOLUME;
                        clsidDMO = GUID_DSFX_STANDARD_I3DL2REVERB;
                        fDMO = TRUE;
                        if (!(m_AudioParams.dwFeatures & DMUS_AUDIOF_BUFFERS))
                        {
                            hr = DMUS_E_AUDIOPATH_NOBUFFER;
                            Trace(1,"Audiopath Creation error: Requested Environmental reverb buffer when DMUS_AUDIOF_ENVIRON not enabled via InitAudio.\n"); 
                        }
                        break;
                        // Following removed for DX8, should be reintroduced for Whistler and DX8.1...
                    case BUFFER_3D :
                        clsidDMO = GUID_DSFX_STANDARD_I3DL2SOURCE;
                        fDMO = TRUE;
                        pSendNode = GetBufferNode(GUID_Buffer_EnvReverb);
                        if (!pSendNode)
                        {
                            Trace(1,"Error: Failed creating 3D audiopath because the environmental reverb audiopath has not been created.\n");
                            hr = DMUS_E_AUDIOPATH_NOGLOBALFXBUFFER;
                            break;
                        }
                    case BUFFER_3D_DRY :
                        dwFunctionIDs[0] = DSBUSID_DYNAMIC_0;
                        dwNumFunctionIDs = 1;
                        WaveFormat.nChannels = 1;
                        BufferDesc.dwFlags = DSBCAPS_GLOBALFOCUS | DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLFREQUENCY |
                            DSBCAPS_CTRL3D | DSBCAPS_MUTE3DATMAXDISTANCE | DSBCAPS_LOCDEFER;
                        BufferDesc.guid3DAlgorithm = DS3DALG_NO_VIRTUALIZATION;
                        break;
                    case BUFFER_MONO :
                        dwFunctionIDs[0] = DSBUSID_LEFT;
                        dwNumFunctionIDs = 1;
                        WaveFormat.nChannels = 1;
                        BufferDesc.dwFlags = DSBCAPS_GLOBALFOCUS | DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLFREQUENCY | DSBCAPS_CTRLPAN | DSBCAPS_LOCDEFER;
                        break;
                    case BUFFER_STEREO :
                        BufferDesc.dwFlags = DSBCAPS_CTRLFREQUENCY;
                    case BUFFER_MUSIC :
                        dwFunctionIDs[0] = DSBUSID_LEFT;
                        dwFunctionIDs[1] = DSBUSID_RIGHT;
                        dwNumFunctionIDs = 2;
                        WaveFormat.nChannels = 2;
                        BufferDesc.dwFlags |= DSBCAPS_GLOBALFOCUS | DSBCAPS_CTRLPAN | DSBCAPS_CTRLVOLUME | DSBCAPS_LOCDEFER;
                        break;
                    default:
                        hr = E_INVALIDARG;
                    }
                    if (SUCCEEDED(hr))
                    {
                        WaveFormat.nBlockAlign = WaveFormat.nChannels * 2;
                        WaveFormat.nSamplesPerSec = m_AudioParams.dwSampleRate;
                        WaveFormat.nAvgBytesPerSec = WaveFormat.nChannels * WaveFormat.nSamplesPerSec * 2;
                        WaveFormat.wBitsPerSample = 16;
                        WaveFormat.wFormatTag = WAVE_FORMAT_PCM;
                        // Ensure that the mixin flag and number of bus ids are in sync (you can't combine mixin with buses.)
                        if ((pConfig->m_BufferHeader.dwFlags & DMUS_BUFFERF_MIXIN) || (dwNumFunctionIDs == 0))
                        {
                            dwNumFunctionIDs = 0;
                            BufferDesc.dwFlags |= DSBCAPS_MIXIN;
                            pConfig->m_BufferHeader.dwFlags |= DMUS_BUFFERF_MIXIN;
                            BufferDesc.dwFlags &= ~DSBCAPS_LOCDEFER;
                        }
                        hr = m_pSinkConnect->CreateSoundBuffer(&BufferDesc, &dwFunctionIDs[0], dwNumFunctionIDs,
                                                               pConfig->m_BufferHeader.guidBufferID, &pNode->m_pBuffer);
#ifdef DBG
                        if (FAILED(hr))
                        {
                            if (pConfig->m_BufferHeader.dwFlags & DMUS_BUFFERF_MIXIN)
                            {
                                Trace(1,"Error: Failed creating global (MIXIN) buffer for standard path.\n");
                            }
                            else
                            {
                                Trace(1,"Error: Failed creating buffer for standard path.\n");
                            }
                        }
#endif
                    }
                    if (SUCCEEDED(hr))
                    {
                        if (fDMO)
                        {
                            IDirectSoundBuffer8 *pBuff8;
                            if (SUCCEEDED(pNode->m_pBuffer->QueryInterface(IID_IDirectSoundBuffer8,(void **)&pBuff8)))
                            {
                                DWORD dwResult;
                                DSEFFECTDESC FXDesc;
                                FXDesc.dwSize = sizeof(DSEFFECTDESC);
                                FXDesc.dwFlags = 0;
                                FXDesc.guidDSFXClass = clsidDMO;
                                FXDesc.dwReserved1 = 0;
                                FXDesc.dwReserved2 = 0;
                                if (pSendNode)
                                {
                                    FXDesc.dwReserved1 = DWORD_PTR(pSendNode->GetBuffer());
                                }
                                hr = pBuff8->SetFX(1, &FXDesc, &dwResult);
                                if (FXDesc.dwReserved1)
                                {
                                    ((IDirectSoundBuffer*)FXDesc.dwReserved1)->Release();
                                }
                                pBuff8->Release();
                            }
                        }
                    }
                    if (pSendNode)
                    {
                        pSendNode->Release();
                    }
                }
                else
                {
                    pConfig->m_BufferHeader.dwFlags &= ~DMUS_BUFFERF_MIXIN;
                    hr = m_pSinkConnect->CreateSoundBufferFromConfig(pConfig->m_pBufferConfig,&pNode->m_pBuffer);
                    if (SUCCEEDED(hr))
                    {
                        // We need to know if this is a mixin buffer so we can identify it later.
                        DWORD dwBusIDs[32];
                        DWORD dwFuncIDs[32];
                        DWORD dwCount = 32;
                        dwFuncIDs[0] = 0;
                        if (SUCCEEDED(m_pSinkConnect->GetSoundBufferBusIDs((CBuffer *)pNode->m_pBuffer,dwBusIDs,dwFuncIDs,&dwCount)))
                        {
                            if (dwFuncIDs[0] == 0xFFFFFFFF)
                            {
                                pConfig->m_BufferHeader.dwFlags |= DMUS_BUFFERF_MIXIN;
                            }
                        }
                    }   
                    else
                    {
                        Trace(1,"Error: Failed creation of buffer defined in audio path configuration file.\n");
                    }
                }
#else   // XBOX
                // Predefined buffer type?
                if (pConfig->m_BufferHeader.dwFlags & DMUS_BUFFERF_DEFINED)
                {
                    // Must be a standard type. Create by hand.
                    DWORD dwMixBin = 0;
                    DSBUFFERDESC BufferDesc;
                    BufferDesc.lpwfxFormat = NULL;
                    BufferDesc.dwSize = sizeof(BufferDesc);
                    BufferDesc.dwBufferBytes = 0;
                    BufferDesc.dwInputMixBin = 0;
                    BufferDesc.dwFlags = DSBCAPS_CTRLVOLUME | DSBCAPS_MIXIN;

                    switch (pConfig->m_dwStandardBufferID)
                    {
                    case BUFFER_REVERB :
                        dwMixBin = (1 << DSMIXBIN_FXSEND_0);
                        break;
                    case BUFFER_CHORUS :
                        dwMixBin = (1 << DSMIXBIN_FXSEND_1);
                        break;
//                    case BUFFER_ENVREVERB :
//                        break;      // Not supported.
                    case BUFFER_3D :
                    case BUFFER_3D_DRY :
                        BufferDesc.dwFlags = DSBCAPS_CTRLVOLUME | DSBCAPS_CTRL3D | DSBCAPS_MIXIN;
                        break;
                    case BUFFER_MONO :
//                        dwBufferMixBin = DSMIXBIN_FRONT_LEFT | DSMIXBIN_FRONT_RIGHT | DSMIXBIN_FRONT_CENTER | DSMIXBIN_BACK_LEFT | DSMIXBIN_BACK_RIGHT | DSMIXBIN_LOW_FREQUENCY;
                        break;
                    case BUFFER_STEREO :
//                        dwBufferMixBin = DSMIXBIN_FRONT_LEFT | DSMIXBIN_FRONT_RIGHT;
                        break;
                    case BUFFER_MUSIC :
                        dwMixBin = (1 << DSMIXBIN_FRONT_LEFT) | (1 << DSMIXBIN_FRONT_RIGHT);
                        break;
                    case BUFFER_MIXBINS :
                        dwMixBin = pConfig->m_MixBinsHeader.dwMixBins;
                        break;
                    default:
                        hr = E_INVALIDARG;
                    }
                    if (SUCCEEDED(hr))
                    {
                        if (!dwMixBin)
                        {
                             //Right before CreateSoundBuffer, we translate the DWORD into a CMixBins class which we then 
                             // cast to an LPCDSMIXBINS struct (very fast).
                             CMIXBINS MixBins;
                             MixBins.CreateFromMask(0);
                             BufferDesc.lpMixBins = MixBins.GetMixBins();                        
                             hr = m_pPerf->m_pDirectSound->CreateSoundBuffer(&BufferDesc,&pNode->m_pBuffer,NULL);
                        }
                        pNode->m_dwMixBin = dwMixBin;
                    }
                }
                else
                {
                    pConfig->m_BufferHeader.dwFlags &= ~DMUS_BUFFERF_MIXIN;
//                    hr = m_pSinkConnect->CreateSoundBufferFromConfig(pConfig->m_pBufferConfig,&pNode->m_pBuffer);
                }
#endif  // XBOX

                if (SUCCEEDED(hr))
                {
                    TraceI(2,"Created Buffer %lx\n",pNode->m_pBuffer);
                    pNew->m_pBufferNode = pNode;
                    pNode->m_pManager = this;
                    AddHead(pNode);
                }
                else
                {
                    delete pNode;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        if (FAILED(hr) && pNew)
        {
            delete pNew;
            *ppNew = NULL;
        }
    }
    else
    {
        hr = DMUS_E_AUDIOPATH_NOBUFFER;
        Trace(0,"Audiopath Creation error: Requested buffer when DMUS_AUDIOF_BUFFERS not enabled via InitAudio.\n"); 
    }
    return hr;
}

CBufferConnect::CBufferConnect()

{
    m_ppBufferNodes = NULL;
    m_pguidBufferIDs = NULL;
    m_ConnectHeader.dwBufferCount = 0;
}

HRESULT CBufferConnect::Load(CRiffParser *pParser)

{
    HRESULT hr = pParser->Read(&m_ConnectHeader, sizeof(DMUS_IO_PCHANNELTOBUFFER_HEADER));
    if (SUCCEEDED(hr))
    {
        DWORD dwBufferCount = m_ConnectHeader.dwBufferCount;
        m_pguidBufferIDs = new GUID[dwBufferCount];
        if (m_pguidBufferIDs )
        {
            hr = pParser->Read(m_pguidBufferIDs,sizeof(GUID)*dwBufferCount);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

CBufferConnect *CBufferConnect::CreateRunTimeVersion(CPortConfig *pParent)

{ 
    CBufferConnect *pCopy = new CBufferConnect;
    if (pCopy && m_pguidBufferIDs)
    {
        pCopy->m_ConnectHeader = m_ConnectHeader;
        pCopy->m_ppBufferNodes = new CBufferNode *[m_ConnectHeader.dwBufferCount];
        if (pCopy->m_ppBufferNodes)
        {
            for (DWORD dwIndex = 0; dwIndex < m_ConnectHeader.dwBufferCount; dwIndex++)
            {
                pCopy->m_ppBufferNodes[dwIndex] = pParent->GetBufferNode(m_pguidBufferIDs[dwIndex]);
            }
        }
        else
        {
            delete pCopy;
            pCopy = NULL;
        }
    }
    return pCopy;
}


CBufferConnect::~CBufferConnect()

{
    if (m_ppBufferNodes)
    {
        for (DWORD dwIndex = 0; dwIndex < m_ConnectHeader.dwBufferCount; dwIndex++)
        {
            if (m_ppBufferNodes[dwIndex]) m_ppBufferNodes[dwIndex]->Release();
        }
        delete [] m_ppBufferNodes;
    }
    if (m_pguidBufferIDs)
    {
        delete [] m_pguidBufferIDs;
    }
}

HRESULT CBufferConnectList::CreateRunTimeVersion(CBufferConnectList *pDestination, CPortConfig *pParent)

{
    CBufferConnect *pScan = GetHead();
    CBufferConnect *pCopy;
    for (;pScan;pScan = pScan->GetNext())
    {
        pCopy = pScan->CreateRunTimeVersion(pParent);
        if (pCopy)
        {
            pDestination->AddTail(pCopy);
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }
    return S_OK;
}

void CBufferConnectList::Clear()

{
    CBufferConnect *pBuffer;
    while (pBuffer = RemoveHead())
    {
        delete pBuffer;
    }
}

HRESULT CBufferConfig::Activate(BOOL fActivate)

{
    if (m_pBufferNode)
    {
        return m_pBufferNode->Activate(fActivate);
    }
    return S_OK;
}

CBufferConfig::CBufferConfig(DWORD dwType)

{
    m_pBufferNode = NULL;
    m_BufferHeader.guidBufferID = GUID_NULL;
    m_BufferHeader.dwFlags = DMUS_BUFFERF_DEFINED;
    m_dwStandardBufferID = dwType;
#ifdef XBOX
    m_MixBinsHeader.bControllers[0] = 0;
#endif
    switch (dwType)
    {
    case BUFFER_REVERB :
        m_BufferHeader.guidBufferID = GUID_Buffer_Reverb;
        m_BufferHeader.dwFlags = DMUS_BUFFERF_SHARED | DMUS_BUFFERF_DEFINED;
        break;
    case BUFFER_ENVREVERB :
        m_BufferHeader.guidBufferID = GUID_Buffer_EnvReverb;
        m_BufferHeader.dwFlags = DMUS_BUFFERF_SHARED | DMUS_BUFFERF_DEFINED | DMUS_BUFFERF_MIXIN;
        break;
    case BUFFER_3D_DRY :
        m_BufferHeader.guidBufferID = GUID_Buffer_3D_Dry;
        break;
    case BUFFER_MONO :
        m_BufferHeader.guidBufferID = GUID_Buffer_Mono;
        break;
    case BUFFER_STEREO :
        m_BufferHeader.guidBufferID = GUID_Buffer_Stereo;
        break;
    case BUFFER_MUSIC :
        m_BufferHeader.guidBufferID = GUID_Buffer_Stereo;
        m_BufferHeader.dwFlags = DMUS_BUFFERF_SHARED | DMUS_BUFFERF_DEFINED;
        break;
#ifndef DXAPI
    case BUFFER_3D :
        m_BufferHeader.guidBufferID = GUID_Buffer_3D;
        break;
    case BUFFER_CHORUS :
        m_BufferHeader.guidBufferID = GUID_Buffer_Chorus;
        m_BufferHeader.dwFlags = DMUS_BUFFERF_SHARED | DMUS_BUFFERF_DEFINED;
        break;
    case BUFFER_MIXBINS :
        m_BufferHeader.guidBufferID = GUID_Buffer_MixBins;
        m_BufferHeader.dwFlags = DMUS_BUFFERF_SHARED | DMUS_BUFFERF_DEFINED;
        break;
#endif
    default:
        m_BufferHeader.dwFlags = 0;
        break;
    }
    m_pBufferConfig = NULL;
}

CBufferConfig::~CBufferConfig()

{
    if (m_pBufferNode)
        m_pBufferNode->Release();
    if (m_pBufferConfig)
        m_pBufferConfig->Release();
}

void CBufferConfig::DecideType()

{
    if (m_BufferHeader.guidBufferID == GUID_Buffer_Reverb)
    {
        m_dwStandardBufferID = BUFFER_REVERB;
    }
    else if (m_BufferHeader.guidBufferID == GUID_Buffer_EnvReverb)
    {
        m_dwStandardBufferID = BUFFER_ENVREVERB;
    }
#ifndef DXAPI
    else if (m_BufferHeader.guidBufferID == GUID_Buffer_3D)
    {
        m_dwStandardBufferID = BUFFER_3D;
    }
    else if (m_BufferHeader.guidBufferID == GUID_Buffer_Chorus)
    {
        m_dwStandardBufferID = BUFFER_CHORUS;
    }
#endif
    else if (m_BufferHeader.guidBufferID == GUID_Buffer_3D_Dry)
    {
        m_dwStandardBufferID = BUFFER_3D_DRY;
    }
    else if (m_BufferHeader.guidBufferID == GUID_Buffer_Mono)
    {
        m_dwStandardBufferID = BUFFER_MONO;
    }
    else if (m_BufferHeader.guidBufferID == GUID_Buffer_Stereo)
    {
        m_dwStandardBufferID = BUFFER_STEREO;
    }
#ifdef XBOX
    else if (m_BufferHeader.guidBufferID == GUID_Buffer_MixBins)
    {
        m_dwStandardBufferID = BUFFER_MIXBINS;
    }
#endif
}



HRESULT CBufferConfig::Load(IStream *pStream)

{
#ifndef XBOX
    IPersistStream *pPersist;
    HRESULT hr = DirectMusicCreateInstance( CLSID_DirectSoundBufferConfig,
        NULL, IID_IPersistStream,
        (void**)&pPersist );
    if (SUCCEEDED(hr))
    {
        hr = pPersist->Load(pStream);
        if (SUCCEEDED(hr))
        {
            m_pBufferConfig = pPersist;
            IDirectMusicObject *pObject;
            hr = pPersist->QueryInterface(IID_IDirectMusicObject,(void **) &pObject);
            if (SUCCEEDED(hr))
            {
                DMUS_OBJECTDESC Desc;
                Desc.dwSize = sizeof(Desc);
                pObject->GetDescriptor(&Desc);
                if (Desc.dwValidData & DMUS_OBJ_OBJECT)
                {
                    m_BufferHeader.guidBufferID = Desc.guidObject;
                }
                else
                {
                    Trace(1,"Error: Unable to load Buffer Configuration in AudioPath Config - Missing buffer GUID in file.\n");
                    hr = E_FAIL;
                }
                pObject->Release();
            }
        }
        else
        {
            pPersist->Release();
        }
    }
    return hr;
#else // XBOX
    Trace(1,"Error: Attempt to load an effects configuration within an AudioPath. XBOX does not support these yet. File load will fail.\n");
	return E_FAIL;
#endif
}

void CBufferConfigList::Clear()

{
    CBufferConfig *pBuffer;
    while (pBuffer = RemoveHead())
    {
        delete pBuffer;
    }
}

CBufferNode * CBufferConfigList::GetBufferNode(REFGUID guidBufferID)

{
    CBufferNode *pBuff = NULL;
    CBufferConfig *pBuffer;
    for (pBuffer = GetHead();pBuffer;pBuffer = pBuffer->GetNext())
    {
        if (pBuffer->m_BufferHeader.guidBufferID == guidBufferID)
        {
            if (pBuffer->m_pBufferNode)
            {
                pBuffer->m_pBufferNode->AddRef();
                pBuff = pBuffer->m_pBufferNode;
            }
            break;
        }
    }
    return pBuff;
}

HRESULT CBufferConfigList::Activate(BOOL fActivate)

{
    HRESULT hr = S_OK;
    CBufferConfig *pBuffer;
    for (pBuffer = GetHead();pBuffer;pBuffer = pBuffer->GetNext())
    {
        hr = pBuffer->Activate(fActivate);
        if (FAILED(hr))
        {
            CBufferConfig *pUndo;
            for (pUndo = GetHead();pUndo && (pUndo != pBuffer);pUndo = pUndo->GetNext())
            {
                pUndo->Activate(!fActivate);
            }
            break;
        }
    }
    return hr;
}

HRESULT CBufferConfigList::CreateRunTimeVersion(CBufferConfigList *pCopy, CBufferManager *pManager)

/*  To create a runtime version, we scan through all bufferconfigs and, for each one, we call the
    buffer manager to create a new one, managed by CBufferNode. In the case where the buffer already exists, it just
    addrefs the CBufferNode and returns that. 
*/

{
    HRESULT hr = S_OK;
    CBufferConfig *pBuffer;
    for (pBuffer = GetHead();pBuffer;pBuffer = pBuffer->GetNext())
    {
        CBufferConfig *pNew = NULL;
        hr = pManager->CreateBuffer(pBuffer,&pNew);
        if (SUCCEEDED(hr))
        {
            pCopy->AddTail(pNew);
        }
        else
        {
            break;
        }
    }
    return hr;
}


CPortConfig::CPortConfig()

{ 
    m_fAlreadyHere = FALSE;
    m_pPort = NULL;
    m_dwPortID = 0;
    m_pParent = NULL;
    m_PortHeader.guidPort = GUID_Synth_Default;     // Default synth, as specified by DMUS_AUDPARAMS.
    m_PortHeader.dwFlags = DMUS_PORTCONFIGF_DRUMSON10;
    m_PortHeader.dwPChannelBase = 0;
    m_PortHeader.dwPChannelCount = 32;
    m_PortParams.dwChannelGroups = 2;
    m_PortParams.dwSize = sizeof(DMUS_PORTPARAMS8);
    m_PortParams.dwValidParams = DMUS_PORTPARAMS_CHANNELGROUPS | DMUS_PORTPARAMS_FEATURES;
    m_PortParams.dwFeatures = DMUS_PORT_FEATURE_AUDIOPATH | DMUS_PORT_FEATURE_STREAMING;
}

CPortConfig::~CPortConfig()

{
    if (m_pPort) m_pPort->Release();
    m_BufferConnectList.Clear();
    m_BufferConfigList.Clear();
}


HRESULT CPortConfig::Activate(BOOL fActivate)

{
    HRESULT hr = m_BufferConfigList.Activate(fActivate);
    if (SUCCEEDED(hr) && fActivate && m_pPort)
    {
        HRESULT hrTemp = m_pPort->Activate(TRUE);
        if (FAILED(hrTemp))
        {
            hr = hrTemp;
        }
    }
    return hr;
}

HRESULT CPortConfig::CreateRunTimeVersion(CPortConfig ** ppCopy, CAudioPath *pParent, CBufferManager *pManager)

{
    HRESULT hr = E_OUTOFMEMORY;
    CPortConfig *pCopy = new CPortConfig();
    if (pCopy)
    {
        pCopy->m_pParent = pParent;
        pCopy->m_PortHeader = m_PortHeader;
        pCopy->m_PortParams = m_PortParams;
        hr = m_BufferConfigList.CreateRunTimeVersion(&pCopy->m_BufferConfigList,pManager);
        if (SUCCEEDED(hr))
        {
            hr = m_BufferConnectList.CreateRunTimeVersion(&pCopy->m_BufferConnectList,pCopy);
        }
    }
    *ppCopy = pCopy;
    return hr;
}

CBufferNode * CPortConfig::GetBufferNode(REFGUID guidBuffer)

{
    CBufferNode *pBuff = NULL;
    pBuff = m_BufferConfigList.GetBufferNode(guidBuffer);
    if (!pBuff && !m_fAlreadyHere)
    {
        m_fAlreadyHere = TRUE;
        pBuff = m_pParent->GetBufferNode(guidBuffer);
        m_fAlreadyHere = FALSE;
    }
    return pBuff;
} 


HRESULT CPortConfig::Load(CRiffParser *pParser)
{
    RIFFIO ckNext;
    HRESULT hr = S_OK;
    DWORD dwLoadedBoth = 0;
    pParser->EnterList(&ckNext);
    while (pParser->NextChunk(&hr))
    {
        switch(ckNext.ckid)
        {
        case DMUS_FOURCC_PORTCONFIG_ITEM:
            hr = pParser->Read(&m_PortHeader, sizeof(DMUS_IO_PORTCONFIG_HEADER));
            dwLoadedBoth |= 1;
            break;
        case DMUS_FOURCC_PORTPARAMS_ITEM:
            hr = pParser->Read(&m_PortParams, sizeof(DMUS_PORTPARAMS8));
            dwLoadedBoth |= 2;
            break;
        case FOURCC_LIST:
        case FOURCC_RIFF:
            switch(ckNext.fccType)
            {
                RIFFIO ckChild;
                case DMUS_FOURCC_PCHANNELS_LIST:
                    pParser->EnterList(&ckChild);
                    while (pParser->NextChunk(&hr))
                    {
                        switch( ckChild.ckid )
                        {
                        case DMUS_FOURCC_PCHANNELS_ITEM:
                            {
                                CBufferConnect *pBufferConnect = new CBufferConnect;
                                if (pBufferConnect)
                                {
                                    hr = pBufferConnect->Load(pParser);
                                    if (SUCCEEDED(hr))
                                    {
                                        m_BufferConnectList.AddTail(pBufferConnect);
                                    }
                                }
                                else
                                {
                                    hr = E_OUTOFMEMORY;
                                }
                            }
                            break;
                        }
                    }
                    pParser->LeaveList();
                    break;
                case DMUS_FOURCC_DSBUFFER_LIST:
                    {
                        CBufferConfig *pSource = new CBufferConfig(0);
                        if (pSource)
                        {
                            pParser->EnterList(&ckChild);
                            while (pParser->NextChunk(&hr))
                            {
                                switch( ckChild.ckid )
                                {
                                case DMUS_FOURCC_DSBUFFATTR_ITEM:
                                    hr = pParser->Read(&pSource->m_BufferHeader, 
                                        sizeof(DMUS_IO_BUFFER_ATTRIBUTES_HEADER));
                                    pSource->DecideType();
                                    break;
                                case DMUS_FOURCC_MIXBINS_ITEM:
                                    hr = pParser->Read(&pSource->m_MixBinsHeader, 
                                        sizeof(DMUS_IO_BUFFER_MIXBINS_HEADER));
                                    break;
                                case FOURCC_LIST:
                                case FOURCC_RIFF:
                                    if ( ckChild.fccType == DMUS_FOURCC_DSBC_FORM)
                                    {
                                        pParser->SeekBack();
                                        hr = pSource->Load(pParser->GetStream());
                                        pParser->SeekForward();
                                        if (FAILED(hr))
                                        {
                                            Trace(1,"AudioPath Configuration failed loading buffer\n");
                                        }
                                    }
                                }
                            }
                            pParser->LeaveList();
                            if (SUCCEEDED(hr))
                            {
                                m_BufferConfigList.AddTail(pSource);
                            }
                            else
                            {
                                delete pSource;
                            }
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }
                    break;
                case DMUS_FOURCC_DSBC_FORM:
                    {
                        CBufferConfig *pSource = new CBufferConfig(0);
                        if (pSource)
                        {
                            pParser->SeekBack();
                            hr = pSource->Load(pParser->GetStream());
                            pParser->SeekForward();
                            if (SUCCEEDED(hr))
                            {
                                m_BufferConfigList.AddTail(pSource);
                            }
                            else
                            {
                                Trace(1,"AudioPath Configuration failed loading buffer\n");
                                delete pSource;
                            }
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }
                    break;                   
                default:
                    break;
            }
            break;
        default:
            break;
        }
    }
    if (dwLoadedBoth != 3) 
    {
        hr = DMUS_E_CHUNKNOTFOUND;
        Trace(1,"Error: Failure loading port configuration chunk in Audio Path Configuration.\n");
    }

    // Make sure the channel groups in the portparams is large enough to handle the requested
    // channels in portheader.
    m_PortParams.dwChannelGroups = (m_PortHeader.dwPChannelCount + 15) / 16;
    m_PortParams.dwValidParams |= DMUS_PORTPARAMS_CHANNELGROUPS;
    pParser->LeaveList();

    return hr;
}

HRESULT CPortConfigList::Activate(BOOL fActivate)

{
    HRESULT hr = S_OK;
    CPortConfig *pPort;
    for (pPort = GetHead();pPort;pPort = pPort->GetNext())
    {
        hr = pPort->Activate(fActivate);
        if (FAILED(hr))
        {
            CPortConfig *pUndo;
            for (pUndo = GetHead();pUndo && (pUndo != pPort);pUndo = pUndo->GetNext())
            {
                pUndo->Activate(!fActivate);
            }
            break;
        }
    }
    return hr;
}

HRESULT CPortConfigList::CreateRunTimeVersion(CPortConfigList *pDestination,CAudioPath *pParent,CBufferManager *pManager)

{
    HRESULT hr = S_OK;
    CPortConfig *pScan = GetHead();
    CPortConfig *pCopy;
    for (;pScan;pScan = pScan->GetNext())
    {
        hr = pScan->CreateRunTimeVersion(&pCopy,pParent,pManager);
        if (pCopy)
        {
            pDestination->AddTail(pCopy);
        }
        else
        {
            break;
        }
    }
    return hr;
}

BOOL CPortConfigList::UsesPort(IDirectMusicPort *pPort)

{
    CPortConfig *pScan = GetHead();
    for (;pScan;pScan = pScan->GetNext())
    {
        if (pScan->m_pPort == pPort) return TRUE;
    } 
    return FALSE;
}


void CPortConfigList::Clear()

{
    CPortConfig *pPort;
    while (pPort = RemoveHead())
    {
        delete pPort;
    }
}

CAudioPath::CAudioPath() : m_MemTrack(DMTRACK_AUDIOPATH)

{
    TraceI(2,"Creating AudioPath %lx\n",this);
    INITIALIZE_CRITICAL_SECTION(&m_CriticalSection);
    m_fDeactivating = FALSE;
    m_rtLastVolChange = 0;
    m_rtLastPitchChange = 0;
    m_cRef = 0;
    m_fActive = FALSE;
    m_pdwVChannels = NULL;
    m_pdwPChannels = NULL;
    m_dwChannelCount = 0;
    m_pPerformance = NULL;
    m_pGraph = NULL;
    m_pConfig = NULL;
    m_pUnkDispatch = NULL;
}


CAudioPath::~CAudioPath()
{
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    if (m_pUnkDispatch)
    {
        m_pUnkDispatch->Release(); // free IDispatch implementation we may have borrowed
    }
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    Deactivate();
    DELETE_CRITICAL_SECTION(&m_CriticalSection);
}

STDMETHODIMP_(ULONG) CAudioPath::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CAudioPath::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CAudioPath::QueryInterface(
    const IID &iid,   
    void **ppv)       
{
    V_INAME(CAudioPath::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    *ppv = NULL;
    if (iid == IID_IUnknown || iid == IID_IDirectMusicAudioPath)
    {
        *ppv = static_cast<IDirectMusicAudioPath*>(this);
    } else
    if (iid == IID_CAudioPath)
    {
        *ppv = static_cast<CAudioPath*>(this);
    } else 
    if (iid == IID_IDirectMusicGraph)
    {
        *ppv = static_cast<IDirectMusicGraph*>(this);
    }
    else if (iid == IID_IDispatch)
    {
        // A helper scripting object implements IDispatch, which we expose via COM aggregation.
        if (!m_pUnkDispatch)
        {
            // Create the helper object
            DirectMusicCreateInstance(CLSID_AutDirectMusicAudioPath,
                static_cast<IDirectMusicAudioPath*>(this),
                IID_IUnknown,
                reinterpret_cast<void**>(&m_pUnkDispatch));
        }
        if (m_pUnkDispatch)
        {
            return m_pUnkDispatch->QueryInterface(IID_IDispatch, ppv);
        }
    }

    if (*ppv == NULL)
    {
        Trace(4,"Warning: Request to query unknown interface on AudioPath object\n");
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}

STDMETHODIMP CAudioPath::SetVolume(long lVolume,DWORD dwDuration) 

{
    V_INAME(AudioPath::SetVolume);
#if defined(DBG) || defined(DXAPI)
    if (lVolume < DSBVOLUME_MIN || lVolume > DSBVOLUME_MAX)
    {
        RIP_E_INVALIDARG(lVolume)
    }
#endif
    HRESULT hr = E_FAIL; // This should never happen, since the audiopath is created by the performance. 
    BYTE bMIDIVol = CParamMerger::VolumeToMidi(lVolume);

    DMUS_CURVE_PMSG *pCurve;
    // Clamp to an hour!
    if (dwDuration > (60 * 60 * 1000)) dwDuration = (60 * 60 * 1000);
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    ENTER_API_CRITICAL_SECTION;
    if (m_pPerformance)
    {
        hr = m_pPerformance->AllocPMsg(sizeof(DMUS_CURVE_PMSG),(DMUS_PMSG **)&pCurve);
        if (SUCCEEDED(hr))
        {
            REFERENCE_TIME rtTimeNow = 0;
            MUSIC_TIME mtNow;
            m_pPerformance->GetQueueTime(&rtTimeNow);
            // Get the equivalent music time so each copy of the curve doesn't need to recompute.
            m_pPerformance->ReferenceToMusicTime(rtTimeNow,&mtNow);
            // If this starts before a previous fade ended, invalidate it.
            if (m_rtLastVolChange > rtTimeNow)
            {
                m_pPerformance->FlushVirtualTrack(m_dwTrackID,mtNow,0);
            }
            if (m_rtLastVolChange < (rtTimeNow + (dwDuration * 10000)))
            {
                m_rtLastVolChange = rtTimeNow + (dwDuration * 10000);
            }
			pCurve->dwVirtualTrackID = m_dwTrackID;
            pCurve->rtTime = rtTimeNow;
            pCurve->mtTime = mtNow;
            pCurve->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_MUSICTIME | 
                DMUS_PMSGF_LOCKTOREFTIME | DMUS_PMSGF_DX8;
            pCurve->dwPChannel = DMUS_PCHANNEL_BROADCAST_AUDIOPATH;
            // dwVirtualTrackID: this isn't a track so leave as 0
            pCurve->dwType = DMUS_PMSGT_CURVE;
            pCurve->dwGroupID = -1; // this isn't a track so just say all groups

            // curve PMsg fields
            pCurve->mtDuration = dwDuration; // setting the DMUS_PMSGF_LOCKTOREFTIME is interpreted by the performance that mtDuration is milliseconds
            // mtResetDuration: no reset so leave as 0
            pCurve->nStartValue = 127; //m_bLastVol;
            // nStartValue: will be ignored
            pCurve->nEndValue = bMIDIVol;
            // nResetValue: no reset so leave as 0
            pCurve->bType = DMUS_CURVET_CCCURVE;
            /*if (dwDuration)
            {
                if (bMIDIVol > 87)
                {
                    // If fading up, make better for crossfade by fading in quickly at first.
                    pCurve->bCurveShape = DMUS_CURVES_LOG;
                }
                else if (bMIDIVol < 40)
                {
                    // If fading out, make better for crossfade by fading out slowly at first.
                    pCurve->bCurveShape = DMUS_CURVES_EXP;
                }
                else
                {
                    pCurve->bCurveShape = DMUS_CURVES_LINEAR;
                }
            }
            else
            {
                pCurve->bCurveShape = DMUS_CURVES_INSTANT;
            }*/
            pCurve->bCurveShape = dwDuration ? DMUS_CURVES_LINEAR : DMUS_CURVES_INSTANT;
            pCurve->bCCData = 7; // MIDI volume controller number
            pCurve->bFlags = DMUS_CURVE_START_FROM_CURRENT;
            // wParamType: leave as zero since this isn't a NRPN/RPN curve
            pCurve->wMergeIndex = 0xFFFE; //  special merge index so this won't get stepped on. is a big number OK? define a constant for this value?

            // send it

            StampPMsg((DMUS_PMSG *)pCurve);
            hr = m_pPerformance->SendPMsg((DMUS_PMSG*)pCurve);
        }
    }
    else
    {
        hr = DMUS_E_NOT_INIT;
    }
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    LEAVE_API_CRITICAL_SECTION;
    return hr;
}

STDMETHODIMP CAudioPath::SetPitch(long lPitch,DWORD dwDuration) 

{
    V_INAME(AudioPath::SetPitch);
    lPitch += 0x2000; // Bump up to center around 0x2000.
#if defined(DBG) || defined(DXAPI)
    if (lPitch < 0 || lPitch > 0x3FFF)
    {
        RIP_E_INVALIDARG(lPitch)
    }
#endif
    HRESULT hr = E_FAIL; // This should never happen, since the audiopath is created by the performance. 
    DMUS_CURVE_PMSG *pCurve;
    // Clamp to an hour!
    if (dwDuration > (60 * 60 * 1000)) dwDuration = (60 * 60 * 1000);
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    ENTER_API_CRITICAL_SECTION;
    if (m_pPerformance)
    {
        hr = m_pPerformance->AllocPMsg(sizeof(DMUS_CURVE_PMSG),(DMUS_PMSG **)&pCurve);
        if (SUCCEEDED(hr))
        {
            REFERENCE_TIME rtTimeNow = 0;
            m_pPerformance->GetQueueTime(&rtTimeNow);
            // If this starts before a previous fade ended, invalidate it.
            if (m_rtLastPitchChange > rtTimeNow)
            {
                MUSIC_TIME mtNow;
                m_pPerformance->ReferenceToMusicTime(rtTimeNow,&mtNow);
                m_pPerformance->FlushVirtualTrack(m_dwTrackID,mtNow,0);
            }
            if (m_rtLastPitchChange < (rtTimeNow + (dwDuration * 10000)))
            {
                m_rtLastPitchChange = rtTimeNow + (dwDuration * 10000);
            }
            pCurve->dwVirtualTrackID = m_dwTrackID;
            pCurve->rtTime = rtTimeNow;
            pCurve->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME | DMUS_PMSGF_DX8;
            pCurve->dwPChannel = DMUS_PCHANNEL_BROADCAST_AUDIOPATH;
            // dwVirtualTrackID: this isn't a track so leave as 0
            pCurve->dwType = DMUS_PMSGT_CURVE;
            pCurve->dwGroupID = -1; // this isn't a track so just say all groups

            // curve PMsg fields
            pCurve->mtDuration = dwDuration; // setting the DMUS_PMSGF_LOCKTOREFTIME is interpreted by the performance that mtDuration is milliseconds
            // mtResetDuration: no reset so leave as 0
            pCurve->nStartValue = 0;
            // nStartValue: will be ignored
            pCurve->nEndValue = (short) lPitch;
            // nResetValue: no reset so leave as 0
            pCurve->bType = DMUS_CURVET_PBCURVE;
            pCurve->bCurveShape = dwDuration ? DMUS_CURVES_LINEAR : DMUS_CURVES_INSTANT;
            // bCCData: Ignore, since this is pitch bend
            pCurve->bFlags = DMUS_CURVE_START_FROM_CURRENT;
            pCurve->wParamType = 0x2000;  // PB Range equivalent to pitch cents units.
            pCurve->wMergeIndex = 0xFFFE; //  special merge index so this won't get stepped on. is a big number OK? define a constant for this value?

            // send it

            StampPMsg((DMUS_PMSG *)pCurve);
            hr = m_pPerformance->SendPMsg((DMUS_PMSG*)pCurve);
        }
    }
    else
    {
        hr = DMUS_E_NOT_INIT;
    }
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    LEAVE_API_CRITICAL_SECTION;
    return hr;
}

STDMETHODIMP CAudioPath::GetObjectInPath( DWORD dwPChannel,DWORD dwStage,
                                          DWORD dwBuffer, REFGUID guidObject,
                                          DWORD dwIndex, REFGUID iidInterface, void ** ppObject)
{
    V_INAME(IDirectMusicAudioPath::GetObjectInPath);
    V_PTRPTR_WRITE(ppObject);
    *ppObject = NULL;
#ifdef XBOX
#ifdef DBG
    if (dwBuffer && ((dwStage < DMUS_PATH_BUFFER) || (dwStage >= DMUS_PATH_PRIMARY_BUFFER)))
    {
        Trace(0,"Invalid buffer or stage id passed to GetObjectInPath\n");
    }
#endif
#else
    if (dwBuffer && ((dwStage < DMUS_PATH_BUFFER) || (dwStage >= DMUS_PATH_PRIMARY_BUFFER)))
    {
        return DMUS_E_NOT_FOUND;
    }
#endif
    HRESULT hr = DMUS_E_NOT_FOUND;
    CPortConfig *pPortConfig;
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    ENTER_API_CRITICAL_SECTION;
    switch (dwStage)
    {
    case DMUS_PATH_AUDIOPATH:
        if ((dwIndex == 0) && (dwPChannel == 0))
        {
            hr = QueryInterface(iidInterface,ppObject);
        }
        break;
    case DMUS_PATH_AUDIOPATH_GRAPH:
        if ((dwIndex == 0) && (dwPChannel == 0))
        {
            if (!m_pGraph)
            {
                m_pGraph = new CGraph;
            }
            if (m_pGraph)
            {
                hr = m_pGraph->QueryInterface(iidInterface,ppObject);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        break;
    case DMUS_PATH_AUDIOPATH_TOOL:
        if (m_pGraph)
        {
            hr = m_pGraph->GetObjectInPath(dwPChannel,guidObject,dwIndex,iidInterface,ppObject);
        }
        break;
    case DMUS_PATH_PERFORMANCE:
        if (m_pPerformance && (dwIndex == 0) && (dwPChannel == 0))
        {
            hr = m_pPerformance->QueryInterface(iidInterface,ppObject);
        }
        break;
    case DMUS_PATH_PERFORMANCE_GRAPH:
        if (m_pPerformance && (dwIndex == 0) && (dwPChannel == 0))
        {
            IDirectMusicGraph *pGraph;
            if (SUCCEEDED(hr = m_pPerformance->GetGraphInternal(&pGraph)))
            {
                hr = pGraph->QueryInterface(iidInterface,ppObject);
                pGraph->Release();
            }
        }
        break;
    case DMUS_PATH_PERFORMANCE_TOOL:
        if (m_pPerformance)
        {
            IDirectMusicGraph *pGraph;
            if (SUCCEEDED(hr = m_pPerformance->GetGraphInternal(&pGraph)))
            {
                CGraph *pCGraph = (CGraph *) pGraph;
                // Convert from audiopath channel to performance channel.
                ConvertPChannel( dwPChannel,&dwPChannel);
                hr = pCGraph->GetObjectInPath(dwPChannel,guidObject,dwIndex,iidInterface,ppObject);
                pGraph->Release();
            }
        }
        break;
    case DMUS_PATH_PORT:
        pPortConfig = m_PortConfigList.GetHead();
        for (;pPortConfig;pPortConfig = pPortConfig->GetNext())
        {
            // First, see if this matches the port guid.
            if ((pPortConfig->m_PortHeader.guidPort == guidObject) || (guidObject == GUID_All_Objects))
            {
                // Then, see if we have a pchannel match.
                if ((dwPChannel == DMUS_PCHANNEL_ALL) ||
                    ((pPortConfig->m_PortHeader.dwPChannelBase <= dwPChannel) &&
                    ((pPortConfig->m_PortHeader.dwPChannelBase + pPortConfig->m_PortHeader.dwPChannelCount) > dwPChannel)))
                {
                    // If everything matches, there is always the chance that we have multiple instances of
                    // this in the list and we are actually looking at a second or third pointer to the same port.
                    // So, scan through the list again, making the exact same matches. If this port is found in
                    // an earlier instance, fail the match.
                    BOOL fSuccess = true;
                    CPortConfig *pScan = m_PortConfigList.GetHead();
                    for (;pScan;pScan = pScan->GetNext())
                    {
                        // First, see if this matches the port guid.
                        if ((pScan->m_PortHeader.guidPort == guidObject) || (guidObject == GUID_All_Objects))
                        {
                            // Then, see if we have a pchannel match.
                            if ((dwPChannel == DMUS_PCHANNEL_ALL) ||
                                ((pScan->m_PortHeader.dwPChannelBase <= dwPChannel) &&
                                ((pScan->m_PortHeader.dwPChannelBase + pScan->m_PortHeader.dwPChannelCount) > dwPChannel)))
                            {
                                // If this is the same as the outer loop, we have arrived. 
                                if (pScan == pPortConfig)
                                {
                                    break;
                                }
                                else
                                {
                                    // Else, if this points to the same port, we have failed.
                                    if (pScan->m_pPort == pPortConfig->m_pPort)
                                    {
                                        fSuccess = false;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    if (fSuccess)
                    {
                        if (dwIndex)
                        {
                            dwIndex--;
                        }
                        else 
                        {
                            IDirectMusicPort *pPort;
                            if (SUCCEEDED(m_pPerformance->GetPort(pPortConfig->m_dwPortID,&pPort)))
                            {
                                hr = pPort->QueryInterface(iidInterface,ppObject);
                                pPort->Release();
                            }
                            break;
                        }
                    }
                }
            }
        }
        break;
#ifdef DXAPI
    case DMUS_PATH_SINK:
        if (m_pPerformance && (dwIndex == 0) && (dwPChannel == 0) &&
            m_pPerformance->m_BufferManager.m_pSinkConnect)
        {
            hr = m_pPerformance->m_BufferManager.m_pSinkConnect->QueryInterface(iidInterface,ppObject);
        }
        break;
#endif
    case DMUS_PATH_BUFFER:
    case DMUS_PATH_BUFFER_DMO:
        {
            CBufferConnect *pConnect = NULL;
            BOOL fAllChannels = (dwPChannel == DMUS_PCHANNEL_ALL);
            pPortConfig = m_PortConfigList.GetHead();
            for (;pPortConfig && FAILED(hr);pPortConfig = pPortConfig->GetNext())
            {
                if (fAllChannels || ((pPortConfig->m_PortHeader.dwPChannelBase <= dwPChannel) &&
                    ((pPortConfig->m_PortHeader.dwPChannelCount + 
                    pPortConfig->m_PortHeader.dwPChannelBase) > dwPChannel)))
                {
                    pConnect = pPortConfig->m_BufferConnectList.GetHead();
                    for (;pConnect;)
                    {
                        if (fAllChannels || ((pConnect->m_ConnectHeader.dwPChannelBase <= dwPChannel) &&
                            ((pConnect->m_ConnectHeader.dwPChannelCount + 
                            pConnect->m_ConnectHeader.dwPChannelBase) > dwPChannel)))
                        {
                            // Found the buffer connect. Which buffer will be determined
                            // by dwBuffer. If dwBuffer is greater than the count of buffer,
                            // decrement and move on to the next pConnect.
                            if (pConnect->m_ConnectHeader.dwBufferCount > dwBuffer) 
                            {
                                if (pConnect->m_ppBufferNodes[dwBuffer])
                                {
                                    IDirectSoundBuffer *pBuffer = pConnect->m_ppBufferNodes[dwBuffer]->GetBuffer();
                                    if (pBuffer)
                                    {
                                        if (dwStage == DMUS_PATH_BUFFER)
                                        {
                                            if (dwIndex == 0)
                                            {
#ifdef XBOX
                                                hr = S_OK;
                                                *ppObject = pBuffer;
                                                pBuffer->AddRef();
#else
                                                hr = pBuffer->QueryInterface(iidInterface,ppObject);
#endif
                                            }
                                        }
                                        else
                                        {
                                            IDirectSoundBuffer8 *pBuffer8;
#ifndef XBOX
                                            hr = pBuffer->QueryInterface(IID_IDirectSoundBuffer8,(void **) &pBuffer8);
                                            if (SUCCEEDED(hr))
                                            {
                                                hr = pBuffer8->GetObjectInPath(guidObject,dwIndex,iidInterface,ppObject);
                                                pBuffer8->Release();
                                            }
#else // XBOX
											hr = E_FAIL; // TODO: What's the right thing to do here?
#endif // XBOX
                                        }
                                        pBuffer->Release();
                                    }
                                }
                                pConnect = NULL;
                            }
                            else
                            {
                                dwBuffer -= pConnect->m_ConnectHeader.dwBufferCount;
                            }
                        }
                        if (pConnect)
                        {
                            pConnect = pConnect->GetNext();
                        }
                    }
                }
            }
            
        }
        break;
    case DMUS_PATH_MIXIN_BUFFER :
    case DMUS_PATH_MIXIN_BUFFER_DMO :
        if (dwPChannel == 0) 
        {
            CBufferConfig *pConfig = m_BufferConfigList.GetHead();
            for (;pConfig; pConfig = pConfig->GetNext())
            {
                if (pConfig->m_BufferHeader.dwFlags & DMUS_BUFFERF_MIXIN)
                {
                    if (!dwBuffer)
                    {
                        IDirectSoundBuffer *pBuffer = pConfig->m_pBufferNode->GetBuffer();
                        if (pBuffer)
                        {
                            if (dwStage == DMUS_PATH_MIXIN_BUFFER)
                            {
                                if (dwIndex == 0)
                                {
#ifdef XBOX
                                    hr = pBuffer->QueryInterface(IID_IDirectSoundBuffer,ppObject);
#else
                                    hr = pBuffer->QueryInterface(iidInterface,ppObject);
#endif
                                }
                            }
                            else
                            {
#ifndef XBOX
                                IDirectSoundBuffer8 *pBuffer8;
                                hr = pBuffer->QueryInterface(IID_IDirectSoundBuffer8,(void **) &pBuffer8);
                                if (SUCCEEDED(hr))
                                {
                                    hr = pBuffer8->GetObjectInPath(guidObject,dwIndex,iidInterface,ppObject);
                                    pBuffer8->Release();
                                }
#else // XBOX
								hr = E_FAIL; // TODO: What's the right thing to do here?
#endif // XBOX
                            }
                            pBuffer->Release();
                        }
                        break;
                    }
                    dwBuffer--;
                }
            }
        }
        break;
#ifndef XBOX
    case DMUS_PATH_PRIMARY_BUFFER :
        if ((dwIndex == 0) && (dwPChannel == 0))
        {
            CBufferNode *pNode = m_pPerformance->m_BufferManager.GetBufferNode(GUID_Buffer_Primary);
            if (pNode)
            {
                IDirectSoundBuffer *pBuffer = pNode->GetBuffer();
                if (pBuffer)
                {
                    hr = pBuffer->QueryInterface(iidInterface,ppObject);
                    pBuffer->Release();
                }
                pNode->Release();
            }
        }
        break;
#endif
    default:
        hr = E_INVALIDARG;
        Trace(0,"Error: Audiopath does not support stage 0x%lx\n",dwStage);
    }
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    LEAVE_API_CRITICAL_SECTION;
#ifdef DBG
    if (hr == DMUS_E_NOT_FOUND)
    {
        Trace(3,"Warning: Requested AudioPath object not found\n");
    }
#endif
    return hr;
}

HRESULT STDMETHODCALLTYPE CAudioPath::Activate(BOOL fActivate)

{
    TraceI(2,"Audiopath %lx Activate: %ld\n",this,fActivate);
    if (fActivate == m_fActive)
    {
#ifdef DBG
        if (fActivate) Trace(2,"Warning: Attempt to activate already active audiopath.\n");
        else Trace(2,"Warning: Attempt to deactivate already inactive audiopath.\n");
#endif
        return S_FALSE;
    }
    ENTER_API_CRITICAL_SECTION;
    m_fActive = fActivate;
    if (!fActivate && !m_fDeactivating)
    {
        ENTER_CRITICAL_SECTION(&m_CriticalSection);
        CPerformance *pPerf = m_pPerformance;
        LEAVE_CRITICAL_SECTION(&m_CriticalSection);
        if (pPerf)
        {
            // Kill anything currently playing on the audiopath.
            pPerf->StopEx(static_cast<IDirectMusicAudioPath*>(this),0,0);
        }
    }
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    HRESULT hr = m_BufferConfigList.Activate(fActivate);
    if (SUCCEEDED(hr))
    {
        hr = m_PortConfigList.Activate(fActivate);
        if (FAILED(hr))
        {
            m_BufferConfigList.Activate(!fActivate);
        }
    }
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    if (FAILED(hr))
    {
        m_fActive = !fActivate;
    }
    LEAVE_API_CRITICAL_SECTION;
    return hr;
}

HRESULT STDMETHODCALLTYPE CAudioPath::ConvertPChannel( DWORD dwPChannelIn,DWORD *pdwPChannelOut)

{
    V_INAME(IDirectMusicAudioPath::ConvertPChannel);
    V_PTR_WRITE(pdwPChannelOut,DWORD);

    // If any special PMsg address (for example, broadcast), leave as is.
    if (dwPChannelIn >= DMUS_PCHANNEL_KILL_ME)
    {
        *pdwPChannelOut = dwPChannelIn;
        return S_OK;
    }
    DWORD dwScan = 0;
    for (;dwScan < m_dwChannelCount;dwScan++)
    {
        if (m_pdwVChannels[dwScan] == dwPChannelIn)
        {
            *pdwPChannelOut = m_pdwPChannels[dwScan];
            return S_OK;
        }
    }
    Trace(1,"Error: Audiopath failed request to convert out of range PChannel %ld\n",dwPChannelIn);
    return DMUS_E_NOT_FOUND;
}

HRESULT STDMETHODCALLTYPE CAudioPath::Shutdown()
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CAudioPath::InsertTool( 
    IDirectMusicTool *pTool,
    DWORD *pdwPChannels,
    DWORD cPChannels,
    LONG lIndex)
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CAudioPath::GetTool(
    DWORD dwIndex,
    IDirectMusicTool** ppTool)
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CAudioPath::RemoveTool(
    IDirectMusicTool* pTool)
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CAudioPath::StampPMsg( 
    /* [in */ DMUS_PMSG* pPMsg)
{
    V_INAME(IDirectMusicAudioPath::StampPMsg);
    V_BUFPTR_WRITE(pPMsg,sizeof(DMUS_PMSG));

    HRESULT hr = E_FAIL;
    
    if (!m_fActive)
    {
        // Only kill notes and wave messages, since they are the only PMsgs that make sound.
        if ((pPMsg->dwType == DMUS_PMSGT_NOTE) || (pPMsg->dwType == DMUS_PMSGT_WAVE))
        {
            pPMsg->dwPChannel = DMUS_PCHANNEL_KILL_ME;
            Trace(1,"Error: Attempting to play on an inactive AudioPath, PMsg being ignored.\n");
            return DMUS_E_AUDIOPATH_INACTIVE;
        }
    }
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    if (!m_pPerformance)
    {
        LEAVE_CRITICAL_SECTION(&m_CriticalSection);
        return DMUS_E_NOT_INIT;
    }
	ENTER_API_CRITICAL_SECTION;
    // First, check if the audio path has its own graph.
    if (m_pGraph)
    {
        // Could return DMUS_S_LAST_TOOL, indicating end of graph. 
        // If so, we'll treat that as a failure and drop on through to the next graph...
        if( S_OK == ( hr = m_pGraph->StampPMsg( pPMsg )))
        {
            if( pPMsg->pGraph != this ) // Make sure this is set to point to the segstate embedded graph so it will come here again.
            {
                if( pPMsg->pGraph )
                {
                    pPMsg->pGraph->Release();
                    pPMsg->pGraph = NULL;
                }
                pPMsg->pGraph = this;
                AddRef();
            }
        }
    }
    
    // If done with the graph, send to the performance. Also, check for the special case of 
    // DMUS_PCHANNEL_BROADCAST_AUDIOPATH. If so, duplicate the pMsg
    // and send all the copies with the appropriate pchannel values.
    // Otherwise, convert the vchannel to the matching pchannel (this is the
    // point where the pchannel mapping occurs.)
    if( FAILED(hr) || (hr == DMUS_S_LAST_TOOL))
    {
        if (pPMsg->dwPChannel == DMUS_PCHANNEL_BROADCAST_AUDIOPATH)
        {
            DWORD dwIndex;
            for (dwIndex = 1;dwIndex < m_dwChannelCount;dwIndex++)
            {
                DWORD dwNewChannel = m_pdwPChannels[dwIndex];
                // Don't broadcast any broadcast messages!
                // And, if this is a transpose on the drum channel, don't send it.
                if ((dwNewChannel < DMUS_PCHANNEL_BROADCAST_GROUPS) &&
                    ((pPMsg->dwType != DMUS_PMSGT_TRANSPOSE) || ((dwNewChannel & 0xF) != 9)))
                {
                    DMUS_PMSG *pNewMsg;
                    if (SUCCEEDED(m_pPerformance->ClonePMsg(pPMsg,&pNewMsg)))
                    {
                        pNewMsg->dwPChannel = dwNewChannel;
                        m_pPerformance->StampPMsg(pNewMsg);
                        m_pPerformance->SendPMsg(pNewMsg);
                    }
                }
            }
            // Now, set the pchannel for this one. First check that there are any
            // pchannels. If none, mark the PMsg to be deleted by the SendPMsg routine.
            // Also, mark it this way if the PMsg is a broadcast PMsg.
            pPMsg->dwPChannel = DMUS_PCHANNEL_KILL_ME;
            if (m_dwChannelCount)
            {
                if (m_pdwPChannels[0] < DMUS_PCHANNEL_BROADCAST_GROUPS)
                {
                    pPMsg->dwPChannel = m_pdwPChannels[0];
                }
            }
        }
        else
        {
            DWORD dwScan = 0;
            for (;dwScan < m_dwChannelCount;dwScan++)
            {
                if (m_pdwVChannels[dwScan] == pPMsg->dwPChannel)
                {
                    pPMsg->dwPChannel = m_pdwPChannels[dwScan];
                    break;
                }
            }
            // If a map was not found, kill the message. 
            // But, ignore for notifications, since they really don't care about pchannel.
            // And, ignore for performance broadcast PMsgs.
            if ((dwScan == m_dwChannelCount) && 
                (pPMsg->dwType != DMUS_PMSGT_NOTIFICATION) &&
                (pPMsg->dwPChannel < DMUS_PCHANNEL_BROADCAST_GROUPS))
            {
                pPMsg->dwPChannel = DMUS_PCHANNEL_KILL_ME;
            }
        }
        hr = m_pPerformance->StampPMsg(pPMsg);
    }
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
	LEAVE_API_CRITICAL_SECTION;
    return hr;
}

CGraph *CAudioPath::GetGraph()

{
    CGraph *pGraph;
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    // Return the graph, and AddRef if it exists.
    if (pGraph = m_pGraph)
    {
        m_pGraph->AddRef();
    }
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    return pGraph;
}

void CAudioPath::Deactivate()
{
    m_fDeactivating = TRUE;
    Activate(FALSE);
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    m_fActive = FALSE;
    m_PortConfigList.Clear();
    m_BufferConfigList.Clear();
    if (m_pGraph)
    {
        m_pGraph->Release();
        m_pGraph = NULL;
    }
    if (m_pConfig)
    {
        m_pConfig->Release();
        m_pConfig = NULL;
    }
    if (m_pPerformance)
    {
        if (m_pdwVChannels && m_pdwPChannels)
        {
            DWORD dwIndex;
            for (dwIndex = 0;dwIndex <m_dwChannelCount;dwIndex++)
            {
                m_pPerformance->ReleasePChannel(m_pdwPChannels[dwIndex]);
            }
            delete [] m_pdwVChannels;
            delete [] m_pdwPChannels;
        }
        m_pPerformance->m_AudioPathList.Remove(this);
        m_pPerformance->RemoveUnusedPorts();
        m_pPerformance->Release();
        m_pPerformance = NULL;
    }
    m_fDeactivating = FALSE;
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
}

void CAudioPath::SetGraph(CGraph *pGraph)

{
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    // Is this a change?
    if (!m_pGraph)
    {
        pGraph->Clone((IDirectMusicGraph **) &m_pGraph);
    }
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
}


CBufferNode * CAudioPath::GetBufferNode(REFGUID guidBuffer)

{
    CBufferNode *pBuff = NULL;
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    pBuff = m_BufferConfigList.GetBufferNode(guidBuffer);
    if (!pBuff)
    {
        CPortConfig *pConfig = m_PortConfigList.GetHead();
        for (;pConfig;pConfig = pConfig->GetNext())
        {
            pBuff = pConfig->GetBufferNode(guidBuffer);
            if (pBuff)
            {
                break;
            }
        }
    }
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    if (!pBuff)
    {
        pBuff = m_pPerformance->m_BufferManager.GetBufferNode(guidBuffer);
    }
    return pBuff;
}

extern long g_lNewTrackID; // Global track id source.

HRESULT CAudioPath::Init(IUnknown *pSourceConfig,CPerformance *pPerf)

{
    HRESULT hr = E_INVALIDARG;
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
	// Give the audiopath a uninque track id. This will be used to invalidate
	// broadcast PMsgs sent to the audiopath.
	DWORD dwTempID;
	InterlockedIncrement(&g_lNewTrackID);
	m_dwTrackID = g_lNewTrackID;
    m_pPerformance = pPerf;
    pPerf->m_AudioPathList.AddHead(this);
    pPerf->AddRef();
    if (pPerf && pSourceConfig)
    {
        if (SUCCEEDED(hr = pSourceConfig->QueryInterface(IID_CAudioPathConfig,(void **) &m_pConfig)))
        {
            if (m_pConfig->m_pGraph)
            {
                SetGraph(m_pConfig->m_pGraph);
            }
#ifdef DXAPI
            // The very first audio path has to create the sink.
            hr = pPerf->m_BufferManager.InitSink();
#endif          
            if (SUCCEEDED(hr))
            {
                // First, install any global buffers that are required.
                hr = m_pConfig->m_BufferConfigList.CreateRunTimeVersion(&m_BufferConfigList,&pPerf->m_BufferManager);
                if (SUCCEEDED(hr))
                {
                    // Then, install the ports and buffers.
                    hr = m_pConfig->m_PortConfigList.CreateRunTimeVersion(&m_PortConfigList,this,&pPerf->m_BufferManager);
                    if (SUCCEEDED(hr))
                    {
                        hr = ConnectToPorts(pPerf,pPerf->m_AudioParams.dwSampleRate);
                    }
                }
            }
        }
    }
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    return hr;
}

HRESULT CAudioPath::ConnectToPorts(CPerformance *pPerf,DWORD dwSampleRate)

/*  This must be called from within a critical section.
*/

{
    HRESULT hr = S_OK;
    // Scan through the list of portconfigs and hook them up with active ports
    // in the performance. If a port is not available, create the port.
    CPortConfig *pConfig = m_PortConfigList.GetHead();
    DWORD dwChannelCount = 0;   // Used to add up total PChannels needed.
    for (;pConfig && SUCCEEDED(hr);pConfig = pConfig->GetNext())
    {
        // Given the configuration, either find a port with a matching id, or create one.
#ifdef DXAPI
        hr = pPerf->GetPathPort(pConfig);
#endif
        dwChannelCount += pConfig->m_PortHeader.dwPChannelCount;
    }
    if (SUCCEEDED(hr))
    {
        // Now, allocate the VChannels needed for each portconfig.
        m_pdwVChannels = new DWORD[dwChannelCount];
        if (m_pdwVChannels)
        {
            m_pdwPChannels = new DWORD[dwChannelCount];
            if (!m_pdwPChannels)
            {
                delete [] m_pdwVChannels;
                m_pdwVChannels = NULL;
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    if (SUCCEEDED(hr))
    {
        // Scan through the port configs and allocate the pchannels, copying the assignments
        // into virtual channel assignment arrays.
        pConfig = m_PortConfigList.GetHead();
        DWORD dwIndex = 0;
        for (;pConfig;pConfig = pConfig->GetNext())
        {
            // If this port uses buffers, then connect them up. 
            if (((pConfig->m_PortParams.dwValidParams & DMUS_PORTPARAMS_FEATURES) && 
                (pConfig->m_PortParams.dwFeatures & DMUS_PORT_FEATURE_AUDIOPATH)))
            {
                CBufferConnect *pConnect = pConfig->m_BufferConnectList.GetHead();
                for (;pConnect && SUCCEEDED(hr);pConnect = pConnect->GetNext())
                {
                    // For each connect block, there should be an array of buffers 
                    // to connect the range of PChannels to.
                    // For each PChannel, get a virtual pchannel and then assign
                    // it to the bus ids that belong to the buffers.
                    if (pConnect->m_ppBufferNodes)
                    {
#ifdef DXAPI
                        DWORD dwCount = 0;
                        DWORD dwBusIDs[32];
                        DWORD *pdwBusIDBase = &dwBusIDs[0];
                        DWORD dwTotalRead = 0;
                        DWORD dwAmountLeft = 32;
                        for (;(dwCount < pConnect->m_ConnectHeader.dwBufferCount) && dwAmountLeft; dwCount++)
                        {
                            if (pConnect->m_ppBufferNodes[dwCount] && !(pConnect->m_ppBufferNodes[dwCount]->m_BufferHeader.dwFlags & DMUS_BUFFERF_PRIMARY))
                            {
                                IDirectSoundBuffer *pBuffer = pConnect->m_ppBufferNodes[dwCount]->GetBuffer();
                                if (pBuffer)
                                {
                                    dwTotalRead = dwAmountLeft;
                                    hr = m_pPerformance->m_BufferManager.m_pSinkConnect->GetSoundBufferBusIDs((CBuffer *)pBuffer,pdwBusIDBase,NULL,&dwTotalRead);
                                    pBuffer->Release();
                                    if (FAILED(hr)) break;
                                    pdwBusIDBase += dwTotalRead; // Increment pointer by how many was read.
                                    dwAmountLeft -=  dwTotalRead;
                                }
                            }
                        }
                        if (SUCCEEDED(hr))
                        {
                            dwTotalRead = 32 - dwAmountLeft;
                            // Now, allocate the pchannels and assign them to buses.
                            IDirectMusicPortP* pPortP = NULL;
                            if (SUCCEEDED(pConfig->m_pPort->QueryInterface(IID_IDirectMusicPortP, (void**)&pPortP)))
                            {
                                for (dwCount = 0;dwCount < pConnect->m_ConnectHeader.dwPChannelCount; dwCount++)
                                {
                                    DWORD dwDrumFlags = 0;
                                    m_pdwVChannels[dwIndex] = pConnect->m_ConnectHeader.dwPChannelBase + dwCount;
                                    if (pConfig->m_PortHeader.dwFlags & DMUS_PORTCONFIGF_DRUMSON10) 
                                    {
                                        dwDrumFlags = 1;
                                        if (((pConnect->m_ConnectHeader.dwPChannelBase + dwCount) & 0xF) == 9)
                                        {
                                            // This is a drum on channel 10.
                                            dwDrumFlags |= 2;
                                        }
                                    } 
                                    // Now, allocate a virtual pchannel for this and get back the equivalent group and midi channel.
                                    DWORD dwGroup;
                                    DWORD dwMChannel;
                                    hr = pPerf->AllocVChannel(pConfig->m_dwPortID,dwDrumFlags,&m_pdwPChannels[dwIndex],&dwGroup,&dwMChannel);
                                    if (dwTotalRead && SUCCEEDED(hr))
                                    {
                                        hr = pPortP->AssignChannelToBuses(dwGroup,dwMChannel,dwBusIDs,dwTotalRead);
                                    }
                                    dwIndex++;
                                }
                                pPortP->Release();
                            }
                        }
#else
                        // For XBOX, the problem is much simpler. We can either connect a channel to a 3D buffer,
                        // in which case we connect it directly to it, or we can connect it to some number of mixbins,
                        // which are all defined by bit flags.
                        DWORD dwMixBins = 0;
                        DWORD dwCount = 0;
                        BYTE *pControllers = NULL;
                        IDirectSoundBuffer *pBuffer = NULL;     
                        for (;(dwCount < pConnect->m_ConnectHeader.dwBufferCount) ; dwCount++)
                        {
                            if (pConnect->m_ppBufferNodes[dwCount])
                            {
                                pBuffer = pConnect->m_ppBufferNodes[dwCount]->GetBuffer();
                                if (pBuffer)
                                {
                                    // Since we have the buffer, forget about the mixbins and fall through.
                                    break;
                                }
                                if (pConnect->m_ppBufferNodes[dwCount]->m_dwMixBin) 
                                {
                                    dwMixBins |= pConnect->m_ppBufferNodes[dwCount]->m_dwMixBin;
                                }
                                if (pConnect->m_ppBufferNodes[dwCount]->m_MixBinsHeader.bControllers[0])
                                {
                                    pControllers = &pConnect->m_ppBufferNodes[dwCount]->m_MixBinsHeader.bControllers[0];
                                    break;
                                }
                            }
                        }
#ifdef DXAPI
                        IDirectMusicPortP* pPortP = NULL;
                        if (SUCCEEDED(pConfig->m_pPort->QueryInterface(IID_IDirectMusicPortP, (void**)&pPortP)))
#else
                        IDirectMusicSynthX* pPortP = pPerf->m_pSynth;
                        pPortP->AddRef();
#endif
                        {
                            for (dwCount = 0;dwCount < pConnect->m_ConnectHeader.dwPChannelCount; dwCount++)
                            {
                                DWORD dwDrumFlags = 0;
                                m_pdwVChannels[dwIndex] = pConnect->m_ConnectHeader.dwPChannelBase + dwCount;
                                if (pConfig->m_PortHeader.dwFlags & DMUS_PORTCONFIGF_DRUMSON10) 
                                {
                                    dwDrumFlags = 1;
                                    if (((pConnect->m_ConnectHeader.dwPChannelBase + dwCount) & 0xF) == 9)
                                    {
                                        // This is a drum on channel 10.
                                        dwDrumFlags |= 2;
                                    }
                                } 
                                // Now, allocate a virtual pchannel for this and get back the equivalent group and midi channel.
                                DWORD dwGroup;
                                DWORD dwMChannel;
                                hr = pPerf->AllocVChannel(pConfig->m_dwPortID,dwDrumFlags,&m_pdwPChannels[dwIndex],&dwGroup,&dwMChannel);
                                if (SUCCEEDED(hr))
                                {
                                    hr = pPortP->AssignChannelToOutput(dwGroup,dwMChannel,pBuffer,dwMixBins,pControllers);
                                }
                                dwIndex++;
                            }
                            pPortP->Release();
                        }
                        if (pBuffer)
                        {
                            pBuffer->Release();
                        }
#endif
                    }
                }
            }
            else
            {
                DWORD dwCount;
                for (dwCount = 0;SUCCEEDED(hr) && (dwCount < pConfig->m_PortHeader.dwPChannelCount); dwCount++)
                {
                    DWORD dwDrumFlags = 0;
                    m_pdwVChannels[dwIndex] = pConfig->m_PortHeader.dwPChannelBase + dwCount;
                    if (pConfig->m_PortHeader.dwFlags & DMUS_PORTCONFIGF_DRUMSON10) 
                    {
                        dwDrumFlags = 1;
                        if (((pConfig->m_PortHeader.dwPChannelBase + dwCount) & 0xF) == 9)
                        {
                            // This is a drum on channel 10.
                            dwDrumFlags |= 2;
                        }
                    } 
                    // Now, allocate a virtual pchannel for this.
                    DWORD dwGroup; // These won't be used since we won't be assigning pchannels on the port to buffers.
                    DWORD dwMChannel;
                    hr = pPerf->AllocVChannel(pConfig->m_dwPortID,dwDrumFlags,&m_pdwPChannels[dwIndex],&dwGroup,&dwMChannel);
/*                    Trace(0,"%ld: Mapping %ld to %ld (Port %ld, Group %ld, Channel %ld)\n",
                        dwIndex,m_pdwVChannels[dwIndex],m_pdwPChannels[dwIndex],
                        pConfig->m_dwPortID,dwGroup,dwMChannel);*/

                    dwIndex++;
                }
            }
        }
    }
    m_dwChannelCount = dwChannelCount;
    return hr;
}

void CAudioPathList::Clear()
{
    CAudioPath *pPath;
    while (pPath = GetHead())
    {
        pPath->Deactivate(); // This should also remove it from the list.
        assert(pPath != GetHead()); // Make sure this is always the case!
    }
}

CBufferNode * CAudioPathList::GetBufferNode(REFGUID guidBufferID)

{
    CBufferNode *pBuff = NULL;
    CAudioPath *pPath;
    for (pPath = GetHead();pPath;pPath = pPath->GetNext())
    {
        pBuff = pPath->GetBufferNode(guidBufferID);
        if (pBuff)
        {
            break;
        }
    }
    return pBuff;
}

BOOL CAudioPathList::UsesPort(IDirectMusicPort *pPort)

{
    CAudioPath *pPath = GetHead();
    for (;pPath;pPath = pPath->GetNext())
    {
        if (pPath->UsesPort(pPort))
        {
            return TRUE;
        }
    }
    return FALSE;
}

CAudioPathConfig::CAudioPathConfig() : CMemTrack(DMTRACK_AUDIOPATH_CONFIG)  
{
    m_pGraph = NULL;
    m_cRef = 1;
    m_pUnkDispatch = NULL;

    INITIALIZE_CRITICAL_SECTION(&m_CriticalSection);
    IncrementDLLCount();
}

CAudioPathConfig::~CAudioPathConfig()
{
    if (m_pGraph)
    {
        m_pGraph->Release();
    }
    if (m_pUnkDispatch)
    {
        m_pUnkDispatch->Release(); // free IDispatch implementation we may have borrowed
    }
    m_PortConfigList.Clear();
    m_BufferConfigList.Clear();
    DELETE_CRITICAL_SECTION(&m_CriticalSection);
    DecrementDLLCount();
}

CAudioPathConfig *CAudioPathConfig::CreateStandardConfig(DWORD dwType,DWORD dwPChannelCount,DWORD dwSampleRate)

{
    CAudioPathConfig *pConfig = new CAudioPathConfig;
    if (pConfig)
    {
        DWORD dwGlobalType = 0;         // Global mixin buffer.
        DWORD dwTypes[3];               // What types of buffers to create.
        DWORD dwTotal = 0;              // How many buffers.
        GUID  guidBufferIDs[3];         // IDs of buffers that should be connected to.
        DWORD dwConnections = 0;        // How many buffer connections.
        BOOL fCreatePort = TRUE;
#ifdef XBOX
        DMUS_IO_BUFFER_MIXBINS_HEADER MixBinsHeader;
        MixBinsHeader.bControllers[0] = 0;
        MixBinsHeader.dwMixBins = 0;
#endif
        switch (dwType)
        {
        case DMUS_APATH_SHARED_STEREOPLUSREVERB:
            dwTypes[0] = BUFFER_MUSIC; 
            dwTypes[1] = BUFFER_REVERB;
            guidBufferIDs[0] = GUID_Buffer_Stereo;
            guidBufferIDs[1] = GUID_Buffer_Reverb;
#ifdef DXAPI
            dwConnections = 2;
            dwTotal = 2;
#else
            dwTypes[2] = BUFFER_CHORUS;
            dwConnections = 3;
            dwTotal = 3;
            guidBufferIDs[2] = GUID_Buffer_Chorus;
#endif
            break;
        // Following removed for DX8, should be reintroduced for Whistler and DX8.1...
/*
        case DMUS_APATH_DYNAMIC_ENV3D:
            dwGlobalType = BUFFER_ENVREVERB;
            dwTypes[0] = BUFFER_3D;
            guidBufferIDs[0] = GUID_Buffer_3D;
            dwConnections = 1;
            dwTotal = 1;
            break;
*/
        case DMUS_APATH_DYNAMIC_3D:
            dwTypes[0] = BUFFER_3D_DRY;
            guidBufferIDs[0] = GUID_Buffer_3D_Dry;
            dwConnections = 1;
            dwTotal = 1;
            break;
        case DMUS_APATH_DYNAMIC_MONO:
            dwTypes[0] = BUFFER_MONO;
            guidBufferIDs[0] = GUID_Buffer_Mono;
            dwConnections = 1;
            dwTotal = 1;
            break;
        case DMUS_APATH_DYNAMIC_STEREO:
            dwTypes[0] = BUFFER_STEREO;
            guidBufferIDs[0] = GUID_Buffer_Stereo;
            dwConnections = 1;
            dwTotal = 1;
            break;
#ifndef DXAPI
        case DMUS_APATH_SHARED_STEREO:
            dwTypes[0] = BUFFER_MUSIC; 
            guidBufferIDs[0] = GUID_Buffer_Stereo;
            dwConnections = 1;
            dwTotal = 1;
            break;
#endif
#ifdef XBOX
        case DMUS_APATH_MIXBIN_5DOT1:
            dwTypes[0] = BUFFER_MIXBINS;
            guidBufferIDs[0] = GUID_Buffer_MixBins;
            dwConnections = 1;
            dwTotal = 1;
            MixBinsHeader.dwMixBins = DSMIXBIN_FRONT_LEFT | DSMIXBIN_FRONT_RIGHT |
                DSMIXBIN_FRONT_CENTER | DSMIXBIN_LOW_FREQUENCY | DSMIXBIN_BACK_LEFT |
                DSMIXBIN_BACK_RIGHT | DSMIXBIN_I3DL2;
            MixBinsHeader.bControllers[0] = 1;
            MixBinsHeader.bControllers[1] = 2;
            MixBinsHeader.bControllers[2] = 3;
            MixBinsHeader.bControllers[3] = 4;
            MixBinsHeader.bControllers[4] = 5;
            MixBinsHeader.bControllers[5] = 6;
            MixBinsHeader.bControllers[6] = 7;
            MixBinsHeader.bControllers[7] = 0;
            break;
        case DMUS_APATH_MIXBIN_STEREOPLUSEFFECTS:
            dwTypes[0] = BUFFER_MIXBINS;
            guidBufferIDs[0] = GUID_Buffer_MixBins;
            dwConnections = 1;
            dwTotal = 1;
            MixBinsHeader.dwMixBins = DSMIXBIN_FRONT_LEFT | DSMIXBIN_FRONT_RIGHT |
                DSMIXBIN_I3DL2 | DSMIXBIN_FXSEND_0 | DSMIXBIN_FXSEND_1 |
                DSMIXBIN_FXSEND_2 | DSMIXBIN_FXSEND_3 | DSMIXBIN_FXSEND_4;
            MixBinsHeader.bControllers[0] = 1;
            MixBinsHeader.bControllers[1] = 2;
            MixBinsHeader.bControllers[2] = 3;
            MixBinsHeader.bControllers[3] = 4;
            MixBinsHeader.bControllers[4] = 5;
            MixBinsHeader.bControllers[5] = 6;
            MixBinsHeader.bControllers[6] = 7;
            MixBinsHeader.bControllers[7] = 8;
            break;
#endif
        }
        if (dwGlobalType)
        {
            CBufferConfig *pBuffer = new CBufferConfig(dwGlobalType);
            if (pBuffer)
            {
                // This buffer configuration just has an id to identify which standard
                // buffer, instead of a pointer to a DSoundBufferConfig object,
                // which is what you'd see in the file io case.
                pConfig->m_BufferConfigList.AddHead(pBuffer);
            }
            else
            {
                delete pConfig;
                return NULL;
            }
        }
        if (fCreatePort)
        {
            CPortConfig *pPort = new CPortConfig();
            if (pPort)
            {
                pConfig->m_PortConfigList.AddHead(pPort);
                for (DWORD dwIndex = 0; dwIndex < dwTotal; dwIndex++)
                {
                    CBufferConfig *pBuffer = new CBufferConfig(dwTypes[dwIndex]);
                    if (pBuffer)
                    {
                        // This buffer configuration just has an id to identify which standard
                        // buffer, instead of a pointer to a DSoundBufferConfig object,
                        // which is what you'd see in the file io case.
                        pPort->m_BufferConfigList.AddHead(pBuffer);
#ifdef XBOX
                        pBuffer->m_MixBinsHeader = MixBinsHeader;
#endif
                    }
                    else
                    {
                        delete pConfig;
                        return NULL;
                    }
                }
                // If there are connections to buffers, create the connection structure.
                if (dwConnections)
                {
                    CBufferConnect *pConnect = new CBufferConnect;
                    if (pConnect)
                    {
                        pPort->m_BufferConnectList.AddHead(pConnect);
                        pConnect->m_ConnectHeader.dwBufferCount = dwConnections;
                        pConnect->m_ConnectHeader.dwFlags = 0;
                        pConnect->m_ConnectHeader.dwPChannelBase = 0;
                        pConnect->m_ConnectHeader.dwPChannelCount = dwPChannelCount;
                        pConnect->m_pguidBufferIDs = new GUID[dwConnections];
                        if (pConnect->m_pguidBufferIDs)
                        {
                            for (DWORD dwIndex = 0; dwIndex < dwConnections; dwIndex++)
                            {
                                pConnect->m_pguidBufferIDs[dwIndex] = guidBufferIDs[dwIndex];
                            }
                        }
                        else
                        {
                            delete pConfig;
                            return NULL;
                        }
                    }
                }
                pPort->m_PortHeader.dwPChannelCount = dwPChannelCount;
                pPort->m_PortParams.dwChannelGroups = (dwPChannelCount + 15) / 16;
            }
            else
            {
                delete pConfig;
                pConfig = NULL;
            }
        }
    }
    return pConfig;
}



STDMETHODIMP CAudioPathConfig::QueryInterface(
    const IID &iid,   
    void **ppv)       
{
    V_INAME(CAudioPathConfig::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    *ppv = NULL;
    if ((iid == IID_IUnknown ) || (iid == IID_IDirectMusicObject))
    {
        *ppv = static_cast<IDirectMusicObject*>(this);
    }
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else if (iid == IID_CAudioPathConfig)
    {
        *ppv = static_cast<CAudioPathConfig*>(this);
    }
    else if (iid == IID_IDispatch)
    {
        // A helper scripting object implements IDispatch, which we expose via COM aggregation.
        if (!m_pUnkDispatch)
        {
            // Create the helper object
            DirectMusicCreateInstance(
                CLSID_AutDirectMusicAudioPathConfig,
                static_cast<IDirectMusicObject*>(this),
                IID_IUnknown,
                reinterpret_cast<void**>(&m_pUnkDispatch));
        }
        if (m_pUnkDispatch)
        {
            return m_pUnkDispatch->QueryInterface(IID_IDispatch, ppv);
        }
    }

    if (*ppv == NULL)
    {
        Trace(4,"Warning: Request to query unknown interface on AudioPathConfig object\n");
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CAudioPathConfig::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CAudioPathConfig::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CAudioPathConfig::GetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CAudioPathConfig::GetDescriptor);
    V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);
    return m_Info.GetDescriptor(pDesc,CLSID_DirectMusicAudioPathConfig);
}

STDMETHODIMP CAudioPathConfig::SetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CAudioPathConfig::SetDescriptor);
    V_STRUCTPTR_READ(pDesc, DMUS_OBJECTDESC);
	return m_Info.SetDescriptor(pDesc);
}

STDMETHODIMP CAudioPathConfig::ParseDescriptor(LPSTREAM pIStream, LPDMUS_OBJECTDESC pDesc) 

{
    V_INAME(CAudioPathConfig::ParseDescriptor);
    V_INTERFACE(pIStream);
    V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);

    return m_Info.ParseDescriptor(pIStream,pDesc,DMUS_FOURCC_AUDIOPATH_FORM,CLSID_DirectMusicAudioPathConfig);
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CAudioPathConfig::GetClassID( CLSID* pClassID )
{
    V_INAME(CAudioPathConfig::GetClassID);
    V_PTR_WRITE(pClassID, CLSID); 
    *pClassID = CLSID_DirectMusicAudioPathConfig;
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPersistStream functions

HRESULT CAudioPathConfig::IsDirty()
{
    return S_FALSE;
}

HRESULT CAudioPathConfig::Load( IStream* pIStream )
{
    V_INAME(IPersistStream::Load);
    V_INTERFACE(pIStream);

    CRiffParser Parser(pIStream);
    RIFFIO ckMain;
    HRESULT hr = S_OK;

    Parser.EnterList(&ckMain);  
    if (Parser.NextChunk(&hr) && (ckMain.fccType == DMUS_FOURCC_AUDIOPATH_FORM))
    {
        ENTER_CRITICAL_SECTION(&m_CriticalSection);
        // Clear out any data that was previously loaded.
        if (m_pGraph)
        {
            m_pGraph->Release();
        }
        m_PortConfigList.Clear();
        m_BufferConfigList.Clear();        
        hr = Load(&Parser);
        LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    }
    else
    {
        Trace(1,"Error: Failed parsing - file is not AudioPathConfig format.\n");
        hr = DMUS_E_DESCEND_CHUNK_FAIL;
    }
    return hr;
}

HRESULT CAudioPathConfig::Load(CRiffParser *pParser)

{
    RIFFIO ckNext, ckChild;
    HRESULT hr = S_OK;

    ENTER_CRITICAL_SECTION(&m_CriticalSection);

    pParser->EnterList(&ckNext);
    while(pParser->NextChunk(&hr))
    {
        switch(ckNext.ckid)
        {
        case DMUS_FOURCC_GUID_CHUNK:
        case DMUS_FOURCC_VERSION_CHUNK:
        case DMUS_FOURCC_CATEGORY_CHUNK:
        case DMUS_FOURCC_DATE_CHUNK:
            hr = m_Info.ReadChunk(pParser,ckNext.ckid);
			break;
		case FOURCC_LIST:
			switch(ckNext.fccType)
			{
                case DMUS_FOURCC_UNFO_LIST:
                    hr = m_Info.ReadChunk(pParser,ckNext.fccType);
					break;
                case DMUS_FOURCC_PORTCONFIGS_LIST:
                    pParser->EnterList(&ckChild);
                    while (pParser->NextChunk(&hr))
                    {
                        switch( ckChild.ckid )
                        {
                        case FOURCC_LIST:
                            if (ckChild.fccType == DMUS_FOURCC_PORTCONFIG_LIST)
                            {
                                CPortConfig *pConfig = new CPortConfig();
                                if (pConfig) 
                                {
                                    hr = pConfig->Load(pParser);
                                    if (SUCCEEDED(hr))
                                    {
                                        m_PortConfigList.AddTail(pConfig);
                                    }
                                }
                                else
                                {
                                    hr = E_OUTOFMEMORY;
                                }
                            }
                            break;
                        }
                    }
                    pParser->LeaveList();
                    break;
                case DMUS_FOURCC_DSBUFFER_LIST:
                    {
                        CBufferConfig *pSource = new CBufferConfig(0);
                        if (pSource)
                        {
                            pParser->EnterList(&ckChild);
                            while (pParser->NextChunk(&hr))
                            {
                                switch( ckChild.ckid )
                                {
                                case DMUS_FOURCC_DSBUFFATTR_ITEM:
                                    hr = pParser->Read(&pSource->m_BufferHeader, 
                                        sizeof(DMUS_IO_BUFFER_ATTRIBUTES_HEADER));
                                    pSource->DecideType();
                                    break;
                                case DMUS_FOURCC_MIXBINS_ITEM:
                                    hr = pParser->Read(&pSource->m_MixBinsHeader, 
                                        sizeof(DMUS_IO_BUFFER_MIXBINS_HEADER));
                                    break;
                                case FOURCC_LIST:
                                case FOURCC_RIFF:
                                    if ( ckChild.fccType == DMUS_FOURCC_DSBC_FORM)
                                    {
                                        pParser->SeekBack();
                                        hr = pSource->Load(pParser->GetStream());
                                        pParser->SeekForward();
                                    }
                                }
                            }
                            if (SUCCEEDED(hr))
                            {
                                m_BufferConfigList.AddTail(pSource);
                            }
                            else
                            {
                                delete pSource;
                                Trace(1,"Error: AudioPath Configuration failed loading buffer\n");
                            }
                            pParser->LeaveList();
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }
                    break;
                case DMUS_FOURCC_DSBC_FORM:
                    {
                        CBufferConfig *pSource = new CBufferConfig(0);
                        if (pSource)
                        {
                            pParser->SeekBack();
                            hr = pSource->Load(pParser->GetStream());
                            pParser->SeekForward();
                            if (SUCCEEDED(hr))
                            {
                                m_BufferConfigList.AddTail(pSource);
                            }
                            else
                            {
                                Trace(1,"Error: AudioPath Configuration failed loading buffer\n");
                                delete pSource;
                            }
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }
                    break;               
                case DMUS_FOURCC_TOOLGRAPH_FORM:
                    {
                        CGraph *pGraph = new CGraph;
                        if (pGraph)
                        {
                            hr = pGraph->Load(pParser); 
                            if(m_pGraph)
                            {
                                m_pGraph->Release();
                            }
                            m_pGraph = pGraph;
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }
                    break;                       
            }
            break;
        }
    }
    pParser->LeaveList();
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    return hr;
}

HRESULT CAudioPathConfig::Save( IStream* pIStream, BOOL fClearDirty )
{
    return E_NOTIMPL;
}

HRESULT CAudioPathConfig::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\dmime.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// dmime.h
//
#ifndef _DMIME_H_
#define _DMIME_H_

// Must be before dmusicc.h, which includes dsound.h
//
#ifdef XBOX
#define NODSOUND
#include <xtl.h>
#else // XBOX
#include <windows.h>
#define COM_NO_WINDOWS_H
#include <objbase.h>
#endif // XBOX

#include <mmsystem.h>
#include <dsoundp.h>

#include "dmusicip.h"

#include <mmsystem.h>
#define RELEASE(x)	if( NULL != x ) { x->Release(); }

#ifdef __cplusplus
extern "C" {
#endif

#ifdef XBOX
extern long g_cComponent;
#define IncrementDLLCount() 
#define DecrementDLLCount()
#else
extern long g_cComponent;
#define IncrementDLLCount() InterlockedIncrement(&g_cComponent)
#define DecrementDLLCount() InterlockedDecrement(&g_cComponent)
extern bool g_fInitCS;
extern CRITICAL_SECTION g_CritSec;
#endif

#ifdef __cplusplus
}; /* extern "C" */
#endif
DEFINE_GUID(IID_IDirectMusicPerformanceStats, 0x9301e312, 0x1f22, 0x11d3, 0x82, 0x26, 0xd2, 0xfa, 0x76, 0x25, 0x5d, 0x47);
DEFINE_GUID(IID_IDirectMusicParamHook,0x58880561, 0x5481, 0x11d3, 0x9b, 0xd1, 0xc2, 0x9f, 0xc4, 0xd1, 0xe6, 0x35);
DEFINE_GUID(IID_IDirectMusicSetParamHook,0x679c4138, 0xc62e, 0x4147, 0xb2, 0xb4, 0x9d, 0x56, 0x9a, 0xcb, 0x25, 0x4c);

#endif // _DMIME_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\dmprfdll.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// dmprfdll.h
//
// Class factory
//

#ifndef __DMPRFDLL_H_
#define __DMPRFDLL_H_
 
class CClassFactory 
#ifndef XBOX
: public IClassFactory
#endif
{
public:
	// IUnknown
    //
	STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

	// Interface IClassFactory
    //
	STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
	STDMETHODIMP LockServer(BOOL bLock); 

	// Constructor
    //
	CClassFactory(DWORD dwToolType);

	// Destructor
	~CClassFactory(); 

private:
	long m_cRef;
    DWORD m_dwClassType;
};

// We use one class factory to create all classes. We need an identifier for each 
// type so the class factory knows what it is creating.

#define CLASS_PERFORMANCE   1
#define CLASS_GRAPH         2
#define CLASS_SEGMENT       3
#define CLASS_SONG          4
#define CLASS_AUDIOPATH     5
#define CLASS_SEQTRACK      6
#define CLASS_SYSEXTRACK    7
#define CLASS_TEMPOTRACK    8
#define CLASS_TIMESIGTRACK  9
#define CLASS_LYRICSTRACK   10
#define CLASS_MARKERTRACK   11
#define CLASS_PARAMSTRACK   12
#define CLASS_TRIGGERTRACK  13
#define CLASS_WAVETRACK     14
#define CLASS_SEGSTATE      15



#endif // __DMPRFDLL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\CMixBins.cpp ===
//
// CMIXBINS.cpp
// 
// Copyright (c) 2001 Microsoft Corporation
//
// Created by danhaff 9/24/01
//
// Class representation of a DSMIXBINS struct.  Has lots of checks in 
// debug mode to prevent screw-ups.

#include "pchime.h"

/********************************************************************************
********************************************************************************/
CMIXBINS::CMIXBINS(void)
{
    m_bValid = FALSE;
    m_DSMixBins.dwMixBinCount = 0;        
    m_DSMixBins.lpMixBinVolumePairs = &m_VolumePair[0];
    ZeroMemory(&m_VolumePair, sizeof(DSMIXBINVOLUMEPAIR) * DSMIXBIN_ASSIGNMENT_MAX);
};


#ifdef _DEBUG
/********************************************************************************
********************************************************************************/
CMIXBINS::~CMIXBINS(void)
{
    //Trash our data.
    m_bValid = FALSE;
    memset(&m_DSMixBins,  0xFF, sizeof(m_DSMixBins));
    memset(&m_VolumePair, 0xFF, sizeof(DSMIXBINVOLUMEPAIR) * DSMIXBIN_ASSIGNMENT_MAX);
};
#endif

/********************************************************************************
DMusic doesn't care about volumes in some places, and simply stores its mixbin
values in a mask.  This sets the object based on that mask.
********************************************************************************/
void CMIXBINS::CreateFromMask(DWORD dwMask)
{
    //Make sure we're not blowing away an already-initialized object.
    ASSERT(!m_bValid);
    m_DSMixBins.dwMixBinCount = 0;
    for (DWORD i=0; i<32; i++)
    {
        if (dwMask & (1<<i))
        {
            m_VolumePair[m_DSMixBins.dwMixBinCount].dwMixBin = i;
            m_VolumePair[m_DSMixBins.dwMixBinCount].lVolume  = 0;
            m_DSMixBins.dwMixBinCount++;
        }
    }
    m_bValid = TRUE;
};

/********************************************************************************
Simply returns a pointer to the class's DSMIXBINS data.  Of course, the data
pointed to is only valid during the scope of the class.
********************************************************************************/
LPCDSMIXBINS CMIXBINS::GetMixBins(void)
{
    ASSERT(m_bValid);
    if (!m_DSMixBins.dwMixBinCount)
        return NULL;
    else
        return &m_DSMixBins;
};

/******************************************w**************************************
This function was built to interface with a DMusic kludge.  DSound's SetMixBinVolumes
once took a set of flags and an array of volumes.  Now DSound's mixbin identifiers have
changed from flags (1, 2, 4, 8) to indices (1, 2, 3, 4).  To minimize code changes,
I simply replaced all instances of (DSMIXBIN_*) with (1 << DSMIXBIN_*) to change
them back to flags so DMusic could continue to use a piddly DWORD instead of a 
DSMIXBINS struct to store the data, since DMusic was storing its volume info separately
anyway.  Eventually DMusic would call SetMixBinVolumes with its flags and volume array,
so this translates from that type of data into a real DSMIXBINS struct which
can be returned with GetMixBins().
********************************************************************************/
void CMIXBINS::PokeMixBinVolumesBasedOnMask(DWORD dwMixBinMask, long *alVolumes)
{
    DWORD dwCount = 0;
    DWORD i       = 0;
    
    ASSERT(m_bValid);
    ASSERT(alVolumes);        
    #ifdef _DEBUG
    DWORD dwBitCount = 0;
    for (i=0; i<32; i++)
    {
        if ((1<<i) & dwMixBinMask)
            dwBitCount++;
    }        
    ASSERT(dwBitCount <= DSMIXBIN_ASSIGNMENT_MAX);
    ASSERT(dwBitCount != 0);
    #endif

    //Scan through bits in the mask.
    for (i=0; i<32; i++)
    {
        //If a bit is set...
        if ((1<<i) & dwMixBinMask)
        {
            //...then find the mixbin represented by that bit and set its volume to the next element in the alVolumes array.
            BOOL bFound = FALSE;
            for (DWORD dwMixBinIndex=0; dwMixBinIndex<DSMIXBIN_ASSIGNMENT_MAX; dwMixBinIndex++)
            {
                if (m_DSMixBins.lpMixBinVolumePairs[dwMixBinIndex].dwMixBin == i)
                {
                    m_VolumePair[dwMixBinIndex].lVolume = alVolumes[dwCount];
                    dwCount++;
                    break;
                }
            }
        }
    }

    #ifdef _DEBUG
    ASSERT(dwCount == dwBitCount);
    #endif
};


/********************************************************************************
********************************************************************************/
BOOL CMIXBINS::operator == (CMIXBINS &p_MixBins)
{
    ASSERT(m_bValid);
    ASSERT(p_MixBins.m_bValid);

    if (m_DSMixBins.dwMixBinCount == p_MixBins.m_DSMixBins.dwMixBinCount)
        if (memcmp(m_DSMixBins.lpMixBinVolumePairs, p_MixBins.m_DSMixBins.lpMixBinVolumePairs, sizeof(DSMIXBINVOLUMEPAIR) * p_MixBins.m_DSMixBins.dwMixBinCount))
            return TRUE;
    return FALSE;
}

/********************************************************************************
********************************************************************************/
BOOL CMIXBINS::operator != (CMIXBINS &p_MixBins)
{
    return (!(*this == p_MixBins));
}


/********************************************************************************
********************************************************************************/
/*
void CMIXBINS::SetMixBinCount(DWORD dwMixBinCount)
{
    ASSERT(dwMixBinCount < DSMIXBIN_ASSIGNMENT_MAX);
    m_DSMixBins.dwMixBinCount = dwMixBinCount;
};
*/


/********************************************************************************
********************************************************************************/
/*
void CMIXBINS::SetMixBinVolumePair(DWORD dwIndex, DSMIXBINVOLUMEPAIR &VolumePair)
{
    ASSERT(dwIndex < m_DSMixBins.dwMixBinCount);
    m_VolumePair[dwIndex] = VolumePair;
    m_bValid = TRUE;

};
*/
/********************************************************************************
********************************************************************************/
/*
void CMIXBINS::SetMixBinVolumePair(DWORD dwIndex, DWORD dwMixBin, long lVolume)
{
    ASSERT(dwIndex < m_DSMixBins.dwMixBinCount);
    m_VolumePair[dwIndex].dwMixBin = dwMixBin;
    m_VolumePair[dwIndex].lVolume  = lVolume;
    m_bValid = TRUE;
};
*/



/********************************************************************************
Actually COPIES the data into our object.
********************************************************************************/
/*
void CMIXBINS::SetMixBins(LPCDSMIXBINS pMixBins)
{
    ASSERT(pMixBins->dwMixBinCount < DSMIXBIN_ASSIGNMENT_MAX);
    ASSERT( !(pMixBins->dwMixBinCount && pMixBins->lpMixBinVolumePairs));
    ASSERT(pMixBins);

    m_DSMixBins.dwMixBinCount = pMixBins->dwMixBinCount;
    memcpy((void *)m_DSMixBins.lpMixBinVolumePairs, pMixBins->lpMixBinVolumePairs, sizeof(DSMIXBINVOLUMEPAIR) * m_DSMixBins.dwMixBinCount);
    m_bValid = TRUE;        
};
*/


/********************************************************************************
Not inline, because it contains more code than usual and will be called multiple
times from a function.
********************************************************************************/
/*
BOOL CMIXBINS::ContainsMixBin(DWORD dwMixBin)
{
    ASSERT(m_bValid);
    ASSERT(dwMixBin);

    for (DWORD i=0; i<DSMIXBIN_ASSIGNMENT_MAX; i++)
    {
        //Found it.
        if (m_DSMixBins.lpMixBinVolumePairs[i].dwMixBin == dwMixBin)
            return TRUE;
    }

    //Didn't find it.
    return FALSE;
}
*/


/********************************************************************************
********************************************************************************/
/*
BOOL DSMIXBINSAreEqual(LPCDSMIXBINS p1, LPCDSMIXBINS p2)
{

};
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\debug.cpp ===
//
// Debug.CPP
//
// Copyright (c) 1997-1998 Microsoft Corporation
//
// @doc INTERNAL
//
// @module Debug | Debug services for DMusic.DLL
//
#include "pchime.h"

/*#ifdef XBOX
#include <xtl.h>
#include <xdbg.h>
#else  // XBOX
#include <windows.h>
#endif // XBOX
#include <stdio.h>
#include <stdarg.h>
#include <dmusicip.h>
#include "debug.h"

#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
extern "C" void DMRegisterPMsgPerformanceCounters();
extern "C" void DMUnregisterPMsgPerformanceCounters();
#endif*/

// Heap objects
IDirectMusicHeap* gpDMHeap;
IDirectMusicHeap* gpDMPhysicalHeap;

// General Direct Music Initialization hook
// Required because we can't allocate any memory until after the heap is registered,
// but then there are various objects that depend upon static constructors being called.

extern LPDIRECTMUSICFACTORYFN gDirectMusicFactoryFn;

#ifdef IMPLEMENT_PERFORMANCE_COUNTERS

HRESULT WrapPerformanceCountersAroundHeap(bool bPhysicalHeap, IDirectMusicHeap* pHeap, IDirectMusicHeap** ppWrappedHeap);

#endif


void InitializeDirectMusicDoWorkCriticalSection();
extern void CScriptTrackCallListInitialize(void);

void DirectMusicInitializedCheck(){
	ASSERTMSG("You must call either DirectMusicInitialize or DirectMusicInitializeEx before using DirectMusic.",
		gDirectMusicFactoryFn != NULL);
}

HRESULT WINAPI DirectMusicInitializeEx(IDirectMusicHeap* pNormalHeap, IDirectMusicHeap* pPhysicalHeap,
                                       LPDIRECTMUSICFACTORYFN pFactory){
    ASSERTMSG("Must not be NULL.",pNormalHeap);
    ASSERTMSG("Must not be NULL.",pPhysicalHeap);
    ASSERTMSG("Must not be NULL.",pFactory);

    ASSERTMSG("DirectMusicInitialize or DirectMusicInitializeEx has already been called.",
        gDirectMusicFactoryFn == NULL);

    HRESULT hr = S_OK;

#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
    IDirectMusicHeap* pWrappedHeap;
    hr = WrapPerformanceCountersAroundHeap(false, pNormalHeap, &pWrappedHeap);
    if(SUCCEEDED(hr)){
        pNormalHeap = pWrappedHeap;
    }
    if(SUCCEEDED(hr)){
        hr = WrapPerformanceCountersAroundHeap(true, pPhysicalHeap, &pWrappedHeap);
    }
    if(SUCCEEDED(hr)){
        pPhysicalHeap = pWrappedHeap;
    }
#else
    pNormalHeap->AddRef();
    pPhysicalHeap->AddRef();
#endif

    if(SUCCEEDED(hr)){
        gpDMHeap = pNormalHeap;

        gpDMPhysicalHeap = pPhysicalHeap;

        gDirectMusicFactoryFn = pFactory;

        CScriptTrackCallListInitialize();
        InitializeDirectMusicDoWorkCriticalSection();
    }
    return hr;
}

HRESULT WINAPI DirectMusicInitialize(){
    HRESULT hr = S_OK;
    IDirectMusicHeap* pHeap = NULL;
    IDirectMusicHeap* pPhysicalHeap = NULL;
    if(SUCCEEDED(hr)){
        hr = DirectMusicCreateDefaultHeap(&pHeap);
    }
    if(SUCCEEDED(hr)){
        hr = DirectMusicCreateDefaultPhysicalHeap(&pPhysicalHeap);
    }
    if(SUCCEEDED(hr)){
        hr = DirectMusicInitializeEx(pHeap, pPhysicalHeap, &DirectMusicDefaultFactory);
    }
    if(pHeap){
        pHeap->Release();
    }
    if(pPhysicalHeap){
        pPhysicalHeap->Release();
    }
    return hr;
}

void* DirectMusicAllocI(size_t cb)
{
    if(!gpDMHeap) {
    	DirectMusicInitializedCheck();
    }
    void* pData = NULL;
    HRESULT hr = gpDMHeap->Allocate(cb, &pData);
    if(FAILED(hr) || pData == NULL){
        Trace(1,"DirectMusic normal heap failed to allocate a block of size %d bytes.\n", cb);
        return NULL;
    }
    ASSERTMSG("Allocated memory must be DWORD aligned.", (((int) pData) & 3) == 0);
    return pData;
}

void DirectMusicFreeI(void *pv)
{
    if(!gpDMHeap) {
    	DirectMusicInitializedCheck();
    }
    if(pv){
        gpDMHeap->Free(pv);
    }
}

void* DirectMusicPhysicalAllocI(size_t dwSize)
{
    if(!gpDMPhysicalHeap) {
    	DirectMusicInitializedCheck();
    }
    void* pData = NULL;
    HRESULT hr = gpDMPhysicalHeap->Allocate(dwSize, &pData);
    ASSERTMSG("Allocated memory must be DWORD aligned.", (((int) pData) & 3) == 0);
    if(FAILED(hr) || pData == NULL){
        Trace(1,"DirectMusic physical heap failed to allocate a block of size %d bytes.\n", dwSize);
        return NULL;
    }
    return pData;
}

void DirectMusicPhysicalFreeI(void *pv)
{
    if(!gpDMPhysicalHeap) {
        DirectMusicInitializedCheck();
    }
    if(pv){
        gpDMPhysicalHeap->Free(pv);
    }
}

// Standard heaps
// Note that we allocate these objects using LocalAlloc and free rather than the DMusic heap

#define LOCALALLOC_NEWDELETE \
    public: __inline void *__cdecl operator new(size_t cbBuffer) { return LocalAlloc(0,cbBuffer); } \
    public: __inline void *__cdecl operator new[](size_t cbBuffer) { return LocalAlloc(0,cbBuffer); } \
    public: __inline void __cdecl operator delete(void *pvBuffer) { if(pvBuffer) LocalFree(pvBuffer); } \
    public: __inline void __cdecl operator delete[](void *pvBuffer) { if(pvBuffer) LocalFree(pvBuffer); }


class DirectMusicDefaultHeap : public IDirectMusicHeap
{
    LOCALALLOC_NEWDELETE
public:
    DirectMusicDefaultHeap(){
        m_cRef = 1;
    }

    HRESULT Initialize() {
        return S_OK;
    }

    ~DirectMusicDefaultHeap() {}

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj)
    {
        return E_NOTIMPL;
    }

    virtual ULONG STDMETHODCALLTYPE AddRef( void) 
        
    {
        return InterlockedIncrement(&m_cRef);
    }

    virtual ULONG STDMETHODCALLTYPE Release( void) 
    {
        ULONG cRef;
            
        cRef = InterlockedDecrement(&m_cRef);

        if (cRef == 0)
            delete this;

        return cRef;
    }

    LONG m_cRef;

    /*  IDirectMusicHeap */
    STDMETHOD(Allocate)   (THIS_ DWORD dwSize, PVOID* ppData){
        *ppData = HeapAlloc(GetProcessHeap(),0, dwSize); // LocalAlloc is threadsafe. Can't use malloc/free because it might not be threadsafe.
        if(!*ppData){
            return E_OUTOFMEMORY;
        }
        return S_OK;
    }

    STDMETHOD(GetSize)(THIS_ PVOID pData, LPDWORD pcbSize){
        HRESULT hr = S_OK;
        if(pData){
            DWORD dwSize = HeapSize(GetProcessHeap(), 0, pData);
            if(dwSize ==0xFFFFFFFF){
                hr = E_FAIL;
            }
            else {
                *pcbSize = dwSize;
            }
        }
        else {
            hr = E_FAIL;
        }
        return hr;
    }

    STDMETHOD(Free)   (THIS_ PVOID pData){
        HeapFree(GetProcessHeap(),0,pData); // LocalFree is threadsafe. Can't use malloc/free because it might not be threadsafe.
        return S_OK;
    }
};

class DirectMusicDefaultPhysicalHeap : public IDirectMusicHeap
{
    LOCALALLOC_NEWDELETE
public:
    DirectMusicDefaultPhysicalHeap(){
        m_cRef = 1;
    }

    HRESULT Initialize() {
        return S_OK;
    }

    ~DirectMusicDefaultPhysicalHeap() {}

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj)
    {
        return E_NOTIMPL;
    }

    virtual ULONG STDMETHODCALLTYPE AddRef( void) 
        
    {
        return InterlockedIncrement(&m_cRef);
    }

    virtual ULONG STDMETHODCALLTYPE Release( void) 
    {
        ULONG cRef;
            
        cRef = InterlockedDecrement(&m_cRef);

        if (cRef == 0)
            delete this;

        return cRef;
    }

    LONG m_cRef;

    /*  IDirectMusicHeap */
    STDMETHOD(Allocate)   (THIS_ DWORD dwSize, PVOID* ppData){
        PVOID pData = XPhysicalAlloc(dwSize+4, MAXULONG_PTR, 0, PAGE_READWRITE);
        if(!pData){
            return E_OUTOFMEMORY;
        }
        ((DWORD*) pData)[0] = dwSize;
        *ppData = ((DWORD*) pData) + 1;
        return S_OK;
    }

    STDMETHOD(GetSize) (THIS_ PVOID pData, LPDWORD pcbSize){
        HRESULT hr = S_OK;
        if(pData){
            *pcbSize = ((DWORD*) pData)[-1];
        }
        else {
            hr = E_FAIL;
        }
        return hr;
    }

    STDMETHOD(Free)   (THIS_ PVOID pData){
        XPhysicalFree(((DWORD*) pData)-1);
        return S_OK;
    }
};

class DirectMusicFixedSizeHeap2 : public IDirectMusicHeap
{
    LOCALALLOC_NEWDELETE
public:
    DirectMusicFixedSizeHeap2(){
        m_cRef = 1;
        m_hHeap = GetProcessHeap();
        InitializeCriticalSection(&m_csPhysicalHeap);
    }

    HRESULT Initialize(DWORD dwNormalHeapSize) {
        m_dwLimit = dwNormalHeapSize;
        m_dwSize = 0;
        return S_OK;
    }

    ~DirectMusicFixedSizeHeap2() {
        // We don't delete m_hHeap, since it's the default process heap
        DeleteCriticalSection(&m_csPhysicalHeap);
    }

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj)
    {
        return E_NOTIMPL;
    }

    virtual ULONG STDMETHODCALLTYPE AddRef( void) 
        
    {
        return InterlockedIncrement(&m_cRef);
    }

    virtual ULONG STDMETHODCALLTYPE Release( void) 
    {
        ULONG cRef;
            
        cRef = InterlockedDecrement(&m_cRef);

        if (cRef == 0)
            delete this;

        return cRef;
    }

    LONG m_cRef;

    /*  IDirectMusicHeap */
    STDMETHOD(Allocate)   (THIS_ DWORD dwSize, PVOID* ppData){
        HRESULT hr = S_OK;
        EnterCriticalSection(&m_csPhysicalHeap);
        if(m_dwSize + dwSize <= m_dwLimit){
            PVOID pData = HeapAlloc(m_hHeap, 0, dwSize);
            if(!pData){
			    hr = E_OUTOFMEMORY;
            }
            else {
                m_dwSize += dwSize;
                *ppData = pData;
            }
        }
        else {
            Trace(1,"Normal fixed size heap is out of memory. Limit = %d, current size = %d, request = %d.\n",
                m_dwLimit, m_dwSize, dwSize);
		    hr = E_OUTOFMEMORY;
        }
        LeaveCriticalSection(&m_csPhysicalHeap);
        return hr;
    }

    STDMETHOD(GetSize) (THIS_ PVOID pData, LPDWORD pcbSize){
        HRESULT hr = S_OK;
        if(pData){
            DWORD dwSize = HeapSize(m_hHeap, 0, pData);
            if(dwSize ==0xFFFFFFFF){
                hr = E_FAIL;
            }
            else {
                *pcbSize = dwSize;
            }
        }
        else {
            hr = E_FAIL;
        }
        return hr;
    }

    STDMETHOD(Free)   (THIS_ PVOID pData){
        HRESULT hr = S_OK;
        if(pData){
            EnterCriticalSection(&m_csPhysicalHeap);
            DWORD dwSize = HeapSize(m_hHeap, 0, pData);
            if(m_dwSize >= dwSize){
                m_dwSize -= dwSize;
            }
            HeapFree(m_hHeap, 0, pData);
            LeaveCriticalSection(&m_csPhysicalHeap);
        }
        else {
            hr = E_FAIL;
        }
        return hr;
    }


private:
    CRITICAL_SECTION m_csPhysicalHeap;
    HANDLE m_hHeap; // An alias to GetProcessHeap();
    DWORD m_dwSize;
    DWORD m_dwLimit;

};

class DirectMusicFixedSizeHeap : public IDirectMusicHeap
{
    LOCALALLOC_NEWDELETE

    // Use standard HeapCreate / HeapAlloc heap for the normal heap.
    // 

    HANDLE m_hHeap; // Used for small blocks

    struct BlockHeader {
        DWORD dwSize;
    };

    // 1044480 is the threshold for using VirtualAlloc on the Xbox implementation of the Rtl Heap.
#define LARGEST_SMALL_HEAP_BLOCK_SIZE (1044480-sizeof(BlockHeader)) /* Blocks larger than this size are allocated using VirtualAlloc */

public:
    DirectMusicFixedSizeHeap(){
        m_cRef = 1;
        m_hHeap = 0;
    }

    HRESULT Initialize(DWORD dwNormalHeapSize) {
        if(dwNormalHeapSize){
            m_hHeap = HeapCreate(0, dwNormalHeapSize, dwNormalHeapSize);
            if(!m_hHeap){
                return E_OUTOFMEMORY;
            }
        }
        return S_OK;
    }

    ~DirectMusicFixedSizeHeap() {
        if(m_hHeap) {
            HeapDestroy(m_hHeap);
        }
    }

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj)
    {
        return E_NOTIMPL;
    }

    virtual ULONG STDMETHODCALLTYPE AddRef( void) 
        
    {
        return InterlockedIncrement(&m_cRef);
    }

    virtual ULONG STDMETHODCALLTYPE Release( void) 
    {
        ULONG cRef;
            
        cRef = InterlockedDecrement(&m_cRef);

        if (cRef == 0)
            delete this;

        return cRef;
    }

    LONG m_cRef;

    /*  IDirectMusicHeap */
    STDMETHOD(Allocate)   (THIS_ DWORD dwSize, PVOID* ppData){
        HRESULT hr = S_OK;
        if(m_hHeap){
            DWORD dwSize2 = dwSize + sizeof(BlockHeader);
            PVOID pData = 0;
            if (dwSize <= LARGEST_SMALL_HEAP_BLOCK_SIZE){
                pData = HeapAlloc(m_hHeap, 0, dwSize2);
            }
            else {
                Trace(2,"DirectMusicFixedSizeHeap allocating large block (%d bytes) using VirtualAlloc\n", dwSize);
                pData = VirtualAlloc(NULL, dwSize2, MEM_COMMIT, PAGE_READWRITE);
            }
            if(!pData){
			    hr = E_OUTOFMEMORY;
            }
            else {
                BlockHeader* pHeader = (BlockHeader*) pData;
                pHeader->dwSize = dwSize;
                *ppData = pHeader + 1;
            }
        }
        else {
		    hr = E_OUTOFMEMORY;
        }
        return hr;
    }

    STDMETHOD(GetSize) (THIS_ PVOID pData, LPDWORD pcbSize){
        HRESULT hr = S_OK;
        if(pData){
            BlockHeader* pHeader = ((BlockHeader*) pData) - 1;
            *pcbSize = pHeader->dwSize;
        }
        else {
            hr = E_FAIL;
        }
        return hr;
    }

    STDMETHOD(Free)   (THIS_ PVOID pData){
        HRESULT hr = S_OK;
        if(m_hHeap){
            if(pData){
                BlockHeader* pHeader = ((BlockHeader*) pData) - 1;
                if(pHeader->dwSize <= LARGEST_SMALL_HEAP_BLOCK_SIZE){ 
                    HeapFree(m_hHeap, 0, pHeader);
                }
                else {
                    VirtualFree(pHeader, 0, MEM_RELEASE);
                }
            }
        }
        else {
            hr = E_FAIL;
        }
        return hr;
    }


private:

};

// VerifyHeap is slow, so we only do it on debug builds.

#ifdef DBG
    #define VERIFYHEAP// VerifyHeap();
#else
    #define VERIFYHEAP
#endif

class DirectMusicFixedSizePhysicalHeap : public IDirectMusicHeap
{
    LOCALALLOC_NEWDELETE
public:
    DirectMusicFixedSizePhysicalHeap(){
        m_cRef = 1;
        m_pHead = 0;
        InitializeCriticalSection(&m_csPhysicalHeap);
    }

private:
    // Use a traditional first-fit heap for the physical memory heap

    struct BlockHead {
        BlockHead* pNext;
        unsigned int size;
        DWORD bUsed; // A DWORD to make the whole BlockHead struct DWORD aligned
    };

    CRITICAL_SECTION m_csPhysicalHeap;
    BlockHead* m_pHead;

public:

    HRESULT Initialize(DWORD dwPhysicalHeapSize) {

        if(dwPhysicalHeapSize < sizeof(BlockHead)){
            dwPhysicalHeapSize = 0;
        }
        else {
            m_pHead = (BlockHead*) XPhysicalAlloc(dwPhysicalHeapSize, MAXULONG_PTR, 0, PAGE_READWRITE);
            if(!m_pHead){
                return E_OUTOFMEMORY;
            }
            m_pHead->pNext = 0;
            m_pHead->size = dwPhysicalHeapSize-sizeof(BlockHead);
            m_pHead->bUsed = 0;
        }

        return S_OK;
    }

    ~DirectMusicFixedSizePhysicalHeap() {
        if(m_pHead){
            XPhysicalFree(m_pHead);
        }
        DeleteCriticalSection(&m_csPhysicalHeap);
    }

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj)
    {
        return E_NOTIMPL;
    }

    virtual ULONG STDMETHODCALLTYPE AddRef( void) 
        
    {
        return InterlockedIncrement(&m_cRef);
    }

    virtual ULONG STDMETHODCALLTYPE Release( void) 
    {
        ULONG cRef;
            
        cRef = InterlockedDecrement(&m_cRef);

        if (cRef == 0)
            delete this;

        return cRef;
    }

    LONG m_cRef;

    /*  IDirectMusicHeap methods */
    STDMETHOD(Allocate)   (THIS_ DWORD dwSize, PVOID* ppData){
        if(!m_pHead){
            return E_OUTOFMEMORY;
        }
		VERIFYHEAP
        PVOID pData = NULL;
        //Round up to the nearest DWORD.
        dwSize = (dwSize + 3) & ~3;

        EnterCriticalSection(&m_csPhysicalHeap);
        for(BlockHead* pB = m_pHead; pB; pB = pB->pNext){
            if((! pB->bUsed)){
                // Coalesce with next block, if possible
                while(pB->pNext && !pB->pNext->bUsed){
                    pB->size += pB->pNext->size + sizeof(BlockHead);
                    pB->pNext = pB->pNext->pNext;
                }
                // Is this block big enough to use?
                if(dwSize <= pB->size){
                    // Is it big enough to split?
                    if(dwSize + sizeof(BlockHead) < pB->size){
                        // split
                        BlockHead* pNew = (BlockHead*) (((char*) pB) + sizeof(BlockHead) + dwSize);
                        pNew->pNext = pB->pNext;
                        pNew->size = pB->size - (dwSize + sizeof(BlockHead));
                        pNew->bUsed = 0;
						pB->size = dwSize;
                        pB->pNext = pNew;
                    }
                    pB->bUsed = 'z';
                    pData = (void*) (((char*) pB) + sizeof(BlockHead));
                    break;
                }
            }
        }
        LeaveCriticalSection(&m_csPhysicalHeap);
		VERIFYHEAP
        if(!pData){
            return E_OUTOFMEMORY;
        }
        *ppData = pData;
		VERIFYHEAP
        return S_OK;
    }

    STDMETHOD(GetSize) (THIS_ PVOID pData, LPDWORD pcbSize){
        HRESULT hr = S_OK;
        if(pData){
            BlockHead* pB = (BlockHead*)(((char*) pData) - sizeof(BlockHead));
            *pcbSize = pB->size;
        }
        else {
            hr = E_FAIL;
        }
        return hr;
    }

    STDMETHOD(Free)   (THIS_ PVOID pData){
        if(!m_pHead){
            return E_FAIL;
        }
        if(pData){
			VERIFYHEAP
            EnterCriticalSection(&m_csPhysicalHeap);
            BlockHead* pB = (BlockHead*)(((char*) pData) - sizeof(BlockHead));
            ASSERTMSG("Bad Block", pB->bUsed == 'z');
            pB->bUsed = 0;
            LeaveCriticalSection(&m_csPhysicalHeap);
			VERIFYHEAP
        }
        return S_OK;
    }

#ifdef VERIFYHEAP

	STDMETHOD(VerifyHeap)(){
		DWORD dwCount = 0;
		BlockHead *pB = NULL;
		char *pByte;

		EnterCriticalSection(&m_csPhysicalHeap);

		for(pB = m_pHead; pB; pB = pB->pNext){
			dwCount++;
			pByte = (char *)pB;
        
			//Verify that the first and last byte in this block are 'X'.
			if(pB->bUsed == 0){
				if((pByte + sizeof(BlockHead))[0] != 'X'){
					Trace(1,"Heap Corruption at beginning of block");
					assert(FALSE);
				}

				if((pByte + sizeof(BlockHead))[pB->size - 1] != 'X'){
					Trace(1,"Heap Corruption at end of block");
					assert(FALSE);
				}
			}

			//Verify that the sizes match.
			if (pB->pNext) {
				if((char *)pB->pNext - (char *)pB != pB->size + sizeof(BlockHead)){
					Trace(1,"Difference between pB (%08X) and pB->pNext (%08X) is %08X (%d), but the size of pB + sizeof(BlockHead) is %08X (%d)\n",
						 pB,
						 pB->pNext,
						 (char *)pB->pNext - (char *)pB,
						 (char *)pB->pNext - (char *)pB,
						 pB->size,
						 pB->size
						 );
					assert(FALSE);
				}
			}
		}

		LeaveCriticalSection(&m_csPhysicalHeap);
		return S_OK;
	}
#endif
};

#ifdef IMPLEMENT_PERFORMANCE_COUNTERS

class PerformanceCounterWrapper : public IDirectMusicHeap {
    LOCALALLOC_NEWDELETE
public:
    PerformanceCounterWrapper(){
        InitializeCriticalSection(&m_csHeap);
        m_cRef = 1;
        m_pHeap = 0;
        m_bPhysicalHeap = false;
    }

    ~PerformanceCounterWrapper(){
        if(m_pHeap){
            m_pHeap->Release();
        }
        DeleteCriticalSection(&m_csHeap);
    }

    HRESULT Initialize(bool bIsPhysicalHeap, IDirectMusicHeap* pHeap){
        m_bPhysicalHeap = bIsPhysicalHeap;
        m_pHeap = pHeap;
        m_pHeap->AddRef();
        m_dwHeapAllocation = 0;
        m_dwHeapAllocationPeak = 0;
        m_dwHeapAllocationBlocks = 0;
        m_dwHeapAllocationBlocksPeak = 0;
        m_dwHeapAllocationRate = 0;
        m_dwHeapAllocationBlocksRate = 0;
        return S_OK;
    }

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj)
    {
        return E_NOTIMPL;
    }

    virtual ULONG STDMETHODCALLTYPE AddRef( void) 
        
    {
        return InterlockedIncrement(&m_cRef);
    }

    virtual ULONG STDMETHODCALLTYPE Release( void) 
    {
        ULONG cRef;
            
        cRef = InterlockedDecrement(&m_cRef);

        if (cRef == 0)
            delete this;

        return cRef;
    }

    LONG m_cRef;

    /*  IDirectMusicHeap */
    STDMETHOD(Allocate)   (THIS_ DWORD dwSize, PVOID* ppData){
        PVOID pData = Alloc(dwSize);
        if(!pData){
            return E_OUTOFMEMORY;
        }
        *ppData = pData;
        return S_OK;
    }

    STDMETHOD(Free)   (THIS_ PVOID pData){
        return Free2(pData);
    }

    void* Alloc(size_t cb){
        DWORD* pBlock = 0;
        HRESULT hr = m_pHeap->Allocate(cb, (PVOID*) & pBlock);
        if(FAILED(hr)){
            return NULL;
        }
        if(!pBlock){
            return NULL;
        }
        ASSERTMSG("Allocated memory must be DWORD aligned.", (((int) pBlock) & 3) == 0);
        EnterCriticalSection(&m_csHeap);
        m_dwHeapAllocation += cb;
        if(m_dwHeapAllocation > m_dwHeapAllocationPeak){
            m_dwHeapAllocationPeak = m_dwHeapAllocation;
        }
        ++m_dwHeapAllocationBlocks;
        if(m_dwHeapAllocationBlocks > m_dwHeapAllocationBlocksPeak){
            m_dwHeapAllocationBlocksPeak = m_dwHeapAllocationBlocks;
        }
        m_dwHeapAllocationRate += cb;
        ++m_dwHeapAllocationBlocksRate;
        LeaveCriticalSection(&m_csHeap);

        return pBlock;
    }

    STDMETHOD(GetSize)(THIS_ PVOID pData, LPDWORD pcbSize){
        return m_pHeap->GetSize(pData, pcbSize);
    }

    HRESULT Free2(void *pv)
    {
        HRESULT hr = S_OK;
        if(pv){
            DWORD cb;
            hr = m_pHeap->GetSize(pv, &cb);
            if(SUCCEEDED(hr)){
                EnterCriticalSection(&m_csHeap);
                m_dwHeapAllocation -= cb;
                --m_dwHeapAllocationBlocks;
                LeaveCriticalSection(&m_csHeap);
                hr = m_pHeap->Free(pv);
            }
        }
        else {
            hr = E_FAIL;
        }
        return hr;
    }

    void RegisterPerformanceCounters(){
        DMusicRegisterPerformanceCounter( Name("bytes"),
                                      DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                                      &m_dwHeapAllocation );
        DMusicRegisterPerformanceCounter( Name("bytes peak"),
                                      DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                                      &m_dwHeapAllocationPeak );
        DMusicRegisterPerformanceCounter( Name("allocations"),
                                      DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                                      &m_dwHeapAllocationBlocks );
        DMusicRegisterPerformanceCounter( Name("allocations peak"),
                                      DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                                      &m_dwHeapAllocationBlocksPeak );
        DMusicRegisterPerformanceCounter( Name("allocation byte rate"),
                                      DMCOUNT_EVENT  | DMCOUNT_ASYNC32,
                                      &m_dwHeapAllocationRate );
        DMusicRegisterPerformanceCounter( Name("allocation rate"),
                                      DMCOUNT_EVENT  | DMCOUNT_ASYNC32,
                                      &m_dwHeapAllocationBlocksRate );

    }

    void UnregisterPerformanceCounters(){
        DMusicUnregisterPerformanceCounter(Name("bytes"));
        DMusicUnregisterPerformanceCounter(Name("bytes peak"));
        DMusicUnregisterPerformanceCounter(Name("allocations"));
        DMusicUnregisterPerformanceCounter(Name("allocations peak"));
        DMusicUnregisterPerformanceCounter(Name("allocation byte rate"));
        DMusicUnregisterPerformanceCounter(Name("allocation rate"));
    }

    char* Name(const char* sBase){
        _snprintf(m_sNameBuffer, sizeof(m_sNameBuffer), "DM heap %s %s", m_bPhysicalHeap ? "physical" : "normal" , sBase);
        return m_sNameBuffer;
    }

private:
    CRITICAL_SECTION m_csHeap;
    DWORD m_dwHeapAllocation;
    DWORD m_dwHeapAllocationPeak;
    DWORD m_dwHeapAllocationBlocks;
    DWORD m_dwHeapAllocationBlocksPeak;
    DWORD m_dwHeapAllocationRate;
    DWORD m_dwHeapAllocationBlocksRate;

    bool m_bPhysicalHeap;

    char m_sNameBuffer[100];

    IDirectMusicHeap* m_pHeap;
};

HRESULT WrapPerformanceCountersAroundHeap(bool bPhysicalHeap, IDirectMusicHeap* pInsideHeap, IDirectMusicHeap** ppHeap)
{
    HRESULT hr = S_OK;
    PerformanceCounterWrapper* pHeap = new PerformanceCounterWrapper();
    if(!pHeap){
        hr = E_OUTOFMEMORY;
    }
    if(SUCCEEDED(hr)){
        hr = pHeap->Initialize(bPhysicalHeap, pInsideHeap);
        if(SUCCEEDED(hr)){
            *ppHeap = pHeap;
        }
        else {
            pHeap->Release();
        }
    }
    return hr;
}


#endif // IMPLEMENT_PERFORMANCE_COUNTERS

void* WINAPI DirectMusicAlloc(size_t cb){
    return DirectMusicAllocI(cb);
}

void WINAPI DirectMusicFree(void *pv){
    DirectMusicFreeI(pv);
}

void* WINAPI DirectMusicPhysicalAlloc(size_t dwSize){
    return DirectMusicPhysicalAllocI(dwSize);
}

void WINAPI DirectMusicPhysicalFree(void* lpAddress){
    DirectMusicPhysicalFreeI(lpAddress);
}

HRESULT WINAPI DirectMusicCreateDefaultHeap(IDirectMusicHeap** ppHeap)
{
    HRESULT hr = S_OK;
    DirectMusicDefaultHeap* pHeap = new DirectMusicDefaultHeap();
    if(!pHeap){
        hr = E_OUTOFMEMORY;
    }
    if(SUCCEEDED(hr)){
        hr = pHeap->Initialize();
        if(SUCCEEDED(hr)){
            *ppHeap = pHeap;
        }
        else {
            pHeap->Release();
        }
    }
    return hr;
}

HRESULT WINAPI DirectMusicCreateDefaultPhysicalHeap(IDirectMusicHeap** ppHeap)
{
    HRESULT hr = S_OK;
    DirectMusicDefaultPhysicalHeap* pHeap = new DirectMusicDefaultPhysicalHeap();
    if(!pHeap){
        hr = E_OUTOFMEMORY;
    }
    if(SUCCEEDED(hr)){
        hr = pHeap->Initialize();
        if(SUCCEEDED(hr)){
            *ppHeap = pHeap;
        }
        else {
            pHeap->Release();
        }
    }
    return hr;
}

HRESULT WINAPI DirectMusicCreateFixedSizeHeap(DWORD dwHeapSize, IDirectMusicHeap** ppHeap)
{
    HRESULT hr = S_OK;
    DirectMusicFixedSizeHeap2* pHeap = new DirectMusicFixedSizeHeap2();
    if(!pHeap){
        hr = E_OUTOFMEMORY;
    }
    if(SUCCEEDED(hr)){
        hr = pHeap->Initialize(dwHeapSize);
        if(SUCCEEDED(hr)){
            *ppHeap = pHeap;
        }
        else {
            pHeap->Release();
        }
    }
    return hr;
}

HRESULT WINAPI DirectMusicCreateFixedSizePhysicalHeap(DWORD dwHeapSize, IDirectMusicHeap** ppHeap)
{
    HRESULT hr = S_OK;
    DirectMusicFixedSizePhysicalHeap* pHeap = new DirectMusicFixedSizePhysicalHeap();
    if(!pHeap){
        hr = E_OUTOFMEMORY;
    }
    if(SUCCEEDED(hr)){
        hr = pHeap->Initialize(dwHeapSize);
        if(SUCCEEDED(hr)){
            *ppHeap = pHeap;
        }
        else {
            pHeap->Release();
        }
    }
    return hr;
}

HRESULT WINAPI DirectMusicInitializeFixedSizeHeaps(DWORD dwNormalHeapSize, DWORD dwPhysicalHeapSize,
											  LPDIRECTMUSICFACTORYFN pFactory)
{
	IDirectMusicHeap* pPhysicalHeap = NULL;
	IDirectMusicHeap* pNormalHeap = NULL;
	HRESULT hr = S_OK;
	if(SUCCEEDED(hr)){
		hr = DirectMusicCreateFixedSizeHeap(dwNormalHeapSize, &pNormalHeap);
	}
	if(SUCCEEDED(hr)){
		hr = DirectMusicCreateFixedSizePhysicalHeap(dwPhysicalHeapSize, &pPhysicalHeap);
	}
	if(SUCCEEDED(hr)){
		hr = DirectMusicInitializeEx(pNormalHeap, pPhysicalHeap, pFactory);
	}
	if(pPhysicalHeap){
		pPhysicalHeap->Release();
	}
	if(pNormalHeap){
		pNormalHeap->Release();
	}
	return hr;
}

#ifdef DBG

#define MODULE "DMUSIC"

// @globalv Section in WIN.INI for all debug settings
const char szDebugSection[] = "debug";

// @globalv Key in WIN.INI for our debug level. All messages with
// a level of this number or lower will be displayed.
const char szDebugKey[] = MODULE;

// @globalv Key in WIN.INI [debug] section which determines if assert calls
// DebugBreak or not
//
const char szAssertBreak[] = "AssertBreak";

// @globalv Prefix for all debug outputs
//
const char szDebugPrefix[] = MODULE ": ";

// @globalv The current debug level. 
static int giDebugLevel = 1;

// The current RIP level.

static int giRIPLevel = 0;

// @globalv Do asserts break?
static BOOL gfAssertBreak = 1;

// @func Sets the debug level from WIN.INI
// 

#ifdef DXAPI
void DebugInit(
    void)
{
    giDebugLevel = GetProfileInt(szDebugSection, szDebugKey, 0);
    gfAssertBreak = GetProfileInt(szDebugSection, szAssertBreak, 0);
    giRIPLevel = 0;
    // Nepotism at its finest
    DebugTrace(-1, "Debug level is %d\n", giDebugLevel);
}
#endif // DXAPI

// @func Send a debug trace out.
//
// @comm Any message with a level less than or equal to the current debug
// level will be displayed using the OutputDebugString API. This means either
// the IDE Debug window if the app is running in that context or WDEB if
// it's running.
//
static BOOL fNeedPrefix = TRUE;
void DebugTrace(
    int iDebugLevel,        // @parm The debug level of this message
    LPSTR pstrFormat,       // @parm A printf style format string
    ...)                    // @parm | ... | Variable paramters based on <p pstrFormat>
{
    char sz[512];

    if (iDebugLevel != -1 && iDebugLevel > giDebugLevel)
    {
        return;
    }

    va_list va;

    va_start(va, pstrFormat);
    vsprintf(sz, pstrFormat, va);
    va_end(va);

    if (fNeedPrefix)
    {
        OutputDebugStringA(szDebugPrefix);
    }
    
    OutputDebugStringA(sz);

    // Let them construct multiple piece trace outs w/o
    // prefixing each one
    //
    fNeedPrefix = FALSE;
    for (;*pstrFormat && !fNeedPrefix; ++pstrFormat)
    {
        if (*pstrFormat == '\n')
        {
            fNeedPrefix = TRUE;
        }
    }
#ifndef DXAPI
	if ((iDebugLevel >= 0) && (iDebugLevel <= giRIPLevel)) 
	{
		DebugBreak();
	}
#endif
}

void DebugAssert(
    LPSTR szExp, 
    LPSTR szFile, 
    ULONG ulLine)
{
    DebugTrace(-1, "ASSERT: \"%s\" %s@%lu\n", szExp, szFile, ulLine);
    if (gfAssertBreak)
    {
        DebugBreak();
    }
}

void WINAPI DirectMusicSetDebugLevel(int iDebugLevel, int iRIPLevel)
{
    giDebugLevel = iDebugLevel;
    giRIPLevel = iRIPLevel;
}

CMemTrackList g_MemTrackList[DMTRACK_MAX];

CMemTrackList::CMemTrackList()
{
    InitializeCriticalSection(&m_CriticalSection);
}

CMemTrackList::~CMemTrackList()
{
    DeleteCriticalSection(&m_CriticalSection);
}

void CMemTrackList::AddHead(CMemTrack* pMemTrack) 
{ 
    EnterCriticalSection(&m_CriticalSection);
    AList::AddHead((AListItem*)pMemTrack);
    LeaveCriticalSection(&m_CriticalSection);
}

CMemTrack* CMemTrackList::GetHead()
{
    CMemTrack *pHead;
    EnterCriticalSection(&m_CriticalSection);
    pHead = (CMemTrack*)AList::GetHead();
    LeaveCriticalSection(&m_CriticalSection);
    return pHead;
}

CMemTrack* CMemTrackList::RemoveHead() 
{
    CMemTrack *pHead;
    EnterCriticalSection(&m_CriticalSection);
    pHead = (CMemTrack *) AList::RemoveHead();
    LeaveCriticalSection(&m_CriticalSection);
    return pHead;
}

void CMemTrackList::Remove(CMemTrack* pMemTrack)
{
    EnterCriticalSection(&m_CriticalSection);
    AList::Remove((AListItem*)pMemTrack);
    LeaveCriticalSection(&m_CriticalSection);
}

LONG CMemTrackList::GetCount()
{
    LONG lCount;
    EnterCriticalSection(&m_CriticalSection);
    lCount = AList::GetCount();
    LeaveCriticalSection(&m_CriticalSection);
    return lCount;
}

#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
static LONG gDMusicClassInstanceCount[DMTRACK_MAX];
#endif

CMemTrack::CMemTrack(DWORD dwClass)
{
    m_dwClass = dwClass;
    if (dwClass < DMTRACK_MAX)
    {
        g_MemTrackList[dwClass].AddHead(this);
#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
        InterlockedIncrement(&gDMusicClassInstanceCount[m_dwClass]);
#endif

    }
}

CMemTrack::~CMemTrack()
{
    if (m_dwClass < DMTRACK_MAX)
    {
#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
        InterlockedDecrement(&gDMusicClassInstanceCount[m_dwClass]);
#endif
        g_MemTrackList[m_dwClass].Remove(this);
    }
}


//Don't forget to update enumClass in DEBUG.H when you update this gpNames array!!!
static char *gpNames[DMTRACK_MAX] = {
    "File Stream",
    "Memory Stream",
    "Stream Stream",
    "Segment",
    "Segment State",
    "Loader",
    "Performance",
    "Wave Track",
    "Wave",
    "Audio Path",
    "Audio Path Config",
    "Script",
    "Tool Graph",
    "Band",
    "Band Track",
    "DLS Collection",
    "Instrument",
    "Composer",
    "ChordMap",
    "Template",
    "SignPost Track",
    "ChordMap Track",
    "Lyrics Track",
    "Marker Track",
    "Parameter Control Track",
    "Segment Trigger Track",
    "Sequence Track",
    "Song",
    "System Exclusive Track",
    "Tempo Track",
    "Time Signature Track",
    "Container",
    "Synthesizer",
};

#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
static void RegisterDMusicObjectCounters(){
    for (DWORD dwI = 0; dwI < DMTRACK_MAX;dwI++)
    {
        char buf[200];
        _snprintf(buf,sizeof(buf),"DM allocated %ss", gpNames[dwI]);
        buf[sizeof(buf)-1] = 0;
        DMusicRegisterPerformanceCounter( buf,
                                  DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                                  &gDMusicClassInstanceCount[dwI] );
    }
}

static void UnregisterDMusicObjectCounters(){
    for (DWORD dwI = 0; dwI < DMTRACK_MAX;dwI++)
    {
        char buf[200];
        _snprintf(buf,sizeof(buf),"DM allocated %ss", gpNames[dwI]);
        buf[sizeof(buf)-1] = 0;
        DMusicUnregisterPerformanceCounter( buf );
    }
}

#endif // IMPLEMENT_PERFORMANCE_COUNTERS

long WINAPI DirectMusicMemCheck(DWORD dwMemType, char **ppName)

{
    if (dwMemType >= DMTRACK_MAX)
    {
        return -1;
    }
    if (ppName)
    {
        *ppName = gpNames[dwMemType];
    }
    return g_MemTrackList[dwMemType].GetCount();
}

void WINAPI DirectMusicDumpMemStats();

void WINAPI DirectMusicMemDump()
{
    DWORD dwI;
    DbgPrint("Objects Allocated:\n");
    for (dwI = 0; dwI < DMTRACK_MAX;dwI++)
    {
        if (g_MemTrackList[dwI].GetCount())
        {
            DbgPrint("%ld %s",g_MemTrackList[dwI].GetCount(),gpNames[dwI]);
            if (g_MemTrackList[dwI].GetCount() > 1)
            {
                DbgPrint("s\n");
            }
            else
            {
                DbgPrint("\n");
            }
        }
    }

    DirectMusicDumpMemStats();
}

#else
void WINAPI DirectMusicSetDebugLevel(int iDebugLevel, int iRIPLevel)
{
}
void WINAPI DirectMusicMemDump() 
{
}
long WINAPI DirectMusicMemCheck(DWORD dwMemType, char **pName) { return (long) 0; }

#endif

// Hooks to use an allocator from the application if there is one.
//

#include "..\shared\xalloc.h"

#ifdef DBG

// Define one of the following
// #define USE_SIZE_RECORDING_ALLOCATOR

// #define USE_LEAK_DETECTING_ALLOCATOR
// #define USE_XHEAP_WITH_LEAK_DETECTING_ALLOCATOR

// #define USE_XHEAP_ALLOCATOR

#define USE_C_ALLOCATOR


#else // non-debug

// #define USE_XHEAP_ALLOCATOR

#define USE_C_ALLOCATOR

#endif

interface IDirectMusicAlloc 
{
	virtual LPVOID STDMETHODCALLTYPE Alloc(THIS_ DWORD cb) = 0;
    
	virtual VOID STDMETHODCALLTYPE Free(THIS_ LPVOID pvFree) = 0;
};

#ifdef USE_SIZE_RECORDING_ALLOCATOR

class CDirectMusicAllocatorI : public IDirectMusicAlloc
{
public:
    CDirectMusicAllocatorI();

    STDMETHODIMP_(LPVOID) Alloc(THIS_ DWORD cb);
    STDMETHODIMP_(VOID)   Free(THIS_ LPVOID pvFree);

    bool EverCalled() const;

private:
    bool                    m_fEverCalled;
};

static CDirectMusicAllocatorI g_DefaultAllocator;
static IDirectMusicAlloc *g_pAllocI = &g_DefaultAllocator;

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicAllocatorI::CDirectMusicAllocatorI
//
//
CDirectMusicAllocatorI::CDirectMusicAllocatorI()    
    : m_fEverCalled(false)
{
}

static DWORD dwAllocated[1000];

void WINAPI DirectMusicDumpMemStats()

{
    DWORD dwIndex;
    for (dwIndex = 0; dwIndex < 1000; dwIndex++)
    {
        if (dwAllocated[dwIndex])
        {
            Trace(1,"%ld: %ld\n",dwIndex,dwAllocated[dwIndex]);
        }
    }
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicAllocatorI::Alloc
// CDirectMusicAllocatorI::Free
//
// Default allocator just uses malloc and free
//
// Also track if we've ever been called so we can disallow the user setting
// the allocator if there's already memory allocated.
//

STDMETHODIMP_(LPVOID) CDirectMusicAllocatorI::Alloc(THIS_ DWORD cb)
{
    if (!m_fEverCalled)
    {
        DWORD dwIndex;
        for (dwIndex = 0; dwIndex < 1000; dwIndex++)
        {
            dwAllocated[dwIndex] = 0;
        }
    }
    if (cb < 1000)
    {
        dwAllocated[cb]++;
    }
    m_fEverCalled = true;

    return malloc(cb);
}

STDMETHODIMP_(VOID) CDirectMusicAllocatorI::Free(THIS_ LPVOID pvAlloc)
{
    free(pvAlloc);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicAllocatorI::EverCalled
//
//
bool CDirectMusicAllocatorI::EverCalled() const
{
    return m_fEverCalled;
}

#endif // USE_SIZE_RECORDING_ALLOCATOR

#ifdef USE_LEAK_DETECTING_ALLOCATOR

#ifdef USE_XHEAP_WITH_LEAK_DETECTING_ALLOCATOR
  #define COMPILING_ROCKALL_LIBRARY
  #include "..\xheap\xheap\blendedheap.hpp"
  #include "..\xheap\xheap\smallheap.hpp"
  #include "..\xheap\xheap\fastheap.hpp"
  #include "..\xheap\xheap\debugheap.hpp"
  #include "..\xheap\xheap\dynamicdebugheap.hpp"
  #include "..\xheap\xheap\pageheap.hpp"
#endif

//////////////////////////////////////////////////////////////////////////////
//
// CAllocate
//
// Simple memory allocation class that can do diffs between two states
//
class CAllocate : public IDirectMusicAlloc
{
public:
    struct SnapBlock
    {
        void               *m_pBlock;                       // -> block as seen by app
        size_t              m_cb;                           // bytes asked for by app
        DWORD               m_RA;                           // Address of allocator
        DWORD               m_nSeq;                         // Allocation sequence number
        bool                m_fDiff;                        // After diff, true if this block
                                                            // is not present in the other
                                                            //  snapshot
        bool                m_fUser;                        // Used in 3-generation diff
    };

    struct SnapHeader
    {
        int                 m_nBlocks;                      // Number of blocks in snapshot
        DWORD               m_cbTotal;                      // Total allocated bytes (app)
        SnapBlock           m_rgBlocks[1];                  // The blocks
    };

    // Constructor
    //
    CAllocate();
    ~CAllocate();

    // Allocator implementation
    //
    STDMETHODIMP_(LPVOID) Alloc(DWORD cb);
    STDMETHODIMP_(VOID) Free(void *pv);

    // Utility functions
    //
    SnapHeader *Snapshot();
    static void FreeSnapshot(SnapHeader *ph);
    static void Diff(SnapHeader *ph1, SnapHeader *ph2);

    enum BlockSortKey
    {
        bsk_ReturnAddress,
        bsk_BlockAddress,
        bsk_Size
    };

    static void SortSnapshot(SnapHeader *ph, BlockSortKey bsk);

    bool EverCalled() const { return m_fEverCalled; }

    DWORD GetTotalAllocationCount() const { return m_nSeq; }

private:
    struct Block
    {
        Block              *m_pNext;                        // Next block in the chain
        size_t              m_cb;                           // Bytes (not including this header)
        DWORD               m_RA;                           // Address of requestor
        DWORD               m_nSeq;                         // Unique sequence number to id blocks
                                                            // with same address
    };

    CRITICAL_SECTION        m_cs;                           // Protect allocation list
    Block                  *m_pBlocks;                      // The list itself
    int                     m_nBlocks;                      // Number of outstanding allocations
    DWORD                   m_nSeq;                         // Next unique sequence number

    DWORD                   m_nBytes;
#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
    __int64                 m_llTotalBytes;                 // Total Bytes ever allocated
#endif

private:
    inline void EnterCS()       { EnterCriticalSection(&m_cs); }
    inline void LeaveCS()       { LeaveCriticalSection(&m_cs); }

    static int __cdecl SortRA(const void *p1, const void *p2);
    static int __cdecl SortBA(const void *p1, const void *p2);
    static int __cdecl SortSize(const void *p1, const void *p2);

    bool m_fEverCalled;

#ifdef USE_XHEAP_WITH_LEAK_DETECTING_ALLOCATOR
    // DEBUG_HEAP m_heap;
    // FAST_HEAP m_heap;
    // BLENDED_HEAP m_heap;
    // SMALL_HEAP m_heap;
#endif

};

static CAllocate g_DefaultAllocator;
static IDirectMusicAlloc *g_pAllocI = &g_DefaultAllocator;

//////////////////////////////////////////////////////////////////////////////
//
// GrovelRA
//
// This function is tailored to the way the allocator call chain is set up.
// It also will not work in retail.
//
#ifdef DBG
static DWORD __declspec(naked) GrovelRA()
{
    _asm
    {
        mov     eax, [ebp]
        mov     eax, [eax]
        mov     eax, [eax + 4]
        ret
    }
}

DWORD CalculatePagesSpanned(CAllocate::SnapHeader* pNew)
{
    g_DefaultAllocator.SortSnapshot(pNew, CAllocate::bsk_BlockAddress);
    DWORD dwNumPages = 0;
    DWORD dwCurrentPage = 0; // Assumes that blocks are never allocated out of the zero page.
    for(int i = 0; i < pNew->m_nBlocks; i++){
        CAllocate::SnapBlock* pBlock = & pNew->m_rgBlocks[i];
        DWORD dwBaseAddress = (DWORD) pBlock->m_pBlock;
        DWORD dwStartPage = (dwBaseAddress >> 12);
        DWORD dwEndPage = ((dwBaseAddress + pBlock->m_cb - 1) >> 12);
        dwNumPages += dwEndPage-dwStartPage+1;
        if(dwCurrentPage == dwStartPage){
            dwNumPages--;
        }
        dwCurrentPage = dwEndPage;
    }
    return dwNumPages;
}

#endif

#ifdef IMPLEMENT_PERFORMANCE_COUNTERS

static HRESULT
__stdcall DMPagesSpannedCallback
(
    PLARGE_INTEGER pliCounter,
    PLARGE_INTEGER pUnused
)
{
    CAllocate::SnapHeader* pNew = g_DefaultAllocator.Snapshot();
    DWORD dwPagesSpanned = CalculatePagesSpanned(pNew);
    g_DefaultAllocator.FreeSnapshot(pNew);

    pliCounter->HighPart = 0;
    pliCounter->LowPart = dwPagesSpanned;
    return XBDM_NOERR;
}

static HRESULT
__stdcall DMHeapDensityCallback
(
    PLARGE_INTEGER pliCounter,
    PLARGE_INTEGER pUnused
)
{
    CAllocate::SnapHeader* pNew = g_DefaultAllocator.Snapshot();
    DWORD dwBytesSpanned = CalculatePagesSpanned(pNew) << 12;
    DWORD dwBytesAllocated = pNew->m_cbTotal;
    g_DefaultAllocator.FreeSnapshot(pNew);

    DWORD dwDensity = dwBytesAllocated ? (dwBytesAllocated * 100 / dwBytesSpanned) : 0;

    pliCounter->HighPart = 0;
    pliCounter->LowPart = dwDensity;
    return XBDM_NOERR;
}

static HRESULT
__stdcall DMHeapDumpCallback
(
    PLARGE_INTEGER pliCounter,
    PLARGE_INTEGER pUnused
)
{
    
    static DWORD gCallCount;

    if(gCallCount++ % 10 == 0){
        DirectMusicDumpMemStats();
    }

    pliCounter->HighPart = 0;
    pliCounter->LowPart = gCallCount;
    return XBDM_NOERR;
}

#endif

#ifdef IMPLEMENT_PERFORMANCE_COUNTERS

extern "C" void DMusicRegisterPerformanceCounters(){
    RegisterDMusicObjectCounters();
    DMRegisterPMsgPerformanceCounters();
}

extern "C" void DMusicUnregisterPerformanceCounters(){
    UnregisterDMusicObjectCounters();
    DMUnregisterPMsgPerformanceCounters();
}

#endif


//////////////////////////////////////////////////////////////////////////////
//
// CAllocate::CAllocate
//
// 
CAllocate::CAllocate()
{
    InitializeCriticalSection(&m_cs);
    m_pBlocks = NULL;
    m_nBlocks = 0;
    m_nSeq = 0;
    m_fEverCalled = 0;
    m_nBytes = 0;

#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
    m_llTotalBytes = 0;
    DMusicRegisterPerformanceCounter( "DM heap bytes",
                                  DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                                  &m_nBytes );
    DMusicRegisterPerformanceCounter( "DM heap allocations",
                                  DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                                  &m_nBlocks );
    DMusicRegisterPerformanceCounter( "DM heap allocation byte rate",
                                  DMCOUNT_EVENT  | DMCOUNT_ASYNC64,
                                  &m_llTotalBytes );
    DMusicRegisterPerformanceCounter( "DM heap allocation rate",
                                  DMCOUNT_EVENT  | DMCOUNT_ASYNC32,
                                  &m_nSeq );
    DMusicRegisterPerformanceCounter("DM heap pages spanned",
        DMCOUNT_VALUE | DMCOUNT_SYNC,
        &DMPagesSpannedCallback);
    DMusicRegisterPerformanceCounter("DM heap density (0..100)",
        DMCOUNT_VALUE | DMCOUNT_SYNC,
        &DMHeapDensityCallback);
#if 0 // Seems to be called always, not just when visible in the UI -- perhaps an xbperfmon bug?
    DMusicRegisterPerformanceCounter("DM heap dump (look at debug output)",
        DMCOUNT_VALUE | DMCOUNT_SYNC,
        &DMHeapDumpCallback);
#endif
#endif
}

CAllocate::~CAllocate(){
#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
    DMusicUnregisterPerformanceCounter("DM heap bytes");
    DMusicUnregisterPerformanceCounter("DM heap allocations");
    DMusicUnregisterPerformanceCounter("DM heap allocation byte rate");
    DMusicUnregisterPerformanceCounter("DM heap allocation rate");
    DMusicUnregisterPerformanceCounter("DM heap pages spanned");
    DMusicUnregisterPerformanceCounter("DM heap density (0..100)");
#if 0 // Seems to be called always, not just when visible in the UI -- perhaps an xbperfmon bug?
    DMusicUnregisterPerformanceCounter("DM heap dump (look at debug output)");
#endif
#endif
}

//////////////////////////////////////////////////////////////////////////////
//
// CAllocate::Alloc
//
// Allocate method exposed to the app.
//
// cb [IN] - Requested block size
// 
// Returns a pointer to the block or NULL on out of memory.
// 
STDMETHODIMP_(LPVOID) CAllocate::Alloc(DWORD cb)
{
    m_fEverCalled = true;

#ifdef USE_XHEAP_WITH_LEAK_DETECTING_ALLOCATOR

    Block *pb = (Block*)m_heap.New(sizeof(Block) + cb);

#else

    Block *pb = (Block*)malloc(sizeof(Block) + cb);

#endif

    if (pb == NULL)
        return NULL;
    
    pb->m_cb = cb;
    pb->m_nSeq = m_nSeq++;

#ifdef DBG
    pb->m_RA = GrovelRA();
#else
    pb->m_RA = 0;
#endif

    EnterCS();

        pb->m_pNext = m_pBlocks;
        m_pBlocks = pb;

        m_nBlocks++;

        m_nBytes += cb;

        m_llTotalBytes += cb;

    LeaveCS();

    return (LPVOID)(pb + 1);
}

//////////////////////////////////////////////////////////////////////////////
//
// CAllocate::Free
//
// Free method exposed to the app.
//
// pv [IN] - The pointer to free; must have been allocated by this allocator
//           instance.
// 
STDMETHODIMP_(VOID) CAllocate::Free(void *pv)
{
    Block *pb = (Block*)pv;

    if (pb == NULL)
        return;

    pb--;

    EnterCS();

        Block *prev = NULL;
        Block *curr = m_pBlocks;

        while (curr && curr != pb)
        {
            prev = curr;
            curr = curr->m_pNext;
        }

        // If this fires then the block did not come from us.
        // 
        assert( curr );

        if (curr) 
        {
            if (prev)
            {
                prev->m_pNext = curr->m_pNext;
            }
            else
            {
                m_pBlocks = curr->m_pNext;
            }

            m_nBytes -= curr->m_cb;

#ifdef USE_XHEAP_WITH_LEAK_DETECTING_ALLOCATOR

            m_heap.Delete(pb);

#else
            free(pb);
#endif

            m_nBlocks--;
        }

    LeaveCS();
}

//////////////////////////////////////////////////////////////////////////////
//
// CAllocate::Snapshot
//
// Returns a pointer to a block of memory describing all the outstanding 
// allocations. This pointer must eventually be free'd with FreeSnapshot.
//
CAllocate::SnapHeader *CAllocate::Snapshot()
{
    EnterCS();

        int n = max(0, m_nBlocks - 1);

        SnapHeader *ph = (SnapHeader*)malloc(sizeof(SnapHeader) + n * sizeof(SnapBlock));
        if (ph)
        {
            ph->m_nBlocks = m_nBlocks;

            n = 0;

            DWORD cbTotal = 0;

            for (Block *pb = m_pBlocks; pb; pb = pb->m_pNext, n++)
            {
                ph->m_rgBlocks[n].m_cb = pb->m_cb;
                ph->m_rgBlocks[n].m_RA = pb->m_RA;
                ph->m_rgBlocks[n].m_nSeq = pb->m_nSeq;
                ph->m_rgBlocks[n].m_pBlock = (LPVOID)(pb + 1);

                cbTotal += pb->m_cb;
            }

            ph->m_cbTotal = cbTotal;

            assert( n == m_nBlocks );
        }

    LeaveCS();

    return ph;
}

//////////////////////////////////////////////////////////////////////////////
//
// CAllocate::FreeSnapshot
//
// Free's a shapshot.
//
void CAllocate::FreeSnapshot(SnapHeader *psh)
{
    free(psh);
}

//////////////////////////////////////////////////////////////////////////////
//
// CAllocate::Diff
//
// Generates the diff of two snapshots. Each entry in both snapshots will have
// the m_fDiff flag set to false if the block exists in both snapshots; else
// it will be set to true. 
//
// If ph1 was taken before ph2, then m_fDiff set on a ph1 entry means that 
// entry has since been free'd; while if the flag is set on a ph2 entry it
// means that the entry has since been allocated.
//
// This will resort both snapshots.
//
void CAllocate::Diff(SnapHeader *ph1, SnapHeader *ph2)
{
    int n1 = 0;
    int n2 = 0;

    SortSnapshot(ph1, bsk_BlockAddress);
    SortSnapshot(ph2, bsk_BlockAddress);

    while (n1 < ph1->m_nBlocks && n2 < ph2->m_nBlocks)
    {
        while (
            ph1->m_rgBlocks[n1].m_pBlock == ph2->m_rgBlocks[n2].m_pBlock &&
            n1 < ph1->m_nBlocks && n2 < ph2->m_nBlocks)
        {
            // This catches the case where the underlying allocator has
            // returned a previously used address.
            //
            bool fDiff = ph1->m_rgBlocks[n1].m_nSeq != ph2->m_rgBlocks[n2].m_nSeq;

            ph1->m_rgBlocks[n1++].m_fDiff = fDiff;
            ph2->m_rgBlocks[n2++].m_fDiff = fDiff;
        }

        while (
            ph1->m_rgBlocks[n1].m_pBlock < ph2->m_rgBlocks[n2].m_pBlock &&
            n1 < ph1->m_nBlocks)
        {
            ph1->m_rgBlocks[n1++].m_fDiff = true;
        }
        
        while (
            ph1->m_rgBlocks[n1].m_pBlock > ph2->m_rgBlocks[n2].m_pBlock &&
            n2 < ph2->m_nBlocks)
        {
            ph2->m_rgBlocks[n2++].m_fDiff = true;
        }
    }

    while (n1 < ph1->m_nBlocks)
    {
        ph1->m_rgBlocks[n1++].m_fDiff = true;
    }

    while (n2 < ph2->m_nBlocks)
    {
        ph2->m_rgBlocks[n2++].m_fDiff = true;
    }
}

//////////////////////////////////////////////////////////////////////////////
//
// CAllocate::SortSnapshot
//
// Sort the snapshot by the given key.
//
void CAllocate::SortSnapshot(SnapHeader *ph, BlockSortKey bsk)
{
    int (__cdecl *comp)(const void *, const void *) = NULL;

    switch (bsk)
    {
    case bsk_ReturnAddress:
        comp = SortRA;
        break;

    case bsk_BlockAddress:
        comp = SortBA;
        break;

    case bsk_Size:
        comp = SortSize;
        break;

    default:
        assert( false );
    }

    if (comp)
    {
        qsort(ph->m_rgBlocks, ph->m_nBlocks, sizeof(SnapBlock), comp);
    }
}


//////////////////////////////////////////////////////////////////////////////
//
// CAllocate::SortXxx
//
// Key compare functions for qsort
//
int __cdecl CAllocate::SortRA(const void *pv1, const void *pv2)
{
    const SnapBlock *pb1 = (const SnapBlock *)pv1;
    const SnapBlock *pb2 = (const SnapBlock *)pv2;

    if (pb1->m_RA < pb2->m_RA)
        return -1;
    else if (pb1->m_RA > pb2->m_RA)
        return 1;

    return 0;
}

int __cdecl CAllocate::SortBA(const void *pv1, const void *pv2)
{
    const SnapBlock *pb1 = (const SnapBlock *)pv1;
    const SnapBlock *pb2 = (const SnapBlock *)pv2;

    if (pb1->m_pBlock < pb2->m_pBlock)
        return -1;
    else if (pb1->m_pBlock > pb2->m_pBlock)
        return 1;

    return 0;
}

int __cdecl CAllocate::SortSize(const void *pv1, const void *pv2)
{
    const SnapBlock *pb1 = (const SnapBlock *)pv1;
    const SnapBlock *pb2 = (const SnapBlock *)pv2;

    if (pb1->m_cb < pb2->m_cb)
        return -1;
    else if (pb1->m_cb > pb2->m_cb)
        return 1;

    return 0;
}

static CAllocate::SnapHeader* pMiddle;
static CAllocate::SnapHeader* pNew;

static void PrintGarbage(const CAllocate::SnapBlock* pGarbageBlock, DWORD totalNum, DWORD totalMem){
    DbgPrint(" Allocator: 0x%08x instance( addr 0x%08x, seq %d) %5d blocks, %7d bytes average %7d bytes total\n",
        pGarbageBlock->m_RA, pGarbageBlock->m_pBlock, pGarbageBlock->m_nSeq, totalNum, totalNum ? totalMem / totalNum : totalMem, totalMem);
}

void WINAPI DirectMusicDumpMemStats()
{
    if(g_pAllocI != &g_DefaultAllocator){
        return; // Allocator has been replaced.
    }

    CAllocate::SnapHeader* pAncient;
    pAncient = pMiddle;
    pMiddle = pNew;
    pNew = g_DefaultAllocator.Snapshot();

    DbgPrint("Total allocated memory: %d bytes, %d active blocks, %d allocations\n",
        pNew->m_cbTotal, pNew->m_nBlocks, g_DefaultAllocator.GetTotalAllocationCount());

    // Calculate how many heap blocks are covered (for trying to minimize lacy heaps)
    {
        DWORD dwNumPages = CalculatePagesSpanned(pNew);
        DbgPrint("DMusic heap allocations span %d pages.\n", dwNumPages);
    }

    // Find 20 largest groups of objects..

    {
        DbgPrint("DMusic heap most frequent allocations:\n");
        g_DefaultAllocator.SortSnapshot(pNew, CAllocate::bsk_ReturnAddress);
        // How many different allocators?
        DWORD dwRA = 0;
        DWORD dwNumRA = 0;
        for(int i = 0; i < pNew->m_nBlocks; i++){
            if(pNew->m_rgBlocks[i].m_RA == dwRA){
            }
            else{
                dwNumRA++;
                dwRA = pNew->m_rgBlocks[i].m_RA;
            }   
        }
        DbgPrint("number of distinct allocators: %d\n", dwNumRA);
        struct RACount {
            DWORD m_dwRA;
            DWORD m_dwCount;
            static int __cdecl SortByCount(const void* pA, const void* pB){
                return ((RACount*) pA)->m_dwCount - ((RACount*) pB)->m_dwCount;
            }
        };
        RACount* pRACount = new RACount[dwNumRA];
        dwRA = 0;
        DWORD dwCurrentRA = 0;
        for(int i = 0; i < pNew->m_nBlocks; i++){
            if(pNew->m_rgBlocks[i].m_RA == dwRA){
                pRACount[dwCurrentRA].m_dwCount++;
            }
            else{
                if(dwRA != 0){
                    dwCurrentRA++;
                }
                dwRA = pNew->m_rgBlocks[i].m_RA; 
                pRACount[dwCurrentRA].m_dwRA = dwRA;
                pRACount[dwCurrentRA].m_dwCount = 1;
            }   
        }
        qsort(pRACount,dwNumRA,sizeof(RACount),RACount::SortByCount);

        for(DWORD i = 0; i < dwNumRA && i < 20; i++){
            RACount* pRAC = &pRACount[dwNumRA-(i+1)];
            DbgPrint("%2d: allocator: %8x instances: %4d\n",
                i, pRAC->m_dwRA, pRAC->m_dwCount);
        }
        delete [] pRACount;
    }

#ifdef TRACK_LONG_TERM_MEMORY_GROWTH

    if(!pAncient){
        DbgPrint("Not enough snapshots to generate long-term memory growth report yet.\n");
        return; // Not enough snapshots yet.
    }

    // Anything that's not in pAncient, but is in Middle and New, is new garbage

    g_DefaultAllocator.Diff(pAncient, pNew);
    for(int i = 0; i < pNew->m_nBlocks; i++){
        pNew->m_rgBlocks[i].m_fUser = pNew->m_rgBlocks[i].m_fDiff;
    }

    g_DefaultAllocator.Diff(pMiddle, pNew);

    // If m_fUser is true, that means block was not in old.
    // If m_fDiff is false, that means the block was in middle
    // Therefore it's probably new garbage

    // Sort by allocator

    g_DefaultAllocator.SortSnapshot(pNew, CAllocate::bsk_ReturnAddress);

    bool bPrintHeader = true;

    size_t totalMem = 0;
    size_t totalNum = 0;
    size_t totalAllocators = 0;

    CAllocate::SnapBlock* pGarbageBlock = 0;

    DbgPrint("Recently created long-term data, possibly garbage:\n");
    for(int i = 0; i < pNew->m_nBlocks; i++){
        CAllocate::SnapBlock* pBlock = & pNew->m_rgBlocks[i];
        if( pBlock->m_fUser && ! pBlock->m_fDiff) {
            if(bPrintHeader){
                bPrintHeader = false;
            }

            if(!pGarbageBlock || pGarbageBlock->m_RA != pBlock->m_RA){
                if(pGarbageBlock){
                    totalAllocators++;
                    PrintGarbage(pGarbageBlock, totalNum, totalMem);
                }
                pGarbageBlock = pBlock;
                totalNum = 0;
                totalMem = 0;
            }
            totalNum++;
            totalMem += pBlock->m_cb;
        }
    }
    if(pGarbageBlock){
        totalAllocators++;
        PrintGarbage(pGarbageBlock, totalNum, totalMem);
    }
    if(totalAllocators){
        DbgPrint(" end of report.\n");
    }
    else {
        DbgPrint(" no new blocks found.\n");
    }

#endif // TRACK_LONG_TERM_MEMORY_GROWTH

    if(pAncient){
        g_DefaultAllocator.FreeSnapshot(pAncient);
    }
}

#endif // USE_LEAK_DETECTING_ALLOCATOR

#ifdef USE_XHEAP_ALLOCATOR

#define COMPILING_ROCKALL_LIBRARY
#include "..\xheap\xheap\blendedheap.hpp"
#include "..\xheap\xheap\smallheap.hpp"
#include "..\xheap\xheap\fastheap.hpp"
#include "..\xheap\xheap\debugheap.hpp"
#include "..\xheap\xheap\dynamicdebugheap.hpp"
#include "..\xheap\xheap\pageheap.hpp"

static FAST_HEAP gDMusicHeap;


void WINAPI DirectMusicDumpMemStats()

{
    Trace(1,"DirectMusicDumpMemStats: Using xheap.\n");
}

////////////////////////////////////////////////////////////////////////////////
//
// Internal alloc/free routines to be called from operator new/delete
//
//
void* DirectMusicAllocI(size_t cb)
{
    return gDMusicHeap.New(cb);
}

void DirectMusicFreeI(void *pv)
{
    gDMusicHeap.Delete(pv);
}


#endif // USE_XHEAP_ALLOCATOR

#ifdef USE_C_ALLOCATOR

void WINAPI DirectMusicDumpMemStats()

{
    Trace(1,"DirectMusicDumpMemStats: Using C allocator.\n");
}

#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
extern "C" void DMusicRegisterPerformanceCounters(){
    if(gpDMHeap){
        // We know this is really a PerformanceCounterWrapper
        ((PerformanceCounterWrapper*)gpDMHeap)->RegisterPerformanceCounters();
    }
    if(gpDMPhysicalHeap){
        // We know this is really a PerformanceCounterWrapper
        ((PerformanceCounterWrapper*)gpDMPhysicalHeap)->RegisterPerformanceCounters();
    }

#ifdef DBG
    RegisterDMusicObjectCounters();
#endif
    DMRegisterPMsgPerformanceCounters();
}

extern "C" void DMusicUnregisterPerformanceCounters(){
    if(gpDMHeap){
        // We know this is really a PerformanceCounterWrapper
        ((PerformanceCounterWrapper*)gpDMHeap)->UnregisterPerformanceCounters();
    }
    if(gpDMPhysicalHeap){
        // We know this is really a PerformanceCounterWrapper
        ((PerformanceCounterWrapper*)gpDMPhysicalHeap)->UnregisterPerformanceCounters();
    }
#ifdef DBG
    UnregisterDMusicObjectCounters();
#endif
    DMUnregisterPMsgPerformanceCounters();
}

#endif // IMPLEMENT_PERFORMANCE_COUNTERS

#endif // USE_C_ALLOCATOR

#if ! ( defined(USE_XHEAP_ALLOCATOR) || defined(USE_C_ALLOCATOR) )

////////////////////////////////////////////////////////////////////////////////
//
// DirectMusicSetAllocator 
//
// Allow the app to specify an interface to manage memory allocations.
//
// This function must be called once, and it must be called before 
//    InitAudioX. This prevents allocations being made via malloc
//    that will attempt to be free'd through the interface and vice
//    versa.
//
//
HRESULT WINAPI DirectMusicSetAllocator(IDirectMusicAlloc *pAlloc)
{
    if (g_pAllocI != &g_DefaultAllocator)
    {
        return DMUS_E_NOT_INIT;         // Someone has already set us
    }
    
    if (g_DefaultAllocator.EverCalled())
    {
        return DMUS_E_NOT_INIT;         // Too late, there's already memory allocated
    }

    if (!pAlloc)
    {
        return E_INVALIDARG;
    }
    
    g_pAllocI = pAlloc;

    return S_OK;
}



////////////////////////////////////////////////////////////////////////////////
//
// Internal alloc/free routines to be called from operator new/delete
//
//
void* DirectMusicAllocI(size_t cb)
{
    return g_pAllocI->Alloc(cb);
}

void DirectMusicFreeI(void *pv)
{
    g_pAllocI->Free(pv);
}


#endif // ! USE_XHEAP_ALLOCATOR
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\dmprfdll.cpp ===
//
// dmprfdll.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Note: Dll entry points as well as class factory implementations.
//

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

#include "pchime.h"

/*#ifdef XBOX
#include <xtl.h>
#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define _WINGDI_
#endif
#include <objbase.h> // Need IClassFactory
#include <initguid.h>
#include <mmsystem.h>
#include <dsoundp.h>

#include "urlmonhelper.h"
#include "debug.h"
#define ASSERT	assert 
#include "debug.h"
#include "dmprfdll.h"
#include "dmperf.h"
#include "dmsegobj.h"
#include "song.h"
#include "seqtrack.h"
#include "sysextrk.h"
#include "tempotrk.h"
#include "tsigtrk.h"
#include "marktrk.h"
#include "wavtrack.h"
#include "segtrtrk.h"
#include "lyrictrk.h"
#include "ParamTrk.h"
#include "dmgraph.h"
#include "dmusicc.h"
#include "dmusici.h"
#include "dmusicf.h"
#include "..\shared\oledll.h"
#include "..\dmstyle\dmstylep.h"
#include "..\dmband\dmbndtrk.h"
#include "..\shared\dmstrm.h"
#include "..\shared\Validate.h"
#include "dmksctrl.h"
#include "dmscriptautguids.h"
#include "audpath.h"
#include "dsoundp.h"            // For IDirectSoundPrivate
#ifdef XBOX
#include "..\shared\xcreate.h"
#endif
*/
long g_cComponent = 0;
long g_cLock = 0;
#ifdef DXAPI
bool g_fInitCS = false;
CRITICAL_SECTION g_CritSec;


//////////////////////////////////////////////////////////////////////
// Globals
// Dll's hModule
//
HMODULE g_hModule = NULL;

// Count of active components and class factory server locks
//


// Flags DMI_F_xxx from dmusicp.h
//
DWORD g_fFlags;

static char const g_szDoEmulation[] = "DoEmulation";

// CClassFactory::QueryInterface
//
HRESULT __stdcall
CClassFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

// CClassFactory::AddRef
//
ULONG __stdcall
CClassFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

// CClassFactory::Release
//
ULONG __stdcall
CClassFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}


CClassFactory::CClassFactory(DWORD dwClassType)

{
    m_dwClassType = dwClassType;
	m_cRef = 1;
	InterlockedIncrement(&g_cLock);
}

CClassFactory::~CClassFactory()

{
	InterlockedDecrement(&g_cLock);
}

// CClassFactory::CreateInstance
//
//
HRESULT __stdcall
CClassFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }


    switch (m_dwClassType)
    {
    case CLASS_PERFORMANCE:
        {
            CPerformance *pInst;
            NEWCATCH(pInst,CPerformance)
            if (pInst == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }

            hr = pInst->QueryInterface(iid, ppv);
        }
        break;
    case CLASS_GRAPH:
        {
            CGraph *pInst = new CGraph;
            if (pInst == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }

            hr = pInst->QueryInterface(iid, ppv);
            pInst->Release();
        }
        break;
    case CLASS_SEGMENT:
        {
            CSegment *pInst = new CSegment;
            if (pInst == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }
            // The segment is initialized with a ref count of 0, so QI will set it to 1.
            hr = pInst->QueryInterface(iid, ppv);
        }
        break;
    case CLASS_SONG:
        {
            CSong *pInst = new CSong;
            if (pInst == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }

            hr = pInst->QueryInterface(iid, ppv);
            pInst->Release();
        }
        break;
    case CLASS_AUDIOPATH:
        {
            CAudioPathConfig *pInst;
            NEWCATCH(pInst,CAudioPathConfig);

            if (pInst == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }

            hr = pInst->QueryInterface(iid, ppv);
            pInst->Release();
        }
        break;
    case CLASS_SEQTRACK:
        {
            CSeqTrack *pInst;
            NEWCATCH(pInst,CSeqTrack);

            if (pInst == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }

            hr = pInst->QueryInterface(iid, ppv);
            pInst->Release();
        }
        break;
    case CLASS_SYSEXTRACK:
        {
            CSysExTrack *pInst;
            NEWCATCH(pInst,CSysExTrack);
            if (pInst == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }

            hr = pInst->QueryInterface(iid, ppv);
            pInst->Release();
        }
        break;
    case CLASS_TEMPOTRACK:
        {
            CTempoTrack *pInst;
            NEWCATCH(pInst,CTempoTrack);

            if (pInst == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }

            hr = pInst->QueryInterface(iid, ppv);
        }
        break;
    case CLASS_TIMESIGTRACK:
        {
            CTimeSigTrack *pInst;
            NEWCATCH(pInst,CTimeSigTrack);

            if (pInst == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }

            hr = pInst->QueryInterface(iid, ppv);
        }
        break;
    case CLASS_MARKERTRACK:
        {
            CMarkerTrack *pInst;
            NEWCATCH(pInst,CMarkerTrack);
    
            if (pInst == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }
            hr = pInst->QueryInterface(iid, ppv);
        }
        break;
    case CLASS_WAVETRACK:
        {
            CWavTrack *pInst;
            NEWCATCH(pInst,CWavTrack);

            if (pInst == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }
            hr = pInst->QueryInterface(iid, ppv);
            pInst->Release();
        }
        break;
    case CLASS_TRIGGERTRACK:
        {
            try
            {
		        hr = TrackHelpCreateInstance<CSegTriggerTrack>(pUnknownOuter, iid, ppv);
            }
            catch( ... )
            {
                hr = E_OUTOFMEMORY;
            }
        }
        break;
    case CLASS_LYRICSTRACK:
        {
            try
            {
		        hr = TrackHelpCreateInstance<CLyricsTrack>(pUnknownOuter, iid, ppv);
            }
            catch( ... )
            {
                hr = E_OUTOFMEMORY;
            }
        }
        break;
    case CLASS_PARAMSTRACK:
        {
            try
            {
		        hr = TrackHelpCreateInstance<CParamControlTrack>(pUnknownOuter, iid, ppv);
            }
            catch( ... )
            {
                hr = E_OUTOFMEMORY;
            }
        }
        break;
    case CLASS_SEGSTATE:
        {
            CSegState *pInst = new CSegState;
            if (pInst == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }

            hr = pInst->QueryInterface(iid, ppv);
            pInst->Release();
        }
    }
    return hr;
}

// CClassFactory::LockServer
//
HRESULT __stdcall
CClassFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}
#else // DXAPI

//////////////////////////////////////////////////////////////////////
// DirectMusicTempoTrackCreate

STDAPI DirectMusicTempoTrackCreate(REFIID iid, void ** ppDMT )
{
    CTempoTrack *pInst = new CTempoTrack;
    if (pInst) 
    {
        return pInst->QueryInterface(iid, ppDMT);
    }
    return E_OUTOFMEMORY;
}

//////////////////////////////////////////////////////////////////////
// DirectMusicMarkerTrackCreate

STDAPI DirectMusicMarkerTrackCreate(REFIID iid, void ** ppDMT )
{
    CMarkerTrack *pInst = new CMarkerTrack;
    if (pInst) 
    {
        return pInst->QueryInterface(iid, ppDMT);
    }
    return E_OUTOFMEMORY;
}

//////////////////////////////////////////////////////////////////////
// DirectMusicSegmentCreate

STDAPI DirectMusicSegmentCreate(REFIID iid, void ** ppDMSeg)

{
    CSegment *pInst = new CSegment;
    if (pInst) 
    {
        return pInst->QueryInterface(iid, ppDMSeg);
    }
    return E_OUTOFMEMORY;
}

//////////////////////////////////////////////////////////////////////
// DirectMusicPerformanceCreate

STDAPI DirectMusicPerformanceCreate(REFIID iid, void ** ppDMP)
{
    CPerformance *pInst = new CPerformance;
    if (pInst) 
    {
        return pInst->QueryInterface(iid, ppDMP);
    }
    return E_OUTOFMEMORY;
}

//////////////////////////////////////////////////////////////////////
// DirectMusicWaveTrackCreate

STDAPI DirectMusicWaveTrackCreate(REFIID iid, void ** ppDMT)
{
    CWavTrack *pInst = new CWavTrack;
    if (pInst) 
    {
        HRESULT hr = pInst->QueryInterface(iid, ppDMT);
        pInst->Release();
        return hr;
    }
    return E_OUTOFMEMORY;
}

//////////////////////////////////////////////////////////////////////
// DirectMusicSongCreate

STDAPI DirectMusicSongCreate(REFIID iid, void ** ppSong)
{
    CSong *pInst = new CSong;
    if (pInst)
    {
        HRESULT hr = pInst->QueryInterface(iid, ppSong);
        pInst->Release();
        return hr;
    }
    return E_OUTOFMEMORY;
}

//////////////////////////////////////////////////////////////////////
// DirectMusicAudioPathConfigCreate

STDAPI DirectMusicAudioPathConfigCreate(REFIID iid, void ** ppPath)
{
    CAudioPathConfig *pInst = new CAudioPathConfig;
    if (pInst)
    {
        HRESULT hr = pInst->QueryInterface(iid, ppPath);
        pInst->Release();
        return hr;
    }
    return E_OUTOFMEMORY;
}

//////////////////////////////////////////////////////////////////////
// DirectMusicSysexTrackCreate

STDAPI DirectMusicSysexTrackCreate(REFIID iid, void ** ppTrack)
{
    CSysExTrack *pInst = new CSysExTrack;
    if (pInst)
    {
        HRESULT hr = pInst->QueryInterface(iid, ppTrack);
        pInst->Release();
        return hr;
    }
    return E_OUTOFMEMORY;
}

//////////////////////////////////////////////////////////////////////
// DirectMusicGraphCreate

STDAPI DirectMusicGraphCreate(REFIID iid, void ** ppGraph)
{
    CGraph *pInst = new CGraph;
    if (pInst)
    {
        HRESULT hr = pInst->QueryInterface(iid, ppGraph);
        pInst->Release();
        return hr;
    }
    return E_OUTOFMEMORY;
}

//////////////////////////////////////////////////////////////////////
// DirectMusicSeqTrackCreate

STDAPI DirectMusicSeqTrackCreate(REFIID iid, void ** ppTrack)
{
    CSeqTrack *pInst = new CSeqTrack;
    if (pInst)
    {
        HRESULT hr = pInst->QueryInterface(iid, ppTrack);
        pInst->Release();
        return hr;
    }
    return E_OUTOFMEMORY;
}

//////////////////////////////////////////////////////////////////////
// DirectMusicLyricsTrackCreate

STDAPI DirectMusicLyricsTrackCreate(REFIID iid, void ** ppTrack)
{
    return TrackHelpCreateInstance<CLyricsTrack>(NULL, iid, ppTrack);
}

//////////////////////////////////////////////////////////////////////
// DirectMusicTriggerTrackCreate

STDAPI DirectMusicTriggerTrackCreate(REFIID iid, void ** ppTrack)
{
    return TrackHelpCreateInstance<CSegTriggerTrack>(NULL, iid, ppTrack);
}

//////////////////////////////////////////////////////////////////////
// DirectMusicTimeSigTrackCreate

STDAPI DirectMusicTimeSigTrackCreate(REFIID iid, void ** ppTrack)
{
    CTimeSigTrack *pInst = new CTimeSigTrack;
    if (pInst) 
    {
        return pInst->QueryInterface(iid, ppTrack);
    }
    return E_OUTOFMEMORY;
}

//////////////////////////////////////////////////////////////////////
// DirectMusicParamsTrackCreate

STDAPI DirectMusicParamsTrackCreate(REFIID iid, void ** ppTrack)
{
    return TrackHelpCreateInstance<CParamControlTrack>(NULL, iid, ppTrack);
}

#endif // !DXAPI

#ifdef DXAPI

// Version information for our class
//
TCHAR g_szDMPerformanceFriendlyName[]    = TEXT("DirectMusicPerformance");
TCHAR g_szDMPerformanceVerIndProgID[]    = TEXT("Microsoft.DirectMusicPerformance");
TCHAR g_szDMPerformanceProgID[]          = TEXT("Microsoft.DirectMusicPerformance.1");

TCHAR g_szDMSegmentFriendlyName[]    = TEXT("DirectMusicSegment");
TCHAR g_szDMSegmentVerIndProgID[]    = TEXT("Microsoft.DirectMusicSegment");
TCHAR g_szDMSegmentProgID[]          = TEXT("Microsoft.DirectMusicSegment.1");

TCHAR g_szDMSegmentStateFriendlyName[]    = TEXT("DirectMusicSegmentState");
TCHAR g_szDMSegmentStateVerIndProgID[]    = TEXT("Microsoft.DirectMusicSegmentState");
TCHAR g_szDMSegmentStateProgID[]          = TEXT("Microsoft.DirectMusicSegmentState.1");

TCHAR g_szSongFriendlyName[]    = TEXT("DirectMusicSong");
TCHAR g_szSongVerIndProgID[]    = TEXT("Microsoft.DirectMusicSong");
TCHAR g_szSongProgID[]          = TEXT("Microsoft.DirectMusicSong.1");

TCHAR g_szAudioPathFriendlyName[]    = TEXT("DirectMusicAudioPath");
TCHAR g_szAudioPathVerIndProgID[]    = TEXT("Microsoft.DirectMusicAudioPath");
TCHAR g_szAudioPathProgID[]          = TEXT("Microsoft.DirectMusicAudioPath.1");

TCHAR g_szDMGraphFriendlyName[]    = TEXT("DirectMusicGraph");
TCHAR g_szDMGraphVerIndProgID[]    = TEXT("Microsoft.DirectMusicGraph");
TCHAR g_szDMGraphProgID[]          = TEXT("Microsoft.DirectMusicGraph.1");

TCHAR g_szDMSeqTrackFriendlyName[]    = TEXT("DirectMusicSeqTrack");
TCHAR g_szDMSeqTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicSeqTrack");
TCHAR g_szDMSeqTrackProgID[]          = TEXT("Microsoft.DirectMusicSeqTrack.1");

TCHAR g_szDMSysExTrackFriendlyName[]    = TEXT("DirectMusicSysExTrack");
TCHAR g_szDMSysExTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicSysExTrack");
TCHAR g_szDMSysExTrackProgID[]          = TEXT("Microsoft.DirectMusicSysExTrack.1");

TCHAR g_szDMTempoTrackFriendlyName[]    = TEXT("DirectMusicTempoTrack");
TCHAR g_szDMTempoTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicTempoTrack");
TCHAR g_szDMTempoTrackProgID[]          = TEXT("Microsoft.DirectMusicTempoTrack.1");

TCHAR g_szDMTimeSigTrackFriendlyName[]    = TEXT("DirectMusicTimeSigTrack");
TCHAR g_szDMTimeSigTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicTimeSigTrack");
TCHAR g_szDMTimeSigTrackProgID[]          = TEXT("Microsoft.DirectMusicTimeSigTrack.1");

TCHAR g_szMarkerTrackFriendlyName[]    = TEXT("DirectMusicMarkerTrack");
TCHAR g_szMarkerTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicMarkerTrack");
TCHAR g_szMarkerTrackProgID[]          = TEXT("Microsoft.DirectMusicMarkerTrack.1");

TCHAR g_szWaveTrackFriendlyName[]    = TEXT("DirectMusicWaveTrack");
TCHAR g_szWaveTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicWaveTrack");
TCHAR g_szWaveTrackProgID[]          = TEXT("Microsoft.DirectMusicWaveTrack.1");

TCHAR g_szSegTriggerTrackFriendlyName[]    = TEXT("DirectMusicSegTriggerTrack");
TCHAR g_szSegTriggerTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicSegTriggerTrack");
TCHAR g_szSegTriggerTrackProgID[]          = TEXT("Microsoft.DirectMusicSegTriggerTrack.1");

TCHAR g_szLyricsTrackFriendlyName[]    = TEXT("DirectMusicLyricsTrack");
TCHAR g_szLyricsTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicLyricsTrack");
TCHAR g_szLyricsTrackProgID[]          = TEXT("Microsoft.DirectMusicLyricsTrack.1");

TCHAR g_szParamControlTrackFriendlyName[]    = TEXT("DirectMusicParamControlTrack");
TCHAR g_szParamControlTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicParamControlTrack");
TCHAR g_szParamControlTrackProgID[]          = TEXT("Microsoft.DirectMusicParamControlTrack.1");

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
// Standard calls needed to be an inproc server

//////////////////////////////////////////////////////////////////////
// DllCanUnloadNow

STDAPI DllCanUnloadNow()
{
    if (g_cComponent || g_cLock) {
        return S_FALSE;
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// DllGetClassObject

STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
	IUnknown* pIUnknown = NULL;
    DWORD dwTypeID = 0;

    if(clsid == CLSID_DirectMusicPerformance)
    {
        dwTypeID = CLASS_PERFORMANCE;
    }
    else if(clsid == CLSID_DirectMusicSegment) 
    {
        dwTypeID = CLASS_SEGMENT;
    }
    else if(clsid == CLSID_DirectMusicSong) 
    {
        dwTypeID = CLASS_SONG;
    }
    else if(clsid == CLSID_DirectMusicAudioPathConfig) 
    {
        dwTypeID = CLASS_AUDIOPATH;
    }
    else if(clsid == CLSID_DirectMusicSeqTrack) 
    {
        dwTypeID = CLASS_SEQTRACK;
    }
    else if(clsid == CLSID_DirectMusicGraph) 
    {
        dwTypeID = CLASS_GRAPH;
    }
    else if(clsid == CLSID_DirectMusicSysExTrack) 
    {
        dwTypeID = CLASS_SYSEXTRACK;
    }
    else if(clsid == CLSID_DirectMusicTempoTrack) 
    {
        dwTypeID = CLASS_TEMPOTRACK;
    }
    else if(clsid == CLSID_DirectMusicTimeSigTrack) 
    {
        dwTypeID = CLASS_TIMESIGTRACK;
    }
    else if(clsid == CLSID_DirectMusicMarkerTrack) 
    {
        dwTypeID = CLASS_MARKERTRACK;
    }
    else if(clsid == CLSID_DirectMusicWaveTrack) 
    {
        dwTypeID = CLASS_WAVETRACK;
    }
    else if(clsid == CLSID_DirectMusicSegmentTriggerTrack)
    {
        dwTypeID = CLASS_TRIGGERTRACK;
    }
    else if(clsid == CLSID_DirectMusicLyricsTrack)
    {
        dwTypeID = CLASS_LYRICSTRACK;
    }
    else if(clsid == CLSID_DirectMusicParamControlTrack)
    {
        dwTypeID = CLASS_PARAMSTRACK;
    }
    else if(clsid == CLSID_DirectMusicSegmentState)
    {
        dwTypeID = CLASS_SEGSTATE;
    }
    else
    {
		return CLASS_E_CLASSNOTAVAILABLE;
	}
    pIUnknown = static_cast<IUnknown*> (new CClassFactory(dwTypeID));
    if(pIUnknown) 
    {
        HRESULT hr = pIUnknown->QueryInterface(iid, ppv);
        pIUnknown->Release();
        return hr;
    }
	return E_OUTOFMEMORY;
}

//////////////////////////////////////////////////////////////////////
// DllUnregisterServer

STDAPI DllUnregisterServer()
{
    UnregisterServer(CLSID_DirectMusicPerformance,
                     g_szDMPerformanceFriendlyName,
                     g_szDMPerformanceVerIndProgID,
                     g_szDMPerformanceProgID);

    UnregisterServer(CLSID_DirectMusicSegment,
                     g_szDMSegmentFriendlyName,
                     g_szDMSegmentVerIndProgID,
                     g_szDMSegmentProgID);

    UnregisterServer(CLSID_DirectMusicSegmentState,
                     g_szDMSegmentStateFriendlyName,
                     g_szDMSegmentStateVerIndProgID,
                     g_szDMSegmentStateProgID);

    UnregisterServer(CLSID_DirectMusicSong,
                     g_szSongFriendlyName,
                     g_szSongVerIndProgID,
                     g_szSongProgID);

    UnregisterServer(CLSID_DirectMusicAudioPathConfig,
                     g_szAudioPathFriendlyName,
                     g_szAudioPathVerIndProgID,
                     g_szAudioPathProgID);
    
    UnregisterServer(CLSID_DirectMusicGraph,
                     g_szDMGraphFriendlyName,
                     g_szDMGraphVerIndProgID,
                     g_szDMGraphProgID);

    UnregisterServer(CLSID_DirectMusicSeqTrack,
                     g_szDMSeqTrackFriendlyName,
                     g_szDMSeqTrackVerIndProgID,
                     g_szDMSeqTrackProgID);

    UnregisterServer(CLSID_DirectMusicSysExTrack,
                     g_szDMSysExTrackFriendlyName,
                     g_szDMSysExTrackVerIndProgID,
                     g_szDMSysExTrackProgID);

    UnregisterServer(CLSID_DirectMusicTempoTrack,
                     g_szDMTempoTrackFriendlyName,
                     g_szDMTempoTrackVerIndProgID,
                     g_szDMTempoTrackProgID);

    UnregisterServer(CLSID_DirectMusicTimeSigTrack,
                     g_szDMTimeSigTrackFriendlyName,
                     g_szDMTimeSigTrackVerIndProgID,
                     g_szDMTimeSigTrackProgID);

    UnregisterServer(CLSID_DirectMusicMarkerTrack,
                     g_szMarkerTrackFriendlyName,
                     g_szMarkerTrackVerIndProgID,
                     g_szMarkerTrackProgID);

    UnregisterServer(CLSID_DirectMusicWaveTrack,
                     g_szWaveTrackFriendlyName,
                     g_szWaveTrackVerIndProgID,
                     g_szWaveTrackProgID);

    UnregisterServer(CLSID_DirectMusicSegmentTriggerTrack,
                     g_szSegTriggerTrackFriendlyName,
                     g_szSegTriggerTrackVerIndProgID,
                     g_szSegTriggerTrackProgID);

    UnregisterServer(CLSID_DirectMusicLyricsTrack,
                     g_szLyricsTrackFriendlyName,
                     g_szLyricsTrackVerIndProgID,
                     g_szLyricsTrackProgID);

    UnregisterServer(CLSID_DirectMusicParamControlTrack,
                     g_szParamControlTrackFriendlyName,
                     g_szParamControlTrackVerIndProgID,
                     g_szParamControlTrackProgID);
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// DllRegisterServer

STDAPI DllRegisterServer()
{
	RegisterServer(g_hModule,
                   CLSID_DirectMusicPerformance,
                     g_szDMPerformanceFriendlyName,
                     g_szDMPerformanceVerIndProgID,
                     g_szDMPerformanceProgID);

	RegisterServer(g_hModule,
				   CLSID_DirectMusicSegment,
                     g_szDMSegmentFriendlyName,
                     g_szDMSegmentVerIndProgID,
                     g_szDMSegmentProgID);

	RegisterServer(g_hModule,
				   CLSID_DirectMusicSegmentState,
                     g_szDMSegmentStateFriendlyName,
                     g_szDMSegmentStateVerIndProgID,
                     g_szDMSegmentStateProgID);

	RegisterServer(g_hModule,
				   CLSID_DirectMusicSong,
                     g_szSongFriendlyName,
                     g_szSongVerIndProgID,
                     g_szSongProgID);

	RegisterServer(g_hModule,
				   CLSID_DirectMusicAudioPathConfig,
                     g_szAudioPathFriendlyName,
                     g_szAudioPathVerIndProgID,
                     g_szAudioPathProgID);

	RegisterServer(g_hModule,
				   CLSID_DirectMusicGraph,
                     g_szDMGraphFriendlyName,
                     g_szDMGraphVerIndProgID,
                     g_szDMGraphProgID);

	RegisterServer(g_hModule,
				   CLSID_DirectMusicSeqTrack,
                     g_szDMSeqTrackFriendlyName,
                     g_szDMSeqTrackVerIndProgID,
                     g_szDMSeqTrackProgID);

	RegisterServer(g_hModule,
				   CLSID_DirectMusicSysExTrack,
                     g_szDMSysExTrackFriendlyName,
                     g_szDMSysExTrackVerIndProgID,
                     g_szDMSysExTrackProgID);

	RegisterServer(g_hModule,
				   CLSID_DirectMusicTempoTrack,
                     g_szDMTempoTrackFriendlyName,
                     g_szDMTempoTrackVerIndProgID,
                     g_szDMTempoTrackProgID);

	RegisterServer(g_hModule,
				   CLSID_DirectMusicTimeSigTrack,
                     g_szDMTimeSigTrackFriendlyName,
                     g_szDMTimeSigTrackVerIndProgID,
                     g_szDMTimeSigTrackProgID);
	RegisterServer(g_hModule,
				   CLSID_DirectMusicMarkerTrack,
                     g_szMarkerTrackFriendlyName,
                     g_szMarkerTrackVerIndProgID,
                     g_szMarkerTrackProgID);
	RegisterServer(g_hModule,
				   CLSID_DirectMusicWaveTrack,
                     g_szWaveTrackFriendlyName,
                     g_szWaveTrackVerIndProgID,
                     g_szWaveTrackProgID);
	RegisterServer(g_hModule,
				   CLSID_DirectMusicSegmentTriggerTrack,
                     g_szSegTriggerTrackFriendlyName,
                     g_szSegTriggerTrackVerIndProgID,
                     g_szSegTriggerTrackProgID);
	RegisterServer(g_hModule,
				   CLSID_DirectMusicLyricsTrack,
                     g_szLyricsTrackFriendlyName,
                     g_szLyricsTrackVerIndProgID,
                     g_szLyricsTrackProgID);
	RegisterServer(g_hModule,
				   CLSID_DirectMusicParamControlTrack,
                     g_szParamControlTrackFriendlyName,
                     g_szParamControlTrackVerIndProgID,
                     g_szParamControlTrackProgID);
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Standard Win32 DllMain

//////////////////////////////////////////////////////////////////////
// DllMain

#ifdef DBG
static char* aszReasons[] =
{
    "DLL_PROCESS_DETACH",
    "DLL_PROCESS_ATTACH",
    "DLL_THREAD_ATTACH",
    "DLL_THREAD_DETACH"
};
const DWORD nReasons = (sizeof(aszReasons) / sizeof(char*));
#endif

BOOL APIENTRY DllMain(HINSTANCE hModule,
                      DWORD dwReason,
                      void *lpReserved)
{
    static int nReferenceCount = 0;

#ifdef DBG
    if (dwReason < nReasons)
    {
        TraceI(0, "DllMain: %s\n", (LPSTR)aszReasons[dwReason]);
    }
    else
    {
        TraceI(0, "DllMain: Unknown dwReason <%u>\n", dwReason);
    }
#endif

    switch(dwReason)
    {
        case DLL_PROCESS_ATTACH:
            if (++nReferenceCount == 1)
            {
				g_fInitCS = false;
				try
				{
					InitializeCriticalSection(&g_CritSec);
                    InitializeCriticalSection(&WaveItem::st_WaveListCritSect);
				}
				catch( ... )
				{
                    TraceI(0, "InitializeCriticalSection failed.\n");
					return FALSE;
				}
				g_fInitCS = true;

                #ifdef DBG
                    DebugInit();
                #endif

                if (!DisableThreadLibraryCalls(hModule))
                {
                    TraceI(1, "DisableThreadLibraryCalls failed.\n");
                }

                g_hModule = hModule;
            }
            break;

        case DLL_PROCESS_DETACH:
            if (--nReferenceCount == 0)
            {
                TraceI(-1, "Unloading g_cLock %d  g_cComponent %d\n", g_cLock, g_cComponent);
			    if (g_fInitCS)
                {
                    DeleteCriticalSection(&g_CritSec);
                    DeleteCriticalSection(&WaveItem::st_WaveListCritSect);
                }
                // Assert if we still have some objects hanging around
                assert(g_cComponent == 0);
                assert(g_cLock == 0);
            }
            break;
            
    }
        
    return TRUE;
}

#endif // DXAPI
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\dmcreate.cpp ===
#include "pchime.h"
#include <xdbg.h>

CRITICAL_SECTION		g_APICriticalSection;	
long					g_lCritSecCount;

/*#include <xtl.h>
#include <dmusicc.h>
#include <dmusici.h>

extern "C" ULONG __cdecl DbgPrint(PCH Format, ...);
#include "..\shared\xcreate.h"
#include "..\shared\dmscriptautguids.h"*/

void DbgPrintGUID ( REFIID riid)
{
    DbgPrint("(0x%08lX,0x%04X,0x%04X,0x%02X,0x%02X,0x%02X,0x%02X,0x%02X,0x%02X,0x%02X,0x%02X)",
        riid.Data1,
        riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2],
        riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7]);
}

class CClassTracker 
{
public:
    CClassTracker() { m_pNext = NULL; m_dwCount = 1; m_fSaved = FALSE; }
    CClassTracker *     m_pNext;
    DWORD               m_dwCount;
    char *              m_pszClassName;
    char *              m_pszFunctionName;
    char *              m_pszComment;
    BOOL                m_fSaved;
};

static CClassTracker *g_pClassList = NULL;

void InsertClass(char *pszClassName, char *pszFunctionName, char *pszComment)

{
    CClassTracker *pScan = g_pClassList;
    for (;pScan;pScan = pScan->m_pNext)
    {
        if (pScan->m_pszClassName == pszClassName)
        {
            pScan->m_dwCount++;
            return;
        }
    }
    pScan = new CClassTracker;
    if (pScan)
    {
        pScan->m_pszClassName = pszClassName;
        pScan->m_pszFunctionName = pszFunctionName;
        pScan->m_pszComment = pszComment;
        pScan->m_pNext = g_pClassList;
        g_pClassList = pScan;
    }
}

void CreateClassLinkFile(char *pszFileName)

{
    HANDLE hFile = CreateFile(pszFileName, GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, 
        FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile != INVALID_HANDLE_VALUE)
    {
		DWORD dwBytesWritten;
        char *szHeader[6] = {
            "HRESULT DirectMusicCreateInstance(REFCLSID clsid,\n",
            "                                  LPUNKNOWN pUnkOuter,\n", 
            "                                  REFIID iid,\n", 
            "                                  LPVOID *ppvInterface)\n",
            "{\n",
            "    HRESULT hr = E_FAIL;\n"
        };
        for (DWORD dwI = 0; dwI < 6; dwI++)
        {
            WriteFile(hFile,szHeader[dwI],strlen(szHeader[dwI]),&dwBytesWritten,NULL);
        }
        CClassTracker *pScan = g_pClassList;
        BOOL fFirst = TRUE;
        for (;;)
        {
            CClassTracker *pBestSoFar = NULL;
            DWORD dwMaxCount = 0;
            for (pScan = g_pClassList;pScan;pScan = pScan->m_pNext)
            {
                if (!pScan->m_fSaved)
                {
                    if (pScan->m_dwCount > dwMaxCount)
                    {
                        pBestSoFar = pScan;
                        dwMaxCount = pScan->m_dwCount;
                    }
                }
            }
            if (!pBestSoFar)
            {
                break;
            }
            pBestSoFar->m_fSaved = TRUE;
			if (fFirst)
			{
				WriteFile(hFile,"    ",4,&dwBytesWritten,NULL);
			}
            if (!fFirst)
            {
                WriteFile(hFile,"    else ",9,&dwBytesWritten,NULL);
            }
            fFirst = FALSE;
            char szData[400];
            wsprintfA(szData,"if (clsid == %s)\n    {\n        // %s.\n        hr = %s;\n    }\n",
                pBestSoFar->m_pszClassName,pBestSoFar->m_pszComment,pBestSoFar->m_pszFunctionName);
            WriteFile(hFile,szData,strlen(szData),&dwBytesWritten,NULL);
        }
        char *szTail[2] = {
            "    return hr;\n",
            "}\n", 
        };
        for (dwI = 0; dwI < 2; dwI++)
        {
            WriteFile(hFile,szTail[dwI],strlen(szTail[dwI]),&dwBytesWritten,NULL);
        }
        CloseHandle(hFile);
    }
}

#define BASEMIDI
#define ADDSEGMENT
#define ADDWAVE
#define ADDSTYLE
#define ADDCOMPOSER
#define ADDMELODY
#define ADDSCRIPT
#define ADDMISC

LPDIRECTMUSICFACTORYFN gDirectMusicFactoryFn;
void DirectMusicInitializedCheck();

HRESULT WINAPI DirectMusicCreateInstance(REFCLSID clsid, LPUNKNOWN pUnkOuter, REFIID iid, LPVOID *ppvInterface)
{
    DirectMusicInitializedCheck();
    return (*gDirectMusicFactoryFn)(clsid, pUnkOuter, iid, ppvInterface);
}

STDAPI_(HRESULT) DirectMusicRegisterFactory(LPDIRECTMUSICFACTORYFN pFactory){
    ASSERTMSG("Another factory is already registered.", !gDirectMusicFactoryFn);
    gDirectMusicFactoryFn = pFactory;
    return S_OK;
}

HRESULT CALLBACK DirectMusicDefaultFactory(REFCLSID clsid, LPUNKNOWN pUnkOuter, REFIID iid, LPVOID *ppvInterface)
{
    HRESULT hr = E_FAIL;
    static fFirstTime = TRUE;
    if (fFirstTime)
    {
        InitializeCriticalSection(&g_APICriticalSection);
		g_lCritSecCount = 0;
        fFirstTime = FALSE;
    }
    char * pszClassName = "";
    char * pszFunctionName = "";
    char * pszComment = "";
#ifdef BASEMIDI
/*    if (clsid == CLSID_DirectMusic)
    {
        pszClassName = "CLSID_DirectMusic";
        pszFunctionName = "DirectMusicCreate(iid,ppvInterface)";
        pszComment = "DirectMusic: core timing and port code is always required";
        hr = DirectMusicCreate(iid,ppvInterface);
    }
    else */
    if (clsid == CLSID_DirectMusicCollection)
    {
        pszClassName = "CLSID_DirectMusicCollection";
        pszFunctionName = "DirectMusicCollectionCreate(iid,ppvInterface)";
        pszComment = "DLS Collection: manages a DLS file - always required for MIDI + DLS";
        hr = DirectMusicCollectionCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicSynth)
    {
        pszClassName = "CLSID_DirectMusicSynth";
        pszFunctionName = "DirectMusicSynthCreate(iid,ppvInterface)";
        pszComment = "Synthesizer: controls the hardware synthesizer - always required";
        hr = DirectMusicSynthCreate(iid,ppvInterface);
    }
#endif
#ifdef ADDSEGMENT
    else if (clsid == CLSID_DirectMusicFileStream)
    {
        // File Stream - used to read content from disk
        pszClassName = "CLSID_DirectMusicFileStream";
        pszFunctionName = "DirectMusicFileStreamCreate(iid,ppvInterface)";
        pszComment = "File Stream - used to read content from disk";
        hr = DirectMusicFileStreamCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicStreamStream)
    {
        // Stream wrapper - used to read content from app supplied IStream
        pszClassName = "CLSID_DirectMusicStreamStream";
        pszFunctionName = "DirectMusicStreamStreamCreate(iid,ppvInterface)";
        pszComment = "Stream wrapper - used to read content from app supplied IStream";
        hr = DirectMusicStreamStreamCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicMemStream)
    {
        // Memory Stream - used to read content from memory
        pszClassName = "CLSID_DirectMusicMemStream";
        pszFunctionName = "DirectMusicMemStreamCreate(iid,ppvInterface)";
        pszComment = "Memory Stream - used to read content from memory";
        hr = DirectMusicMemStreamCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicSegment)
    {
        // Segment - primary playback mechanism - always required
        pszClassName = "CLSID_DirectMusicSegment";
        pszFunctionName = "DirectMusicSegmentCreate(iid,ppvInterface)";
        pszComment = "Segment - primary playback mechanism - always required";
        hr = DirectMusicSegmentCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicLoader)
    {
        pszClassName = "CLSID_DirectMusicLoader";
        pszFunctionName = "DirectMusicLoaderCreate(iid,ppvInterface)";
        pszComment = "Loader: required to read files from disk and link objects. May be replaced by application";
        hr = DirectMusicLoaderCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicTempoTrack)
    {
        pszClassName = "CLSID_DirectMusicTempoTrack";
        pszFunctionName = "DirectMusicTempoTrackCreate(iid,ppvInterface)";
        pszComment = "Tempo Track - defines tempo changes, always required for music";
        hr = DirectMusicTempoTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicTimeSigTrack)
    {
        pszClassName = "CLSID_DirectMusicTimeSigTrack";
        pszFunctionName = "DirectMusicTimeSigTrackCreate(iid,ppvInterface)";
        pszComment = "Time Signature Track - defines time signature in segments, always required for music synchronization";
        hr = DirectMusicTimeSigTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicBandTrack)
    {
        pszClassName = "CLSID_DirectMusicBandTrack";
        pszFunctionName = "DirectMusicBandTrackCreate(iid,ppvInterface)";
        pszComment = "Band Track - manages one or more bands - always required for any MIDI + DLS playback";
        hr = DirectMusicBandTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicPerformance)
    {
        pszClassName = "CLSID_DirectMusicPerformance";
        pszFunctionName = "DirectMusicPerformanceCreate(iid,ppvInterface)";
        pszComment = "Performance - segment playback framework, always required";
        hr = DirectMusicPerformanceCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicBand)
    {
        pszClassName = "CLSID_DirectMusicBand";
        pszFunctionName = "DirectMusicBandCreate(iid,ppvInterface)";
        pszComment = "Band - manages downloading of DLS instruments as well as volume and pan presets - always required for MIDI + DLS";
        hr = DirectMusicBandCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicSeqTrack)
    {
        pszClassName = "CLSID_DirectMusicSeqTrack";
        pszFunctionName = "DirectMusicSeqTrackCreate(iid,ppvInterface)";
        pszComment = "Sequence Track: plays straight MIDI sequences";
        hr = DirectMusicSeqTrackCreate(iid,ppvInterface);
    }
#endif
#ifdef ADDWAVE
    else if (clsid == CLSID_DirectSoundWave)
    {
        pszClassName = "CLSID_DirectSoundWave";
        pszFunctionName = "DirectSoundWaveCreate(iid,ppvInterface)";
        pszComment = "Wave: represents the file version of a wave - required if wave files are used";
        hr = DirectSoundWaveCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicWaveTrack)
    {
        pszClassName = "CLSID_DirectMusicWaveTrack";
        pszFunctionName = "DirectMusicWaveTrackCreate(iid,ppvInterface)";
        pszComment = "Wave Track - plays one or more waves";
        hr = DirectMusicWaveTrackCreate(iid,ppvInterface);
    }
#endif
#ifdef ADDSTYLE
    else if (clsid == CLSID_DirectMusicChordTrack)
    {
        pszClassName = "CLSID_DirectMusicChordTrack";
        pszFunctionName = "DirectMusicChordTrackCreate(iid,ppvInterface)";
        pszComment = "Chord Track - used for style playback";
        hr = DirectMusicChordTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicCommandTrack)
    {
        pszClassName = "CLSID_DirectMusicCommandTrack";
        pszFunctionName = "DirectMusicCommandTrackCreate(iid,ppvInterface)";
        pszComment = "Groove Track - used to store groove levels for style playback";
        hr = DirectMusicCommandTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicStyleTrack)
    {
        pszClassName = "CLSID_DirectMusicStyleTrack";
        pszFunctionName = "DirectMusicStyleTrackCreate(iid,ppvInterface)";
        pszComment = "Style Track - selects style for playback";
        hr = DirectMusicStyleTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicPatternTrack)
    {
        pszClassName = "CLSID_DirectMusicPatternTrack";
        pszFunctionName = "DirectMusicPatternTrackCreate(iid,ppvInterface)";
        pszComment = "Pattern Track - plays patterns with variations tranposed to chord progression";
        hr = DirectMusicPatternTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicMotifTrack)
    {
        pszClassName = "CLSID_DirectMusicMotifTrack";
        pszFunctionName = "DirectMusicMotifTrackCreate(iid,ppvInterface)";
        pszComment = "Motif Track - mechanism for playing a style motif segment";
        hr = DirectMusicMotifTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicStyle)
    {
        pszClassName = "CLSID_DirectMusicStyle";
        pszFunctionName = "DirectMusicStyleCreate(iid,ppvInterface)";
        pszComment = "Style - style playback object, represents a specific style type";
        hr = DirectMusicStyleCreate(iid,ppvInterface);
    }
#endif
#ifdef ADDMELODY
    else if (clsid == CLSID_DirectMusicMelodyFormulationTrack)
    {
        pszClassName = "CLSID_DirectMusicMelodyFormulationTrack";
        pszFunctionName = "DirectMusicMelodyFormulationTrackCreate(iid,ppvInterface)";
        pszComment = "Melody Formulation Track - define the shape of a melody";
        hr = DirectMusicMelodyFormulationTrackCreate(iid,ppvInterface);
    }
#endif
#ifdef ADDCOMPOSER
    else if (clsid == CLSID_DirectMusicComposer)
    {
        pszClassName = "CLSID_DirectMusicComposer";
        pszFunctionName = "DirectMusicComposerCreate(iid,ppvInterface)";
        pszComment = "Composer: creates playback segments and autotransitions from chordmaps and template segments";
        hr = DirectMusicComposerCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicChordMap)
    {
        pszClassName = "CLSID_DirectMusicChordMap";
        pszFunctionName = "DirectMusicChordMapCreate(iid,ppvInterface)";
        pszComment = "ChordMap - defines chords to create chord progressions and transitions on the fly";
        hr = DirectMusicChordMapCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicChordMapTrack)
    {
        pszClassName = "CLSID_DirectMusicChordMapTrack";
        pszFunctionName = "DirectMusicChordMapTrackCreate(iid,ppvInterface)";
        pszComment = "ChordMap Track - defines ChordMap to be used to compose a chord track";
        hr = DirectMusicChordMapTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicSignPostTrack)
    {
        pszClassName = "CLSID_DirectMusicSignPostTrack";
        pszFunctionName = "DirectMusicSignPostTrackCreate(iid,ppvInterface)";
        pszComment = "SignPost Track - defines phrasing to be used to compose a chord track";
        hr = DirectMusicSignPostTrackCreate(iid,ppvInterface);
    }
#endif
#ifdef ADDSCRIPT
    else if (clsid == CLSID_AutDirectMusicAudioPath)
    {
        pszClassName = "CLSID_AutDirectMusicAudioPath";
        pszFunctionName = "DirectMusicAutAudioPathCreate(pUnkOuter,iid,ppvInterface)";
        pszComment = "Audio Path Automation - used by scripting to control a style directly";
        hr = DirectMusicAutAudioPathCreate(pUnkOuter,iid,ppvInterface);
    }
    else if (clsid == CLSID_AutDirectMusicAudioPathConfig)
    {
        pszClassName = "CLSID_AutDirectMusicAudioPathConfig";
        pszFunctionName = "DirectMusicAutAudioPathConfigCreate(pUnkOuter,iid,ppvInterface)";
        pszComment = "Audio Path Configuration Automation - used by scripting to control an audiopath configuration";
        hr = DirectMusicAutAudioPathConfigCreate(pUnkOuter,iid,ppvInterface);
    }
    else if (clsid == CLSID_AutDirectMusicSong)
    {
        pszClassName = "CLSID_AutDirectMusicSong";
        pszFunctionName = "DirectMusicAutSongCreate(pUnkOuter,iid,ppvInterface)";
        pszComment = "Song Automation - used by scripting to control a song";
        hr = DirectMusicAutSongCreate(pUnkOuter,iid,ppvInterface);
    }
    else if (clsid == CLSID_AutDirectMusicPerformance)
    {
        pszClassName = "CLSID_AutDirectMusicPerformance";
        pszFunctionName = "DirectMusicAutPerformanceCreate(pUnkOuter,iid,ppvInterface)";
        pszComment = "Performance Automation - used by scripting to control a performance";
        hr = DirectMusicAutPerformanceCreate(pUnkOuter,iid,ppvInterface);
    }
    else if (clsid == CLSID_AutDirectMusicSegment)
    {
        pszClassName = "CLSID_AutDirectMusicSegment";
        pszFunctionName = "DirectMusicAutSegmentCreate(pUnkOuter,iid,ppvInterface)";
        pszComment = "Segment Automation: used by scripting to control a segment";
        hr = DirectMusicAutSegmentCreate(pUnkOuter,iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicScript)
    {
        pszClassName = "CLSID_DirectMusicScript";
        pszFunctionName = "DirectMusicScriptCreate(iid,ppvInterface)";
        pszComment = "Script: Manages a script and all embedded and linked content";
        hr = DirectMusicScriptCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicScriptTrack)
    {
        pszClassName = "CLSID_DirectMusicScriptTrack";
        pszFunctionName = "DirectMusicScriptTrackCreate(iid,ppvInterface)";
        pszComment = "Script Track: Sequences script routines to play in time with the music";
        hr = DirectMusicScriptTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicContainer)
    {
        pszClassName = "CLSID_DirectMusicContainer";
        pszFunctionName = "DirectMusicContainerCreate(iid,ppvInterface)";
        pszComment = "Container: storage container for multiple DirectMusic file objects. Always used in scripting";
        hr = DirectMusicContainerCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_AutDirectMusicSegmentState)
    {
        pszClassName = "CLSID_AutDirectMusicSegmentState";
        pszFunctionName = "CAutDirectMusicSegmentState(iid,ppvInterface)";
        pszComment = "A helper scripting object that implements IDispatch";
        hr = AutDirectMusicSegmentStateCreate(pUnkOuter,iid,ppvInterface);
    }
#endif
#ifdef ADDMISC
    else if (clsid == CLSID_DirectMusicMuteTrack)
    {
        pszClassName = "CLSID_DirectMusicMuteTrack";
        pszFunctionName = "DirectMusicMuteTrackCreate(iid,ppvInterface)";
        pszComment = "Mute Track - controls muting on sequence, style, and other event generating tracks";
        hr = DirectMusicMuteTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicMarkerTrack)
    {
        pszClassName = "CLSID_DirectMusicMarkerTrack";
        pszFunctionName = "DirectMusicMarkerTrackCreate(iid,ppvInterface)";
        pszComment = "Marker Track - indicates segment start and alignment points";
        hr = DirectMusicMarkerTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicSong)
    {
        pszClassName = "CLSID_DirectMusicSong";
        pszFunctionName = "DirectMusicSongCreate(iid,ppvInterface)";
        pszComment = "Song: manages the composition and playback of a set of segments";
        hr = DirectMusicSongCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicAudioPathConfig)
    {
        pszClassName = "CLSID_DirectMusicAudioPathConfig";
        pszFunctionName = "DirectMusicAudioPathConfigCreate(iid,ppvInterface)";
        pszComment = "Audio Path Configuration: file representation of an audiopath";
        hr = DirectMusicAudioPathConfigCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicGraph)
    {
        pszClassName = "CLSID_DirectMusicGraph";
        pszFunctionName = "DirectMusicGraphCreate(iid,ppvInterface)";
        pszComment = "Tool Graph: manages a set of Tools (MIDI Processors)";
        hr = DirectMusicGraphCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicSysExTrack)
    {
        pszClassName = "CLSID_DirectMusicSysExTrack";
        pszFunctionName = "DirectMusicSysexTrackCreate(iid,ppvInterface)";
        pszComment = "System Exclusive Track: sends system exclusive messages to the synthesizer";
        hr = DirectMusicSysexTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicSegmentTriggerTrack)
    {
        pszClassName = "CLSID_DirectMusicSegmentTriggerTrack";
        pszFunctionName = "DirectMusicTriggerTrackCreate(iid,ppvInterface)";
        pszComment = "Segment Trigger Track: triggers additional segments";
        hr = DirectMusicTriggerTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicLyricsTrack)
    {
        pszClassName = "CLSID_DirectMusicLyricsTrack";
        pszFunctionName = "DirectMusicLyricsTrackCreate(iid,ppvInterface)";
        pszComment = "Lyrics Track: sends lyrics";
        hr = DirectMusicLyricsTrackCreate(iid,ppvInterface);
    }
    else if (clsid == CLSID_DirectMusicParamControlTrack)
    {
        pszClassName = "CLSID_DirectMusicParamControlTrack";
        pszFunctionName = "DirectMusicParamsTrackCreate(iid,ppvInterface)";
        pszComment = "Parameter Control Track: provides realtime control of audio and MIDI effects";
        hr = DirectMusicParamsTrackCreate(iid,ppvInterface);
    }
#endif
//    else
//    {
//        DbgPrint("Creating Unknown object ");
//        DbgPrintGUID(clsid);
//        DbgPrint(" Failed\n");
//        return hr;
//    }
    if (SUCCEEDED(hr))
    {
        InsertClass(pszClassName, pszFunctionName, pszComment);
#ifdef SPEW
        DbgPrint("Creating %s object with interface ",pszClassName);
        DbgPrintGUID(iid);
        DbgPrint(" Succeeded\n");
#endif
    }
    else
    {
        DbgPrint("Creating \"%s\" object with interface ",pszClassName);
        DbgPrintGUID(iid);
        DbgPrint("And clsid: ");
        DbgPrintGUID(clsid);
        DbgPrint(" Failed, returned error: %lx\n",hr);
    }
    return hr;
}

char *GetClassName(REFGUID clsid)

{
    if (clsid == CLSID_DirectMusic)
    {
        return "DirectMusic";
    }
    else if (clsid == CLSID_DirectMusicCollection)
    {
        return "DLS Collection";
    }
    else if (clsid == CLSID_DirectMusicSynth)
    {
        return "Microsoft Synth";
    }
    else if (clsid == CLSID_DirectMusicFileStream)
    {
        return "File Stream";
    }
    else if (clsid == CLSID_DirectMusicStreamStream)
    {
        return "Stream Wrapper";
    }
    else if (clsid == CLSID_DirectMusicMemStream)
    {
        return "Memory Stream";
    }
    else if (clsid == CLSID_DirectMusicSegment)
    {
        return "Segment";
    }
    else if (clsid == CLSID_DirectMusicLoader)
    {
        return "Loader";
    }
    else if (clsid == CLSID_DirectMusicTempoTrack)
    {
        return "Tempo Track";
    }
    else if (clsid == CLSID_DirectMusicTimeSigTrack)
    {
        return "Time Signature Track";
    }
    else if (clsid == CLSID_DirectMusicBandTrack)
    {
        return "Band Track";
    }
    else if (clsid == CLSID_DirectMusicPerformance)
    {
        return "Performance";
    }
    else if (clsid == CLSID_DirectMusicBand)
    {
        return "Band";
    }
    else if (clsid == CLSID_DirectMusicSeqTrack)
    {
        return "Seqquence Track";
    }
    else if (clsid == CLSID_DirectSoundWave)
    {
        return "Wave";
    }
    else if (clsid == CLSID_DirectMusicWaveTrack)
    {
        return "Wave Track";
    }
    else if (clsid == CLSID_DirectMusicChordTrack)
    {
        return "Chord Track";
    }
    else if (clsid == CLSID_DirectMusicCommandTrack)
    {
        return "Command Track";
    }
    else if (clsid == CLSID_DirectMusicStyleTrack)
    {
        return "Style Track";
    }
    else if (clsid == CLSID_DirectMusicPatternTrack)
    {
        return "Pattern Track";
    }
    else if (clsid == CLSID_DirectMusicMotifTrack)
    {
        return "Motif Track";
    }
    else if (clsid == CLSID_DirectMusicStyle)
    {
        return "Style";
    }
    else if (clsid == CLSID_DirectMusicMelodyFormulationTrack)
    {
        return "Melody Formulation Track";
    }
    else if (clsid == CLSID_DirectMusicComposer)
    {
        return "Composer";
    }
    else if (clsid == CLSID_DirectMusicChordMap)
    {
        return "Chord Map";
    }
    else if (clsid == CLSID_DirectMusicChordMapTrack)
    {
        return "Chord Map Track";
    }
    else if (clsid == CLSID_DirectMusicSignPostTrack)
    {
        return "Sign Post Track";
    }
    else if (clsid == CLSID_AutDirectMusicAudioPath)
    {
        return "AudioPath IDispatch";
    }
    else if (clsid == CLSID_AutDirectMusicAudioPathConfig)
    {
        return "AudioPath Config IDispatch";
    }
    else if (clsid == CLSID_AutDirectMusicSong)
    {
        return "Song IDispatch";
    }
    else if (clsid == CLSID_AutDirectMusicPerformance)
    {
        return "Performance IDispatch";
    }
    else if (clsid == CLSID_AutDirectMusicSegment)
    {
        return "Segment IDispatch";
    }
    else if (clsid == CLSID_DirectMusicScript)
    {
        return "Script";
    }
    else if (clsid == CLSID_DirectMusicScriptTrack)
    {
        return "Script Track";
    }
    else if (clsid == CLSID_DirectMusicContainer)
    {
        return "Container";
    }
    else if (clsid == CLSID_AutDirectMusicSegmentState)
    {
        return "Segment State IDispatch";
    }
    else if (clsid == CLSID_DirectMusicMuteTrack)
    {
        return "Mute Track";
    }
    else if (clsid == CLSID_DirectMusicMarkerTrack)
    {
        return "Marker Track";
    }
    else if (clsid == CLSID_DirectMusicSong)
    {
        return "Song";
    }
    else if (clsid == CLSID_DirectMusicAudioPathConfig)
    {
        return "AudioPath Config";
    }
    else if (clsid == CLSID_DirectMusicGraph)
    {
        return "Tool Graph";
    }
    else if (clsid == CLSID_DirectMusicSysExTrack)
    {
        return "SysEx Track";
    }
    else if (clsid == CLSID_DirectMusicSegmentTriggerTrack)
    {
        return "Segment Trigger Track";
    }
    else if (clsid == CLSID_DirectMusicLyricsTrack)
    {
        return "Lyrics Track";
    }
    else if (clsid == CLSID_DirectMusicParamControlTrack)
    {
        return "Parameter Control Track";
    }
    return "Unknown object";
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\dmperf.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// dmperf.cpp 

#include "pchime.h"
#include <xboxverp.h>
#include "curve.h"

#pragma warning(disable:4296)
#define PORT_CHANNEL 0

#define GetLatencyWithPrePlay() ( GetLatency() + m_rtBumperLength )

void CChannelBlockList::Clear()
{
    CChannelBlock* pCB;
    while( pCB = RemoveHead() )
    {
        delete pCB;
    }
}

void CChannelMap::Clear()

{
    Reset(TRUE);                // Clear all MIDI controllers
    m_TransposeMerger.Clear(0); // No transpose.
    nTranspose = 0;
    wFlags = CMAP_FREE;
}

void CChannelMap::Reset(BOOL fVolumeAndPanToo)

{
    if (fVolumeAndPanToo)
    {
        m_PanMerger.Clear(0);       // Panned to center.
        m_VolumeMerger.Clear(-415); // Equivalent to MIDI value 100.
    }
    m_PitchbendMerger.Clear(0); // No pitch bend.
    m_ExpressionMerger.Clear(0);// Full volume for expression (MIDI 127.)
    m_FilterMerger.Clear(0);    // No filter change.
    m_ReverbMerger.Clear(-87); // Start at default level (MIDI 40).
    m_ChorusMerger.Clear(-127);    // Start with no chorus.
    m_ModWheelMerger.Clear(-127);  // Start with no mod wheel.
}

void CParamMerger::Clear(long lInitValue )

{
    CMergeParam *pParam;
    while (pParam = RemoveHead())
    {
        delete pParam;
    }
    m_lZeroIndexData = lInitValue;
    m_lMergeTotal = 0;
}


short CParamMerger::m_lMIDIToDB[128] = {       // Global array used to convert MIDI to dB. 
    -9600, -8415, -7211, -6506, -6006, -5619, -5302, -5034, 
    -4802, -4598, -4415, -4249, -4098, -3959, -3830, -3710, 
    -3598, -3493, -3394, -3300, -3211, -3126, -3045, -2968, 
    -2894, -2823, -2755, -2689, -2626, -2565, -2506, -2449, 
    -2394, -2341, -2289, -2238, -2190, -2142, -2096, -2050, 
    -2006, -1964, -1922, -1881, -1841, -1802, -1764, -1726, 
    -1690, -1654, -1619, -1584, -1551, -1518, -1485, -1453, 
    -1422, -1391, -1361, -1331, -1302, -1273, -1245, -1217, 
    -1190, -1163, -1137, -1110, -1085, -1059, -1034, -1010, 
    -985, -961, -938, -914, -891, -869, -846, -824, 
    -802, -781, -759, -738, -718, -697, -677, -657, 
    -637, -617, -598, -579, -560, -541, -522, -504, 
    -486, -468, -450, -432, -415, -397, -380, -363, 
    -347, -330, -313, -297, -281, -265, -249, -233, 
    -218, -202, -187, -172, -157, -142, -127, -113, 
    -98, -84, -69, -55, -41, -27, -13, 0
};


BYTE CParamMerger::m_lDBToMIDI[97] = {        // Global array used to convert db to MIDI.
    127, 119, 113, 106, 100, 95, 89, 84, 80, 75, 
    71, 67, 63, 60, 56, 53, 50, 47, 45, 42, 
    40, 37, 35, 33, 31, 30, 28, 26, 25, 23, 
    22, 21, 20, 19, 17, 16, 15, 15, 14, 13, 
    12, 11, 11, 10, 10, 9, 8, 8, 8, 7, 
    7, 6, 6, 6, 5, 5, 5, 4, 4, 4, 
    4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 
    2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0
};


CParamMerger::CParamMerger()
{
    m_lMergeTotal = 0;
    m_lZeroIndexData = 0;
}

BYTE CParamMerger::VolumeToMidi(long lVolume)

{
    if (lVolume < -9600) lVolume = -9600;
    if (lVolume > 0) lVolume = 0;
    lVolume = -lVolume;
    long lFraction = lVolume % 100;
    lVolume = lVolume / 100;
    long lResult = m_lDBToMIDI[lVolume];
    lResult += ((m_lDBToMIDI[lVolume + 1] - lResult) * lFraction) / 100;
    return (BYTE) lResult;
}

/*  MergeMidiVolume() takes an incoming volume and updates the matching
    MergeParam structure (determined by index.) If there is no such matching
    structure, it creates one. Also, the volumes are totaled to create a new
    total volume, which is converted back to MIDI volume and returned.
    This mechanism allows us to introduce additional volume controllers
    that are summed.
*/

BYTE CParamMerger::MergeMidiVolume(DWORD dwIndex, BYTE bMIDIVolume)

{
    long lVolume = MergeData(dwIndex,(long)m_lMIDIToDB[bMIDIVolume]);
    if (m_lMergeTotal || dwIndex) // Optimization for simplest and most frequent case - there are no additional indexes.
    {
        return (BYTE) VolumeToMidi(lVolume);
    }
    return bMIDIVolume;
}

BYTE CParamMerger::GetVolumeStart(DWORD dwIndex)

{
    if (dwIndex == 0)
    {
        return VolumeToMidi(m_lZeroIndexData);
    }
    return VolumeToMidi(GetIndexedValue(dwIndex));
}

/*  MergeValue is used for all data types that have a plus and minus range
    around a center bias. These include pitch bend, pan and filter.
    MergeValue takes an incoming data value, adds the bias (in lRange),
    calls MergeData to combine it with the other merged inputs, 
    adds the bias back in and checks for over or underflow.
*/

long CParamMerger::MergeValue(DWORD dwIndex, long lData, long lCenter, long lRange)

{
    lData = MergeData(dwIndex,lData - lCenter) + lCenter;
    if (lData < 0) lData = 0;
    if (lData > lRange) lData = lRange;
    return lData;
}


short CParamMerger::MergeTranspose(DWORD dwIndex, short nTranspose)

{
    return (short) MergeData(dwIndex,nTranspose);
}

long CParamMerger::MergeData(DWORD dwIndex, long lData)

{
    if (dwIndex)
    {
        // If this has an index, scan the indexes. Look
        // for the matching index. If it is found, update it
        // with the new data. Meanwhile, add up all the data fields.
        // If it is not found, add an entry for it.
        m_lMergeTotal = 0;   // Recalculate
        BOOL fNoEntry = TRUE;
        CMergeParam *pParam = GetHead();
        for (;pParam;pParam = pParam->GetNext())
        {
            if (pParam->m_dwIndex == dwIndex)
            {
                // Found the index. Store the new value.
                pParam->m_lData = lData;
                fNoEntry = FALSE;
            }
            // Sum all values to create the merged total.
            m_lMergeTotal += pParam->m_lData;
        }
        if (fNoEntry)
        {
            // Didn't find the index. Create one and store the value.
            pParam = new CMergeParam;
            if (pParam)
            {
                pParam->m_dwIndex = dwIndex;
                pParam->m_lData = lData;
                m_lMergeTotal += lData;
                AddHead(pParam);
            }
        }
        // Add the initial value for merge index 0.
        lData = m_lMergeTotal + m_lZeroIndexData;
    }
    else
    {
        m_lZeroIndexData = lData;
        lData += m_lMergeTotal;
    }
    return lData;
}


long CParamMerger::GetIndexedValue(DWORD dwIndex)

{
    if (dwIndex)
    {
        // If this has an index, scan the indexes. Look
        // for the matching index. If it is found, return its data.  
        // If not, return the default 0.
        BOOL fNoEntry = TRUE;
        CMergeParam *pParam = GetHead();
        for (;pParam;pParam = pParam->GetNext())
        {
            if (pParam->m_dwIndex == dwIndex)
            {
                return pParam->m_lData;
            }
        }
        return 0;
    }
    return m_lZeroIndexData;
}

CPitchMerger::CPitchMerger()
{
    m_lBendRange = 200;     // Default value for pitch bend range is whole tone.
}

void CChannelBlock::Init(DWORD dwPChannelStart, 
                         DWORD dwPortIndex, DWORD dwGroup,
                         WORD wFlags)

{
    DWORD dwIndex;
    m_dwPortIndex = dwPortIndex;
    m_dwPChannelStart = ( dwPChannelStart / PCHANNEL_BLOCKSIZE ) * PCHANNEL_BLOCKSIZE;
    for( dwIndex = 0; dwIndex < PCHANNEL_BLOCKSIZE; dwIndex++ )
    {
        m_aChannelMap[dwIndex].Clear();
        m_aChannelMap[dwIndex].dwPortIndex = dwPortIndex;
        m_aChannelMap[dwIndex].dwGroup = dwGroup;
        m_aChannelMap[dwIndex].dwMChannel = dwIndex;
        m_aChannelMap[dwIndex].nTranspose = 0;
        m_aChannelMap[dwIndex].wFlags = wFlags;
    }
    if (wFlags == CMAP_FREE) m_dwFreeChannels = 16;
    else m_dwFreeChannels = 0;
}

#ifdef USE_PMSG_ZONE

// We know we're only ever called from within the API critical section, so no need
// to do our own critical section

class CPMsgZone {
public:
    // The dwInitalAlloc and dwDefaultGrowth parameters are chosen to be heap friendly.
    // (We know the heap gets VM pages on 4K boundaries, so we grab in multiples of 4K.
    // and we know the debug heap likes to add some header information, so we ask for
    // 200 bytes less than a full page.
    CPMsgZone(DWORD dwInitalAlloc = 16*1024-200, DWORD dwDefaultGrowth=16*1024-200){
        m_pBlock = 0;
        m_dwOffset = 0;
        m_dwSize = 0;
        m_dwDefaultGrowth = dwDefaultGrowth;
        AllocZone(dwInitalAlloc);
    }

    ~CPMsgZone(){
        FreeAll();
    }

    void FreeAll(){
        while(m_pBlock){
            char* pNext = *((char**) m_pBlock);
            delete [] m_pBlock;
            m_pBlock = pNext;
        }
        m_dwOffset = 0;
        m_dwSize = 0;
    }

    void* Alloc(size_t size){
        AllocZone(size);
        if(m_dwSize - m_dwOffset < size){
            return NULL;
        }
        void* result = m_pBlock + m_dwOffset;
        m_dwOffset += size;

        return result;
    }

private:

    void AllocZone(DWORD dwMinSize){
        if(m_dwSize - m_dwOffset < dwMinSize){
            DWORD dwAllocSize = m_dwDefaultGrowth;
            if(dwAllocSize < dwMinSize + 4){
                dwAllocSize = dwMinSize + 4;
            }
            char* pNew = new char[dwAllocSize];
            if(!pNew){
                return;
            }
            *((char**) pNew) = m_pBlock;
            m_pBlock = pNew;
            m_dwOffset = 4;
            m_dwSize = dwAllocSize;
        }
    }

    char* m_pBlock;
    DWORD m_dwOffset;
    DWORD m_dwSize;
    DWORD m_dwDefaultGrowth;
};

#endif // USE_PMSG_ZONE

#ifdef IMPLEMENT_PERFORMANCE_COUNTERS

extern "C" void DMusicRegisterPerformanceCounters();
extern "C" void DMusicUnregisterPerformanceCounters();

#endif

/////////////////////////////////////////////////////////////////////////////
// CPerformance

// Flags for which critical sections have been initialized
//

#define PERF_ICS_SEGMENT        0x0001
#define PERF_ICS_PIPELINE       0x0002
#define PERF_ICS_PCHANNEL       0x0004
#define PERF_ICS_GLOBAL         0x0010
#define PERF_ICS_REALTIME       0x0020
#define PERF_ICS_PORTTABLE      0x0040
#define PERF_ICS_MAIN           0x0100
#define PERF_ICS_PMSGCACHE      0x0200

CPerformance::CPerformance() : CMemTrack(DMTRACK_PERFORMANCE)
{
#ifdef USE_PMSG_ZONE
    m_pPMsgZone = new CPMsgZone();
#endif
    m_pGraph = NULL;
    m_dwPrepareTime = 1000;
    m_dwBumperLength = 50;
    m_rtBumperLength = m_dwBumperLength * REF_PER_MIL;
    m_pGlobalData = NULL;
    m_fInTrackPlay = FALSE;
    m_fPlaying = FALSE;
    m_wRollOverCount = 0;
    m_mtTransported = 0;
    m_mtTempoCursor = 0;
    m_hNotification = 0;
    m_rtNotificationDiscard = 20000000;
    m_rtStart = 0;
    m_rtAdjust = 0;
    m_mtPlayTo = 0;
    m_cRef = 0;
    m_pUnkDispatch = NULL;
#ifdef DXAPI
    m_dwVersion = 6;
    m_pParamHook = NULL;
    m_fKillThread = 0; 
    m_fKillRealtimeThread = 0;
    m_dwTransportThreadID = 0;
    m_dwInitCS = 0;
    m_pPortTable = NULL;
    m_dwNumPorts = 0;
    m_pDirectMusic = NULL;
    m_fReleasedInTransport = false;
    m_fReleasedInRealtime = false;
#else
    m_dwNumChannelGroups = 0;
    m_pSynth = NULL;
#endif
    m_fInTransportThread = 0;
    m_dwAudioPathMode = 0;
    m_pDirectSound = NULL;
    m_pClock = NULL;
    IncrementDLLCount();

    TraceI(3,"CPerformance %lx\n", this);
//#ifdef DXAPI
    INITIALIZE_CRITICAL_SECTION(&m_SegmentCrSec);         m_dwInitCS |= PERF_ICS_SEGMENT;
    INITIALIZE_CRITICAL_SECTION(&m_PipelineCrSec);        m_dwInitCS |= PERF_ICS_PIPELINE;
    INITIALIZE_CRITICAL_SECTION(&m_PChannelInfoCrSec);    m_dwInitCS |= PERF_ICS_PCHANNEL;
    INITIALIZE_CRITICAL_SECTION(&m_GlobalDataCrSec);      m_dwInitCS |= PERF_ICS_GLOBAL;
    INITIALIZE_CRITICAL_SECTION(&m_RealtimeCrSec);        m_dwInitCS |= PERF_ICS_REALTIME;
    INITIALIZE_CRITICAL_SECTION(&m_PMsgCacheCrSec);       m_dwInitCS |= PERF_ICS_PMSGCACHE;
    INITIALIZE_CRITICAL_SECTION(&m_MainCrSec);            m_dwInitCS |= PERF_ICS_MAIN;
//#endif
    memset( m_apPMsgCache, 0, sizeof(DMUS_PMSG*) * (PERF_PMSG_CB_MAX - PERF_PMSG_CB_MIN) );
    DWORD dwCount;
    for (dwCount = 0; dwCount < SQ_COUNT; dwCount++)
    {
        m_SegStateQueues[dwCount].SetID(dwCount);
    }
    Init();
}

void CPerformance::Init()

{
    dm_srand((unsigned int)time(NULL));
    m_rtEarliestStartTime = 0;
    m_lMasterVolume = 0;
#ifdef DXAPI
    if (m_dwVersion >= 8)
#endif
    {
        m_rtQueuePosition = 0;
        m_dwPrepareTime = 1000;
        m_dwBumperLength = 50;
        m_rtBumperLength = m_dwBumperLength * REF_PER_MIL;
        if (m_dwAudioPathMode)
        {
            CloseDown();
        }
    }
    m_pDefaultAudioPath = NULL;
    m_fltRelTempo = 1;
    m_pGetParamSegmentState = NULL;
    m_dwGetParamFlags = 0;
    m_rtHighestPackedNoteOn = 0;
    m_dwAudioPathMode = 0;
    m_fMusicStopped = TRUE;
    BOOL fAuto = FALSE;
#ifdef DXAPI
    m_hTransport = 0;
    m_hTransportThread = 0;
    m_dwRealtimeThreadID = 0;
    m_hRealtime = 0;
    m_hRealtimeThread = 0;
    SetGlobalParam(GUID_PerfAutoDownload,&fAuto,sizeof(BOOL));
#else
    m_pTransportWorker = NULL;
    m_pRealtimeWorker = NULL;
#endif
    DMUS_TIMESIG_PMSG* pTimeSig;
    if (SUCCEEDED(AllocPMsg(sizeof(DMUS_TIMESIG_PMSG),(DMUS_PMSG **) &pTimeSig)))
    {
        pTimeSig->wGridsPerBeat = 4;
        pTimeSig->bBeatsPerMeasure = 4;
        pTimeSig->bBeat = 4;
        pTimeSig->dwFlags = DMUS_PMSGF_REFTIME;
        pTimeSig->dwType = DMUS_PMSGT_TIMESIG;
        ENTER_CRITICAL_SECTION(&m_PipelineCrSec);
        m_TimeSigQueue.Enqueue(  DMUS_TO_PRIV(pTimeSig) );
        LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);
    }
    
#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
    DMusicRegisterPerformanceCounters();
    DMusicRegisterPerformanceCounter("DM PMSG queue early queue",
                                      DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                                      &m_EarlyQueue.m_lCount );
    DMusicRegisterPerformanceCounter("DM PMSG queue near time queue",
                                      DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                                      &m_NearTimeQueue.m_lCount );
    DMusicRegisterPerformanceCounter("DM PMSG queue on time queue",
                                      DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                                      &m_OnTimeQueue.m_lCount );
    DMusicRegisterPerformanceCounter("DM PMSG queue tempo map queue",
                                      DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                                      &m_TempoMap.m_lCount );
    DMusicRegisterPerformanceCounter("DM PMSG queue old tempo map queue",
                                      DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                                      &m_OldTempoMap.m_lCount );
    DMusicRegisterPerformanceCounter("DM PMSG queue notification queue",
                                      DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                                      &m_NotificationQueue.m_lCount );
    DMusicRegisterPerformanceCounter("DM PMSG queue time sig queue",
                                      DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                                      &m_TimeSigQueue.m_lCount );
    DMusicRegisterPerformanceCounter("DM Out: Notes Per Second",
                                      DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                                      &m_dwNotesPerSecond );
    DMusicRegisterPerformanceCounter("DM Out: Waves Per Second",
                                      DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                                      &m_dwWavesPerSecond );
    DMusicRegisterPerformanceCounter("DM Out: Curve Generated Events Per Second",
                                      DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                                      &m_dwCurvesPerSecond );
    DMusicRegisterPerformanceCounter("DM Out: SysEx Per Second",
                                      DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                                      &m_dwSysExPerSecond );
    DMusicRegisterPerformanceCounter("DM Out: Raw MIDI Events Per Second",
                                      DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                                      &m_dwMIDIPerSecond );
#endif

}

#ifdef IMPLEMENT_PERFORMANCE_COUNTERS

static void GetPentiumTime(REFERENCE_TIME *prtTime)

{
    _int64 cycNow;

    _asm
    {
        RDTSC                       // Get the time in EDX:EAX
        mov     dword ptr [cycNow], eax
        mov     dword ptr [cycNow+4], edx
    }

    cycNow *= 10;          // Gives greater clock granularity.
    cycNow /= 733; // m_dwDivisor;
    *prtTime = cycNow;
}

void CPerformance::UpdateDebugParams()
{
    REFERENCE_TIME rtNow;
    GetPentiumTime(&rtNow);
    if (rtNow > (m_rtLastWrite + (1000 * 10000)))
    {
        m_rtLastWrite = rtNow;
        m_dwNotesPerSecond = m_dwTempNotesPerSecond;
        m_dwWavesPerSecond = m_dwTempWavesPerSecond;
        m_dwCurvesPerSecond = m_dwTempCurvesPerSecond;
        m_dwSysExPerSecond = m_dwTempSysExPerSecond;
        m_dwMIDIPerSecond = m_dwTempMIDIPerSecond;
        m_dwPatchesPerSecond = m_dwTempPatchesPerSecond;
        m_dwTempNotesPerSecond = 0;
        m_dwTempWavesPerSecond = 0;
        m_dwTempCurvesPerSecond = 0;
        m_dwTempSysExPerSecond = 0;
        m_dwTempMIDIPerSecond = 0;
        m_dwTempPatchesPerSecond = 0;
    }
}
#endif

CPerformance::~CPerformance()
{
    TraceI(3,"~CPerformance %lx\n", this);
    CloseDown(); // this should have already been called, but just in case...
#ifdef USE_PMSG_ZONE
    delete m_pPMsgZone;
    m_pPMsgZone = NULL;
#endif

    if (m_pUnkDispatch)
        m_pUnkDispatch->Release(); // free IDispatch implementation we may have borrowed

#ifdef DXAPI
    if (m_pParamHook)
    {
        m_pParamHook->Release();
    }
#endif
    if (m_dwInitCS & PERF_ICS_SEGMENT)  DELETE_CRITICAL_SECTION(&m_SegmentCrSec);
    if (m_dwInitCS & PERF_ICS_PIPELINE) DELETE_CRITICAL_SECTION(&m_PipelineCrSec);
    if (m_dwInitCS & PERF_ICS_PCHANNEL) DELETE_CRITICAL_SECTION(&m_PChannelInfoCrSec);
    if (m_dwInitCS & PERF_ICS_GLOBAL)   DELETE_CRITICAL_SECTION(&m_GlobalDataCrSec);
    if (m_dwInitCS & PERF_ICS_REALTIME) DELETE_CRITICAL_SECTION(&m_RealtimeCrSec);
    if (m_dwInitCS & PERF_ICS_PMSGCACHE)DELETE_CRITICAL_SECTION(&m_PMsgCacheCrSec);
    if (m_dwInitCS & PERF_ICS_MAIN)     DELETE_CRITICAL_SECTION(&m_MainCrSec);

    DecrementDLLCount();
}

STDMETHODIMP CPerformance::CloseDown(void)
{
    V_INAME(CPerformance::CloseDown);
#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
    DMusicUnregisterPerformanceCounters();
    DMusicUnregisterPerformanceCounter("DM PMSG queue early queue");
    DMusicUnregisterPerformanceCounter("DM PMSG queue near time queue");
    DMusicUnregisterPerformanceCounter("DM PMSG queue on time queue");
    DMusicUnregisterPerformanceCounter("DM PMSG queue tempo map queue");
    DMusicUnregisterPerformanceCounter("DM PMSG queue old tempo map queue");
    DMusicUnregisterPerformanceCounter("DM PMSG queue notification queue");
    DMusicUnregisterPerformanceCounter("DM PMSG queue time sig queue");
    DMusicUnregisterPerformanceCounter("DM Out: Notes Per Second");
    DMusicUnregisterPerformanceCounter("DM Out: Waves Per Second");
    DMusicUnregisterPerformanceCounter("DM Out: Curve Generated Events Per Second");
    DMusicUnregisterPerformanceCounter("DM Out: SysEx Per Second");
    DMusicUnregisterPerformanceCounter("DM Out: Raw MIDI Events Per Second");
#endif
#ifdef DXAPI
    DWORD dwThreadID = GetCurrentThreadId();
    if( m_dwAudioPathMode )
    {
        // kill the transport thread
        m_fKillThread = 1;
        m_fKillRealtimeThread = 1;
        if (dwThreadID != m_dwTransportThreadID)
        {
            // signal the transport thread so we don't have to wait for it to wake up on its own
            if( m_hTransport ) SetEvent( m_hTransport );
            // wait until the transport thread quits
            WaitForSingleObject(m_hTransportThread, INFINITE);
        }
        if (dwThreadID != m_dwRealtimeThreadID)
        {
            // signal the realtime thread so we don't have to wait for it to wake up on its own
            if( m_hRealtime ) SetEvent( m_hRealtime );
            // wait until the realtime thread quits
            WaitForSingleObject(m_hRealtimeThread, INFINITE);
        }
    }
#else
    if (m_pTransportWorker)
    {
        m_pTransportWorker->PinkSlip();
        m_pTransportWorker = NULL;
    }
    if (m_pRealtimeWorker)
    {
        m_pRealtimeWorker->PinkSlip();
        m_pRealtimeWorker = NULL;
    }
#endif

//    if (m_pDummy) m_pDummy->Release();
//    m_pDummy = NULL;

    if (m_pGraph) SetGraph(NULL); // shut down the graph and release it (needs to happen before clearing audio path)

    ENTER_CRITICAL_SECTION(&m_SegmentCrSec);
    ENTER_CRITICAL_SECTION(&m_RealtimeCrSec);

    m_fPlaying = FALSE; // prevents transport thread from doing anything more
#ifdef DXAPI
    IDirectMusicPerformance* pPerf = NULL;
    if (SUCCEEDED(QueryInterface(IID_IDirectMusicPerformance, (void**)&pPerf)))
    {
        CWavTrack::UnloadAllWaves(pPerf);
        pPerf->Release();
    }
#endif
    DequeueAllSegments();
    if (m_pDefaultAudioPath)
    {
        m_pDefaultAudioPath->Release();
        m_pDefaultAudioPath = NULL;
    }
    m_AudioPathList.Clear();
    m_dwAudioPathMode = 0;  // Set this after clearing, so if any audiopaths are still
                            // around, they won't assert in PChannelInfo() when 
                            // disconnecting the synth.
    CNotificationItem* pItem = m_NotificationList.GetHead();
    while( pItem )
    {
        CNotificationItem* pNext = pItem->GetNext();
        m_NotificationList.Remove( pItem );
        delete pItem;
        pItem = pNext;
    }
    LEAVE_CRITICAL_SECTION(&m_RealtimeCrSec);
    LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);

    ENTER_CRITICAL_SECTION(&m_PipelineCrSec);
    PRIV_PMSG* pPMsg;
    while( pPMsg = m_EarlyQueue.Dequeue() )
    {
        FreePMsg(pPMsg);
    }
    while( pPMsg = m_NearTimeQueue.Dequeue() )
    {
        FreePMsg(pPMsg);
    }
    while( pPMsg = m_OnTimeQueue.Dequeue() )
    {
        FreePMsg(pPMsg);
    }
    while( pPMsg = m_TempoMap.Dequeue() )
    {
        FreePMsg(pPMsg);
    }
    while( pPMsg = m_OldTempoMap.Dequeue() )
    {
        FreePMsg(pPMsg);
    }
    while( pPMsg = m_NotificationQueue.Dequeue() )
    {
        FreePMsg(pPMsg);
    }
    while( pPMsg = m_TimeSigQueue.Dequeue() )
    {
        FreePMsg(pPMsg);
    }

    LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);

    ENTER_CRITICAL_SECTION(&m_GlobalDataCrSec);
    GlobalData* pGD = m_pGlobalData;
    while( pGD )
    {
        m_pGlobalData = pGD->pNext;
        delete pGD;
        pGD = m_pGlobalData;
    }
    LEAVE_CRITICAL_SECTION(&m_GlobalDataCrSec);

    ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);
    // clear out ports, buffers, and pchannel maps
#ifdef DXAPI
    if( m_pPortTable )
    {
        DWORD dwIndex;
        for( dwIndex = 0; dwIndex < m_dwNumPorts; dwIndex++ )
        {
            if( m_pPortTable[dwIndex].pPort )
            {
                m_pPortTable[dwIndex].pPort->Release();
            }
            if( m_pPortTable[dwIndex].pBuffer )
            {
                m_pPortTable[dwIndex].pBuffer->Release();
            }
            if( m_pPortTable[dwIndex].pLatencyClock )
            {
                m_pPortTable[dwIndex].pLatencyClock->Release();
            }
        }
        delete [] m_pPortTable;
        m_pPortTable = NULL;
        m_dwNumPorts = 0;
    }
#endif
    m_ChannelBlockList.Clear();
    LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);
    ENTER_CRITICAL_SECTION(&m_MainCrSec);
    if( m_pClock )
    {
        m_pClock->Release();
        m_pClock = NULL;
    }
    m_BufferManager.Clear();
    if (m_pDirectSound)
    {
        m_pDirectSound->Release();
        m_pDirectSound = NULL;
    }
#ifdef DXAPI
    if( m_pDirectMusic )
    {
        m_pDirectMusic->Release();
        m_pDirectMusic = NULL;
    }
#else
    if (m_pSynth)
    {
        m_pSynth->Release();
        m_pSynth = NULL;
    }
#endif
    m_hNotification = NULL;
    LEAVE_CRITICAL_SECTION(&m_MainCrSec);

    ENTER_CRITICAL_SECTION(&m_PMsgCacheCrSec);
    for( int i = 0; i < (PERF_PMSG_CB_MAX - PERF_PMSG_CB_MIN); i++ )
    {
        while( m_apPMsgCache[i] )
        {
            PRIV_PMSG* pPriv = m_apPMsgCache[i];
            m_apPMsgCache[i] = pPriv->pNext;
#ifdef USE_PMSG_ZONE
            // This test has to match the one in CPerformance::FreePMsg and CPerformance::AllocPMsg
            ULONG cbSize = pPriv->dwPrivPubSize; 
            if( (cbSize >= PERF_PMSG_CB_MIN) && (cbSize < PERF_PMSG_CB_MAX) ){
                // allocated out of the zone, do nothing
            }
            else {
                delete [] pPriv;
            }
#else
            delete [] pPriv;
#endif
        }
    }
    LEAVE_CRITICAL_SECTION(&m_PMsgCacheCrSec);
#ifdef DXAPI
    if (m_hTransportThread)
    {
        CloseHandle( m_hTransportThread );
        m_hTransportThread = 0;
    }
    if( m_hTransport )
    {
        CloseHandle( m_hTransport );
        m_hTransport = 0;
    }
    if (m_hRealtimeThread)
    {
        CloseHandle( m_hRealtimeThread );
        m_hRealtimeThread = 0;
    }
    if( m_hRealtime )
    {
        CloseHandle( m_hRealtime );
        m_hRealtime = 0;
    }
#else
    
#endif
    m_mtPlayTo = 0;
#ifdef USE_PMSG_ZONE
    m_pPMsgZone->FreeAll();
#endif
    return S_OK;
}

// @method:(INTERNAL) HRESULT | IDirectMusicPerformance | QueryInterface | Standard QueryInterface implementation for <i IDirectMusicPerformance>
//
// @rdesc Returns one of the following:
//
// @flag S_OK | If the interface is supported and was returned
// @flag E_NOINTERFACE | If the object does not support the given interface.
// @flag E_POINTER | <p ppv> is NULL or invalid.
//
STDMETHODIMP CPerformance::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
    V_INAME(CPerformance::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    *ppv = NULL;
    if (iid == IID_IUnknown || iid == IID_IDirectMusicPerformance)
    {
        *ppv = static_cast<IDirectMusicPerformance*>(this);
    } else
    if (iid == IID_IDirectMusicPerformance8)
    {
#ifdef DXAPI
        m_dwVersion = 8;
#endif
        *ppv = static_cast<IDirectMusicPerformance8*>(this);
    } else
#ifdef DXAPI
    if (iid == IID_IDirectMusicPerformance2)
    {
        m_dwVersion = 7;
        *ppv = static_cast<IDirectMusicPerformance*>(this);
    } else 
    if( iid == IID_IDirectMusicPerformanceStats )
    {
        *ppv = static_cast<IDirectMusicPerformanceStats*>(this);
    } else 
    if( iid == IID_IDirectMusicSetParamHook )
    {
        *ppv = static_cast<IDirectMusicSetParamHook*>(this);
    } else
#endif
    if (iid == IID_IDirectMusicTool)
    {
        *ppv = static_cast<IDirectMusicTool*>(this);
    } else
    if (iid == IID_CPerformance)
    {
        *ppv = static_cast<CPerformance*>(this);
    }
    if (iid == IID_IDirectMusicGraph)
    {
        *ppv = static_cast<IDirectMusicGraph*>(this);
    }
    if (iid == IID_IDirectMusicPerformanceP)
    {
        *ppv = static_cast<IDirectMusicPerformanceP*>(this);
    } else
    if (iid == IID_IDispatch)
    {
        // A helper scripting object implements IDispatch, which we expose from the
        // Performance object via COM aggregation.
        if (!m_pUnkDispatch)
        {
            // Create the helper object
            DirectMusicCreateInstance(
                CLSID_AutDirectMusicPerformance,
                static_cast<IDirectMusicPerformance*>(this),
                IID_IUnknown,
                reinterpret_cast<void**>(&m_pUnkDispatch));
        }
        if (m_pUnkDispatch)
        {
            return m_pUnkDispatch->QueryInterface(IID_IDispatch, ppv);
        }
    }
    if (*ppv == NULL)
    {
        Trace(4,"Warning: Request to query unknown interface on Performance object\n");
        return E_NOINTERFACE;
    }
    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


// @method:(INTERNAL) HRESULT | IDirectMusicPerformance | AddRef | Standard AddRef implementation for <i IDirectMusicPerformance>
//
// @rdesc Returns the new reference count for this object.
//
STDMETHODIMP_(ULONG) CPerformance::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


// @method:(INTERNAL) HRESULT | IDirectMusicPerformance | Release | Standard Release implementation for <i IDirectMusicPerformance>
//
// @rdesc Returns the new reference count for this object.
//
STDMETHODIMP_(ULONG) CPerformance::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
#ifndef XBOX
        DWORD dwThreadID = GetCurrentThreadId();
        m_cRef = 100; // artificial reference count to prevent reentrency due to COM aggregation
        if (dwThreadID == m_dwTransportThreadID)
        {
            m_fReleasedInTransport = true;
            m_fKillThread = TRUE;
        }
        else if (dwThreadID == m_dwRealtimeThreadID)
        {
            m_fReleasedInRealtime = true;
            m_fKillRealtimeThread = TRUE;
        }
        else
        {
            delete this;
        }
        return 0;
#else
        m_cRef = 100; // artificial reference count to prevent reentrency due to COM aggregation
        delete this;
        return 0;
#endif
    }

    return m_cRef;
}

// call this only from within a m_SegmentCrSec critical section
// if fSendNotify, then send segment end notifications for segments that were
// playing
void CPerformance::DequeueAllSegments()
{
    CSegState *pNode;
    DWORD dwCount;

    for( dwCount = 0; dwCount < SQ_COUNT; dwCount++ )
    {
        while( pNode = m_SegStateQueues[dwCount].RemoveHead())
        {
            pNode->ShutDown();
        }
    }
    while( pNode = m_ShutDownQueue.RemoveHead())
    {
        pNode->ShutDown();
    }
}

// IDirectMusicPerformanceStats 
#ifndef XBOX
STDMETHODIMP CPerformance::TraceAllSegments()
{
    CSegState *pNode;
    DWORD dwCount;
    for( dwCount = 0; dwCount < SQ_COUNT; dwCount++ )
    {
        ENTER_CRITICAL_SECTION(&m_SegmentCrSec);
        for ( pNode = m_SegStateQueues[dwCount].GetHead();pNode;pNode=pNode->GetNext())
        {
            TraceI(0,"%x %ld: Playing: %ld, Start: %ld, Seek: %ld, LastPlayed: %ld\n",
                pNode,dwCount,pNode->m_fStartedPlay, pNode->m_mtResolvedStart,
                pNode->m_mtSeek, pNode->m_mtLastPlayed);
        }
        LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);
    }
    return S_OK;
}

STDMETHODIMP CPerformance::CreateSegstateList(DMUS_SEGSTATEDATA ** ppList)

{
    if (!ppList) return E_POINTER;
    CSegState *pNode;
    DWORD dwCount;
    for( dwCount = 0; dwCount < SQ_COUNT; dwCount++ )
    {
        ENTER_CRITICAL_SECTION(&m_SegmentCrSec);
        for ( pNode = m_SegStateQueues[dwCount].GetHead();pNode;pNode=pNode->GetNext())
        {
            DMUS_SEGSTATEDATA *pData = new DMUS_SEGSTATEDATA;
            if (pData)
            {
                CSegment *pSegment = pNode->m_pSegment;
                if (pSegment && (pSegment->m_Info.m_dwValidData & DMUS_OBJ_NAME))
                {
                    wcscpy(pData->wszName,pSegment->m_Info.m_wszName);
                }
                else
                {
                    pData->wszName[0] = 0;
                }
                pData->dwQueue = dwCount;
                pData->pSegState = (IDirectMusicSegmentState *) pNode;
                pNode->AddRef();
                pData->pNext = *ppList;
                pData->mtLoopEnd = pNode->m_mtLoopEnd;
                pData->mtLoopStart = pNode->m_mtLoopStart;
                pData->dwRepeats = pNode->m_dwRepeats;
                pData->dwPlayFlags = pNode->m_dwPlaySegFlags;
                pData->mtLength = pNode->m_mtLength;
                pData->rtGivenStart = pNode->m_rtGivenStart;
                pData->mtResolvedStart = pNode->m_mtResolvedStart;
                pData->mtOffset = pNode->m_mtOffset;
                pData->mtLastPlayed = pNode->m_mtLastPlayed;
                pData->mtPlayTo = pNode->m_mtStopTime;
                pData->mtSeek = pNode->m_mtSeek;
                pData->mtStartPoint = pNode->m_mtStartPoint;
                pData->dwRepeatsLeft = pNode->m_dwRepeatsLeft;
                pData->fStartedPlay = pNode->m_fStartedPlay;
                *ppList = pData;
            }
        }
        LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);
    }
    return S_OK;
}

STDMETHODIMP CPerformance::FreeSegstateList(DMUS_SEGSTATEDATA * pList) 

{
    DMUS_SEGSTATEDATA *pState;
    while (pList)
    {
        pState = pList;
        pList = pList->pNext;
        pState->pSegState->Release();
        delete pState;
    }
    return S_OK;
}
#endif \\ !XBOX

#ifdef DXAPI
void CPerformance::SendBuffers()
{
    DWORD dwIndex;
    PortTable* pPortTable;

#ifdef DBG_PROFILE
    DWORD dwDebugTime;
    dwDebugTime = timeGetTime();
#endif
    ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);
    for( dwIndex = 0; dwIndex < m_dwNumPorts; dwIndex++ )
    {
        if( m_pPortTable[dwIndex].fBufferFilled && m_pPortTable[dwIndex].pBuffer )
        {
            pPortTable = &m_pPortTable[dwIndex];
            pPortTable->fBufferFilled = FALSE;
            ASSERT( pPortTable->pBuffer );
            if( pPortTable->pPort )
            {
                pPortTable->pPort->PlayBuffer( pPortTable->pBuffer );
//  TraceI(5, "SENT BUFFERS time=%ld latency=%ld\n", (long)(GetTime() / 10000),(long)(GetLatency()/10000));
            }
            pPortTable->pBuffer->Flush();
        }
    }
    LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);
#ifdef DBG_PROFILE
    dwDebugTime = timeGetTime() - dwDebugTime;
    if( dwDebugTime > 1 )
    {
        TraceI(5, "Hall, debugtime SendBuffers %u\n", dwDebugTime);
    }
#endif
}
#else
// If this is not DXAPI, then kill all calls to SendBuffers(), since the messages are sent
// directly to the synth.
#define SendBuffers();
#endif

#ifdef DXAPI
static DWORD WINAPI _Realtime(LPVOID lpParam)
{
    if (SUCCEEDED(::CoInitialize(NULL)))
    {
        ((CPerformance *)lpParam)->RealtimeThread();
        ::CoUninitialize();
    }
    return 0;
}
#else
static void WINAPI _Realtime(LPVOID lpParam,REFERENCE_TIME *prtWakeUp)
{
    ((CPerformance *)lpParam)->Realtime(prtWakeUp);
}
#endif

void CPerformance::Realtime(REFERENCE_TIME *prtWakeUp)

{
    if (m_dwAudioPathMode == 0)
    {
        Trace(1,"Error: Performance not initialized.\n");
        return ;
    }
    ENTER_CRITICAL_SECTION(&m_RealtimeCrSec);
    PRIV_PMSG *pEvent;
    HRESULT hr;
    REFERENCE_TIME  rtFirst = 0;
    REFERENCE_TIME  rtEnter = GetLatencyWithPrePlay();
    DWORD   dwTestTime;
    DWORD   dwBeginTime = timeGetTime();
    DWORD   dwLimitLoop = 0;

    if( rtEnter > m_rtQueuePosition )
    {
        m_rtQueuePosition = rtEnter;
    }

    while (1)
    {
        // rtFirst equals the time that the first event was packed into a buffer.
        // Once this time is greater than the latency clock (minus a delay) we need
        // to queue the buffers so the events get down in time to be rendered.
        // If rtFirst is 0 it means it hasn't been initialized yet.
        dwTestTime = timeGetTime();
        if( dwTestTime - dwBeginTime > REALTIME_RES )
        {
            if( ++dwLimitLoop > 10 )
            {
                TraceI(1,"Error! We've been in the realtime thread too long!!! Breaking out without completing.\n");
                break;
            }
            SendBuffers();
            dwBeginTime = dwTestTime;
        }
        pEvent = GetNextPMsg();
        if( NULL == pEvent )
        {
            break;
        }
        ASSERT( pEvent->pNext == NULL );
        if( !pEvent->pTool )
        {
            // this event doesn't have a Tool pointer, so stamp it with the
            // final output Tool.
            pEvent->pTool = (IDirectMusicTool*)this;
            AddRef();
        }

        // before processing the event, set rtLast to the event's current time
        pEvent->rtLast = pEvent->rtTime;

        hr = pEvent->pTool->ProcessPMsg( this, PRIV_TO_DMUS(pEvent) );
        if( hr != S_OK ) // S_OK means do nothing
        {
            if( hr == DMUS_S_REQUEUE )
            {
                if(FAILED(SendPMsg( PRIV_TO_DMUS(pEvent) )))
                {
                    FreePMsg(pEvent);
                }
            }
            else // e.g. DMUS_S_FREE or error code
            {
                FreePMsg( pEvent );
            }
        }
    }
    SendBuffers();
    LEAVE_CRITICAL_SECTION(&m_RealtimeCrSec);
    *prtWakeUp = rtEnter + REALTIME_RES * 10000;    
}

#ifdef DXAPI
void CPerformance::RealtimeThread()
{
    while (!m_fKillRealtimeThread)
    {
        Realtime();
        if( m_hRealtime )
        {
            WaitForSingleObject( m_hRealtime, REALTIME_RES );
        }
        else
        {
            Sleep(REALTIME_RES);
        }
    }
    m_fKillRealtimeThread = FALSE;
    TraceI(2, "dmperf: LEAVE realtime\n");
    if (m_fReleasedInRealtime)
    {
        delete this;
    }
}
#endif

void CPerformance::GenerateNotification( DWORD dwNotification, MUSIC_TIME mtTime,
                                          IDirectMusicSegmentState* pSegSt)
{
    GUID guid;
    guid = GUID_NOTIFICATION_PERFORMANCE;
    if( FindNotification( guid ))
    {
        DMUS_NOTIFICATION_PMSG* pEvent = NULL;
        if( SUCCEEDED( AllocPMsg( sizeof(DMUS_NOTIFICATION_PMSG), 
            (DMUS_PMSG**)&pEvent )))
        {
            pEvent->dwField1 = 0;
            pEvent->dwField2 = 0;
            pEvent->guidNotificationType = GUID_NOTIFICATION_PERFORMANCE;
            pEvent->dwType = DMUS_PMSGT_NOTIFICATION;
            pEvent->mtTime = mtTime;
            pEvent->dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_TOOL_ATTIME;
            pEvent->dwGroupID = 0xffffffff;
            pEvent->dwPChannel = 0;
            pEvent->dwNotificationOption = dwNotification;
            if( pSegSt )
            {
                pSegSt->QueryInterface(IID_IUnknown, (void**)&pEvent->punkUser);
            }
            StampPMsg((DMUS_PMSG*)pEvent);
            if(FAILED(SendPMsg( (DMUS_PMSG*)pEvent )))
            {
                FreePMsg((DMUS_PMSG*)pEvent);
            }
        }
    }
}

void CPerformance::PrepSegToPlay(CSegState *pSegState, bool fQueue)

/*  Called when a segment is first queued, once the start time of the segment is known.
    This calculates various fields that need to be initialized and also regenerates the
    tempo map if the new segment has an active tempo map in it.
*/

{
    if (!pSegState->m_fPrepped)
    {
        pSegState->m_fPrepped = TRUE;
        pSegState->m_mtLastPlayed = pSegState->m_mtResolvedStart;
        // if this is queued to play after the current segment ends, no need to recalc the tempo map;
        // it will be updated as necessary by the transport thread.
        if (!fQueue)
        {
            RecalcTempoMap(pSegState, pSegState->m_mtResolvedStart);
        }
        MusicToReferenceTime(pSegState->m_mtLastPlayed,&pSegState->m_rtLastPlayed);
        // Calculate the total duration of the segment and store in m_mtEndTime.
        pSegState->m_mtEndTime = pSegState->GetEndTime(pSegState->m_mtResolvedStart);
    }
}

/*

  void | CPerformance | PerformSegStNode |
  Perform a Segment State contained in the CSegState.

  Note that this ppSegStNode may be dequeued, so don't depend on it
  staying around!

*/
void CPerformance::PerformSegStNode( 
    DWORD dwList,   // The list the segmentstate comes from.
    CSegState* pSegStNode)  // The segmentstate node.
{
    MUSIC_TIME mtMargin; // tracks how much of a segment to play
    HRESULT hr;
    CSegStateList *pList = &m_SegStateQueues[dwList];
    CSegState *pNext;

    if( !m_fPlaying || m_fInTrackPlay )
    {
        return;
    }
    if( pSegStNode )
    {
        m_fInTransportThread = TRUE;    // Disable realtime processing of early queue messages.
        hr = S_OK;
//Trace(0,"%ld: Performing %lx, Active: %ld, Start Time: %ld, End Time: %ld\n",m_mtPlayTo,
//      pSegStNode->m_pSegment,pSegStNode->m_fStartedPlay,pSegStNode->m_mtResolvedStart,pSegStNode->m_mtEndTime);
        if( !pSegStNode->m_fStartedPlay )
        {
            // check to see if this SegState should start playing.
            ASSERT( !(pSegStNode->m_dwPlaySegFlags & DMUS_SEGF_REFTIME ));
            if( pSegStNode->m_mtResolvedStart < m_mtPlayTo )
            {
                pSegStNode->m_fStartedPlay = TRUE;
                PrepSegToPlay(pSegStNode);
                // send a MUSICSTARTED notification if needed
                if(m_fMusicStopped)
                {
                    m_fMusicStopped = FALSE;
                    GenerateNotification( DMUS_NOTIFICATION_MUSICSTARTED, pSegStNode->m_mtResolvedStart, NULL );
                }
                // We don't want the music to start with a big BLURP in track
                // order, so we send a little dribble out on each track.
                mtMargin = m_mtPlayTo - pSegStNode->m_mtLastPlayed;
                if( mtMargin >= 50 )
                {
                    hr = pSegStNode->Play( 50 );
                    ProcessEarlyPMsgs();
                    // Once done processing all the early messages, make sure that the realtime
                    // thread wakes up and does whatever it needs to do. This ensures that the starting
                    // notes in a sequence get to the output port immediately. 
#ifdef DXAPI
                    if( m_hRealtime ) SetEvent( m_hRealtime );
#else
                    if (m_pRealtimeWorker) m_pRealtimeWorker->WakeUp();
#endif
                    mtMargin = m_mtPlayTo - pSegStNode->m_mtLastPlayed;
                    // Then, we send a larger chunk out on each track to catch up a little more...
                    if ((hr == S_OK) && ( mtMargin >= 200 ))
                    {
                        hr = pSegStNode->Play( 200 );
                        ProcessEarlyPMsgs();
                    }
                }
            }
            else
            {
                MusicToReferenceTime(pSegStNode->m_mtLastPlayed,&pSegStNode->m_rtLastPlayed);
            }
        }
        if( pSegStNode->m_fStartedPlay )
        {
            if( pSegStNode->m_mtStopTime && ( pSegStNode->m_mtStopTime < m_mtPlayTo ) )
            {
                mtMargin = pSegStNode->m_mtStopTime - pSegStNode->m_mtLastPlayed;
            }
            else
            {
                mtMargin = m_mtPlayTo - pSegStNode->m_mtLastPlayed;
            }
            while ((hr == S_OK) && (mtMargin > 0))
            {
                // Do not allow more than a quarter note's worth to be done at once.
                MUSIC_TIME mtRange = mtMargin;
                if (mtRange > DMUS_PPQ) 
                {
                    mtRange = DMUS_PPQ;
                    mtMargin -= mtRange;
                }
                else
                {
                    mtMargin = 0;
                }
                hr = pSegStNode->Play( mtRange );
                ProcessEarlyPMsgs();
            }
        }
        if( (hr == DMUS_S_END) || ( pSegStNode->m_mtStopTime && 
                                  ( pSegStNode->m_mtStopTime <= pSegStNode->m_mtLastPlayed ) ) )
        {

            if( pSegStNode->m_mtStopTime && (pSegStNode->m_mtStopTime == pSegStNode->m_mtLastPlayed) )
            {
                pSegStNode->AbortPlay(pSegStNode->m_mtStopTime - 1, FALSE);
            }
            MUSIC_TIME mtEnd = pSegStNode->m_mtLastPlayed;
            if( pList == &m_SegStateQueues[SQ_PRI_PLAY] )
            {
                // move primary segments to PriPastList
                pList->Remove(pSegStNode);
                m_SegStateQueues[SQ_PRI_DONE].Insert(pSegStNode);
                pNext = pList->GetHead();
                if( pNext )
                {
                    if (!( pNext->m_dwPlaySegFlags & DMUS_SEGF_NOINVALIDATE ))
                    {
                        if (IsConQueue(dwList))
                        {
                            Invalidate( pNext->m_mtResolvedStart, 0 );
                        }
                    }
                }
                else    // No more primary segments, send DMUS_NOTIFICATION_MUSICALMOSTEND
                {
#ifdef DXAPI
                    if (m_dwVersion >= 8)
#endif
                    {
                        MUSIC_TIME mtNow;
                        GetTime( NULL, &mtNow );
                        GenerateNotification( DMUS_NOTIFICATION_MUSICALMOSTEND, mtNow, pSegStNode );
                    }
                }
                ManageControllingTracks();
            }
            else if ( pList == &m_SegStateQueues[SQ_CON_PLAY] )
            {
                pList->Remove(pSegStNode );
                if (pSegStNode->m_mtStopTime == pSegStNode->m_mtLastPlayed)
                {
                    m_ShutDownQueue.Insert(pSegStNode); 
                }
                else
                {
                    m_SegStateQueues[SQ_CON_DONE].Insert(pSegStNode);
                }
            }
            else
            {
                // move 2ndary segments to SecPastList
                pList->Remove(pSegStNode);
                m_SegStateQueues[SQ_SEC_DONE].Insert(pSegStNode);
            }
            // if there aren't any more segments to play, send a Music Stopped
            // notification
            if( (m_SegStateQueues[SQ_PRI_PLAY].IsEmpty() && m_SegStateQueues[SQ_SEC_PLAY].IsEmpty() &&
                m_SegStateQueues[SQ_PRI_WAIT].IsEmpty() && m_SegStateQueues[SQ_SEC_WAIT].IsEmpty() &&
                m_SegStateQueues[SQ_CON_PLAY].IsEmpty() && m_SegStateQueues[SQ_CON_WAIT].IsEmpty()))
            {
                m_fMusicStopped = TRUE;
                GenerateNotification( DMUS_NOTIFICATION_MUSICSTOPPED, mtEnd, NULL );
            }
        }
        m_fInTransportThread = FALSE;
    }
}

#ifdef DXAPI
static DWORD WINAPI _Transport(LPVOID lpParam)
{
    if (SUCCEEDED(::CoInitialize(NULL)))
    {
        ((CPerformance *)lpParam)->TransportThread();
        ::CoUninitialize();
    }
    return 0;
}
#else
static void WINAPI _Transport(LPVOID lpParam,REFERENCE_TIME *prtWakeUp)
{
    ((CPerformance *)lpParam)->Transport(prtWakeUp);
}
#endif

// call Segment's play code on a periodic basis. This routine is in its
// own thread.

#ifdef DXAPI
void CPerformance::TransportThread()
{
    while (!m_fKillThread)
    {
        Transport();
        if( m_hTransport )
        {
            WaitForSingleObject( m_hTransport, TRANSPORT_RES );
        }
        else
        {
            Sleep(TRANSPORT_RES);
        }
    }
    m_fKillThread = FALSE;
    TraceI(2, "dmperf: LEAVE transport\n");
    if (m_fReleasedInTransport)
    {
        delete this;
    }
}
#endif

void CPerformance::Transport(REFERENCE_TIME *prtWakeUp)
{
    ENTER_CRITICAL_SECTION(&m_SegmentCrSec);
    if (m_dwAudioPathMode == 0)
    {
        Trace(1,"Error: Performance not initialized.\n");
        LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);
        return ;
    }
    DWORD dwCount;
    CSegState*  pNode;
    CSegState*  pNext;
    CSegState*  pTempQueue = NULL;
    REFERENCE_TIME rtNow = GetTime();

    // Compute the time we should play all the segments to.
    REFERENCE_TIME rtPlayTo = rtNow + PREPARE_TIME;
    MUSIC_TIME mtAmount, mtResult, mtPlayTo;
    mtPlayTo = 0;
    ReferenceToMusicTime( rtPlayTo, &mtPlayTo );
    if (m_fTempoChanged)
    {
        // If there has been a tempo change to slower, any clock time tracks could
        // be delayed to long as the transport holds off sending out events. That's
        // okay for music time tracks, but bad news for clock time tracks. This
        // makes sure that the clock time tracks get a chance to spew.
        if (m_mtPlayTo >= mtPlayTo)
        {
            mtPlayTo = m_mtPlayTo + 10;
        }
        m_fTempoChanged = FALSE;
    }
    IncrementTempoMap();
    while (m_mtPlayTo < mtPlayTo)
    {
        BOOL fDirty = FALSE; // see below
        m_mtPlayTo = mtPlayTo; // Start out optimistic
        // We need to set play boundaries at the end of control segments.
        // The beginnings of control segments are handled inside the segment state code.
        pNode = m_SegStateQueues[SQ_PRI_PLAY].GetHead();
        if( pNode && pNode->m_fStartedPlay )
        {
            mtAmount = m_mtPlayTo - pNode->m_mtLastPlayed;
            pNode->CheckPlay( mtAmount, &mtResult );
            if( mtResult < mtAmount )
            {
                m_mtPlayTo -= ( mtAmount - mtResult );
                // don't need dirty flag when primary segment loops or ends normally (bug 30829)
                // fDirty = TRUE; // see below 
            }
        }
        // if a control segment ended prematurely, mtPlayTo will have a value besides 0
        // check for upcoming endings to control segments
        for( pNode = m_SegStateQueues[SQ_CON_PLAY].GetHead(); pNode; pNode = pNode->GetNext() )
        {
            if( pNode->m_fStartedPlay )
            {
                if( pNode->m_mtStopTime && (m_mtPlayTo > pNode->m_mtStopTime) )
                {
                    m_mtPlayTo = pNode->m_mtStopTime;
                    fDirty = TRUE; // see below
                }
                else
                {
                    mtAmount = m_mtPlayTo - pNode->m_mtLastPlayed;
                    pNode->CheckPlay( mtAmount, &mtResult );
                    if( mtResult < mtAmount )
                    {
                        m_mtPlayTo -= ( mtAmount - mtResult );
                        fDirty = TRUE; // see below
                    }
                }
            }
        }
        // play the primary segment
        PerformSegStNode( SQ_PRI_PLAY,m_SegStateQueues[SQ_PRI_PLAY].GetHead() );
        // check to see if the next primary segment in the queue is ready to play
        while( (pNode = m_SegStateQueues[SQ_PRI_PLAY].GetHead()) && 
            (pNext = pNode->GetNext()) &&
            ( pNext->m_mtResolvedStart <= pNode->m_mtLastPlayed ) )
        {
            // the next primary segment is indeed ready to begin playing.
            // save the old one in the primary past list so Tools can reference
            // it if they're looking for chord progressions and such.
            pNode->AbortPlay(pNext->m_mtResolvedStart-1,TRUE && (pNext->m_dwPlaySegFlags & DMUS_SEGF_NOINVALIDATE));
            m_SegStateQueues[SQ_PRI_DONE].Insert(m_SegStateQueues[SQ_PRI_PLAY].RemoveHead());
            ManageControllingTracks();
            // we need to flush primary events after the new start time
            if(!( m_SegStateQueues[SQ_PRI_PLAY].GetHead()->m_dwPlaySegFlags & 
                (DMUS_SEGF_NOINVALIDATE | DMUS_SEGF_INVALIDATE_PRI) ))
            {
                Invalidate( m_SegStateQueues[SQ_PRI_PLAY].GetHead()->m_mtResolvedStart, 0 );
            }
            // and play the new segment
            PerformSegStNode( SQ_PRI_PLAY,m_SegStateQueues[SQ_PRI_PLAY].GetHead());
        }
        // play the controlling segments
        pNode = m_SegStateQueues[SQ_CON_PLAY].GetHead();
        pNext = NULL;
        for(; pNode != NULL; pNode = pNext)
        {
            pNext = pNode->GetNext();
            PerformSegStNode(SQ_CON_PLAY,pNode );
        }
        // play the secondary segments
        pNode = m_SegStateQueues[SQ_SEC_PLAY].GetHead();
        pNext = NULL;
        for(; pNode != NULL; pNode = pNext)
        {
            pNext = pNode->GetNext();
            PerformSegStNode( SQ_SEC_PLAY,pNode );
        }

        // if we set fDirty above, it means that we truncated the playback of a control
        // segment because of a loop or end condition. Therefore, we want all segments
        // to set the DMUS_TRACKF_DIRTY flag on the next play cycle.
        if( fDirty )
        {
            for (dwCount = SQ_PRI_PLAY; dwCount <= SQ_SEC_PLAY; dwCount++)
            {
                for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext() )
                {
                    if( pNode->m_fStartedPlay )
                    {
                        pNode->m_dwPlayTrackFlags |= DMUS_TRACKF_DIRTY;
                    }
                }
            }
            ManageControllingTracks();
        }
        m_mtTransported = m_mtPlayTo;

    }

    // check segments queued in ref-time to see if it's time for them to
    // play. Add some extra time just in case. We'll bet that a tempo pmsg won't come
    // in in the intervening 200 ms.
    REFERENCE_TIME rtLatency = GetLatencyWithPrePlay();
    for (dwCount = SQ_PRI_WAIT;dwCount <= SQ_SEC_WAIT; dwCount++)
    {
        while( pNode = m_SegStateQueues[dwCount].GetHead() )
        {
            if( pNode->m_rtGivenStart > (rtLatency + PREPARE_TIME + (200 * REF_PER_MIL) ))
            {
                // it's not yet time to handle this one
                break;
            }
            if (dwCount == SQ_PRI_WAIT)
            {
                QueuePrimarySegment( m_SegStateQueues[SQ_PRI_WAIT].RemoveHead());
            }
            else
            {
                QueueSecondarySegment( m_SegStateQueues[dwCount].RemoveHead());
            }
        }
    }

    // Check to see if Segments in the done queues
    // can be released. They can be released if their
    // final play times are older than the current time.
    for (dwCount = SQ_PRI_DONE;dwCount <= SQ_SEC_DONE; dwCount++)
    {
        for (pNode = m_SegStateQueues[dwCount].GetHead();pNode;pNode = pNext)
        {
            pNext = pNode->GetNext();
            if( pNode->m_rtLastPlayed < rtNow - 1000 * REF_PER_MIL ) // Let it last an additional second
            {
                m_SegStateQueues[dwCount].Remove(pNode);
                pNode->ShutDown();
            }
        }
    }
    for (pNode = m_ShutDownQueue.GetHead();pNode;pNode = pNext)
    {
        pNext = pNode->GetNext();
        if( pNode->m_rtLastPlayed < rtNow - 1000 * REF_PER_MIL ) // Let it last an additional second
        {
            m_ShutDownQueue.Remove(pNode);
            pNode->ShutDown();
        }
    }
    LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);

    // check to see if there are old notifications that haven't been
    // retrieved by the application and need to be removed.
    ENTER_CRITICAL_SECTION(&m_PipelineCrSec);
    while( m_NotificationQueue.GetHead() )
    {
        if( m_NotificationQueue.GetHead()->rtTime < 
            (rtNow - m_rtNotificationDiscard) )
        {
            FreePMsg(m_NotificationQueue.Dequeue());
        }
        else
        {
            break;
        }
    }
    LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);
    *prtWakeUp = rtPlayTo + TRANSPORT_RES * 10000;
}

//////////////////////////////////////////////////////////////////////
// CPerformance::GetNextPMsg
/*
HRESULT | CPerformance | GetNextPMsg |
Returns messages from the queues in priority order.  Any message in the
OnTime queue that is scheduled to be played at the current time is
returned above any other.  Secondly, any message in the NearTime queue
that is scheduled to be played within the next NEARTIME ms is returned.
Lastly, any message in the Early queue is returned.

rvalue PRIV_PMSG* | The message, or NULL if there are no messages.
*/
inline PRIV_PMSG *CPerformance::GetNextPMsg()
{
#ifdef DBG_PROFILE
    DWORD dwDebugTime;
    dwDebugTime = timeGetTime();
#endif
    PRIV_PMSG* pEvent = NULL;

    ENTER_CRITICAL_SECTION(&m_PipelineCrSec);
    if (m_OnTimeQueue.GetHead())
    {
        ASSERT( m_OnTimeQueue.GetHead()->dwFlags & DMUS_PMSGF_REFTIME );
        if ( m_OnTimeQueue.GetHead()->rtTime - GetTime() <= 0 )
        {
            pEvent = m_OnTimeQueue.Dequeue();
        }
    }
    if( !pEvent )
    {
        if (m_NearTimeQueue.GetHead())
        {
            ASSERT( m_NearTimeQueue.GetHead()->dwFlags & DMUS_PMSGF_REFTIME );
            if ( m_NearTimeQueue.GetHead()->rtTime < (m_rtQueuePosition + (m_rtBumperLength >> 1)))
            {
                pEvent = m_NearTimeQueue.Dequeue();
            }
        }
        if( !pEvent && !m_fInTransportThread)
        {
            if (m_EarlyQueue.GetHead())
            {
                pEvent = m_EarlyQueue.Dequeue();
            }
        }
    }
    LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);
#ifdef DBG_PROFILE
    dwDebugTime = timeGetTime() - dwDebugTime;
    if( dwDebugTime > 1 )
    {
        TraceI(5, "Hall, debugtime GetNextPMsg %u\n", dwDebugTime);
    }
#endif

    return pEvent;
}

/*  This next function is used just by the transport thread 
    which can process messages in the early queue, but not
    the other types. This allows all the tools that process
    events right after they are generated by tracks to process
    the events right after they were generated, and in sequential
    order. This allows them to take a little longer, since it's
    not as time critical, and it's much more likely to ensure 
    that they are in sequential order. If the realtime thread were
    allowed to process these, it would preempt and process them
    as soon as generated, so they would be processed in the order
    of the tracks. The m_fInTransportThread is set by the
    transport thread when it is generating and processing events
    and this disallows the realtime thread from processing
    early events (but not others.) At other times, the realtime
    thread is welcome to process early events.
*/

void CPerformance::ProcessEarlyPMsgs()
{
    PRIV_PMSG* pEvent;

#ifdef XBOX
    while (1)
#else
    //  Exit if the thread is exiting.  If we don't test here
    //  we can actually loop forever because tools and queue more
    //  early PMSGs (the Echo tool does this)
    while (!m_fKillThread)
#endif
    {
        ENTER_CRITICAL_SECTION(&m_PipelineCrSec);
        pEvent = m_EarlyQueue.Dequeue();
        LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);
        if (!pEvent) break; // Done?
        ASSERT( pEvent->pNext == NULL );
        if( !pEvent->pTool )
        {
            // this event doesn't have a Tool pointer, so stamp it with the
            // final output Tool.
            pEvent->pTool = (IDirectMusicTool*)this;
            AddRef();
            // Don't process it. Instead, send to neartime queue so
            // realtime thread will deal with it.
            pEvent->dwFlags &= ~(DMUS_PMSGF_TOOL_IMMEDIATE | DMUS_PMSGF_TOOL_QUEUE | DMUS_PMSGF_TOOL_ATTIME);
            pEvent->dwFlags |= DMUS_PMSGF_TOOL_QUEUE;
            SendPMsg( PRIV_TO_DMUS(pEvent) );
        }
        else
        {
            // before processing the event, set rtLast to the event's current time
            pEvent->rtLast = pEvent->rtTime;

            HRESULT hr = pEvent->pTool->ProcessPMsg( this, PRIV_TO_DMUS(pEvent) );
            if( hr != S_OK ) // S_OK means do nothing
            {
                if( hr == DMUS_S_REQUEUE )
                {
                    if(FAILED(SendPMsg( PRIV_TO_DMUS(pEvent) )))
                    {
                        FreePMsg(pEvent);
                    }
                }
                else // e.g. DMUS_S_FREE or error code
                {
                    FreePMsg( pEvent );
                }
            }
        }
    }
}

REFERENCE_TIME CPerformance::GetTime()
{
    DWORD dwTime;
    REFERENCE_TIME rtCurrent;
    WORD    w;

    ENTER_CRITICAL_SECTION(&m_MainCrSec);
    if( !m_pClock || ( m_pClock && FAILED( m_pClock->GetTime( &rtCurrent ) ) ) )
    {
        // this only gets called with machines that don't support m_pClock
        dwTime = timeGetTime();
        rtCurrent = dwTime * 10; // 100 ns increments
        // take care of timeGetTime rolling over every 49 days
        if( rtCurrent < 0 )
        {
            m_wRollOverCount++;
        }
        for( w = 0; w < m_wRollOverCount; w++ )
        {
            rtCurrent += 4294967296;
        }
        // if rtCurrent is negative, it means we've rolled over rtCurrent. Ignore
        // this case for now, as it will be quite uncommon.
    }
    LEAVE_CRITICAL_SECTION(&m_MainCrSec);

    return rtCurrent;
}

REFERENCE_TIME CPerformance::GetLatency(void)
{
    REFERENCE_TIME rtLatency = 0;
#ifdef DXAPI
    DWORD dwIndex;
    REFERENCE_TIME rtTemp;

#ifdef DBG_PROFILE
    DWORD dwDebugTime;
    dwDebugTime = timeGetTime();
#endif
    ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);
    if( m_pPortTable )
    {
        for( dwIndex = 0; dwIndex < m_dwNumPorts; dwIndex++ )
        {
            if( m_pPortTable[dwIndex].pLatencyClock )
            {
                if( SUCCEEDED( m_pPortTable[dwIndex].pLatencyClock->GetTime( &rtTemp )))
                {
                    if( rtTemp > rtLatency )
                        rtLatency = rtTemp;
                }
            }
            else if( m_pPortTable[dwIndex].pPort )
            {
                if( SUCCEEDED( m_pPortTable[dwIndex].pPort->GetLatencyClock( &m_pPortTable[dwIndex].pLatencyClock )))
                {
                    if( SUCCEEDED( m_pPortTable[dwIndex].pLatencyClock->GetTime( &rtTemp )))
                    {
                        if( rtTemp > rtLatency )
                            rtLatency = rtTemp;
                    }
                }
            }
        }
    }
    LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);
#endif
    if( 0 == rtLatency )
    {
        rtLatency = GetTime();
    }
#ifdef DBG_PROFILE
    dwDebugTime = timeGetTime() - dwDebugTime;
    if( dwDebugTime > 1 )
    {
        TraceI(5, "Hall, debugtime GetLatency %u\n", dwDebugTime);
    }
#endif
    if (m_rtEarliestStartTime > rtLatency)
    {
        rtLatency = m_rtEarliestStartTime;
    }
    return rtLatency;
}

// return the most desireable Segment latency, based on which ports this
// segment plays on.
REFERENCE_TIME CPerformance::GetBestSegLatency( CSegState* pSeg )
{
#ifdef XBOX
    return GetLatency();
#else
    // If we're using audiopaths, the code below doesn't work because it doesn't
    // take converting pchannels into account. So, just use the worse case
    // latency. 99% of the time, there is only one port, so this results
    // in just a performance enhancement.
    if (m_dwAudioPathMode == 2)
    {
        return GetLatency();
    }
    DWORD dwIndex;
    REFERENCE_TIME rtLatency = 0;
    REFERENCE_TIME rtTemp;
    BOOL* pafIndexUsed = NULL;
    DWORD dwCount;

    if( m_dwNumPorts == 1 )
    {
        return GetLatency();
    }
    pafIndexUsed = new BOOL[m_dwNumPorts];
    if( NULL == pafIndexUsed )
    {
        return GetLatency();
    }
    for( dwCount = 0; dwCount < m_dwNumPorts; dwCount++ )
    {
        pafIndexUsed[dwCount] = FALSE;
    }
    DWORD dwNumPChannels, dwGroup, dwMChannel;
    DWORD* paPChannels;
    pSeg->m_pSegment->GetPChannels( &dwNumPChannels, &paPChannels );
    for( dwCount = 0; dwCount < dwNumPChannels; dwCount++ )
    {
        if( SUCCEEDED( PChannelIndex( paPChannels[dwCount],
            &dwIndex, &dwGroup, &dwMChannel )))
        {
            pafIndexUsed[dwIndex] = TRUE;
        }
    }
    for( dwCount = 0; dwCount < m_dwNumPorts; dwCount++ )
    {
        if( pafIndexUsed[dwCount] )
            break;
    }
    if( dwCount >= m_dwNumPorts )
    {
        delete [] pafIndexUsed;
        return GetLatency();
    }
    ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);
    for( dwIndex = 0; dwIndex < m_dwNumPorts; dwIndex++ )
    {
        if( pafIndexUsed[dwIndex] )
        {
            if( m_pPortTable[dwIndex].pLatencyClock )
            {
                if( SUCCEEDED( m_pPortTable[dwIndex].pLatencyClock->GetTime( &rtTemp )))
                {
                    if( rtTemp > rtLatency )
                        rtLatency = rtTemp;
                }
            }
            else if( m_pPortTable[dwIndex].pPort )
            {
                if( SUCCEEDED( m_pPortTable[dwIndex].pPort->GetLatencyClock( &m_pPortTable[dwIndex].pLatencyClock )))
                {
                    if( SUCCEEDED( m_pPortTable[dwIndex].pLatencyClock->GetTime( &rtTemp )))
                    {
                        if( rtTemp > rtLatency )
                            rtLatency = rtTemp;
                    }
                }
            }
        }
    }
    LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);
    if( 0 == rtLatency )
    {
        rtLatency = GetLatency();
    }
    delete [] pafIndexUsed;
    return rtLatency;
#endif // !XBOX
}

/*  Called from either QueuePrimarySegment or QueueSecondarySegment,
    this calculates the appropriate boundary time to start the segment
    playback. Most of the logic takes care of the new DMUS_SEGF_ALIGN
    capabilities.
*/


void CPerformance::CalculateSegmentStartTime( CSegState* pSeg )
{
    BOOL fNoValidStart = TRUE;
    if (pSeg->m_dwPlaySegFlags & DMUS_SEGF_ALIGN)
    {
        // If the ALIGN flag is set, see if we can align with the requested resolution,
        // but switch to the new segment at an earlier point, as defined by
        // a "valid start" point in the new segment.
        DMUS_VALID_START_PARAM ValidStart;    // Used to read start parameter from segment.
        MUSIC_TIME mtIntervalSize = 0;      // Quantization value.
        MUSIC_TIME mtTimeNow = (MUSIC_TIME)pSeg->m_rtGivenStart; // The earliest time this can start.
        // Call resolve time to get the last quantized interval that precedes mtTimeNow.
        MUSIC_TIME mtStartTime = ResolveTime( mtTimeNow, pSeg->m_dwPlaySegFlags, &mtIntervalSize );
        // StartTime actually shows the next time after now, so subtract the interval time to get the previous position.
        mtStartTime -= mtIntervalSize;
        // If the segment was supposed to start after the very beginning, quantize it.
        if (mtIntervalSize && pSeg->m_mtStartPoint)
        {
            pSeg->m_mtStartPoint = ((pSeg->m_mtStartPoint + (mtIntervalSize >> 1)) 
                / mtIntervalSize) * mtIntervalSize;
            // If this ends up being longer than the segment, do we need to drop back?
        }
        // Now, get the next start point after the point in the segment that 
        // corresponds with mtTimeNow, adjusted for the startpoint.
        if (SUCCEEDED(pSeg->m_pSegment->GetParam( GUID_Valid_Start_Time,-1,0,
            pSeg->m_mtStartPoint + mtTimeNow - mtStartTime,NULL,(void *) &ValidStart)))
        {
            // If the valid start point is within the range, we can cut in at the start point.
            if ((mtTimeNow - mtStartTime + ValidStart.mtTime) < (mtIntervalSize + pSeg->m_mtStartPoint))
            {
                pSeg->m_mtResolvedStart = mtTimeNow + ValidStart.mtTime;
                pSeg->m_mtStartPoint += mtTimeNow - mtStartTime + ValidStart.mtTime;
                fNoValidStart = FALSE;
            }
        }
        if (fNoValidStart)
        {
            // Couldn't find a valid start point. Was DMUS_SEGF_VALID_START_XXX set so we can override?
            if (pSeg->m_dwPlaySegFlags & 
                (DMUS_SEGF_VALID_START_MEASURE | DMUS_SEGF_VALID_START_BEAT | DMUS_SEGF_VALID_START_GRID | DMUS_SEGF_VALID_START_TICK))
            {
                MUSIC_TIME mtOverrideTime;
                // Depending on the flag, we need to get the appropriate interval resolution.
                if (pSeg->m_dwPlaySegFlags & DMUS_SEGF_VALID_START_MEASURE)
                {
                    mtOverrideTime = ResolveTime( mtTimeNow, DMUS_SEGF_MEASURE, 0 );
                } 
                else if (pSeg->m_dwPlaySegFlags & DMUS_SEGF_VALID_START_BEAT)
                {
                    mtOverrideTime = ResolveTime( mtTimeNow, DMUS_SEGF_BEAT, 0 );
                } 
                else if (pSeg->m_dwPlaySegFlags & DMUS_SEGF_VALID_START_GRID)
                {
                    mtOverrideTime = ResolveTime( mtTimeNow, DMUS_SEGF_GRID, 0 );
                } 
                else
                {
                    mtOverrideTime = mtTimeNow;
                }
                // If the valid start point is within the range, we can cut in at the start point.
                if ((mtOverrideTime - mtTimeNow) < (mtIntervalSize + pSeg->m_mtStartPoint))
                {
                    pSeg->m_mtResolvedStart = mtOverrideTime;
                    if ((mtOverrideTime - mtStartTime) >= mtIntervalSize)
                    {
                        mtOverrideTime -= mtIntervalSize;
                    }
/*Trace(0,"Startpoint %ld plus OverrideTime %ld - StartTime %ld = %ld\n",
      pSeg->m_mtStartPoint, mtOverrideTime - mtSegmentTime, mtStartTime - mtSegmentTime,
        pSeg->m_mtStartPoint + mtOverrideTime - mtStartTime);*/
                    pSeg->m_mtStartPoint += mtOverrideTime - mtStartTime;
                    fNoValidStart = FALSE;
                }
            }
        }
    }
    if (fNoValidStart)
    {
        pSeg->m_mtResolvedStart = ResolveTime( (MUSIC_TIME)pSeg->m_rtGivenStart,
            pSeg->m_dwPlaySegFlags, NULL );
    }
    else
    {
        // If we succeeded in finding a place to switch over, make sure it isn't deep inside
        // a loop. This is specifically a problem when syncing to segment and switching inside
        // or after a loop.
        while (pSeg->m_dwRepeats && (pSeg->m_mtStartPoint >= pSeg->m_mtLoopEnd))
        {
            pSeg->m_dwRepeats--;
            pSeg->m_mtStartPoint -= (pSeg->m_mtLoopEnd - pSeg->m_mtLoopStart);
        }
        // Since we were decrementing the repeats, we need to also decrement the repeats left.
        pSeg->m_dwRepeatsLeft = pSeg->m_dwRepeats;
        // Finally, if the startpoint is after the end of the segment, cut it back to the end of the
        // segment. This will cause it to play for time 0 and, if this is a transition segment, whatever
        // should play after will play immediately.
        if (pSeg->m_mtStartPoint > pSeg->m_mtLength)
        {
            pSeg->m_mtStartPoint = pSeg->m_mtLength;
        }
    }
    pSeg->m_mtOffset = pSeg->m_mtResolvedStart;
    pSeg->m_mtLastPlayed = pSeg->m_mtResolvedStart;
}

// this function should only be called from within a SegmentCrSec
// critical section!
void CPerformance::QueuePrimarySegment( CSegState* pSeg )
{
    CSegState* pTemp;
    BOOL fInCrSec = TRUE;
    BOOL fNotDone = TRUE;
    ENTER_CRITICAL_SECTION(&m_PipelineCrSec);
    pSeg->m_dwPlayTrackFlags |= DMUS_TRACKF_DIRTY;
    if( pSeg->m_dwPlaySegFlags & DMUS_SEGF_QUEUE )
    {
        MUSIC_TIME mtStart = 0;

        pTemp = m_SegStateQueues[SQ_PRI_PLAY].GetTail();
        if( pTemp )
        {
            mtStart = pTemp->GetEndTime( pTemp->m_mtResolvedStart );
        }
        else
        {
            pTemp = m_SegStateQueues[SQ_PRI_DONE].GetTail();
            if( pTemp )
            {
                mtStart = pTemp->m_mtLastPlayed;
            }
        }
        pSeg->m_dwPlaySegFlags &= ~DMUS_SEGF_QUEUE;
        if( NULL == pTemp )
        {
            // if there's nothing in the queue, this means play it now
            if( pSeg->m_dwPlaySegFlags & DMUS_SEGF_AFTERPREPARETIME )
            {
                // we want to queue this at the last transported time,
                // so we don't need to do an invalidate
                if( pSeg->m_dwPlaySegFlags & DMUS_SEGF_REFTIME )
                {
                    REFERENCE_TIME rtTrans;
                    MusicToReferenceTime( m_mtTransported, &rtTrans );
                    if( pSeg->m_rtGivenStart < rtTrans )
                    {
                        pSeg->m_dwPlaySegFlags &= ~DMUS_SEGF_REFTIME;
                        pSeg->m_rtGivenStart = m_mtTransported;
                    }
                }
                else
                {
                    if( pSeg->m_rtGivenStart < m_mtTransported )
                    {
                        pSeg->m_rtGivenStart = m_mtTransported;
                    }
                }
            }
            else
            {
                // This will be changed to Queue time below
                pSeg->m_rtGivenStart = 0;
            }
        }
        else
        {
            REFERENCE_TIME rtQueue;
            
            // otherwise, time stamp it with the time corresponding to
            // the end time of all segments currently in the queue.
            pSeg->m_mtResolvedStart = mtStart;
            // make sure the resolved start time isn't before the latency
            GetQueueTime(&rtQueue);
            ReferenceToMusicTime( rtQueue, &mtStart );
            if( pSeg->m_mtResolvedStart < mtStart )
            {
                pSeg->m_mtResolvedStart = 0; // below code will take care of this case
            }
            else
            {
                pSeg->m_dwPlaySegFlags &= ~DMUS_SEGF_REFTIME;
                pSeg->m_mtOffset = pSeg->m_mtResolvedStart;
                m_SegStateQueues[SQ_PRI_PLAY].Insert(pSeg);
                TraceI(2, "dmperf: queueing primary seg/DMUS_SEGF_QUEUE. Prev time=%ld, this=%ld\n",
                    pTemp->m_mtResolvedStart, pSeg->m_mtResolvedStart);
                fNotDone = FALSE;
                PrepSegToPlay(pSeg, true);
            }
        }
    }
    if( fNotDone && (pSeg->m_rtGivenStart == 0) )
    {
        // if the given start time is 0, it means play now.
        MUSIC_TIME mtStart;
        REFERENCE_TIME rtStart;

        GetQueueTime( &rtStart );
        ReferenceToMusicTime( rtStart, &mtStart );
        pSeg->m_dwPlaySegFlags &= ~DMUS_SEGF_REFTIME;
        pSeg->m_rtGivenStart = mtStart;
        // we definitely want to get rid of all segments following
        // the currently playing segment
        if( m_SegStateQueues[SQ_PRI_PLAY].GetHead() )
        {
            while( pTemp = m_SegStateQueues[SQ_PRI_PLAY].GetHead()->GetNext() )
            {
                m_SegStateQueues[SQ_PRI_PLAY].Remove(pTemp);
                pTemp->AbortPlay(mtStart,FALSE);
                m_ShutDownQueue.Insert(pTemp); 
            }
        }
    }
    if( fNotDone && pSeg->m_dwPlaySegFlags & DMUS_SEGF_REFTIME )
    {
        // rtStartTime is in RefTime units. 
        // We can convert this to Music Time immediately if either there
        // is no currently playing Primary Segment, or the conversion
        // falls within the time that has already played. If the time
        // falls within PREPARE_TIME, we need to get this Segment
        // playing right away.
        REFERENCE_TIME rtNow = GetLatencyWithPrePlay() + PREPARE_TIME + (200 * REF_PER_MIL); //m_rtQueuePosition;
        MUSIC_TIME mtTime;
        if( m_SegStateQueues[SQ_PRI_PLAY].IsEmpty() || ( pSeg->m_rtGivenStart <= rtNow ) )
        {
            ReferenceToMusicTime( pSeg->m_rtGivenStart, &mtTime );
            pSeg->m_dwPlaySegFlags &= ~( DMUS_SEGF_REFTIME );
            pSeg->m_rtGivenStart = mtTime;
            // let the block of code below that handles music time
            // deal with it from here on
        }
        else
        {
            // Otherwise, we must wait until rtStartTime
            // has been performed in order to convert to music time, because
            // we require the tempo map at that time to do the conversion.
            // This will be handled by the Transport code.
            m_SegStateQueues[SQ_PRI_WAIT].Insert(pSeg);
            fNotDone = FALSE; // prevents the next block of code from operating on
                        // this Segment.
        }
    }
    if( fNotDone ) // music time
    {
        // if we're in music time units, we can queue this segment in the
        // main queue, in time order. If this segment's music time is less
        // than the start time of other segments in the queue, all of those
        // segments are removed and discarded. Also, segments that are in
        // the wait queue as RefTime are discarded.
        
        ASSERT( !(pSeg->m_dwPlaySegFlags & DMUS_SEGF_REFTIME )); // m_rtGivenStart must be in music time
        CalculateSegmentStartTime( pSeg );
        while( (pTemp = m_SegStateQueues[SQ_PRI_WAIT].RemoveHead()) )
        {
            pTemp->AbortPlay(pSeg->m_mtResolvedStart,FALSE);
            m_ShutDownQueue.Insert(pTemp);
        }
        if( pTemp = m_SegStateQueues[SQ_PRI_PLAY].GetHead() )
        {
            if( pSeg->m_mtResolvedStart > pTemp->m_mtResolvedStart )
            {
                while( pTemp->GetNext() )
                {
                    if( pTemp->GetNext()->m_mtResolvedStart >= pSeg->m_mtResolvedStart )
                    {
                        break;
                    }
                    pTemp = pTemp->GetNext();
                }
                pSeg->SetNext(pTemp->GetNext());
                pTemp->SetNext(pSeg);
                while( pTemp = pSeg->GetNext() )
                {
                    // delete the remaining pSegs after this one
                    pSeg->SetNext(pTemp->GetNext());
                    pTemp->AbortPlay(pSeg->m_mtResolvedStart,FALSE);
                    m_ShutDownQueue.Insert(pTemp); 
                }
            }
            else
            {
                if( !pTemp->m_fStartedPlay )
                {
                    // blow away the entire queue
                    while( m_SegStateQueues[SQ_PRI_PLAY].GetHead() )
                    {
                        pTemp = m_SegStateQueues[SQ_PRI_PLAY].RemoveHead();
                        pTemp->AbortPlay(pSeg->m_mtResolvedStart,FALSE);
                        m_ShutDownQueue.Insert(pTemp); 
                    }
                    m_SegStateQueues[SQ_PRI_PLAY].AddHead(pSeg);
                    // give this a chance to start performing if it's near
                    // enough to time
                    if( fInCrSec )
                    {
                        LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);
                        fInCrSec = FALSE;
                    }
                    SyncTimeSig( pSeg );
                    ManageControllingTracks();
                    PerformSegStNode( SQ_PRI_PLAY,pSeg);
                }
                else
                {
                    // else, place this segment after the current one
                    // and count on the routine below to take care of dequeing
                    // the current one, because in this case m_mtLastPlayed
                    // must be greater than m_mtResolvedStart.
                    if ( m_SegStateQueues[SQ_PRI_PLAY].GetHead()->m_mtLastPlayed <= 
                        m_SegStateQueues[SQ_PRI_PLAY].GetHead()->m_mtResolvedStart )
                    {
                        TraceI(0,"Current Primary segment has not started playing.\n");
                    }
                    m_SegStateQueues[SQ_PRI_PLAY].AddHead(pSeg);
                    MUSIC_TIME mtTime = pSeg->m_mtResolvedStart;
                    while( pTemp = pSeg->GetNext() )
                    {
                        pTemp->AbortPlay( mtTime, TRUE && (pSeg->m_dwPlaySegFlags & DMUS_SEGF_NOINVALIDATE) );
                        // delete the remaining pSegs after this one
                        pSeg->SetNext(pTemp->GetNext());
                        m_ShutDownQueue.Insert(pTemp); 
                    }
                }
            }
            // m_pPriSegQueue could have become NULL from the PerformSegStNode call above.
            if( m_SegStateQueues[SQ_PRI_PLAY].GetHead() && (pSeg != m_SegStateQueues[SQ_PRI_PLAY].GetHead()) )
            {
                CSegState *pCurrentSeg = m_SegStateQueues[SQ_PRI_PLAY].GetHead();
                if( pCurrentSeg->m_fStartedPlay &&
                    ( pSeg->m_mtResolvedStart <= pCurrentSeg->m_mtLastPlayed ))
                {
                    // If Playsegment is recursively called by the end of a previous segment in a song, don't abort.
                    if (!pCurrentSeg->m_fInPlay || !pCurrentSeg->m_fSongMode)
                    {
                        // the new segment wants to play on top of stuff that's
                        // already been transported by the current primary segment.
                        pCurrentSeg->AbortPlay(pSeg->m_mtResolvedStart-1,TRUE && (pSeg->m_dwPlaySegFlags & DMUS_SEGF_NOINVALIDATE));
                        m_SegStateQueues[SQ_PRI_DONE].Insert(m_SegStateQueues[SQ_PRI_PLAY].RemoveHead());
                        // make sure none of the last played times in the past list
                        // are past the resolved start
                        for( CSegState* pSegTemp = m_SegStateQueues[SQ_PRI_DONE].GetHead(); 
                            pSegTemp; pSegTemp = pSegTemp->GetNext() )
                        {
                            if( pSegTemp->m_mtLastPlayed > pSeg->m_mtResolvedStart )
                            {
                                pSegTemp->m_mtLastPlayed = pSeg->m_mtResolvedStart;
                            }
                        }
                        if( !( pSeg->m_dwPlaySegFlags & (DMUS_SEGF_NOINVALIDATE | DMUS_SEGF_INVALIDATE_PRI) ) )
                        {
                            // if we set the PREPARE flag it means we specifically
                            // don't want to invalidate
                            Invalidate( pSeg->m_mtResolvedStart, pSeg->m_dwPlaySegFlags );
                        }
                        else if ( (pSeg->m_dwPlaySegFlags & DMUS_SEGF_INVALIDATE_PRI) &&
                                   !(pSeg->m_dwPlaySegFlags & DMUS_SEGF_NOINVALIDATE) )
                        {
                            pCurrentSeg->Flush(pSeg->m_mtResolvedStart);
                        }
                        ASSERT( m_SegStateQueues[SQ_PRI_PLAY].GetHead() == pSeg ); // this should be the case
                        if( fInCrSec )
                        {
                            LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);
                            fInCrSec = FALSE;
                        }
                        SyncTimeSig( pSeg );
                        ManageControllingTracks();
                        PerformSegStNode( SQ_PRI_PLAY,m_SegStateQueues[SQ_PRI_PLAY].GetHead() );
                    }
                }
                else
                {
                    if( !( pSeg->m_dwPlaySegFlags & 
                        (DMUS_SEGF_NOINVALIDATE | DMUS_SEGF_INVALIDATE_PRI) ))
                    {
                        Invalidate( pSeg->m_mtResolvedStart, pSeg->m_dwPlaySegFlags );
                    }
                    else if ( (pSeg->m_dwPlaySegFlags & DMUS_SEGF_INVALIDATE_PRI) &&
                             !(pSeg->m_dwPlaySegFlags & DMUS_SEGF_NOINVALIDATE) )
                    {
                        pCurrentSeg->Flush(pSeg->m_mtResolvedStart);
                    }
                }
            }
        }
        else
        {
            m_SegStateQueues[SQ_PRI_PLAY].AddHead(pSeg);
            // give this a chance to start performing if it's near
            // enough to time
            if( fInCrSec )
            {
                LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);
                fInCrSec = FALSE;
            }
			//DWORD dwDebugTime = timeGetTime();
            SyncTimeSig( pSeg );
			//DWORD dwDebugTime2 = timeGetTime();
			//Trace(0, "perf, debugtime SyncTimeSig %u\n", dwDebugTime2 - dwDebugTime);

            ManageControllingTracks();
			//dwDebugTime = timeGetTime();
			//Trace(0, "perf, debugtime ManageControllingTracks %u\n", dwDebugTime - dwDebugTime2);

            PerformSegStNode( SQ_PRI_PLAY,pSeg );
			//dwDebugTime2 = timeGetTime();
			//Trace(0, "perf, debugtime PerformSegStNode %u\n", dwDebugTime2 - dwDebugTime);
        }
    }
    if( fInCrSec )
    {
        LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);
    }
}

// this function should only be called from within a SegmentCrSec
// critical section!
void CPerformance::QueueSecondarySegment( CSegState* pSeg)
{
    BOOL fInCrSec = FALSE;
    BOOL fNotDone = TRUE;

    if( pSeg->m_dwPlaySegFlags & DMUS_SEGF_CONTROL )
    {
        ENTER_CRITICAL_SECTION(&m_PipelineCrSec);
        fInCrSec = TRUE;
    }
    pSeg->m_dwPlaySegFlags &= ~DMUS_SEGF_QUEUE; // not legal for 2ndary segs.
    if( pSeg->m_rtGivenStart == 0 )
    {
        MUSIC_TIME mtStart;
        
        if( pSeg->m_dwPlaySegFlags & DMUS_SEGF_CONTROL )
        {
            REFERENCE_TIME rtStart;
            GetQueueTime( &rtStart ); // need queue time because control segments cause invalidations
            ReferenceToMusicTime( rtStart, &mtStart );
        }
        else
        {
            ReferenceToMusicTime( GetBestSegLatency(pSeg), &mtStart );
        }
        pSeg->m_dwPlaySegFlags &= ~DMUS_SEGF_REFTIME;
        pSeg->m_rtGivenStart = mtStart;
    }

    if( pSeg->m_dwPlaySegFlags & DMUS_SEGF_REFTIME )
    {
        // rtStartTime is in RefTime units. 
        // We can convert this to Music Time immediately if either there
        // is no currently playing Primary Segment, or the conversion
        // falls within the time that has already played. If the time
        // falls within PREPARE_TIME, we need to get this Segment
        // playing right away.
        REFERENCE_TIME rtNow;
        if( pSeg->m_dwPlaySegFlags & DMUS_SEGF_CONTROL )
        {
            GetQueueTime( &rtNow ); // need queue time because control segments cause invalidations
        }
        else
        {
            rtNow = GetBestSegLatency(pSeg);
        }
        MUSIC_TIME mtTime;
        if( pSeg->m_rtGivenStart <= rtNow )
        {
            ReferenceToMusicTime( rtNow, &mtTime );
            pSeg->m_dwPlaySegFlags &= ~( DMUS_SEGF_REFTIME );
            pSeg->m_rtGivenStart = mtTime;
            // let the block of code below that handles music time
            // deal with it from here on
        }
        else if( m_SegStateQueues[SQ_PRI_PLAY].IsEmpty() )
        {
            ReferenceToMusicTime( pSeg->m_rtGivenStart, &mtTime );
            pSeg->m_dwPlaySegFlags &= ~( DMUS_SEGF_REFTIME );
            pSeg->m_rtGivenStart = mtTime;
        }
        else
        {
            // Otherwise, we must wait until rtStartTime
            // has been performed in order to convert to music time, because
            // we require the tempo map at that time to do the conversion.
            // This will be handled by the Transport code.
            m_SegStateQueues[SQ_SEC_WAIT].Insert(pSeg);
            fNotDone = FALSE; // prevents the next block of code from operating on
                        // this Segment.
        }
    }

    if( fNotDone ) // music time
    {
        // if we're in music time units, we can queue this segment in the
        // main queue, in time order. If this segment's music time is less
        // than the start time of other segments in the queue, all of those
        // segments are removed and discarded.
        ASSERT( !(pSeg->m_dwPlaySegFlags & DMUS_SEGF_REFTIME )); // m_m_rtGivenStart must be in music time
        CalculateSegmentStartTime( pSeg );
        TraceI(2,"Queuing 2ndary seg time %ld\n",pSeg->m_mtResolvedStart);
        if( pSeg->m_dwPlaySegFlags & DMUS_SEGF_CONTROL)
        {
            m_SegStateQueues[SQ_CON_PLAY].Insert( pSeg );
            // If this is a control segment, we need to do an invalidate.
            if(!(pSeg->m_dwPlaySegFlags & DMUS_SEGF_NOINVALIDATE) )
            {
                ManageControllingTracks();
                Invalidate( pSeg->m_mtResolvedStart, 0 );
            }
        }
        else
        {
            m_SegStateQueues[SQ_SEC_PLAY].Insert( pSeg );
        }
        // give this a chance to start performing if it's near
        // enough to time
        if( fInCrSec )
        {
            LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);
            fInCrSec = FALSE;
        }
        // play the secondary segments
        CSegState *pNode = m_SegStateQueues[SQ_SEC_PLAY].GetHead();
        CSegState *pNext;
        for(; pNode != NULL; pNode = pNext)
        {
            pNext = pNode->GetNext();
            PerformSegStNode( SQ_SEC_PLAY,pNode );
        }
        // play the controlling segments
        pNode = m_SegStateQueues[SQ_CON_PLAY].GetHead();
        for(; pNode != NULL; pNode = pNext)
        {
            pNext = pNode->GetNext();
            PerformSegStNode( SQ_CON_PLAY,pNode );
        }
    }
    if( fInCrSec )
    {
        LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);
    }
}

/*  If a segment is controlling, this establishes which tracks in the currently playing
    primary segment are disabled. 
    We store temporary information in each playing track's m_dwInternalFlags, which is not used
    otherwise in segmentstates. 
    
    Four scenarios, each for play and notify:
    1) An officially enabled track is currently enabled and gets disabled. 
    2) An officially enabled track is currently disabled and continues to be disabled.
    3) An officially enabled track is currently disabled and gets enabled.
    4) An officially disabled track is left disabled. If none of the CONTROL_ flags are set and the track is disabled,
       set the _WAS_DISABLED flag, which also indicates that this should be left alone.

    This should get called every time a primary or secondary segment starts or stop, so it
    can recalculate the behavior of all tracks in the primary segment.
*/

void CPerformance::ManageControllingTracks()

{
    ENTER_CRITICAL_SECTION(&m_SegmentCrSec);
    CSegState* pSegNode;
    // First, prepare all tracks in the primary segment, putting them back to normal. 
    // so they are ready to be reset by the controlling tracks.
    // To do this, check for WAS_ENABLED or WAS_DISABLED and set the appropriate flags in m_dwFlags.
    // Else, if these weren't set, then it's time to set them, since this is the first pass through this segment.
    for( pSegNode = m_SegStateQueues[SQ_PRI_PLAY].GetHead(); pSegNode; pSegNode = pSegNode->GetNext() )
    {
        ENTER_CRITICAL_SECTION(&pSegNode->m_CriticalSection);
        CTrack *pTrack = pSegNode->m_TrackList.GetHead();
        for (;pTrack;pTrack = pTrack->GetNext())
        {
            if (pTrack->m_dwInternalFlags) // This has been touched before.
            {
                // First transfer and reset the is disabled flags.
                if (pTrack->m_dwInternalFlags & CONTROL_PLAY_IS_DISABLED)
                {
                    pTrack->m_dwInternalFlags |= CONTROL_PLAY_WAS_DISABLED;
                }
                pTrack->m_dwInternalFlags &= ~(CONTROL_PLAY_IS_DISABLED | CONTROL_NTFY_IS_DISABLED);
                // Then, set the play flags based on the original state.
                if (pTrack->m_dwInternalFlags & CONTROL_PLAY_DEFAULT_ENABLED)
                {
                    pTrack->m_dwFlags |= DMUS_TRACKCONFIG_PLAY_ENABLED;
                }
                if (pTrack->m_dwInternalFlags & CONTROL_NTFY_DEFAULT_ENABLED)
                {
                    pTrack->m_dwFlags |= DMUS_TRACKCONFIG_NOTIFICATION_ENABLED;
                }
            }
            else
            {
                // Since this has never been touched before, set the flags so we can know what to return to.
                if (pTrack->m_dwFlags & DMUS_TRACKCONFIG_PLAY_ENABLED)
                {
                    pTrack->m_dwInternalFlags = CONTROL_PLAY_DEFAULT_ENABLED;
                }
                else
                {
                    pTrack->m_dwInternalFlags = CONTROL_PLAY_DEFAULT_DISABLED;
                }
                if (pTrack->m_dwFlags & DMUS_TRACKCONFIG_NOTIFICATION_ENABLED)
                {
                    pTrack->m_dwInternalFlags |= CONTROL_NTFY_DEFAULT_ENABLED;
                }
                else
                {
                    pTrack->m_dwInternalFlags |= CONTROL_NTFY_DEFAULT_DISABLED;
                }
            }
        }
        LEAVE_CRITICAL_SECTION(&pSegNode->m_CriticalSection);
    }
    CSegState* pControlNode;
    // Now, go through all the controlling segments and, for each controlling track that matches
    // a primary segment track, clear the enable flags on the segment track.
    for( pControlNode = m_SegStateQueues[SQ_CON_PLAY].GetHead(); pControlNode; pControlNode = pControlNode->GetNext() )
    {
        ENTER_CRITICAL_SECTION(&pControlNode->m_CriticalSection);
        CTrack *pTrack = pControlNode->m_TrackList.GetHead();
        for (;pTrack;pTrack = pTrack->GetNext())
        {
            // If the track has never been overridden, the internal flags for IS_DISABLED should be clear.
            // If the track is currently overridden, the internal flags should be CONTROL_PLAY_IS_DISABLED and/or 
            // CONTROL_NTFY_IS_DISABLED
            if (pTrack->m_dwFlags & (DMUS_TRACKCONFIG_CONTROL_PLAY | DMUS_TRACKCONFIG_CONTROL_NOTIFICATION)) // This overrides playback and/or notification.
            {
                for( pSegNode = m_SegStateQueues[SQ_PRI_PLAY].GetHead(); pSegNode; pSegNode = pSegNode->GetNext() )
                {
                    ENTER_CRITICAL_SECTION(&pSegNode->m_CriticalSection);
                    CTrack *pPrimaryTrack = pSegNode->m_TrackList.GetHead();
                    for (;pPrimaryTrack;pPrimaryTrack = pPrimaryTrack->GetNext())
                    {
                        // A track matches if it has the same class id and overlapping group bits.
                        if ((pPrimaryTrack->m_guidClassID == pTrack->m_guidClassID) &&
                            (pPrimaryTrack->m_dwGroupBits & pTrack->m_dwGroupBits))
                        {
                            if ((pTrack->m_dwFlags & DMUS_TRACKCONFIG_CONTROL_PLAY) &&
                                (pPrimaryTrack->m_dwFlags & DMUS_TRACKCONFIG_PLAY_ENABLED))
                            {
                                pPrimaryTrack->m_dwFlags &= ~DMUS_TRACKCONFIG_PLAY_ENABLED;
                                pPrimaryTrack->m_dwInternalFlags |= CONTROL_PLAY_IS_DISABLED; // Mark so we can turn on later.
                            }
                            if ((pTrack->m_dwFlags & DMUS_TRACKCONFIG_CONTROL_NOTIFICATION) &&
                                (pPrimaryTrack->m_dwFlags & DMUS_TRACKCONFIG_NOTIFICATION_ENABLED))
                            {
                                pPrimaryTrack->m_dwFlags &= ~DMUS_TRACKCONFIG_NOTIFICATION_ENABLED;
                                pPrimaryTrack->m_dwInternalFlags |= CONTROL_NTFY_IS_DISABLED; // Mark so we can turn on later.
                            }
                        }
                    }
                    LEAVE_CRITICAL_SECTION(&pSegNode->m_CriticalSection);
                }
            }
        }
        LEAVE_CRITICAL_SECTION(&pControlNode->m_CriticalSection);
    }
    // Now, go back to the primary segment and find all tracks that have been reenabled
    // and tag them so they will generate refresh data on the next play (by seeking, as if they 
    // were starting or looping playback.) We only do this for play, not notify, because no
    // notifications have state.
    for( pSegNode = m_SegStateQueues[SQ_PRI_PLAY].GetHead(); pSegNode; pSegNode = pSegNode->GetNext() )
    {
        ENTER_CRITICAL_SECTION(&pSegNode->m_CriticalSection);
        CTrack *pTrack = pSegNode->m_TrackList.GetHead();
        for (;pTrack;pTrack = pTrack->GetNext())
        {
            if ((pTrack->m_dwInternalFlags & CONTROL_PLAY_DEFAULT_ENABLED) &&
                (pTrack->m_dwInternalFlags & CONTROL_PLAY_WAS_DISABLED) &&
                !(pTrack->m_dwInternalFlags & CONTROL_PLAY_IS_DISABLED))
            {
                pTrack->m_dwInternalFlags |= CONTROL_PLAY_REFRESH; // Mark so we can turn on later.
            }
        }
        LEAVE_CRITICAL_SECTION(&pSegNode->m_CriticalSection);
    }
    LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);
}

void CPerformance::GetTimeSig( MUSIC_TIME mtTime, DMUS_TIMESIG_PMSG* pTimeSig )
{
    ENTER_CRITICAL_SECTION(&m_PipelineCrSec);
    PRIV_PMSG* pEvent = m_TimeSigQueue.GetHead();
    for (;pEvent;pEvent = pEvent->pNext)
    {
        // If this is the last time sig, return it. Or, if the next time sig is after mtTime.
        if (!pEvent->pNext || ( pEvent->pNext->mtTime > mtTime ))
        {
            DMUS_TIMESIG_PMSG* pNewTimeSig = (DMUS_TIMESIG_PMSG*)PRIV_TO_DMUS(pEvent);
            memcpy( pTimeSig, pNewTimeSig, sizeof(DMUS_TIMESIG_PMSG) );
            LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);
            return;
        }
    }
    // This should only happen if there is no timesig at all. Should only happen before any segments play.
    memset( pTimeSig, 0, sizeof(DMUS_TIMESIG_PMSG ) );
    pTimeSig->wGridsPerBeat = 4;
    pTimeSig->bBeatsPerMeasure = 4;
    pTimeSig->bBeat = 4;
    LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);
}

void CPerformance::SyncTimeSig( CSegState *pSegState )

/*  If a primary segment is played that does not have a time signature track,
    this forces the current time signature to line up with the start of the
    primary segment. 
*/

{
    // First, test to see if the segment has a time signature.
    // If it doesn't then we need to do this.
    DMUS_TIMESIGNATURE TimeSig;
    if (FAILED(pSegState->GetParam(this,GUID_TimeSignature,-1,0,0,NULL,(void *)&TimeSig)))
    {
        MUSIC_TIME mtTime = pSegState->m_mtResolvedStart;
        ENTER_CRITICAL_SECTION(&m_PipelineCrSec);
        PRIV_PMSG* pEvent = m_TimeSigQueue.GetHead();
        // Scan through the time signatures until the most recent one is found.
        for (;pEvent;pEvent = pEvent->pNext)
        {
            // If this is the last time sig, return it. Or, if the next time sig is after mtTime.
            if (!pEvent->pNext || ( pEvent->pNext->mtTime > mtTime ))
            {
                pEvent->mtTime = mtTime;
                MusicToReferenceTime(mtTime,&pEvent->rtTime);
                break;
            }
        }
        // Should never fall through to here without finding a time signature because Init() creates a timesig.
        LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);
    }
}

// Convert mtTime into the resolved time according to the resolution in 
// dwResolution.
// This should only be called from within a segment critical section.
MUSIC_TIME CPerformance::ResolveTime( MUSIC_TIME mtTime, DWORD dwResolution, MUSIC_TIME *pmtIntervalSize )
{
    if (pmtIntervalSize)
    {
        *pmtIntervalSize = 0;
    }
    if (dwResolution & DMUS_SEGF_MARKER)
    {
        DMUS_PLAY_MARKER_PARAM Marker;
        MUSIC_TIME mtNext;
        // First, get the time of the marker preceding this one.
        if (SUCCEEDED (GetParam(GUID_Play_Marker,-1,0,mtTime,&mtNext,(void *) &Marker)))
        {
            BOOL fIsMarker = FALSE;
            MUSIC_TIME mtInitialTime = mtTime;
            MUSIC_TIME mtFirst = mtTime + Marker.mtTime; // This is the time of the preceding marker.
            MUSIC_TIME mtSecond = mtTime + mtNext;  // This might be the time of the next marker.
            // Then, scan forward until a marker is found after or equal to this time.
            // If a loop point or end of segment is encountered, the value in Marker.mtTime will
            // continue to be negative. Once we hit the actual marker, it will become 0, since
            // we are asking for the marker at that specific time.
            while (mtNext)
            {
                mtTime += mtNext;
                if (SUCCEEDED(GetParam(GUID_Play_Marker,-1,0,mtTime,&mtNext,(void *) &Marker)))
                {
                    // If the marker time is 0, this means we are sitting right on the marker, 
                    // so we are done. 
                    if (fIsMarker = (Marker.mtTime == 0))
                    {
                        mtSecond = mtTime;
                        break;
                    }
                    // Otherwise, this was a loop boundary or segment end, so we should continue scanning forward.
                }
                else
                {
                    // GetParam failed, must be nothing more to search. 
                    break;
                }
            }            
            // If the caller wants the interval size, then we know they are interested in 
            // aligning to a previous marker as well as a future one. In that case, 
            // if we didn't find a marker in the future, it's okay because it will 
            // use the previous marker (mtFirst) anyway.
            // For all other cases, we only return if the upcoming marker is legal.
            // Otherwise, we drop through and try other resolutions.
            if (pmtIntervalSize || fIsMarker)
            {
                if (pmtIntervalSize)
                {
                    *pmtIntervalSize = mtSecond - mtFirst;
                }
                return mtSecond;
            }
            mtTime = mtInitialTime;
        }
        // If marker fails, we can drop down to the other types...
    }
    if( dwResolution & DMUS_SEGF_SEGMENTEND )
    {
        // In this mode, we don't actually get the time signature. Instead, we
        // find out the time of the next segment start after the requested time. 
        CSegState *pSegNode = GetPrimarySegmentAtTime( mtTime );
        if( pSegNode )
        {
            // First, calculate the end time of the segment.
            // Include any starting offset so we see the full span of the segment.
            mtTime = pSegNode->GetEndTime( pSegNode->m_mtStartPoint );
            if (pmtIntervalSize)
            {
                // Interval would be the length of the primary segment!
                *pmtIntervalSize = mtTime;
            }
            // Return the end of the segment.
            LONGLONG llEnd = mtTime + (LONGLONG)(pSegNode->m_mtResolvedStart - pSegNode->m_mtStartPoint);
            if(llEnd > 0x7fffffff) llEnd = 0x7fffffff;
            mtTime = (MUSIC_TIME) llEnd;
            return mtTime;

        }
        // If there was no segment, we should fail and try the other flags.
    }
    long        lQuantize;
    MUSIC_TIME  mtNewTime;
    MUSIC_TIME  mtStartOfTimeSig = 0;
    DMUS_TIMESIGNATURE  timeSig;
    if (!(dwResolution & DMUS_SEGF_TIMESIG_ALWAYS))
    {
        if (!GetPrimarySegmentAtTime(mtTime))
        {
            return mtTime;
        }
    }
    GetParam(GUID_TimeSignature,-1,0,mtTime,NULL,(void *) &timeSig);
    mtStartOfTimeSig = timeSig.mtTime + mtTime;
    mtNewTime = mtTime - mtStartOfTimeSig;
    if (dwResolution & DMUS_SEGF_MEASURE)
    {
        lQuantize = ( DMUS_PPQ * 4 * timeSig.bBeatsPerMeasure ) / timeSig.bBeat;
    }
    else if (dwResolution & DMUS_SEGF_BEAT)
    {
        lQuantize = ( DMUS_PPQ * 4 ) / timeSig.bBeat;
    }
    else if (dwResolution & DMUS_SEGF_GRID)
    {
        lQuantize = ( ( DMUS_PPQ * 4 ) / timeSig.bBeat ) / timeSig.wGridsPerBeat;
    }
    else
    {
        lQuantize = 1;
    }
    if (lQuantize == 0) // Avoid divide by 0 error.
    {
        lQuantize = 1;
    }
    if (pmtIntervalSize)
    {
        *pmtIntervalSize = lQuantize;
    }
    if( mtNewTime ) // if it's 0 it stays 0
    {
        // round up to next boundary
        mtNewTime = ((mtNewTime-1) / lQuantize ) * lQuantize;
        mtNewTime += lQuantize;
    }
    return (mtNewTime + mtStartOfTimeSig);
}

// returns:
// true if the note should be invalidated (any other return code will invalidate)
// false if the note should not be invalidated
inline bool GetInvalidationStatus(DMUS_PMSG* pPMsg)
{
    bool fResult = true; // default: invalidate the note

    if( pPMsg->dwType == DMUS_PMSGT_NOTE )
    {
        DMUS_NOTE_PMSG* pNote = (DMUS_NOTE_PMSG*)pPMsg;
        if (pNote->bFlags & DMUS_NOTEF_NOINVALIDATE)
        {
            fResult = false;
        }
    }
    else if( pPMsg->dwType == DMUS_PMSGT_WAVE )
    {
        DMUS_WAVE_PMSG* pWave = (DMUS_WAVE_PMSG*)pPMsg;
        if(pWave->bFlags & DMUS_WAVEF_NOINVALIDATE)
        {
            fResult = false;
        }
    }
    else if( pPMsg->dwType == DMUS_PMSGT_NOTIFICATION )
    {
        // Don't invalidate segment abort messages
        DMUS_NOTIFICATION_PMSG* pNotification = (DMUS_NOTIFICATION_PMSG*) pPMsg;
        if ((pNotification->guidNotificationType == GUID_NOTIFICATION_SEGMENT) &&
            (pNotification->dwNotificationOption == DMUS_NOTIFICATION_SEGABORT))
		{
            fResult = false;
		}
    }
    return fResult;
}

static inline long ComputeCurveTimeSlice(DMUS_CURVE_PMSG* pCurve)
{
    long lTimeIncrement;
    DWORD dwTotalDistance;
    DWORD dwResolution;
    if (pCurve->bType == DMUS_CURVET_PBCURVE) 
    {
        dwResolution = 10;
    }
    else if ((pCurve->bType == DMUS_CURVET_RPNCURVE) ||
        (pCurve->bType == DMUS_CURVET_NRPNCURVE))
    {
        dwResolution = 100;
    }
    else
    {
        dwResolution = 3;
    }
    if (pCurve->nEndValue > pCurve->nStartValue)
        dwTotalDistance = pCurve->nEndValue - pCurve->nStartValue;
    else 
        dwTotalDistance = pCurve->nStartValue - pCurve->nEndValue;
    if (dwTotalDistance == 0) dwTotalDistance = 1;
    lTimeIncrement = (pCurve->mtDuration * dwResolution) / dwTotalDistance;
    // Force to no smaller than 192nd note (10ms at 120 bpm.)
    if( lTimeIncrement < (DMUS_PPQ/48) ) lTimeIncrement = DMUS_PPQ/48;
    return lTimeIncrement;
}

static DWORD ComputeCurve( DMUS_CURVE_PMSG* pCurve )
{
    DWORD dwRet;
    short *panTable;
    MUSIC_TIME mtCurrent;
    long lIndex;

    switch( pCurve->bCurveShape )
    {
    case DMUS_CURVES_INSTANT:
    default:
        if( pCurve->dwFlags & DMUS_PMSGF_TOOL_FLUSH )
        {
            pCurve->rtTime = 0;
            return (DWORD)pCurve->nResetValue;
        }
        if( ( pCurve->bFlags & DMUS_CURVE_RESET ) && ( pCurve->mtResetDuration > 0 ) )
        {
            pCurve->mtTime = pCurve->mtResetDuration + pCurve->mtOriginalStart;
            pCurve->mtDuration = 0;
            pCurve->dwFlags &= ~DMUS_PMSGF_REFTIME;
        }
        else
        {
            pCurve->rtTime = 0; // setting this to 0 will free the event upon return
        }
        return (DWORD)pCurve->nEndValue;
        break;
    case DMUS_CURVES_LINEAR:
        panTable = &ganCT_Linear[ 0 ];
        break;
    case DMUS_CURVES_EXP:
        panTable = &ganCT_Exp[ 0 ];
        break;
    case DMUS_CURVES_LOG:
        panTable = &ganCT_Log[ 0 ];
        break;
    case DMUS_CURVES_SINE:
        panTable = &ganCT_Sine[ 0 ];
        break;
    }

    // compute index into table
    // there are CT_MAX + 1 elements in the table.
    mtCurrent = pCurve->mtTime - pCurve->mtOriginalStart;

    // if we're flushing this event, send the reset value
    if( pCurve->dwFlags & DMUS_PMSGF_TOOL_FLUSH )
    {
        // it will only get here if pCurve->bFlags & 1, because that is checked in
        // the :Flush() routine.
        pCurve->rtTime = 0;
        return pCurve->nResetValue;
    }
    
    // this should now never happen, as a result of fixing 33987: Transition on a beat boundary invalidates CC's right away (doesn't wait for the beat)
    if( (pCurve->bFlags & DMUS_CURVE_RESET) &&
        (pCurve->mtResetDuration < 0 ) && // this can happen from flushing
        (pCurve->mtTime >= pCurve->mtOriginalStart + pCurve->mtDuration + pCurve->mtResetDuration ))
    {
        pCurve->rtTime = 0;
        return pCurve->nResetValue;
    }
    else if( (pCurve->mtDuration == 0) ||
        (pCurve->mtTime - pCurve->mtOriginalStart >= pCurve->mtDuration ))
    {
        // if we're supposed to send the return value (m_bFlags & 1) then
        // set it up to do so. Otherwise, free the event.
        if( pCurve->bFlags & DMUS_CURVE_RESET )
        {
            pCurve->mtTime = pCurve->mtDuration + pCurve->mtResetDuration +
                pCurve->mtOriginalStart;
            pCurve->dwFlags &= ~DMUS_PMSGF_REFTIME;
        }
        else
        {
            pCurve->rtTime = 0; // time to free the event, we're done
        }
        dwRet = pCurve->nEndValue;
    }
    else
    {
        // Calculate how far into the table we should be.
        lIndex = (mtCurrent * (CT_MAX + 1)) / pCurve->mtDuration;

        // find an amount of time to add to the curve event such that there is at
        // least a change by CT_FACTOR. This will be used as the time stamp
        // for the next iteration of the curve.

        // clamp lIndex
        if( lIndex < 0 )
        {
            lIndex = 0;
        }
        if( lIndex >= CT_MAX )
        {
            lIndex = CT_MAX;
            dwRet = pCurve->nEndValue;
        }
        else
        {
            // Okay, in the curve, so calculate the return value.
            dwRet = ((panTable[lIndex] * (pCurve->nEndValue - pCurve->nStartValue)) / 
                CT_DIVFACTOR) + pCurve->nStartValue;
        }
        
        // this should now never happen, as a result of fixing 33987
        if( (pCurve->bFlags & DMUS_CURVE_RESET) && (pCurve->mtResetDuration < 0) )
        {
            // this can happen as a result of flushing. We want to make sure the next
            // time is the reset flush time.
            pCurve->mtTime = pCurve->mtDuration + pCurve->mtResetDuration +
                pCurve->mtOriginalStart;
        }
        else
        {
            // Within curve, so increment time.
            if (!pCurve->wMeasure) // oops --- better compute this.
            {
                TraceI(2, "Warning: Computing curve time slice...\n");
                pCurve->wMeasure = (WORD) ComputeCurveTimeSlice(pCurve);  // Use this to store the time slice interval.
            }
            pCurve->mtTime += pCurve->wMeasure; // We are storing the time increment here.
        }
        if( pCurve->mtTime > pCurve->mtDuration + pCurve->mtOriginalStart )
        {
            pCurve->mtTime = pCurve->mtDuration + pCurve->mtOriginalStart;
        }
        pCurve->dwFlags &= ~DMUS_PMSGF_REFTIME;

    }
    return dwRet;
}

static int RecomputeCurveEnd( DMUS_CURVE_PMSG* pCurve, MUSIC_TIME mtCurrent )
{
    int nRet = 0;
    short *panTable;

    switch( pCurve->bCurveShape )
    {
    case DMUS_CURVES_INSTANT:
    default:
        return pCurve->nEndValue;
        break;
    case DMUS_CURVES_LINEAR:
        panTable = &ganCT_Linear[ 0 ];
        break;
    case DMUS_CURVES_EXP:
        panTable = &ganCT_Exp[ 0 ];
        break;
    case DMUS_CURVES_LOG:
        panTable = &ganCT_Log[ 0 ];
        break;
    case DMUS_CURVES_SINE:
        panTable = &ganCT_Sine[ 0 ];
        break;
    }

    if( (pCurve->mtDuration == 0) || (mtCurrent >= pCurve->mtDuration ))
    {
        return pCurve->nEndValue;
    }
    else
    {
        // Calculate how far into the table we should be.
        long lIndex = (mtCurrent * (CT_MAX + 1)) / pCurve->mtDuration;

        // find an amount of time to add to the curve event such that there is at
        // least a change by CT_FACTOR. This will be used as the time stamp
        // for the next iteration of the curve.

        // clamp lIndex
        if( lIndex < 0 )
        {
            lIndex = 0;
        }
        if( lIndex >= CT_MAX )
        {
            lIndex = CT_MAX;
            nRet = pCurve->nEndValue;
        }
        else
        {
            // Okay, in the curve, so calculate the return value.
            nRet = ((panTable[lIndex] * (pCurve->nEndValue - pCurve->nStartValue)) / 
                CT_DIVFACTOR) + pCurve->nStartValue;
        }
    }
    return nRet;
}

void CPerformance::FlushEventQueue( DWORD dwId,
    CPMsgQueue *pQueue,                 // Queue to flush events from.
    REFERENCE_TIME rtFlush,             // Time that flush occurs. This may be resolved to a timing resolution.
    REFERENCE_TIME rtFlushUnresolved,   // Queue time at time flush was requested. This is not resolved to the timing resolution.
                                        // Instead, it is the actual time at which that the flush was requested. This is used only by curves.
    DWORD dwFlushFlags)                 // If notes or waves are currently on, do not cut short their durations.
{
    PRIV_PMSG* pEvent;
    PRIV_PMSG* pNext;
    REFERENCE_TIME rtTemp;
    GetQueueTime(&rtTemp);
    pNext = NULL;
    for(pEvent = pQueue->GetHead(); pEvent; pEvent = pNext )
    {
        pNext = pEvent->pNext;
        // Clear the remove bit. This will be set for each event that should be removed from the queue.
        pEvent->dwPrivFlags &= ~PRIV_FLAG_REMOVE;
        // Also clear the requeue bit, which will be set for each event that needs to be requeued.
        pEvent->dwPrivFlags &= ~PRIV_FLAG_REQUEUE;
        if( ( 0 == dwId ) || ( pEvent->dwVirtualTrackID == dwId ) )
        {
            // First, create the correct mtTime and rtTime for invalidation.
            REFERENCE_TIME rtTime = pEvent->rtTime;
            if( pEvent->dwType == DMUS_PMSGT_NOTE )
            {
                DMUS_NOTE_PMSG* pNote = (DMUS_NOTE_PMSG*)PRIV_TO_DMUS(pEvent);
                if( pNote->bFlags & DMUS_NOTEF_NOTEON )
                {
                    // If this is a note on, we want to take the offset into consideration for
                    // determining whether or not to invalidate. 
                    MUSIC_TIME mtNote = pNote->mtTime - pNote->nOffset; 
                    MusicToReferenceTime( mtNote, &rtTime );
                }
                // If note off and we want to leave notes playing, turn on the noinvalidate flag.
                else if (dwFlushFlags & FLUSH_LEAVE_ON)
                {
                    pNote->bFlags |= DMUS_NOTEF_NOINVALIDATE;
                }
            }
            else if( pEvent->dwType == DMUS_PMSGT_WAVE )
            {
                DMUS_WAVE_PMSG* pWave = (DMUS_WAVE_PMSG*)PRIV_TO_DMUS(pEvent);
                if ((pWave->bFlags & DMUS_WAVEF_IGNORELOOPS) && (dwFlushFlags & FLUSH_ON_REPEAT))
                {
                    // If this invalidation was caused by a loop track repeating and this
                    // is a wave that should continue playing on loop, let it do so.
                    continue;
                }
                if( !(pWave->bFlags & DMUS_WAVEF_OFF) )
                {
                    if (pWave->dwFlags & DMUS_PMSGF_LOCKTOREFTIME)
                    {
                        rtTime = pWave->rtTime;
                    }
                    else
                    {
                        MusicToReferenceTime(pWave->mtTime, &rtTime);
                    }
                }
                // If wave off and we want to leave waves playing, turn on the noinvalidate flag.
                else if (dwFlushFlags & FLUSH_LEAVE_ON)
                {
                    pWave->bFlags |= DMUS_WAVEF_NOINVALIDATE;
                }
            }
            else if( pEvent->dwType == DMUS_PMSGT_CURVE )
            {
                if (dwFlushFlags & FLUSH_LEAVE_ON)
                {
                    rtTime = 0;
                }
                else
                {
                    DMUS_CURVE_PMSG* pCurve = (DMUS_CURVE_PMSG*)PRIV_TO_DMUS(pEvent);
                    MUSIC_TIME mtCurve;
                    MUSIC_TIME mtStart;
                    mtStart = pCurve->mtOriginalStart ? pCurve->mtOriginalStart : pCurve->mtTime;
                
                    // if rtFlush is before the beginning of the curve minus the offset of 
                    // the curve, we want to prevent the curve from playing
                    mtCurve = mtStart - pCurve->nOffset; 
                    MusicToReferenceTime( mtCurve, &rtTime );
                    if( rtFlush > rtTime ) // if it isn't...
                    {
                        // if the curve has a reset value and has already begun,
                        // we may want to flush right away.
                        if( ( pCurve->bFlags & DMUS_CURVE_RESET) && 
                              pCurve->mtOriginalStart && 
                              rtFlush <= rtFlushUnresolved )
                        {
                            mtCurve = mtStart + pCurve->mtDuration;
                            MusicToReferenceTime( mtCurve, &rtTime );
                            if( rtTime >= rtFlush && !(pEvent->dwPrivFlags & PRIV_FLAG_FLUSH) )
                            {
                                MUSIC_TIME mt = 0;
                                ReferenceToMusicTime(rtFlush, &mt);
                                pCurve->mtDuration = (mt - mtStart) - 1;
                                pCurve->mtResetDuration = 1;
                            }
                            else 
                            {
                                mtCurve += pCurve->mtResetDuration;
                                MusicToReferenceTime( mtCurve, &rtTime );
                                if ( rtTime >= rtFlush && !(pEvent->dwPrivFlags & PRIV_FLAG_FLUSH) )
                                {
                                    MUSIC_TIME mt = 0;
                                    ReferenceToMusicTime(rtFlush, &mt);
                                    pCurve->mtResetDuration = mt - (mtStart + pCurve->mtDuration);
                                }
                            }
                        }
                        else 
                        {
                            // Otherwise, we may cut the curve short in the code below.
                            rtTime = 0;
                        }
                    }
                }
            }
            // now flush the event if needed
            if( rtTime >= rtFlush )
            {
                if (!(pEvent->dwPrivFlags & PRIV_FLAG_FLUSH))
                {
                    if( pEvent->pTool)
                    {
                        bool fFlush = false;
                        if (pEvent->dwType == DMUS_PMSGT_WAVE)
                        {
                            DMUS_WAVE_PMSG* pWave = (DMUS_WAVE_PMSG*)PRIV_TO_DMUS(pEvent);
                            if( !(pWave->bFlags & DMUS_WAVEF_OFF) )
                            {
                                // this wave on is due to start after the flush time.
                                // we never want to hear it.
                                fFlush = true;
                            }
                            else 
                            {
                                // cut the duration short, but don't actually flush here,
                                // since it's possible to invalidate the same wave more
                                // than once, and the second invalidation might have a
                                // time prior to the first one (e.g., first is from a loop,
                                // second is from a transition)
                                if (GetInvalidationStatus(PRIV_TO_DMUS(pEvent)) &&
                                    rtFlush < pWave->rtTime)
                                {
                                    pEvent->dwPrivFlags |= PRIV_FLAG_REQUEUE;
                                    MUSIC_TIME mtFlush = 0;
                                    ReferenceToMusicTime(rtFlush, &mtFlush);
                                    pWave->rtTime = rtFlush;
                                    pWave->mtTime = mtFlush;
                                }
                            }
                        }
                        if (fFlush || 
                            (pEvent->dwType != DMUS_PMSGT_WAVE &&
                             GetInvalidationStatus(PRIV_TO_DMUS(pEvent))) )
                        {
                            pEvent->dwPrivFlags |= PRIV_FLAG_REMOVE;
                            pEvent->dwFlags |= DMUS_PMSGF_TOOL_FLUSH;
                            if( rtFlush <= pEvent->rtLast )
                            {
                                pEvent->pTool->Flush( this, PRIV_TO_DMUS(pEvent), pEvent->rtLast + REF_PER_MIL );
                            }
                            else
                            {
                                pEvent->pTool->Flush( this, PRIV_TO_DMUS(pEvent), rtFlush );
                            }
                        }
                    }
                    else
                    {
                        pEvent->dwPrivFlags |= PRIV_FLAG_REMOVE;
                    }
                }
            }
            else // cut notes, waves, and curves short if needed
            {
                if( pEvent->dwType == DMUS_PMSGT_NOTE && !(dwFlushFlags & FLUSH_LEAVE_ON ))
                {
                    DMUS_NOTE_PMSG* pNote = (DMUS_NOTE_PMSG*)PRIV_TO_DMUS(pEvent);
                    if( pNote->bFlags & DMUS_NOTEF_NOTEON )
                    {
                        if (GetInvalidationStatus(PRIV_TO_DMUS(pEvent)))
                        {
                            // subtract 2 from the duration to guarantee the note cuts short
                            // 1 clock before the flush time.
                            MUSIC_TIME mtNoteOff = pNote->mtTime + pNote->mtDuration - 2;
                            REFERENCE_TIME rtNoteOff;
                            MusicToReferenceTime( mtNoteOff, &rtNoteOff );
                            if( rtNoteOff >= rtFlush )
                            {
                                ReferenceToMusicTime( rtFlush, &mtNoteOff );
                                mtNoteOff -= pNote->mtTime;
                                // Make any duration < 1 be 0; this will cause the note not to 
                                // sound.  Can happen if the note's logical time is well before
                                // its physical time.
                                if( mtNoteOff < 1 ) mtNoteOff = 0;
                                pNote->mtDuration = mtNoteOff;
                            }
                        }
                    }
                }
                else if( pEvent->dwType == DMUS_PMSGT_WAVE && !(dwFlushFlags & FLUSH_LEAVE_ON ))
                {
                    DMUS_WAVE_PMSG* pWave = (DMUS_WAVE_PMSG*)PRIV_TO_DMUS(pEvent);
                    if( !(pWave->bFlags & DMUS_WAVEF_OFF) &&
                        (GetInvalidationStatus(PRIV_TO_DMUS(pEvent))) )
                    {
                        if (pWave->dwFlags & DMUS_PMSGF_LOCKTOREFTIME)
                        {
                            // This is a clock time message. 
                            // subtract 2 from the duration to guarantee the wave cuts short
                            // 1 clock before the flush time.
                            if ((rtTime + pWave->rtDuration - 2) >= rtFlush)
                            {
                                pWave->rtDuration = rtFlush - rtTime;
                            }
            
                        }
                        else
                        {
                            MUSIC_TIME mtTime = 0;
                            MUSIC_TIME mtFlush = 0;
                            ReferenceToMusicTime(rtTime, &mtTime);
                            ReferenceToMusicTime(rtFlush, &mtFlush);
                            // subtract 2 from the duration to guarantee the wave cuts short
                            // 1 clock before the flush time.
                            if ((mtTime + (MUSIC_TIME)pWave->rtDuration - 2) >= mtFlush)
                            {
                                pWave->rtDuration = mtFlush - mtTime;
                            }
                        }
                        if (pWave->rtDuration < 1) // disallow durations less than 1. This should never happen anyway.
                        {
                            pWave->rtDuration = 1;
                        }
                    }
                }
                else if( pEvent->dwType == DMUS_PMSGT_CURVE && !(dwFlushFlags & FLUSH_LEAVE_ON ))
                {
                    DMUS_CURVE_PMSG* pCurve = (DMUS_CURVE_PMSG*)PRIV_TO_DMUS(pEvent);
                    MUSIC_TIME mtEnd;
                    MUSIC_TIME mtStart = pCurve->mtOriginalStart ? pCurve->mtOriginalStart : pCurve->mtTime;

                    if( pCurve->bFlags & DMUS_CURVE_RESET )
                    {
                        mtEnd = mtStart + pCurve->mtResetDuration + pCurve->mtDuration;
                    }
                    else
                    {
                        mtEnd = mtStart + pCurve->mtDuration;
                    }
                    REFERENCE_TIME rtEnd;
                    MusicToReferenceTime( mtEnd, &rtEnd );
                    // Note: as a result of fixing 33987, the curve is no longer given
                    // a negative reset duration.  Now, the curve's duration is recomputed
                    // and its time slice is recalculated.
                    if( rtEnd >= rtFlush )
                    {
                        // reset the curve's duration
                        MUSIC_TIME mtFlush;
                        ReferenceToMusicTime( rtFlush, &mtFlush );
                        mtEnd = mtFlush - mtStart;
                        // get the curve value at the flush time, and make that the end value
                        pCurve->nEndValue = (short) RecomputeCurveEnd(pCurve, mtEnd);
                        // subtract 2 from the duration to guarantee the curve cuts short
                        // 1 clock before the flush time.
                        mtEnd -= 2;
                        if ( mtEnd < 1)
                        {
                            mtEnd = 1;
                        }
                        else if (pCurve->bFlags & DMUS_CURVE_RESET) 
                        {
                            if (mtEnd > pCurve->mtDuration)
                            {
                                // curve ends in the reset duration; keep regular duration the
                                // same as it was and adjust reset duration
                                pEvent->dwPrivFlags |= PRIV_FLAG_FLUSH;
                                pCurve->mtResetDuration = mtFlush - (mtStart + pCurve->mtDuration);
                                mtEnd = pCurve->mtDuration;
/* NOTE: I've commented out a bunch of code because it really seems to be redundant.
   And, it was exhibiting the problem of not always reseting before the invalidation.
   By forcing the time stamp to be just before the invalidation for all cases, it seems
   to clear up behavior. But, I'm leaving the old code in comments in case something
   breaks and we have that, "ah, that's what that was doing!" realization.
*/
//                                if (pCurve->mtTime > mtEnd + pCurve->mtResetDuration + mtStart)
//                                {
//                                    pCurve->mtTime = mtEnd + pCurve->mtResetDuration + mtStart;
                                    // Need to requeue since the time stamp has changed.
//                                    pEvent->dwPrivFlags |= PRIV_FLAG_REQUEUE;
//                            MusicToReferenceTime(pCurve->mtTime, &pCurve->rtTime);
//                                }
                            }
                            else 
                            {
                                // curve ends in the regular duration; reduce it by 1 and
                                // give the reset duration a value of 1
                                mtEnd--;
                                pCurve->mtResetDuration = 1;
                                if (mtEnd < 1)
                                {
                                    // this is unlikely, but the curve really should have
                                    // a duration...
                                    mtEnd = 1;
                                }
//                                pEvent->dwPrivFlags |= PRIV_FLAG_FLUSH;
                            }
                            // If this is an instant curve that's already started, we
                            // don't want it to play again, so reset its start time
/*                            if ( pCurve->bCurveShape == DMUS_CURVES_INSTANT && 
                                 pCurve->mtOriginalStart )
                            {
                                pCurve->mtTime = pCurve->mtResetDuration + pCurve->mtOriginalStart + mtEnd;
                                pEvent->dwPrivFlags |= PRIV_FLAG_REQUEUE;
                                MusicToReferenceTime(pCurve->mtTime, &pCurve->rtTime);
                            }*/
                            // Ensure that the end of the curve will play prior to the invalidation.
                            pCurve->rtTime = rtFlush - 10000; // Drop this back 1 ms to ensure rounding errors don't push it up.
                            pCurve->mtTime = mtFlush - 2;
                            pEvent->dwPrivFlags |= PRIV_FLAG_REQUEUE;
                            pCurve->mtDuration = mtEnd;
                        }
                        else
                        {
                            // If this does not have a reset, simply lose it.
                            pEvent->dwPrivFlags |= PRIV_FLAG_REMOVE;
                        }
                    }
                }
            }
        }
    }
    // remove (and unmark) all marked PMsgs from the current queue
    for(pEvent = pQueue->GetHead(); pEvent; pEvent = pNext )
    {
        pNext = pEvent->pNext;
        if (pEvent->dwPrivFlags & (PRIV_FLAG_REMOVE | PRIV_FLAG_REQUEUE))
        {
            pEvent->dwPrivFlags &= ~PRIV_FLAG_REMOVE;
            if (pQueue->Dequeue(pEvent))
            {
                if (pEvent->dwPrivFlags & PRIV_FLAG_REQUEUE)
                {
                    pEvent->dwPrivFlags &= ~PRIV_FLAG_REQUEUE;
                    pQueue->Enqueue(pEvent);
                }
                else
                {
                    FreePMsg(pEvent);
                }
            }
            else
            {
                TraceI(0,"Error dequeing event for flushing\n");
            }
        }
    }
    SendBuffers();
}

/*

  Flushes all events in all queues from time <p mtFlush> on.

  comm Only call this from withing a PipelineCrSec critical section!

*/
void CPerformance::FlushMainEventQueues( 
    DWORD dwId,                      // Virtual Track ID to flush, or zero for all.
    MUSIC_TIME mtFlush,              // Time to flush (resolved to timing resolution).
    MUSIC_TIME mtFlushUnresolved,    // Time to flush (unresolved).
    DWORD dwFlushFlags)              // If true, notes currently on are left to play through their duration.
{
    REFERENCE_TIME rt;
    if( mtFlush )
    {
        MusicToReferenceTime( mtFlush, &rt );
    }
    else
    {
        rt = 0;
    }
    REFERENCE_TIME rtUnresolved;
    if( mtFlushUnresolved && mtFlushUnresolved != mtFlush)
    {
        MusicToReferenceTime( mtFlushUnresolved, &rtUnresolved );
    }
    else
    {
        rtUnresolved = rt;
    }
    FlushEventQueue( dwId, &m_OnTimeQueue, rt, rtUnresolved, dwFlushFlags );
    FlushEventQueue( dwId, &m_NearTimeQueue, rt, rtUnresolved, dwFlushFlags );
    FlushEventQueue( dwId, &m_EarlyQueue, rt, rtUnresolved, dwFlushFlags );
    if (dwId == 0)
    {
        MUSIC_TIME mtTime;
        ReferenceToMusicTime(rt,&mtTime);
        FlushEventQueue( dwId, &m_TempoMap, rt, rtUnresolved, dwFlushFlags );
        RecalcTempoMap(NULL, mtTime );
    }
}

// the only kinds of events we care about are note events.
void CPerformance::OnChordUpdateEventQueue( DMUS_NOTIFICATION_PMSG* pNotify, CPMsgQueue *pQueue, REFERENCE_TIME rtFlush )
{
    PRIV_PMSG* pEvent;
    PRIV_PMSG* pNext;
    HRESULT hr = S_OK;
    DWORD dwId = pNotify->dwVirtualTrackID;
    DWORD dwTrackGroup = pNotify->dwGroupID;
    CPMsgQueue UpdateQueue;        // List of PMsgs to be inserted into a queue during update.

    REFERENCE_TIME rtTemp;
    GetQueueTime(&rtTemp);
    pNext = NULL;
    for(pEvent = pQueue->GetHead(); pEvent; pEvent = pNext )
    {
        pNext = pEvent->pNext;
        pEvent->dwPrivFlags &= ~PRIV_FLAG_REMOVE;
        DMUS_PMSG* pNew = NULL;
        if( ( 0 == dwId || pEvent->dwVirtualTrackID == dwId ) && 
            (pEvent->dwType == DMUS_PMSGT_NOTE) )
        {
            REFERENCE_TIME rtTime = pEvent->rtTime;
            DMUS_NOTE_PMSG* pNote = (DMUS_NOTE_PMSG*)PRIV_TO_DMUS(pEvent);
            if( pNote->bFlags & DMUS_NOTEF_NOTEON )
            {
                MUSIC_TIME mtNote = pNote->mtTime - pNote->nOffset; 
                MusicToReferenceTime( mtNote, &rtTime );
            }
            // now flush the event if needed
            if( rtTime >= rtFlush )
            {
                REFERENCE_TIME rtFlushTime = (rtFlush <= pEvent->rtLast) ? pEvent->rtLast + REF_PER_MIL : rtFlush;
                if( pEvent->pTool && 
                    !(pNote->bFlags & DMUS_NOTEF_NOTEON) &&
                    S_OK == (hr = GetChordNotificationStatus(pNote, dwTrackGroup, rtFlushTime, &pNew)))
                {
                    pEvent->dwPrivFlags |= PRIV_FLAG_REMOVE;
                    pEvent->dwFlags |= DMUS_PMSGF_TOOL_FLUSH;
                    pEvent->pTool->Flush( this, PRIV_TO_DMUS(pEvent), rtFlushTime );
                }
                if (SUCCEEDED(hr) && pNew) // add to temp queue for later insertion into regular queue
                {
                    UpdateQueue.Enqueue( DMUS_TO_PRIV(pNew) );
                }
            } 
            else // cut notes short if needed
            {
                if( pNote->bFlags & DMUS_NOTEF_NOTEON )
                {
                    if (S_OK == (hr = GetChordNotificationStatus(pNote, dwTrackGroup, rtFlush, &pNew)))
                    {
                        // subtract 2 from the duration to guarantee the note cuts short
                        // 1 clock before the flush time.
                        MUSIC_TIME mtNoteOff = pNote->mtTime + pNote->mtDuration - 2;
                        REFERENCE_TIME rtNoteOff;
                        MusicToReferenceTime( mtNoteOff, &rtNoteOff );
                        if( rtNoteOff >= rtFlush )
                        {
                            ReferenceToMusicTime( rtFlush, &mtNoteOff );
                            mtNoteOff -= pNote->mtTime;
                            if( mtNoteOff < 1 ) mtNoteOff = 1; // disallow durations less than 1. This should never happen anyway.
                            pNote->mtDuration = mtNoteOff;
                        }
                    }
                    if (SUCCEEDED(hr) && pNew) // add to temp queue for later insertion into regular queue
                    {
                        UpdateQueue.Enqueue( DMUS_TO_PRIV(pNew) );
                    }
                }
            }
        }
    }
    // remove (and unmark) all marked PMsgs from the current queue
    for(pEvent = pQueue->GetHead(); pEvent; pEvent = pNext )
    {
        pNext = pEvent->pNext;
        if (pEvent->dwPrivFlags & PRIV_FLAG_REMOVE)
        {
            pEvent->dwPrivFlags &= ~PRIV_FLAG_REMOVE;
            if (pQueue->Dequeue(pEvent))
            {
                FreePMsg(pEvent);
            }
            else
            {
                TraceI(0,"Error dequeing event for flushing\n");
            }
        }
    }
    // empty the Update queue into the current queue
    while( pEvent = UpdateQueue.Dequeue() )
    {
        pQueue->Enqueue(pEvent);
    }
    SendBuffers();
}

/*

  Only call this from withing a PipelineCrSec critical section!

*/
void CPerformance::OnChordUpdateEventQueues( 
    DMUS_NOTIFICATION_PMSG* pNotify)    // notification PMsg that caused this to be called
{
    IDirectMusicSegmentState* pSegState = NULL;
    if (!pNotify || !pNotify->punkUser) return;
    REFERENCE_TIME rt = 0;
    if( pNotify->mtTime )
    {
        MusicToReferenceTime( pNotify->mtTime, &rt );
    }
    OnChordUpdateEventQueue( pNotify, &m_OnTimeQueue, rt );
    OnChordUpdateEventQueue( pNotify, &m_NearTimeQueue, rt );
    OnChordUpdateEventQueue( pNotify, &m_EarlyQueue, rt );
}

/////////////////////////////////////////////////////////////////////////////
// IDirectMusicPerformance

HRESULT CPerformance::CreateThreads()

{
#ifdef DXAPI
    // initialize the realtime thread
    m_hRealtimeThread = CreateThread(NULL, 1024, _Realtime, this, 0, &m_dwRealtimeThreadID);
    if( m_hRealtimeThread )
    {
        m_hRealtime = CreateEvent(NULL,FALSE,FALSE,NULL);
        SetThreadPriority( m_hRealtimeThread, THREAD_PRIORITY_HIGHEST );
    }
    else
    {
        TraceI(0, "Major error! Realtime thread not created.\n");
        return E_OUTOFMEMORY;
    }
    // initialize the transport thread
    m_hTransportThread = CreateThread(NULL, 1024, _Transport, this, 0, &m_dwTransportThreadID);
    if( m_hTransportThread )
    {
        m_hTransport = CreateEvent(NULL, FALSE, FALSE, NULL);
        SetThreadPriority( m_hTransportThread, THREAD_PRIORITY_ABOVE_NORMAL );
    }
    else
    {
        TraceI(0, "Major error! Transport thread not created.\n");
        m_fKillRealtimeThread = TRUE;
        if( m_hRealtime ) SetEvent( m_hRealtime );
        return E_OUTOFMEMORY;
    }
    m_pDirectMusic->GetMasterClock( NULL, &m_pClock );
#else
    m_pSynth->GetMasterClock(&m_pClock );
    g_BossMan.SetMasterClock(m_pClock);
    m_pTransportWorker = g_BossMan.InstallWorker(_Transport,this,10,"DM Worker: Track Playback (MilsPerSecond) ");
    m_pRealtimeWorker = g_BossMan.InstallWorker(_Realtime,this,20,"DM Worker: MIDI Process (MilsPerSecond)");
#endif
    m_rtStart = GetTime();
    m_rtQueuePosition = m_rtStart;
    return S_OK;
}

void SetDoWorkThreadMode(DWORD dwFlags);

STDMETHODIMP CPerformance::InitAudioX(DWORD dwDefaultPathType,
                           DWORD dwPChannelCount,
                           DWORD dwVoiceCount,
                           DWORD dwFlags)

{
	DMUS_AUDIOPARAMS Params;
    Params.dwSampleRate = SAMPLERATE;
    Params.dwSize = sizeof (Params);
    Params.dwValidData = DMUS_AUDIOPARAMS_VOICES; // DMUS_AUDIOPARAMS_FEATURES | DMUS_AUDIOPARAMS_VOICES | DMUS_AUDIOPARAMS_SAMPLERATE | DMUS_AUDIOPARAMS_DEFAULTSYNTH;
    Params.fInitNow = TRUE;
    Params.clsidDefaultSynth = CLSID_DirectMusicSynth;
    Params.dwVoices = dwVoiceCount;
    SetDoWorkThreadMode(dwFlags & DMUS_INITAUDIO_NOTHREADS);
    ENTER_API_CRITICAL_SECTION;
	HRESULT hr = InitAudio(NULL,NULL,NULL,dwDefaultPathType,dwPChannelCount,0,&Params);
    LEAVE_API_CRITICAL_SECTION;
    return hr;
}


STDMETHODIMP CPerformance::InitAudio(IDirectMusic** ppDirectMusic,
                           IDirectSound** ppDirectSound,
                           HWND hWnd,
                           DWORD dwDefaultPathType,
                           DWORD dwPChannelCount,
                           DWORD dwFlags,                          
                           DMUS_AUDIOPARAMS *pParams)
 
{
    V_INAME(IDirectMusicPerformance::InitAudio);
    V_PTRPTR_WRITE_OPT(ppDirectMusic);
    V_PTRPTR_WRITE_OPT(ppDirectSound);
#ifndef XBOX
    V_HWND_OPT(hWnd);
#endif
    HRESULT hr = S_OK;
#ifndef XBOX
    // Further validate, checking for a pointer to a bad interface pointer...
    if (ppDirectMusic)
    {
        V_INTERFACE_OPT(*ppDirectMusic);
    }
    if (ppDirectSound)
    {
        V_INTERFACE_OPT(*ppDirectSound);
    }
#endif
    if( m_dwAudioPathMode )
    {
        Trace(0,"Error: InitAudio called on an already initialized Performance.\n");
        return DMUS_E_ALREADY_INITED;
    }
    if (dwFlags == 0)
    {
        dwFlags = DMUS_AUDIOF_ALL;
    }
    Init();
    m_AudioParams.dwFeatures = dwFlags;
    m_AudioParams.dwSampleRate = SAMPLERATE;
    m_AudioParams.dwSize = sizeof (m_AudioParams);
    m_AudioParams.dwValidData = DMUS_AUDIOPARAMS_FEATURES | DMUS_AUDIOPARAMS_VOICES | DMUS_AUDIOPARAMS_SAMPLERATE | DMUS_AUDIOPARAMS_DEFAULTSYNTH;
    m_AudioParams.dwVoices = 64;
    m_AudioParams.fInitNow = TRUE;
    m_AudioParams.clsidDefaultSynth = CLSID_DirectMusicSynth;
    if (pParams)
    {
        if (pParams->dwValidData & DMUS_AUDIOPARAMS_FEATURES)
        {
            m_AudioParams.dwFeatures = pParams->dwFeatures;
        }
        if (pParams->dwValidData & DMUS_AUDIOPARAMS_VOICES)
        {
            m_AudioParams.dwVoices = pParams->dwVoices;
        }
        if (pParams->dwValidData & DMUS_AUDIOPARAMS_DEFAULTSYNTH)
        {
            // If they requested the DX7 default synth and yet also asked for audiopath
            // features, force to DX8 default synth.
            if ((pParams->clsidDefaultSynth != GUID_NULL) || 
                !((m_AudioParams.dwValidData & DMUS_AUDIOPARAMS_FEATURES) &&
                (m_AudioParams.dwFeatures & DMUS_AUDIOF_ALL)))
            {
                m_AudioParams.clsidDefaultSynth = pParams->clsidDefaultSynth;
            }
        }
        if (pParams->dwValidData & DMUS_AUDIOPARAMS_SAMPLERATE)
        {
            if (pParams->dwSampleRate > 96000)
            {
                m_AudioParams.dwSampleRate = 96000;
            }
            else if (pParams->dwSampleRate < 11025)
            {
                m_AudioParams.dwSampleRate = 11025;
            }
            else
            {
                m_AudioParams.dwSampleRate = pParams->dwSampleRate;
            }
        }
    }
    m_dwAudioPathMode = 2;
    ENTER_CRITICAL_SECTION(&m_MainCrSec);
#ifndef XBOX
    if (ppDirectMusic && *ppDirectMusic)
    {
        hr = (*ppDirectMusic)->QueryInterface(IID_IDirectMusic8,(void **) &m_pDirectMusic);
    }
#endif
    if (SUCCEEDED(hr))
    {
#ifndef XBOX
        if (ppDirectSound && *ppDirectSound)
        {
            hr = (*ppDirectSound)->QueryInterface(IID_IDirectSound8,(void **) &m_pDirectSound);
        }
#endif // XBOX
        if (SUCCEEDED(hr))
        {
#ifdef DXAPI
            if (!m_pDirectSound)
            {
                hr = DirectSoundCreate8(NULL,&m_pDirectSound,NULL);
                if (SUCCEEDED(hr))
                {
                    if (!hWnd)
                    {
                        hWnd = GetForegroundWindow();
                        if (!hWnd)
                        {
                            hWnd = GetDesktopWindow();
                        }
                    }
                    m_pDirectSound->SetCooperativeLevel(hWnd, DSSCL_PRIORITY);
                }
            }
#endif // ! XBOX
            
            if (SUCCEEDED(hr))
            {
#ifdef DXAPI
                if (!m_pDirectMusic)
                {
                    hr = DirectMusicCreateInstance(CLSID_DirectMusic,
                                          NULL,
                                          IID_IDirectMusic8, 
                                          (LPVOID*)&m_pDirectMusic);
                    if (SUCCEEDED(hr))
                    {
                        hr = m_pDirectMusic->SetDirectSound(m_pDirectSound,hWnd);
                    }
                }
#else
                DirectSoundCreate(NULL, &m_pDirectSound, 0);
                hr = DirectMusicCreateInstance(CLSID_DirectMusicSynth,
                                      NULL,
                                      IID_IDirectMusicSynthX, 
                                      (LPVOID*)&m_pSynth);
                if (m_pSynth)
                {
                    m_pSynth->Init(m_AudioParams.dwVoices);
                }
#endif
            }
        }
    }
    if (SUCCEEDED(hr))
    {
        hr = m_BufferManager.Init(this,&m_AudioParams);
        if (SUCCEEDED(hr))
        {
#ifdef DXAPI
            // If we are going to be connecting the synth to Buffers, 
            // force the use of the dsound clock.
            // This is automatically handed in BufferManager.Init() for non-DX versions.
            if (m_AudioParams.dwFeatures & DMUS_AUDIOF_BUFFERS)
            {
                DMUS_CLOCKINFO ClockInfo;
                ClockInfo.dwSize = sizeof(ClockInfo);
                DWORD dwIndex;
                GUID guidMasterClock = GUID_NULL;
                for (dwIndex = 0; ;dwIndex++)
                {
                    if (S_OK == m_pDirectMusic->EnumMasterClock(dwIndex, &ClockInfo))
                    {
                        if (!wcscmp(ClockInfo.wszDescription, L"DirectSound Clock"))
                        {
                            guidMasterClock = ClockInfo.guidClock;
                            break;
                        }
                    }
                    else
                    {
                        break;
                    }
                }
                m_pDirectMusic->SetMasterClock(guidMasterClock);
            }
#endif
            hr = CreateThreads();
            if (SUCCEEDED(hr))
            {
                if (dwDefaultPathType)
                {
                    IDirectMusicAudioPath *pPath;
                    hr = CreateStandardAudioPath(dwDefaultPathType,dwPChannelCount,m_AudioParams.fInitNow,&pPath);
                    if (SUCCEEDED(hr))
                    {
                        hr = SetDefaultAudioPath(pPath);
                        pPath->Release();
                    }
                }
                // Hack to make timing work for now...
//                CreateStandardAudioPath(DMUS_APATH_DYNAMIC_MONO,1,TRUE,&m_pDummy);
            }
        }
    }
    if (SUCCEEDED(hr))
    {
#ifndef XBOX
        if (m_pDirectMusic && ppDirectMusic && !*ppDirectMusic)
        {
            *ppDirectMusic = m_pDirectMusic;
            m_pDirectMusic->AddRef();
        }
        if (m_pDirectSound && ppDirectSound && !*ppDirectSound)
        {
            *ppDirectSound = m_pDirectSound;
            m_pDirectSound->AddRef();
        }
#endif !XBOX
        if (pParams && pParams->fInitNow)
        {
            if (pParams->clsidDefaultSynth != m_AudioParams.clsidDefaultSynth)
            {
                pParams->clsidDefaultSynth = m_AudioParams.clsidDefaultSynth;
                if (pParams->dwValidData & DMUS_AUDIOPARAMS_DEFAULTSYNTH) 
                {
                    Trace(2,"Warning: Default synth choice has been changed.\n");
                    hr = S_FALSE;
                }
            }
            if (pParams->dwFeatures != m_AudioParams.dwFeatures)
            {
                pParams->dwFeatures = m_AudioParams.dwFeatures;
                if (pParams->dwValidData & DMUS_AUDIOPARAMS_FEATURES) 
                {
                    Trace(2,"Warning: Features flags has been changed to %lx.\n",pParams->dwFeatures);
                    hr = S_FALSE;
                }
            }
            if (pParams->dwSampleRate != m_AudioParams.dwSampleRate)
            {
                pParams->dwSampleRate = m_AudioParams.dwSampleRate;
                if (pParams->dwValidData & DMUS_AUDIOPARAMS_SAMPLERATE) 
                {
                    Trace(2,"Warning: Sample rate has been changed to %ld.\n",pParams->dwSampleRate);
                    hr = S_FALSE;
                }
            }
            if (pParams->dwVoices != m_AudioParams.dwVoices)
            {
                pParams->dwVoices = m_AudioParams.dwVoices;
                if (pParams->dwValidData & DMUS_AUDIOPARAMS_VOICES) 
                {
                    Trace(2,"Warning: Number of requested voices has been changed to %ld.\n",pParams->dwVoices);
                    hr = S_FALSE;
                }
            }
            pParams->dwValidData = m_AudioParams.dwValidData;
        }
        LEAVE_CRITICAL_SECTION(&m_MainCrSec);
    }
    else
    {
        LEAVE_CRITICAL_SECTION(&m_MainCrSec);
        CloseDown();
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE CPerformance::Init( 
    IDirectMusic** ppDirectMusic,   LPDIRECTSOUND pDirectSound,HWND hWnd)
{
#ifndef DXAPI
    return E_FAIL; // THis is not supported on XBox.
#else
    V_INAME(IDirectMusicPerformance::Init);
    V_PTRPTR_WRITE_OPT(ppDirectMusic);
    V_INTERFACE_OPT(pDirectSound);
    V_HWND_OPT(hWnd);
    HRESULT hr = S_OK;

    // Further validate, checking for a pointer to a bad interface pointer...
    if (ppDirectMusic)
    {
        V_INTERFACE_OPT(*ppDirectMusic);
    }
    if( m_dwAudioPathMode )
    {
        Trace(0,"Error: Init called on an already initialized Performance.\n");
        return DMUS_E_ALREADY_INITED;
    }
    Init();
    m_dwAudioPathMode = 1;
    ENTER_CRITICAL_SECTION(&m_MainCrSec);

    if(( NULL == ppDirectMusic ) || ( NULL == *ppDirectMusic ))
    {
        // intialize DirectMusic. 

        if( FAILED( DirectMusicCreateInstance(CLSID_DirectMusic,
                              NULL,
                              IID_IDirectMusic,
                              (LPVOID*)&m_pDirectMusic)))
        {
            m_pDirectMusic = NULL;
            LEAVE_CRITICAL_SECTION(&m_MainCrSec);
            return E_OUTOFMEMORY;
        }

        // If version2 was requested by the app (in the process of requesting the
        // IDirectMusicPerformance2 interface), do the same for IDirectMusic.
        if (m_dwVersion > 6)
        {
            IDirectMusic *pTemp = NULL;
            if (SUCCEEDED(m_pDirectMusic->QueryInterface(
                IID_IDirectMusic2,
                (LPVOID*)&pTemp)))
            {
                // Succeeded in requesting DX7 and up behavior...
                pTemp->Release();
            }
        }

        hr = m_pDirectMusic->SetDirectSound(pDirectSound, hWnd);
        if( FAILED( hr ) )
        {
            m_pDirectMusic->Release();
            m_pDirectMusic = NULL;
            LEAVE_CRITICAL_SECTION(&m_MainCrSec);
            return hr;
        }
                    
        if( ppDirectMusic )
        {
            *ppDirectMusic = m_pDirectMusic;
            m_pDirectMusic->AddRef();
        }
    }
    else
    {
        m_pDirectMusic = (IDirectMusic8 *) *ppDirectMusic;
        m_pDirectMusic->AddRef();
    }
    if (FAILED(hr = CreateThreads()))
    {
        if( m_pDirectMusic )
        {
            m_pDirectMusic->Release();
            m_pDirectMusic = NULL;
        }
    }
    LEAVE_CRITICAL_SECTION(&m_MainCrSec);
    return hr;
#endif
}

CSegState *CPerformance::GetSegmentForTransition(DWORD dwFlags,MUSIC_TIME mtTime, IUnknown *pFrom)

{
    CSegState *pSegState = NULL;

    // If the source segment was provided, use it. 
    if (pFrom)
    {
        if (SUCCEEDED(pFrom->QueryInterface(IID_CSegState,(void **) &pSegState)))
        {
            pSegState->Release();
        }
    }
    // Else, if this is a primary segment, get the current primary segment.
    if (!pSegState && !(dwFlags & DMUS_SEGF_SECONDARY))
    {
        pSegState = GetPrimarySegmentAtTime(mtTime);
    }
    return pSegState;
}

void CPerformance::ClearMusicStoppedNotification()

{
    ENTER_CRITICAL_SECTION(&m_PipelineCrSec);
    PRIV_PMSG* pPMsg;
    PRIV_PMSG* pNext;
    DMUS_NOTIFICATION_PMSG* pNotification;

    pPMsg = m_OnTimeQueue.GetHead(); // where notifications live normally
    for (; pPMsg ; pPMsg = pNext)
    {
        pNext = pPMsg->pNext;
        pNotification = (DMUS_NOTIFICATION_PMSG*)PRIV_TO_DMUS(pPMsg);
        if( ( pPMsg->dwType == DMUS_PMSGT_NOTIFICATION ) &&
            ( pNotification->guidNotificationType == GUID_NOTIFICATION_PERFORMANCE ) && 
            ( pNotification->dwNotificationOption == DMUS_NOTIFICATION_MUSICSTOPPED ) )
        {
            pPMsg = m_OnTimeQueue.Dequeue(pPMsg);
            if( pPMsg ) // Should always succeeed
            {
                FreePMsg(pPMsg);
            }
            m_fMusicStopped = FALSE;
        }
    }
    LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);
}

HRESULT CPerformance::PlayOneSegment(
    CSegment* pSegment, 
    DWORD dwFlags, 
    __int64 i64StartTime, 
    CSegState **ppSegState,
    CAudioPath *pAudioPath)
{
    HRESULT hr;
#ifdef DBG_PROFILE
    DWORD dwDebugTime;
    dwDebugTime = timeGetTime();
#endif

//    TraceI(0,"Play Segment %lx (%ls) at time %ld with flags %lx\n",pSegment,pSegment->m_wszName,(long)i64StartTime,dwFlags);
    if( dwFlags & DMUS_SEGF_CONTROL )
    {
        dwFlags |= DMUS_SEGF_SECONDARY;
    }
    if( i64StartTime )
    {
        if (!(dwFlags & DMUS_SEGF_ALIGN))
        {
            if(dwFlags & DMUS_SEGF_REFTIME)
            {
                // Give a grace period of 100ms.
                if( i64StartTime < (GetLatency() - (100 * REF_PER_MIL)))
                {
                    Trace(1,"Error: Unable to play segment, requested clock time %I64d is past current time %I64d\n",
                        i64StartTime,GetLatency() - (100 * REF_PER_MIL));
                    return DMUS_E_TIME_PAST;
                }
            }
            else
            {
                MUSIC_TIME mtPrePlay;
                // Give a grace period of 100ms.
                ReferenceToMusicTime( (GetLatency() - (100 * REF_PER_MIL)), &mtPrePlay );
                if( (MUSIC_TIME)i64StartTime < mtPrePlay )
                {
                    Trace(1,"Error: Unable to play segment, requested music time %I64d is past current time %ld\n",
                        i64StartTime,(long)mtPrePlay);
                    return DMUS_E_TIME_PAST;
                }
            }
        }
    }

    CSegState *pSegState = NULL;
    hr = pSegment->CreateSegmentState( &pSegState, this, pAudioPath, dwFlags);
    *ppSegState = pSegState;
    if (FAILED(hr))
    {
        Trace(1,"Error: Unable to play segment because of failure creating segment state.\n");
        return DMUS_E_SEGMENT_INIT_FAILED;
    }
    pSegState->m_rtGivenStart = i64StartTime;

    pSegState->m_dwPlaySegFlags = dwFlags;

    // add the pSegState to the appropriate queue
    ENTER_CRITICAL_SECTION(&m_SegmentCrSec);
    m_fPlaying = 1; // turn on the transport
    // add all notifications to the segment. First, clear it, in case old notifications
    // are in effect.
    pSegment->RemoveNotificationType(GUID_NULL,TRUE);
    CNotificationItem* pItem;
    pItem = m_NotificationList.GetHead();
    while( pItem )
    {
        pSegment->AddNotificationType( pItem->guidNotificationType, TRUE );
        pItem = pItem->GetNext();
    }

    if( pSegState->m_dwPlaySegFlags & DMUS_SEGF_AFTERPREPARETIME )
    {
        // we want to queue this at the last transported time,
        // so we don't need to do an invalidate
        if( pSegState->m_dwPlaySegFlags & DMUS_SEGF_REFTIME )
        {
            REFERENCE_TIME rtTrans;
            MusicToReferenceTime( m_mtTransported, &rtTrans );
            if( pSegState->m_rtGivenStart < rtTrans )
            {
                pSegState->m_dwPlaySegFlags &= ~DMUS_SEGF_REFTIME;
                pSegState->m_rtGivenStart = m_mtTransported;
            }
        }
        else
        {
            if( pSegState->m_rtGivenStart < m_mtTransported )
            {
                pSegState->m_rtGivenStart = m_mtTransported;
            }
        }
    }
    else if( pSegState->m_dwPlaySegFlags & DMUS_SEGF_AFTERQUEUETIME )
    {
        // we want to queue this at the queue time, as opposed to latency time,
        // which is an option for secondary segments.
        REFERENCE_TIME rtStart;
        GetQueueTime( &rtStart ); // need queue time because control segments cause invalidations
        if( pSegState->m_dwPlaySegFlags & DMUS_SEGF_REFTIME )
        {
            if( pSegState->m_rtGivenStart < rtStart )
            {
                pSegState->m_rtGivenStart = rtStart;
            }
        }
        else
        {
            MUSIC_TIME mtStart;
            ReferenceToMusicTime( rtStart, &mtStart );
            if( pSegState->m_rtGivenStart < mtStart )
            {
                pSegState->m_rtGivenStart = mtStart;
            }
        }
    }
    // need to get rid of any pending musicstopped notifications
    ClearMusicStoppedNotification();

    pSegState->AddRef(); 

    if( dwFlags & DMUS_SEGF_SECONDARY ) // queue a secondary segment
    {
        QueueSecondarySegment( pSegState );
    }
    else // queue a primary segment
    {
        QueuePrimarySegment( pSegState );
    }

    LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);
    
#ifdef DBG_PROFILE
    dwDebugTime = timeGetTime() - dwDebugTime;
    TraceI(5, "perf, debugtime PlaySegment %u\n", dwDebugTime);
#endif

#ifdef DXAPI
    // signal the transport thread so we don't have to wait for it to wake up on its own
    if( m_hTransport ) SetEvent( m_hTransport );
#else
    g_BossMan.WakeUp(m_pRealtimeWorker);

//    m_pTransportWorker->WakeUp();
#endif
    return S_OK;
}


HRESULT CPerformance::PlaySegmentInternal( 
    CSegment* pSegment, 
    CSong * pSong,
    WCHAR *pwzSegmentName,
    CSegment* pTransition,
    DWORD dwFlags, 
    __int64 i64StartTime, 
    IDirectMusicSegmentState** ppSegmentState,
    IUnknown *pFrom,
    CAudioPath *pAudioPath)
{
    HRESULT hr;
    CAudioPath *pInternalPath = NULL;
    if( m_pClock == NULL )
    {
        Trace(0,"Error: Can not play segment because master clock has not been initialized.\n");
        return DMUS_E_NO_MASTER_CLOCK;
    }
    if (pAudioPath && (pAudioPath->NoPorts()))
    {
        // This audiopath can't be used for playback since it doesn't have any ports.
        Trace(0,"Error: Audiopath can't be used for playback because it doesn't have any ports.\n");
        return DMUS_E_AUDIOPATH_NOPORT;
    }

    // Pointer to segment or song provided audio path config.
    IUnknown *pConfig = NULL;

    /*  If this is a song, use the segment name to get the segment.
        Then, it looks like a normal segment except the 
        existence of the pSong will let the segstate know
        that it is a member of a song, so it should chain segments.
    */
    if (pSong)
    {
        IDirectMusicSegment *pISegment = NULL;
        hr = pSong->GetSegment(pwzSegmentName,&pISegment);
        if (hr != S_OK)
        {
            return DMUS_E_NOT_FOUND;
        }
        pSegment = (CSegment *) pISegment;
        // If the app wants an audiopath created dynamically from the song, find it and use it.
        if (dwFlags & DMUS_SEGF_USE_AUDIOPATH)
        {
            pSong->GetAudioPathConfig(&pConfig);
        }
    }
    else if (pSegment)
    {
        // Addref so we can release later.
        pSegment->AddRef();
    }
    else
    {
        // No Segment!
        Trace(0,"Error: No segment - nothing to play!\n");
        return E_FAIL;
    }
    if (dwFlags & DMUS_SEGF_DEFAULT ) 
    {
        DWORD   dwResTemp;
        pSegment->GetDefaultResolution( &dwResTemp );
        dwFlags &= ~DMUS_SEGF_DEFAULT;
        dwFlags |= dwResTemp;
    }
    // If the app wants an audiopath created dynamically from the segment, find it and use it.
    // Note that this overrides an audiopath created from the song. 
    if (dwFlags & DMUS_SEGF_USE_AUDIOPATH)
    {
        IUnknown *pSegConfig;
        if (SUCCEEDED(pSegment->GetAudioPathConfig(&pSegConfig)))
        {
            if (pConfig)
            {
                pConfig->Release();
            }
            pConfig = pSegConfig;
        }
    }

    // If we got an audiopath config from the segment or song, use it.
    if (pConfig)
    {
        IDirectMusicAudioPath *pNewPath;
        if (SUCCEEDED(CreateAudioPath(pConfig,TRUE,&pNewPath)))
        {
            // Now, get the CAudioPath structure.
            if (SUCCEEDED(pNewPath->QueryInterface(IID_CAudioPath,(void **) &pInternalPath)))
            {
                pAudioPath = pInternalPath;
            }
            pNewPath->Release();
        }
        else
        {
            pConfig->Release();
            Trace(0,"Error: Embedded audiopath failed to create, segment will not play.\n");
            return DMUS_E_NO_AUDIOPATH;
        }
        pConfig->Release();
    }
    
    if (pTransition)
    {
        pTransition->AddRef();
    }

    if ((dwFlags & DMUS_SEGF_SECONDARY) && (dwFlags & DMUS_SEGF_QUEUE))
    {
        // Can only queue if there's a segment to queue after.
        if (pFrom)
        {
            CSegState *pSegFrom = NULL;
            if (SUCCEEDED(pFrom->QueryInterface(IID_CSegState,(void **) &pSegFrom)))
            {
                // Calculate the time at which the preceding segment will stop.
                MUSIC_TIME mtStartTime = pSegFrom->GetEndTime( pSegFrom->m_mtResolvedStart );
                i64StartTime = mtStartTime;
                dwFlags &= ~DMUS_SEGF_REFTIME;
                pSegFrom->Release();
            }
        }
    }

    // If auto-transition is requested,
    // get the transition template, if it exists,
    // and compose a segment with it.
    CSegment *pPlayAfter = NULL;    // This will hold the second segment, if we end up with a transition.
    DWORD dwFlagsAfter = dwFlags & (DMUS_SEGF_SECONDARY | DMUS_SEGF_CONTROL);
    if ( dwFlags & DMUS_SEGF_AUTOTRANSITION )
    {
        // First, calculate the time to start the transition.
        // Note: this will be done again later. We really need to fold this all together.
        REFERENCE_TIME rtTime;
        if (i64StartTime == 0)
        {
            GetQueueTime( &rtTime );
        }
        else if (dwFlags & DMUS_SEGF_REFTIME)
        {
            rtTime = i64StartTime;
        }
        else
        {
            MusicToReferenceTime((MUSIC_TIME) i64StartTime,&rtTime);
        }
        REFERENCE_TIME rtResolved;
        GetResolvedTime(rtTime, &rtResolved,dwFlags);
        MUSIC_TIME mtTime;  // Actual time to start transition.
        ReferenceToMusicTime(rtResolved,&mtTime);

        CSegment *pPriorSeg = NULL;
        // Find the segment that is active at transition time.
        CSegState *pPriorState = GetSegmentForTransition(dwFlags,mtTime,pFrom);
        if (pPriorState)
        {
            pPriorSeg = pPriorState->m_pSegment;
        }
        // If this is a song, use the id to get the transition.
        if (pSong && !pTransition)
        {
            DMUS_IO_TRANSITION_DEF Transition;
            // Now, find out what sort of transition is expected.
            if (SUCCEEDED(pSong->GetTransitionSegment(pPriorSeg,pSegment,&Transition)))
            {
                if (Transition.dwTransitionID != DMUS_SONG_NOSEG)
                {
                    if (S_OK == pSong->GetPlaySegment(Transition.dwTransitionID,&pTransition))
                    {
                        dwFlags = Transition.dwPlayFlags;
                    }
                }
                else
                {
                    dwFlags = Transition.dwPlayFlags;
                }
            }
        }
        if (pTransition)
        {
            IDirectMusicSegment *pITransSegment = NULL;
            if (pPriorState)
            {
                pTransition->Compose(mtTime - pPriorState->m_mtOffset, pPriorSeg, pSegment, &pITransSegment);
            }
            else
            {
                pTransition->Compose(0,pPriorSeg,pSegment,&pITransSegment);
            }
            // Now, if we successfully composed a transition segment, set it up to be the one we
            // will play first. Later, we fill call PlaySegment() with pPlayAfter, to queue it
            // to play after the transition.
            if (pITransSegment)
            {
                pPlayAfter = pSegment;
                pSegment = (CSegment *) pITransSegment;
            }
        }
    }
    if (pSegment)
    {
        CSegState *pSegState;
        if (!pAudioPath)
        {
            pAudioPath = m_pDefaultAudioPath;
        }
        if (pAudioPath && !pAudioPath->IsActive())
        {
            Trace(1,"Error: Can not play segment on inactive audiopath\n");
            hr = DMUS_E_AUDIOPATH_INACTIVE;
        }
        else if ((m_dwAudioPathMode != 1) && !pAudioPath)
        {
            Trace(1,"Error: No audiopath to play segment on.\n");
            hr = DMUS_E_NO_AUDIOPATH;
        }
        else
        {
            if (ppSegmentState)
            {
                *ppSegmentState = NULL;
            }
            hr = PlayOneSegment(
                pSegment, 
                dwFlags, 
                i64StartTime, 
                &pSegState,
                pAudioPath);
            if (SUCCEEDED(hr))
            {
                if (pFrom)
                {
                    pSegState->m_fCanStop = FALSE;
                    StopEx(pFrom,pSegState->m_mtResolvedStart,0);
                    pSegState->m_fCanStop = TRUE;
                }
                // If this was actually a transition segment, now we need to play the original segment!
                if (pPlayAfter)
                {
                    MUSIC_TIME mtStartTime = pSegState->GetEndTime(pSegState->m_mtResolvedStart );
                    pSegState->Release();
                    hr = PlayOneSegment(pPlayAfter,dwFlagsAfter,mtStartTime,&pSegState,pAudioPath);
                }
                if (SUCCEEDED(hr))
                {
                    if (pSong)
                    {
                        pSegState->m_fSongMode = TRUE;
                    }
                    if (ppSegmentState)
                    {
                        *ppSegmentState = pSegState;
                    }
                    else
                    {
                        pSegState->Release();
                    }
                }
            }   
        }
    }
    else
    {
        // There never was a segment to play, not even a transition. 
        Trace(1,"Error: No segment to play.\n");
        hr = E_INVALIDARG;
    }
    // Before leaving, reduce the reference counts on variables that have been addref'd.
    if (pSegment)
    {
        pSegment->Release();
    }
    if (pTransition)
    {
        pTransition->Release();
    }
    if (pPlayAfter)
    {
        pPlayAfter->Release();
    }
    if (pInternalPath)
    {
        pInternalPath->Release();
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE CPerformance::PlaySegment( 
    IDirectMusicSegment *pSegment,
    DWORD dwFlags,
    __int64 i64StartTime,
    IDirectMusicSegmentState **ppSegmentState) 
{
    V_INAME(IDirectMusicPerformance::PlaySegment);
    V_INTERFACE(pSegment);
    V_PTRPTR_WRITE_OPT(ppSegmentState);
    CSegment *pCSourceSegment = NULL;
    if (SUCCEEDED(pSegment->QueryInterface(IID_CSegment,(void **) &pCSourceSegment)))
    {
        pCSourceSegment->Release();
    }
    else
    {
        Trace(0,"Error: Invalid segment object passed to PlaySegment(). Segment must be created using CLSID_DirectMusicSegment object.\n"); 
        return E_POINTER;
    }
    return PlaySegmentInternal(pCSourceSegment,NULL,0,NULL,dwFlags,i64StartTime,ppSegmentState,NULL,NULL);
}

HRESULT STDMETHODCALLTYPE CPerformance::PlaySegmentEx(
    IUnknown* pSource,
#ifdef XBOX
    const char *pszSegmentName,
#else
    WCHAR *pwzSegmentName,
#endif
    IUnknown* pTransition,
    DWORD dwFlags, 
    __int64 i64StartTime, 
    IDirectMusicSegmentState** ppSegmentState,
    IUnknown *pFrom,
    IUnknown *pAudioPath)
{
    V_INAME(IDirectMusicPerformance::PlaySegmentEx);
    V_INTERFACE_OPT(pSource);
    V_INTERFACE_OPT(pTransition);
    V_PTRPTR_WRITE_OPT(ppSegmentState);
    V_INTERFACE_OPT(pFrom);
    V_INTERFACE_OPT(pAudioPath);

#ifdef XBOX
    WCHAR *pwzSegmentName;
	WCHAR wzSegmentName[20];
    if (pszSegmentName)
	{
		mbstowcs( wzSegmentName, pszSegmentName, 20 );
		pwzSegmentName = wzSegmentName;
	}
	else pwzSegmentName = NULL;
#endif

    CSegment *pCSourceSegment = NULL;
    CSong *pCSourceSong = NULL;
    CSegment *pCTransition = NULL;
    CAudioPath *pCAudioPath = NULL;
//    TraceI(0,"Playing %lx at time %ld, flags %lx, Transition %lx\n",pSource,(long)i64StartTime,dwFlags,pTransition);

    // We may not have a source segment in the special case of transitioning from NULL.
    if (!pSource && !pTransition)
    {
        Trace(0,"Error: Must pass either a segment or transition segment to PlaySegmentEx()\n"); 
        return E_POINTER;
    }
    if (pSource)
    {
        // Figure out if we have a source song or segment and get the internal representations.
        if (SUCCEEDED(pSource->QueryInterface(IID_CSegment,(void **) &pCSourceSegment)))
        {
            pCSourceSegment->Release();
        }
        else if (SUCCEEDED(pSource->QueryInterface(IID_CSong,(void **) &pCSourceSong)))
        {
            pCSourceSong->Release();
        }
        else
        {
            Trace(0,"Error: Invalid segment or song passed to PlaySegmentEx().\n"); 
            return E_POINTER;
        }
    }
    // If we have a transition segment, get the CSegment representation.
    if (pTransition)
    {
        if (SUCCEEDED(pTransition->QueryInterface(IID_CSegment,(void **) &pCTransition)))
        {
            pCTransition->Release();
        }
        else
        {
            Trace(0,"Error: Invalid transition passed to PlaySegmentEx().\n"); 
            return E_POINTER;
        }
    }
    if (pAudioPath)
    {
        if (SUCCEEDED(pAudioPath->QueryInterface(IID_CAudioPath,(void **) &pCAudioPath)))
        {
            pCAudioPath->Release();
        }
        else
        {
            Trace(0,"Error: Invalid audiopath passed to PlaySegmentEx().\n"); 
            return E_POINTER;
        }
    }
    ENTER_API_CRITICAL_SECTION;
    HRESULT hr = PlaySegmentInternal(pCSourceSegment,pCSourceSong,pwzSegmentName,
        pCTransition,dwFlags,i64StartTime,
        ppSegmentState,pFrom,
        pCAudioPath);
    LEAVE_API_CRITICAL_SECTION;
    return hr;

}

STDMETHODIMP CPerformance::SetDefaultAudioPath(IDirectMusicAudioPath *pAudioPath) 
{
    V_INAME(IDirectMusicPerformance::SetDefaultAudioPath);
    V_INTERFACE_OPT(pAudioPath);
    if (m_dwAudioPathMode == 0)
    {
        Trace(0,"Error: Performance not initialized.\n");
        return DMUS_E_NOT_INIT;
    }
#ifndef XBOX
    if (m_dwAudioPathMode == 1)
    {
        Trace(0,"Error: Performance initialized not to support Audiopaths.\n"); 
        return DMUS_E_AUDIOPATHS_NOT_VALID;
    }
#endif
    ENTER_API_CRITICAL_SECTION;
    CAudioPath *pCPath = NULL;
    if (pAudioPath)
    {
        if (SUCCEEDED(pAudioPath->QueryInterface(IID_CAudioPath,(void **) &pCPath)))
        {
            pCPath->Release();
            if (!m_AudioPathList.IsMember(pCPath))
            {
                // This is not a legal audiopath, since it wasn't created by this performance.
                Trace(0,"Error: Invalid audiopath - not created by this Performance.\n"); 
                LEAVE_API_CRITICAL_SECTION;
                return E_INVALIDARG;
            }
            if (pCPath->NoPorts())
            {
                // This is an audiopath that doesn't have any port configurations. 
                // For example, it might be environmental reverb.
                Trace(0,"Error: Failure setting default audiopath - does not have any ports, so can not be played on.\n"); 
                LEAVE_API_CRITICAL_SECTION;
                return DMUS_E_AUDIOPATH_NOPORT;
            }
        }
        else
        {
            // This is not a legal audiopath object at all.
            Trace(0,"Error: Invalid audiopath - not created by call to Performance->CreateAudioPath().\n"); 
            LEAVE_API_CRITICAL_SECTION;
            return E_INVALIDARG;
        }
    }
    if (m_pDefaultAudioPath)
    {
        m_pDefaultAudioPath->Release();
        m_pDefaultAudioPath = NULL;
    }
    m_pDefaultAudioPath = pCPath;
    if (pCPath)
    {
        pCPath->AddRef();
        pCPath->Activate(TRUE);
    }
    LEAVE_API_CRITICAL_SECTION;
    return S_OK;
}

STDMETHODIMP CPerformance::GetDefaultAudioPath(IDirectMusicAudioPath **ppAudioPath) 
{
    V_INAME(IDirectMusicPerformance::GetDefaultAudioPath);
    V_PTRPTR_WRITE(ppAudioPath);
    if (m_dwAudioPathMode == 0)
    {
        Trace(0,"Error: Performance not initialized.\n");
        return DMUS_E_NOT_INIT;
    }
#ifndef XBOX
    if (m_dwAudioPathMode == 1)
    {
        Trace(0,"Error: Performance was initialized not to support audiopaths.\n"); 
        return DMUS_E_AUDIOPATHS_NOT_VALID;
    }
#endif
    if (m_pDefaultAudioPath)
    {
        *ppAudioPath = (IDirectMusicAudioPath *) m_pDefaultAudioPath;
        m_pDefaultAudioPath->AddRef();
        return S_OK;
    }
    Trace(3,"Warning: No default audiopath\n"); 
    return DMUS_E_NOT_FOUND;
}

HRESULT STDMETHODCALLTYPE CPerformance::CreateAudioPath( IUnknown *pSourceConfig, 
                                                        BOOL fActivate, 
                                                        IDirectMusicAudioPath **ppNewPath)

{
    V_INAME(IDirectMusicPerformance::CreateAudioPath);
    V_INTERFACE(pSourceConfig);
    V_PTRPTR_WRITE_OPT(ppNewPath);

    if (m_dwAudioPathMode == 0)
    {
        Trace(0,"Error: Performance not initialized.\n");
        return DMUS_E_NOT_INIT;
    }
#ifndef XBOX
    if (m_dwAudioPathMode == 1)
    {
        Trace(0,"Error: Performance not initialized to support audiopaths (must use InitAudio.)\n"); 
        return DMUS_E_AUDIOPATHS_NOT_VALID;
    }
#endif
    ENTER_API_CRITICAL_SECTION;
    HRESULT hr = E_OUTOFMEMORY;
    CAudioPath *pPath = new CAudioPath;
    if (pPath)
    {
        hr = pPath->Init(pSourceConfig,this);
        if (SUCCEEDED(hr) && fActivate)
        {
            hr = pPath->Activate(TRUE);
#ifdef DBG
            if (FAILED(hr))
            {
                Trace(1,"Error: Audiopath creation failed because one or more buffers could not be activated.\n");
            }
#endif
        }
        if (SUCCEEDED(hr))
        {
            hr = pPath->QueryInterface(IID_IDirectMusicAudioPath,(void **) ppNewPath);
        }
        else
        {
            delete pPath;
        }
    }
    LEAVE_API_CRITICAL_SECTION;
    return hr;
}

STDMETHODIMP CPerformance::CreateStandardAudioPath(DWORD dwType, 
                                                   DWORD dwPChannelCount, 
                                                   BOOL fActivate, 
                                                   IDirectMusicAudioPath **ppNewPath)
{
    V_INAME(IDirectMusicPerformance::CreateStandardAudioPath);
    V_PTRPTR_WRITE_OPT(ppNewPath);
    HRESULT hr = S_OK;
    if (m_dwAudioPathMode == 2)
    {
        if ((dwType <= DMUS_APATH_SHARED_STEREO) && (dwType >= DMUS_APATH_SHARED_STEREOPLUSREVERB))
        {
            if (!(m_AudioParams.dwFeatures & DMUS_AUDIOF_BUFFERS))
            {
                Trace(4,"Warning: Creating a standard audiopath without buffers - InitAudio specified no buffer support.\n");
                // If the default synth doesn't support buffers, then create a simple port with no buffers.
                dwType = 0;
            }
            CAudioPathConfig *pConfig = CAudioPathConfig::CreateStandardConfig(dwType,dwPChannelCount,m_AudioParams.dwSampleRate);
            if (pConfig)
            {
                hr = CreateAudioPath((IPersistStream *) pConfig,fActivate,ppNewPath);
                pConfig->Release();
            }
            else
            {
                // CreateStandardConfig only returns NULL if we've run out of memory.
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            Trace(0,"Error: %ld is not a valid predefined audiopath.\n",dwType);
            hr  = E_INVALIDARG;
        }
    }
    else
    {
        Trace(0,"Error: Performance not initialized to support audiopaths.\n"); 
        hr = DMUS_E_AUDIOPATHS_NOT_VALID;
    }
    return hr;
}

// Stop the segment state at mtTime. If NULL, stop all.
void CPerformance::DoStop( CSegState* pSegState, MUSIC_TIME mtTime,
                                     BOOL fInvalidate)
{
    HRESULT hrAbort = S_OK;
    DWORD dwCount;
    if( NULL == pSegState ) return;
    ENTER_CRITICAL_SECTION(&m_SegmentCrSec);
    CSegStateList *pSourceList = NULL;
    CSegStateList *pDestList = NULL;
    CSegState *pNode = NULL;
    // Mark the length of the segstate to be only as far as it played
    // to keep GetParam() from accessing the unplayed portion.
    if (pSegState)  
    {
        if (mtTime < pSegState->m_mtEndTime) 
        {
            pSegState->m_mtLength = mtTime - pSegState->m_mtResolvedStart + 
                pSegState->m_mtStartPoint;
            if (pSegState->m_mtLength < 0)
            {
                pSegState->m_mtLength = 0;
            }
            // Make endtime one greater than mtTime so Abort notification will still happen.
            pSegState->m_mtEndTime = mtTime + 1;   
        }
    }
    RecalcTempoMap(pSegState,mtTime);
    // check each play queue
    for (dwCount = SQ_PRI_PLAY; dwCount <= SQ_SEC_PLAY; dwCount++)
    {
        for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext())
        {
            if( pNode == pSegState )
            {
                // we want to move this to the approprate done queue
                pDestList = &m_SegStateQueues[SQ_PRI_DONE - SQ_PRI_PLAY + dwCount];
                pSourceList = &m_SegStateQueues[dwCount];
                if ((dwCount == SQ_PRI_PLAY) && (m_SegStateQueues[SQ_PRI_PLAY].GetCount() == 1))
                {
#ifdef DXAPI
                    if (m_dwVersion >= 8)
#endif
                    {
                        MUSIC_TIME mtNow;
                        GetTime( NULL, &mtNow );
                        GenerateNotification( DMUS_NOTIFICATION_MUSICALMOSTEND, mtNow, pSegState );
                    }
                }
                dwCount = SQ_SEC_PLAY;  // Force out of outer loop.
                break;
            }
        }
    }
    if (!pNode)
    {
        // check each done queue
        for (dwCount = SQ_PRI_DONE; dwCount <= SQ_SEC_DONE; dwCount++)
        {
            for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext())
            {
                if( pNode == pSegState )
                {
                    pSourceList = &m_SegStateQueues[dwCount];
                    dwCount = SQ_SEC_DONE;  // Force out of outer loop.
                    break;
                }
            }
        }
    }
    if( pNode && pSourceList)
    {
        REFERENCE_TIME rtTime;
        MusicToReferenceTime(mtTime,&rtTime);
        if( pNode->m_mtLastPlayed >= mtTime )
        {
            pNode->Flush( mtTime );
            pNode->m_mtLastPlayed = mtTime; // must set this to indicate it only played until then
            pNode->m_rtLastPlayed = rtTime;
        }
        if( fInvalidate )
        {
            if( pNode->m_dwPlaySegFlags & DMUS_SEGF_CONTROL )
            {
                Invalidate( mtTime, 0 ); // must call Invalidate before AbortPlay so we don't
                // invalidate the abort notification
            }
            else if ( !(pNode->m_dwPlaySegFlags & DMUS_SEGF_SECONDARY ))
            {
                // If this is a primary segment, kill the tempo map.
                FlushEventQueue( 0, &m_TempoMap, rtTime, rtTime, 0 );
            }
        }
        hrAbort = pNode->AbortPlay( mtTime, FALSE );
        if( pNode->m_dwPlaySegFlags & DMUS_SEGF_CONTROL )
        {
            pSourceList->Remove(pNode);
            m_ShutDownQueue.Insert(pNode); // we're guaranteed to never need this again

            // set dirty flags on all other segments

            for (dwCount = SQ_PRI_PLAY; dwCount <= SQ_SEC_PLAY; dwCount++)
            {
                for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext() )
                {
                    if( pNode->m_fStartedPlay )
                    {
                        pNode->m_dwPlayTrackFlags |= DMUS_TRACKF_DIRTY;
                    }
                }
            }
        }
        else if( pDestList )
        {
            pSourceList->Remove(pNode);
            pDestList->Insert(pNode);
        }
    }
    else
    {
        // check the wait lists.
        for (dwCount = SQ_PRI_WAIT; dwCount <= SQ_SEC_WAIT; dwCount++)
        {
            for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext() )
            {
                if( pNode == pSegState ) 
                {
                    hrAbort = pNode->AbortPlay( mtTime, FALSE );
                    m_SegStateQueues[dwCount].Remove(pNode);
                    RecalcTempoMap(pNode, mtTime);
                    m_ShutDownQueue.Insert(pNode); 
                    break;
                }
            }
        }
    }
    // if there aren't any more segments to play, send a Music Stopped
    // notification
    if( m_SegStateQueues[SQ_PRI_PLAY].IsEmpty() && m_SegStateQueues[SQ_SEC_PLAY].IsEmpty() &&
        m_SegStateQueues[SQ_PRI_WAIT].IsEmpty() && m_SegStateQueues[SQ_SEC_WAIT].IsEmpty() &&
        m_SegStateQueues[SQ_CON_PLAY].IsEmpty() && m_SegStateQueues[SQ_CON_WAIT].IsEmpty())
    {
        m_fMusicStopped = TRUE;
        // S_FALSE means we tried to abort this segstate, but it's already been aborted
        if (hrAbort != S_FALSE)
        {
            GenerateNotification( DMUS_NOTIFICATION_MUSICSTOPPED, mtTime, NULL );
        }
    }
    LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);
}

// Stop all segment states based off of the segment.
void CPerformance::DoStop( CSegment* pSeg, MUSIC_TIME mtTime, BOOL fInvalidate )
{
    long lCount;
    CSegState* pNode;
    CSegState* pNext;
    ENTER_CRITICAL_SECTION(&m_SegmentCrSec);
    // find all seg pSegStates based off this segment that have played through time mtTime
    // if pSeg is NULL, go through all of the segment lists. Flush any
    // segment that played through time mtTime. Move any active segments
    // into past lists.
    if( pSeg )
    {
        for (lCount = SQ_SEC_DONE; lCount >= SQ_PRI_WAIT; lCount--)
        {
            pNode = m_SegStateQueues[lCount].GetHead();
            while( pNode )
            {
                pNext = pNode->GetNext();
                if( pNode->m_pSegment == pSeg )
                {
                    if (IsDoneQueue(lCount))
                    {
                        if (pNode->m_mtLastPlayed >= mtTime)
                        {
                             DoStop( pNode, mtTime, fInvalidate );
                        }
                    }
                    else
                    {
                        DoStop( pNode, mtTime, fInvalidate );
                    }
                }
                pNode = pNext;
            }
        }
    }
    else // pSeg is NULL, stop everything.
    {
        // go ahead and flush the event queues
        ENTER_CRITICAL_SECTION(&m_PipelineCrSec);
        FlushMainEventQueues( 0, mtTime, mtTime, 0 );
        LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);
        // clear out the wait lists
        for (lCount = SQ_PRI_WAIT; lCount <= SQ_SEC_WAIT; lCount++)
        {
            while (pNode = m_SegStateQueues[lCount].GetHead())
            {
                pNode->AbortPlay( mtTime, FALSE );
                m_SegStateQueues[lCount].RemoveHead();
                m_ShutDownQueue.Insert(pNode); 
            }
        }
        // stop any segment that is currently playing.
        for (lCount = SQ_PRI_DONE; lCount <= SQ_SEC_DONE; lCount++)
        {
            for( pNode = m_SegStateQueues[lCount].GetHead(); pNode; pNode = pNode->GetNext() )
            {
                if( pNode->m_mtLastPlayed >= mtTime )
                {
                    DoStop( pNode, mtTime, fInvalidate );
                }
            }
        }
        for (lCount = SQ_PRI_PLAY; lCount <= SQ_SEC_PLAY; lCount++)
        {
            while( m_SegStateQueues[lCount].GetHead() )
            {
                DoStop( m_SegStateQueues[lCount].GetHead(), mtTime, fInvalidate );
            }
        }
        // reset controllers and force all notes off.
        ResetAllControllers( GetLatency() );
    }
    LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);
}


STDMETHODIMP CPerformance::StopEx(IUnknown *pObjectToStop,__int64 i64StopTime,DWORD dwFlags) 
{
    V_INAME(IDirectMusicPerformance::StopEx);
    V_INTERFACE_OPT(pObjectToStop);
    HRESULT hr = E_INVALIDARG;
    IDirectMusicSegmentState *pState;
    IDirectMusicSegment *pSegment;
    CSong *pSong;
    CAudioPath *pAudioPath;
    if (m_dwAudioPathMode == 0)
    {
        Trace(0,"Error: Performance not initialized.\n");
        return DMUS_E_NOT_INIT;
    }
TraceI(0,"StopExing %lx at time %ld, flags %lx\n",pObjectToStop,(long)i64StopTime,dwFlags);
    if (pObjectToStop == NULL)
    {
        MUSIC_TIME mtTime;
        if (dwFlags & DMUS_SEGF_REFTIME)
        {
            ReferenceToMusicTime(i64StopTime,&mtTime);
            dwFlags &= ~DMUS_SEGF_REFTIME;
        }
        else
        {
            mtTime = (MUSIC_TIME) i64StopTime;
        }
        return Stop(NULL,NULL,mtTime,dwFlags);
    }
    if (dwFlags & DMUS_SEGF_AUTOTRANSITION)
    {
        // I this is an autotransition, it will only work if the currently playing segment in question
        // is a member of a song. So, check the segstate, segment, song, and audiopath
        // to find the segstate. And, if found, see if it is part of a song. If so,
        // then go ahead and do the transition.
        ENTER_CRITICAL_SECTION(&m_SegmentCrSec);
        BOOL fTransition = FALSE;
        dwFlags &= ~DMUS_SEGF_AUTOTRANSITION;
        CSegState *pCState = NULL;
        // First, see if this is a segstate.
        HRESULT hrTemp = pObjectToStop->QueryInterface(IID_CSegState,(void **)&pCState);
        if (FAILED(hrTemp))
        {
            // Segstate failed. Is this a Song? If so, find the first correlating segstate.
            CSong *pCSong = NULL;
            CAudioPath *pCAudioPath = NULL;
            CSegment *pCSegment = NULL;
            hrTemp = pObjectToStop->QueryInterface(IID_CSong,(void **)&pCSong);
            if (FAILED(hrTemp))
            {
                hrTemp = pObjectToStop->QueryInterface(IID_CSegment,(void **)&pCSegment);
            }
            if (FAILED(hrTemp))
            {
                hrTemp = pObjectToStop->QueryInterface(IID_CAudioPath,(void **)&pCAudioPath);
            }
            if (SUCCEEDED(hrTemp))
            {
                CSegState *pNode;
                DWORD dwCount;
                for (dwCount = SQ_PRI_WAIT; dwCount <= SQ_SEC_DONE; dwCount++)
                {
                    for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext() )
                    {
                        if (pNode->m_fCanStop)
                        {
                            // Can only do this if the segstate ultimately points to a song.
                            if (pNode->m_pSegment && pNode->m_pSegment->m_pSong)
                            {
                                if ((pNode->m_pSegment == pCSegment) ||
                                    (pNode->m_pSegment->m_pSong == pCSong) ||
                                    (pCAudioPath && (pNode->m_pAudioPath == pCAudioPath)))
                                {
                                    pCState = pNode;
                                    pCState->AddRef();
                                    break;
                                }
                            }
                        }
                    }
                    if (pCState) break;
                }
            }
            if (pCSong) pCSong->Release();
            else if (pCAudioPath) pCAudioPath->Release();
            else if (pCSegment) pCSegment->Release();
        }
        if (pCState)
        {
            CSegment *pPriorSeg = pCState->m_pSegment;
            if (pPriorSeg)
            {
                pSong = pPriorSeg->m_pSong;
                if (pSong)
                {
                    // If this is an autotransition, compose a transition segment from the
                    // current position in the song and play it.
                    // This will, in turn, call stop on the song, so we don't need to do it here.
                    // First, calculate the time to start the transition.
                    REFERENCE_TIME rtTime;
                    if (i64StopTime == 0)
                    {
                        GetQueueTime( &rtTime );
                    }
                    else if (dwFlags & DMUS_SEGF_REFTIME)
                    {
                        rtTime = i64StopTime;
                    }
                    else
                    {
                        MusicToReferenceTime((MUSIC_TIME) i64StopTime,&rtTime);
                    }
                    REFERENCE_TIME rtResolved;
                    GetResolvedTime(rtTime, &rtResolved,dwFlags);
                    MUSIC_TIME mtTime;  // Actual time to start transition.
                    ReferenceToMusicTime(rtResolved,&mtTime);

                    CSegment *pTransition = NULL;
                    // Now, get the transition.
                    DMUS_IO_TRANSITION_DEF Transition;
                    if (SUCCEEDED(pSong->GetTransitionSegment(pPriorSeg,NULL,&Transition)))
                    {
                        if (Transition.dwTransitionID != DMUS_SONG_NOSEG)
                        {
                            if (S_OK == pSong->GetPlaySegment(Transition.dwTransitionID,&pTransition))
                            {
                                dwFlags = Transition.dwPlayFlags;
                            }
                        }
                    }
                    if (pTransition)
                    {
                        IDirectMusicSegment *pITransSegment = NULL;
                        pTransition->Compose(mtTime - pCState->m_mtOffset, pPriorSeg, NULL, &pITransSegment);
                        // Now, if we successfully composed a transition segment, set it up to be the one we
                        // will play first. Later, we fill call PlaySegment() with pPlayAfter, to queue it
                        // to play after the transition.
                        if (pITransSegment)
                        {
                            hr = PlaySegmentEx(pITransSegment,NULL,NULL,dwFlags,i64StopTime,NULL,(IDirectMusicSegmentState *)pCState,NULL);
                            pITransSegment->Release();
                            fTransition = TRUE;
                        }
                        pTransition->Release();
                    }
                }
            }
            pCState->Release();
        }
        LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);
        if (fTransition)
        {
            return hr;
        }
    }
    if (SUCCEEDED(pObjectToStop->QueryInterface(IID_IDirectMusicSegmentState,(void **) &pState)))
    {
        hr = Stop(NULL,pState,(MUSIC_TIME)i64StopTime,dwFlags);
        pState->Release();
    }
    else if (SUCCEEDED(pObjectToStop->QueryInterface(IID_IDirectMusicSegment,(void **) &pSegment)))
    {
        hr = Stop(pSegment,NULL,(MUSIC_TIME)i64StopTime,dwFlags);
        pSegment->Release();
    }
    else if (SUCCEEDED(pObjectToStop->QueryInterface(IID_CAudioPath,(void **) &pAudioPath)))
    {
        pAudioPath->Release();
        ENTER_CRITICAL_SECTION(&m_SegmentCrSec);
        CSegState *pNode;
        DWORD dwCount;
        for (dwCount = SQ_PRI_WAIT; dwCount <= SQ_SEC_DONE; dwCount++)
        {
            CSegState *pNext;
            for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNext )
            {
                pNext = pNode->GetNext();
                if (pNode->m_fCanStop && (pNode->m_pAudioPath == pAudioPath))
                {
                    hr = Stop(NULL,(IDirectMusicSegmentState *)pNode,(MUSIC_TIME)i64StopTime,dwFlags);
                }
            }
        }
        LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);
    }
    else if (SUCCEEDED(pObjectToStop->QueryInterface(IID_CSong,(void **) &pSong)))
    {
        pSong->Release();
        ENTER_CRITICAL_SECTION(&m_SegmentCrSec);
        CSegState *pNode;
        DWORD dwCount;
        for (dwCount = SQ_PRI_WAIT; dwCount <= SQ_SEC_DONE; dwCount++)
        {
            for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext() )
            {
                if (pNode->m_fCanStop && pNode->m_pSegment && (pNode->m_pSegment->m_pSong == pSong))
                {
                    hr = Stop(NULL,(IDirectMusicSegmentState *)pNode,(MUSIC_TIME)i64StopTime,dwFlags);
                }
            }
        }
        LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);
    }
#ifdef XBOX // Need to force some real time processing so the notes get cut off.
    g_BossMan.WakeUp(m_pRealtimeWorker);
#endif
    return hr;
}


HRESULT STDMETHODCALLTYPE CPerformance::Stop( 
    IDirectMusicSegment *pISegment, // @parm The Segment to stop playing. All SegmentState's based upon this Segment are
                                    // stopped playing at time <p mtTime>.
    IDirectMusicSegmentState *pISegmentState, // @parm The SegmentState to stop playing.
    MUSIC_TIME mtTime,  // @parm The time at which to stop the Segments, Segment State, or everything. If
                                    // this time is in the past, stop everything right away. Therefore, a value of
                                    // 0 indicates stop everything NOW.
    DWORD dwFlags)      // @parm Flag that indicates whether we should stop immediately at time <p mtTime>,
                                    // or on the grid, measure, or beat following <p mtTime>. This is only valid in
                                    // relation to the currently playing primary segment. (For flag descriptions,
                                    // see <t DMPLAYSEGFLAGS>.)
{
    V_INAME(IDirectMusicPerformance::Stop);
    V_INTERFACE_OPT(pISegment);
    V_INTERFACE_OPT(pISegmentState);


    CSegment *pSegment = NULL;
    CSegState *pSegmentState = NULL; 
TraceI(0,"Stopping Segment %lx, SegState %lx at time %ld, flags %lx\n",pISegment,pISegmentState,mtTime,dwFlags);
    if (pISegmentState)
    {
        if (SUCCEEDED(pISegmentState->QueryInterface(IID_CSegState,(void **)&pSegmentState)))
        {
            pISegmentState->Release();
        }
        else
        {
            Trace(0,"Error: Pointer in SegState parameter to Stop() is invalid.\n");
            return E_INVALIDARG;
        }
    }
    if (pISegment)
    {
        if (SUCCEEDED(pISegment->QueryInterface(IID_CSegment,(void **)&pSegment)))
        {
            pISegment->Release();
        }
        else
        {
            Trace(0,"Error: Pointer in Segment parameter to Stop() is invalid.\n");
            return E_INVALIDARG;
        }
    }
    ENTER_CRITICAL_SECTION(&m_SegmentCrSec);
    ENTER_API_CRITICAL_SECTION;
    if (pSegmentState)
    {
        // If this is the starting segstate from a playing song, find the
        // current active segstate within that song.
        // The current active segstate keeps a pointer to 
        // this segstate.
        if (pSegmentState->m_fSongMode)
        {
            CSegState* pNode;
            DWORD dwCount;
            for (dwCount = 0; dwCount < SQ_COUNT; dwCount++)
            {
                for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext() )
                {
                    if (pNode->m_pSongSegState == pSegmentState)
                    {
                        pSegmentState = pNode;
                        dwCount = SQ_COUNT;
                        break;
                    }
                }
            }
        }
    }
    if( dwFlags & DMUS_SEGF_DEFAULT )
    {
        DWORD   dwNewRes = 0;
        if( pSegment )
        {
            pSegment->GetDefaultResolution( &dwNewRes );
        }
        else if( pSegmentState )
        {
            IDirectMusicSegment*    pSegTemp;
            if( SUCCEEDED( pSegmentState->GetSegment( &pSegTemp ) ) )
            {
                pSegTemp->GetDefaultResolution( &dwNewRes );
                pSegTemp->Release();
            }
            else
            {
                dwNewRes = 0;
            }
        }
        else
        {
            dwNewRes = 0;
        }
        dwFlags |= dwNewRes;
        dwFlags &= ~DMUS_SEGF_DEFAULT;
    }
    // Make sure mtTime is greater or equal to QueueTime, which is the last time notes were
    // queued down (or latency time, whichever is later) so we can stop everything after it.
    MUSIC_TIME mtLatency;
    REFERENCE_TIME rtQueueTime;
    GetQueueTime( &rtQueueTime );
    ReferenceToMusicTime( rtQueueTime, &mtLatency );
    if( mtTime < mtLatency ) mtTime = mtLatency;
    // Resolve the time according to the resolution
    mtTime = ResolveTime( mtTime, dwFlags, NULL );
    // if mtTime is less than the current transported time, we can take
    // care of the Stop now. Otherwise, we need to cue a Stop PMsg and
    // take care of it at QUEUE time.
    if( mtTime <= m_mtTransported )
    {
        if( pSegmentState )
        {
            DoStop( pSegmentState, mtTime, TRUE );
            if( pSegment )
            {
                DoStop( pSegment, mtTime, TRUE );
            }
        }
        else
        {
            DoStop( pSegment, mtTime, TRUE );
        }
    }
    else
    {
        // find and mark the segment and/or segment state to not play beyond
        // the stop point.
        CSegState* pNode;
        DWORD dwCount;
        for (dwCount = SQ_PRI_PLAY; dwCount <= SQ_SEC_PLAY; dwCount++)
        {
            for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext() )
            {
                if( (pNode->m_pSegment == pSegment) ||
                    (pNode == pSegmentState) ||
                    (!pSegment && !pSegmentState))
                {
                    if (pNode->m_fCanStop)
                    {
                        pNode->m_mtStopTime = mtTime;
                        // Make sure GetParams ignore the rest of the segment from now on.
                        if (mtTime < pNode->m_mtEndTime) 
                        {
                            pNode->m_mtLength = mtTime - pNode->m_mtResolvedStart + 
                                pNode->m_mtStartPoint;
                            if (pNode->m_mtLength < 0)
                            {
                                pNode->m_mtLength = 0;
                            }
                            // Make endtime one greater than mtTime so Abort notification will still happen.
                            pNode->m_mtEndTime = mtTime + 1;   
                        }
                        // Force the tempo map to be recalculated IF this has a tempo track.
                        RecalcTempoMap(pNode,mtTime);
                    }
                }
            }
        }
    }
    LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);
    LEAVE_API_CRITICAL_SECTION;
    return S_OK;
}

void CPerformance::ResetAllControllers(CChannelMap* pChannelMap, REFERENCE_TIME rtTime, bool fGMReset)

{
    DWORD dwIndex = pChannelMap->dwPortIndex;
    DWORD dwGroup = pChannelMap->dwGroup;
    DWORD dwMChannel = pChannelMap->dwMChannel;

    ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);
#ifdef DXAPI
    IDirectMusicPort* pPort = m_pPortTable[dwIndex].pPort;
    IDirectMusicBuffer* pBuffer = m_pPortTable[dwIndex].pBuffer;
    if( pPort && pBuffer )
    {
        m_pPortTable[dwIndex].fBufferFilled = TRUE;
        if (!rtTime)
        {
            rtTime = m_pPortTable[dwIndex].rtLast + 1;
        }
        else
        {
            m_pPortTable[dwIndex].rtLast = rtTime;
        }
        pChannelMap->Reset(true);
        DWORD dwMsg = dwMChannel | MIDI_CCHANGE | (MIDI_CC_ALLSOUNDSOFF << 8); // 0x78 is all sounds off. 
        if( FAILED( pBuffer->PackStructured( rtTime, dwGroup, dwMsg ) ) )
        {
            pPort->PlayBuffer( pBuffer );
            pBuffer->Flush();
            // try one more time
            pBuffer->PackStructured( rtTime, dwGroup, dwMsg );
        }
        dwMsg = dwMChannel | MIDI_CCHANGE | (MIDI_CC_RESETALL << 8) | (1 << 16) ; // 0x79 is reset all controllers. Data byte set to indicate volume and pan too.
        if( FAILED( pBuffer->PackStructured( rtTime + 30 * REF_PER_MIL, dwGroup, dwMsg ) ) )
        {
            pPort->PlayBuffer( pBuffer );
            pBuffer->Flush();
            // try one more time
            pBuffer->PackStructured( rtTime + (30 * REF_PER_MIL), dwGroup, dwMsg );
        }
        // Send one GM Reset per channel group, but only under DX8 (and only if we need to). 
        if ((dwMChannel == 0) 
            && (m_dwVersion >= 8) 
            && fGMReset)
        {
            // create a buffer of the right size
            DMUS_BUFFERDESC dmbd;
            IDirectMusicBuffer *pBuffer;
            static BYTE abGMReset[6] = { (BYTE)MIDI_SYSX,0x7E,0x7F,9,1,(BYTE)MIDI_EOX }; 
            memset( &dmbd, 0, sizeof(DMUS_BUFFERDESC) );
            dmbd.dwSize = sizeof(DMUS_BUFFERDESC);
            dmbd.cbBuffer = 50;

            ENTER_CRITICAL_SECTION(&m_MainCrSec);
            if( SUCCEEDED( m_pDirectMusic->CreateMusicBuffer(&dmbd, &pBuffer, NULL)))
            {
                if( SUCCEEDED( pBuffer->PackUnstructured( rtTime + (30 * REF_PER_MIL), dwGroup,
                    6, abGMReset ) ) )
                {
                    pPort->PlayBuffer(pBuffer);
                }
                pBuffer->Release();
            }
            LEAVE_CRITICAL_SECTION(&m_MainCrSec);
        }
        m_rtEarliestStartTime = rtTime + (60 * REF_PER_MIL); // Give synth chance to stabilize
                                                             // before next start.
    }
#else
    if (!rtTime)
    {
        rtTime = m_rtLastSendTime + 1;
    }
    else
    {
        m_rtLastSendTime = rtTime;
    }
    pChannelMap->Reset(true);
    SendShortMsg(0,0,dwMChannel | MIDI_CCHANGE | (MIDI_CC_ALLSOUNDSOFF << 8), rtTime, dwGroup);
    SendShortMsg(0,0,dwMChannel | MIDI_CCHANGE | (MIDI_CC_RESETALL << 8) | (1 << 16), rtTime, dwGroup);
    // Send one GM Reset per channel group, but only under DX8 (and only if we need to). 
    if ((dwMChannel == 0) 
        && fGMReset)
    {
        static BYTE abGMReset[6] = { (BYTE)MIDI_SYSX,0x7E,0x7F,9,1,(BYTE)MIDI_EOX }; 
        SendLongMsg(abGMReset,6,rtTime + (30 * REF_PER_MIL), dwGroup);
    }
    m_rtEarliestStartTime = rtTime + (60 * REF_PER_MIL); // Give synth chance to stabilize
                                                             // before next start.
#endif
    LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);
}


void CPerformance::ResetAllControllers( REFERENCE_TIME rtTime )
{
    ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);

    CChannelBlock* pChannelBlock;
    SendBuffers();
    for( pChannelBlock = m_ChannelBlockList.GetHead(); pChannelBlock; pChannelBlock = pChannelBlock->GetNext() )
    {
        CChannelMap* pChannelMap;
        for( DWORD dwPChannel = pChannelBlock->m_dwPChannelStart;
            dwPChannel < pChannelBlock->m_dwPChannelStart + PCHANNEL_BLOCKSIZE;
            dwPChannel++ )
        {
            pChannelMap = &pChannelBlock->m_aChannelMap[dwPChannel - pChannelBlock->m_dwPChannelStart];
            if( pChannelMap->dwGroup ) // Valid group?
            {
                // Reset controllers and send a GM reset.
                ResetAllControllers(pChannelMap, rtTime, true);
            }
        }
    }
    SendBuffers();

    LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);
}

// internal: return CSegState* at time mtTime
// only call this from within a segment critical section
CSegState* CPerformance::GetPrimarySegmentAtTime( MUSIC_TIME mtTime )
{
    CSegState* pSegNode;
    CSegState* pSegReturn = NULL;
    BOOL fCheckedPri = FALSE;
    for( pSegNode = m_SegStateQueues[SQ_PRI_DONE].GetHead(); pSegNode; pSegNode = pSegNode->GetNext() )
    {
        // if we're checking the past list, only check up until the last time played.
        if( (mtTime >= pSegNode->m_mtResolvedStart) && (mtTime <= pSegNode->m_mtLastPlayed) )
        {
            pSegReturn = pSegNode;
            break;
        }
    }
    for( pSegNode = m_SegStateQueues[SQ_PRI_PLAY].GetHead(); pSegNode; pSegNode = pSegNode->GetNext() )
    {
        MUSIC_TIME mtTest = mtTime;
        MUSIC_TIME mtOffset;
        DWORD dwRepeat;
        // if we're checking the current list, check the full segment time
        if( S_OK == pSegNode->ConvertToSegTime( &mtTest, &mtOffset, &dwRepeat ))
        {
            pSegReturn = pSegNode;
            break;
        }
    }
    if (!pSegReturn)
    {
        for( pSegNode = m_SegStateQueues[SQ_PRI_WAIT].GetHead(); pSegNode; pSegNode = pSegNode->GetNext() )
        {
            MUSIC_TIME mtTest = mtTime;
            MUSIC_TIME mtOffset;
            DWORD dwRepeat;
            // if we're checking the current list, check the full segment time
            if( S_OK == pSegNode->ConvertToSegTime( &mtTest, &mtOffset, &dwRepeat ))
            {
                pSegReturn = pSegNode;
                break;
            }
        }
    }
    return pSegReturn;
}

/*

  @method HRESULT | IDirectMusicPerformance | GetSegmentState |
  Returns the Primary SegmentState at time <p mtTime>.

  @rvalue S_OK | Success.
  @rvalue E_POINTER | ppSegmentState is NULL or invalid.
  @rvalue DMUS_E_NOT_FOUND | There is no currently playing SegmentState or one at <p mtTime>.

  @comm This function is intended for routines that need to access the currently
  playing SegmentState, e.g. to obtain the chord or command track. "Currently
  Playing" in this context means that it is being called into to perform messages.
  I.e., this includes all latencies and doesn't imply that this
  SegmentState is currenty being "heard" through the speakers.

*/
HRESULT STDMETHODCALLTYPE CPerformance::GetSegmentState( 
    IDirectMusicSegmentState **ppSegmentState,  // @parm Returns the SegmentState pointer to the one currently playing.
                                                // The caller is responsible for calling Release on this pointer.
    MUSIC_TIME mtTime ) // @parm Return the SegmentState which played, is playing, or will 
                        // be playing at mtTime. To get the currently playing segment, pass the
                        // mtTime retrieved from <om .GetTime>.
{
    V_INAME(IDirectMusicPerformance::GetSegmentState);
    V_PTRPTR_WRITE(ppSegmentState);

    CSegState* pSegNode;
    HRESULT hr;
    ENTER_CRITICAL_SECTION(&m_SegmentCrSec);
    ENTER_API_CRITICAL_SECTION;
    if( pSegNode = GetPrimarySegmentAtTime( mtTime ))
    {
        *ppSegmentState = pSegNode;
        pSegNode->AddRef();
        hr = S_OK;
    }
    else
    {
        Trace(3,"Unable to find a segment state at time %ld\n",mtTime);
        hr  = DMUS_E_NOT_FOUND;
    }
    LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);
    LEAVE_API_CRITICAL_SECTION;
    return hr;
}

/*
  @method HRESULT | IDirectMusicPerformance | SetPrepareTime |
  Sets the prepare time. The prepare time is the amount of time ahead that
  <om IDirectMusicTrack.Play> is called before the messages should actually
  be heard through the loudspeaker. The midi messages from the tracks are placed in
  the early queue, are processed by Tools, and then placed in the near-time
  queue to await being sent to the midi ports.

  @rvalue S_OK | Success.
  @comm The default value is 1000 milliseconds.
*/
HRESULT STDMETHODCALLTYPE CPerformance::SetPrepareTime( 
    DWORD dwMilliSeconds) // @parm The amount of time.
{
    m_dwPrepareTime = dwMilliSeconds;
    return S_OK;
}

/*
  @method HRESULT | IDirectMusicPerformance | GetPrepareTime |
  Gets the prepare time. The prepare time is the amount of time ahead that
  <om IDirectMusicTrack.Play> is called before the messages should actually
  be heard through the loudspeaker. The midi messages from the tracks are placed in
  the early queue, are processed by Tools, and then placed in the near-time
  queue to await being sent to the midi ports.

  @rvalue S_OK | Success.
  @rvalue E_POINTER | pdwMilliSeconds is NULL or invalid.
  @comm The default value is 1000 milliseconds.
*/
HRESULT STDMETHODCALLTYPE CPerformance::GetPrepareTime( 
    DWORD* pdwMilliSeconds) // @parm The amount of time.
{
    V_INAME(IDirectMusicPerformance::GetPrepareTime);
    V_PTR_WRITE(pdwMilliSeconds,DWORD);

    *pdwMilliSeconds = m_dwPrepareTime;
    return S_OK; 
}

/*
  @method HRESULT | IDirectMusicPerformance | SetBumperLength |
  Sets the bumper length. The bumper length is the amount of time to buffer ahead
  of the Port's latency for midi messages to be sent to the Port for rendering.

  @rvalue S_OK | Success.
  @comm The default value is 50 milliseconds.
*/
HRESULT STDMETHODCALLTYPE CPerformance::SetBumperLength( 
    DWORD dwMilliSeconds)   // @parm The amount of time.
{
    m_dwBumperLength = dwMilliSeconds; 
    m_rtBumperLength = m_dwBumperLength * REF_PER_MIL;
    return S_OK;
}

/*
  @method HRESULT | IDirectMusicPerformance | GetBumperLength |
  Gets the bumper length. The bumper length is the amount of time to buffer ahead
  of the Port's latency for midi messages to be sent to the Port for rendering.

  @rvalue S_OK | Success.
  @rvalue E_POINTER | pdwMilliSeconds is NULL or invalid.
  @comm The default value is 50 milliseconds.
*/
HRESULT STDMETHODCALLTYPE CPerformance::GetBumperLength( 
    DWORD* pdwMilliSeconds) // @parm The amount of time.
{
    V_INAME(IDirectMusicPerformance::GetBumperLength);
    V_PTR_WRITE(pdwMilliSeconds,DWORD);

    *pdwMilliSeconds = m_dwBumperLength;
    return S_OK;
}

#define RESOLVE_FLAGS (DMUS_TIME_RESOLVE_AFTERPREPARETIME | \
                       DMUS_TIME_RESOLVE_AFTERLATENCYTIME | \
                       DMUS_TIME_RESOLVE_AFTERQUEUETIME | \
                       DMUS_TIME_RESOLVE_BEAT | \
                       DMUS_TIME_RESOLVE_MEASURE | \
                       DMUS_TIME_RESOLVE_GRID | \
                       DMUS_TIME_RESOLVE_MARKER | \
                       DMUS_TIME_RESOLVE_SEGMENTEND)


HRESULT STDMETHODCALLTYPE CPerformance::SendPMsg( 
    DMUS_PMSG *pDMUS_PMSG)  

{
    V_INAME(IDirectMusicPerformance::SendPMsg);
#ifdef DXAPI
    if( m_dwVersion < 8)
    {
        V_BUFPTR_WRITE(pDMUS_PMSG,sizeof(DMUS_PMSG));
    }
    else
    {
#ifdef DBG
        V_BUFPTR_WRITE(pDMUS_PMSG,sizeof(DMUS_PMSG));
#else
        if (!pDMUS_PMSG)
        {
            return E_POINTER;
        }
#endif
    }
#else
    V_BUFPTR_WRITE(pDMUS_PMSG,sizeof(DMUS_PMSG));
#endif

    ENTER_CRITICAL_SECTION(&m_MainCrSec);
    if( m_pClock == NULL )
    {
        LEAVE_CRITICAL_SECTION(&m_MainCrSec);
        Trace(0,"Error: Unable to Send PMsg because performance not initialized.\n");
        return DMUS_E_NO_MASTER_CLOCK;
    }
    LEAVE_CRITICAL_SECTION(&m_MainCrSec);

    if (pDMUS_PMSG->dwSize < sizeof(DMUS_PMSG))
    {
        TraceI(1,"Warning: PMsg size field has been cleared.\n");
    }

    // If this is a PMsg that was marked by STampPMsg as one that should be removed,
    // do so now. 
    if (pDMUS_PMSG->dwPChannel == DMUS_PCHANNEL_KILL_ME)
    {
        FreePMsg(pDMUS_PMSG);
        return S_OK;
    }

    ENTER_CRITICAL_SECTION(&m_PipelineCrSec);
    ENTER_API_CRITICAL_SECTION;
    PRIV_PMSG* pPrivPMsg = DMUS_TO_PRIV(pDMUS_PMSG);
    if( ( pPrivPMsg->dwPrivFlags & PRIV_FLAG_QUEUED ) ||
        ( ( pPrivPMsg->dwPrivFlags & PRIV_FLAG_ALLOC_MASK ) != PRIV_FLAG_ALLOC ) )
    {
        Trace(1, "Error: Attempt to send an improperly allocated PMsg, or trying to send it after it is already sent.\n" );
        LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);
        LEAVE_API_CRITICAL_SECTION;
        return DMUS_E_ALREADY_SENT;
    }
#ifdef DXAPI
    if (m_dwVersion >= 8)
#endif
    {
        // If the music and ref times are both 0, set to latency time.
        if ((pDMUS_PMSG->mtTime == 0) && ( pDMUS_PMSG->rtTime == 0 ))
        {
            // If this needs to resolve, use the worse case latency
            // because this needs to sync with other pmsgs. 
            if (pDMUS_PMSG->dwFlags & RESOLVE_FLAGS)
            {
                GetLatencyTime(&pDMUS_PMSG->rtTime);
            }
            else
            {
                // Otherwise, we want to play as soon as possible. 
                pDMUS_PMSG->rtTime = GetTime();
            }
            pDMUS_PMSG->dwFlags |= DMUS_PMSGF_REFTIME;
            pDMUS_PMSG->dwFlags &= ~DMUS_PMSGF_MUSICTIME;
        }
    }

    // fill in missing time value
    if (!(pDMUS_PMSG->dwFlags & DMUS_PMSGF_MUSICTIME))
    {
        if( !(pDMUS_PMSG->dwFlags & DMUS_PMSGF_REFTIME ) )
        {
            LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);
            LEAVE_API_CRITICAL_SECTION;
            Trace(1,"Error: Unable to send PMsg because neither clock time (DMUS_PMSGF_REFTIME) nor music time (DMUS_PMSGF_MUSICTIME) has been set.\n");
            return E_INVALIDARG; // one or the other MUST be set
        }
        // quantize to resolution boundaries
        GetResolvedTime( pDMUS_PMSG->rtTime, &pDMUS_PMSG->rtTime, pDMUS_PMSG->dwFlags );
        pDMUS_PMSG->dwFlags &= ~RESOLVE_FLAGS;
        // if time is zero, set it to time now plus latency
        if( pDMUS_PMSG->rtTime == 0 )
        {
            pDMUS_PMSG->rtTime = GetLatency();
        }
        ReferenceToMusicTime(pDMUS_PMSG->rtTime,
            &pDMUS_PMSG->mtTime);
        pDMUS_PMSG->dwFlags |= DMUS_PMSGF_MUSICTIME;
    }
    else if (!(pDMUS_PMSG->dwFlags & DMUS_PMSGF_REFTIME))
    {
        MusicToReferenceTime(pDMUS_PMSG->mtTime,
            &pDMUS_PMSG->rtTime);
        pDMUS_PMSG->dwFlags |= DMUS_PMSGF_REFTIME;
        // quantize to resolution boundaries
        REFERENCE_TIME rtNew;
        GetResolvedTime( pDMUS_PMSG->rtTime, &rtNew, pDMUS_PMSG->dwFlags );
        pDMUS_PMSG->dwFlags &= ~RESOLVE_FLAGS;
        if( rtNew != pDMUS_PMSG->rtTime )
        {
            pDMUS_PMSG->rtTime = rtNew;
            ReferenceToMusicTime( pDMUS_PMSG->rtTime, &pDMUS_PMSG->mtTime );
        }
    }

    // insert into the proper queue by music value
    if (pDMUS_PMSG->dwFlags & DMUS_PMSGF_TOOL_QUEUE)
    {
        m_NearTimeQueue.Enqueue(pPrivPMsg);
    }
    else if (pDMUS_PMSG->dwFlags & DMUS_PMSGF_TOOL_ATTIME)
    {
        m_OnTimeQueue.Enqueue(pPrivPMsg);
    }
    else // (pDMUS_PMSG->dwFlags & DMUS_PMSGF_TOOL_IMMEDIATE)
    {
        pDMUS_PMSG->dwFlags |= DMUS_PMSGF_TOOL_IMMEDIATE;
        m_EarlyQueue.Enqueue(pPrivPMsg);
    }
    LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);
    LEAVE_API_CRITICAL_SECTION;
    return S_OK;
}

/*

  Call this only from within a PipelineCrSec.
*/
void CPerformance::RevalidateRefTimes( CPMsgQueue * pList, MUSIC_TIME mtTime )
{
    PRIV_PMSG* pCheck;
    BOOL fError = FALSE;
    for( pCheck = pList->GetHead(); pCheck; pCheck = pCheck->pNext )
    {
        if (pCheck->mtTime > mtTime)
        {
            if (pCheck->dwFlags & DMUS_PMSGF_LOCKTOREFTIME)
            {
                ReferenceToMusicTime(pCheck->rtTime,&pCheck->mtTime);
            }
            else // if(pCheck->dwFlags & DMUS_PMSGF_MUSICTIME)
            {
                MusicToReferenceTime(pCheck->mtTime,&pCheck->rtTime);
            }
        }
    }
    // Make sure that we do not end up with out of order RTimes. This can happen with
    // DMUS_PMSGF_LOCKTOREFTIME messages or very abrupt changes in tempo.
    for( pCheck = pList->GetHead(); pCheck; pCheck = pCheck->pNext )
    {
        if (pCheck->pNext && ( pCheck->rtTime > pCheck->pNext->rtTime ))
        {
            fError = TRUE;  // Need to sort the list.
        }
    }
    if (fError)
    {
        TraceI(2,"Rearrangement of times in message list due to tempo change, resorting\n");
        pList->Sort();
    }
}

void CPerformance::AddToTempoMap( double dblTempo, MUSIC_TIME mtTime, REFERENCE_TIME rtTime )
{
    DMInternalTempo* pITempo = NULL;
    // The following shouldn't be necessary, so it would be nice to remove this eventually.
    // For some reason, duplicate tempos are being entered under some circumstances.
    // These can eat up a lot of memory. 
    // So, ignore is this was already called with the same time and tempo.
    if (dblTempo == m_dblLastTempo && mtTime == m_mtLastTempoTime)
    {
        return;
    }
    m_dblLastTempo = dblTempo;
    m_mtLastTempoTime = mtTime;
    if( FAILED( AllocPMsg( sizeof(DMInternalTempo), (PRIV_PMSG**)&pITempo )))
    {
        return; // out of memory!
    }
    if( dblTempo > DMUS_TEMPO_MAX ) dblTempo = DMUS_TEMPO_MAX;
    else if( dblTempo < DMUS_TEMPO_MIN ) dblTempo = DMUS_TEMPO_MIN;
    pITempo->tempoPMsg.dblTempo = dblTempo;
    pITempo->tempoPMsg.rtTime = rtTime;
    pITempo->tempoPMsg.mtTime = mtTime;
    pITempo->tempoPMsg.dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_REFTIME;
    pITempo->pNext = NULL;
    // set the relative tempo field
    ENTER_CRITICAL_SECTION(&m_GlobalDataCrSec);
    pITempo->fltRelTempo = m_fltRelTempo;
    // add the tempo event to the tempo map and clear the tool and graph pointers
    pITempo->tempoPMsg.pTool = NULL;
    ENTER_CRITICAL_SECTION(&m_PipelineCrSec);
    // remove stale tempo events from the tempo map.
    // as long as there is another tempo with a time stamp before the current
    // time, get rid of the first in the list.
    REFERENCE_TIME rtNow = GetTime() - (10000 * 1000); // keep around for a second.
    PRIV_PMSG* pCheck;
    while (pCheck = m_TempoMap.FlushOldest(rtNow))
    {
        m_OldTempoMap.Enqueue(pCheck);
    }
    // add the new tempo event to the queue
    m_TempoMap.Enqueue( (PRIV_PMSG*) pITempo );
    // now that it's been added, scan forward from it and change the relative tempo
    // times of everyone after it
    DMInternalTempo* pChange;
    for( pChange = (DMInternalTempo*)pITempo->pNext; pChange; 
        pChange = (DMInternalTempo*)pChange->pNext )
    {
        pChange->fltRelTempo = pITempo->fltRelTempo;
    }
    // remove stale tempo events from the old tempo map.
    // as long as there is another tempo with a time stamp before the current
    // time, get rid of the first in the list.
    rtNow = GetTime() - ((REFERENCE_TIME)10000 * 60 * 1000); // keep around for one minute.
    while (pCheck = m_OldTempoMap.FlushOldest(rtNow))
    {
        FreePMsg(pCheck);
    }
    m_fTempoChanged = TRUE;
    LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);
    LEAVE_CRITICAL_SECTION(&m_GlobalDataCrSec);
}

void CPerformance::AddEventToTempoMap( PRIV_PMSG* pEvent )
{
    PRIV_TEMPO_PMSG* pTempo = (PRIV_TEMPO_PMSG*)pEvent;
    MUSIC_TIME mtTime = pTempo->tempoPMsg.mtTime;
    AddToTempoMap( pTempo->tempoPMsg.dblTempo, mtTime, pTempo->tempoPMsg.rtTime );
    pEvent->dwPrivFlags = PRIV_FLAG_ALLOC;
    ENTER_CRITICAL_SECTION(&m_GlobalDataCrSec);
    ENTER_CRITICAL_SECTION(&m_PipelineCrSec);
    // revalidate the ref times of the events in the queues
    RevalidateRefTimes( &m_TempoMap, mtTime );
    RevalidateRefTimes( &m_OnTimeQueue, mtTime );
    RevalidateRefTimes( &m_NearTimeQueue, mtTime );
    RevalidateRefTimes( &m_EarlyQueue, mtTime );
    m_fTempoChanged = TRUE;
    LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);
    LEAVE_CRITICAL_SECTION(&m_GlobalDataCrSec);
    RecalcTempoMap(NULL,mtTime+1);
}

#define TEMPO_AHEAD 768 * 4 * 10    // 10 measures ahead is plenty!

void CPerformance::IncrementTempoMap()

{
    if (m_mtTempoCursor <= (m_mtTransported + TEMPO_AHEAD))
    {
        UpdateTempoMap(m_mtTempoCursor, false, NULL);
    }
}

void CPerformance::RecalcTempoMap(CSegState *pSegState, MUSIC_TIME mtStart, bool fAllDeltas)

/*  Called whenever a primary or controlling segment that has a tempo
    track is played or stopped.
    1) Convert the music time at transport time to ref time using the old
    map.  
    2) Build a replacement tempo map starting at mtStart, by
    calling GetParam() until there is no next time. 
    3) Install the new map.
    4) Convert with the new map.
    5) If the two numbers are not identical, recalculate all message times.
*/

{
    if( mtStart > 0) // Don't do this for invalid values.
    {
        if (!pSegState || (pSegState->m_pSegment && pSegState->m_pSegment->IsTempoSource()))
        { 
            REFERENCE_TIME rtCompareTime;
            REFERENCE_TIME rtAfterTime;
            MUSIC_TIME mtCompareTime = m_mtTransported;
            MusicToReferenceTime(mtCompareTime,&rtCompareTime);
            ENTER_CRITICAL_SECTION(&m_PipelineCrSec);
            FlushEventQueue( 0, &m_TempoMap, rtCompareTime, rtCompareTime, 0 );
            LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);
            UpdateTempoMap(mtStart, true, pSegState, fAllDeltas);
            MusicToReferenceTime(mtCompareTime,&rtAfterTime);
            if (rtAfterTime != rtCompareTime)
            {
                ENTER_CRITICAL_SECTION(&m_GlobalDataCrSec);
                ENTER_CRITICAL_SECTION(&m_PipelineCrSec);
                // revalidate the ref times of the events in the queues
                RevalidateRefTimes( &m_TempoMap, mtStart );
                RevalidateRefTimes( &m_OnTimeQueue, mtStart );
                RevalidateRefTimes( &m_NearTimeQueue, mtStart );
                RevalidateRefTimes( &m_EarlyQueue, mtStart );
                m_fTempoChanged = TRUE;
                LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);
                LEAVE_CRITICAL_SECTION(&m_GlobalDataCrSec);
            }
        }
    }
}
                
void CPerformance::UpdateTempoMap(MUSIC_TIME mtStart, bool fFirst, CSegState *pSegState, bool fAllDeltas)

{
    HRESULT hr = S_OK;
    DWORD dwIndex = 0;
    PrivateTempo Tempo;
    TList<PrivateTempo> TempoList;
    TListItem<PrivateTempo>* pScan = NULL;
    MUSIC_TIME mtNext = 0;
    MUSIC_TIME mtTime = mtStart;
    MUSIC_TIME mtCursor = mtStart;
    REFERENCE_TIME rtTime;
    do
    {
        hr = GetParam(GUID_PrivateTempoParam,-1,dwIndex,mtTime,&mtNext,(void *)&Tempo );
        Tempo.mtTime = mtTime;
        if (hr == S_OK && Tempo.mtDelta > 0)
        {
            mtTime += Tempo.mtDelta;
            hr = GetParam(GUID_PrivateTempoParam,-1,dwIndex,mtTime,&mtNext,(void *)&Tempo );
            Tempo.mtTime = mtTime;
        }
        if (hr == S_FALSE && fFirst && !pSegState)
        {
            // If this was the very first try, there might not be any tempo track, and
            // so global tempo is called. If so, S_FALSE is returned. This is okay
            // for the NULL segstate case where we are recomputing the tempo map in response 
            // to a change in global tempo, or stop of all segments.
            if (fAllDeltas) // Never do this in response to adding a new event to the tempo map
            {
                MusicToReferenceTime(mtTime,&rtTime);
                // the rtTime in the tempo map needs to be the non-adjusted value (305694)
                AddToTempoMap( Tempo.dblTempo, mtTime, rtTime + m_rtAdjust );
            }
            break;
        }
        if (hr == S_OK)
        {
            TListItem<PrivateTempo>* pNew = new TListItem<PrivateTempo>(Tempo);
            if (pNew)
            {
                // add to TempoList, replacing duplicate times with the most recent mtDelta
                TListItem<PrivateTempo>* pNext = TempoList.GetHead();
                if (!pNext || Tempo.mtTime < pNext->GetItemValue().mtTime)
                {
                    TempoList.AddHead(pNew);
                }
                else for (pScan = TempoList.GetHead(); pScan; pScan = pNext)
                {
                    pNext = pScan->GetNext();
                    if (Tempo.mtTime == pScan->GetItemValue().mtTime)
                    {
                        if (Tempo.mtDelta > pScan->GetItemValue().mtDelta)
                        {
                            pScan->GetItemValue() = Tempo;
                        }
                        delete pNew;
                        break;
                    }
                    else if (!pNext || Tempo.mtTime < pNext->GetItemValue().mtTime)
                    {
                        pScan->SetNext(pNew);
                        pNew->SetNext(pNext);
                        break;
                    }
                }
            }
            mtTime += mtNext;
            fFirst = false;
            // If this was the last tempo in the track (that we care about),
            // reset the time and bump the track index
            if (Tempo.fLast || mtTime > (m_mtTransported + TEMPO_AHEAD))
            {
                dwIndex++;
                mtCursor = mtTime;
                mtTime = mtStart;
            }
            else if (!mtNext) break; // should never happen but if it does, infinite loop
        }
        else if (Tempo.fLast) // There was an empty tempo track
        {
            dwIndex++;
            hr = S_OK;
        }
        Tempo.fLast = false;
    } while (hr == S_OK);
    if (TempoList.GetHead() && TempoList.GetHead()->GetItemValue().mtTime > mtStart)
    {
        // add a tempo of 120 at time mtStart
        TListItem<PrivateTempo>* pNew = new TListItem<PrivateTempo>();
        if (pNew)
        {
            PrivateTempo& rNew = pNew->GetItemValue();
            rNew.dblTempo = 120.0;
            rNew.mtTime = mtStart;
            TempoList.AddHead(pNew);
        }
        else
        {
#ifdef DBG
            Trace(1, "Error: Out of memory; Tempo map is incomplete.\n");
#endif
            TempoList.GetHead()->GetItemValue().mtTime = mtStart;
        }
    }
    for (pScan = TempoList.GetHead(); pScan; pScan = pScan->GetNext())
    {
        PrivateTempo& rTempo = pScan->GetItemValue();
        if (fAllDeltas || rTempo.mtTime + rTempo.mtDelta >= mtStart)
        {
            MusicToReferenceTime(rTempo.mtTime,&rtTime);
            // the rtTime in the tempo map needs to be the non-adjusted value (305694)
            AddToTempoMap( rTempo.dblTempo, rTempo.mtTime, rtTime + m_rtAdjust );
        }
    }
    m_mtTempoCursor = mtCursor;
}
                
HRESULT STDMETHODCALLTYPE CPerformance::MusicToReferenceTime( 
    MUSIC_TIME mtTime,          // @parm The time in MUSIC_TIME format to convert.
    REFERENCE_TIME *prtTime)    // @parm Returns the converted time in REFERENCE_TIME format.
{
    V_INAME(IDirectMusicPerformance::MusicToReferenceTime);
    V_PTR_WRITE(prtTime,REFERENCE_TIME);

    ENTER_CRITICAL_SECTION(&m_MainCrSec);
    if( m_pClock == NULL )
    {
        LEAVE_CRITICAL_SECTION(&m_MainCrSec);
        Trace(0,"Error: Unable to convert music to reference time because the performance has not been initialized.\n");
        return DMUS_E_NO_MASTER_CLOCK;
    }
    LEAVE_CRITICAL_SECTION(&m_MainCrSec);

    PRIV_PMSG*  pEvent;
    double dbl = 120;
    MUSIC_TIME mtTempo = 0;
    REFERENCE_TIME rtTempo = m_rtStart;
    REFERENCE_TIME rtTemp;

    ENTER_CRITICAL_SECTION( &m_PipelineCrSec );
    ENTER_API_CRITICAL_SECTION;
    pEvent = m_TempoMap.GetHead();
    if( pEvent )
    {
        if( mtTime >= pEvent->mtTime )
        {
            while( pEvent->pNext )
            {
                if( pEvent->pNext->mtTime > mtTime )
                {
                    break;
                }
                pEvent = pEvent->pNext;
            }
            DMInternalTempo* pTempo = (DMInternalTempo*)pEvent;
            dbl = pTempo->tempoPMsg.dblTempo * pTempo->fltRelTempo;
            mtTempo = pTempo->tempoPMsg.mtTime;
            rtTempo = pTempo->tempoPMsg.rtTime;
        }
        else
        {
            // If mtTime is less than everything in the tempo map, look in the old tempo map 
            // (which goes one minute into the past).  This keeps the regular tempo map
            // small, but allows us to get a valid tempo in the cases where the regular tempo
            // map no longer contains the tempo we need.
            pEvent = m_OldTempoMap.GetHead();
            if( pEvent )
            {
                if( mtTime >= pEvent->mtTime )
                {
                    while( pEvent->pNext )
                    {
                        if( pEvent->pNext->mtTime > mtTime )
                        {
                            break;
                        }
                        pEvent = pEvent->pNext;
                    }
                    DMInternalTempo* pTempo = (DMInternalTempo*)pEvent;
                    dbl = pTempo->tempoPMsg.dblTempo * pTempo->fltRelTempo;
                    mtTempo = pTempo->tempoPMsg.mtTime;
                    rtTempo = pTempo->tempoPMsg.rtTime;
                }
            }
        }
    }
    LEAVE_CRITICAL_SECTION( &m_PipelineCrSec );
    LEAVE_API_CRITICAL_SECTION;
    rtTempo -= m_rtAdjust;
    rtTemp = ( mtTime - mtTempo );
    rtTemp *= 600000000;
    rtTemp += (DMUS_PPQ / 2);
    rtTemp /= DMUS_PPQ;
    rtTemp = (REFERENCE_TIME)(rtTemp / dbl);
    *prtTime = rtTempo + rtTemp;
    return S_OK;
}


HRESULT STDMETHODCALLTYPE CPerformance::ReferenceToMusicTime( 
    REFERENCE_TIME rtTime,  // @parm The time in REFERENCE_TIME format to convert.
    MUSIC_TIME *pmtTime)    // @parm Returns the converted time in MUSIC_TIME format.
{
    V_INAME(IDirectMusicPerformance::ReferenceToMusicTime);
    V_PTR_WRITE(pmtTime,MUSIC_TIME);

    ENTER_CRITICAL_SECTION(&m_MainCrSec);
    if( m_pClock == NULL )
    {
        LEAVE_CRITICAL_SECTION(&m_MainCrSec);
        Trace(0,"Error: Unable to convert reference to music time because the performance has not been initialized.\n");
        return DMUS_E_NO_MASTER_CLOCK;
    }
    LEAVE_CRITICAL_SECTION(&m_MainCrSec);

    PRIV_PMSG*  pEvent;
    double dbl = 120;
    MUSIC_TIME mtTempo = 0;
    REFERENCE_TIME rtTempo = m_rtStart;

    ENTER_CRITICAL_SECTION( &m_PipelineCrSec );
    ENTER_API_CRITICAL_SECTION;
    pEvent = m_TempoMap.GetHead();
    if( pEvent )
    {
        if( rtTime >= pEvent->rtTime )
        {
            while( pEvent->pNext )
            {
                if( pEvent->pNext->rtTime > rtTime )
                {
                    break;
                }
                pEvent = pEvent->pNext;
            }
            DMInternalTempo* pTempo = (DMInternalTempo*)pEvent;
            dbl = pTempo->tempoPMsg.dblTempo * pTempo->fltRelTempo;
            mtTempo = pTempo->tempoPMsg.mtTime;
            rtTempo = pTempo->tempoPMsg.rtTime;
        }
        else
        {
            // If mtTime is less than everything in the tempo map, look in the old tempo map 
            // (which goes one minute into the past).  This keeps the regular tempo map
            // small, but allows us to get a valid tempo in the cases where the regular tempo
            // map no longer contains the tempo we need.
            pEvent = m_OldTempoMap.GetHead();
            if( pEvent )
            {
                if( rtTime >= pEvent->rtTime )
                {
                    while( pEvent->pNext )
                    {
                        if( pEvent->pNext->rtTime > rtTime )
                        {
                            break;
                        }
                        pEvent = pEvent->pNext;
                    }
                    DMInternalTempo* pTempo = (DMInternalTempo*)pEvent;
                    dbl = pTempo->tempoPMsg.dblTempo * pTempo->fltRelTempo;
                    mtTempo = pTempo->tempoPMsg.mtTime;
                    rtTempo = pTempo->tempoPMsg.rtTime;
                }
            }
        }
    }
    LEAVE_CRITICAL_SECTION( &m_PipelineCrSec );
    LEAVE_API_CRITICAL_SECTION;
    rtTempo -= m_rtAdjust;
    if( rtTime < rtTempo )
    {
        rtTime = rtTempo;
    }
    rtTime -= rtTempo;
    rtTime *= DMUS_PPQ;
    rtTime = (REFERENCE_TIME)(rtTime * dbl);
    rtTime += 300000000;
    rtTime /= 600000000;
    if ( rtTime & 0xFFFFFFFF00000000 )
    {
        Trace(3,"Warning: Reference to Music time conversion with very large ref time resulted in max music time.\n");
        rtTime = 0x7FFFFFFF; // Set to max.
    }
    *pmtTime = (long) (rtTime & 0xFFFFFFFF);
    *pmtTime += mtTempo;
    return S_OK;
}

/*
  @method HRESULT | IDirectMusicPerformance | AdjustTime |
  Adjust the internal Performance time forward or backward. This is mostly used to
  compensate for drift when synchronizing to another source, such as SMPTE.

  @rvalue S_OK | Success.
  @rvalue E_INVALIDARG | rtAmount is too large or too small.
*/
HRESULT STDMETHODCALLTYPE CPerformance::AdjustTime(
    REFERENCE_TIME rtAmount)    // @parm The amount of time to adjust. This may be a
                                // number from -10000000 to 10000000 (-1 second to +1 second.)
{
    if( ( rtAmount < -10000000 ) || ( rtAmount > 10000000 ) )
    {
        Trace(1,"Error: Time parameter passed to AdjustTime() is out of range.\n"); 
        return E_INVALIDARG;
    }
    m_rtAdjust += rtAmount;
    return S_OK;
}

/*
  @method HRESULT | IDirectMusicPerformance | GetResolvedTime |
  Quantize a time to a resolution boundary. Given a time, in REFERENCE_TIME,
  return the next time on a given boundary after the time given.

  @rvalue S_OK | Success.
  @rvalue E_POINTER <prtResolved> is not valid.
*/
HRESULT STDMETHODCALLTYPE CPerformance::GetResolvedTime(
    REFERENCE_TIME rtTime,
    REFERENCE_TIME* prtResolved,
    DWORD dwResolvedTimeFlags)
{
    V_INAME(IDirectMusicPerformance::GetResolvedTime);
    V_PTR_WRITE(prtResolved,REFERENCE_TIME);

    if (rtTime == 0)
    {
        dwResolvedTimeFlags |= DMUS_TIME_RESOLVE_AFTERQUEUETIME ;
    }
    if( dwResolvedTimeFlags & DMUS_TIME_RESOLVE_AFTERPREPARETIME )
    {
        REFERENCE_TIME rtTrans;
        MusicToReferenceTime( m_mtTransported, &rtTrans );
        if( rtTime < rtTrans ) rtTime = rtTrans;
    }
    else if (dwResolvedTimeFlags & DMUS_TIME_RESOLVE_AFTERLATENCYTIME )
    {
        REFERENCE_TIME rtStart;
        rtStart = GetLatency();
        if( rtTime < rtStart ) rtTime = rtStart;
    }  
    else if( dwResolvedTimeFlags & DMUS_TIME_RESOLVE_AFTERQUEUETIME )
    {
        REFERENCE_TIME rtStart;
        GetQueueTime( &rtStart ); // need queue time because control segments cause invalidations
        if( rtTime < rtStart ) rtTime = rtStart;
    }
    

    if( dwResolvedTimeFlags & ( DMUS_TIME_RESOLVE_BEAT | DMUS_TIME_RESOLVE_MEASURE |
        DMUS_TIME_RESOLVE_GRID | DMUS_TIME_RESOLVE_MARKER | DMUS_TIME_RESOLVE_SEGMENTEND))
    {
        MUSIC_TIME mtTime; //, mtResolved;

        ReferenceToMusicTime( rtTime, &mtTime );
        ENTER_CRITICAL_SECTION(&m_SegmentCrSec);
        mtTime = ResolveTime( mtTime, dwResolvedTimeFlags, NULL);
        LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);
        MusicToReferenceTime( mtTime, prtResolved );
    }
    else
    {
        *prtResolved = rtTime;
    }
    return S_OK;
}


/*
  @method HRESULT | IDirectMusicPerformance | IsPlaying |
  Find out if a particular Segment or SegmentState is currently playing.

  @rvalue E_POINTER | Both pSegment and pSegState are null, or one or both are invalid.
  @rvalue DMUS_E_NO_MASTER_CLOCK | There is no master clock in the performance.
  Make sure to call <om .Init> before calling this method.
  @rvalue S_OK | Yes, it is playing.
  @rvalue S_FALSE | No, it is not playing.
*/
HRESULT STDMETHODCALLTYPE CPerformance::IsPlaying( 
    IDirectMusicSegment *pSegment,          // @parm The Segment to check. If NULL, check
                                            // <p pSegState>.
    IDirectMusicSegmentState *pSegState)    // @parm The SegmentState to check. If NULL,
                                            // check <p pSegment>.
{
    CSegState* pNode;
    DWORD dwCount;

    V_INAME(IDirectMusicPerformance::IsPlaying);
    V_INTERFACE_OPT(pSegment);
    V_INTERFACE_OPT(pSegState);

    ENTER_CRITICAL_SECTION(&m_MainCrSec);
    if( m_pClock == NULL )
    {
        LEAVE_CRITICAL_SECTION(&m_MainCrSec);
        Trace(0,"Error: IsPlaying() failed because the performance has not been initialized.\n");
        return DMUS_E_NO_MASTER_CLOCK;
    }
    LEAVE_CRITICAL_SECTION(&m_MainCrSec);

    if( !pSegment && !pSegState )
    {
        Trace(0,"Error: IsPlaying() failed because segment and segment state are both NULL pointers.\n");
        return E_POINTER;
    }

    MUSIC_TIME mtNow;
    GetTime(NULL, &mtNow);
    ENTER_CRITICAL_SECTION(&m_SegmentCrSec);
    ENTER_API_CRITICAL_SECTION;
    for( dwCount = 0; dwCount < SQ_COUNT; dwCount++ )
    {
        for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext() )
        {
            if( !pNode->m_fStartedPlay )
            {
                continue;
            }
            if( mtNow >= pNode->m_mtResolvedStart )
            {
                if( mtNow < pNode->m_mtLastPlayed )
                {
                    if(( pNode == (CSegState*) pSegState ) || 
                        ( pNode->m_pSegment == (CSegment *) pSegment ))
                    {
                        LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);
                        LEAVE_API_CRITICAL_SECTION;
                        return S_OK;
                    }
                }
            }
            else
            {
                // if mtNow is before this pSegState's resolved start, it is before every
                // pSegState after this too, so break now.
                break;
            }
        }
    }
    LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);
    LEAVE_API_CRITICAL_SECTION;
    return S_FALSE;
}


HRESULT STDMETHODCALLTYPE CPerformance::GetTime(
        REFERENCE_TIME *prtNow, // @parm Returns the current time in REFERENCE_TIME
                                            // format. May be NULL.
        MUSIC_TIME  *pmtNow)    // @parm Returns the current time in MUSIC_TIME
                                            // format. May be NULL.
{
    V_INAME(IDirectMusicPerformance::GetTime);
    V_PTR_WRITE_OPT(prtNow,REFERENCE_TIME);
    V_PTR_WRITE_OPT(pmtNow,MUSIC_TIME);

    ENTER_CRITICAL_SECTION(&m_MainCrSec);
    if( m_pClock == NULL )
    {
        LEAVE_CRITICAL_SECTION(&m_MainCrSec);
        Trace(0,"Error: GetTime() failed because the performance has not been initialized.\n");
        return DMUS_E_NO_MASTER_CLOCK;
    }
    LEAVE_CRITICAL_SECTION(&m_MainCrSec);

    REFERENCE_TIME rtTime = GetTime();
    if( prtNow )
    {
        *prtNow = rtTime;
    }
    if( pmtNow )
    {
        MUSIC_TIME mtTime;
        ReferenceToMusicTime( rtTime, &mtTime );
        *pmtNow = mtTime;
    }
    return S_OK;
}


HRESULT STDMETHODCALLTYPE CPerformance::GetLatencyTime(
        REFERENCE_TIME *prtTime)    // @parm Returns the current latency time.
{
    V_INAME(IDirectMusicPerformance::GetLatencyTime);
    V_PTR_WRITE(prtTime,REFERENCE_TIME);

    ENTER_CRITICAL_SECTION(&m_MainCrSec);
    if( m_pClock == NULL )
    {
        LEAVE_CRITICAL_SECTION(&m_MainCrSec);
        Trace(0,"Error: GetLatencyTime() failed because the performance has not been initialized.\n");
        return DMUS_E_NO_MASTER_CLOCK;
    }
    LEAVE_CRITICAL_SECTION(&m_MainCrSec);

    *prtTime = GetLatency();
    return S_OK;
}


HRESULT STDMETHODCALLTYPE CPerformance::GetQueueTime(
        REFERENCE_TIME *prtTime)    // @parm Returns the current queue time.
{
    V_INAME(IDirectMusicPerformance::GetQueueTime);
    V_PTR_WRITE(prtTime,REFERENCE_TIME);

    ENTER_CRITICAL_SECTION(&m_MainCrSec);
    if( m_pClock == NULL )
    {
        LEAVE_CRITICAL_SECTION(&m_MainCrSec);
        Trace(0,"Error: GetQueueTime() failed because the performance has not been initialized.\n");
        return DMUS_E_NO_MASTER_CLOCK;
    }
    LEAVE_CRITICAL_SECTION(&m_MainCrSec);

    DWORD dw;
    REFERENCE_TIME rtLatency;

    *prtTime = 0;
#ifdef DXAPI
    ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);
    for( dw = 0; dw < m_dwNumPorts; dw++ )
    {
        if( m_pPortTable[dw].rtLast > *prtTime )
            *prtTime = m_pPortTable[dw].rtLast;
    }
    LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);
#else
    *prtTime = m_rtLastSendTime;
#endif
    rtLatency = GetLatency();
    if( *prtTime < rtLatency )
    {
        *prtTime = rtLatency;
    }
    if (m_rtEarliestStartTime > rtLatency)
    {
        rtLatency = m_rtEarliestStartTime;
    }
    return S_OK;
}

// private version of AllocPMsg
HRESULT CPerformance::AllocPMsg(
    ULONG cb,
    PRIV_PMSG** ppPMSG)
{
    ASSERT( cb >= sizeof(PRIV_PMSG) );
    DMUS_PMSG* pDMUS_PMSG;
    HRESULT hr;

    hr = AllocPMsg( cb - PRIV_PART_SIZE, &pDMUS_PMSG );
    if( SUCCEEDED(hr) )
    {
        *ppPMSG = DMUS_TO_PRIV(pDMUS_PMSG);
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE CPerformance::ClonePMsg(DMUS_PMSG* pSourcePMSG,DMUS_PMSG** ppCopyPMSG)
{
    V_INAME(IDirectMusicPerformance::ClonePMsg);
#ifdef DBG
    V_PTRPTR_WRITE(ppCopyPMSG);
    V_BUFPTR_READ(pSourcePMSG,sizeof(DMUS_PMSG));
#else
#ifdef DXAPI
    if (!ppCopyPMSG || !pSourcePMSG)
    { 
        return E_POINTER;
    }
#endif
#endif
    HRESULT hr = AllocPMsg(pSourcePMSG->dwSize,ppCopyPMSG);
    if (SUCCEEDED(hr))
    {
        memcpy(*ppCopyPMSG,pSourcePMSG,pSourcePMSG->dwSize);
        if (pSourcePMSG->punkUser)
        {
            pSourcePMSG->punkUser->AddRef();
        }
        if (pSourcePMSG->pTool)
        {
            pSourcePMSG->pTool->AddRef();
        }
        if (pSourcePMSG->pGraph)
        {
            pSourcePMSG->pGraph->AddRef();
        }
    }
    return hr;
}

#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
static __int64 g_llPMsgAllocCount; // Tracks how often we grab a Pmsg
static LONG g_dwPMsgCount;  // Total allocated
static LONG g_dwPMsgBytes;  // Number of bytes allocated
static LONG g_dwPMsgActive; // number of PMsgs that are active
static LONG g_dwPMsgCached; // Number of PMsgs that are in the cache

extern "C" void DMRegisterPMsgPerformanceCounters(){
    DMusicRegisterPerformanceCounter( "DM allocated PMSG bytes",
                              DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                              &g_dwPMsgBytes );
    DMusicRegisterPerformanceCounter( "DM allocated PMSG bytes",
                              DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                              &g_dwPMsgBytes );
    DMusicRegisterPerformanceCounter( "DM allocated PMSGs",
                              DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                              &g_dwPMsgCount );
    DMusicRegisterPerformanceCounter( "DM active PMSGs",
                              DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                              &g_dwPMsgActive );
    DMusicRegisterPerformanceCounter( "DM cached PMSGs",
                              DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                              &g_dwPMsgCached );
    DMusicRegisterPerformanceCounter( "DM allocation rate PMSGs",
                              DMCOUNT_FREQ100MS | DMCOUNT_EVENT  | DMCOUNT_ASYNC64,
                              &g_llPMsgAllocCount );
}

extern "C" void DMUnregisterPMsgPerformanceCounters(){
    DMusicUnregisterPerformanceCounter( "DM allocated PMSG bytes");
    DMusicUnregisterPerformanceCounter( "DM allocated PMSG bytes");
    DMusicUnregisterPerformanceCounter( "DM allocated PMSGs");
    DMusicUnregisterPerformanceCounter( "DM active PMSGs");
    DMusicUnregisterPerformanceCounter( "DM cached PMSGs");
    DMusicUnregisterPerformanceCounter( "DM allocation rate PMSGs");
}

#endif

//////////////////////////////////////////////////////////////////////
// CPerformance::AllocPMsg
/*
  @method HRESULT | IDirectMusicPerformance | AllocPMsg |
  Allocate a DMUS_PMSG. 

  @rvalue E_OUTOFMEMORY | Out of memory.
  @rvalue S_OK | Success.
  @rvalue E_INVALIDARG | <p cb> is smaller than sizeof(DMUS_PMSG)
  @rvalue E_POINTER | <p ppPMSG> is NULL or invalid.
*/
HRESULT STDMETHODCALLTYPE CPerformance::AllocPMsg(
    ULONG cb,               // @parm Size of the <p ppPMSG>. Must be equal to or greater
                            // than sizeof(DMUS_PMSG).
    DMUS_PMSG** ppPMSG  // @parm Returns the pointer to the allocated message, which will
                            // be of size <p cb>. All fields are initialized to zero, 
                            // except dwSize which is initialized to <p cb>.
    )
{
    V_INAME(IDirectMusicPerformance::AllocPMsg);
#ifdef DXAPI
    if( m_dwVersion < 8)
    {
        V_PTRPTR_WRITE(ppPMSG);
    }
    else
    {
#ifdef DBG
        V_PTRPTR_WRITE(ppPMSG);
#else
        if (!ppPMSG)
        {
            return E_POINTER;
        }
#endif
    }
#else
    V_PTRPTR_WRITE(ppPMSG);
#endif
    PRIV_PMSG* pPrivPMsg;

#ifdef DXAPI
    if( cb < sizeof(DMUS_PMSG) )
        return E_INVALIDARG;
#else
#ifdef DBG
    if( cb < sizeof(DMUS_PMSG) )
	    Trace(0,"cb is %d but must be at least size of %d\n", cb, sizeof(DMUS_PMSG));
    if ( cb > 1000)
        Trace(0,"Attempt to allocate PMSG of size %d is too large\n",cb);
#endif
#endif

    ENTER_CRITICAL_SECTION(&m_PMsgCacheCrSec);
    ENTER_API_CRITICAL_SECTION;

#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
    g_llPMsgAllocCount++;
#endif

    // cached pmsg's are stored in an array based on their public size.
    // If a cached pmsg exists, return it. Otherwise, make a new one.
    if( (cb >= PERF_PMSG_CB_MIN) && (cb < PERF_PMSG_CB_MAX) )
    {
        ULONG cbIndex = cb - PERF_PMSG_CB_MIN;
        if( m_apPMsgCache[ cbIndex ] )
        {
            pPrivPMsg = m_apPMsgCache[ cbIndex ];
            m_apPMsgCache[ cbIndex ] = pPrivPMsg->pNext;
            pPrivPMsg->pNext = NULL;
            if (pPrivPMsg->dwPrivFlags != PRIV_FLAG_FREE)
            {
                Trace(0,"Error - previously freed PMsg has been mangled.\n");
                LEAVE_CRITICAL_SECTION(&m_PMsgCacheCrSec);
                return E_FAIL;
            }
            pPrivPMsg->dwPrivFlags = PRIV_FLAG_ALLOC;
            if (m_fInTrackPlay) pPrivPMsg->dwPrivFlags |= PRIV_FLAG_TRACK;
            *ppPMSG = PRIV_TO_DMUS(pPrivPMsg);

#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
            g_dwPMsgCached--;
            g_dwPMsgActive++;
#endif

            LEAVE_CRITICAL_SECTION(&m_PMsgCacheCrSec);
            LEAVE_API_CRITICAL_SECTION;
            return S_OK;
        }
    }

    HRESULT hr = S_OK;
    // no cached pmsg exists. Return a new one.
    ULONG cbPriv = cb + PRIV_PART_SIZE;

#ifdef USE_PMSG_ZONE
    // Allocate cachable PMSGs out of a private zone to reduce fragmentation
    // This test has to match the one in CPerformance::FreePMsg
    if((cb >= PERF_PMSG_CB_MIN) && (cb < PERF_PMSG_CB_MAX))
    {
        pPrivPMsg = (PRIV_PMSG*) m_pPMsgZone->Alloc(cbPriv);
    }
    else {
        pPrivPMsg = (PRIV_PMSG*)(new char[cbPriv]);
    }

#else
    pPrivPMsg = (PRIV_PMSG*)(new char[cbPriv]);
#endif

#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
    g_dwPMsgCount++;
    g_dwPMsgBytes += cbPriv;
    g_dwPMsgActive++;
#endif

    if( pPrivPMsg )
    {
        memset( pPrivPMsg, 0, cbPriv );
        pPrivPMsg->dwSize = pPrivPMsg->dwPrivPubSize = cb; // size of public part only
        pPrivPMsg->dwPrivFlags = PRIV_FLAG_ALLOC;
        if (m_fInTrackPlay) pPrivPMsg->dwPrivFlags |= PRIV_FLAG_TRACK;
        *ppPMSG = PRIV_TO_DMUS(pPrivPMsg);
        hr = S_OK;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    LEAVE_CRITICAL_SECTION(&m_PMsgCacheCrSec);
    LEAVE_API_CRITICAL_SECTION;
    return hr;
}

// private version of FreePMsg
HRESULT CPerformance::FreePMsg(
    PRIV_PMSG* pPMSG)
{
    return FreePMsg( PRIV_TO_DMUS(pPMSG) );
}


HRESULT STDMETHODCALLTYPE CPerformance::FreePMsg(
    DMUS_PMSG*  pPMSG   // @parm The message to free. This message must have been allocated
                            // using <om .AllocPMsg>.
    )
{
    V_INAME(IDirectMusicPerformance::FreePMsg);
#ifdef DXAPI
    if( m_dwVersion < 8)
    {
        V_BUFPTR_WRITE(pPMSG,sizeof(DMUS_PMSG));
    }
    else
    {
#ifdef DBG
        V_BUFPTR_WRITE(pPMSG,sizeof(DMUS_PMSG));
#else
        if (!pPMSG)
        {
            return E_POINTER;
        }
#endif
    }
#else
    V_BUFPTR_WRITE(pPMSG,sizeof(DMUS_PMSG));
#endif

    PRIV_PMSG* pPrivPMsg = DMUS_TO_PRIV(pPMSG);

    if( (pPrivPMsg->dwPrivFlags & PRIV_FLAG_ALLOC_MASK) != PRIV_FLAG_ALLOC )
    {
        Trace(0, "Error --- Attempt to free a PMsg that is not allocated memory.\n");
        // this isn't a msg allocated by AllocPMsg.
        return DMUS_E_CANNOT_FREE;
    }
    if( pPrivPMsg->dwPrivFlags & PRIV_FLAG_QUEUED )
    {
        TraceI(1, "Attempt to free a PMsg that is currently in the Performance queue.\n");
        return DMUS_E_CANNOT_FREE;
    }

    ENTER_CRITICAL_SECTION(&m_PMsgCacheCrSec);
    ENTER_API_CRITICAL_SECTION;
    if( pPMSG->pTool )
    {
        pPMSG->pTool->Release();
    }
    if( pPMSG->pGraph )
    {
        pPMSG->pGraph->Release();
    }
    if( pPMSG->punkUser )
    {
        pPMSG->punkUser->Release();
    }

    ULONG cbSize = pPrivPMsg->dwPrivPubSize;
    if( (cbSize >= PERF_PMSG_CB_MIN) && (cbSize < PERF_PMSG_CB_MAX) )
    {
        memset( pPrivPMsg, 0, cbSize + PRIV_PART_SIZE );
        pPrivPMsg->dwPrivFlags = PRIV_FLAG_FREE; // Mark this as in the free queue.
        pPrivPMsg->dwSize = pPrivPMsg->dwPrivPubSize = cbSize;
        pPrivPMsg->pNext = m_apPMsgCache[ cbSize - PERF_PMSG_CB_MIN ];
        m_apPMsgCache[ cbSize - PERF_PMSG_CB_MIN ] = pPrivPMsg;
#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
        g_dwPMsgCached++;
#endif
    }
    else
    {
        delete [] pPrivPMsg;
#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
        g_dwPMsgBytes -= (cbSize + PRIV_PART_SIZE);
        g_dwPMsgCount--;
#endif
    }

#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
        g_dwPMsgActive--;
#endif

    LEAVE_CRITICAL_SECTION(&m_PMsgCacheCrSec);
    LEAVE_API_CRITICAL_SECTION;
    return S_OK;
}

HRESULT CPerformance::FlushVirtualTrack(
    DWORD       dwId,
    MUSIC_TIME  mtTime,
    DWORD dwFlushFlags)
{
    ENTER_CRITICAL_SECTION(&m_PipelineCrSec);
    FlushMainEventQueues( dwId, mtTime, mtTime, dwFlushFlags );
    LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);
    return S_OK;
}

/*
  Given a time, mtTime, returns the time of the next control segment in pmtNextSeg.
  Returns S_FALSE if none found, and sets pmtNextSeg to zero.
*/

HRESULT CPerformance::GetControlSegTime(
    MUSIC_TIME mtTime, 
    MUSIC_TIME* pmtNextSeg)
{
    HRESULT hr = S_FALSE;
    *pmtNextSeg = 0;
    ENTER_CRITICAL_SECTION( &m_SegmentCrSec );
    // search the secondary lists for a control segment
    CSegState* pTemp;
    for( pTemp = m_SegStateQueues[SQ_CON_DONE].GetHead(); pTemp; pTemp = pTemp->GetNext() )
    {
        if( pTemp->m_mtResolvedStart >= mtTime )
        {
            *pmtNextSeg = pTemp->m_mtResolvedStart;
            hr = S_OK;
            break;
        }
    }
    if( S_FALSE == hr ) // if this is still zero, check the current queue
    {
        for( pTemp = m_SegStateQueues[SQ_CON_PLAY].GetHead(); pTemp; pTemp = pTemp->GetNext() )
        {
            if( pTemp->m_mtResolvedStart >= mtTime )
            {
                *pmtNextSeg = pTemp->m_mtResolvedStart;
                hr = S_OK;
                break;
            }
        }
    }
    LEAVE_CRITICAL_SECTION( &m_SegmentCrSec );
    return hr;
}

/*
  Given a time, mtTime, returns the time of the next primary segment in pmtNextSeg.
  Returns S_FALSE if none found, and sets pmtNextSeg to zero.
*/
HRESULT CPerformance::GetPriSegTime(
    MUSIC_TIME mtTime, 
    MUSIC_TIME* pmtNextSeg)
{
    HRESULT hr = S_FALSE;
    *pmtNextSeg = 0;
    ENTER_CRITICAL_SECTION( &m_SegmentCrSec );
    CSegState* pTemp;
    for( pTemp = m_SegStateQueues[SQ_PRI_PLAY].GetHead(); pTemp; pTemp = pTemp->GetNext() )
    {
        if( pTemp->m_mtResolvedStart > mtTime )
        {
            *pmtNextSeg = pTemp->m_mtResolvedStart;
            hr = S_OK;
            break;
        }
    }
    LEAVE_CRITICAL_SECTION( &m_SegmentCrSec );
    return hr;
}

/*
  @method HRESULT | IDirectMusicPerformance | GetGraph |
  Returns the performance's Tool Graph, AddRef'd.

  @rvalue S_OK | Success.
  @rvalue DMUS_E_NOT_FOUND | There is no graph in the performance, and therefore
  one couldn't be returned.
  @rvalue E_POINTER | <p ppGraph> is NULL or invalid.
*/
HRESULT STDMETHODCALLTYPE CPerformance::GetGraph(
         IDirectMusicGraph** ppGraph // @parm Returns the tool graph pointer.
        )
{
    V_INAME(IDirectMusicPerformance::GetGraph);
    V_PTRPTR_WRITE(ppGraph);

    HRESULT hr;
#ifdef DXAPI
    if ((m_dwVersion >= 8) && (m_dwAudioPathMode == 0))
    {
        Trace(0,"Error: Performance not initialized.\n");
        return DMUS_E_NOT_INIT;
    }
#endif
    ENTER_CRITICAL_SECTION(&m_MainCrSec);
    if( m_pGraph )
    {
        *ppGraph = m_pGraph;
        m_pGraph->AddRef();
        hr = S_OK;
    }
    else
    {
        Trace(1,"Error: Performance does not currently have a tool graph installed.\n");
        hr = DMUS_E_NOT_FOUND;
    }
    LEAVE_CRITICAL_SECTION(&m_MainCrSec);
    return hr;
}


HRESULT CPerformance::GetGraphInternal(
         IDirectMusicGraph** ppGraph )
{
    ENTER_CRITICAL_SECTION(&m_MainCrSec);
    if( !m_pGraph )
    {
        m_pGraph = new CGraph;
    }
    LEAVE_CRITICAL_SECTION(&m_MainCrSec);
    return GetGraph(ppGraph);
}

/*
  @method HRESULT | IDirectMusicPerformance | SetGraph |
  Replaces the performance's Tool Graph. <p pGraph> is AddRef'd inside this
  method. Any messages flowing through Tools in the current Tool Graph are deleted.

  @rvalue S_OK | Success.
  @rvalue E_POINTER | <p pGraph> is invalid.
*/
HRESULT STDMETHODCALLTYPE CPerformance::SetGraph(
         IDirectMusicGraph* pGraph  // @parm The tool graph pointer. May be NULL to clear
                                    // the current graph out of the performance.
        )
{
    V_INAME(IDirectMusicPerformance::SetGraph);
    V_INTERFACE_OPT(pGraph);

#ifdef DXAPI
    if ((m_dwVersion >= 8) && (m_dwAudioPathMode == 0))
    {
        Trace(0,"Error: Performance not initialized.\n");
        return DMUS_E_NOT_INIT;
    }
#endif

    ENTER_CRITICAL_SECTION(&m_MainCrSec);
    if( m_pGraph )
    {
        m_pGraph->Release();
    }
    m_pGraph = pGraph;
    if( pGraph )
    {
        pGraph->AddRef();
    }
    LEAVE_CRITICAL_SECTION(&m_MainCrSec);
    return S_OK;
}


HRESULT STDMETHODCALLTYPE CPerformance::SetNotificationHandle(
     HANDLE hNotification,      // @parm The event handle created by CreateEvent, or
                                // 0 to clear out an existing handle.
     REFERENCE_TIME rtMinimum ) // @parm The minimum amount of time that the
                                // performance should hold notify messages before discarding them.
                                // 0 means to use the default minimum time of 20000000 reference time units,
                                // which is 2 seconds, or the previous value if this API has been called previously.
                                // If the application hasn't called <om .GetNotificationPMsg> by this time, the message is
                                // discarded to free the memory.
{
    ENTER_CRITICAL_SECTION(&m_MainCrSec);
    m_hNotification = hNotification;
    if( rtMinimum )
    {
        m_rtNotificationDiscard = rtMinimum;
    }
    LEAVE_CRITICAL_SECTION(&m_MainCrSec);
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CPerformance::GetNotificationPMsg(
     DMUS_NOTIFICATION_PMSG** ppNotificationPMsg )  

{
    V_INAME(IDirectMusicPerformance::GetNotificationPMsg);
    V_PTRPTR_WRITE(ppNotificationPMsg);

    HRESULT hr;
    ENTER_CRITICAL_SECTION(&m_PipelineCrSec);
    ENTER_API_CRITICAL_SECTION;
    if( m_NotificationQueue.GetHead() )
    {
        PRIV_PMSG* pPriv = m_NotificationQueue.Dequeue();
        ASSERT(pPriv);
        *ppNotificationPMsg = (DMUS_NOTIFICATION_PMSG*)PRIV_TO_DMUS(pPriv);
        hr = S_OK;
    }
    else
    {
        *ppNotificationPMsg = NULL;
        hr = S_FALSE;
    }
    LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);
    LEAVE_API_CRITICAL_SECTION;
    return hr;
}

void CPerformance::AddNotificationTypeToAllSegments( REFGUID rguidNotification )
{
    CSegState* pSegSt;
    DWORD dwCount;
    // Note: might be nice to optimize this so the same segment
    // doesn't get called multiple times
    ENTER_CRITICAL_SECTION(&m_SegmentCrSec);
    for (dwCount = 0; dwCount < SQ_COUNT; dwCount++)
    {
        for( pSegSt = m_SegStateQueues[dwCount].GetHead(); pSegSt; pSegSt = pSegSt->GetNext() )
        {
            pSegSt->m_pSegment->AddNotificationType( rguidNotification, TRUE );
        }
    }
    LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);
}

void CPerformance::RemoveNotificationTypeFromAllSegments( REFGUID rguidNotification )
{
    CSegState* pSegSt;
    DWORD dwCount;
    // Note: might be nice to optimize this so the same segment
    // doesn't get called multiple times
    ENTER_CRITICAL_SECTION(&m_SegmentCrSec);
    for (dwCount = 0; dwCount < SQ_COUNT; dwCount++)
    {
        for( pSegSt = m_SegStateQueues[dwCount].GetHead(); pSegSt; pSegSt = pSegSt->GetNext() )
        {
            pSegSt->m_pSegment->RemoveNotificationType( rguidNotification, TRUE );
        }
    }
    LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);
}

/*
  Check to see if this notification is already being tracked.
*/
CNotificationItem* CPerformance::FindNotification( REFGUID rguidNotification )
{
    CNotificationItem* pItem;

    pItem = m_NotificationList.GetHead();
    while(pItem)
    {
        if( rguidNotification == pItem->guidNotificationType )
        {
            break;
        }
        pItem = pItem->GetNext();
    }
    return pItem;
}

/*
  @method HRESULT | IDirectMusicPerformance | AddNotificationType |
  Adds a notification type to the performance. Notifications are identified
  by a guid. When a notification is added to the performance, notify messages
  are sent to the application, which provides a message handle on which to
  block through <om IDirectMusicPerformance.SetNotificationHandle>. All segments
  and tracks are automatically updated with the new notification by calling
  their AddNotificationType methods.

  @rvalue S_OK | Success.
  @rvalue S_FALSE | The requested notification is already on the performance.
  @rvalue E_OUTOFMEMORY | Out of memory.

  @xref <om .SetNotificationHandle>, <om .GetNotificationPMsg>, <om .RemoveNotificationType>
*/
HRESULT STDMETHODCALLTYPE CPerformance::AddNotificationType(
     REFGUID rguidNotification) // @parm The guid of the notification message to add.
{
    V_INAME(IDirectMusicPerformance::AddNotificationType);
    V_REFGUID(rguidNotification);

    CNotificationItem*  pItem;
    HRESULT hr = S_OK;

    ENTER_CRITICAL_SECTION(&m_SegmentCrSec);
    ENTER_API_CRITICAL_SECTION;
    if( NULL == FindNotification( rguidNotification ) )
    {
        pItem = new CNotificationItem;
        if( NULL == pItem )
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            pItem->guidNotificationType = rguidNotification;
            m_NotificationList.Cat( pItem );
            AddNotificationTypeToAllSegments( rguidNotification );
        }
    }
    else
    {
        hr = S_FALSE;
    }
    LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);
    LEAVE_API_CRITICAL_SECTION;
    return hr;
}

/*
  @method HRESULT | IDirectMusicPerformance | RemoveNotificationType |
  Removes a previously added notification type from the performance. All
  segments and tracks are updated with the removed notification by calling
  their RemoveNotificationType methods.

  @rvalue S_OK | Success.
  @rvalue S_FALSE | The requested notification isn't currently active.

  @xref <om .SetNotificationHandle>, <om .GetNotificationPMsg>, <om .AddNotificationType>
*/
HRESULT STDMETHODCALLTYPE CPerformance::RemoveNotificationType(
     REFGUID rguidNotification) // @parm The guid of the notification message to remove.
                        // If GUID_NULL, remove all notifications.
{
    V_INAME(IDirectMusicPerformance::RemoveNotificationType);
    V_REFGUID(rguidNotification);

    HRESULT hr = S_OK;
    CNotificationItem* pItem;
    ENTER_API_CRITICAL_SECTION;
    if( GUID_NULL == rguidNotification )
    {
        while (pItem = m_NotificationList.RemoveHead())
        {
            RemoveNotificationTypeFromAllSegments( pItem->guidNotificationType );
            delete pItem;
        }
    }
    else
    {
        if( pItem = FindNotification( rguidNotification ))
        {
            RemoveNotificationTypeFromAllSegments( pItem->guidNotificationType );
            m_NotificationList.Remove( pItem );
            delete pItem;
        }
        else
        {
            Trace(2,"Warning: Unable to remove requested notification because it is not currently installed.\n");
            hr = S_FALSE;
        }
    }
    LEAVE_API_CRITICAL_SECTION;
    return hr;
}

void CPerformance::RemoveUnusedPorts()


{
#ifdef DXAPI
    DWORD dwIndex;
    ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);
    for( dwIndex = 0; dwIndex < m_dwNumPorts; dwIndex++ )
    {
        if( m_pPortTable[dwIndex].pPort && !m_AudioPathList.UsesPort(m_pPortTable[dwIndex].pPort))
        {
            // release the port and buffer. NULL them in the table. PChannels
            // that map will return an error code.
            ASSERT( m_pPortTable[dwIndex].pBuffer );
            m_pPortTable[dwIndex].pPort->Release();
            m_pPortTable[dwIndex].pBuffer->Release();
            if( m_pPortTable[dwIndex].pLatencyClock )
            {
                m_pPortTable[dwIndex].pLatencyClock->Release();
            }
            memset( &m_pPortTable[dwIndex], 0, sizeof( PortTable ));
            CChannelBlock *pBlock = m_ChannelBlockList.GetHead();
            CChannelBlock *pNext;
            for(;pBlock;pBlock = pNext)
            {
                pNext = pBlock->GetNext();
                if (pBlock->m_dwPortIndex == dwIndex)
                {
                    m_ChannelBlockList.Remove(pBlock);
                    delete pBlock;
                }
            }
        }
    }
    LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);
#endif
}

#ifdef DXAPI
HRESULT CPerformance::GetPathPort(CPortConfig *pConfig)

{
    HRESULT hr = S_OK;
    DWORD dwPort;
    ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);
    GUID &guidScan = pConfig->m_PortHeader.guidPort;
    // If we are looking for the default synth, get the class id for the default synth.
    BOOL fDefault = (pConfig->m_PortHeader.guidPort == GUID_Synth_Default); 
    if (fDefault)
    {
        guidScan = m_AudioParams.clsidDefaultSynth;
    }
    for (dwPort = 0;dwPort < m_dwNumPorts;dwPort++)
    {
        if ((m_pPortTable[dwPort].guidPortID == guidScan) && m_pPortTable[dwPort].pPort)
        { 
            pConfig->m_dwPortID = dwPort;
            pConfig->m_pPort = m_pPortTable[dwPort].pPort;
            pConfig->m_PortParams = m_pPortTable[dwPort].PortParams;
            ASSERT(pConfig->m_pPort);
            pConfig->m_pPort->AddRef();
            break;
        }
    }
    LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);
    // Failed finding the port, so create it.
    if (dwPort >= m_dwNumPorts)
    {
        BOOL fUseBuffers = FALSE;
        pConfig->m_PortParams.dwSampleRate = m_AudioParams.dwSampleRate;
        if (m_AudioParams.dwFeatures & DMUS_AUDIOF_STREAMING)
        {
            pConfig->m_PortParams.dwFeatures |= DMUS_PORT_FEATURE_STREAMING;
        }
        if (m_AudioParams.dwFeatures & DMUS_AUDIOF_BUFFERS)
        {
            fUseBuffers = TRUE;
            pConfig->m_PortParams.dwFeatures |= DMUS_PORT_FEATURE_AUDIOPATH;
        }
        pConfig->m_PortParams.dwValidParams |= DMUS_PORTPARAMS_SAMPLERATE  | DMUS_PORTPARAMS_FEATURES;
        // If this wants a default synth, consult m_AudioParams and create that synth.
        if (fDefault)
        {
            pConfig->m_PortParams.dwAudioChannels = 1;
            pConfig->m_PortParams.dwVoices = m_AudioParams.dwVoices;
            pConfig->m_PortParams.dwValidParams |= DMUS_PORTPARAMS_AUDIOCHANNELS | DMUS_PORTPARAMS_VOICES;
        }
        hr = m_pDirectMusic->CreatePort(guidScan,&pConfig->m_PortParams,&pConfig->m_pPort, NULL);
        if (SUCCEEDED(hr))
        {
            if ((pConfig->m_PortParams.dwValidParams & DMUS_PORTPARAMS_FEATURES) && (pConfig->m_PortParams.dwFeatures & DMUS_PORT_FEATURE_AUDIOPATH))
            {
                IDirectMusicPortP* pPortP = NULL;
                // QI for the private interface.
                if (SUCCEEDED(pConfig->m_pPort->QueryInterface(IID_IDirectMusicPortP,(void **) &pPortP)))
                {
                    // Connect the port to the sink.
                    hr = pPortP->SetSink(m_BufferManager.m_pSinkConnect);
                    pPortP->Release();
                }
                else
                {
                    Trace(1,"Error: Attempt to create a port with audiopath buffer support failed because synth does not support buffers.\n");
                    hr = E_INVALIDARG;
                }
            }
            else if (fUseBuffers && fDefault)
            {
                Trace(1,"Error: Attempt to create a port with audiopath buffer support failed because default synth does not support buffers.\n");
                hr = E_INVALIDARG;
            }
        }
        if (SUCCEEDED(hr))
        {
            // Now add the port to the performance.
            hr = AddPort(pConfig->m_pPort,&pConfig->m_PortHeader.guidPort,
                &pConfig->m_PortParams,&pConfig->m_dwPortID);
        }
        if (SUCCEEDED(hr))
        {
            // Activate the port. 
            hr = pConfig->m_pPort->Activate(TRUE);
            // It's okay if the synth is already active.
            if (hr == DMUS_E_SYNTHACTIVE)
            {
                hr = S_OK;
            }
        }
        if (SUCCEEDED(hr))
        {
            DWORD dwPortID = GetPortID(pConfig->m_pPort);
            // Then create matching channel blocks for all of the channel groups in the port.
            for (DWORD dwGroup = 0;dwGroup < pConfig->m_PortParams.dwChannelGroups; dwGroup++)
            {
                AllocVChannelBlock(dwPortID,dwGroup+1);
            }
        }
    }
    return (hr);
}
#endif

HRESULT STDMETHODCALLTYPE CPerformance::AddPort(
            IDirectMusicPort* pPort)
{
#ifdef XBOX
    return E_NOTIMPL;
#else
    V_INAME(IDirectMusicPerformance::AddPort);
    V_INTERFACE_OPT(pPort);
   if (m_dwAudioPathMode == 2)
    {
        Trace(0,"Error: Can not call AddPort() when using AudioPaths.\n");
        return DMUS_E_AUDIOPATHS_IN_USE;
    }
    m_dwAudioPathMode = 1;
    return AddPort(pPort,NULL,NULL,NULL);
#endif // !XBOX
}

HRESULT CPerformance::AddPort(
            IDirectMusicPort* pPort,
            GUID *pguidPortID,
            DMUS_PORTPARAMS8 *pParams,
            DWORD *pdwPortID)
{
    HRESULT hr = S_OK;
#ifdef DXAPI
    PortTable* pPortTable;
    IDirectMusicBuffer* pBuffer;
    BOOL    fSetUpBlock = FALSE;
    BOOL    fBuiltNewTable = FALSE;
    GUID guidPortID;             // Class ID of port.
    DWORD dwChannelGroups;       // Number of channel groups at initialization.
    DWORD dwNewPortIndex = 0;    // Index into port array for new port.

    ENTER_CRITICAL_SECTION(&m_MainCrSec);
    ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);

    if( NULL == m_pDirectMusic )
    {
        Trace(0,"Error: Performance is not initialized, ports can not be added.\n");
        hr = DMUS_E_NOT_INIT;
        goto END;
    }

    for (;dwNewPortIndex < m_dwNumPorts; dwNewPortIndex++)
    {
        if (!m_pPortTable[dwNewPortIndex].pPort)
        {
            break;
        }
    }
    if (dwNewPortIndex == m_dwNumPorts)
    {
        pPortTable = new PortTable[m_dwNumPorts + 1];
        if( !pPortTable )
        {
            hr = E_OUTOFMEMORY;
            goto END;
        }
        fBuiltNewTable = TRUE;
    }

    // if pPort is NULL, create a software synth port
    DMUS_PORTPARAMS dmpp;
    if( NULL == pPort )
    {
        pParams = &dmpp;
        memset(&dmpp, 0, sizeof(DMUS_PORTPARAMS) );
        dmpp.dwSize = sizeof(DMUS_PORTPARAMS);
        dmpp.dwChannelGroups = dwChannelGroups = 1;
        dmpp.dwValidParams = DMUS_PORTPARAMS_CHANNELGROUPS |
            DMUS_PORTPARAMS_AUDIOCHANNELS;
        dmpp.dwAudioChannels = 2;
        guidPortID = GUID_NULL;
        hr = m_pDirectMusic->CreatePort(GUID_NULL, &dmpp, &pPort, NULL);
        
        if ( SUCCEEDED( hr ) ) 
        {
            hr = pPort->Activate(TRUE);
        }


        fSetUpBlock = TRUE;
    }
    else
    {
        if (pguidPortID)
        {
            guidPortID = *pguidPortID;
        }
        else
        {
            DMUS_PORTCAPS PortCaps;
            PortCaps.dwSize = sizeof (PortCaps);
            pPort->GetCaps(&PortCaps);
            guidPortID = PortCaps.guidPort;
        }
        pPort->GetNumChannelGroups(&dwChannelGroups);
        pPort->AddRef();
    }
    if( FAILED(hr) || ( pPort == NULL ) )
    {
        if (fBuiltNewTable) delete [] pPortTable;
        Trace(0,"Error: Unable to open requested port.\n");
        hr = DMUS_E_CANNOT_OPEN_PORT;
        goto END;
    }

    // Create a buffer
    DMUS_BUFFERDESC dmbd;
    memset( &dmbd, 0, sizeof(DMUS_BUFFERDESC) );
    dmbd.dwSize = sizeof(DMUS_BUFFERDESC);
    dmbd.cbBuffer = DEFAULT_BUFFER_SIZE;
    if( FAILED( m_pDirectMusic->CreateMusicBuffer(&dmbd, &pBuffer, NULL)))
    {
        if (fBuiltNewTable) delete [] pPortTable;
        pPort->Release();
        Trace(1,"Error: Unable to create MIDI buffer for port.\n");
        hr = DMUS_E_CANNOT_OPEN_PORT;
        goto END;
    }

    if (fBuiltNewTable) 
    {
        // if there is an existing port table, copy its contents to the new, bigger, port table
        if( m_pPortTable )
        {
            if( m_dwNumPorts > 0 )
            {
                memcpy( pPortTable, m_pPortTable, sizeof(PortTable) * ( m_dwNumPorts ) );
            }
            delete [] m_pPortTable;
        }
        m_pPortTable = pPortTable;
    }
    if (pdwPortID)
    {
        *pdwPortID = dwNewPortIndex;
    }
    pPortTable = &m_pPortTable[dwNewPortIndex];
    pPortTable->pPort = pPort;
    // If we have a passed params structure, copy it. This will be used for identifying the
    // params as initialized by the synth.
    if (pParams)
    {
        pPortTable->PortParams = *pParams;
    }
    pPortTable->dwGMFlags = 0;
    //set master volume
    IKsControl *pControl;
    if(SUCCEEDED(pPort->QueryInterface(IID_IKsControl, (void**)&pControl)))
    {
        KSPROPERTY ksp;
        ULONG cb;

        memset(&ksp, 0, sizeof(ksp));
        ksp.Set   = GUID_DMUS_PROP_Volume;
        ksp.Id    = 0;
        ksp.Flags = KSPROPERTY_TYPE_SET;

        pControl->KsProperty(&ksp,
                            sizeof(ksp),
                            (LPVOID)&m_lMasterVolume,
                            sizeof(m_lMasterVolume),
                            &cb);
        // Now, find out if it has a gm, gs, or xg sets in rom...
        BOOL bIsSupported = FALSE;
        ksp.Set     = GUID_DMUS_PROP_GM_Hardware;
        ksp.Flags   = KSPROPERTY_TYPE_GET;

        hr = pControl->KsProperty(&ksp,
                            sizeof(ksp),
                            (LPVOID)&bIsSupported,
                            sizeof(bIsSupported),
                            &cb);
        if (SUCCEEDED(hr) && (bIsSupported))
        {
            pPortTable->dwGMFlags |= DM_PORTFLAGS_GM;
        }
        bIsSupported = FALSE;
        ksp.Set     = GUID_DMUS_PROP_GS_Hardware;
        ksp.Flags   = KSPROPERTY_TYPE_GET;

        hr = pControl->KsProperty(&ksp,
                            sizeof(ksp),
                            (LPVOID)&bIsSupported,
                            sizeof(bIsSupported),
                            &cb);
        if (SUCCEEDED(hr) && (bIsSupported))
        {
            pPortTable->dwGMFlags |= DM_PORTFLAGS_GS;
        }
        bIsSupported = FALSE;
        ksp.Set     = GUID_DMUS_PROP_XG_Hardware;
        ksp.Flags   = KSPROPERTY_TYPE_GET;

        hr = pControl->KsProperty(&ksp,
                            sizeof(ksp),
                            (LPVOID)&bIsSupported,
                            sizeof(bIsSupported),
                            &cb);
        if (SUCCEEDED(hr) && (bIsSupported))
        {
            pPortTable->dwGMFlags |= DM_PORTFLAGS_XG;
        }
        pControl->Release();
    }

    if( FAILED( pPort->GetLatencyClock( &pPortTable->pLatencyClock )))
    {
        pPortTable->pLatencyClock = NULL;
    }
    pPortTable->dwChannelGroups = dwChannelGroups;
    pPortTable->guidPortID = guidPortID;
    pPortTable->pBuffer = pBuffer;
    pPortTable->fBufferFilled = FALSE;
    pPortTable->rtLast = 0;
    if (fBuiltNewTable) m_dwNumPorts++; // must do this before calling AssignPChannelBlock
    if( fSetUpBlock && m_ChannelBlockList.IsEmpty() ) // set up default PChannel map if none already set
    {
        AssignPChannelBlock( 0, pPort, 1);
    }
    hr = S_OK;
END:
    LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);
    LEAVE_CRITICAL_SECTION(&m_MainCrSec);
#endif
    return hr;
}

HRESULT STDMETHODCALLTYPE CPerformance::RemovePort(
            IDirectMusicPort* pPort     // @parm The port to remove.
        )
{
    HRESULT hr = E_INVALIDARG;
#ifdef DXAPI
    V_INAME(IDirectMusicPerformance::RemovePort);
    V_INTERFACE(pPort);

    DWORD dwIndex;

    ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);
    for( dwIndex = 0; dwIndex < m_dwNumPorts; dwIndex++ )
    {
        if( m_pPortTable[dwIndex].pPort == pPort )
        {
            // release the port and buffer. NULL them in the table. PChannels
            // that map will return an error code.
            ASSERT( m_pPortTable[dwIndex].pBuffer );
            m_pPortTable[dwIndex].pPort->Release();
            m_pPortTable[dwIndex].pBuffer->Release();
            if( m_pPortTable[dwIndex].pLatencyClock )
            {
                m_pPortTable[dwIndex].pLatencyClock->Release();
            }
            memset( &m_pPortTable[dwIndex], 0, sizeof( PortTable ));
            hr = S_OK;
            break;
        }
    }
#ifdef DBG
    if (hr == E_INVALIDARG)
    {
        Trace(0,"Error: Invalid port passed to RemovePort().\n");
    }
#endif
    LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);
#endif
    return hr;
}

// this must be called from within a PChannelCrSec critical section.
HRESULT CPerformance::AssignPChannelBlock(
            DWORD dwBlockNum,
            DWORD dwPortIndex,
            DWORD dwGroup,
            WORD wFlags)
{
    // see if we've already allocated this block before
    // blocknum is PChannel / 16, so search on that.
    DWORD dwPChannel = dwBlockNum * 16;
    CChannelBlock* pChannelBlock = m_ChannelBlockList.GetHead();

    for( ; pChannelBlock; pChannelBlock = pChannelBlock->GetNext() )
    {
        if( pChannelBlock->m_dwPChannelStart == dwPChannel )
        {
            pChannelBlock->Init(dwPChannel,dwPortIndex,dwGroup,wFlags);
            break;
        }
    }
    if( !pChannelBlock )
    {
        pChannelBlock = new CChannelBlock;
        if( !pChannelBlock )
        {
            return E_OUTOFMEMORY;
        }
        pChannelBlock->Init(dwPChannel,dwPortIndex,dwGroup,wFlags);
        m_ChannelBlockList.AddHead(pChannelBlock);
        pChannelBlock->m_dwPChannelStart = dwPChannel;
    }
    return S_OK;
}

// this must be called from within a PChannelCrSec critical section.
HRESULT CPerformance::AssignPChannel(
            DWORD dwPChannel,
            DWORD dwPortIndex,
            DWORD dwGroup,
            DWORD dwMChannel,
            WORD wFlags)
{
    DWORD dwIndex;
    CChannelBlock* pChannelBlock = m_ChannelBlockList.GetHead();

    for( ; pChannelBlock; pChannelBlock = pChannelBlock->GetNext() )
    {
        if( pChannelBlock->m_dwPChannelStart <= dwPChannel )
        {
            if( pChannelBlock->m_dwPChannelStart + PCHANNEL_BLOCKSIZE > dwPChannel )
            {
                break;
            }
        }
    }
    if( !pChannelBlock )
    {
        // there is no currently existing block that encompases dwPChannel.
        // Create one.
        pChannelBlock = new CChannelBlock;

        if( !pChannelBlock )
        {
            return E_OUTOFMEMORY;
        }
        pChannelBlock->Init(dwPChannel,0,0,CMAP_FREE);
        m_ChannelBlockList.AddHead(pChannelBlock);
    }

    dwIndex = dwPChannel - pChannelBlock->m_dwPChannelStart;

    ASSERT( dwIndex < PCHANNEL_BLOCKSIZE );
    CChannelMap *pMap = &pChannelBlock->m_aChannelMap[dwIndex];
    pMap->dwPortIndex = dwPortIndex;
    pMap->dwGroup = dwGroup;
    pMap->dwMChannel = dwMChannel;
    pMap->nTranspose = 0;
    if ((pMap->wFlags & CMAP_FREE) && !(wFlags & CMAP_FREE)) 
        pChannelBlock->m_dwFreeChannels--;
    else if (!(pMap->wFlags & CMAP_FREE) && (wFlags & CMAP_FREE)) 
        pChannelBlock->m_dwFreeChannels++;
    pMap->wFlags = wFlags;
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CPerformance::AssignPChannelBlock(
            DWORD dwBlockNum,           // @parm The block number. Should be 0 or greater.
            IDirectMusicPort* pPort,    // @parm The port.
            DWORD dwGroup               // @parm The group on the port. Should be 1 or greater.
        )
{
#ifdef XBOX
    return E_NOTIMPL;
#else
    V_INAME(IDirectMusicPerformance::AssignPChannelBlock);
    V_INTERFACE(pPort);


    if (m_dwAudioPathMode == 2)
    {
        Trace(0,"Error: Can not call AssignPChannelBlock() when using AudioPaths.\n");
        return DMUS_E_AUDIOPATHS_IN_USE;
    }
    m_dwAudioPathMode = 1;
    DWORD dwIndex;
    HRESULT hr = E_INVALIDARG;
    ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);
    for( dwIndex = 0; dwIndex < m_dwNumPorts; dwIndex++ )
    {
        if( m_pPortTable[dwIndex].pPort == pPort )
        {
            if( SUCCEEDED( hr = AssignPChannelBlock( dwBlockNum, dwIndex, dwGroup, CMAP_STATIC )))
            {
                if (m_pPortTable[dwIndex].dwChannelGroups < dwGroup)
                {
                    hr = S_FALSE;
                }
            }
            break;
        }
    }
#ifdef DBG
    if (hr == E_INVALIDARG)
    {
        Trace(0,"Error: AssignPChannelBlock() called with invalid port.\n");
    }
#endif
    LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);
    return hr;
#endif // !XBOX
}

HRESULT STDMETHODCALLTYPE CPerformance::AssignPChannel(
            DWORD dwPChannel,           // @parm The PChannel.
            IDirectMusicPort* pPort,    // @parm The port.
            DWORD dwGroup,              // @parm The group on the port.
            DWORD dwMChannel            // @parm The channel on the group.
        )
{
#ifdef XBOX
    return E_NOTIMPL;
#else
    V_INAME(IDirectMusicPerformance::AssignPChannel);
    V_INTERFACE(pPort);


    if (m_dwAudioPathMode == 2)
    {
        Trace(0,"Error: Can not call AssignPChannel() when using AudioPaths.\n");
        return DMUS_E_AUDIOPATHS_IN_USE;
    }
    m_dwAudioPathMode = 1;
    DWORD dwIndex;
    HRESULT hr = E_INVALIDARG;
    if( (dwMChannel < 0) || (dwMChannel > 15))
    {
        Trace(0,"Error: AssignPChannel() called with invalid MIDI Channel %ld.\n",dwMChannel);
        return E_INVALIDARG;
    }
    ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);
    for( dwIndex = 0; dwIndex < m_dwNumPorts; dwIndex++ )
    {
        if( m_pPortTable[dwIndex].pPort == pPort )
        {
            if( SUCCEEDED( hr = AssignPChannel( dwPChannel, dwIndex, dwGroup, dwMChannel, CMAP_STATIC )))
            {
                if (m_pPortTable[dwIndex].dwChannelGroups < dwGroup)
                {
                    hr = S_FALSE;
                }
            }
            break;
        }
    }
    LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);
    return hr;
#endif // !XBOX
}

/*  ReleasePChannel finds the requested PChannel and makes it available
    for reuse.
    It also calls ResetAllControllers(), which sends MIDI CC 121 and 123,
    reset all controllers and all notes off.
*/

HRESULT CPerformance::ReleasePChannel(DWORD dwPChannel)
{
    HRESULT hr = E_INVALIDARG;
    ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);
    CChannelBlock* pChannelBlock = m_ChannelBlockList.GetHead();
    for( ; pChannelBlock; pChannelBlock = pChannelBlock->GetNext() )
    {
        if( pChannelBlock->m_dwPChannelStart <= dwPChannel )
        {
            if( pChannelBlock->m_dwPChannelStart + PCHANNEL_BLOCKSIZE > dwPChannel )
            {
                break;
            }
        }
    }
    if( pChannelBlock )
    {
        // Only release if this is genuinely a virtual pchannel. Otherwise, leave alone.
        CChannelMap *pMap = &pChannelBlock->m_aChannelMap[dwPChannel - pChannelBlock->m_dwPChannelStart];
        if (pMap->wFlags & CMAP_VIRTUAL)
        {
            pChannelBlock->m_dwFreeChannels++;
            // Clear out all the merge lists, etc.
            pMap->Clear();
            // Reset controllers, but don't send a GM reset.
            ResetAllControllers(pMap,0, false);
#ifdef XBOX
            // For XBox, we may have passed a buffer down to the port, so make sure it is released.
            DWORD dwIndex;
            DWORD dwGroup;
            DWORD dwMChannel;
            HRESULT hr = PChannelIndex( dwPChannel, &dwIndex, &dwGroup, &dwMChannel, NULL );
            if (SUCCEEDED(hr) && m_pSynth)
            {
                m_pSynth->AssignChannelToOutput(dwGroup,dwMChannel,NULL,0,NULL);
            }
#endif
        }
        hr = S_OK;
    }
    LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);
    return hr;
}

HRESULT CPerformance::GetPort(DWORD dwPortID, IDirectMusicPort **ppPort)

{
#ifdef DXAPI
    HRESULT hr;
    ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);
    if (dwPortID < m_dwNumPorts)
    {
        *ppPort = m_pPortTable[dwPortID].pPort;
        (*ppPort)->AddRef();
        hr = S_OK;
    }
    else 
    {
        Trace(1,"Error: Unable to find requested port.\n");
        hr = E_FAIL;
    }
    LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);
    return hr;
#else
    return E_FAIL;
#endif
}
 

HRESULT CPerformance::AllocVChannel(DWORD dwPortID, DWORD dwDrumFlags, DWORD *pdwPChannel, DWORD *pdwGroup,DWORD *pdwMChannel)
{
    // dwDrumsFlags:
    // bit 0 determines whether this port separates out drums on channel 10.
    // bit 1 determines whether this request is for a drum.
    // First, figure out if we are scanning for drums on channel 10, melodic instruments
    // on the other channels, or any on all channels.
    static DWORD sdwSearchForDrums[1] = { 9 };
    static DWORD sdwSearchForAll[16] = { 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 };
    static DWORD sdwSearchForMelodic[15] = { 0,1,2,3,4,5,6,7,8,10,11,12,13,14,15 };
    DWORD *pSearchArray = sdwSearchForAll;
    DWORD dwSearchSize = 16;
    if (dwDrumFlags & 1) // Do we handle drums as a special case for channel 10?
    {
        if (dwDrumFlags & 2) // And are we looking for drums on channel 10?
        {
            pSearchArray = sdwSearchForDrums;
            dwSearchSize = 1;
        }
        else
        {
            pSearchArray = sdwSearchForMelodic;
            dwSearchSize = 15;
        }
    }
    HRESULT hr = E_INVALIDARG; // Return this if the vChannel is out of range.
    ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);

    CChannelBlock* pChannelBlock = m_ChannelBlockList.GetHead();
    BOOL fNotFound = TRUE;              // Use to indicate when we finally find a match.
    DWORD dwHighestPChannel = 0;        // Keep track of the highest PCHannel in use, this will be 
                                        // used to create a new PChannel block, if needed.
    DWORD dwChannel;
    for (;fNotFound && pChannelBlock;pChannelBlock = pChannelBlock->GetNext() )
    {
        if (dwHighestPChannel < pChannelBlock->m_dwPChannelStart)
        {
            dwHighestPChannel = pChannelBlock->m_dwPChannelStart;
        }
        if ((pChannelBlock->m_dwPortIndex == dwPortID) && (pChannelBlock->m_dwFreeChannels))
        {
            DWORD dwIndex;
            for (dwIndex = 0; dwIndex < dwSearchSize; dwIndex++)
            {
                dwChannel = pSearchArray[dwIndex];
                if (pChannelBlock->m_aChannelMap[dwChannel].wFlags & CMAP_FREE) 
                {
                    *pdwPChannel = pChannelBlock->m_dwPChannelStart + dwChannel;
                    pChannelBlock->m_dwFreeChannels--;
                    pChannelBlock->m_aChannelMap[dwChannel].wFlags = CMAP_VIRTUAL;
                    *pdwGroup = pChannelBlock->m_aChannelMap[dwChannel].dwGroup;
                    *pdwMChannel = pChannelBlock->m_aChannelMap[dwChannel].dwMChannel;
                    fNotFound = FALSE;
                    hr = S_OK;
                    break;
                }
            }
        }
    }
    if( fNotFound )
    {
        // there is no currently existing block that has a free channel.
        // Create one.
        DWORD dwChannelGroupCount;
#ifdef DXAPI
        IDirectMusicPort *pPort = m_pPortTable[dwPortID].pPort;
        pPort->GetNumChannelGroups(&dwChannelGroupCount);
        dwChannelGroupCount++;
#else
        IDirectMusicSynthX *pPort = m_pSynth;
        m_dwNumChannelGroups++;
        dwChannelGroupCount = m_dwNumChannelGroups;
#endif
        hr = pPort->SetNumChannelGroups(dwChannelGroupCount);
        if (SUCCEEDED(hr))
        {
#ifdef DXAPI
            m_pPortTable[dwPortID].dwChannelGroups = dwChannelGroupCount;
#endif
            hr = E_OUTOFMEMORY;
            dwHighestPChannel += PCHANNEL_BLOCKSIZE;
            pChannelBlock = new CChannelBlock;
            if (pChannelBlock)
            {
                pChannelBlock->Init(dwHighestPChannel,dwPortID,dwChannelGroupCount,CMAP_FREE);
                m_ChannelBlockList.AddTail(pChannelBlock);
                dwChannel = pSearchArray[0];  // Which channel should we use?
                CChannelMap *pMap = &pChannelBlock->m_aChannelMap[dwChannel];
                pMap->dwMChannel = dwChannel;
                pMap->wFlags = CMAP_VIRTUAL;
                pChannelBlock->m_dwFreeChannels--;
                *pdwPChannel = dwChannel + dwHighestPChannel;
                *pdwGroup = pMap->dwGroup;
                *pdwMChannel = dwChannel;
                hr = S_OK;
            }
        }
    }
#ifdef DBG
    if (hr == E_INVALIDARG)
    {
        Trace(1,"Error: Unable to allocated dynamic PChannel.\n");
    }
#endif
    LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);
    return hr;
}

HRESULT CPerformance::AllocVChannelBlock(DWORD dwPortID,DWORD dwGroup)
{
    ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);

    CChannelBlock* pChannelBlock = m_ChannelBlockList.GetHead();
    long lHighestPChannel = -PCHANNEL_BLOCKSIZE;
    for (;pChannelBlock;pChannelBlock = pChannelBlock->GetNext() )
    {
        if (lHighestPChannel < (long) pChannelBlock->m_dwPChannelStart)
        {
            lHighestPChannel = pChannelBlock->m_dwPChannelStart;
        }
    }
    HRESULT hr = E_OUTOFMEMORY;
    lHighestPChannel += PCHANNEL_BLOCKSIZE;
    pChannelBlock = new CChannelBlock;
    if (pChannelBlock)
    {
        pChannelBlock->Init((DWORD) lHighestPChannel,dwPortID,dwGroup,CMAP_FREE);
        m_ChannelBlockList.AddTail(pChannelBlock);
        hr = S_OK;
    }
    LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);
    return hr;
}


#ifdef DBG
void CPerformance::TraceAllChannelMaps()

{
    ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);
    CChannelBlock* pChannelBlock = m_ChannelBlockList.GetHead();
    for( ; pChannelBlock; pChannelBlock = pChannelBlock->GetNext() )
    {
        TraceI(0,"ChannelBlock %lx, Free %ld\n",pChannelBlock->m_dwPChannelStart,pChannelBlock->m_dwFreeChannels);
        DWORD dwIndex;
        for (dwIndex = 0; dwIndex < PCHANNEL_BLOCKSIZE; dwIndex++)
        {
            CChannelMap *pMap = &pChannelBlock->m_aChannelMap[dwIndex];
            TraceI(0,"\tPort %ld, Group: %ld, MIDI: %ld, Transpose: %ld, Flags: %ld\n",
                pMap->dwPortIndex, pMap->dwGroup, pMap->dwMChannel, (long) pMap->nTranspose, (long) pMap->wFlags);
        }
    }
    LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);
}

#endif


/* Note that the following must be called from within a m_PChannelInfoCrSec
   critical section and stay within that critical section for the duration
   of using the returned CChannelMap.
*/


CChannelMap * CPerformance::GetPChannelMap( DWORD dwPChannel )
{
    CChannelBlock*  pChannelBlock = m_ChannelBlockList.GetHead();

    for( ; pChannelBlock; pChannelBlock = pChannelBlock->GetNext() )
    {
        if( ( dwPChannel >= pChannelBlock->m_dwPChannelStart ) &&
            ( dwPChannel < pChannelBlock->m_dwPChannelStart + PCHANNEL_BLOCKSIZE ) )
        {
            CChannelMap* pChannelMap;

            pChannelMap = &pChannelBlock->m_aChannelMap[ dwPChannel - pChannelBlock->m_dwPChannelStart ];
            if( pChannelMap->dwGroup == 0 )
            {
                // this PChannel isn't on a valid group, therefore it hasn't
                // been set.
//              return NULL;
            }
            return pChannelMap;
        }
    }
    return NULL;
}

/*
  internal version
*/

HRESULT CPerformance::PChannelIndex( DWORD dwPChannel, DWORD* pdwIndex,
            DWORD* pdwGroup, DWORD* pdwMChannel, short* pnTranspose )
{
    if (m_dwAudioPathMode == 0)
    {
        Trace(0,"Error: Performance not initialized.\n");
        return DMUS_E_NOT_INIT;
    }
    HRESULT hr;
    ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);
    CChannelMap *pChannelMap = GetPChannelMap(dwPChannel);
    if (pChannelMap)
    {
        ASSERT( pdwIndex && pdwGroup && pdwMChannel );

        *pdwIndex = pChannelMap->dwPortIndex;
        *pdwGroup = pChannelMap->dwGroup;
        *pdwMChannel = pChannelMap->dwMChannel;
        if( pnTranspose )
        {
            *pnTranspose = pChannelMap->nTranspose;
        }
        hr = S_OK;
    }
    else
    {
        Trace(1,"Error: PChannel %ld has not been assigned to a port.\n",dwPChannel);
#ifdef DXAPI
        if (m_dwVersion < 8)
        {
            hr = E_INVALIDARG;
        }
        else
#endif
        {
            hr = DMUS_E_AUDIOPATH_NOPORT;
        }
    }
    LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);
    return hr;
}
#ifdef DXAPI
DWORD CPerformance::GetPortID(IDirectMusicPort * pPort)

{
    ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);
    DWORD dwID = 0;
    for (;dwID < m_dwNumPorts; dwID++)
    {
        if (pPort == m_pPortTable[dwID].pPort)
        {
            break;
        }
    }
    LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);
    if (dwID == m_dwNumPorts) dwID = 0;
    return dwID;
}
#endif

STDMETHODIMP CPerformance::GetPortAndFlags(DWORD dwPChannel,IDirectMusicPort **ppPort,DWORD * pdwFlags)

{
#ifdef DXAPI
    ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);
    DWORD dwIndex;
    DWORD dwGroup;
    DWORD dwMChannel;
    HRESULT hr = PChannelIndex( dwPChannel, &dwIndex, &dwGroup, &dwMChannel, NULL );
    if (SUCCEEDED(hr))
    {
        *ppPort = m_pPortTable[dwIndex].pPort;
        if( *ppPort )
        {
            m_pPortTable[dwIndex].pPort->AddRef();
        }
        else
        {
            Trace(1,"Error: Performance does not have a port assigned to PChannel %ld.\n",dwPChannel);
            hr = DMUS_E_NOT_INIT;
        }
        *pdwFlags = m_pPortTable[dwIndex].dwGMFlags;
    }
    LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);
    return hr;
#else
    return E_FAIL;
#endif
}

STDMETHODIMP CPerformance::PChannelInfo(
            DWORD dwPChannel,           // @parm The PChannel to convert.
            IDirectMusicPort** ppPort,  // @parm Returns the port. May be NULL.
            DWORD* pdwGroup,            // @parm Returns the group on the port. May be NULL.
            DWORD* pdwMChannel          // @parm Returns the channel on the group. May be NULL.
        )
{
    V_INAME(IDirectMusicPerformance::PChannelInfo);
    V_PTRPTR_WRITE_OPT(ppPort);
    V_PTR_WRITE_OPT(pdwGroup,DWORD);
    V_PTR_WRITE_OPT(pdwMChannel,DWORD);

    DWORD dwIndex, dwGroup, dwMChannel;
    HRESULT hr;

    if (m_dwAudioPathMode == 0)
    {
        Trace(0,"Error: Performance not initialized.\n");
        return DMUS_E_NOT_INIT;
    }
    ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);
    if( SUCCEEDED( PChannelIndex( dwPChannel, &dwIndex, &dwGroup, &dwMChannel )))
    {
#ifdef DXAPI
        if( ppPort )
        {
            *ppPort = m_pPortTable[dwIndex].pPort;
            if( *ppPort )
            {
                m_pPortTable[dwIndex].pPort->AddRef();
            }
        }
#endif
        if( pdwGroup )
        {
            *pdwGroup = dwGroup;
        }
        if( pdwMChannel )
        {
            *pdwMChannel = dwMChannel;
        }
        hr = S_OK;
    }
    else
    {
        // No need to print an error message because PChannelIndex() does it.
        hr = E_INVALIDARG;
    }
    LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);
    return hr;
}

/*
  @method HRESULT | IDirectMusicPerformance | DownloadInstrument |
  Downloads an IDirectMusicInstrument to the IDirectMusicPort specified by
  the selected PChannel.

  @rvalue E_INVALIDARG | The PChannel isn't assigned to a Port, or the Port failed
  to download the instrument. No return parameter is valid.
  @rvalue S_OK | Success.
  @rvalue E_POINTER | One of the pointers is invalid.
*/
#ifdef DXAPI
HRESULT STDMETHODCALLTYPE CPerformance::DownloadInstrument(
    IDirectMusicInstrument* pInst,  // @parm The instrument to download.
    DWORD dwPChannel,               // @parm The PChannel to assign the instrument.
    IDirectMusicDownloadedInstrument** ppDownInst,  // @parm Returns the downloaded instrument.
    DMUS_NOTERANGE* pNoteRanges,    // @parm A pointer to an array of DMUS_NOTERANGE structures
    DWORD dwNumNoteRanges,          // @parm Number of DMUS_NOTERANGE structures in array pointed to by pNoteRanges
    IDirectMusicPort** ppPort,      // @parm Returns the port to which the instrument was downloaded.
    DWORD* pdwGroup,                // @parm Returns the group to which the instrument was assigned.
    DWORD* pdwMChannel              // @parm Returns the MChannel to which the instrument was assigned.
        )
{
    V_INAME(IDirectMusicPerformance::DownloadInstrument);
    V_INTERFACE(pInst);
    V_PTRPTR_WRITE(ppDownInst);
    V_BUFPTR_READ_OPT(pNoteRanges, (sizeof(DMUS_NOTERANGE) * dwNumNoteRanges));
    V_PTRPTR_WRITE(ppPort);
    V_PTR_WRITE(pdwGroup,DWORD);
    V_PTR_WRITE(pdwMChannel,DWORD);


    DWORD dwIndex, dwGroup, dwMChannel;
    IDirectMusicPort* pPort = NULL;
    HRESULT hr = E_INVALIDARG;

    if (m_dwAudioPathMode == 0) 
    {
        Trace(0,"Error: Performance not initialized.\n");
        return DMUS_E_NOT_INIT;
    }
    ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);
    if( SUCCEEDED( PChannelIndex( dwPChannel, &dwIndex, &dwGroup, &dwMChannel )))
    {
        pPort = m_pPortTable[dwIndex].pPort;
        if( pPort )
        {
            hr = pPort->DownloadInstrument( pInst, ppDownInst, pNoteRanges, dwNumNoteRanges );
            pPort->AddRef();
        }
    }
    else
    {
        Trace(1,"Error: Download attempted on unassigned PChannel %ld\n",dwPChannel);
    }
    LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);
    if( SUCCEEDED(hr) )
    {
        *ppPort = pPort;
        pPort->AddRef();
        *pdwGroup = dwGroup;
        *pdwMChannel = dwMChannel;
    }
    if( pPort )
    {
        pPort->Release();
    }
    return hr;
}
#endif
/*
  @method HRESULT | IDirectMusicPerformance | Invalidate |
  Flushes all methods from <p mtTime> forward, and seeks all Segments back
  to <p mtTime>, thereby calling all Tracks to resend their data.

  @rvalue S_OK | Success.
  @rvalue DMUS_E_NO_MASTER_CLOCK | There is no master clock in the performance.
  Make sure to call <om .Init> before calling this method.

  @comm If <p mtTime> is so long ago that it is impossible to invalidate that time,
  the earliest possible time will be used.
*/
HRESULT STDMETHODCALLTYPE CPerformance::Invalidate(
    MUSIC_TIME mtTime,  // @parm The time to invalidate, adjusted by <p dwFlags>. 0 means now.
    DWORD dwFlags)      // @parm Adjusts <p mtTime> to align to measures, beats, etc. See
                        // <t DMPLAYSEGFLAGS>.
{
    ENTER_CRITICAL_SECTION(&m_MainCrSec);
    if( m_pClock == NULL )
    {
        LEAVE_CRITICAL_SECTION(&m_MainCrSec);
         Trace(0,"Error: Invalidate() failed because the performance has not been initialized.\n");
        return DMUS_E_NO_MASTER_CLOCK;
    }
    LEAVE_CRITICAL_SECTION(&m_MainCrSec);

    ENTER_CRITICAL_SECTION( &m_SegmentCrSec );
    ENTER_CRITICAL_SECTION( &m_PipelineCrSec );
    
    SendBuffers();

    // make sure mtTime is greater than the current queue time
    REFERENCE_TIME rtQueue;
    MUSIC_TIME mtQueue;
    MUSIC_TIME mtBumperLength;

    GetQueueTime( &rtQueue );
    ReferenceToMusicTime( rtQueue, &mtQueue );
    ReferenceToMusicTime( m_rtBumperLength, &mtBumperLength );
    if( mtTime < mtQueue + mtBumperLength )
    {
        mtTime = mtQueue + mtBumperLength;
    }
    // resolve mtTime to the boundary of dwFlags
    mtTime = ResolveTime( mtTime, dwFlags, NULL );
    // flush messages
    FlushMainEventQueues( 0, mtTime, mtQueue, 0 );
    // move any segments in the past list that are affected into the current list
    CSegState *pSegSt;
    CSegState *pNext;
    for (pSegSt = m_SegStateQueues[SQ_SEC_DONE].GetHead();pSegSt;pSegSt = pNext)
    {
        pNext = pSegSt->GetNext();
        if( pSegSt->m_mtLastPlayed > mtTime )
        {
            m_SegStateQueues[SQ_SEC_DONE].Remove(pSegSt);
            m_SegStateQueues[SQ_SEC_PLAY].Insert( pSegSt );
        }
    }
    for (pSegSt = m_SegStateQueues[SQ_CON_DONE].GetHead();pSegSt;pSegSt = pNext)
    {
        pNext = pSegSt->GetNext();
        if( pSegSt->m_mtLastPlayed > mtTime )
        {
            m_SegStateQueues[SQ_CON_DONE].Remove(pSegSt);
            m_SegStateQueues[SQ_CON_PLAY].Insert( pSegSt );
        }
    }
    pSegSt = m_SegStateQueues[SQ_PRI_DONE].GetTail();
    if(pSegSt)
    {
        // only check the last one in this list
        if( pSegSt->m_mtLastPlayed > mtTime )
        {
            m_SegStateQueues[SQ_PRI_DONE].Remove(pSegSt);
            m_SegStateQueues[SQ_PRI_PLAY].Insert( pSegSt );
        }
    }
    // seek back any affected segmentstates that were playing
    DWORD dwCount;
    for( dwCount = SQ_PRI_PLAY; dwCount <= SQ_SEC_PLAY; dwCount++ )
    {
        for( pSegSt = m_SegStateQueues[dwCount].GetHead(); pSegSt; pSegSt = pSegSt->GetNext() )
        {
            if( pSegSt->m_fStartedPlay )
            {
                if (SQ_PRI_PLAY == dwCount && pSegSt->m_mtResolvedStart >= mtTime)
                {
                    // resend the segment start notification 
                    pSegSt->GenerateNotification( DMUS_NOTIFICATION_SEGSTART, pSegSt->m_mtResolvedStart );
                    // if this is a primary or controlling segment, resend a DMUS_PMSGT_DIRTY message
                    if( !(pSegSt->m_dwPlaySegFlags & DMUS_SEGF_SECONDARY) || (pSegSt->m_dwPlaySegFlags & DMUS_SEGF_CONTROL) )
                    {
                        TraceI(4, "ReSend Dirty PMsg [3] %d (%d)\n", pSegSt->m_mtSeek, pSegSt->m_mtOffset + pSegSt->m_mtSeek);
                        pSegSt->SendDirtyPMsg( pSegSt->m_mtOffset + pSegSt->m_mtSeek );
                    }
                }
                if( pSegSt->m_mtLastPlayed > mtTime )
                {
                    // if mtTime is after the actual start time of the segment,
                    // set it so the segment has never been played before and
                    // seek the segment to the beginning
                    if( pSegSt->m_mtResolvedStart > mtTime )
                    {
                        pSegSt->m_mtLastPlayed = pSegSt->m_mtResolvedStart;
                        pSegSt->m_fStartedPlay = FALSE;
                    }
                    else
                    {
                        pSegSt->m_mtLastPlayed = mtTime;
                    }
                    pSegSt->SetInvalidate( pSegSt->m_mtLastPlayed );
                }
            }
        }
    }

    LEAVE_CRITICAL_SECTION( &m_PipelineCrSec );
    LEAVE_CRITICAL_SECTION( &m_SegmentCrSec );
    // signal the transport thread so we don't have to wait for it to wake up on its own
#ifdef DXAPI
    if( m_hTransport ) SetEvent( m_hTransport );
#else
    if (m_pTransportWorker) m_pTransportWorker->WakeUp();
#endif
    return S_OK;
}

#ifdef DXAPI
STDMETHODIMP CPerformance::SetParamHook(IDirectMusicParamHook *pIHook)

{   V_INAME(IDirectMusicPerformance::SetParamHook);
    V_INTERFACE_OPT(pIHook);

    ENTER_CRITICAL_SECTION(&m_MainCrSec);
    if (m_pParamHook)
    {
        m_pParamHook->Release();
    }
    m_pParamHook = pIHook;
    if (pIHook)
    {
        pIHook->AddRef();
    }
    LEAVE_CRITICAL_SECTION(&m_MainCrSec);
    return S_OK;
}
#endif

HRESULT STDMETHODCALLTYPE CPerformance::GetParamEx(
    REFGUID rguidType,  
    DWORD dwTrackID,
    DWORD dwGroupBits,      
    DWORD dwIndex,
    MUSIC_TIME mtTime,
    MUSIC_TIME* pmtNext,
    void* pData)

{
    V_INAME(IDirectMusicPerformance::GetParamEx);
    V_PTR_WRITE_OPT(pmtNext,MUSIC_TIME);
    V_PTR_WRITE_OPT(pData,1);
    V_REFGUID(rguidType);

    static DWORD dwSearchOrder[SQ_COUNT] = { SQ_PRI_PLAY, SQ_SEC_PLAY, 
                                      SQ_PRI_DONE, SQ_SEC_DONE, 
                                      SQ_PRI_WAIT, SQ_SEC_WAIT,
                                      SQ_CON_PLAY, SQ_CON_DONE,
                                      SQ_CON_WAIT };

    DWORD dwIX;
    HRESULT hr;
    CSegState *pSegNode;
    ENTER_API_CRITICAL_SECTION;
    if (dwTrackID)
    {
        ENTER_CRITICAL_SECTION(&m_SegmentCrSec);
        for (dwIX = 0; dwIX < SQ_COUNT; dwIX++)
        {
            pSegNode = m_SegStateQueues[dwSearchOrder[dwIX]].GetHead();
            for (;pSegNode;pSegNode = pSegNode->GetNext())
            {
                if ((pSegNode->m_dwFirstTrackID <= dwTrackID) && 
                    (pSegNode->m_dwLastTrackID >= dwTrackID))
                {
                    CTrack* pCTrack;
                    for (pCTrack = pSegNode->m_TrackList.GetHead();pCTrack;pCTrack = pCTrack->GetNext())
                    {
                        if (pCTrack->m_dwVirtualID == dwTrackID)
                        {
                            m_dwGetParamFlags = pCTrack->m_dwFlags;
                            m_pGetParamSegmentState = pSegNode;
                            break;
                        }
                    }
                    break;
                } 
            }
        }
        LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);
    }
    else
    {
        m_pGetParamSegmentState = NULL;
        m_dwGetParamFlags = 0;
    }
    hr = GetParam(rguidType,dwGroupBits,dwIndex,mtTime,pmtNext,pData);
    m_pGetParamSegmentState = NULL;
    m_dwGetParamFlags = 0;
    LEAVE_API_CRITICAL_SECTION;
    return hr;
}

HRESULT STDMETHODCALLTYPE CPerformance::GetParam(
    REFGUID rguidType,  
    DWORD dwGroupBits,      
    DWORD dwIndex,
    MUSIC_TIME mtTime,
    MUSIC_TIME* pmtNext,
    void* pData)

{
    V_INAME(IDirectMusicPerformance::GetParam);
    V_PTR_WRITE_OPT(pmtNext,MUSIC_TIME);
    V_PTR_WRITE_OPT(pData,1);
    V_REFGUID(rguidType);

    ENTER_CRITICAL_SECTION(&m_MainCrSec);
    if( m_pClock == NULL )
    {
        LEAVE_CRITICAL_SECTION(&m_MainCrSec);
        Trace(0,"Error: GetParam() failed because the performance has not been initialized.\n");
        return DMUS_E_NO_MASTER_CLOCK;
    }
    LEAVE_CRITICAL_SECTION(&m_MainCrSec);

    if( pmtNext )
    {
        *pmtNext = 0; // this will be replaced by calls to IDMSegment::GetParam
    }
    CSegState* pSegNode;
    CSegState* pSegSource = (CSegState *) m_pGetParamSegmentState;
    DWORD dwOverrideFlags;
    HRESULT hr = DMUS_E_NOT_FOUND;
    BOOL fCheckedPast = FALSE;
    MUSIC_TIME mtOffset;
    DWORD dwRepeat = 0;
    MUSIC_TIME mtSegTime = 0;
    MUSIC_TIME mtSegEnd = 0;
    MUSIC_TIME mtLoopEnd = 0;
    DWORD dwRepeatsLeft = 0;
    if (pSegSource) 
    {
        dwOverrideFlags = m_dwGetParamFlags & (DMUS_TRACKCONFIG_OVERRIDE_ALL | DMUS_TRACKCONFIG_OVERRIDE_PRIMARY | DMUS_TRACKCONFIG_FALLBACK);
    }
    else
    {
        dwOverrideFlags = 0;
    }

    if (dwOverrideFlags & DMUS_TRACKCONFIG_OVERRIDE_ALL)
    {
        // The calling track wants the controlling param to come from the segment itself 
        mtSegTime = mtTime;
        if( S_OK == pSegSource->ConvertToSegTime( &mtSegTime, &mtOffset, &dwRepeat ) )
        {
            hr = pSegSource->GetParam( this, rguidType, dwGroupBits, dwIndex, 
                    mtSegTime, pmtNext, pData );
            if( SUCCEEDED(hr) )
            {
                dwRepeatsLeft = pSegSource->m_dwRepeats;
                mtLoopEnd = pSegSource->m_mtLoopEnd;
                mtSegEnd = pSegSource->m_mtLength;
                dwRepeatsLeft -= dwRepeat;
            }
        }       
    }
    if (FAILED(hr))
    {
        ENTER_CRITICAL_SECTION(&m_SegmentCrSec);
        // we only care about control segments
        if( m_SegStateQueues[SQ_CON_DONE].GetHead() )
        {
            pSegNode = m_SegStateQueues[SQ_CON_DONE].GetHead();
        }
        else
        {
            pSegNode = m_SegStateQueues[SQ_CON_PLAY].GetHead();
            fCheckedPast = TRUE;
        }
        while( pSegNode )
        {
            mtSegTime = mtTime;
            if( S_OK == pSegNode->ConvertToSegTime( &mtSegTime, &mtOffset, &dwRepeat ) )
            {
                hr = pSegNode->GetParam( this, rguidType, dwGroupBits, dwIndex, 
                        mtSegTime, pmtNext, pData );
                if( SUCCEEDED(hr) )
                {
                    dwRepeatsLeft = pSegNode->m_dwRepeats;
                    mtLoopEnd = pSegNode->m_mtLoopEnd;
                    mtSegEnd = pSegNode->m_mtLength;
                    dwRepeatsLeft -= dwRepeat;
                
                    break; // got the param we want. We're outta this loop with a success.
                }
            }
            // we didn't find the param, so try the next segment.
            pSegNode = pSegNode->GetNext();

            // if we're the last segnode in the done queue, we need to 
            // check against the time of the first segnode in the control play queue
            if (!pSegNode && !fCheckedPast )
            {
                pSegNode = m_SegStateQueues[SQ_CON_PLAY].GetHead();
                fCheckedPast = TRUE;
            }
        }
        LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);
    }

    if( FAILED(hr) && (dwOverrideFlags & DMUS_TRACKCONFIG_OVERRIDE_PRIMARY))
    {
        // The calling track wants the controlling param to come from the segment 
        // itself if there was no controlling segment.
        mtSegTime = mtTime;
        if( S_OK == pSegSource->ConvertToSegTime( &mtSegTime, &mtOffset, &dwRepeat ) )
        {
            hr = pSegSource->GetParam( this, rguidType, dwGroupBits, dwIndex, 
                    mtSegTime, pmtNext, pData );
            if( SUCCEEDED(hr) )
            {
                dwRepeatsLeft = pSegSource->m_dwRepeats;
                mtLoopEnd = pSegSource->m_mtLoopEnd;
                mtSegEnd = pSegSource->m_mtLength;
                dwRepeatsLeft -= dwRepeat;
            }
        }       
    }

    if( FAILED(hr) ) // didn't find one in the previous, so check for a primary segment
    {
        IDirectMusicSegment* pSegment = NULL;
        mtSegTime = mtTime;
        ENTER_CRITICAL_SECTION(&m_SegmentCrSec);
        pSegNode = GetPrimarySegmentAtTime( mtTime );
        if( pSegNode )
        {
            pSegment = pSegNode->m_pSegment;
            pSegment->AddRef();
            pSegNode->ConvertToSegTime( &mtSegTime, &mtOffset, &dwRepeat );
            dwRepeatsLeft = pSegNode->m_dwRepeats;
            mtLoopEnd = pSegNode->m_mtLoopEnd;
            mtSegEnd = pSegNode->m_mtLength;
            dwRepeatsLeft -= dwRepeat;
        }
        else
        {
            Trace(4, "Couldn't find SegState in GetParam call.\n");
        }
        LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);
        if( pSegment )
        {
            hr = pSegNode->GetParam( this, rguidType, dwGroupBits, dwIndex, 
                    mtSegTime, pmtNext, pData );
            pSegment->Release();
        }
    }
    
    if( FAILED(hr) && (dwOverrideFlags & DMUS_TRACKCONFIG_FALLBACK))
    {
        // The calling track wants the controlling param to come from the segment itself 
        mtSegTime = mtTime;
        if( S_OK == pSegSource->ConvertToSegTime( &mtSegTime, &mtOffset, &dwRepeat ) )
        {
            hr = pSegSource->GetParam( this, rguidType, dwGroupBits, dwIndex, 
                    mtSegTime, pmtNext, pData );
            if( SUCCEEDED(hr) )
            {
                dwRepeatsLeft = pSegSource->m_dwRepeats;
                mtLoopEnd = pSegSource->m_mtLoopEnd;
                mtSegEnd = pSegSource->m_mtLength;
                dwRepeatsLeft -= dwRepeat;
            }
        }       
    }

    if( FAILED(hr) )
    {   // If we failed, fill in the end time of loop or segment anyway. 
        if (pmtNext) 
        {   // Check to see if the loop end is earlier than end of segment.
            if (dwRepeatsLeft && (mtLoopEnd > mtSegTime))
            {
                *pmtNext = mtLoopEnd - mtSegTime;                
            }
            else // Or, mark end of segment.
            {
                *pmtNext = mtSegEnd - mtSegTime; 
            }
        }
        // if we're looking for timesig, and didn't find it anywhere,
        // return the Performance timesig
        if( rguidType == GUID_TimeSignature )
        {
            if( NULL == pData )
            {
                Trace(0,"Error: Null pointer for time signature passed to GetParam().\n");
                hr = E_POINTER;
            }
            else
            {
                DMUS_TIMESIGNATURE* pTSigData = (DMUS_TIMESIGNATURE*)pData;
                DMUS_TIMESIG_PMSG timeSig;

                GetTimeSig( mtTime, &timeSig );
                pTSigData->bBeatsPerMeasure = timeSig.bBeatsPerMeasure;
                pTSigData->bBeat = timeSig.bBeat;
                pTSigData->wGridsPerBeat = timeSig.wGridsPerBeat;
                pTSigData->mtTime = timeSig.mtTime - mtTime;
                hr = S_OK;
            }
        }
        // Likewise, if there was no tempo in a segment, we need to read directly from the tempo list.
        else if  ( rguidType == GUID_TempoParam || rguidType == GUID_PrivateTempoParam)
        {
            if( NULL == pData )
            {
                Trace(0,"Error: Null pointer for tempo passed to GetParam().\n");
                hr = E_POINTER;
            }
            else 
            {
                DMInternalTempo* pInternalTempo;
                ENTER_CRITICAL_SECTION( &m_PipelineCrSec );
                pInternalTempo = (DMInternalTempo*)m_TempoMap.GetHead();
                DMInternalTempo* pNextTempo = NULL;
                for ( ;pInternalTempo;pInternalTempo = pNextTempo )
                {
                    pNextTempo = (DMInternalTempo *) pInternalTempo->pNext;
                    if (pNextTempo && (pNextTempo->tempoPMsg.mtTime <= mtTime))
                    {
                        continue;
                    }
                    if (rguidType == GUID_TempoParam)
                    {
                        DMUS_TEMPO_PARAM* pTempoData = (DMUS_TEMPO_PARAM*)pData;
                        pTempoData->mtTime = pInternalTempo->tempoPMsg.mtTime - mtTime;
                        pTempoData->dblTempo = pInternalTempo->tempoPMsg.dblTempo;
                    }
                    else // rguidType == GUID_PrivateTempoParam
                    {
                        PrivateTempo* pTempoData = (PrivateTempo*)pData;
                        pTempoData->mtTime = pInternalTempo->tempoPMsg.mtTime - mtTime;
                        pTempoData->dblTempo = pInternalTempo->tempoPMsg.dblTempo;
                    }
                    if( pmtNext )
                    {
                        *pmtNext = 0;
                    }
                    break;
                }
                LEAVE_CRITICAL_SECTION( &m_PipelineCrSec );
                if (pInternalTempo)
                {
                    hr = S_FALSE;
                }
            }
        }
    }
    else // GetParam from a segment succeeded, so we need to clean up the next time parameter to account
         // for loops and end of segment.
    {
        if (pmtNext) // Check to see if the loop end is earlier than *pmtNext.
        {
            if (dwRepeatsLeft && (*pmtNext > (mtLoopEnd - mtSegTime)))
            {
                if (mtLoopEnd >= mtSegTime) // This should always be true, but test anyway.
                {
                    *pmtNext = mtLoopEnd - mtSegTime;                
                }
            }
        }
    }
#ifdef DXAPI
    ENTER_CRITICAL_SECTION(&m_MainCrSec);
    if (m_pParamHook && SUCCEEDED(hr))
    {
        hr = m_pParamHook->GetParam(rguidType,dwGroupBits,dwIndex,mtTime,pmtNext,pData,
            pSegSource,m_dwGetParamFlags,hr);
        
    }
    LEAVE_CRITICAL_SECTION(&m_MainCrSec);
#endif
    return hr;
}



/*
  @method HRESULT | IDirectMusicPerformance | SetParam |
  Sets data on a Track inside a Primary Segment in this Performance.

  @rvalue S_OK | Success.
  @rvalue DMUS_E_NO_MASTER_CLOCK | There is no master clock in the performance.
  Make sure to call <om .Init> before calling this method.
*/
HRESULT STDMETHODCALLTYPE CPerformance::SetParam(
    REFGUID rguidType,      // @parm The type of data to set.
    DWORD dwGroupBits,      // @parm The group the desired track is in. Use 0xffffffff 
                            // for all groups.
    DWORD dwIndex,          // @parm Identifies which track, by index, in the group 
                            // identified by <p dwGroupBits> to set the data.
    MUSIC_TIME mtTime,      // @parm The time at which to set the data. Unlike
                            // <om IDirectMusicSegment.SetParam>, this time is in
                            // performance time. The start time of the segment is
                            // subtracted from this time, and <om IDirectMusicSegment.SetParam>
                            // is called.
    void* pData)            // @parm The struture containing the data to set. Each
                            // <p pGuidType> identifies a particular structure of a
                            // particular size. It is important that this field contain
                            // the correct structure of the correct size. Otherwise,
                            // fatal results can occur.
{
    V_INAME(IDirectMusicPerformance::SetParam);
    V_PTR_WRITE_OPT(pData,1);
    V_REFGUID(rguidType);

    ENTER_CRITICAL_SECTION(&m_MainCrSec);
    if( m_pClock == NULL )
    {
        LEAVE_CRITICAL_SECTION(&m_MainCrSec);
        Trace(0,"Error: SetParam() failed because the performance has not been initialized.\n");
        return DMUS_E_NO_MASTER_CLOCK;
    }
    LEAVE_CRITICAL_SECTION(&m_MainCrSec);

    CSegState* pSegNode;
    IDirectMusicSegment* pSegment = NULL;
    HRESULT hr;

    ENTER_CRITICAL_SECTION(&m_SegmentCrSec);
    pSegNode = GetPrimarySegmentAtTime( mtTime );

    MUSIC_TIME mtOffset;
    DWORD dwRepeat;
    if( pSegNode )
    {
        pSegment = pSegNode->m_pSegment;
        pSegment->AddRef();
        pSegNode->ConvertToSegTime( &mtTime, &mtOffset, &dwRepeat );
    }
    LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);
    if( pSegment )
    {
        hr = pSegment->SetParam( rguidType, dwGroupBits, dwIndex, 
                mtTime, pData );
        pSegment->Release();
    }
    else
    {
        Trace(2,"Error: SetParam failed because there is no segment at requested time.\n");
        hr = DMUS_E_NOT_FOUND;
    }
    return hr;
}

/*
  @method HRESULT | IDirectMusicPerformance | GetGlobalParam |
  Gets global values from the Performance.

  @rvalue S_OK | Success.
  @rvalue E_INVALIDARG | <p pGuidType> isn't in the list of global data being handled by this
  Performance. Make sure to call <om IDirectMusicPerformance.SetGlobalParam> first.  Or,
  the value of <p pData> doesn't point to valid memory. Or, <p dwSize> isn't the size 
  originally given in <om .SetGlobalParam>
  @rvalue E_POINTER | <p pData> is NULL or invalid.

  @xref <om .SetGlobalParam>
*/
HRESULT STDMETHODCALLTYPE CPerformance::GetGlobalParam(
    REFGUID rguidType,  // @parm Identifies the type of data.
    void* pData,        // @parm Allocated memory to receive a copy of the data. This must be
                        // the correct size, which is constant for each <p pGuidType> type of
                        // data, and was also passed in to <om .SetGlobalParam>.
    DWORD dwSize        // @parm The size of the data in <p pData>. This should be constant for each 
                        // <p pGuidType>. This parameter is needed because the Performance doesn't
                        // know about all types of data, allowing new ones to be created as needed.
    )
{
    V_INAME(IDirectMusicPerformance::GetGlobalParam);
    V_REFGUID(rguidType);

    if( dwSize )
    {
        V_BUFPTR_WRITE( pData, dwSize );
    }

    GlobalData* pGD;
    HRESULT hr = S_OK;
    ENTER_CRITICAL_SECTION(&m_GlobalDataCrSec); 
    ENTER_API_CRITICAL_SECTION;
    for( pGD = m_pGlobalData; pGD; pGD = pGD->pNext )
    {
        if( pGD->guidType == rguidType )
        {
            break;
        }
    }
    if( pGD && ( dwSize == pGD->dwSize ) )
    {
        memcpy( pData, pGD->pData, pGD->dwSize );
    }
    else
    {
#ifdef DBG
        if (pGD && ( dwSize != pGD->dwSize ))
        {
            Trace(1,"Error: GetGlobalParam() failed because the passed data size %ld was inconsistent with %ld, set previously.\n",
                dwSize, pGD->dwSize);
        }
        else
        {
            Trace(4,"Warning: GetGlobalParam() failed because the parameter had never been set.\n");
        }
#endif
        hr = E_INVALIDARG;
    }
    LEAVE_CRITICAL_SECTION(&m_GlobalDataCrSec);
    LEAVE_API_CRITICAL_SECTION;
    return hr;
}

/*
  @method HRESULT | IDirectMusicPerformance | SetGlobalParam |
  Set global values on the Performance.

  @rvalue S_OK | Success.
  @rvalue E_POINTER | <p pData> is NULL or invalid.
  @rvalue E_OUTOFMEMORY | Ran out of memory.
  @rvalue E_INVALIDARG | Other failure. pData or dwSize not correct?

  @xref <om .GetGlobalParam>
*/
HRESULT STDMETHODCALLTYPE CPerformance::SetGlobalParam(
    REFGUID rguidType,  // @parm Identifies the type of data.
    void* pData,        // @parm The data itself, which will be copied and stored by the Performance.
    DWORD dwSize        // @parm The size of the data in <p pData>. This should be constant for each 
                        // <p pGuidType>. This parameter is needed because the Performance doesn't
                        // know about all types of data, allowing new ones to be created as needed.
    )
{
    V_INAME(IDirectMusicPerformance::SetGlobalParam);
    V_REFGUID(rguidType);

    if( dwSize )
    {
        V_BUFPTR_READ( pData, dwSize );
    }
    GlobalData* pGD;
    // see if this is one of our special Performance globals
    if( rguidType == GUID_PerfMasterTempo )
    {
        if( dwSize == sizeof(float) )
        {
            float flt;
            memcpy( &flt, pData, sizeof(float) );
            if( (flt >= DMUS_MASTERTEMPO_MIN) && (flt <= DMUS_MASTERTEMPO_MAX) )
            {
                if( m_fltRelTempo != flt )
                {
                    m_fltRelTempo = flt;
                    // It's only necessary to recalc the tempo map if something is playing
                    ENTER_CRITICAL_SECTION(&m_SegmentCrSec);
                    if (GetPrimarySegmentAtTime(m_mtTransported))
                    {
                        RecalcTempoMap(NULL,m_mtTransported);
                    }
                    LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);
                }
            }
        }
        else
        {
            Trace(1,"Error: Attempt to set global tempo failed because dwSize is not size of float.\n");
            return E_INVALIDARG;
        }
    }
    else if( rguidType == GUID_PerfMasterVolume )
    {
        // master volume
        if( dwSize == sizeof(long) )
        {
            memcpy( &m_lMasterVolume, pData, sizeof(long) );
        }
        else
        {
            Trace(1,"Error: Attempt to set global volume failed because dwSize is not size of long.\n");
            return E_INVALIDARG;
        }
#ifdef DXAPI
        // Go through all Ports and set the master volume.
        // This is also done upon adding a Port.
        DWORD dw;

        ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);
        ENTER_API_CRITICAL_SECTION;
        for( dw = 0; dw < m_dwNumPorts; dw++ )
        {
            IDirectMusicPort* pPort = m_pPortTable[dw].pPort;
            if( pPort )
            {
                IKsControl *pControl;
                if(SUCCEEDED(pPort->QueryInterface(IID_IKsControl, (void**)&pControl)))
                {
                    KSPROPERTY ksp;
                    ULONG cb;

                    memset(&ksp, 0, sizeof(ksp));
                    ksp.Set   = GUID_DMUS_PROP_Volume;
                    ksp.Id    = 0;
                    ksp.Flags = KSPROPERTY_TYPE_SET;

                    pControl->KsProperty(&ksp,
                                         sizeof(ksp),
                                         (LPVOID)&m_lMasterVolume,
                                         sizeof(m_lMasterVolume),
                                         &cb);
                    pControl->Release();
                }
            }
        }
        LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);
        LEAVE_API_CRITICAL_SECTION;
#else
        m_pSynth->SetMasterVolume(m_lMasterVolume);
#endif
    }

    // see if this type is already there. If so, use it.
    ENTER_CRITICAL_SECTION(&m_GlobalDataCrSec); 
    ENTER_API_CRITICAL_SECTION;
    for( pGD = m_pGlobalData; pGD; pGD = pGD->pNext )
    {
        if( pGD->guidType == rguidType )
        {
            break;
        }
    }
    LEAVE_CRITICAL_SECTION(&m_GlobalDataCrSec);
    LEAVE_API_CRITICAL_SECTION;
    // if it already exists, just copy the new data into the
    // existing memory block and return
    if( pGD )
    {
        if( pGD->dwSize != dwSize )
        {
            Trace(1,"Error: Attempt to set global parameter failed because dwSize is not consistent with previous SetGlobalParam() call.\n");
            return E_INVALIDARG;
        }
        if( dwSize )
        {
            memcpy( pGD->pData, pData, dwSize );
        }
        return S_OK;
    }

    // otherwise, create new memory
    pGD = new GlobalData;
    if( NULL == pGD )
    {
        return E_OUTOFMEMORY;
    }
    pGD->dwSize = dwSize;
    if( dwSize )
    {
        pGD->pData = (void*)(new char[dwSize]);
        if( NULL == pGD->pData )
        {
            delete pGD;
            return E_OUTOFMEMORY;
        }
        memcpy( pGD->pData, pData, dwSize );
    }
    else
    {
        pGD->pData = NULL;
    }
    pGD->guidType = rguidType;
    ENTER_CRITICAL_SECTION(&m_GlobalDataCrSec); // just using this one since it's available and not used much
    pGD->pNext = m_pGlobalData;
    m_pGlobalData = pGD;
    LEAVE_CRITICAL_SECTION(&m_GlobalDataCrSec);
    return S_OK;
}

// IDirectMusicTool
/*
  @method HRESULT | IDirectMusicTool | Init |
  Called when the Tool is inserted into the Graph, providing the Tool the opportunity
  to initialize itself.

  @rvalue S_OK | Success.
  @rvalue E_NOTIMPL | Not implemented is a valid return for the method.
*/
HRESULT STDMETHODCALLTYPE CPerformance::Init(
         IDirectMusicGraph* pGraph  // @parm The calling graph.
    )
{
    return E_NOTIMPL;
}

#ifdef DXAPI
bool CPerformance::SendShortMsg( IDirectMusicBuffer* pBuffer,
                                   IDirectMusicPort* pPort,DWORD dwMsg,
                                   REFERENCE_TIME rt, DWORD dwGroup)

{
    if( FAILED( pBuffer->PackStructured( rt, dwGroup, dwMsg ) ) )
    {
        // ran out of room in the buffer
        TraceI(2, "RAN OUT OF ROOM IN THE BUFFER!\n");
        pPort->PlayBuffer( pBuffer );
        pBuffer->Flush();
        // try one more time
        if( FAILED( pBuffer->PackStructured( rt, dwGroup, dwMsg ) ) )
        {
            TraceI(1, "MAJOR BUFFER PACKING FAILURE!\n");
            // if it didn't work this time, free the event because something
            // bad has happened.
            return false;
        }
    }
    return true;
}
#else
void CPerformance::SendLongMsg(BYTE *pbMsg, DWORD dwLength, REFERENCE_TIME rt, DWORD dwGroup)
{
    if (m_pSynth)
    {
        m_pSynth->SendLongMsg(rt,dwGroup,pbMsg,dwLength);
    }
}

#endif

//////////////////////////////////////////////////////////////////////
// CPerformance::PackNote
/*
  HRESULT | CPerformance | PackNote |
  Converts the message into a midiShortMsg, midiLongMsg, or user message 
  and packs it into the appropriate IDirectMusicBuffer in the PortTable,
  setting the m_fBufferFilled flag.

  DMUS_PMSG* | pPMsg |
  [in] The message to pack into the buffer.

  REFERENCE_TIME | mt |
  [in] The time (in the Buffer's clock coordinates) at which to queue the message.

  E_INVALIDARG | Either pPMsg or pBuffer is NULL.
  E_OUTOFMEMORY | Failed to pack the buffer.
  DMUS_S_REQUEUE | Tells the Pipeline to requeue this message.
  DMUS_S_FREE | Tells the Pipeline to free this message.
*/
HRESULT CPerformance::PackNote(
            DMUS_PMSG* pEvent,
            REFERENCE_TIME rt ) 
{
    DMUS_NOTE_PMSG* pNote = (DMUS_NOTE_PMSG*)pEvent;
    PRIV_PMSG* pPriv = DMUS_TO_PRIV(pEvent);
    REFERENCE_TIME rtLogical; // the time the note occurs in logical music time (subtract offset)
    IDirectMusicBuffer* pBuffer = NULL;
    IDirectMusicPort* pPort = NULL;
    DWORD dwMsg;
    DWORD dwGroup, dwMChannel, dwPortTableIndex;
    short nTranspose = 0;
    short nValue;
    HRESULT hr = DMUS_S_FREE;

    if( NULL == pEvent )
        return E_INVALIDARG;

    if( FAILED( PChannelIndex( pNote->dwPChannel, &dwPortTableIndex, &dwGroup, &dwMChannel,
        &nTranspose )))
    {
        Trace(1,"Play note failed on unassigned PChannel %ld\n",pNote->dwPChannel);
        return DMUS_S_FREE; // the PChannel map wasn't found. Just free the event.
    }
#ifdef DXAPI
    ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);
    if( dwPortTableIndex > m_dwNumPorts )
    {
        pPort = NULL; // the PChannel map is out of range of the number of ports
                    // so return outta here! (see after the LEAVE_CRITICAL_SECTION)
    }
    else
    {
        pPort = m_pPortTable[dwPortTableIndex].pPort;
        if( pPort ) pPort->AddRef();
        pBuffer = m_pPortTable[dwPortTableIndex].pBuffer;
        if( pBuffer ) pBuffer->AddRef();
    }
    LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);
    if(pPort && pBuffer )
#endif
    {
        dwMsg = 0;
        if( pNote->bFlags & DMUS_NOTEF_NOTEON )
        {
            // transpose the note's bMidiValue, and store it in the note so the note off
            // plays the correct pitch.
            nValue = pNote->bMidiValue + nTranspose;
            if( ( nValue > 127 ) || ( nValue < 0 ) 
                || pNote->mtDuration <= 0 )
            {
                // don't play this out-of-range or 0-duration note
#ifdef DXAPI
                pPort->Release();
                pBuffer->Release();
#endif
                return DMUS_S_FREE;
            }
            pNote->bMidiValue = (BYTE)nValue;
            dwMsg |= pNote->bVelocity << 16;
        }
        else if( rt < pPriv->rtLast )
        {
            // the note off will play before the note on. Bad.
            rt = pPriv->rtLast + REF_PER_MIL;
        }
        dwMsg |= pNote->bMidiValue << 8; // set note value
        dwMsg |= dwMChannel; // MIDI Channel
        if( pNote->bFlags & DMUS_NOTEF_NOTEON )
        {
            dwMsg |= MIDI_NOTEON;
#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
            m_dwTempNotesPerSecond++;
            UpdateDebugParams();
#endif
        }
        else
        {
            dwMsg |= MIDI_NOTEOFF;
        }
        if (SendShortMsg(pBuffer,pPort,dwMsg,rt-2,dwGroup))
        {
            ENTER_CRITICAL_SECTION(&m_PipelineCrSec); // to prevent deadlock in MusicToReferenceTime
            ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);
#ifdef DXAPI
            m_pPortTable[dwPortTableIndex].fBufferFilled = TRUE; // so we send this in SendBuffers
#endif
            rtLogical = rt;
            // subtract the offset if needed, but only for a note on.
            if( pNote->nOffset && (pNote->bFlags & DMUS_NOTEF_NOTEON))
            {
                MUSIC_TIME mtTemp = pNote->mtTime - pNote->nOffset + 1;
                REFERENCE_TIME rtTemp;
                MusicToReferenceTime( mtTemp, &rtTemp );
                if( rtTemp > rtLogical )
                {
                    rtLogical = rtTemp;
                }
            }
#ifdef DXAPI
            if( m_pPortTable[dwPortTableIndex].rtLast < rtLogical )
            {
                m_pPortTable[dwPortTableIndex].rtLast = rtLogical;
            }
#else
            if (m_rtLastSendTime < rtLogical)
            {
                m_rtLastSendTime = rtLogical;
            }
#endif
            LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);
            LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);

            if( pNote->bFlags & DMUS_NOTEF_NOTEON )
            {
                pPriv->rtLast = rt;
                m_rtHighestPackedNoteOn = rt;
                if (pNote->dwFlags & DMUS_PMSGF_LOCKTOREFTIME)
                {
                    // This is a clock time message. 
                    REFERENCE_TIME rt = pNote->rtTime;
                    pNote->rtTime += (pNote->mtDuration * REF_PER_MIL);
                    if (pNote->mtDuration > 1)
                    {
                        pNote->rtTime -= REF_PER_MIL;
                    }
                    // subtract 1 to guarantee that a note off at the same time as a note on doesn't
                    // stop the note on short. It's possible that rt == pNote->rtTime, if the duration
                    // was zero, so be sure to check that.
                    if( pNote->rtTime < rt + 1 )
                    {
                        pNote->rtTime = rt + 1;
                    }
                    pNote->bFlags &= ~DMUS_NOTEF_NOTEON; // make this a note off now
                    pNote->dwFlags &= ~DMUS_PMSGF_MUSICTIME; 
                    hr = DMUS_S_REQUEUE;
                }
                else
                {
                    pNote->mtTime += pNote->mtDuration;
                    if (pNote->mtDuration > 1)
                    {
                        pNote->mtTime--;
                    }
                    MusicToReferenceTime( pNote->mtTime, &rt );
                    // subtract 1 to guarantee that a note off at the same time as a note on doesn't
                    // stop the note on short. It's possible that rt == pNote->rtTime, if the duration
                    // was zero, so be sure to check that.
                    if( rt < pNote->rtTime + 2 )
                    {
                        rt = pNote->rtTime + 2;
                    }
                    pNote->rtTime = rt - 1;
                }
                pNote->bFlags &= ~DMUS_NOTEF_NOTEON; // make this a note off now
                hr = DMUS_S_REQUEUE;
            }
        }
    }
    if( pPort ) pPort->Release();
    if( pBuffer ) pBuffer->Release();
    return hr;
}

#define DMUS_CURVE_STARTED  0x80        // Set this on the curve once it has been entered.

//////////////////////////////////////////////////////////////////////
// CPerformance::PackCurve
HRESULT CPerformance::PackCurve(
            DMUS_PMSG* pEvent, 
            REFERENCE_TIME rt )
{
    DMUS_CURVE_PMSG* pCurve = (DMUS_CURVE_PMSG*)pEvent;
    IDirectMusicBuffer* pBuffer = NULL;
    IDirectMusicPort* pPort = NULL;
    DWORD dwMsg;
    HRESULT hr = DMUS_S_FREE;
    BOOL fCalcStartValue = FALSE;
    BOOL fIsStartOfCurve = FALSE;
    CChannelMap *pChannelMap = NULL;

    if( NULL == pEvent )
        return E_INVALIDARG;

    if ( !(pCurve->bFlags & DMUS_CURVE_STARTED))
    {
        fIsStartOfCurve = TRUE;
        pCurve->bFlags |= DMUS_CURVE_STARTED;
        // if we're flushing and have never played this curve at all, just free
        // it.
        if( pCurve->dwFlags & DMUS_PMSGF_TOOL_FLUSH )
        {
            return DMUS_S_FREE;
        }
        if (pCurve->dwFlags & DMUS_PMSGF_LOCKTOREFTIME)
        {
            // This is a clock time message. Convert the duration into music time. It will act as 
            // a music time message from now on. This does have the downside that if a dramatic tempo
            // change occurs in the middle of a lengthy curve, the end time can be distorted. 
            // But, given the purpose of curves, this is really an unlikely issue.
            MUSIC_TIME mtTemp;
            ReferenceToMusicTime(pCurve->rtTime + (pCurve->mtDuration * REF_PER_MIL),&mtTemp);
            mtTemp -= pCurve->mtTime;
            pCurve->mtDuration = mtTemp;
            ReferenceToMusicTime(pCurve->rtTime + (pCurve->mtResetDuration * REF_PER_MIL),&mtTemp);
            mtTemp -= pCurve->mtTime;
            pCurve->mtResetDuration = mtTemp;
            pCurve->dwFlags &= ~DMUS_PMSGF_LOCKTOREFTIME;
        }
        // store the original start time so we know how far into the curve we are
        if (!pCurve->mtOriginalStart)
        {
            pCurve->mtOriginalStart = pCurve->mtTime;
        }
        // check the latency clock. Adjust pCurve->mtTime if needed. This can happen
        // if the curve is time-stamped for the past. We only need do this for non-instant
        // curve types.
        if( pCurve->bCurveShape != DMUS_CURVES_INSTANT )
        {
            REFERENCE_TIME rtLatency = GetLatency();
            MUSIC_TIME mtLatency;
            ReferenceToMusicTime( rtLatency, &mtLatency );
            if( pCurve->mtTime < mtLatency )
            {
                if( pCurve->mtTime + pCurve->mtDuration < mtLatency )
                {
                    // If it is far enough in the past,
                    // we only need to send out the final value.
                    pCurve->mtTime += pCurve->mtDuration;
                }
                else
                {
                    pCurve->mtTime = mtLatency;
                }
            }
            // If this is the start of a curve and we are supposed to start with the current playing value...
            if (pCurve->bFlags & DMUS_CURVE_START_FROM_CURRENT)
            {
                fCalcStartValue = TRUE;
            }
            else
            {
                pCurve->wMeasure = (WORD) ComputeCurveTimeSlice(pCurve);    // Use this to store the time slice interval.
            }
        }
    }
    // it is necessary to check reset duration >= 0 because it could have been set
    // to be negative by the flushing, and we don't want to toss it in that case.
    // (should no longer be necessary to check, as a result of fixing 33987)
    if( ( pCurve->bFlags & DMUS_CURVE_RESET ) && (pCurve->mtResetDuration >= 0) && ( pCurve->mtTime == 
        pCurve->mtDuration + pCurve->mtResetDuration + pCurve->mtOriginalStart ))
    {
        if( !( pCurve->dwFlags & DMUS_PMSGF_TOOL_FLUSH ) )
        {
            PRIV_PMSG* pPrivPMsg = DMUS_TO_PRIV(pEvent);
            if ( (pPrivPMsg->dwPrivFlags & PRIV_FLAG_FLUSH) )
            {
                pPrivPMsg->dwPrivFlags &= ~PRIV_FLAG_FLUSH;
                pCurve->dwFlags |= DMUS_PMSGF_TOOL_FLUSH;
                MUSIC_TIME mt = 0;
                if( rt <= pPrivPMsg->rtLast )
                {
                    return PackCurve( pEvent, pPrivPMsg->rtLast + REF_PER_MIL );
                }
                else
                {
                    return PackCurve( pEvent, rt );
                }
            }
            else
            {
                // the reset duration has expired, and we're not flushing, so expire the event.
                return DMUS_S_FREE;
            }
        }
    }
    ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);
    pChannelMap = GetPChannelMap(pCurve->dwPChannel);
    if (!pChannelMap)
    {
        Trace(1,"Play curve failed on unassigned PChannel %ld\n",pCurve->dwPChannel);
        LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);
        return DMUS_S_FREE; // the PChannel map wasn't found. Just free the event.
    }
#ifdef DXAPI
    if( pChannelMap->dwPortIndex > m_dwNumPorts )
    {
        pPort = NULL; // the PChannel map is out of range of the number of ports
                    // so return outta here! (see after the LEAVE_CRITICAL_SECTION)
    }
    else
    {
        pPort = m_pPortTable[pChannelMap->dwPortIndex].pPort;
        if( pPort ) pPort->AddRef();
        pBuffer = m_pPortTable[pChannelMap->dwPortIndex].pBuffer;
        if( pBuffer ) pBuffer->AddRef();
    }
    if( pPort && pBuffer)
#endif
    {
        DWORD dwCurve;
        DWORD dwMergeIndex = 0;
        dwMsg = 0; 
        if (pCurve->dwFlags & DMUS_PMSGF_DX8)
        {
            dwMergeIndex = pCurve->wMergeIndex;
        }
        switch( pCurve->bType )
        {
        case DMUS_CURVET_PBCURVE:
            if (fIsStartOfCurve)
            {
                // This is the start of the curve, so convert all values to 
                // pitch cents (100ths of a semitone). The pitch range is set
                // to this in the synth and we trap all calls to set the range
                // and store the value in pChannelMap->m_PitchbendMerger.m_lBendRange.
                long lRange = pCurve->wParamType;   // Store the range here.
                pCurve->wParamType = 0;             // Make sure this now reflects full range.
                if (!lRange)
                {   
                    lRange = pChannelMap->m_PitchbendMerger.m_lBendRange;
                }

                if (!fCalcStartValue)
                {
                    long lTemp = pCurve->nStartValue - 0x2000;
                    lTemp *= lRange;
                    lTemp += 0x1000;    // handle rounding up.
                    lTemp /= 0x2000;
                    pCurve->nStartValue = (short) (lTemp + 0x2000);
                }
                long lTemp = pCurve->nEndValue - 0x2000;
                lTemp *= lRange;
                lTemp += 0x1000;        // handle rounding up.
                lTemp /= 0x2000;
                pCurve->nEndValue = (short) (lTemp + 0x2000);
            }
            if (fCalcStartValue)
            {
                pCurve->nStartValue = 
                    (short) pChannelMap->m_PitchbendMerger.GetIndexedValue(dwMergeIndex) + 0x2000;
            }
            dwCurve = ComputeCurve( pCurve );
            dwCurve = pChannelMap->m_PitchbendMerger.MergeValue(dwMergeIndex,(long)dwCurve,0x2000,0x3FFF);
            dwMsg = MIDI_PBEND;
            dwMsg |= ( (dwCurve & 0x7F) << 8);
            dwCurve = dwCurve >> 7;
            dwMsg |= ( (dwCurve & 0x7F) << 16);
            break;
        case DMUS_CURVET_CCCURVE:
            switch (pCurve->bCCData)
            {
            case MIDI_CC_MOD_WHEEL:
                if (fCalcStartValue)
                {
                    pCurve->nStartValue = 
                        (short) pChannelMap->m_ModWheelMerger.GetIndexedValue(dwMergeIndex) + 0x7F;
                }
                dwCurve = ComputeCurve( pCurve );
                dwCurve = pChannelMap->m_ModWheelMerger.MergeValue(dwMergeIndex,(long)dwCurve,0x7F,0x7F);
                break;
            case MIDI_CC_VOLUME:
                if (fCalcStartValue)
                {
                    pCurve->nStartValue = 
                        (short) pChannelMap->m_VolumeMerger.GetVolumeStart(dwMergeIndex);
//                    DbgPrint("S%ld,",pCurve->nStartValue); 
                }
                dwCurve = ComputeCurve( pCurve );
//                DbgPrint("(%ld)%ld->",(long)(rt),dwCurve);
                dwCurve = pChannelMap->m_VolumeMerger.MergeMidiVolume(dwMergeIndex,(BYTE) dwCurve);
//                DbgPrint("%ld, ",dwCurve);
                break;
            case MIDI_CC_PAN:
                if (fCalcStartValue)
                {
                    pCurve->nStartValue = 
                        (short) pChannelMap->m_PanMerger.GetIndexedValue(dwMergeIndex) + 0x40;
                }
                dwCurve = ComputeCurve( pCurve );
                dwCurve = pChannelMap->m_PanMerger.MergeValue(dwMergeIndex,(long)dwCurve,0x40,0x7F);
                break;
            case MIDI_CC_EXPRESSION:
                if (fCalcStartValue)
                {
                    pCurve->nStartValue = 
                        (short) pChannelMap->m_ExpressionMerger.GetVolumeStart(dwMergeIndex);
                }
                dwCurve = ComputeCurve( pCurve );
                dwCurve = pChannelMap->m_ExpressionMerger.MergeMidiVolume(dwMergeIndex,(BYTE) dwCurve);
                break;
            case MIDI_CC_FILTER:
                if (fCalcStartValue)
                {
                    pCurve->nStartValue = 
                        (short) pChannelMap->m_FilterMerger.GetIndexedValue(dwMergeIndex) + 0x40;
                }
                dwCurve = ComputeCurve( pCurve );
                dwCurve = pChannelMap->m_FilterMerger.MergeValue(dwMergeIndex,(long)dwCurve,0x40,0x7F);
                break;
            case MIDI_CC_REVERB:
                if (fCalcStartValue)
                {
                    pCurve->nStartValue = 
                        (short) pChannelMap->m_ReverbMerger.GetIndexedValue(dwMergeIndex) + 0x7F;
                }
                dwCurve = ComputeCurve( pCurve );
                dwCurve = pChannelMap->m_ReverbMerger.MergeValue(dwMergeIndex,(long)dwCurve,0x7F,0x7F);
                break;
            case MIDI_CC_CHORUS:
                if (fCalcStartValue)
                {
                    pCurve->nStartValue = 
                        (short) pChannelMap->m_ChorusMerger.GetIndexedValue(dwMergeIndex) + 0x7F;
                }
                dwCurve = ComputeCurve( pCurve );
                dwCurve = pChannelMap->m_ChorusMerger.MergeValue(dwMergeIndex,(long)dwCurve,0x7F,0x7F);
                break;
            case MIDI_CC_RESETALL:
                dwCurve = ComputeCurve( pCurve );
                pChannelMap->Reset(pCurve->nEndValue);
                break;
            default:
                dwCurve = ComputeCurve( pCurve );
                break;
            }
            dwMsg = MIDI_CCHANGE;
            dwMsg |= (pCurve->bCCData << 8);
            dwMsg |= (dwCurve << 16);
            break;
        case DMUS_CURVET_MATCURVE:
            dwCurve = ComputeCurve( pCurve );
            dwMsg = MIDI_MTOUCH;
            dwMsg |= (dwCurve << 8);
            break;
        case DMUS_CURVET_PATCURVE:
            dwCurve = ComputeCurve( pCurve );
            dwMsg = MIDI_PTOUCH;
            dwMsg |= (pCurve->bCCData << 8);
            dwMsg |= (dwCurve << 16);
            break;
        case DMUS_CURVET_RPNCURVE:
        case DMUS_CURVET_NRPNCURVE:
#ifdef DXAPI
            if (pCurve->dwFlags & DMUS_PMSGF_DX8)
#endif
            {
                if ((pCurve->bType == DMUS_CURVET_RPNCURVE) && 
                    (pCurve->wParamType == MIDI_RPN_PITCHBEND))
                {
                    pChannelMap->m_PitchbendMerger.m_lBendRange = pCurve->nEndValue;
                    dwMsg = 0; // No need to send since we do the math here.
                }
                else
                {
                    dwCurve = ComputeCurve( pCurve );
                    DWORD dwMsg2 = MIDI_CCHANGE;
                    dwMsg = MIDI_CCHANGE;
                    // First, send the two CC commands to select which RPN or NRPN event.
                    if (pCurve->bType == DMUS_CURVET_RPNCURVE)
                    {
                        dwMsg |= (MIDI_CC_RPN_MSB << 8);
                        dwMsg2 |= (MIDI_CC_RPN_LSB << 8);
                    }
                    else
                    {
                        dwMsg |= (MIDI_CC_NRPN_MSB << 8);
                        dwMsg2 |= (MIDI_CC_NRPN_LSB << 8);
                    }
                    dwMsg |= (pCurve->wParamType  & 0x3F80) << 9;  // Upper 8 bits of command #
                    dwMsg2 |= (pCurve->wParamType & 0x7F) << 16;   // Lower 8 bits.
                    dwMsg |= pChannelMap->dwMChannel; // MIDI Channel
                    dwMsg2 |= pChannelMap->dwMChannel; // MIDI Channel
                    SendShortMsg(pBuffer,pPort,dwMsg,rt-3,pChannelMap->dwGroup); // Too bad if it fails!
                    SendShortMsg(pBuffer,pPort,dwMsg2,rt-2,pChannelMap->dwGroup);
                    // Then, send the two data CC commands.
                    dwMsg = MIDI_CCHANGE | (MIDI_CC_DATAENTRYMSB << 8);
                    dwMsg |= (dwCurve & 0x3F80) << 9;  // Upper 8 bits of data
                    dwMsg |= pChannelMap->dwMChannel; // MIDI Channel
                    SendShortMsg(pBuffer,pPort,dwMsg,rt-1,pChannelMap->dwGroup);
                    dwMsg = MIDI_CCHANGE | (MIDI_CC_DATAENTRYLSB << 8);
                    dwMsg |= (dwCurve & 0x7F) << 16;  // Lower 8 bits of data
                }
            }
        }
        if (dwMsg) // Make sure we successfully created a message.
        {
            dwMsg |= pChannelMap->dwMChannel; // MIDI Channel
            if (SendShortMsg(pBuffer,pPort,dwMsg,rt,pChannelMap->dwGroup))
            {
#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
                m_dwTempCurvesPerSecond++;
                UpdateDebugParams();
#endif                
#ifdef DXAPI
                m_pPortTable[pChannelMap->dwPortIndex].fBufferFilled = TRUE; // so we send this in SendBuffers
                m_pPortTable[pChannelMap->dwPortIndex].rtLast = rt;
#else
                m_rtLastSendTime = rt;
#endif

                // ComputeCurve() will set this to 0 if it's time to free the event. Otherwise, it
                // will set it to the next time this event should be performed.
                if( pCurve->rtTime )
                {
                    // If we didn't calculate the time slice because we didn't know 
                    // what the start value was, do it now.
                    if (fCalcStartValue)
                    {
                        pCurve->wMeasure = (WORD) ComputeCurveTimeSlice(pCurve);    // Use this to store the time slice interval.
                    }
                    hr = DMUS_S_REQUEUE;
                }
            }
        }
    }
    LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);
    if( pPort ) pPort->Release();
    if( pBuffer ) pBuffer->Release();
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CPerformance::PackMidi
HRESULT CPerformance::PackMidi(
            DMUS_PMSG* pEvent, 
            REFERENCE_TIME rt )
{
    DMUS_MIDI_PMSG* pMidi = (DMUS_MIDI_PMSG*)pEvent;
    IDirectMusicBuffer* pBuffer = NULL;
    IDirectMusicPort* pPort = NULL;
    DWORD dwMsg;
//  DWORD dwGroup, dwMChannel, dwPortTableIndex;
    HRESULT hr = DMUS_S_FREE;
    CChannelMap *pChannelMap = NULL;

    if( NULL == pMidi )
        return E_INVALIDARG;

    ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);
    pChannelMap = GetPChannelMap(pMidi->dwPChannel);
    if (!pChannelMap)
    {
        Trace(1,"Play MIDI failed on unassigned PChannel %ld\n",pMidi->dwPChannel);
        LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);
        return DMUS_S_FREE; // the PChannel map wasn't found. Just free the event.
    }

#ifdef DXAPI
    if( pChannelMap->dwPortIndex > m_dwNumPorts )
    {
        pPort = NULL; // the PChannel map is out of range of the number of ports
                    // so return outta here! (see after the LEAVE_CRITICAL_SECTION)
    }
    else
    {
        pPort = m_pPortTable[pChannelMap->dwPortIndex].pPort;
        if( pPort ) pPort->AddRef();
        pBuffer = m_pPortTable[pChannelMap->dwPortIndex].pBuffer;
        if( pBuffer ) pBuffer->AddRef();
    }
    if(pPort && pBuffer )
#endif
    {
        pMidi->bStatus &= 0xF0;
        if (pMidi->bStatus == MIDI_CCHANGE)
        {
            switch (pMidi->bByte1)
            {
            case MIDI_CC_MOD_WHEEL:
                pMidi->bByte2 = (BYTE) pChannelMap->m_ModWheelMerger.MergeValue(0,pMidi->bByte2,0x7F,0x7F);
                break;
            case MIDI_CC_VOLUME:
                pMidi->bByte2 = pChannelMap->m_VolumeMerger.MergeMidiVolume(0,pMidi->bByte2);
                break;
            case MIDI_CC_PAN:
                pMidi->bByte2 = (BYTE) pChannelMap->m_PanMerger.MergeValue(0,pMidi->bByte2,0x40,0x7F);
                break;
            case MIDI_CC_EXPRESSION:
                pMidi->bByte2 = pChannelMap->m_ExpressionMerger.MergeMidiVolume(0,pMidi->bByte2);
                break;
            case MIDI_CC_FILTER:
                pMidi->bByte2 = (BYTE) pChannelMap->m_FilterMerger.MergeValue(0,pMidi->bByte2,0x40,0x7F);
                break;
            case MIDI_CC_REVERB:
                pMidi->bByte2 = (BYTE) pChannelMap->m_ReverbMerger.MergeValue(0,pMidi->bByte2,0x7F,0x7F);
                break;
            case MIDI_CC_CHORUS:
                pMidi->bByte2 = (BYTE) pChannelMap->m_ChorusMerger.MergeValue(0,pMidi->bByte2,0x7F,0x7F);
                break;
            case MIDI_CC_RESETALL:
                pChannelMap->Reset(pMidi->bByte2);
                break;
            }

        }
        else if (pMidi->bStatus == MIDI_PBEND)
        {
            long lBend = pMidi->bByte1 | (pMidi->bByte2 << 7);
            lBend -= 0x2000;
            lBend *= pChannelMap->m_PitchbendMerger.m_lBendRange;;
            lBend += 0x1000;        // handle rounding up.
            lBend /= 0x2000;
            lBend += 0x2000;
            lBend = pChannelMap->m_PitchbendMerger.MergeValue(0,lBend,0x2000,0x3FFF);
            pMidi->bByte1 = (BYTE) lBend & 0x7F;
            pMidi->bByte2 = (BYTE) (lBend >> 7) & 0x7F;
        }
        dwMsg = pMidi->bByte1 << 8;
        dwMsg |= pMidi->bByte2 << 16;
        dwMsg |= pMidi->bStatus;
        dwMsg |= pChannelMap->dwMChannel;
        if (SendShortMsg(pBuffer,pPort,dwMsg,rt,pChannelMap->dwGroup))
        {
#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
            m_dwTempMIDIPerSecond++;
            UpdateDebugParams();
#endif               
#ifdef DXAPI
            m_pPortTable[pChannelMap->dwPortIndex].fBufferFilled = TRUE; // so we send this in SendBuffers
            m_pPortTable[pChannelMap->dwPortIndex].rtLast = rt;
#else
            m_rtLastSendTime = rt;
#endif
        }
    }
    LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);
    if( pPort ) pPort->Release();
    if( pBuffer ) pBuffer->Release();
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CPerformance::PackSysEx
HRESULT CPerformance::PackSysEx(
            DMUS_PMSG* pEvent, 
            REFERENCE_TIME rt )
{
    DMUS_SYSEX_PMSG* pSysEx = (DMUS_SYSEX_PMSG*)pEvent;
    IDirectMusicBuffer* pBuffer = NULL;
    IDirectMusicPort* pPort = NULL;
    DWORD dwGroup, dwMChannel, dwPortTableIndex;
    HRESULT hr = DMUS_S_FREE;

    if( NULL == pEvent )
        return E_INVALIDARG;

    if( FAILED( PChannelIndex( pSysEx->dwPChannel, &dwPortTableIndex, &dwGroup, &dwMChannel)))
    {
        Trace(1,"Play SysEx failed on unassigned PChannel %ld\n",pSysEx->dwPChannel);
        return DMUS_S_FREE; // the PChannel map wasn't found. Just free the event.
    }
#ifdef DXAPI
    if( NULL == m_pDirectMusic )
        return DMUS_E_NOT_INIT;
    ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);
    if( dwPortTableIndex > m_dwNumPorts )
    {
        pPort = NULL; // the PChannel map is out of range of the number of ports
                    // so return outta here! (see after the LEAVE_CRITICAL_SECTION)
    }
    else
    {
        pPort = m_pPortTable[dwPortTableIndex].pPort;
        if( pPort ) pPort->AddRef();
    }
    LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);
    if( pPort )
    {
        // create a buffer of the right size
        DMUS_BUFFERDESC dmbd;
        memset( &dmbd, 0, sizeof(DMUS_BUFFERDESC) );
        dmbd.dwSize = sizeof(DMUS_BUFFERDESC);
        dmbd.cbBuffer = pSysEx->dwLen + 48;

        ENTER_CRITICAL_SECTION(&m_MainCrSec);
        if( SUCCEEDED( m_pDirectMusic->CreateMusicBuffer(&dmbd, &pBuffer, NULL)))
        {
            if( SUCCEEDED( pBuffer->PackUnstructured( rt - 4, dwGroup, pSysEx->dwLen, pSysEx->abData ) ) )
            {
#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
                m_dwTempSysExPerSecond++;
                UpdateDebugParams();
#endif   
                pPort->PlayBuffer(pBuffer);
            }
            pBuffer->Release();
        }
        LEAVE_CRITICAL_SECTION(&m_MainCrSec);
    }
    if( pPort ) pPort->Release();
#else
    SendLongMsg(pSysEx->abData,pSysEx->dwLen,rt - 4, dwGroup);
#endif
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CPerformance::PackPatch
HRESULT CPerformance::PackPatch(
            DMUS_PMSG* pEvent, 
            REFERENCE_TIME rt )
{
    DMUS_PATCH_PMSG* pPatch = (DMUS_PATCH_PMSG*)pEvent;
    IDirectMusicBuffer* pBuffer = NULL;
    IDirectMusicPort* pPort = NULL;
    DWORD dwGroup, dwMChannel, dwPortTableIndex;
    DWORD dwMsg;
    HRESULT hr = DMUS_S_FREE;

    if( NULL == pEvent )
        return E_INVALIDARG;

    if( FAILED( PChannelIndex( pPatch->dwPChannel, &dwPortTableIndex, &dwGroup, &dwMChannel)))
    {
        Trace(1,"Play Patch failed on unassigned PChannel %ld\n",pPatch->dwPChannel);
        return DMUS_S_FREE; // the PChannel map wasn't found. Just free the event.
    }
    ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);
#ifdef DXAPI
    if( dwPortTableIndex > m_dwNumPorts )
    {
        pPort = NULL; // the PChannel map is out of range of the number of ports
                    // so return outta here! (see after the LEAVE_CRITICAL_SECTION)
    }
    else
    {
        pPort = m_pPortTable[dwPortTableIndex].pPort;
        if( pPort ) pPort->AddRef();
        pBuffer = m_pPortTable[dwPortTableIndex].pBuffer;
        if( pBuffer ) pBuffer->AddRef();
    }
    if( pPort && pBuffer) 
#endif
    {
        // subtract 10 from rt to guarantee that patch events always go out earlier than
        // notes with the same time stamp.
        rt -= 10;
        // send the bank select lsb
        dwMsg = MIDI_CCHANGE;
        dwMsg |= ( MIDI_CC_BS_LSB << 8 );
        dwMsg |= (pPatch->byLSB << 16);
        ASSERT( dwMChannel < 16 );
        dwMsg |= dwMChannel;
        SendShortMsg(pBuffer,pPort,dwMsg,rt-2,dwGroup);
        // send the bank select msb
        dwMsg = MIDI_CCHANGE;
        dwMsg |= ( MIDI_CC_BS_MSB << 8 );
        dwMsg |= (pPatch->byMSB << 16);
        dwMsg |= dwMChannel;
        SendShortMsg(pBuffer,pPort,dwMsg,rt-1,dwGroup);
        // send the program change
        dwMsg = MIDI_PCHANGE;
        dwMsg |= (pPatch->byInstrument << 8);
        dwMsg |= dwMChannel;
        if (SendShortMsg(pBuffer,pPort,dwMsg,rt,dwGroup))
        {
#ifdef DXAPI
            m_pPortTable[dwPortTableIndex].fBufferFilled = TRUE; // so we send this in SendBuffers
            m_pPortTable[dwPortTableIndex].rtLast = rt;
#else
            m_rtLastSendTime = rt;
#endif
        }
#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
        m_dwTempPatchesPerSecond++;
        UpdateDebugParams();
#endif
    }
    LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);
    if( pPort ) pPort->Release();
    if( pBuffer ) pBuffer->Release();
    return hr;
}

HRESULT CPerformance::PackWave(DMUS_PMSG* pPMsg, REFERENCE_TIME rtTime) 
{
    DMUS_WAVE_PMSG* pWave = (DMUS_WAVE_PMSG*)pPMsg;
    HRESULT hr = DMUS_S_FREE;
#ifdef DXAPI
    IDirectMusicVoiceP *pVoice = (IDirectMusicVoiceP *) pWave->punkUser;
    if (pVoice)
#endif
    {
        if (pWave->bFlags & DMUS_WAVEF_OFF)
        {
#ifdef DXAPI
            pVoice->Stop(rtTime);
            ENTER_CRITICAL_SECTION(&m_SegmentCrSec);
            for (DWORD dwCount = 0; dwCount < SQ_COUNT; dwCount++)
            {
                for( CSegState* pSegSt = m_SegStateQueues[dwCount].GetHead(); pSegSt; pSegSt = pSegSt->GetNext() )
                {
	                CTrack* pTrack = pSegSt->m_TrackList.GetHead();
	                while( pTrack )
	                {
                        if (pTrack->m_guidClassID == CLSID_DirectMusicWaveTrack)
                        {
                            IPrivateWaveTrack* pWaveTrack = NULL;
                            if (pTrack->m_pTrack &&
                                SUCCEEDED(pTrack->m_pTrack->QueryInterface(IID_IPrivateWaveTrack, (void**)&pWaveTrack)))
                            {
                                pWaveTrack->OnVoiceEnd(pVoice, pTrack->m_pTrackState);
                                pWaveTrack->Release();
                            }
                        }
		                pTrack = pTrack->GetNext();
	                }
                }
            }
            LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);
#else
            m_pSynth->StopWave(rtTime,pWave->dwVoiceID);
#endif
        }
        else
        {
#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
            m_dwTempWavesPerSecond++;
            UpdateDebugParams();
#endif      
#ifdef DXAPI
            if (SUCCEEDED(pVoice->Play(rtTime, pWave->lPitch, pWave->lVolume)))
            {
#else
            DWORD dwPortTableIndex, dwGroup, dwMChannel;
            if( SUCCEEDED( PChannelIndex( pWave->dwPChannel, &dwPortTableIndex, &dwGroup, &dwMChannel)))
            {
                if (SUCCEEDED(m_pSynth->PlayWave(rtTime,dwGroup,dwMChannel,
                    pWave->lPitch, pWave->lVolume,0,0,0,(IDirectSoundWave *)pWave->punkUser,&pWave->dwVoiceID)))
#endif
                {
                    if (pWave->dwFlags & DMUS_PMSGF_LOCKTOREFTIME)
                    {
                        // This is a clock time message. 
                        pWave->rtTime += pWave->rtDuration ;
                        pWave->dwFlags &= ~DMUS_PMSGF_MUSICTIME; 
                    
                    }
                    else
                    {
                        pWave->mtTime += (MUSIC_TIME) pWave->rtDuration;
                        pWave->dwFlags &= ~DMUS_PMSGF_REFTIME; 
                    }
                    pWave->bFlags |= DMUS_WAVEF_OFF;   // Queue this back up as a wave off.
                    hr = DMUS_S_REQUEUE;
                }
            }
        }
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE CPerformance::ProcessPMsg( 
    IDirectMusicPerformance* pPerf, // @parm The performance pointer.
    DMUS_PMSG* pPMsg            // @parm The message to process.
    )
{
    V_INAME(IDirectMusicTool::ProcessPMsg);
    V_INTERFACE(pPerf);
    V_BUFPTR_WRITE(pPMsg,sizeof(DMUS_PMSG));

    HRESULT hr = DMUS_S_FREE;

    ASSERT( pPerf == this );
    if( pPMsg->dwType == DMUS_PMSGT_TEMPO )
    {
        PRIV_PMSG* pPrivPMsg = DMUS_TO_PRIV(pPMsg);
        // If the pmsg was generated by a track, discard it
        // because it was already placed in the tempo map.
        if( pPrivPMsg->dwPrivFlags & PRIV_FLAG_TRACK )
        {
            return DMUS_S_FREE;
        }
        // Otherwise, this was generated by the application, so it's not already
        // in the tempo map and we need to add it.
        AddEventToTempoMap( DMUS_TO_PRIV(pPMsg));
        return DMUS_S_FREE; // OK to free this event; not requeued
    }

    if ((pPMsg->dwPChannel == DMUS_PCHANNEL_BROADCAST_GROUPS) ||
        (pPMsg->dwPChannel == DMUS_PCHANNEL_BROADCAST_PERFORMANCE))
    {
        // Scan through all the pchannels and make copies of the message for each pchannel. 
        // Then, release this one. 
        DWORD dwMax = PCHANNEL_BLOCKSIZE;
        // If one per channel group (for sysex, for example,) do only one per block.
        if (pPMsg->dwPChannel == DMUS_PCHANNEL_BROADCAST_GROUPS) dwMax = 1;
        ENTER_CRITICAL_SECTION(&m_PipelineCrSec); // Make sure we are in this so we don't deadlock in SendPMsg().
        ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);
        CChannelBlock*  pChannelBlock = m_ChannelBlockList.GetHead();
        for( ; pChannelBlock; pChannelBlock = pChannelBlock->GetNext() )
        {
            DWORD dwIndex;
            for (dwIndex = 0; dwIndex < dwMax; dwIndex++)
            {
                CChannelMap* pChannelMap = &pChannelBlock->m_aChannelMap[ dwIndex ];
                if( pChannelMap->dwGroup && 
                    (pChannelMap->wFlags & (CMAP_STATIC | CMAP_VIRTUAL)))
                {
                    DWORD dwPChannel = dwIndex + pChannelBlock->m_dwPChannelStart;
                    // If this is a transpose on the drum channel, don't send it.
                    if ((pPMsg->dwType != DMUS_PMSGT_TRANSPOSE) || ((dwPChannel & 0xF) != 9))
                    {
                        DMUS_PMSG *pNewMsg;
                        if (SUCCEEDED(ClonePMsg(pPMsg,&pNewMsg)))
                        {
                            pNewMsg->dwPChannel = dwIndex + pChannelBlock->m_dwPChannelStart;
                            SendPMsg(pNewMsg);
                        }
                    }
                }
            }
        }
        LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);
        LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);
        return DMUS_S_FREE;
    }

    if(pPMsg->dwType == DMUS_PMSGT_TRANSPOSE)
    {
        if( !( pPMsg->dwFlags & DMUS_PMSGF_TOOL_QUEUE ))
        {
            // requeue any tranpose event to be queue time
            pPMsg->dwFlags |= DMUS_PMSGF_TOOL_QUEUE;
            pPMsg->dwFlags &= ~( DMUS_PMSGF_TOOL_ATTIME | DMUS_PMSGF_TOOL_IMMEDIATE );
            return DMUS_S_REQUEUE;
        }
        else
        {
            DMUS_TRANSPOSE_PMSG* pTrans = (DMUS_TRANSPOSE_PMSG*)pPMsg;
            // set the PChannel for this transpose message
            ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);
            CChannelMap * pChannelMap = GetPChannelMap(pPMsg->dwPChannel);
            if (pChannelMap)
            {
                WORD wMergeIndex = 0;
                if (pPMsg->dwFlags & DMUS_PMSGF_DX8)
                {
                    wMergeIndex = pTrans->wMergeIndex;
                }
                pChannelMap->nTranspose = pChannelMap->m_TransposeMerger.MergeTranspose(
                    wMergeIndex,pTrans->nTranspose);
            }
            LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);
            return DMUS_S_FREE;
        }
    }

    if(pPMsg->dwType == DMUS_PMSGT_NOTIFICATION )
    {
        DMUS_NOTIFICATION_PMSG* pNotify = (DMUS_NOTIFICATION_PMSG*)pPMsg;
        if (pNotify->guidNotificationType == GUID_NOTIFICATION_PRIVATE_CHORD)
        {
            // if we've got a GUID_NOTIFICATION_PRIVATE_CHORD, 
            // invalidate/regenerate queued note events as necessary
            ENTER_CRITICAL_SECTION(&m_PipelineCrSec);
            OnChordUpdateEventQueues(pNotify);
            LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);
            return DMUS_S_FREE;
        }
        else if( !( pPMsg->dwFlags & DMUS_PMSGF_TOOL_ATTIME ))
        {
            // requeue any notification event to be ontime
            pPMsg->dwFlags |= DMUS_PMSGF_TOOL_ATTIME;
            pPMsg->dwFlags &= ~( DMUS_PMSGF_TOOL_QUEUE | DMUS_PMSGF_TOOL_IMMEDIATE );
            return DMUS_S_REQUEUE;
        }
        else
        {
            // otherwise, fire the notification
            // first, move the event into the notification queue.
            // The app then calls GetNotificationPMsg to get the event.
            CLEARTOOLGRAPH(pPMsg);
            ENTER_CRITICAL_SECTION(&m_PipelineCrSec);
            m_NotificationQueue.Enqueue( DMUS_TO_PRIV(pPMsg) );
            LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);
            ENTER_CRITICAL_SECTION(&m_MainCrSec);
            if( m_hNotification )
            {
                SetEvent(m_hNotification);
            }
            LEAVE_CRITICAL_SECTION(&m_MainCrSec);
            return S_OK; // don't free since we've placed the event into the
            // notification queue
        }
    }

    // add time signature changes to the time sig queue
    if(pPMsg->dwType == DMUS_PMSGT_TIMESIG )
    {
        CLEARTOOLGRAPH(pPMsg);
        DMUS_TIMESIG_PMSG* pTimeSig = (DMUS_TIMESIG_PMSG*)pPMsg;

        // check for a legal time signature, which may not have any
        // members equal to 0, and bBeat must be evenly divisible by 2.
        if( pTimeSig->wGridsPerBeat &&
            pTimeSig->bBeatsPerMeasure &&
            pTimeSig->bBeat &&
            ( 0 == ( pTimeSig->bBeat % 2 )))
        {
            ENTER_CRITICAL_SECTION(&m_PipelineCrSec);
            REFERENCE_TIME rtNow = GetTime() - (10000 * 1000); // keep around for a second.
            PRIV_PMSG* pCheck;
            while (pCheck = m_TimeSigQueue.FlushOldest(rtNow))
            {
                FreePMsg(pCheck);
            }
            m_TimeSigQueue.Enqueue(  DMUS_TO_PRIV(pPMsg) );
            LEAVE_CRITICAL_SECTION(&m_PipelineCrSec);
            return S_OK;
        }
        else
        {
            return DMUS_S_FREE;
        }
    }

    // requeue anything else that's early to be neartime
    if (pPMsg->dwFlags & DMUS_PMSGF_TOOL_IMMEDIATE)
    {
        // if this is a stop command, make sure the segment state doesn't keep going
        if( pPMsg->dwType == DMUS_PMSGT_STOP )
        {
            IDirectMusicSegment* pSeg = NULL;
            IDirectMusicSegmentState* pSegState = NULL;
            if( pPMsg->punkUser )
            {
                if( FAILED( pPMsg->punkUser->QueryInterface( IID_IDirectMusicSegment,
                    (void**)&pSeg )))
                {
                    pSeg = NULL;
                }
                else if( FAILED( pPMsg->punkUser->QueryInterface( IID_IDirectMusicSegmentState,
                    (void**)&pSegState )))
                {
                    pSegState = NULL;
                }
            }
            if( pSeg || pSegState )
            {
                ENTER_CRITICAL_SECTION(&m_SegmentCrSec);
                if( pPMsg->mtTime > m_mtTransported )
                {
                    // find and mark the segment and/or segment state to not play beyond
                    // the stop point.
                    CSegState* pNode;
                    DWORD dwCount;
                    for (dwCount = 0; dwCount < SQ_COUNT; dwCount++)
                    {
                        for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext() )
                        {
                            if( (pNode->m_pSegment == pSeg) ||
                                (pNode == pSegState) )
                            {
                                pNode->m_mtStopTime = pPMsg->mtTime;
                            }
                        }
                    }
                }
                LEAVE_CRITICAL_SECTION(&m_SegmentCrSec);
                if( pSeg )
                {
                    pSeg->Release();
                }
                if( pSegState )
                {
                    pSegState->Release();
                }
            }
        }
        pPMsg->dwFlags |= DMUS_PMSGF_TOOL_QUEUE;
        pPMsg->dwFlags &= ~( DMUS_PMSGF_TOOL_ATTIME | DMUS_PMSGF_TOOL_IMMEDIATE );
        return DMUS_S_REQUEUE;
    }

    switch( pPMsg->dwType )
    {
    case DMUS_PMSGT_NOTE:
        {
            hr = PackNote(  pPMsg, pPMsg->rtTime );
        }
        break;
    case DMUS_PMSGT_CURVE:
        {
            hr = PackCurve( pPMsg, pPMsg->rtTime );
        }
        break;
    case DMUS_PMSGT_SYSEX:
        {
            hr = PackSysEx( pPMsg, pPMsg->rtTime );
        }
        break;
    case DMUS_PMSGT_MIDI:
        {
            hr = PackMidi( pPMsg, pPMsg->rtTime );
        }
        break;
    case DMUS_PMSGT_PATCH:
        {
            hr = PackPatch( pPMsg, pPMsg->rtTime );
        }
        break;
    case DMUS_PMSGT_CHANNEL_PRIORITY:
        {
            DMUS_CHANNEL_PRIORITY_PMSG* pPriPMsg = (DMUS_CHANNEL_PRIORITY_PMSG*)pPMsg;
            DWORD dwPortTableIndex, dwGroup, dwMChannel;

            hr = DMUS_S_FREE;
            if( SUCCEEDED( PChannelIndex( pPriPMsg->dwPChannel, &dwPortTableIndex, &dwGroup, 
                &dwMChannel )))
            {
                ENTER_CRITICAL_SECTION(&m_PChannelInfoCrSec);
#ifdef DXAPI
                if( dwPortTableIndex <= m_dwNumPorts )
#endif
                {
#ifdef DXAPI
                    IDirectMusicPort* pPort = m_pPortTable[dwPortTableIndex].pPort;
#else
                    IDirectMusicSynthX* pPort = m_pSynth;
#endif
                    if( pPort )
                    {
                        pPort->SetChannelPriority( dwGroup, dwMChannel, 
                            pPriPMsg->dwChannelPriority );
                    }
                }
                LEAVE_CRITICAL_SECTION(&m_PChannelInfoCrSec);
            }
        }
        break;
    case DMUS_PMSGT_WAVE:
        {
            hr = PackWave( pPMsg, pPMsg->rtTime );
        }
    default:
        break;
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE CPerformance::Flush(
    IDirectMusicPerformance* pPerf, // @parm The Performance pointer.
     DMUS_PMSG* pPMsg,          // @parm The event to flush.
     REFERENCE_TIME rtTime          // @parm The time at which to flush.
    )
{
    V_INAME(IDirectMusicTool::Flush);
    V_INTERFACE(pPerf);
    V_BUFPTR_WRITE(pPMsg,sizeof(DMUS_PMSG));

    HRESULT hr = S_OK;

    ASSERT( pPerf == this );
    switch( pPMsg->dwType )
    {
    case DMUS_PMSGT_NOTE:
        {
            DMUS_NOTE_PMSG* pNote = (DMUS_NOTE_PMSG*)pPMsg;
            if( !(pNote->bFlags & DMUS_NOTEF_NOTEON) )
            {
                PackNote( pPMsg, rtTime );
            }           
        }
        break;
    case DMUS_PMSGT_CURVE:
        {
            DMUS_CURVE_PMSG* pCurve = (DMUS_CURVE_PMSG*)pPMsg;
            if( pCurve->bFlags & DMUS_CURVE_RESET )
            {
                PackCurve( pPMsg, rtTime );
            }
        }
        break;
    case DMUS_PMSGT_WAVE:
        {
            DMUS_WAVE_PMSG* pWave = (DMUS_WAVE_PMSG*)pPMsg;
            if (pWave->bFlags & DMUS_WAVEF_OFF)
            {
                PackWave( pPMsg, rtTime );
            }
        }
    default:
        break;
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE CPerformance::GetMsgDeliveryType(
    DWORD* pdwDeliveryType) // @parm Should return either DMUS_PMSGF_TOOL_IMMEDIATE, DMUS_PMSGF_TOOL_QUEUE, or DMUS_PMSGF_TOOL_ATTIME.
                    // An illegal return value will be treated as DMUS_PMSGF_TOOL_IMMEDIATE by the <i IDirectMusicGraph>.
{
    V_INAME(IDirectMusicTool::GetMsgDeliveryType);
    V_PTR_WRITE(pdwDeliveryType,DWORD);

    *pdwDeliveryType = DMUS_PMSGF_TOOL_IMMEDIATE;
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CPerformance::GetMediaTypeArraySize(
    DWORD* pdwNumElements) // @parm Returns the number of media types, with 0 meaning all.
{
    V_INAME(IDirectMusicTool::GetMediaTypeArraySize);
    V_PTR_WRITE(pdwNumElements,DWORD);

    *pdwNumElements = 0;
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CPerformance::GetMediaTypes(
    DWORD** padwMediaTypes, // @parm This should be a DWORD array of size <p dwNumElements>. 
                            // Upon return, the elements will be filled with the media types 
                            // this Tool supports.
    DWORD dwNumElements)    // @parm Contains the number of elements, i.e. the size, of the 
                            // array <p padwMediaTypes>. <p dwNumElements> should be equal 
                            // to the number returned in 
                            // <om IDirectMusicTool.GetMediaTypeArraySize>. If dwNumElements 
                            // is less than this number, this method can't return all of the 
                            // message types that are supported. If it is greater than this 
                            // number, the element fields in the array will be set to zero.
{
    return E_NOTIMPL;
}

// IDirectMusicGraph
HRESULT STDMETHODCALLTYPE CPerformance::Shutdown()
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CPerformance::InsertTool( 
    IDirectMusicTool *pTool,
    DWORD *pdwPChannels,
    DWORD cPChannels,
    LONG lIndex)
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CPerformance::GetTool(
    DWORD dwIndex,
    IDirectMusicTool** ppTool)
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CPerformance::RemoveTool(
    IDirectMusicTool* pTool)
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CPerformance::StampPMsg( DMUS_PMSG* pPMsg )
{
    V_INAME(IDirectMusicGraph::StampPMsg);
#ifdef DXAPI
    if( m_dwVersion < 8)
    {
        V_PTR_WRITE(pPMsg,sizeof(DMUS_PMSG));
    }
    else
    {
#ifdef DBG
        V_PTR_WRITE(pPMsg,sizeof(DMUS_PMSG));
#else
        if (!pPMsg)
        {
            return E_POINTER;
        }
#endif
    }
#else
    V_PTR_WRITE(pPMsg,sizeof(DMUS_PMSG));
#endif
    
    ENTER_CRITICAL_SECTION(&m_MainCrSec);
	ENTER_API_CRITICAL_SECTION;
    if( m_pGraph && ( S_OK == m_pGraph->StampPMsg( pPMsg )))
    {
        if (pPMsg->pGraph != this)
        {
            if( pPMsg->pGraph )
            {
                pPMsg->pGraph->Release();
                pPMsg->pGraph = NULL;
            }
            pPMsg->pGraph = this;
            pPMsg->pGraph->AddRef();
        }
        LEAVE_CRITICAL_SECTION(&m_MainCrSec);
		LEAVE_API_CRITICAL_SECTION;
        return S_OK;
    }
    LEAVE_CRITICAL_SECTION(&m_MainCrSec);
	LEAVE_API_CRITICAL_SECTION;
    if( pPMsg->pGraph )
    {
        pPMsg->pGraph->Release();
        pPMsg->pGraph = NULL;
    }
    if( pPMsg->pTool )
    {
        pPMsg->pTool->Release();
        pPMsg->pTool = NULL;
    }

    //otherwise there is no graph: set it to the internal Performance Tool
    pPMsg->dwFlags &= ~(DMUS_PMSGF_TOOL_IMMEDIATE | DMUS_PMSGF_TOOL_QUEUE | DMUS_PMSGF_TOOL_ATTIME);
    pPMsg->dwFlags |= DMUS_PMSGF_TOOL_QUEUE;
    pPMsg->pTool = this;
    pPMsg->pTool->AddRef();
    return S_OK;
}

// default scale is C Major
const DWORD DEFAULT_SCALE_PATTERN = 0xab5ab5;

inline DWORD BitCount(DWORD dwPattern)

{
    DWORD dwCount = 0;

    while (dwPattern)
    {
        dwPattern &= (dwPattern - 1);
        dwCount++;
    }

    return dwCount;
}

inline bool InScale(BYTE bMIDI, BYTE bRoot, DWORD dwScale)
{
    TraceI(3, "note: %d root: %d scale: %x\n", bMIDI, bRoot, dwScale);
    // shift the note by the scale root, and put it in a one-octave range
    bMIDI = ((bMIDI + 12) - (bRoot % 12)) % 12; 
     // merge two octaves of scale into one
    dwScale = (dwScale & 0x0fff) | ((dwScale >> 12) & 0x0fff);
    // note n is in scale if there's a bit in position n
    TraceI(3, "shifted note: %d shifted scale: %x\n", bMIDI, dwScale);
    return ((1 << bMIDI) & dwScale) ? true : false;
}

inline DWORD CleanupScale(DWORD dwPattern)

//  Force scale to be exactly two octaves 

{
    dwPattern &= 0x0FFF;            // Clear upper octave.
    dwPattern |= (dwPattern << 12); // Copy lower octave to top.
    return dwPattern;
}

inline DWORD PatternMatch(DWORD dwA, DWORD dwB)

{
    DWORD dwHit = 0;
    DWORD dwIndex = 0;
    for (;dwIndex < 24; dwIndex++)
    {
        if ((dwA & (1 << dwIndex)) == (dwB & (1 << dwIndex)))
        {
            dwHit++;
        }
    }
    return dwHit;
}

static DWORD dwFallbackScales[12] = 
{
    0xab5ab5,0x6ad6ad,
    0x5ab5ab,0xad5ad5,
    0x6b56b5,0x5ad5ad,
    0x56b56b,0xd5ad5a,
    0xb56b56,0xd6ad6a,
    0xb5ab5a,0xad6ad6,
};

inline DWORD FixScale(DWORD dwScale)

{
    if (BitCount(dwScale & 0xFFF) > 4)
    {
        return dwScale;
    }
    DWORD dwBest = 0;
    DWORD dwBestPattern = DEFAULT_SCALE_PATTERN;
    DWORD dwX;
    for (dwX = 0;dwX < 12; dwX++)
    {
        DWORD dwTest = PatternMatch(dwScale,dwFallbackScales[dwX]);
        if (dwTest > dwBest)
        {
            dwBestPattern = dwFallbackScales[dwX];
            dwBest = dwTest;
        }
    }
    return dwBestPattern;
}

inline DWORD ThreeOctave(DWORD dwScale)
{
    DWORD dwResult = dwScale;
     // don't change third octave if there's something there
    if ( !(0xFFF000000 & dwScale) )
    {
        // copy second octave to third octave
        dwResult |= (dwScale & 0xFFF000) << 12;
    }
    return dwResult;
}

inline DWORD AddRootToScale(BYTE bScaleRoot, DWORD dwScalePattern)

{
    dwScalePattern = CleanupScale(dwScalePattern);
    dwScalePattern >>= (12 - (bScaleRoot % 12));
    dwScalePattern = CleanupScale(dwScalePattern);
    return dwScalePattern;
}

inline DWORD SubtractRootFromScale(BYTE bScaleRoot, DWORD dwScalePattern)

{
    dwScalePattern = CleanupScale(dwScalePattern);
    dwScalePattern >>= (bScaleRoot % 12);
    dwScalePattern = CleanupScale(dwScalePattern);
    return dwScalePattern;
}

static DWORD ChordFromScale(BYTE bRoot, DWORD dwScalePattern)

{
    DWORD dwChordPattern = CleanupScale(dwScalePattern >> (bRoot % 12));
    DWORD dwX;
    DWORD dwBitCount = 0;
    for (dwX = 0; dwX < 24; dwX++)
    {
        DWORD dwBit = 1 << dwX;
        if (dwChordPattern & dwBit)
        {
            if ((dwBitCount & 1) || (dwBitCount > 7))
            {
                dwChordPattern &= ~dwBit;
            }
            dwBitCount++;
        }
    }
    return dwChordPattern;
}

static DWORD InvertChord(BYTE bKey, BYTE bChordRoot, DWORD dwChordPattern, bool& rfBelowRoot)

{
    // rotate the chord by the difference between the key and chord root
    rfBelowRoot = false;
    bKey %= 12;
    bChordRoot %= 12;
    if (bKey < bChordRoot) bKey += 12;
    BYTE bRotate = bKey - bChordRoot;
    // first check if the whole chord fits into one octave
    if ( !(dwChordPattern & 0xFFF000) )
    {
        dwChordPattern = ThreeOctave(CleanupScale(dwChordPattern));
        dwChordPattern >>= bRotate;
        dwChordPattern &= 0xFFF;
        if (!(dwChordPattern & 0x7) && ((dwChordPattern & 0xc00)) || 
            !(dwChordPattern & 0x3) && ((dwChordPattern & 0x800)))
        {
            dwChordPattern |= (dwChordPattern << 12);
            dwChordPattern &= 0x3FFC00;
            rfBelowRoot = true;
        }
    }
    else
    {
        dwChordPattern &= 0xFFFFFF; // make sure there are only notes in the two-octave range
        // do a circular shift in the closest direction
        BYTE bRotate2 = (bChordRoot + 12) - bKey;
        if (bRotate <= bRotate2)
        {
            dwChordPattern = (dwChordPattern << (24 - bRotate)) | (dwChordPattern >> bRotate);
        }
        else
        {
            dwChordPattern = (dwChordPattern >> (24 - bRotate2)) | (dwChordPattern << bRotate2);
        }
        dwChordPattern &= 0xFFFFFF;
        if (!(dwChordPattern & 0x7) &&
            (!(dwChordPattern & 0x7000) && ((dwChordPattern & 0xc00000)) || 
             !(dwChordPattern & 0x3000) && ((dwChordPattern & 0x800000)) ||
             !(dwChordPattern & 0x1000) && ((dwChordPattern & 0x1000000)) ||
             !(dwChordPattern & 0x7) && (dwChordPattern & 0x7000) && ((dwChordPattern & 0xc00000))) )
        {
            dwChordPattern = (dwChordPattern << 12) | (dwChordPattern >> 12);
            dwChordPattern &= 0xFFFFFF;
        }
        if (!(dwChordPattern & 0x7) && ((dwChordPattern & 0xc00)) || 
            !(dwChordPattern & 0x3) && ((dwChordPattern & 0x800)) ||
            !(dwChordPattern & 0x1) && ((dwChordPattern & 0x1000)) )
        {
            // put everything up to the G in the first octave two octaves up; 
            // put G# and A one octave up
            dwChordPattern |= (((dwChordPattern & 0xFF) << 24) | ((dwChordPattern & 0x300) << 12));
            // get rid of everything below A# in the first octave
            dwChordPattern &= 0xFFFFFC00;
            // If there are no notes lower than C2, shift everything back down an octave
            if (!(dwChordPattern & 0xFFF))
            {
                dwChordPattern >>= 12;
            }
            else
            {
                rfBelowRoot = true;
            }
        }
    }
    return dwChordPattern;

}

/*  This is SuperJAM! code */

static unsigned char OldMusicValueToNote(

unsigned short value,   // Music value to convert.
char scalevalue,        // Scale value if chord failes.
long keypattern,        // Description of key as interval pattern.
char keyroot,           // Root note of key.
long chordpattern,      // Description of chord as interval pattern.
char chordroot)         // Root note of chord.

{
    unsigned char   result ;
    char            octpart   = (char)(value >> 12) ;
    char            chordpart = (char)((value >> 8) & 0xF) ;
    char            keypart   = (char)((value >> 4) & 0xF) ;
    char            accpart   = (char)(value & 0xF) ;

    result  = unsigned char(12 * octpart) ;
    result += chordroot ;

    if( accpart > 8 )
        accpart -= 16 ;

    for( ;  chordpattern ;  result++ ) {
        if( chordpattern & 1L ) {
            if( !chordpart )
                break ;
            chordpart-- ;
        }
        chordpattern = chordpattern >> 1L ;
        if( !chordpattern ) {
            if( !scalevalue )
                return( 0 ) ;
            result  = unsigned char(12 * octpart) ;
            result += chordroot ;
            keypart = char(scalevalue >> 4) ;
            accpart = char(scalevalue & 0x0F) ;
            break ;
        }
    }

    if( keypart ) {
        keypattern = CleanupScale(keypattern) ;
        keypattern  = keypattern >> (LONG)((result - keyroot) % 12) ;
        for( ;  keypattern ;  result++ ) {
            if( keypattern & 1L ) {
                if( !keypart )
                    break ;
                keypart-- ;
            }
            keypattern = keypattern >> 1L ;
        }
    }

    result += unsigned char(accpart) ;
    return( result ) ;

}


/*  This is SuperJAM! code */

static unsigned short OldNoteToMusicValue(

unsigned char note,     // MIDI note to convert.
long keypattern,        // Description of key as interval pattern.
char keyroot,           // Root note of key.
long chordpattern,      // Description of chord as interval pattern.
char chordroot)         // Root note of chord.

{
    unsigned char   octpart = 0 ;
    unsigned char   chordpart = 0;
    unsigned char   keypart = (BYTE)-1 ;       
    unsigned char   accpart = 0 ;
    unsigned char   scan, test, base, last ;    // was char
    long            pattern ;
    short           testa, testb ;


    scan = chordroot ;

    // If we're trying to play a note below the bottom of our chord, forget it
    if( note < scan)
    {
        return 0;
    }

    while( scan < (note - 24) )
    {
        scan += 12 ;
        octpart++ ;
    }

    base = last = scan ;

    for( ;  base<=note ;  base+=12 )
    {
        chordpart = (unsigned char)-1 ;
        pattern   = chordpattern ;
        scan      = last = base ;
        if( scan == note )
        {
            accpart = 0;
            while (!(pattern & 1) && pattern)
            {
                accpart--;
                pattern >>= 1;
            }
            return( (unsigned short) (octpart << 12) + (accpart & 0xF)) ;           // if octave, return.
        }
        for( ;  pattern ;  pattern=pattern >> 1 )
        {
            if( pattern & 1 )                   // chord interval?
            {                 
                if( scan == note )              // note in chord?
                {            
                    chordpart++ ;
                    return((unsigned short) ((octpart << 12) | (chordpart << 8))) ; // yes, return.
                }
                else if (scan > note)           // above note?
                {         
                    test = scan ;
                    break ;                     // go on to key.
                }
                chordpart++ ;
                last = scan ;
            }
            scan++ ;
        }
        if( !pattern )                          // end of chord.
        {                        
            test = unsigned char(base + 12) ;                  // set to next note.
        }
        octpart++ ;
        if( test > note )
        {
            break ;                             // above our note?
        }
    }

    octpart-- ;

//  To get here, the note is not in the chord.  Scan should show the last
//  note in the chord.  octpart and chordpart have their final values.
//  Now, increment up the key to find the match.

    scan        = last ;
    pattern     = CleanupScale(keypattern);
    pattern     = pattern >> ((scan - keyroot) % 12) ;

    for( ;  pattern ;  pattern=pattern >> 1 )
    {
        if( 1 & pattern )
        {
            keypart++ ;
            accpart = 0 ;
        }
        else
        {
            accpart++ ;
        }
        if( scan == note )
            break ;
        scan++;
    }

    if( accpart && keypart )
    {
        testa = short((octpart << 12) + (chordpart << 8) + (keypart << 4) + accpart + 1);
        testb = short((octpart << 12) + ((chordpart + 1) << 8) + 0);
        testa = OldMusicValueToNote( testa, 0, keypattern, keyroot,
                                     chordpattern, chordroot );
        testb = OldMusicValueToNote( testb, 0, keypattern, keyroot,
                                     chordpattern, chordroot );
        if( testa == testb )
        {
            chordpart++ ;
            keypart = 0 ;
            accpart = -1 ;
        }
    }

    // If the conversion didn't find an exact match, fudge accpart to make it work
    testa = short((octpart << 12) + (chordpart << 8) + (keypart << 4) + (accpart & 0xF));
    testa = OldMusicValueToNote( testa, 0, keypattern, keyroot,
                                 chordpattern, chordroot );

    if( testa != note )
    {
        accpart += note - testa;
    }

    return unsigned short((octpart << 12) + (chordpart << 8) + (keypart << 4) + (accpart & 0xF));

}

inline short MusicValueOctave(WORD wMusicValue)
{ return short((wMusicValue >> 12) & 0xf) * 12; }

inline short MusicValueAccidentals(WORD wMusicValue)
{ 
    short acc = short(wMusicValue & 0xf);
    return (acc > 8) ? acc - 16 : acc;
}

inline short BitsInChord(DWORD dwChordPattern)
{
    
    for (short nResult = 0; dwChordPattern != 0; dwChordPattern >>= 1)
        if (dwChordPattern & 1) nResult++;
    return nResult;
}

#define S_OVER_CHORD    0x1000      // Success code to indicate the musicval could not be
                                    // converted because the note is above the top of the chord.

short MusicValueIntervals(WORD wMusicValue, BYTE bPlayModes, DMUS_SUBCHORD *pSubChord, BYTE bRoot)
{ 
    if ((bPlayModes & DMUS_PLAYMODE_CHORD_INTERVALS) || (bPlayModes & DMUS_PLAYMODE_SCALE_INTERVALS))
    {
        DWORD dwDefaultScale = 
            (pSubChord->dwScalePattern) ? (pSubChord->dwScalePattern) : DEFAULT_SCALE_PATTERN;
        dwDefaultScale = AddRootToScale(pSubChord->bScaleRoot, dwDefaultScale);
        dwDefaultScale = ThreeOctave(FixScale(dwDefaultScale));
        DWORD dwChordPattern = pSubChord->dwChordPattern;
        if (!dwChordPattern) dwChordPattern = 1;
        bool fBelowRoot = false;
        if ((bPlayModes & DMUS_PLAYMODE_KEY_ROOT) && bPlayModes != DMUS_PLAYMODE_PEDALPOINT)
        {
            dwChordPattern = InvertChord(bRoot, pSubChord->bChordRoot, dwChordPattern, fBelowRoot);
        }
        const short nChordPosition = (wMusicValue >> 8) & 0xf;
//      const short nScalePosition = (wMusicValue >> 4) & 0xf;
        // ensure that scale position is < 8
        const short nScalePosition = (wMusicValue >> 4) & 0x7;
        const short nChordBits = BitsInChord(dwChordPattern);
        short nSemitones = 0;
        // If the chord doesn't have a root or second, but does have a seventh, it's been inverted and
        // we need to start below the root
        short nTransposetones;
        DWORD dwPattern;
        short nPosition;
        BYTE bOctRoot = bRoot % 12; // root in one octave
        // if using chord intervals and the note is in the chord
        if ((bPlayModes & DMUS_PLAYMODE_CHORD_INTERVALS) && 
            !nScalePosition &&
            (nChordPosition < nChordBits) )
        {
            nTransposetones = bRoot + MusicValueAccidentals(wMusicValue);
            dwPattern = dwChordPattern;
            nPosition = nChordPosition;
        }
        // if using chord intervals and note is inside the chord (including 6ths)
        else if ((bPlayModes & DMUS_PLAYMODE_CHORD_INTERVALS) &&
                 (nChordPosition < nChordBits) )
        {
            dwPattern = dwChordPattern;
            nPosition = nChordPosition;
            if (dwPattern)
            {
                // skip to the first note in the chord
                while (!(dwPattern & 1))
                {
                    dwPattern >>= 1;
                    nSemitones++;
                }
            }
            if (nPosition > 0)
            {
                do
                {
                    dwPattern >>= 1; // this will ignore the first note in the chord
                    nSemitones++;
                    if (dwPattern & 1)
                    {
                        nPosition--;
                    }
                    if (!dwPattern)
                    {
                        nSemitones += nPosition;
//                      assert (0); // This shouldn't happen...
                        break;
                    }
                } while (nPosition > 0);
            }

            nSemitones += bOctRoot;
            nTransposetones = MusicValueAccidentals(wMusicValue) + bRoot - bOctRoot;
            dwPattern = dwDefaultScale >> (nSemitones % 12);  // start comparing partway through the pattern
            nPosition = nScalePosition;
        }
        // if using scale intervals
        else if (bPlayModes & DMUS_PLAYMODE_SCALE_INTERVALS)
        {
            fBelowRoot = false; // forget about chord inversions
            nSemitones = bOctRoot;
            nTransposetones = MusicValueAccidentals(wMusicValue) + bRoot - bOctRoot;
            dwPattern = dwDefaultScale >> bOctRoot;  // start comparing partway through the pattern
            nPosition = nChordPosition * 2 + nScalePosition;
        }
        else
        {
            return S_OVER_CHORD;  // 
        }
        nPosition++; // Now nPosition corresponds to actual scale positions
        for (; nPosition > 0; dwPattern >>= 1)
        {
            nSemitones++;
            if (dwPattern & 1)
            {
                nPosition--;
            }
            if (!dwPattern)
            {
                nSemitones += nPosition;
//              assert (0); // This shouldn't happen...
                break;
            }
        }
        nSemitones--; // the loop counts one too many semitones...
        if (fBelowRoot)
        {
            nSemitones -=12; 
        }
        return nSemitones + nTransposetones;
    }
    else
    {
        // should be impossible for 2.5 format
        return bRoot + wMusicValue;
    }
}

inline short MusicValueChord(WORD wMusicValue, BYTE bPlayModes, DMUS_SUBCHORD *pSubChord, BYTE bKey)
{ 
    // first, get the root for transposition.
    BYTE bRoot = 0;
    if (bPlayModes & DMUS_PLAYMODE_CHORD_ROOT)
    {
        bRoot = pSubChord->bChordRoot;
    }
    else if (bPlayModes & DMUS_PLAYMODE_KEY_ROOT)
        bRoot = bKey;
    // Next, get an interval and combine it with the root.
    return MusicValueIntervals(wMusicValue, bPlayModes, pSubChord, bRoot);
}

inline short MusicValueConvert(WORD wMV, BYTE bPlayModes, DMUS_SUBCHORD *pSubChord, BYTE bKey)
{ 
    short nResult = 0;
    // First, make sure the octave is not negative.
    short nOffset = 0;
    while (wMV >= 0xE000)
    {
        wMV += 0x1000;
        nOffset -= 12;
    }

    // If the music value has a negative scale offset, convert to an equivalent
    // music value with a positive offset (up an octave) and shift the whole thing
    // down an octave
    WORD wTemp = (wMV & 0x00f0) + 0x0070;
    if (wTemp & 0x0f00)
    {
        wMV = (wMV & 0xff0f) | (wTemp & 0x00f0);
        nOffset = -12;
    }

    short nChordValue = MusicValueChord(wMV, bPlayModes, pSubChord, bKey);
    if (nChordValue != S_OVER_CHORD)
    {
        nChordValue += nOffset;
        // If the chord root is < 12, take the result down an octave.
        if ((bPlayModes & DMUS_PLAYMODE_CHORD_ROOT))
            nResult = MusicValueOctave(wMV) + nChordValue - 12;
        else
            nResult = MusicValueOctave(wMV) + nChordValue;
    }
    else
        nResult = S_OVER_CHORD;
    return nResult;
}

HRESULT STDMETHODCALLTYPE CPerformance::MIDIToMusic(
                BYTE bMIDIValue,
                DMUS_CHORD_KEY* pChord,
                BYTE bPlayMode,
                BYTE bChordLevel,
                WORD *pwMusicValue
            )

{
    V_INAME(IDirectMusicPerformance::MIDIToMusic);
    V_BUFPTR_READ( pChord, sizeof(DMUS_CHORD_KEY) );
    V_PTR_WRITE(pwMusicValue,WORD);

    long lMusicValue;
    HRESULT hr = S_OK;
#ifdef DBG
    long lMIDIInTraceValue = bMIDIValue;
#endif

    if ((bPlayMode & DMUS_PLAYMODE_NONE ) || (bMIDIValue & 0x80))
    {
        Trace(1,"Error: MIDIToMusic conversion failed either because there is no playmode or MIDI value %ld is out of range.\n",(long)bMIDIValue);
        return E_INVALIDARG;
    }
    else if( bPlayMode == DMUS_PLAYMODE_FIXED )
    {
        *pwMusicValue = bMIDIValue & 0x7F;
        return S_OK;
    }
    else if (bPlayMode == DMUS_PLAYMODE_FIXEDTOKEY) // fixed to key
    {
        lMusicValue = bMIDIValue - pChord->bKey;
        while (lMusicValue < 0)
        {
            lMusicValue += 12;
            Trace(2,"Warning: MIDIToMusic had to bump the music value up an octave for DMUS_PLAYMODE_FIXEDTOKEY note.\n");
            hr = DMUS_S_UP_OCTAVE;
        }
        while (lMusicValue > 127)
        {
            lMusicValue -= 12;
            Trace(2,"Warning: MIDIToMusic had to bump the music value up an octave for DMUS_PLAYMODE_FIXEDTOKEY note.\n");
            hr = DMUS_S_DOWN_OCTAVE;
        }
        *pwMusicValue = (WORD) lMusicValue;
        return hr;
    }
    else
    {
        DMUS_SUBCHORD *pSubChord;
        DWORD dwLevel = 1 << bChordLevel;
        bool fFoundLevel = false;
        for (int i = 0; i < pChord->bSubChordCount; i++)
        {
            if (dwLevel & pChord->SubChordList[i].dwLevels)
            {
                pSubChord = &pChord->SubChordList[i];
                fFoundLevel = true;
                break;
            }
        }
        if (!fFoundLevel) // No luck? Use first chord.
        {
            pSubChord = &pChord->SubChordList[0];
        }
        if (bPlayMode == DMUS_PLAYMODE_FIXEDTOCHORD) // fixed to chord
        {
            lMusicValue = bMIDIValue - (pSubChord->bChordRoot % 24);
            while (lMusicValue < 0)
            {
                lMusicValue += 12;
                Trace(2,"Warning: MIDIToMusic had to bump the music value up an octave for DMUS_PLAYMODE_FIXEDTOCHORD note.\n");
                hr = DMUS_S_UP_OCTAVE;
            }
            while (lMusicValue > 127)
            {
                lMusicValue -= 12;
                Trace(2,"Warning: MIDIToMusic had to bump the music value down an octave for DMUS_PLAYMODE_FIXEDTOCHORD note.\n");
                hr = DMUS_S_DOWN_OCTAVE;
            }
            *pwMusicValue = (WORD) lMusicValue;
            return hr;
        }
        bool fBelowRoot = false;
        DWORD dwScalePattern = AddRootToScale(pSubChord->bScaleRoot, pSubChord->dwScalePattern);
        DWORD dwChordPattern = pSubChord->dwChordPattern;
        BYTE bKeyRoot = pChord->bKey;
        BYTE bChordRoot = pSubChord->bChordRoot;
        dwScalePattern = FixScale(dwScalePattern);
        bPlayMode &= 0xF;   // We only know about the bottom four flags, at this point.
//        if (bPlayMode == DMUS_PLAYMODE_PEDALPOINT) 
        // Do this for any non-fixed key root mode (Pedalpoint, PedalpointChord, PedalpointAlways)
        if (bPlayMode & DMUS_PLAYMODE_KEY_ROOT) 
        {
            while (bKeyRoot > bMIDIValue)
            {
                hr = DMUS_S_UP_OCTAVE;
                Trace(2,"Warning: MIDIToMusic had to bump the music value up an octave for DMUS_PLAYMODE_KEY_ROOT note.\n");
                bMIDIValue += 12;
            }
            dwScalePattern = SubtractRootFromScale(bKeyRoot,dwScalePattern);
            if (bPlayMode == DMUS_PLAYMODE_PEDALPOINT || !dwChordPattern)
            {
                bChordRoot = bKeyRoot;
                dwChordPattern = ChordFromScale(0,dwScalePattern);
            }
            else
            {
                dwChordPattern = InvertChord(bKeyRoot, bChordRoot, dwChordPattern, fBelowRoot);
                BYTE bNewChordRoot = 0;
                if (dwChordPattern)
                {
                    for (; !(dwChordPattern & (1 << bNewChordRoot)); bNewChordRoot++);
                }
                bChordRoot = bNewChordRoot + bKeyRoot;
                dwChordPattern >>= bNewChordRoot;
            }
        }
        else if (bPlayMode == DMUS_PLAYMODE_MELODIC)
        {
            bKeyRoot = 0;
            dwChordPattern = ChordFromScale(bChordRoot,dwScalePattern);
        }
        else
        {
            bKeyRoot = 0;
            if (!dwChordPattern) 
            {
                dwChordPattern = ChordFromScale(bChordRoot,dwScalePattern);
            }
        }
        BOOL fDropOctave = FALSE;
        if (bMIDIValue < 24)
        {
            fDropOctave = TRUE;
            bMIDIValue += 24;
        }
        WORD wNewMusicValue = OldNoteToMusicValue( bMIDIValue, 
            dwScalePattern,
            bKeyRoot, 
            dwChordPattern, 
            bChordRoot );
        if (fDropOctave)
        {
            wNewMusicValue -= 0x2000;
            bMIDIValue -= 24;
        }

        // If DMUS_PLAYMODE_CHORD_ROOT is set, take the result up an octave.
        // // also take the result up for the new pedalpoint chord modes.
        if( (bPlayMode & DMUS_PLAYMODE_CHORD_ROOT)  ||
            fBelowRoot)
            //((bPlayMode & DMUS_PLAYMODE_KEY_ROOT) && bPlayMode != DMUS_PLAYMODE_PEDALPOINT) )
        {
            wNewMusicValue += 0x1000;
        }
        short nTest = 
            MusicValueConvert(wNewMusicValue, bPlayMode, 
                pSubChord, pChord->bKey);
        
        if (nTest == (short) bMIDIValue)
        {
            *pwMusicValue = wNewMusicValue;
        }
        else
        {
            if (nTest == S_OVER_CHORD)
            {
                if (BitCount(pSubChord->dwChordPattern) < 4)
                {
                    DWORD dwOldChordPattern = pSubChord->dwChordPattern;
                    pSubChord->dwChordPattern = ChordFromScale(bChordRoot,dwScalePattern);
                    nTest = 
                        MusicValueConvert(wNewMusicValue, bPlayMode, 
                            pSubChord, pChord->bKey);
                    pSubChord->dwChordPattern = dwOldChordPattern;
                    if (nTest == (short) bMIDIValue)
                    {
                        *pwMusicValue = wNewMusicValue;
                        return hr;
                    }
                }
            }
            *pwMusicValue = wNewMusicValue;
#ifdef DBG // Put in brackets just in case the compiler is using something different than DBG for turning on Trace.
            Trace(1,"Error: Unable to convert MIDI value %ld to Music value. This usually means the DMUS_CHORD_KEY structure has an invalid chord or scale pattern.\n",
                lMIDIInTraceValue);
#endif
            return DMUS_E_CANNOT_CONVERT;
        }
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE CPerformance::MusicToMIDI(
                WORD wMusicValue,
                DMUS_CHORD_KEY* pChord,
                BYTE bPlayMode,
                BYTE bChordLevel, 
                BYTE *pbMIDIValue
            )

{
    V_INAME(IDirectMusicPerformance::MusicToMIDI);
    V_BUFPTR_READ( pChord, sizeof(DMUS_CHORD_KEY) );
    V_PTR_WRITE(pbMIDIValue,BYTE);

    long lReturnVal = wMusicValue;
    HRESULT hr = S_OK;

    if (bPlayMode != DMUS_PLAYMODE_FIXED)
    {
        DMUS_SUBCHORD *pSubChord;
        DWORD dwLevel = 1 << bChordLevel;
        bool fFoundLevel = false;
        for (int i = 0; i < pChord->bSubChordCount; i++)
        {
            if (dwLevel & pChord->SubChordList[i].dwLevels)
            {
                pSubChord = &pChord->SubChordList[i];
                fFoundLevel = true;
                break;
            }
        }
        if (!fFoundLevel) // No luck? Use first chord.
        {
            pSubChord = &pChord->SubChordList[0];
        }
        if (bPlayMode & DMUS_PLAYMODE_NONE )
        {
            *pbMIDIValue = 0;
            Trace(1,"Error: Unable to convert Music value to MIDI because the playmode is DMUS_PLAYMODE_NONE.\n");
            return E_INVALIDARG;
        }
        if (bPlayMode == DMUS_PLAYMODE_FIXEDTOCHORD) // fixed to chord
        {
            lReturnVal += (pSubChord->bChordRoot % 24);
        }
        else if (bPlayMode == DMUS_PLAYMODE_FIXEDTOKEY) // fixed to scale
        {
            lReturnVal += pChord->bKey;
        }
        else
        {
            lReturnVal = 
                MusicValueConvert((WORD)lReturnVal, bPlayMode, pSubChord, pChord->bKey);
        }
    }
    if (lReturnVal == S_OVER_CHORD)
    {
        Trace(5,"Warning: MIDIToMusic unable to convert because note out of chord range.\n");
        return DMUS_S_OVER_CHORD;
    }
    while (lReturnVal < 0) 
    {
        lReturnVal += 12;
        Trace(2,"Warning: MusicToMIDI had to bump the music value up an octave to stay in MIDI range.\n");
        hr = DMUS_S_UP_OCTAVE;
    }
    while (lReturnVal > 127) 
    {
        lReturnVal -= 12;
        Trace(2,"Warning: MusicToMIDI had to bump the music value down an octave to stay in MIDI range.\n");
        hr = DMUS_S_DOWN_OCTAVE;
    }
    *pbMIDIValue = (BYTE) lReturnVal;
    return hr;
}

// returns:
// S_OK if the note should be invalidated (any other return code will not invalidate)
// S_FALSE if processing otherwise succeeded, but the note should not be invalidated
// E_OUTOFMEMORY if allocation of a new note failed
HRESULT CPerformance::GetChordNotificationStatus(DMUS_NOTE_PMSG* pNote, 
                                                 //IDirectMusicSegment* pSegment, 
                                                 DWORD dwTrackGroup, 
                                                 REFERENCE_TIME rtTime, 
                                                 DMUS_PMSG** ppNew)
{
    HRESULT hr = S_FALSE; // default: succeed, but don't invalidate the note

    DMUS_CHORD_PARAM CurrentChord;
    MUSIC_TIME mtTime;
    ReferenceToMusicTime(rtTime, &mtTime);

    if (pNote->bFlags & (DMUS_NOTEF_NOINVALIDATE_INSCALE | DMUS_NOTEF_NOINVALIDATE_INCHORD))
    {
        // If the note is inconsistent with the current scale/chord, invalidate it
        if (SUCCEEDED(GetParam(GUID_ChordParam, dwTrackGroup, DMUS_SEG_ANYTRACK, 
                                mtTime, NULL, (void*) &CurrentChord)))
        {
            if (CurrentChord.bSubChordCount > 0)
            {
                BYTE bRoot = CurrentChord.SubChordList[0].bChordRoot;
                DWORD dwScale = CurrentChord.SubChordList[0].dwScalePattern;
                if (pNote->bFlags & DMUS_NOTEF_NOINVALIDATE_INCHORD)
                {
                    dwScale = CurrentChord.SubChordList[0].dwChordPattern;
                }
                else
                {
                    dwScale = FixScale(SubtractRootFromScale(bRoot, dwScale));
                }
                if (!InScale(pNote->bMidiValue, bRoot, dwScale))
                {
                    hr = S_OK;
                }
            }
        }
    }
    else if (pNote->bFlags & DMUS_NOTEF_REGENERATE)
    {
        // this always causes an invalidation, and in addition generates a new note event, 
        // based on the Music Value of the current one, that starts at rtTime 
        // and continues until pNote->mtTime + pNote->Duration
        // EXCEPTION: the newly generated note is the same as the currently playing one
        if (SUCCEEDED(GetParam(GUID_ChordParam, dwTrackGroup, DMUS_SEG_ANYTRACK, 
                                mtTime, NULL, (void*) &CurrentChord)))
        {
            BYTE bNewMidiValue = 0;
            if (SUCCEEDED(MusicToMIDI(pNote->wMusicValue, &CurrentChord, pNote->bPlayModeFlags,
                                        pNote->bSubChordLevel, &bNewMidiValue)) &&
                bNewMidiValue != pNote->bMidiValue)
            {
                MUSIC_TIME mtDuration = (pNote->bFlags & DMUS_NOTEF_NOTEON) ? pNote->mtDuration - (mtTime - pNote->mtTime) : pNote->mtTime - mtTime;
                // Make any duration < 1 be 0; this will cause the note not to 
                // sound.  Can happen if the note's logical time is well before
                // its physical time.
                if( mtDuration < 1 ) mtDuration = 0;
                DMUS_PMSG* pNewPMsg = NULL;
                if( SUCCEEDED( AllocPMsg( sizeof(DMUS_NOTE_PMSG), &pNewPMsg )))
                {
                    DMUS_NOTE_PMSG* pNewNote = (DMUS_NOTE_PMSG*)pNewPMsg;
                    // start by copying the current note into the new one
                    pNewNote->dwFlags = pNote->dwFlags;
                    pNewNote->dwPChannel = pNote->dwPChannel;
                    pNewNote->dwVirtualTrackID = pNote->dwVirtualTrackID;
                    pNewNote->pTool = pNote->pTool;
                    if (pNewNote->pTool) pNewNote->pTool->AddRef();
                    pNewNote->pGraph = pNote->pGraph;
                    if (pNewNote->pGraph) pNewNote->pGraph->AddRef();
                    pNewNote->dwType = pNote->dwType;
                    pNewNote->dwVoiceID = pNote->dwVoiceID;
                    pNewNote->dwGroupID = pNote->dwGroupID;
                    pNewNote->punkUser = pNote->punkUser;
                    if (pNewNote->punkUser) pNewNote->punkUser->AddRef();
                    pNewNote->wMusicValue = pNote->wMusicValue;
                    pNewNote->wMeasure = pNote->wMeasure;
                    pNewNote->nOffset = pNote->nOffset;
                    pNewNote->bBeat = pNote->bBeat;
                    pNewNote->bGrid = pNote->bGrid;
                    pNewNote->bVelocity = pNote->bVelocity;
                    pNewNote->bTimeRange = pNote->bTimeRange;
                    pNewNote->bDurRange = pNote->bDurRange;
                    pNewNote->bVelRange = pNote->bVelRange;
                    pNewNote->bPlayModeFlags = pNote->bPlayModeFlags;
                    pNewNote->bSubChordLevel = pNote->bSubChordLevel;
                    pNewNote->cTranspose = pNote->cTranspose;
                    // only things that need to change are flags, MIDI value, start time, and duration
                    pNewNote->mtTime = mtTime;
                    MusicToReferenceTime(pNewNote->mtTime, &pNewNote->rtTime);
                    pNewNote->mtDuration = mtDuration;
                    pNewNote->bMidiValue = bNewMidiValue;
                    pNewNote->bFlags = DMUS_NOTEF_NOTEON | DMUS_NOTEF_REGENERATE;
                    PackNote(pNewPMsg, rtTime + 1); // play the note on
                    *ppNew = pNewPMsg;  // PackNote modifies event to be note-off; queue this
                    // invalidate the current note
                    hr = S_OK;
                }
                else hr = E_OUTOFMEMORY;
            }
        }
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE CPerformance::TimeToRhythm(
                MUSIC_TIME mtTime,
                DMUS_TIMESIGNATURE *pTimeSig,
                WORD *pwMeasure,
                BYTE *pbBeat,
                BYTE *pbGrid,
                short *pnOffset
            )

{
    V_INAME(IDirectMusicPerformance::TimeToRhythm);
    V_BUFPTR_READ( pTimeSig, sizeof(DMUS_TIMESIGNATURE) );
    V_PTR_WRITE(pwMeasure,WORD);
    V_PTR_WRITE(pbBeat,BYTE);
    V_PTR_WRITE(pbGrid,BYTE);
    V_PTR_WRITE(pnOffset,short);

    long lMeasureLength;
    long lBeatLength = DMUS_PPQ;
    long lGridLength;

    if( pTimeSig->bBeat )
    {
        lBeatLength = DMUS_PPQ * 4 / pTimeSig->bBeat;
    }
    lMeasureLength = lBeatLength * pTimeSig->bBeatsPerMeasure;
    if( pTimeSig->wGridsPerBeat )
    {
        lGridLength = lBeatLength / pTimeSig->wGridsPerBeat;
    }
    else
    {
        lGridLength = lBeatLength / 256;
    }
    long lTemp = mtTime - pTimeSig->mtTime;
    *pwMeasure = (WORD)((lTemp / lMeasureLength));
    lTemp = lTemp % lMeasureLength;
    *pbBeat = (BYTE)(lTemp / lBeatLength);
    lTemp = lTemp % lBeatLength;
    *pbGrid = (BYTE)(lTemp / lGridLength);
    *pnOffset = (short)(lTemp % lGridLength);
    if (*pnOffset > (lGridLength >> 1))
    {
        *pnOffset -= (short) lGridLength;
        (*pbGrid)++;
        if (*pbGrid == pTimeSig->wGridsPerBeat)
        {
            *pbGrid = 0;
            (*pbBeat)++;
            if (*pbBeat == pTimeSig->bBeatsPerMeasure)
            {
                *pbBeat = 0;
                (*pwMeasure)++;
            }
        }
    }
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CPerformance::RhythmToTime(
                WORD wMeasure,
                BYTE bBeat,
                BYTE bGrid,
                short nOffset,
                DMUS_TIMESIGNATURE *pTimeSig,
                MUSIC_TIME *pmtTime
            )

{
    V_INAME(IDirectMusicPerformance::RhythmToTime);
    V_BUFPTR_READ( pTimeSig, sizeof(DMUS_TIMESIGNATURE) );
    V_PTR_WRITE(pmtTime,MUSIC_TIME);

    long lMeasureLength;
    long lBeatLength = DMUS_PPQ;
    long lGridLength;

    if( pTimeSig->bBeat )
    {
        lBeatLength = DMUS_PPQ * 4 / pTimeSig->bBeat;
    }
    lMeasureLength = lBeatLength * pTimeSig->bBeatsPerMeasure;
    if( pTimeSig->wGridsPerBeat )
    {
        lGridLength = lBeatLength / pTimeSig->wGridsPerBeat;
    }
    else
    {
        lGridLength = lBeatLength / 256;
    }
    long lTemp = nOffset + pTimeSig->mtTime;
    lTemp += wMeasure * lMeasureLength;
    lTemp += bBeat * lBeatLength;
    lTemp += bGrid * lGridLength;
    *pmtTime = lTemp;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\dmsegobj.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// dmsegobj.cpp : Implementation of CSegment

#include "pchime.h"

/// @doc EXTERNAL

long g_lNewTrackID = 0; // shared by all instances of Segments, this keeps track of the
	// next available TrackID when creating new Track states.

/////////////////////////////////////////////////////////////////////////////
// CSegment


void CSegment::Init()

{
    INITIALIZE_CRITICAL_SECTION(&m_CriticalSection);
    m_pSong = NULL;
    m_dwNextPlayFlags = 0;
    m_dwNextPlayID = 0xFFFFFFFF;
    m_dwPlayID = 0;
	m_mtLength = 1;
	m_mtStart = 0;
	m_mtLoopStart = 0;
	m_mtLoopEnd = 0;
    m_rtLoopStart = 0;
    m_rtLoopEnd = 0;
    m_rtLength = 0;
	m_dwRepeats = 0;
	m_dwResolution = 0;
	m_dwNumPChannels = 0;
	m_paPChannels = NULL;
	m_pGraph = NULL;
    m_pAudioPathConfig = NULL;
	m_pUnkDispatch = NULL;
    m_dwSegFlags = 0;
	m_cRef = 0; 
    m_dwVersion = 0; // Init to 6.1 behavior.
    m_Info.Init();
    m_fZombie = false;
    IncrementDLLCount();
	TraceI(2, "Segment %lx created\n", this );
}

CSegment::CSegment() : m_MemTrack(DMTRACK_SEGMENT)
{
    Init();
}

CSegment::CSegment(DMUS_IO_SEGMENT_HEADER *pHeader, CSegment *pSource) : m_MemTrack(DMTRACK_SEGMENT)

{
    Init();
    AddRef(); // so that this doesn't get deleted in Track::Init...
    // Force the version to at least 8 so audiopath functionality will be turned on.
    m_dwVersion = 8;
    m_dwResolution = pHeader->dwResolution;
	m_mtLength = pHeader->mtLength;
	m_mtStart = pHeader->mtPlayStart;
	m_mtLoopStart = pHeader->mtLoopStart;
	m_mtLoopEnd = pHeader->mtLoopEnd;
	m_dwRepeats = pHeader->dwRepeats;
    m_dwSegFlags = pHeader->dwFlags;
    if (m_dwSegFlags & DMUS_SEGIOF_REFLENGTH)
    {
        m_rtLength = pHeader->rtLength;
    }
    else
    {
        m_rtLength = 0; 
    }
    if (pSource)
    {
        pSource->m_TrackList.CreateCopyWithBlankState(&m_TrackList);
        CTrack *pTrack = m_TrackList.GetHead();
        for (;pTrack;pTrack = pTrack->GetNext())
        {
            pTrack->m_pTrack->Init( this );
        }
    }
}

CSegment::~CSegment()
{
	if (m_pUnkDispatch)
		m_pUnkDispatch->Release(); // free IDispatch implementation we may have borrowed
    Clear(false);
    DELETE_CRITICAL_SECTION(&m_CriticalSection);
    DecrementDLLCount();
	TraceI(2, "Segment %lx destroyed\n", this );
}

void CSegment::Clear(bool fZombie)
{
	m_TrackList.Clear();
    if (m_pAudioPathConfig)
    {
        m_pAudioPathConfig->Release();
        m_pAudioPathConfig = NULL;
    }
	SetGraph(NULL); // shut down the graph and release it
    // We need the following stuff to hang around if the segment is being zombied.
    if (!fZombie)
    {
	    // remove all notifies
	    CNotificationItem* pItem = m_NotificationList.GetHead();
	    while( pItem )
	    {
		    CNotificationItem* pNext = pItem->GetNext();
		    m_NotificationList.Remove( pItem );
		    delete pItem;
		    pItem = pNext;
	    }
	    if( m_paPChannels )
        {
            delete [] m_paPChannels;
            m_paPChannels = NULL;
            m_dwNumPChannels = 0;
        }
    }
}

STDMETHODIMP_(void) CSegment::Zombie()
{
	Clear(true);
	m_fZombie = true;
}

STDMETHODIMP CSegment::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
	V_INAME(CSegment::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

	*ppv = NULL;
    if (iid == IID_IUnknown || iid == IID_IDirectMusicSegment)
    {
        *ppv = static_cast<IDirectMusicSegment*>(this);
    } 
	else if (iid == IID_CSegment)
	{
        *ppv = static_cast<CSegment*>(this);
	} 
	else if (iid == IID_IDirectMusicSegment8)
    {
        m_dwVersion = 8;
        *ppv = static_cast<IDirectMusicSegment*>(this);
    }
#ifdef DXAPI
	else if (iid == IID_IDirectMusicSegment8P)
    {
        *ppv = static_cast<IDirectMusicSegment8P*>(this);
    }
    else if (iid == IID_IDirectMusicSegment2)
    {
        m_dwVersion = 2;
        *ppv = static_cast<IDirectMusicSegment*>(this);
    } 
#endif
	else if (iid == IID_IPersistStream)
	{
        *ppv = static_cast<IPersistStream*>(this);
	} 
	else if(iid == IID_IDirectMusicObject)
	{
		*ppv = static_cast<IDirectMusicObject*>(this);
	}
	else if (iid == IID_IDirectMusicObjectP)
	{
		*ppv = static_cast<IDirectMusicObjectP*>(this);
	}
	else if (iid == IID_IDispatch)
	{
		// A helper scripting object implements IDispatch, which we expose from the
		// Performance object via COM aggregation.
		if (!m_pUnkDispatch)
		{
			// Create the helper object
			DirectMusicCreateInstance(
				CLSID_AutDirectMusicSegment,
				static_cast<IDirectMusicSegment*>(this),
				IID_IUnknown,
				reinterpret_cast<void**>(&m_pUnkDispatch));
		}
		if (m_pUnkDispatch)
		{
			return m_pUnkDispatch->QueryInterface(IID_IDispatch, ppv);
		}
	}

	if (*ppv == NULL)
    {
        Trace(4,"Warning: Segment queried for unknown interface.\n");
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CSegment::AddRef()
{
//    DbgPrint("A Segment %lx: %ld->%ld\n",this,m_cRef,m_cRef+1);
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CSegment::Release()
{
//    DbgPrint("R Segment %lx: %ld->%ld\n",this,m_cRef,m_cRef-1);
    if (!InterlockedDecrement(&m_cRef))
    {
		m_cRef = 100; // artificial reference count to prevent reentrency due to COM aggregation
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CSegment::GetLength( 
    MUSIC_TIME *pmtLength) // @parm Returns the Segment's length.
{
	V_INAME(IDirectMusicSegment::GetLength);
	V_PTR_WRITE(pmtLength, MUSIC_TIME);
#ifdef DXAPI
	if (m_fZombie)
	{
		Trace(2, "Warning: Call of IDirectMusicSegment::GetLength after the segment has been garbage collected.\n");
		return DMUS_S_GARBAGE_COLLECTED;
	}
#endif
	*pmtLength = m_mtLength;
	return S_OK;
}


STDMETHODIMP CSegment::SetLength( 
    MUSIC_TIME mtLength) // @parm The desired length.
{
#if defined DXAPI || defined DBG
	if( mtLength <=0 )
    {
        Trace(1,"Error: Can not set segment length to a negative number (%ld.)\n",mtLength);
		return E_INVALIDARG;
    }
	if(( mtLength <= m_mtStart ) || ( mtLength < m_mtLoopEnd ))
    {
        Trace(1,"Error: Can not set segment length to %ld, which is either less that the start time %ld or the loop end %ld\n",
            mtLength,m_mtStart,m_mtLoopEnd);
		return DMUS_E_OUT_OF_RANGE;
    }
#endif
#ifdef DXAPI
    if (m_fZombie)
	{
		Trace(2, "Warning: Call of IDirectMusicSegment::SetLength after the segment has been garbage collected.\n");
		return DMUS_S_GARBAGE_COLLECTED;
	}
#endif
	m_mtLength = mtLength;
	return S_OK;
}

STDMETHODIMP CSegment::GetRepeats( 
    DWORD *pdwRepeats) // @parm Returns the number of repeats.
{
	V_INAME(IDirectMusicSegment::GetRepeats);
	V_PTR_WRITE(pdwRepeats, DWORD);
#ifdef DXAPI
    if (m_fZombie)
	{
        Trace(2, "Warning: Call of IDirectMusicSegment::GetRepeats after the segment has been garbage collected.\n");
		return DMUS_S_GARBAGE_COLLECTED;
	}
#endif
	*pdwRepeats = m_dwRepeats;
	return S_OK;
}

STDMETHODIMP CSegment::SetRepeats( 
    DWORD dwRepeats)	// @parm The desired number of repeats.
{
#ifdef DXAPI
    if (m_fZombie)
	{
		Trace(2, "Warning: Call of IDirectMusicSegment::SetRepeats after the segment has been garbage collected.\n");
		return DMUS_S_GARBAGE_COLLECTED;
	}
#endif
	m_dwRepeats = dwRepeats;
	return S_OK;
}

STDMETHODIMP CSegment::GetDefaultResolution( 
    DWORD *pdwResolution)	// @parm Returns the default resolution. (See <t DMPLAYSEGFLAGS>.)
{
	V_INAME(IDirectMusicSegment::GetDefaultResolution);
	V_PTR_WRITE(pdwResolution, DWORD);

#ifdef DXAPI
    if (m_fZombie)
	{
		Trace(2, "Warning: Call of IDirectMusicSegment::GetDefaultResolution after the segment has been garbage collected.\n");

		return DMUS_S_GARBAGE_COLLECTED;
	}
#endif
    
	*pdwResolution = m_dwResolution;
	return S_OK;
}

#define LEGAL_RES_FLAGS (DMUS_SEGF_SECONDARY | \
                        DMUS_SEGF_QUEUE | \
                        DMUS_SEGF_CONTROL | \
                        DMUS_SEGF_AFTERPREPARETIME  | \
                        DMUS_SEGF_GRID | \
                        DMUS_SEGF_BEAT | \
                        DMUS_SEGF_MEASURE | \
                        DMUS_SEGF_NOINVALIDATE | \
                        DMUS_SEGF_ALIGN | \
                        DMUS_SEGF_VALID_START_BEAT | \
                        DMUS_SEGF_VALID_START_GRID | \
                        DMUS_SEGF_VALID_START_TICK | \
                        DMUS_SEGF_AFTERQUEUETIME | \
                        DMUS_SEGF_AFTERLATENCYTIME | \
                        DMUS_SEGF_SEGMENTEND | \
                        DMUS_SEGF_MARKER | \
                        DMUS_SEGF_TIMESIG_ALWAYS | \
                        DMUS_SEGF_USE_AUDIOPATH | \
                        DMUS_SEGF_VALID_START_MEASURE)

STDMETHODIMP CSegment::SetDefaultResolution( 
    DWORD dwResolution)	// @parm The desired default resolution. (See <t DMPLAYSEGFLAGS>.)
{
#ifdef DXAPI
    if (m_fZombie)
	{
		Trace(2, "Warning: Call of IDirectMusicSegment::SetDefaultResolution after the segment has been garbage collected.\n");
		return DMUS_S_GARBAGE_COLLECTED;
	}
#endif
#ifdef DBG
    if ((dwResolution & LEGAL_RES_FLAGS) != dwResolution)
    {
        Trace(2,"Warning: Attempt to set resolution includes inappropriate or non-existant flag: %lx\n",
            dwResolution & ~LEGAL_RES_FLAGS);
    }
#endif
	m_dwResolution = dwResolution;
	return S_OK;
}

STDMETHODIMP CSegment::SetClockTimeLength(REFERENCE_TIME rtLength, BOOL fClockTime)

{
    if (rtLength > 157680000000)
    {
        rtLength = 157680000000;
    }
    m_rtLength = rtLength;
    if (fClockTime) 
    {
        m_dwSegFlags |= DMUS_SEGIOF_REFLENGTH;
    }
    else
    {
        m_dwSegFlags &= ~DMUS_SEGIOF_REFLENGTH;
    }
    return S_OK;
}

STDMETHODIMP CSegment::GetClockTimeLength(REFERENCE_TIME *prtLength, BOOL *pfClockTime)

{
	V_INAME(IDirectMusicSegment::GetClockTimeLength);
	V_PTR_WRITE(prtLength,REFERENCE_TIME);
	V_PTR_WRITE(pfClockTime,BOOL);
    if (m_rtLength >= 157680000000)
    {
        *prtLength = 0x7FFFFFFFFFFFFFFF;
    }
    else
    {
        *prtLength = m_rtLength;
    }
    *pfClockTime = (TRUE && (m_dwSegFlags & DMUS_SEGIOF_REFLENGTH)); 
    return S_OK;
}

STDMETHODIMP CSegment::SetClockTimeLoopPoints(REFERENCE_TIME rtStart, REFERENCE_TIME rtEnd)

{
    m_rtLoopStart = rtStart;
    m_rtLoopEnd = rtEnd;
    return S_OK;
}

STDMETHODIMP CSegment::GetClockTimeLoopPoints(REFERENCE_TIME* prtStart, REFERENCE_TIME* prtEnd)
{
	V_INAME(IDirectMusicSegment::GetClockTimeLength);
	V_PTR_WRITE(prtStart,REFERENCE_TIME);
	V_PTR_WRITE(prtEnd,REFERENCE_TIME);
    *prtStart = m_rtLoopStart;
    *prtEnd = m_rtLoopEnd;
    return S_OK;
}


#ifdef DXAPI
STDMETHODIMP CSegment::GetHeaderChunk(
        DWORD *pdwSize,      /* Size of passed header chunk. Also, returns size written. */
        DMUS_IO_SEGMENT_HEADER *pHeader)
{
    if (m_fZombie)
	{
		Trace(2, "Warning: Call of IDirectMusicSegment::GetHeaderChunk after the segment has been garbage collected.\n");
		return DMUS_S_GARBAGE_COLLECTED;
	}

    DMUS_IO_SEGMENT_HEADER Header;
    Header.dwFlags = m_dwSegFlags;
    Header.dwRepeats = m_dwRepeats;
    Header.dwResolution = m_dwResolution;
    Header.mtLength = m_mtLength;
    Header.mtLoopEnd = m_mtLoopEnd;
    Header.mtLoopStart = m_mtLoopStart;
    Header.mtPlayStart = m_mtStart;
    Header.dwReserved = 0;
    Header.rtLength = m_rtLength;
    if (pdwSize && pHeader)
    {
        *pdwSize = min(sizeof(Header),*pdwSize);
        memcpy(pHeader,&Header,*pdwSize);
        return S_OK;
    }
    Trace(1,"Error: GetHeaderChunk() was passed a NULL for either pdwSize or pHeader.\n");
    return E_POINTER;
}

STDMETHODIMP CSegment::SetHeaderChunk(
        DWORD dwSize,        /* Size of passed header chunk. */
        DMUS_IO_SEGMENT_HEADER *pHeader)
{
    if (m_fZombie)
	{
		Trace(2, "Warning: Call of IDirectMusicSegment::SetHeaderChunk after the segment has been garbage collected.\n");
		return DMUS_S_GARBAGE_COLLECTED;
	}

    if (pHeader)
    {
        DMUS_IO_SEGMENT_HEADER Header;
        dwSize = min(sizeof(Header),dwSize);
        // Initialize all fields so we don't have to worry about the passed size.
        Header.dwFlags = m_dwSegFlags;
        Header.dwRepeats = m_dwRepeats;
        Header.dwResolution = m_dwResolution;
        Header.mtLength = m_mtLength;
        Header.mtLoopEnd = m_mtLoopEnd;
        Header.mtLoopStart = m_mtLoopStart;
        Header.mtPlayStart = m_mtStart;
        Header.dwReserved = 0;
        Header.rtLength = m_rtLength;
        Header.rtLoopStart = m_rtLoopStart;
        Header.rtLoopEnd = m_rtLoopEnd;
        memcpy(&Header,pHeader,dwSize);
        m_dwSegFlags = Header.dwFlags;
        m_dwRepeats = Header.dwRepeats;
        m_dwResolution = Header.dwResolution;
        m_mtLength = Header.mtLength;
        m_mtLoopEnd = Header.mtLoopEnd;
        m_mtLoopStart = Header.mtLoopStart;
        m_mtStart = Header.mtPlayStart;
        m_rtLength = Header.rtLength;
        if (m_dwSegFlags & DMUS_SEGIOF_REFLOOP)
        {
            m_rtLoopStart = Header.rtLoopStart;
            m_rtLoopEnd = Header.rtLoopEnd;
        }
        else
        {
            m_rtLoopEnd = m_rtLoopStart = 0;
        }
        return S_OK;
    }
    Trace(1,"Error: SetHeaderChunk() was passed a NULL for pHeader.\n");
    return E_POINTER;
}


STDMETHODIMP CSegment::SetTrackPriority(
        REFGUID rguidTrackClassID,  /* ClassID of Track. */
        DWORD dwGroupBits,          /* Group bits. */
        DWORD dwIndex,              /* Nth track. */
        DWORD dwPriority)       /* Priority to set. */
{
    if (m_fZombie)
	{
		Trace(2, "Warning: Call of IDirectMusicSegment::SetTrackPriority after the segment has been garbage collected.\n");
		return DMUS_S_GARBAGE_COLLECTED;
	}

	HRESULT hr = DMUS_E_TRACK_NOT_FOUND;
    CTrack* pCTrack;
    DWORD dwCounter = dwIndex;
    DWORD dwMax = dwIndex;
    if (dwIndex == DMUS_SEG_ALLTRACKS)
    {
        dwCounter = 0;
        dwMax = DMUS_SEG_ALLTRACKS;
    }
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    while (pCTrack = GetTrack(rguidTrackClassID,dwGroupBits,dwCounter))
    {
        pCTrack->m_dwPriority = dwPriority;
        hr = S_OK;
        dwCounter++;
        if (dwCounter > dwMax) break;
    }
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
	return hr;
}

STDMETHODIMP CSegment::SetAudioPathConfig(
        IUnknown *pAudioPathConfig) 
{
    if (m_fZombie)
	{
		Trace(2, "Warning: Call of IDirectMusicSegment::SetAudioPathConfig after the segment has been garbage collected.\n");
		return DMUS_S_GARBAGE_COLLECTED;
	}

    if (m_dwVersion < 8) m_dwVersion = 8;
    if (m_pAudioPathConfig)
    {
        m_pAudioPathConfig->Release();
        m_pAudioPathConfig = NULL;
    }
    if (pAudioPathConfig)
    {
        return pAudioPathConfig->QueryInterface(IID_CAudioPathConfig,(void **) &m_pAudioPathConfig);
    }
    return S_OK;
}
#endif


STDMETHODIMP CSegment::GetTrack( 
    REFCLSID rType,		
	DWORD dwGroupBits,	
    DWORD dwIndex,		
    IDirectMusicTrack **ppTrack)
{
	V_INAME(IDirectMusicSegment::GetTrack);
	V_PTRPTR_WRITE(ppTrack);

#ifdef DXAPI
    if (m_fZombie)
	{
		Trace(2, "Warning: Call of IDirectMusicSegment::GetTrack after the segment has been garbage collected.\n");
		return DMUS_S_GARBAGE_COLLECTED;
	}
#endif
    
	CTrack* pCTrack;
    HRESULT hr;
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    pCTrack = GetTrack(rType,dwGroupBits,dwIndex);
    if (pCTrack)
    {
	    *ppTrack = pCTrack->m_pTrack;
		pCTrack->m_pTrack->AddRef();
        hr = S_OK;
    }
    else 
    {
        Trace(2,"Error: GetTrack could not find the requested track at index %ld.\n",dwIndex);
        hr = DMUS_E_NOT_FOUND;
    }
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
	return hr;
}

CTrack *CSegment::GetTrack( 
    REFCLSID rType,		
	DWORD dwGroupBits,	
    DWORD dwIndex)
{
	CTrack* pCTrack;
	pCTrack = m_TrackList.GetHead();
	while( pCTrack )
	{
		ASSERT(pCTrack->m_pTrack);
		if( pCTrack->m_dwGroupBits & dwGroupBits )
		{
			if( (GUID_NULL == rType) || (pCTrack->m_guidClassID == rType))
			{
				if( 0 == dwIndex )
				{
                    break;
				}
				dwIndex--;
			}
		}
		pCTrack = pCTrack->GetNext();
	}
	return pCTrack;
}

BOOL CSegment::IsTempoSource()

{
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    BOOL fHasTempo = (NULL != GetTrackByParam(NULL, GUID_TempoParam,-1,0, FALSE));
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    return fHasTempo;
}

STDMETHODIMP CSegment::GetTrackGroup( 
    IDirectMusicTrack* pTrack,	// @parm The Track to find the group bits.
	DWORD* pdwGroupBits)// @parm Returns the group(s) to which a Track belongs. 
						// Each bit in <p pdwGroupBits> corresponds to a Track 
						// group.
{
	V_INAME(IDirectMusicSegment::GetTrackGroup);
	V_INTERFACE(pTrack);
	V_PTR_WRITE(pdwGroupBits,DWORD);

#ifdef DXAPI
    if (m_fZombie)
	{
		Trace(2, "Warning: Call of IDirectMusicSegment::GetTrackGroup after the segment has been garbage collected.\n");
		return DMUS_S_GARBAGE_COLLECTED;
	}
#endif
    
	CTrack* pCTrack;
    HRESULT hr = DMUS_E_NOT_FOUND;
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
	pCTrack = m_TrackList.GetHead();
	while( pCTrack )
	{
		ASSERT(pCTrack->m_pTrack);
		if( pCTrack->m_pTrack == pTrack )
		{
			*pdwGroupBits = pCTrack->m_dwGroupBits;
			hr = S_OK;
            break;
		}
		pCTrack = pCTrack->GetNext();
	}
#ifdef DBG
    if (hr == DMUS_E_NOT_FOUND)
    {
        Trace(2,"Error: GetTrackGroup could not find the requested track.\n");
    }
#endif
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
	return hr;
}

CTrack * CSegment::GetTrackByParam( CTrack * pCTrack,
    REFGUID rguidType,DWORD dwGroupBits,DWORD dwIndex, BOOL fDontCheck)
{
	// If the caller was already part way through the list, it passes the current
    // track. Otherwise, NULL to indicate start at the top.
    if (pCTrack)
    {
        pCTrack = pCTrack->GetNext();
    }
    else
    {
	    pCTrack = m_TrackList.GetHead();
    }
	while( pCTrack )
	{
		ASSERT(pCTrack->m_pTrack);
		if( (pCTrack->m_dwGroupBits & dwGroupBits ) && (fDontCheck ||
            (pCTrack->m_dwFlags & DMUS_TRACKCONFIG_CONTROL_ENABLED)))
		{
			if( (GUID_NULL == rguidType) || 
                (pCTrack->m_pTrack->IsParamSupported( rguidType ) == S_OK ))
			{
				if( 0 == dwIndex )
				{
                    return pCTrack;
				}
				dwIndex--;
			}
		}
		pCTrack = pCTrack->GetNext();
	}
    return NULL;
}

HRESULT CSegment::GetTrackByParam( 
    REFGUID rguidType,	// The command type of the Track to find. A value of GUID_NULL
						// will get any track.
	DWORD dwGroupBits,	// Which track groups to scan for the track in. A value of 0 
						// is invalid. Each bit in <p dwGroupBits> corresponds to a Track 
						// group. To scan all tracks regardless of groups, set all bits in 
						// this parameter (0xffffffff).
    DWORD dwIndex,		// The index into the list of tracks of type <p rguidType> 
						// and in group <p dwGroupBits> to return. 0 means the first
						// one found, 1 would be the second, etc. If multiple groups are 
						// selected in <p dwGroupBits>, this index will indicate the nth 
						// track of type <p pCommandGuid> encountered in the union
						// of the groups selected.
    IDirectMusicTrack **ppTrack)	// Returns the Track (AddRef'd), or NULL if the 
									// Track isn't found.
{
    HRESULT hr;
	CTrack* pCTrack;
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
	pCTrack = GetTrackByParam(NULL,rguidType,dwGroupBits,dwIndex,TRUE);
	if (pCTrack)
    {
		*ppTrack = pCTrack->m_pTrack;
		pCTrack->m_pTrack->AddRef();
		hr = S_OK;
	}
    else
    {
        hr = DMUS_E_NOT_FOUND;
        // Don't think we need an error message here since SetParam also does one...
        // Trace(1,"Error: Could not find the requested track for SetParam.\n");
    }
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
	return hr;
}

STDMETHODIMP CSegment::InsertTrack( 
    IDirectMusicTrack *pTrack,	// @parm The Track to add to the Segment.
	DWORD dwGroupBits )			// @parm Identifies the group(s) this should be inserted into.
								// May not be 0.
{
	V_INAME(IDirectMusicSegment::InsertTrack);
	V_INTERFACE(pTrack);
#ifdef DXAPI
    if (m_fZombie)
	{
		Trace(2, "Warning: Call of IDirectMusicSegment::InsertTrack after the segment has been garbage collected.\n");
		return DMUS_S_GARBAGE_COLLECTED;
	}
#endif	
    return InsertTrack(pTrack,dwGroupBits,DMUS_TRACKCONFIG_DEFAULT,0, 0);
}

HRESULT CSegment::InsertTrack( 
    IDirectMusicTrack *pTrack,	
	DWORD dwGroupBits,
    DWORD dwFlags,
    DWORD dwPriority,
    DWORD dwPosition)	
{
	CTrack* pCTrack;
	
	if( 0 == dwGroupBits )
    {
        Trace(1,"Error: InsertTrack called with dwGroupBits set to 0.\n");
		return E_INVALIDARG;
    }
	if( FAILED( pTrack->Init( this ) ))
	{
        TraceI(1,"Error: Track failed to initialize\n");
		return DMUS_E_NOT_INIT;
	}
	pCTrack = new CTrack;
	if( NULL == pCTrack )
	{
		return E_OUTOFMEMORY;
	}
	pCTrack->m_pTrack = pTrack;
    pTrack->QueryInterface(IID_IDirectMusicTrack8,(void **) &pCTrack->m_pTrack8);
    IPersist *pPersist;
    if (S_OK == pTrack->QueryInterface(IID_IPersistStream,(void **) &pPersist))
    {
        pPersist->GetClassID( &pCTrack->m_guidClassID );
        pPersist->Release();
    }
	pCTrack->m_dwGroupBits = dwGroupBits;
    pCTrack->m_dwFlags = dwFlags;
    pCTrack->m_dwPriority = dwPriority;
    pCTrack->m_dwPosition = dwPosition;
	pTrack->AddRef();
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    // Add the track based on position.
	CTrack* pScan = m_TrackList.GetHead();
	CTrack* pPrevTrack = NULL;
    for (; pScan; pScan = pScan->GetNext())
	{
        if (pCTrack->Less(pScan))
        {
            break;
        }
        pPrevTrack = pScan;
    }
    if (pPrevTrack)
    {
        pPrevTrack->SetNext(pCTrack);
        pCTrack->SetNext(pScan);
    }
    else
    {
        m_TrackList.AddHead( pCTrack );
    }
	
	// send notifications to track
	CNotificationItem* pItem = m_NotificationList.GetHead();
	while( pItem )
	{
		pTrack->AddNotificationType( pItem->guidNotificationType );
		pItem = pItem->GetNext();
	}
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
	return S_OK;
}

STDMETHODIMP CSegment::RemoveTrack( 
    IDirectMusicTrack *pTrack)	// @parm The Track to remove from the Segment's Track list.
{
	V_INAME(IDirectMusicSegment::RemoveTrack);
	V_INTERFACE(pTrack);
#ifdef DXAPI
    if (m_fZombie)
	{
		Trace(2, "Warning: Call of IDirectMusicSegment::RemoveTrack after the segment has been garbage collected.\n");
		return DMUS_S_GARBAGE_COLLECTED;
	}
#endif
    
	HRESULT hr = S_FALSE;
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
	CTrack* pCTrackTemp;
	pCTrackTemp = m_TrackList.GetHead();
	while( pCTrackTemp )
	{
		if( pTrack == pCTrackTemp->m_pTrack )
		{
			hr = S_OK;
			m_TrackList.Remove( pCTrackTemp );
			delete pCTrackTemp;
			break;
		}
		pCTrackTemp = pCTrackTemp->GetNext();
	}
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
#ifdef DBG
    if (hr == S_FALSE)
    {
        Trace(1,"Warning: RemoveTrack failed because the requested track is not in the segment.\n");
    }
#endif
	return hr;
}

HRESULT CSegment::CreateSegmentState( 
    CSegState **ppSegState,
    CPerformance *pPerformance,
    IDirectMusicAudioPath *pAudioPath,
    DWORD dwFlags)                          

{
	IDirectMusicSegmentState* pSegmentState;
    CSegState *pState = new CSegState;
    if (pState)
    {
	    pState->QueryInterface( IID_IDirectMusicSegmentState,
            (void**)&pSegmentState);
        pState->m_dwVersion = m_dwVersion;
        pState->Release();
    }
    else
    {
        return E_OUTOFMEMORY;
    }
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
	if( FAILED( m_TrackList.CreateCopyWithBlankState(&pState->m_TrackList)))
	{
        LEAVE_CRITICAL_SECTION(&m_CriticalSection);
        pState->Release();
		return E_OUTOFMEMORY;
	}
	// set the segstate's parent and performance
	pState->PrivateInit( this, pPerformance );

    if (m_pGraph)
    {
        m_pGraph->Clone((IDirectMusicGraph **) &pState->m_pGraph);
    }
    pState->InitRoute(pAudioPath);
	CTrack* pCTrack = pState->m_TrackList.GetHead();
	while( pCTrack )
	{
		DWORD dwTempID;
		InterlockedIncrement(&g_lNewTrackID);
		dwTempID = g_lNewTrackID;
        if (!pState->m_dwFirstTrackID)
            pState->m_dwFirstTrackID = dwTempID;
        pState->m_dwLastTrackID = dwTempID;
		ASSERT(pCTrack->m_pTrack);
		if( FAILED(pCTrack->m_pTrack->InitPlay(
			pSegmentState, (IDirectMusicPerformance *) pPerformance, 
            &pCTrack->m_pTrackState, dwTempID, dwFlags )))
		{
			pCTrack->m_pTrackState = NULL;
		}
		pCTrack->m_dwVirtualID = dwTempID;
		pCTrack = pCTrack->GetNext();
	}
	*ppSegState = pState;
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
	return S_OK; 
}

/*  The following function is kept around only for DX6.1 compatibility just
    in case some mindless bureaucrat actually uses this somehow.
    For internal use, we've switched to the function above.
*/

STDMETHODIMP CSegment::InitPlay( 
    IDirectMusicSegmentState **ppSegState,	// @parm Returns the SegmentState created
			// by this method call. It is returned with a reference count of 1, thus a 
			// call to its Release will fully release it.
    IDirectMusicPerformance *pPerformance,	// @parm The IDirectMusicPerformance pointer.
			// This is needed by the Segment and SegmentState in order to call methods on 
			// the Performance object. This pointer is not AddRef'd. It is a weak reference 
			// because it is assumed that the Performance will outlive the Segment.
    DWORD dwFlags)                          // @parm Same flags that were set with the call
            // to PlaySegment. These are passed to the tracks, who may want to know
            // if the track was played as a primary, controlling, or secondary segment.
{
#ifdef DXAPI
	V_INAME(IDirectMusicSegment::InitPlay);
	V_INTERFACE(pPerformance);
	V_PTRPTR_WRITE(ppSegState);

    if (m_dwVersion)
    {
        return E_NOTIMPL;
    }

	IDirectMusicSegmentState* pSegmentState;
    CSegState *pState = new CSegState;
    if (pState)
    {
	    pState->QueryInterface( IID_IDirectMusicSegmentState,
            (void**)&pSegmentState);
        pState->m_dwVersion = m_dwVersion;
        pState->Release();
        if (pPerformance)
        {
            // QI addref's the performance but we want only a weak refrenece with the segment state
            HRESULT hr = pPerformance->QueryInterface(IID_CPerformance,(void **) &pState->m_pPerformance);
            if(FAILED(hr))
            {
                return E_FAIL;
            }

            pPerformance->Release();
        }
    }
    else
    {
        return E_OUTOFMEMORY;
    }
	*ppSegState = pSegmentState;
#endif
    return S_OK;
}

STDMETHODIMP CSegment::GetGraph(
	IDirectMusicGraph**	ppGraph	// @parm Returns the Tool Graph pointer.
		)
{
	V_INAME(IDirectMusicSegment::GetGraph);
	V_PTRPTR_WRITE(ppGraph);
#ifdef DXAPI
    if (m_fZombie)
	{
		Trace(2, "Warning: Call of IDirectMusicSegment::GetGraph after the segment has been garbage collected.\n");
		return DMUS_S_GARBAGE_COLLECTED;
	}
#endif	
	if( NULL == m_pGraph )
    {
        Trace(2,"Error: GetGraph failed because segment does not have a tool graph.\n");
		return DMUS_E_NOT_FOUND;
    }
	ENTER_CRITICAL_SECTION(&m_CriticalSection);
	*ppGraph = m_pGraph;
	m_pGraph->AddRef();
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
	return S_OK;
}

STDMETHODIMP CSegment::SetGraph(
	IDirectMusicGraph*	pGraph	// @parm The Tool Graph pointer. May be NULL to
								// clear out the Segment graph.
		)
{
	V_INAME(IDirectMusicSegment::SetGraph);
	V_INTERFACE_OPT(pGraph);
#ifdef DXAPI
    if (m_fZombie)
	{
		Trace(2, "Warning: Call of IDirectMusicSegment::SetGraph after the segment has been garbage collected.\n");
		return DMUS_S_GARBAGE_COLLECTED;
	}
#endif	
	ENTER_CRITICAL_SECTION(&m_CriticalSection);
	if( m_pGraph )
	{
		m_pGraph->Release();
	}
	m_pGraph = (CGraph *) pGraph;
	if( pGraph )
	{
		pGraph->AddRef();
	}
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
	return S_OK;
}

HRESULT CSegment::SetClockTimeDuration(REFERENCE_TIME rtDuration)

{
    m_rtLength = rtDuration;
    return S_OK;
}

HRESULT CSegment::SetFlags(DWORD dwFlags)

{
    m_dwSegFlags = dwFlags;
    return S_OK;
}

/*
  Check to see if this notification is already being tracked.
*/
CNotificationItem* CSegment::FindNotification( REFGUID rguidNotification )
{
	CNotificationItem* pItem;

	pItem = m_NotificationList.GetHead();
	while(pItem)
	{
		if( rguidNotification == pItem->guidNotificationType )
		{
			break;
		}
		pItem = pItem->GetNext();
	}
	return pItem;
}

void CSegment::AddNotificationTypeToAllTracks( REFGUID rguidNotification )
{
	CTrack* pTrack;

	// add the notify to the tracks
	pTrack = m_TrackList.GetHead();
	while( pTrack )
	{
		pTrack->m_pTrack->AddNotificationType( rguidNotification );
		pTrack = pTrack->GetNext();
	}
}

void CSegment::RemoveNotificationTypeFromAllTracks( REFGUID rguidNotification )
{
	CTrack* pTrack;

	// add the notify to the tracks
	pTrack = m_TrackList.GetHead();
	while( pTrack )
	{
		pTrack->m_pTrack->RemoveNotificationType( rguidNotification );
		pTrack = pTrack->GetNext();
	}
}

HRESULT CSegment::AddNotificationType(
	 REFGUID rguidNotification, BOOL fFromPerformance)	
{
	CNotificationItem* pItem;
	HRESULT hr = S_OK;
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
	pItem = FindNotification( rguidNotification );
    if (pItem)
	{
        // If the item was installed previously, but by
        // a difference source (performance vs. app)
        // then treat this as a normal addition.
        // Otherwise, indicate that the same operation 
        // was done twice.
        if (pItem->fFromPerformance == fFromPerformance)
        {
            hr = S_FALSE;
        }
        else
        {
            // Clear the fFromPerformance flag since this has
            // now been added by the app and the performance.
            pItem->fFromPerformance = FALSE;
        }
	}
    else
    {
        pItem = new CNotificationItem;
		if( NULL == pItem )
		{
			hr = E_OUTOFMEMORY;
		}
		else
		{
            pItem->fFromPerformance = fFromPerformance;
			pItem->guidNotificationType = rguidNotification;
			m_NotificationList.Cat( pItem );
			AddNotificationTypeToAllTracks( rguidNotification );
		}
    }
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
	return hr;
}

STDMETHODIMP CSegment::AddNotificationType(
	 REFGUID rguidNotification)	// @parm The notification guid to add.
{
	V_INAME(IDirectMusicSegment::AddNotificationType);
	V_REFGUID(rguidNotification);

    if (m_fZombie)
	{
		Trace(2, "Warning: Call of IDirectMusicSegment::AddNotificationType after the segment has been garbage collected.\n");
		return DMUS_S_GARBAGE_COLLECTED;
	}
	
	return AddNotificationType(rguidNotification,FALSE);
}

HRESULT CSegment::RemoveNotificationType(
	 REFGUID rguidNotification,BOOL fFromPerformance)
{

	CNotificationItem* pItem;
    HRESULT hr = S_OK;
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
	if( GUID_NULL == rguidNotification )
	{
        CNotificationList TempList;
		while( pItem = m_NotificationList.RemoveHead() )
		{
            // If this is being called on an item that was installed by the
            // performance OR we are calling this directly from the app,
            // go ahead and remove. However, do not remove in the specific
            // case where the app installed the notification and the performance
            // is clearing notifications. 
            if (pItem->fFromPerformance || !fFromPerformance) 
            {
			    RemoveNotificationTypeFromAllTracks( pItem->guidNotificationType );
                delete pItem;
            }
            else
            {
                TempList.AddHead(pItem);
            }
		}
        // Now, put the saved notifications back.
        while (pItem = TempList.RemoveHead())
        {
            m_NotificationList.AddHead(pItem);
        }
	}
	else if( pItem = FindNotification( rguidNotification ))
	{
		m_NotificationList.Remove( pItem );
		delete pItem;
		RemoveNotificationTypeFromAllTracks( rguidNotification );	
	}
    else
    {
        Trace(2,"Warning: Unable to remove requested notification from segment, it was not currently installed.\n");
        hr = S_FALSE;
    }
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
	return hr;
}

STDMETHODIMP CSegment::RemoveNotificationType(
	 REFGUID rguidNotification)	// @parm The notification guid to remove. GUID_NULL to remove all notifies.
{
	V_INAME(IDirectMusicSegment::RemoveNotificationType);
	V_REFGUID(rguidNotification);

    if (m_fZombie)
	{
		Trace(2, "Warning: Call of IDirectMusicSegment::RemoveNotificationType after the segment has been garbage collected.\n");
		return DMUS_S_GARBAGE_COLLECTED;
	}

    return RemoveNotificationType(rguidNotification,FALSE);
}

STDMETHODIMP CSegment::GetParam(
	REFGUID rguidType,	    // @parm The type of data to obtain.
	DWORD dwGroupBits,		// @parm The group the desired track is in. Use 0xffffffff 
							// for all groups.
	DWORD dwIndex,			// @parm Identifies which track, by index, in the group 
							// identified by <p dwGroupBits> to obtain the data from.
	MUSIC_TIME mtTime,		// @parm The segment time from which to obtain the data.
	MUSIC_TIME* pmtNext,	// @parm Returns the segment time until which the data is valid. <p pmtNext>
							// may be NULL. If this returns a value of 0, it means that this
							// data will either be always valid, or it is unknown when it will
							// become invalid.
	void* pParam)			// @parm The struture in which to return the data. Each
							// <p rguidType> identifies a particular structure of a
							// particular size. It is important that this field contain
							// the correct structure of the correct size. Otherwise,
							// fatal results can occur.
{
	V_INAME(IDirectMusicSegment::GetParam);
	V_REFGUID(rguidType);

    if (m_fZombie)
	{
		Trace(2, "Warning: Call of IDirectMusicSegment::GetParam after the segment has been garbage collected.\n");
		return DMUS_S_GARBAGE_COLLECTED;
	}

	HRESULT hr = DMUS_E_TRACK_NOT_FOUND;
    BOOL fMultipleTry = FALSE;
    if (dwIndex == DMUS_SEG_ANYTRACK)
    {
        dwIndex = 0;
        // App must be using IDirectMusicSegment8 interface for this to be enabled...
        // Nah, nobody would ever have a use for an index that high, so this is safe.
        fMultipleTry = TRUE; // (m_dwVersion > 2);
    }
    CTrack* pCTrack;
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
	pCTrack = GetTrackByParam(NULL,rguidType,dwGroupBits,dwIndex,FALSE);
	while (pCTrack)
    {
        if (pCTrack->m_pTrack8)
        {
            REFERENCE_TIME rtNext, *prtNext;
            // We need to store the next time in a 64 bit pointer. But, don't
            // make 'em fill it in unless the caller requested it. 
            if (pmtNext)
            {
                prtNext = &rtNext;
            }
            else
            {
                prtNext = NULL;
            }
		    hr = pCTrack->m_pTrack8->GetParamEx( rguidType, mtTime, prtNext, pParam,
                NULL, 0 );
            if (pmtNext)
            {
                *pmtNext = (MUSIC_TIME) rtNext;
            }
        }
        else
        {
            hr = pCTrack->m_pTrack->GetParam( rguidType, mtTime, pmtNext, pParam );
		    if( pmtNext && (( *pmtNext == 0 ) || (*pmtNext > (m_mtLength - mtTime))))
		    {
			    *pmtNext = m_mtLength - mtTime;
		    }
        }
        // If nothing was found and dwIndex was DMUS_SEG_ANYTRACK, try again...
        if (fMultipleTry && (hr == DMUS_E_NOT_FOUND))
        {
            pCTrack = GetTrackByParam( pCTrack, rguidType, dwGroupBits, 0, FALSE);
        }
        else
        {
            pCTrack = NULL;
        }
	}
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
#ifdef DBG
    if (hr == DMUS_E_TRACK_NOT_FOUND)
    {
        Trace(2,"Warning: Segment GetParam failed to find a track.\n");
    }
#endif
	return hr;
}


STDMETHODIMP CSegment::SetParam(
	REFGUID rguidType,		// @parm The type of data to set.
	DWORD dwGroupBits,		// @parm The group the desired track is in. Use 0xffffffff 
							// for all groups.
	DWORD dwIndex,			// @parm Identifies which track, by index, in the group 
							// identified by <p dwGroupBits> to set the data.
	MUSIC_TIME mtTime,		// @parm The time at which to set the data.
	void* pParam)			// @parm The struture containing the data to set. Each
							// <p rguidType> identifies a particular structure of a
							// particular size. It is important that this field contain
							// the correct structure of the correct size. Otherwise,
							// fatal results can occur.
{
	V_INAME(IDirectMusicSegment::SetParam);
	V_REFGUID(rguidType);

    if (m_fZombie)
	{
		Trace(2, "Warning: Call of IDirectMusicSegment::SetParam after the segment has been garbage collected.\n");
		return DMUS_S_GARBAGE_COLLECTED;
	}
    ENTER_API_CRITICAL_SECTION;
	HRESULT hr = DMUS_E_TRACK_NOT_FOUND;
	IDirectMusicTrack* pTrack;
    DWORD dwCounter = dwIndex;
    DWORD dwMax = dwIndex;
    if (dwIndex == DMUS_SEG_ALLTRACKS)
    {
        dwCounter = 0;
        dwMax = DMUS_SEG_ALLTRACKS;
    }
    while (SUCCEEDED( GetTrackByParam( rguidType, dwGroupBits, dwCounter, &pTrack )))
	{
		hr = pTrack->SetParam( rguidType, mtTime, pParam );
		pTrack->Release();
        dwCounter++;
        if (dwCounter > dwMax) break;
	}
#ifdef DBG
    if (hr == DMUS_E_TRACK_NOT_FOUND)
    {
        Trace(2,"Warning: Segment SetParam failed to find the requested track.\n");
    }
#endif
    LEAVE_API_CRITICAL_SECTION;
	return hr;
}

STDMETHODIMP CSegment::SetWavePlaybackParams(DWORD dwFlags, DWORD dwReadAhead)

{
    DMUS_IO_WAVE_HEADER ioParams;
#if DBG
    if (dwReadAhead < DMUS_READAHEAD_MIN) {
        Trace(1,"Warning: dwReadhead is less than minimum required. dwReadAhead reset to %d ms\n",DMUS_READAHEAD_MIN);
    }    
#endif

    ioParams.rtReadAhead = max(dwReadAhead * REF_PER_MIL, DMUS_READAHEAD_MIN*REF_PER_MIL);
    ioParams.dwFlags = dwFlags;

    return SetParam(GUID_WavePlayParams,-1,0,0,&ioParams);
}


STDMETHODIMP CSegment::Download(IUnknown *pAudioPath)

{
	V_INAME(IDirectMusicSegment::Download);
    V_INTERFACE(pAudioPath);
    HRESULT hr = S_OK;

    if (m_fZombie)
	{
		Trace(2, "Warning: Call of IDirectMusicSegment::Download after the segment has been garbage collected.\n");
		return DMUS_S_GARBAGE_COLLECTED;
	}

    // Validate that pAudioPath is either a performance or an audio path 
    IDirectMusicPerformance* pPerf = NULL;
    if ( FAILED(hr = pAudioPath->QueryInterface(IID_IDirectMusicPerformance, (void**)&pPerf)) )
    {
        IDirectMusicAudioPath* pAP = NULL;
        if ( FAILED(hr = pAudioPath->QueryInterface(IID_IDirectMusicAudioPath, (void**)&pAP)) )
        {
            return hr; // nothing to release, since all the QI's failed.
        }
        else
        {
            pAP->Release();
        }
    }
    else
    {
        pPerf->Release();
    }

    hr = SetParam(GUID_DownloadToAudioPath,-1,DMUS_SEG_ALLTRACKS,0,pAudioPath);
    if (hr == DMUS_E_TRACK_NOT_FOUND)
    {
        Trace(2,"Attempted download to a segment that has no tracks that support downloading (wave and band tracks.)\n");
        hr = S_OK;
    }
    return hr;
}

STDMETHODIMP CSegment::Unload(IUnknown *pAudioPath)

{
	V_INAME(IDirectMusicSegment::Unload);
    V_INTERFACE(pAudioPath);

    if (m_fZombie)
	{
		Trace(2, "Warning: Call of IDirectMusicSegment::Unload after the segment has been garbage collected.\n");
		return DMUS_S_GARBAGE_COLLECTED;
	}

    HRESULT hr = SetParam(GUID_UnloadFromAudioPath,-1,DMUS_SEG_ALLTRACKS,0,pAudioPath);
    if (hr == DMUS_E_TRACK_NOT_FOUND)
    {
        Trace(2,"Attempted unload from a segment that has no tracks that support downloading (wave and band tracks.)\n");
        hr = S_OK;
    }
    return hr;
}

STDMETHODIMP CSegment::SetTrackConfig(REFGUID rguidTrackClassID,
                                      DWORD dwGroup, DWORD dwIndex, 
                                      DWORD dwFlagsOn, DWORD dwFlagsOff)  
{
	V_INAME(IDirectMusicSegment::SetTrackConfig);
	V_REFGUID(rguidTrackClassID);
    if (rguidTrackClassID == GUID_NULL)
    {
        return E_INVALIDARG;
    }
#ifdef DXAPI
    if (m_fZombie)
	{
		Trace(2, "Warning: Call of IDirectMusicSegment::SetTrackConfig after the segment has been garbage collected.\n");
		return DMUS_S_GARBAGE_COLLECTED;
	}
#endif
    HRESULT hr = DMUS_E_TRACK_NOT_FOUND;
    CTrack* pCTrack;
    DWORD dwCounter = dwIndex;
    DWORD dwMax = dwIndex;
    if (dwIndex == DMUS_SEG_ALLTRACKS)
    {
        dwCounter = 0;
        dwMax = DMUS_SEG_ALLTRACKS;
    }
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    while (pCTrack = GetTrack(rguidTrackClassID,dwGroup,dwCounter))
    {
        pCTrack->m_dwFlags &= ~dwFlagsOff;
        pCTrack->m_dwFlags |= dwFlagsOn;
        hr = S_OK;
        dwCounter++;
        if (dwCounter > dwMax) break;
    }
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
#ifdef DBG
    if (hr == DMUS_E_TRACK_NOT_FOUND)
    {
        Trace(1,"Error: Segment SetTrackConfig failed to find the requested track.\n");
    }
#endif
	return hr;
}

HRESULT CSegment::GetTrackConfig(REFGUID rguidTrackClassID,
                                      DWORD dwGroup, DWORD dwIndex, DWORD *pdwFlags) 
{

	HRESULT hr = DMUS_E_TRACK_NOT_FOUND;
    CTrack* pCTrack;
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
	pCTrack = GetTrack(rguidTrackClassID,dwGroup,dwIndex);
	if (pCTrack)
    {
        *pdwFlags = pCTrack->m_dwFlags;
        hr = S_OK;
    }
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
	return hr;
}


STDMETHODIMP CSegment::Clone(
			MUSIC_TIME mtStart,	// @parm The start of the part to clone. If less than 0,
								// or greater than the length of the Segment, 0 will be used.
			MUSIC_TIME mtEnd,	// @parm The end of the part to clone. If past the end of the
								// Segment, it will clone to the end. Also, a value of 0 or
								// anything less than <p mtStart> will also clone to the end.
			IDirectMusicSegment** ppSegment	// @parm Returns the created Segment, if successful.
								// It is caller's responsibility to call Release() when finished
								// with it.
		)
{
	V_INAME(IDirectMusicSegment::Clone);
	V_PTRPTR_WRITE(ppSegment);

    if (m_fZombie)
	{
		Trace(2, "Warning: Call of IDirectMusicSegment::Clone after the segment has been garbage collected.\n");
		return DMUS_S_GARBAGE_COLLECTED;
	}

	CSegment* pCSegment;
	HRESULT hr = S_OK;

	if( (mtEnd < mtStart) || (mtEnd > m_mtLength) )
	{
		mtEnd = m_mtLength;
	}
	if( ( mtEnd == 0 ) && ( mtStart == 0 ))
	{
		mtEnd = m_mtLength;
	}
	if( (mtStart < 0) || (mtStart > m_mtLength) )
	{
		mtStart = 0;
	}
    pCSegment = new CSegment;
    if (pCSegment == NULL) {
        return E_OUTOFMEMORY;
    }
    // Addref to 1 and assign to ppSegment.
    pCSegment->AddRef();
    (*ppSegment) = (IDirectMusicSegment *) pCSegment;
	if( m_pGraph )
	{
		pCSegment->m_pGraph = m_pGraph;
		m_pGraph->AddRef();
	}
    if (m_pAudioPathConfig)
    {
        pCSegment->m_pAudioPathConfig = m_pAudioPathConfig;
        m_pAudioPathConfig->AddRef();
    }
    pCSegment->m_dwRepeats = m_dwRepeats;
    pCSegment->m_dwResolution = m_dwResolution;
    pCSegment->m_dwSegFlags = m_dwSegFlags;
	pCSegment->m_mtLength = mtEnd - mtStart;
	pCSegment->m_rtLength = m_rtLength;
    pCSegment->m_mtStart = m_mtStart;
    pCSegment->m_mtLoopStart = m_mtLoopStart;
    pCSegment->m_mtLoopEnd = m_mtLoopEnd;
    pCSegment->m_Info = m_Info;
    pCSegment->m_dwVersion = m_dwVersion;
    pCSegment->m_dwLoadID = m_dwLoadID;
    pCSegment->m_dwPlayID = m_dwPlayID;
    pCSegment->m_dwNextPlayID = m_dwNextPlayID;
    pCSegment->m_dwNextPlayFlags = m_dwNextPlayFlags;

	CTrack* pCTrack;
	IDirectMusicTrack* pTrack;
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
	pCTrack = m_TrackList.GetHead();
	while( pCTrack )
	{
		if( SUCCEEDED( pCTrack->m_pTrack->Clone( mtStart, mtEnd, &pTrack )))
		{
			if( FAILED( pCSegment->InsertTrack( pTrack, pCTrack->m_dwGroupBits, pCTrack->m_dwFlags, pCTrack->m_dwPriority, pCTrack->m_dwPosition )))
			{
                Trace(1,"Warning: Insertion of cloned track failed, cloned segment is incomplete.\n");
				hr = S_FALSE;
			}
			pTrack->Release();
		}
		else
		{
            Trace(1,"Warning: Track clone failed, cloned segment is incomplete.\n");
			hr = S_FALSE;
		}
		pCTrack = pCTrack->GetNext();
	}
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
	return hr;
}

STDMETHODIMP CSegment::GetAudioPathConfig(IUnknown ** ppAudioPathConfig)

{
    V_INAME(IDirectMusicSegment::GetAudioPathConfig);
	V_PTRPTR_WRITE(ppAudioPathConfig);

    if (m_fZombie)
	{
		Trace(2, "Warning: Call of IDirectMusicSegment::GetAudioPathConfig after the segment has been garbage collected.\n");
		return DMUS_S_GARBAGE_COLLECTED;
	}

    HRESULT hr;
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    if (m_pAudioPathConfig)
    {
        hr = m_pAudioPathConfig->QueryInterface(IID_IUnknown,(void **)ppAudioPathConfig);
    }
    else
    {
        Trace(2,"Warning: No embedded audiopath configuration in the segment.\n"); 
        hr = DMUS_E_NO_AUDIOPATH_CONFIG;
    }
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    return hr;
}

#ifndef XBOX
STDMETHODIMP CSegment::GetObjectInPath(DWORD dwPChannel,    /* PChannel to search. */
                                DWORD dwStage,       /* Which stage in the path. */
                                DWORD dwBuffer,
                                REFGUID guidObject,  /* ClassID of object. */
                                DWORD dwIndex,       /* Which object of that class. */
                                REFGUID iidInterface,/* Requested COM interface. */
                                void ** ppObject) 

{
    V_INAME(IDirectMusicSegment::GetObjectInPath);
	V_PTRPTR_WRITE(ppObject);

    if (m_fZombie)
	{
		Trace(2, "Warning: Call of IDirectMusicSegment::GetObjectInPath after the segment has been garbage collected.\n");
		return DMUS_S_GARBAGE_COLLECTED;
	}

    HRESULT hr = DMUS_E_NOT_FOUND;
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    if (dwStage == DMUS_PATH_SEGMENT_TRACK)
    {
        CTrack * pCTrack = GetTrack(guidObject,-1,dwIndex);
	    if (pCTrack)
        {
            if (pCTrack->m_pTrack)
            {
                hr = pCTrack->m_pTrack->QueryInterface(iidInterface,ppObject);
            }
        }
    }
    else if (dwStage == DMUS_PATH_SEGMENT_GRAPH)
    {
        if (dwIndex == 0)
        {
            if (!m_pGraph)
            {
                m_pGraph = new CGraph;
            }
            if (m_pGraph)
            {
                hr = m_pGraph->QueryInterface(iidInterface,ppObject);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    else if (dwStage == DMUS_PATH_SEGMENT_TOOL)
    {
        if (!m_pGraph)
        {
            m_pGraph = new CGraph;
        }
        if (m_pGraph)
        {
            hr = m_pGraph->GetObjectInPath(dwPChannel,guidObject,dwIndex,iidInterface,ppObject);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else if (dwStage >= DMUS_PATH_BUFFER)
    {
        // Nothing here now. But, in DX9, we may add support for addressing the buffer configuration 
        // and DMOS in it.
    }
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    return hr;
}
#endif // !XBOX

STDMETHODIMP CSegment::Compose(MUSIC_TIME mtTime,
								IDirectMusicSegment* pFromSegment,
								IDirectMusicSegment* pToSegment,
								IDirectMusicSegment** ppComposedSegment)

{
    V_INAME(IDirectMusicSegment::Compose);
    V_INTERFACE_OPT(pFromSegment);
    V_INTERFACE_OPT(pToSegment);
	V_PTRPTR_WRITE_OPT(ppComposedSegment);
#ifdef DBG
    if (pFromSegment)
    {
        MUSIC_TIME mtLength, mtLoopEnd, mtLoopStart;
        DWORD dwRepeats;
        // To calculate the full length, we need to access the loop parameters.
        pFromSegment->GetLoopPoints(&mtLoopStart,&mtLoopEnd);
        pFromSegment->GetRepeats(&dwRepeats);
        pFromSegment->GetLength(&mtLength);
        // If repeats is set to infinite, the total length will be greater than 32 bits.
        LONGLONG llTotalLength = dwRepeats * (mtLoopEnd - mtLoopStart) + mtLength;
        if (mtTime >= (llTotalLength & 0x7FFFFFFF)) 
        {
            Trace(2,"Warning: A time value of %ld was passed to Compose for a segment of length %ld.\n",
                mtTime, (long) llTotalLength);
        }
    }
#endif
    if (m_fZombie)
	{
		Trace(2, "Warning: Call of IDirectMusicSegment::Compose after the segment has been garbage collected.\n");
		return DMUS_S_GARBAGE_COLLECTED;
	}

	HRESULT hr = S_OK;
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    ENTER_API_CRITICAL_SECTION;
	if (ppComposedSegment)
	{
		hr = Clone(0, m_mtLength, ppComposedSegment);
		if (SUCCEEDED(hr))
		{
			hr = ((CSegment*)*ppComposedSegment)->ComposeTransition(mtTime, pFromSegment, pToSegment);
		}
	}
	else
	{
		hr = ComposeTransition(mtTime, pFromSegment, pToSegment);
	}

    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    LEAVE_API_CRITICAL_SECTION;
	return hr;
}

HRESULT CSegment::ComposeTransition(MUSIC_TIME mtTime,
									IDirectMusicSegment* pFromSegment,
									IDirectMusicSegment* pToSegment)
{
	HRESULT hr = S_OK;
	bool fTrackPadded = false;

	// Compute amount of time to pad any tracks that need padding.
	DMUS_TIMESIGNATURE TimeSig;
	if (!pFromSegment ||
		FAILED(pFromSegment->GetParam(GUID_TimeSignature, 0xffffffff, 0, mtTime, NULL, (void*) &TimeSig)))
	{
		TimeSig.mtTime = 0;
		TimeSig.bBeatsPerMeasure = 4;
		TimeSig.bBeat = 4;
		TimeSig.wGridsPerBeat = 4;
	}
	else // avoid divide-by-zero
	{
		if (!TimeSig.bBeat) TimeSig.bBeat = 4;
	}
	MUSIC_TIME mtBar = ( DMUS_PPQ * 4 * TimeSig.bBeatsPerMeasure ) / TimeSig.bBeat;
	MUSIC_TIME mtStartPad = min(mtBar, mtTime);
	if (!pFromSegment) mtStartPad = 0;
	MUSIC_TIME mtToLength = 0;
	if (pToSegment) pToSegment->GetLength(&mtToLength);
	MUSIC_TIME mtEndPad = min(mtBar, mtToLength);

	// Instantiate tracks
	CTrack* pTrack = m_TrackList.GetHead();
    for (; pTrack; pTrack = pTrack->GetNext())
	{
		pTrack->m_dwInternalFlags &= ~(TRACKINTERNAL_START_PADDED | TRACKINTERNAL_END_PADDED);
		IDirectMusicTrack* pTransTrack1 = NULL;
		IDirectMusicTrack* pTransTrack2 = NULL;
		GUID guidClassID;
		memset(&guidClassID, 0, sizeof(guidClassID));
		IPersist* pPersist = NULL;
		if (SUCCEEDED(pTrack->m_pTrack->QueryInterface(IID_IPersistStream, (void**)&pPersist)))
		{
			pPersist->GetClassID(&guidClassID);
			pPersist->Release();
		}
		DWORD dwTrackGroup = 0;
		GetTrackGroup(pTrack->m_pTrack, &dwTrackGroup);

		// Get track info
		if (pTrack->m_dwFlags & COMPOSE_TRANSITION1)
		{
            // Clone the appropriate track, with length m_mtLength
			MUSIC_TIME mtStart = 0;
			if (pTrack->m_dwFlags & DMUS_TRACKCONFIG_TRANS1_FROMSEGCURRENT)
			{
				mtStart = mtTime;
			}
			MUSIC_TIME mtEnd = mtStart + m_mtLength;
			IDirectMusicTrack* pSourceTrack = NULL;
			if ( (pTrack->m_dwFlags & DMUS_TRACKCONFIG_TRANS1_FROMSEGSTART) ||
				 (pTrack->m_dwFlags & DMUS_TRACKCONFIG_TRANS1_FROMSEGCURRENT) )
			{
				if (pFromSegment)
				{
					hr = pFromSegment->GetTrack(guidClassID, dwTrackGroup, 0, &pSourceTrack);
				}
			}
			else if (pTrack->m_dwFlags & DMUS_TRACKCONFIG_TRANS1_TOSEGSTART)
			{
				if (pToSegment)
				{
					hr = pToSegment->GetTrack(guidClassID, dwTrackGroup, 0, &pSourceTrack);
				}
			}
			if (pSourceTrack)
			{
				hr = pSourceTrack->Clone(mtStart, mtEnd, &pTransTrack1);
				pSourceTrack->Release();
				pSourceTrack = NULL;
			}
		}
		if (!pTransTrack1)
		{
			pTransTrack1 = pTrack->m_pTrack;
			pTransTrack1->AddRef();

		}
		if (pTransTrack1)
		{
			// Pad the track with an extra bar of header and trailer, by cloning header and trailer
			// tracks (from From and To segments, respectively --- *not* using transition flags) and 
			// joining them onto the transition segment track.
			IDirectMusicTrack* pStartPadTrack = NULL;
			IDirectMusicTrack* pEndPadTrack = NULL;
			IDirectMusicTrack* pSourceTrack = NULL;
			if (pFromSegment && mtStartPad)
			{
				hr = pFromSegment->GetTrack(guidClassID, dwTrackGroup, 0, &pSourceTrack);
				if (SUCCEEDED(hr))
				{
					pSourceTrack->Clone(mtTime - mtStartPad, mtTime, &pStartPadTrack);
					pSourceTrack->Release();
					pSourceTrack = NULL;
				}
			}
			if (pToSegment && mtEndPad)
			{
				hr = pToSegment->GetTrack(guidClassID, dwTrackGroup, 0, &pSourceTrack);
				if (SUCCEEDED(hr))
				{
					pSourceTrack->Clone(0, mtEndPad, &pEndPadTrack);
					pSourceTrack->Release();
					pSourceTrack = NULL;
				}
			}
			IDirectMusicTrack8* pTrack8 = NULL;
			if (pEndPadTrack)
			{
				if (SUCCEEDED(pTransTrack1->QueryInterface(IID_IDirectMusicTrack8, (void**)&pTrack8)))
				{
					if (SUCCEEDED(pTrack8->Join(pEndPadTrack, m_mtLength, (IDirectMusicSegment*)this, dwTrackGroup, NULL)))
					{
						fTrackPadded = true;
						pTrack->m_dwInternalFlags |= TRACKINTERNAL_END_PADDED;
					}
					pTrack8->Release();
				}
				pEndPadTrack->Release();
			}
			if (SUCCEEDED(hr) && pStartPadTrack)
			{
				if (SUCCEEDED(hr = pStartPadTrack->QueryInterface(IID_IDirectMusicTrack8, (void**)&pTrack8)))
				{
					if (SUCCEEDED(pTrack8->Join(pTransTrack1, mtStartPad, (IDirectMusicSegment*)this, dwTrackGroup, NULL)))
					{
						fTrackPadded = true;
						pTrack->m_dwInternalFlags |= TRACKINTERNAL_START_PADDED;
						pTransTrack1->Release();
						pTransTrack1 = pStartPadTrack;
					}
					else
					{
						pStartPadTrack->Release();
					}
					pTrack8->Release();
				}
				else
				{
					pStartPadTrack->Release();
				}
			}
            else if(pStartPadTrack)
			{
				pStartPadTrack->Release();
			}

			// Replace the current track with the instantiated one
			IDirectMusicTrack8* pTempTrack8 = NULL;
			pTransTrack1->QueryInterface(IID_IDirectMusicTrack8, (void**)&pTempTrack8);
			if (pTrack->m_pTrack) pTrack->m_pTrack->Release();
			pTrack->m_pTrack = pTransTrack1;
            pTrack->m_pTrack->Init( this );
			if (pTrack->m_pTrack8) pTrack->m_pTrack8->Release();
			pTrack->m_pTrack8 = pTempTrack8;
		}

		if (FAILED(hr)) break;
	}
	MUSIC_TIME mtOldLength = m_mtLength;
	if (fTrackPadded) // any tracks got joined with header/trailer info
	{
        // pad the length of the segment, to account for the header/trailer
		m_mtLength += mtStartPad + mtEndPad;
	}

	// Compose
	if (SUCCEEDED(hr))
	{
		hr = ComposeInternal();
	}

	// Back end
	if (fTrackPadded) // any tracks got joined with header/trailer info
	{
        // Trim header and trailer from each track that was joined, using Clone.
		pTrack = m_TrackList.GetHead();
		for (; pTrack; pTrack = pTrack->GetNext())
		{
			if ( (pTrack->m_pTrack) && (pTrack->m_dwInternalFlags & TRACKINTERNAL_START_PADDED) )
			{
				IDirectMusicTrack* pTempTrack = NULL;
				IDirectMusicTrack8* pTempTrack8 = NULL;
				pTrack->m_pTrack->Clone(mtStartPad, mtOldLength + mtStartPad, &pTempTrack);
				pTempTrack->QueryInterface(IID_IDirectMusicTrack8, (void**)&pTempTrack8);
				pTrack->m_pTrack->Release();
				pTrack->m_pTrack = pTempTrack;
				pTrack->m_pTrack->Init( this );
				if (pTrack->m_pTrack8) pTrack->m_pTrack8->Release();
				pTrack->m_pTrack8 = pTempTrack8;
			}
			else if ( (pTrack->m_pTrack) && (pTrack->m_dwInternalFlags & TRACKINTERNAL_END_PADDED) )
			{
				IDirectMusicTrack* pTempTrack = NULL;
				IDirectMusicTrack8* pTempTrack8 = NULL;
				pTrack->m_pTrack->Clone(0, mtOldLength, &pTempTrack);
				pTempTrack->QueryInterface(IID_IDirectMusicTrack8, (void**)&pTempTrack8);
				pTrack->m_pTrack->Release();
				pTrack->m_pTrack = pTempTrack;
				pTrack->m_pTrack->Init( this );
				if (pTrack->m_pTrack8) pTrack->m_pTrack8->Release();
				pTrack->m_pTrack8 = pTempTrack8;
			}
			pTrack->m_dwInternalFlags &= ~(TRACKINTERNAL_START_PADDED | TRACKINTERNAL_END_PADDED);
		}
        // Return the length of the segment to its original value. 
 		m_mtLength = mtOldLength;
	}

	return hr;
}

HRESULT CSegment::ComposeInternal()
{
	HRESULT hr = S_OK;
	TList<CTrack*> TrackList;
	// Find the composing tracks and put them in priority order
	CTrack* pTrack = m_TrackList.GetHead();
    for (; pTrack; pTrack = pTrack->GetNext())
	{
		if (pTrack->m_dwFlags & DMUS_TRACKCONFIG_COMPOSING)
		{
			TListItem<CTrack*>* pTrackItem = new TListItem<CTrack*>(pTrack);
			if (!pTrackItem)
			{
				hr = E_OUTOFMEMORY;
			}
			else
			{
				TListItem<CTrack*>* pMaster = TrackList.GetHead();
				TListItem<CTrack*>* pPrevious = NULL;
				for (; pMaster; pMaster = pMaster->GetNext())
				{
					CTrack*& rpMaster = pMaster->GetItemValue();
					if (pTrack->m_dwPriority > rpMaster->m_dwPriority) break;
					pPrevious = pMaster;
				}
				if (!pPrevious) // this has higher priority than anything in the list
				{
					TrackList.AddHead(pTrackItem);
				}
				else // lower priority than pPrevious, higher than pMaster
				{
					pTrackItem->SetNext(pMaster);
					pPrevious->SetNext(pTrackItem);
				}
			}
		}
		if (FAILED(hr)) break;
	}
	// Compose a new track from each from each composing track; put the results
	// in the segment (remove any existing composed tracks)
	if (SUCCEEDED(hr))
	{
		TListItem<CTrack*>* pTrackItem = TrackList.GetHead();
		for (; pTrackItem; pTrackItem = pTrackItem->GetNext())
		{
			CTrack*& rpTrack = pTrackItem->GetItemValue();
			IDirectMusicTrack8* pComposedTrack = NULL;
			hr = rpTrack->m_pTrack8->Compose((IDirectMusicSegment*)this, rpTrack->m_dwGroupBits, (IDirectMusicTrack**)&pComposedTrack);
			if (SUCCEEDED(hr))
			{
				// Remove any tracks of this type (in the same group) from the segment.
				IDirectMusicTrack* pOldTrack = NULL;
				GUID guidClassId;
				memset(&guidClassId, 0, sizeof(guidClassId));
				IPersistStream* pPersist = NULL;
				if (SUCCEEDED(pComposedTrack->QueryInterface(IID_IPersistStream, (void**)&pPersist)) )
				{
					if (SUCCEEDED(pPersist->GetClassID(&guidClassId)) &&
						SUCCEEDED( GetTrack( guidClassId, rpTrack->m_dwGroupBits, 0, &pOldTrack ) ) )
					{
						RemoveTrack( pOldTrack );
						pOldTrack->Release();
					}
					pPersist->Release();
				}
				hr = InsertTrack(pComposedTrack, rpTrack->m_dwGroupBits);
				pComposedTrack->Release();
			}
			if (FAILED(hr)) break;
		}
	}
	return hr;
}


STDMETHODIMP CSegment::GetStartPoint(
			MUSIC_TIME* pmtStart	// @parm Returns the Segment's start point.
		)
{
	V_INAME(IDirectMusicSegment::GetStartPoint);
#ifdef DXAPI
    if (m_fZombie)
	{
		Trace(2, "Warning: Call of IDirectMusicSegment::GetStartPoint after the segment has been garbage collected.\n");
		return DMUS_S_GARBAGE_COLLECTED;
	}
#endif
	*pmtStart = m_mtStart;
	return S_OK;
}

STDMETHODIMP CSegment::SetStartPoint(
			MUSIC_TIME mtStart	// @parm The start point at which to begin playing the
								// Segment. If it is less than zero or greater than the
								// length of the Segment, the start point will be set
								// to zero.
		)
{
	if( (mtStart < 0) || (mtStart >= m_mtLength) )
	{
        Trace(1,"Error: Unable to set start point %ld because not within the range of the segment, which is %ld.\n",
            mtStart,m_mtLength);
		return DMUS_E_OUT_OF_RANGE;
	}

#ifdef DXAPI
    if (m_fZombie)
	{
		Trace(2, "Warning: Call of IDirectMusicSegment::SetStartPoint after the segment has been garbage collected.\n");
		return DMUS_S_GARBAGE_COLLECTED;
	}
#endif
	m_mtStart = mtStart;
	return S_OK;
}

STDMETHODIMP CSegment::GetLoopPoints(
			MUSIC_TIME* pmtStart,	// @parm Returns the start point of the loop.
			MUSIC_TIME* pmtEnd		// @parm Returns the end point of the loop. A value of
									// 0 indicates that the entire Segment will loop.
		)
{
	V_INAME(IDirectMusicSegment::GetLoopPoints);
	V_PTR_WRITE(pmtStart, MUSIC_TIME);
	V_PTR_WRITE(pmtEnd, MUSIC_TIME);
#ifdef DXAPI
    if (m_fZombie)
	{
		Trace(2, "Warning: Call of IDirectMusicSegment::GetLoopPoints after the segment has been garbage collected.\n");
		return DMUS_S_GARBAGE_COLLECTED;
	}
#endif
	*pmtStart = m_mtLoopStart;
	*pmtEnd = m_mtLoopEnd;
	return S_OK;
}

STDMETHODIMP CSegment::SetLoopPoints(
			MUSIC_TIME mtStart,	// @parm The start point at which to begin the loop.
			MUSIC_TIME mtEnd	// @parm The end point at which to begin the loop. Set 
                                // <p mtStart> and <p mtEnd> to 0
								// to loop the entire Segment.
		)
{
#ifdef DXAPI
	if( (mtStart < 0) || (mtEnd > m_mtLength) || (mtStart > mtEnd) )
	{
        Trace(1,"Error: Unable to set loop points %ld, %ld because they are not within the range of the segment, which is %ld.\n",
            mtStart,mtStart,mtEnd,m_mtLength);
		return DMUS_E_OUT_OF_RANGE;
	}

    if (m_fZombie)
	{
		Trace(2, "Warning: Call of IDirectMusicSegment::SetLoopPoints after the segment has been garbage collected.\n");
		return DMUS_S_GARBAGE_COLLECTED;
	}
#endif
	m_mtLoopStart = mtStart;
	m_mtLoopEnd = mtEnd;
	return S_OK;
}

STDMETHODIMP CSegment::SetPChannelsUsed(
	DWORD dwNumPChannels,	// @parm The number of PChannels to set. This must be equal
							// to the number of members in the array pointed to by
							// <p paPChannels>.
	DWORD* paPChannels		// @parm Points to an array of PChannels. The array should
							// have the same number of elements as specified by <p dwNumPChannels>.
	)
{
	V_INAME(IDirectMusicSegment::SetPChannelsUsed);
#ifdef DXAPI
    if (m_fZombie)
	{
		Trace(2, "Warning: Call of IDirectMusicSegment::SetPChannelsUsed after the segment has been garbage collected.\n");
		return DMUS_S_GARBAGE_COLLECTED;
	}
#endif
	if( dwNumPChannels )
	{
		if( NULL == paPChannels )
		{
            Trace(1,"Error: Bad call to SetPChannelsUsed, pointer to PChannel array is NULL.\n");
			return E_INVALIDARG;
		}
		V_BUFPTR_READ(paPChannels, sizeof(DWORD)*dwNumPChannels);

		DWORD* padwTemp = new DWORD[dwNumPChannels]; // temp array
		DWORD dwTotalNum = 0;
		if( NULL == padwTemp )
		{
			return E_OUTOFMEMORY;
		}
		// count the number of unique PChannels are in the array. That is, the ones
		// that we don't already have stored.
		DWORD dwCount;
		for( dwCount = 0; dwCount < dwNumPChannels; dwCount++ )
		{
			DWORD dwCurrent;
			for( dwCurrent = 0; dwCurrent < m_dwNumPChannels; dwCurrent++ )
			{
				if( m_paPChannels[dwCurrent] == paPChannels[dwCount] )
				{
					// we already track this one
					break;
				}
			}
			if( dwCurrent >= m_dwNumPChannels )
			{
				// we're not already tracking this one
				padwTemp[dwTotalNum] = paPChannels[dwCount];
				dwTotalNum++;
			}
		}
		// dwTotalNum equals the total number of new PChannels, and they are indexed
		// inside adwTemp.
		DWORD* paNewPChannels = new DWORD[m_dwNumPChannels + dwTotalNum];
		if( NULL == paNewPChannels )
		{
			delete [] padwTemp;
			return E_OUTOFMEMORY;
		}
		if( m_paPChannels )
		{
			memcpy( paNewPChannels, m_paPChannels, sizeof(DWORD) * m_dwNumPChannels );
			delete [] m_paPChannels;
		}
		memcpy( &paNewPChannels[m_dwNumPChannels], padwTemp, sizeof(DWORD) * dwTotalNum );
		delete [] padwTemp;
		m_dwNumPChannels += dwTotalNum;
		m_paPChannels = paNewPChannels;
	}
	return S_OK;
}

#ifdef DXAPI
/////////////////////////////////////////////////////////////////////////////
// IDirectMusicSegmentObject (private)
HRESULT CSegment::GetPChannels(
	DWORD* pdwNumPChannels,	// returns the number of pchannels
	DWORD** ppaPChannels)	// returns a pointer to the array of pchannels. Don't free this
							// memory or keep it, as it is owned by the Segment.
{
	ASSERT(pdwNumPChannels && ppaPChannels);
	*pdwNumPChannels = m_dwNumPChannels;
	*ppaPChannels = m_paPChannels;
	return S_OK;
}
#endif
// return S_OK if the notification is active, S_FALSE if not.
HRESULT CSegment::CheckNotification( REFGUID rguid )
{
	if( NULL == FindNotification( rguid ) )
	{
		return S_FALSE;
	}
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CSegment::GetClassID( CLSID* pClassID )
{
	V_INAME(CSegment::GetClassID);
	V_PTR_WRITE(pClassID, CLSID); 
#ifdef DXAPI
    if (m_fZombie)
	{
		Trace(2, "Warning: Call of IDirectMusicSegment::GetClassID after the segment has been garbage collected.\n");
		return DMUS_S_GARBAGE_COLLECTED;
	}
#endif
	*pClassID = CLSID_DirectMusicSegment;
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPersistStream functions

HRESULT CSegment::IsDirty()
{
#ifdef DXAPI
    if (m_fZombie)
	{
		Trace(2, "Warning: Call of IDirectMusicSegment::IsDirty after the segment has been garbage collected.\n");
		return DMUS_S_GARBAGE_COLLECTED;
	}
#endif
	return S_FALSE;
}

#define DMUS_FOURCC_RMID_FORM    mmioFOURCC('R','M','I','D')
#define DMUS_FOURCC_data_FORM    mmioFOURCC('d','a','t','a')
#define DMUS_FOURCC_DLS_FORM    mmioFOURCC('D','L','S',' ')
#define FOURCC_SECTION_FORM     mmioFOURCC('A','A','S','E')

HRESULT CSegment::Load( IStream* pIStream )
{
	V_INAME(CSegment::Load);
	V_INTERFACE(pIStream);
#ifdef DXAPI
    if (m_fZombie)
	{
		Trace(2, "Warning: Call of IDirectMusicSegment::Load after the segment has been garbage collected.\n");
		return DMUS_S_GARBAGE_COLLECTED;
	}
#endif
	// Save stream's current position
	LARGE_INTEGER li;
    ULARGE_INTEGER ul;

    li.HighPart = 0;
    li.LowPart = 0;

    HRESULT hr = pIStream->Seek(li, STREAM_SEEK_CUR, &ul);
    
	if(FAILED(hr))
	{
		return hr;	
    }
	
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    Clear(false);

	DWORD dwSavedPos = ul.LowPart;
    
	// Read first 4 bytes to determine what type of stream we
	// have been passed

	FOURCC type;
	DWORD dwRead;
	hr = pIStream->Read(&type, sizeof(FOURCC), &dwRead);
	
	if(SUCCEEDED(hr) && dwRead == sizeof(FOURCC))
	{
		// Check for a RIFF file
		if(type == mmioFOURCC( 'R', 'I', 'F', 'F' ))
		{
            long lFileLength = 0;
            pIStream->Read(&lFileLength, sizeof(long), &dwRead);
			// Check to see if what type of RIFF file we have
			hr = pIStream->Read(&type, sizeof(FOURCC), &dwRead);

			if(SUCCEEDED(hr) && dwRead == sizeof(FOURCC))
			{
				if(type == DMUS_FOURCC_SEGMENT_FORM)	// We have a DirectMusic segment
				{
					// Since we now know what type of stream we need to 
					// seek back to saved position
					li.HighPart = 0;
					li.LowPart = dwSavedPos;
					hr = pIStream->Seek(li, STREAM_SEEK_SET, NULL);

					hr = LoadDirectMusicSegment(pIStream);
				}
#ifdef DXAPI
				else if(type == FOURCC_SECTION_FORM)	// We have section
				{
					// Since we now know what type of stream we need to seek back to saved position
					li.HighPart = 0;
					li.LowPart = dwSavedPos;
					hr = pIStream->Seek(li, STREAM_SEEK_SET, NULL);
					
					// Create Section
					IDMSection* pSection;
					if(SUCCEEDED(hr))
					{
						hr = DirectMusicCreateInstance(CLSID_DMSection,
												NULL,
												IID_IDMSection,
												(void**)&pSection);
					}

					if(SUCCEEDED(hr))
					{
						// Load Section
						IPersistStream* pIPersistStream;
						hr = pSection->QueryInterface(IID_IPersistStream, (void **)&pIPersistStream);
								
						if(SUCCEEDED(hr))
						{
							hr = pIPersistStream->Load(pIStream);
							pIPersistStream->Release();
						}

						if(SUCCEEDED(hr))
						{
							HRESULT hrTemp = pSection->CreateSegment(static_cast<IDirectMusicSegment*>(this));
							if (hrTemp != S_OK)
							{
								hr = hrTemp;
							}
						}
						
						pSection->Release();
					}
				}
				else if(type == DMUS_FOURCC_RMID_FORM)	// We have an RMID MIDI file
				{ 
                    IDirectMusicCollection *pCollection = NULL;
                    BOOL fLoadedMIDI = FALSE;
                    // Since it's a RIFF file, it could have more than one top level chunk.
                    while (SUCCEEDED(hr) && (lFileLength > 8))
                    {
					    FOURCC dwType = 0;	
					    DWORD dwRead;
                        DWORD dwLength;
					    pIStream->Read(&dwType, sizeof(FOURCC), &dwRead);
                        hr = pIStream->Read(&dwLength, sizeof(DWORD), &dwRead);
                        lFileLength -= 8;
                        if (FAILED(hr))
                        {
                            break;
                        }
                        ULARGE_INTEGER ulPosition;  // Memorize start of chunk.
                        LARGE_INTEGER liStart;
                        liStart.QuadPart = 0;
                        hr = pIStream->Seek(liStart, STREAM_SEEK_CUR, &ulPosition);
                        liStart.QuadPart = ulPosition.QuadPart;
                        if (dwType == DMUS_FOURCC_data_FORM)
                        {   // Get MIDI file header.
					        hr = pIStream->Read(&dwType, sizeof(FOURCC), &dwRead);
					        if(SUCCEEDED(hr) && (dwType == mmioFOURCC( 'M', 'T', 'h', 'd' )))
						    {
							    // Since we now know what type of stream we need to seek back to saved position
							    hr = pIStream->Seek(liStart, STREAM_SEEK_SET, NULL);

							    if(SUCCEEDED(hr))
							    {
								    hr = CreateSegmentFromMIDIStream(pIStream, 
				 												     static_cast<IDirectMusicSegment*>(this));
							    }
                                if (SUCCEEDED(hr)) fLoadedMIDI = TRUE;
						    }
                        }
                        else if ((dwType == mmioFOURCC( 'R', 'I', 'F', 'F' ) ||
                            (dwType == mmioFOURCC( 'L', 'I', 'S', 'T' ))))
                        {
                            pIStream->Read(&dwType, sizeof(FOURCC), &dwRead);
                            if (dwType == DMUS_FOURCC_DLS_FORM)
                            {
                                hr = DirectMusicCreateInstance(CLSID_DirectMusicCollection,
										NULL,
										IID_IDirectMusicCollection,
										(void**)&pCollection);
                                if (SUCCEEDED(hr))
                                {
                                    IPersistStream* pIPS;
				                    hr = pCollection->QueryInterface( IID_IPersistStream, (void**)&pIPS );
				                    if (SUCCEEDED(hr))
				                    {
            							// We need to seek back to start of chunk
                                        liStart.QuadPart -= 8;
							            pIStream->Seek(liStart, STREAM_SEEK_SET, NULL);

					                    hr = pIPS->Load( pIStream );
					                    pIPS->Release();
                                    }
                                    if (FAILED(hr))
                                    {
                                        pCollection->Release();
                                        pCollection = NULL;
                                    }
                                }
                            }
                        }
                        if (SUCCEEDED(hr))
                        {
                            if (dwLength & 1) ++dwLength;
                            ulPosition.QuadPart += dwLength; // Point to start of next chunk.
                            liStart.QuadPart = ulPosition.QuadPart;
                            hr = pIStream->Seek(liStart, STREAM_SEEK_SET, NULL);
                            lFileLength -= dwLength; // Decrement amount left in file.
                        }
                    }
                    if (pCollection)
                    {
                        if (fLoadedMIDI)
                        {
                            SetParam(GUID_ConnectToDLSCollection,-1,0,0,(void *) pCollection);
                        }
                        pCollection->Release();
                    }
                }
#endif
                else if (type == mmioFOURCC('W','A','V','E')) // we have a wave file
                {
                    IDirectSoundWave* pWave = NULL;
                    // Seek back to saved position
                    li.HighPart = 0;
                    li.LowPart = dwSavedPos;
                    hr = pIStream->Seek(li, STREAM_SEEK_SET, NULL);

                    // Check to see if this wave is embedded
                    if (dwSavedPos == 0)
                    {
                        // CoCreate the wave and load it from the stream
                        if (SUCCEEDED(hr))
                        {
                            hr = DirectMusicCreateInstance(CLSID_DirectSoundWave,
                                    NULL,
                                    IID_IDirectSoundWave,
                                    (void**)&pWave);

                            if (SUCCEEDED(hr))
                            {
                                IPersistStream* pIPS = NULL;

                                hr = pWave->QueryInterface(IID_IPersistStream, (void**)&pIPS);
                                if (SUCCEEDED(hr))
                                {
                                    hr = pIPS->Load( pIStream );
                                    pIPS->Release();
                                }

                                if (FAILED(hr))
                                {
                                    pWave->Release();
                                    pWave = NULL;
                                }
                            }
                        }
                    }
                    else
                    {
                        // Have the loader load the wave object from the stream
                        DMUS_OBJECTDESC descWave;
                        ZeroMemory(&descWave, sizeof(descWave));
                        descWave.dwSize = sizeof(descWave);
                        descWave.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_STREAM;
                        descWave.guidClass = CLSID_DirectSoundWave;
                        descWave.pStream = pIStream;
                        IDirectMusicLoader *pLoader = NULL;
                        IDirectMusicGetLoader *pGetLoader = NULL;
                        hr = pIStream->QueryInterface(IID_IDirectMusicGetLoader,(void **)&pGetLoader);
                        if (SUCCEEDED(hr))
                        {
                            if (SUCCEEDED(pGetLoader->GetLoader(&pLoader)))
                            {
                                hr = pLoader->GetObject(&descWave, IID_IDirectSoundWave, (void **)&pWave);
                                descWave.pStream = NULL;
                                descWave.dwValidData &= ~DMUS_OBJ_STREAM;
                                if (SUCCEEDED(hr))
                                {
                                    IDirectMusicObject* pObject = NULL;
                                    hr = pWave->QueryInterface(IID_IDirectMusicObject, (void **)&pObject);
                                    if (SUCCEEDED(hr))
                                    {
                                        // set this object to be a segment with the same GUID
                                        pObject->GetDescriptor(&descWave);
                                        descWave.guidClass = CLSID_DirectMusicSegment;
                                        SetDescriptor(&descWave);
                                        pObject->Release();
                                    }
                                }
                                pLoader->Release();
                            }
                            pGetLoader->Release();
                        }
                    }

                    if (pWave)
                    {

					    // CoCreate a wave track
					    IDirectMusicTrack* pWaveTrack = NULL;
					    if (SUCCEEDED(hr))
					    {
						    hr = DirectMusicCreateInstance(CLSID_DirectMusicWaveTrack,
												    NULL,
												    IID_IDirectMusicTrack,
												    (void**)&pWaveTrack);
					    }

					    // Add the wave object to the wave track, and insert the track in the segment.
					    if (SUCCEEDED(hr))
					    {
						    IPrivateWaveTrack* pPrivateWave = NULL;
						    hr = pWaveTrack->QueryInterface(IID_IPrivateWaveTrack, (void**)&pPrivateWave);
						    if (SUCCEEDED(hr))
						    {
							    REFERENCE_TIME rt = 0;
							    hr = pPrivateWave->AddWave(pWave, 0, 0, 0, &rt);
							    if (SUCCEEDED(hr))
							    {
								    SetClockTimeDuration(rt * REF_PER_MIL);
								    SetFlags(DMUS_SEGIOF_REFLENGTH);
							    }
							    InsertTrack(pWaveTrack, 1);
							    SetTrackConfig(CLSID_DirectMusicWaveTrack, 1, 0, DMUS_TRACKCONFIG_DEFAULT | DMUS_TRACKCONFIG_PLAY_CLOCKTIME,0);
							    pPrivateWave->Release();
						    }
					    }

					    // Clean up anything that's still hanging around
					    if (pWaveTrack) pWaveTrack->Release();
					    if (pWave) pWave->Release();
                    }
				}
			}
			else
			{
				hr = DMUS_E_CANNOTREAD;
			}
		}
#ifdef DXAPI
        // Check for a template file
		else if(type == mmioFOURCC('L', 'P', 'T', 's'))
		{
			// Since we now know what type of stream we need to seek back to saved position
			li.HighPart = 0;
			li.LowPart = dwSavedPos;
			hr = pIStream->Seek(li, STREAM_SEEK_SET, NULL);
			
			// Create Template
			IDMTempl* pTemplate;
			if(SUCCEEDED(hr))
			{
				hr = DirectMusicCreateInstance(CLSID_DMTempl,
										NULL,
										IID_IDMTempl,
										(void**)&pTemplate);
			}

			if(SUCCEEDED(hr))
			{
				// Load Template
				IPersistStream* pIPersistStream;
				hr = pTemplate->QueryInterface(IID_IPersistStream, (void **)&pIPersistStream);
						
				if(SUCCEEDED(hr))
				{
					hr = pIPersistStream->Load(pIStream);
					pIPersistStream->Release();
				}

				if(SUCCEEDED(hr))
				{
					hr = pTemplate->CreateSegment(static_cast<IDirectMusicSegment*>(this));
				}
				
				pTemplate->Release();
			}
		}		
		// Check for normal MIDI file
		else if(type == mmioFOURCC('M', 'T', 'h', 'd'))
	    {
			// Since we now know what type of stream we need to seek back to saved position
			li.HighPart = 0;
			li.LowPart = dwSavedPos;
			hr = pIStream->Seek(li, STREAM_SEEK_SET, NULL);

			if(SUCCEEDED(hr))
			{
				hr = CreateSegmentFromMIDIStream(pIStream, 
				 								 static_cast<IDirectMusicSegment*>(this));
			}	
		}
#endif
		else
		{
			// Not a DirectMusic Segment file, MIDI file or section or 
			// template; unsupported
            Trace(1,"Error: Segment unable to parse file. Must be segment, midi, wave, or rmi file format.\n");
			hr = DMUS_E_UNSUPPORTED_STREAM;
		}
	}
	else
	{
		hr = DMUS_E_CANNOTREAD;
	}
	if( SUCCEEDED(hr) )
	{
		m_Info.m_dwValidData |= DMUS_OBJ_LOADED;		
	}
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
	return hr;
}


HRESULT CSegment::Save( IStream* pIStream, BOOL fClearDirty )
{
	return E_NOTIMPL;
}

HRESULT CSegment::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
	return E_NOTIMPL;
}

HRESULT CSegment::LoadDirectMusicSegment(IStream* pIStream)
{
	// Argument validation
	assert(pIStream);
	CRiffParser Parser(pIStream);
    RIFFIO ckMain;
    HRESULT hr = S_OK;
    Parser.EnterList(&ckMain);  
    if (Parser.NextChunk(&hr))
    {
        if (ckMain.fccType == DMUS_FOURCC_SEGMENT_FORM)
        {
    	    RIFFIO ckNext;    // Descends into the next chunk.
	        RIFFIO ckChild;   // For scanning through children lists.
            IDirectMusicContainer *pContainer = NULL; // For handling embedded container with linked objects.
            Parser.EnterList(&ckNext);
	        while(Parser.NextChunk(&hr))
	        {
		        switch(ckNext.ckid)
		        {
                case DMUS_FOURCC_SEGMENT_CHUNK:
				    DMUS_IO_SEGMENT_HEADER ioSegHdr;
                    ioSegHdr.rtLoopStart = 0;
                    ioSegHdr.rtLoopEnd = 0;
                    ioSegHdr.rtLength = 0;
                    ioSegHdr.dwFlags = 0;
				    hr = Parser.Read(&ioSegHdr, sizeof(DMUS_IO_SEGMENT_HEADER));
				    if(SUCCEEDED(hr))
				    {
					    m_dwResolution = ioSegHdr.dwResolution;
					    m_mtLength = ioSegHdr.mtLength;
					    m_mtStart = ioSegHdr.mtPlayStart;
					    m_mtLoopStart = ioSegHdr.mtLoopStart;
					    m_mtLoopEnd = ioSegHdr.mtLoopEnd;
					    m_dwRepeats = ioSegHdr.dwRepeats;
                        m_dwSegFlags = ioSegHdr.dwFlags;
                        if (m_dwSegFlags & DMUS_SEGIOF_REFLENGTH)
                        {
                            m_rtLength = ioSegHdr.rtLength;
                        }
                        else
                        {
                            m_rtLength = 0; 
                        }
                        if (m_dwSegFlags & DMUS_SEGIOF_REFLOOP)
                        {
                            m_rtLoopStart = ioSegHdr.rtLoopStart;
                            m_rtLoopEnd = ioSegHdr.rtLoopEnd;
                        }
                        else
                        {
                            m_rtLoopStart = m_rtLoopEnd = 0;
                        }
				    }
				    break;
			    case DMUS_FOURCC_GUID_CHUNK:
			    case DMUS_FOURCC_VERSION_CHUNK:
			    case DMUS_FOURCC_CATEGORY_CHUNK:
			    case DMUS_FOURCC_DATE_CHUNK:
                    hr = m_Info.ReadChunk(&Parser,ckNext.ckid);
                    break;
			    case FOURCC_LIST:
                case FOURCC_RIFF:
				    switch(ckNext.fccType)
				    {
					    case DMUS_FOURCC_UNFO_LIST:
                            hr = m_Info.ReadChunk(&Parser,ckNext.fccType);
/*                            Parser.EnterList(&ckChild);
                            while (Parser.NextChunk(&hr))
						    {
							    switch( ckChild.ckid )
							    {
								    case DMUS_FOURCC_UNAM_CHUNK:
								    {
									    hr = Parser.Read(&m_wszName, sizeof(m_wszName));
									    if(SUCCEEDED(hr) )
									    {
										    m_dwValidData |= DMUS_OBJ_NAME;
									    }
									    break;
								    }
								    default:
									    break;
							    }
						    }
                            Parser.LeaveList();*/
						    break;
                        case DMUS_FOURCC_CONTAINER_FORM:
                            // An embedded container RIFF chunk which includes a bunch
                            // of objects referenced by the segment. This should precede the
                            // tracks and gets loaded prior to the tracks. Loading this
                            // causes all of its objects to get SetObject'd in the loader,
                            // so they later get pulled in as requested by the tracks.
                            // After the tracks are loaded, the loader references are
                            // released by a call to release the IDirectMusicContainer.
                            {
                                DMUS_OBJECTDESC Desc;
                                IDirectMusicLoader *pLoader;
                                IDirectMusicGetLoader *pGetLoader;
                                HRESULT hr = pIStream->QueryInterface(IID_IDirectMusicGetLoader,(void **) &pGetLoader);
                                if (SUCCEEDED(hr))
                                {
                                    if (SUCCEEDED(pGetLoader->GetLoader(&pLoader)))
                                    {
                                   	    // Move back stream's current position
                                        Parser.SeekBack();
                                        Desc.dwSize = sizeof(Desc);
                                        Desc.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_STREAM;
                                        Desc.guidClass = CLSID_DirectMusicContainer;
                                        Desc.pStream = pIStream;
                                        pLoader->GetObject(&Desc,IID_IDirectMusicContainer,(void **) &pContainer);
                                        if (pContainer)
                                        {
                                            // Don't cache the container object! We want it and the
                                            // objects it references to go away when the segment is done loading.
#ifdef DXAPI
                                            IDirectMusicObject *pObject = NULL;
                                            pContainer->QueryInterface(IID_IDirectMusicObject,(void **)&pObject);
                                            if (pObject)
                                            {
                                                pLoader->ReleaseObject(pObject);
                                                pObject->Release();
                                            }
#else
                                            pLoader->ReleaseObjectByUnknown(pContainer);
#endif
                                        }
                                        // Now, seek to the end of this chunk.
                                        Parser.SeekForward();
                                        pLoader->Release();
                                    }
                                    pGetLoader->Release();
                                }
                            }
                            break;
					    case DMUS_FOURCC_TRACK_LIST:
                            Parser.EnterList(&ckChild);
                            while(Parser.NextChunk(&hr))
	                        {	
		                        if ((ckChild.ckid == FOURCC_RIFF) && (ckChild.fccType == DMUS_FOURCC_TRACK_FORM))
                                {
			                        hr = LoadTrack(&Parser);
		                        }
	                        }
                            Parser.LeaveList();
						    break;
    				    case DMUS_FOURCC_TOOLGRAPH_FORM:
						    hr = LoadGraph(&Parser,&m_pGraph);
						    break;
                        case DMUS_FOURCC_AUDIOPATH_FORM:
                            // Move back to start of this chunk.
                            Parser.SeekBack();
                            hr = LoadAudioPath(pIStream);
                            // Now, seek to the end of this chunk.
                            Parser.SeekForward();
                            break;
				    }
				    break;
		        }
            }
            Parser.LeaveList();
            if (pContainer)
            {
                pContainer->Release();
            }
        }
        else 
        {
            Trace(1,"Error: Unknown file format.\n");
            hr = DMUS_E_DESCEND_CHUNK_FAIL;
        }
    }
    Parser.LeaveList();
#ifdef DXAPI
    if (SUCCEEDED(hr) && Parser.ComponentFailed())
    {
        Trace(1,"Warning: Segment successfully loaded but one or more tracks within it did not.\n");
        hr = DMUS_S_PARTIALLOAD;
    }
#endif
	return hr;
}

HRESULT CSegment::LoadTrack(CRiffParser *pParser)
{
    BOOL fHeaderRead = FALSE;

	DMUS_IO_TRACK_HEADER ioTrackHdr;
    DMUS_IO_TRACK_EXTRAS_HEADER ioTrackExtrasHdr;
    ioTrackExtrasHdr.dwPriority = 0;
    ioTrackExtrasHdr.dwFlags = DMUS_TRACKCONFIG_DEFAULT;
    ioTrackHdr.ckid = 0;
    ioTrackHdr.fccType = 0;
    ioTrackHdr.dwPosition = 0;

	RIFFIO ckNext;
	HRESULT hr = S_OK;
    pParser->EnterList(&ckNext);
    while(pParser->NextChunk(&hr))
	{	
        if (ckNext.ckid == DMUS_FOURCC_TRACK_CHUNK)
        {
            fHeaderRead = TRUE;
		    hr = pParser->Read(&ioTrackHdr, sizeof(DMUS_IO_TRACK_HEADER));
		    if(ioTrackHdr.ckid == 0 && ioTrackHdr.fccType == NULL)
		    {
                Trace(1,"Error: Invalid track header in Segment.\n");
			    hr = DMUS_E_INVALID_TRACK_HDR;
		    }
        }
        else if (ckNext.ckid == DMUS_FOURCC_TRACK_EXTRAS_CHUNK)
        {
		    hr = pParser->Read(&ioTrackExtrasHdr, sizeof(DMUS_IO_TRACK_EXTRAS_HEADER));
        }
        else if((((ckNext.ckid == FOURCC_LIST) || (ckNext.ckid == FOURCC_RIFF))
		    && ckNext.fccType == ioTrackHdr.fccType) ||
            (ckNext.ckid == ioTrackHdr.ckid))
		{
            if (fHeaderRead)
		    {	
                // Okay, this is the chunk we are looking for.
                // Seek back to start of chunk.
                pParser->SeekBack();
#ifdef DXAPI
                // Let the parser know it's okay to fail this.
                pParser->EnteringComponent();
#endif
			    hr = CreateTrack(ioTrackHdr, ioTrackExtrasHdr.dwFlags, ioTrackExtrasHdr.dwPriority, pParser->GetStream());
                // Now, make sure we are at the end of the chunk.
                pParser->SeekForward();
            }
            else
            {
                Trace(1,"Error: Invalid track in Segment - track header is not before track data.\n");
			    hr = DMUS_E_TRACK_HDR_NOT_FIRST_CK;
		    }	

        }
	}
    pParser->LeaveList();
	return hr;
}

HRESULT CSegment::CreateTrack(DMUS_IO_TRACK_HEADER& ioTrackHdr, DWORD dwFlags, DWORD dwPriority, IStream *pStream)
{
	assert(pStream);

	IDirectMusicTrack* pDMTrack = NULL;
	HRESULT hrTrack = S_OK;
	HRESULT hr = DirectMusicCreateInstance(ioTrackHdr.guidClassID,
								  NULL,
								  IID_IDirectMusicTrack,
								  (void**)&pDMTrack);

    IPersistStream *pIPersistStream = NULL;
	
	if(SUCCEEDED(hr))
	{
		hr = pDMTrack->QueryInterface(IID_IPersistStream, (void **)&pIPersistStream);
	}

	if(SUCCEEDED(hr))
	{
		hr = hrTrack = pIPersistStream->Load(pStream);
	}

	if(SUCCEEDED(hr))
	{
		hr = InsertTrack(pDMTrack, ioTrackHdr.dwGroup, dwFlags, dwPriority, ioTrackHdr.dwPosition);
	}

	if(pIPersistStream)
	{
		pIPersistStream->Release();
	}
	
	if(pDMTrack)
	{
		pDMTrack->Release();
	}

	if (hr == S_OK && hrTrack != S_OK)
	{
		hr = hrTrack;
	}
	return hr;
}

HRESULT CSegment::LoadGraph(CRiffParser *pParser,CGraph **ppGraph)
{
    CGraph *pGraph = new CGraph;
    if (pGraph == NULL) {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pGraph->Load(pParser);

    ENTER_CRITICAL_SECTION(&m_CriticalSection);
	if(*ppGraph)
	{
		(*ppGraph)->Release();
	}
	*ppGraph = pGraph;
	LEAVE_CRITICAL_SECTION(&m_CriticalSection);
	
	return hr;
}

HRESULT CSegment::LoadAudioPath(IStream *pStream)
{
	assert(pStream);

    CAudioPathConfig *pPath = new CAudioPathConfig;
    if (pPath == NULL) {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pPath->Load(pStream);

    if (FAILED(hr))
    {
        Trace(1,"Segment failed loading embedded AudioPath Configuration\n");
    }

    ENTER_CRITICAL_SECTION(&m_CriticalSection);
	if(m_pAudioPathConfig)
	{
		m_pAudioPathConfig->Release();
	}
	m_pAudioPathConfig = pPath;
    if (m_dwVersion < 8) m_dwVersion = 8;
	LEAVE_CRITICAL_SECTION(&m_CriticalSection);
	
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// IDirectMusicObject

STDMETHODIMP CSegment::GetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
	// Argument validation
	V_INAME(CSegment::GetDescriptor);
    V_PTR_WRITE(pDesc, DMUS_OBJECTDESC);
#ifdef DXAPI
    if (m_fZombie)
	{
		Trace(2, "Warning: Call of IDirectMusicSegment::GetDescriptor after the segment has been garbage collected.\n");
		return DMUS_S_GARBAGE_COLLECTED;
	}
#endif
    if (pDesc->dwSize)
    {
	    V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);
    }
    else
    {
        pDesc->dwSize = sizeof(DMUS_OBJECTDESC);
    }

    return m_Info.GetDescriptor(pDesc,CLSID_DirectMusicSegment);
}

STDMETHODIMP CSegment::SetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
	// Argument validation
	V_INAME(CSegment::SetDescriptor);
    V_PTR_READ(pDesc, DMUS_OBJECTDESC);
#ifdef DXAPI
    if (m_fZombie)
	{
		Trace(2, "Warning: Call of IDirectMusicSegment::SetDescriptor after the segment has been garbage collected.\n");
		return DMUS_S_GARBAGE_COLLECTED;
	}
#endif
	if (pDesc->dwSize)
    {
	    V_STRUCTPTR_READ(pDesc, DMUS_OBJECTDESC);
    }
	
	return m_Info.SetDescriptor(pDesc);
}

STDMETHODIMP CSegment::ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc) 
{
	V_INAME(CSegment::ParseDescriptor);
	V_INTERFACE(pStream);
    V_PTR_WRITE(pDesc, DMUS_OBJECTDESC);
    if (pDesc->dwSize)
    {
	    V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);
    }
    else
    {
        pDesc->dwSize = sizeof(DMUS_OBJECTDESC);
    }
#ifdef DXAPI
    if (m_fZombie)
	{
		Trace(2, "Warning: Call of IDirectMusicSegment::ParseDescriptor after the segment has been garbage collected.\n");
		return DMUS_S_GARBAGE_COLLECTED;
	}
#endif
	HRESULT hret = E_FAIL;
	// Save stream's current position
	LARGE_INTEGER li;
    ULARGE_INTEGER ul;

    li.HighPart = 0;
    li.LowPart = 0;

    HRESULT hr = pStream->Seek(li, STREAM_SEEK_CUR, &ul);
    
	if(FAILED(hr))
	{
		return hr;	
    }
	pDesc->dwValidData = 0;
	DWORD dwSavedPos = ul.LowPart;
    
	// Read first 4 bytes to determine what type of stream we
	// have been passed

	FOURCC type;
	DWORD dwRead;
	hr = pStream->Read(&type, sizeof(FOURCC), &dwRead);
	
	if(SUCCEEDED(hr) && dwRead == sizeof(FOURCC))
	{
		// Check for a RIFF file
		if(type == mmioFOURCC( 'R', 'I', 'F', 'F' ))
		{
			// Check to see if what type of RIFF file we have
			li.HighPart = 0;
			li.LowPart = dwSavedPos + 8; // Length needed to seek to form type of RIFF chunk

			hr = pStream->Seek(li, STREAM_SEEK_SET, NULL);
			if(SUCCEEDED(hr))
			{
				hr = pStream->Read(&type, sizeof(FOURCC), &dwRead);
			}

			if(SUCCEEDED(hr) && dwRead == sizeof(FOURCC))
			{
				if(type == DMUS_FOURCC_SEGMENT_FORM)	// We have a DirectMusic segment
				{
					// Since we now know what type of stream we need to 
					// seek back to saved position
					li.HighPart = 0;
					li.LowPart = dwSavedPos;
					hr = pStream->Seek(li, STREAM_SEEK_SET, NULL);
					if( SUCCEEDED(hr) ) // should always succeed.
					{
                        hret = m_Info.ParseDescriptor(pStream,pDesc,DMUS_FOURCC_SEGMENT_FORM,CLSID_DirectMusicSegment);
					}
				}
#ifdef DXAPI
                else if(type == FOURCC_SECTION_FORM)	// We have section
				{			
					long lTemp;
					hr = pStream->Read(&lTemp, sizeof(long), &dwRead);
					if( lTemp == mmioFOURCC('s','e','c','n') )
					{
						hr = pStream->Read(&lTemp, sizeof(long), &dwRead); // length
						hr = pStream->Read(&lTemp, sizeof(long), &dwRead); // time
						if( SUCCEEDED(hr) && (dwRead == sizeof(long) ))
						{
							hr = pStream->Read(&pDesc->wszName, sizeof(wchar_t)*16, &dwRead);
							if(SUCCEEDED(hr) && (dwRead == sizeof(wchar_t)*16))
							{
								pDesc->dwValidData |= DMUS_OBJ_NAME;
							}
						}
						hret = S_OK;
					}
				}
#endif
				else if (type == mmioFOURCC('W','A','V','E')) // we have a wave file
				{
                    // Create a wave object and have it parse the file.
                    IDirectMusicObject *pObject;
                    hret = DirectMusicCreateInstance(CLSID_DirectSoundWave,NULL,
                        IID_IDirectMusicObject,(void **) &pObject);
                    if(SUCCEEDED(hret))
                    {
					    // seek back to saved position
					    li.HighPart = 0;
					    li.LowPart = dwSavedPos;
					    hret = pStream->Seek(li, STREAM_SEEK_SET, NULL);
                        if (SUCCEEDED(hret))
                        {
                            hret = pObject->ParseDescriptor(pStream,pDesc);
                        }
                        pObject->Release();
                    }
				}
#ifdef DXAPI
				// Check to see if we have a MIDI file
				else
				{
					li.HighPart = 0;
					li.LowPart = dwSavedPos + 20; // Length needed to seek to start of normal MIDI file
									 // contained within the Riff chunk

					FOURCC type;	
					DWORD dwRead;

					hr = pStream->Seek(li, STREAM_SEEK_SET, NULL);
					
					if(SUCCEEDED(hr))
					{
						hr = pStream->Read(&type, sizeof(FOURCC), &dwRead);
					}

					if(SUCCEEDED(hr) && dwRead == sizeof(FOURCC))
					{
						if(type == mmioFOURCC( 'M', 'T', 'h', 'd' ))
						{
							hret = S_OK;
						}
					}
				}
#endif
			}
		}
#ifdef DXAPI
		// Check for a template file
		else if(type == mmioFOURCC('L', 'P', 'T', 's'))
		{
			hret = S_OK;
		}
		// Check for normal MIDI file
		else if(type == mmioFOURCC('M', 'T', 'h', 'd'))
	    {
			hret = S_OK;
		}
#endif
    }
    if (SUCCEEDED(hret))
    {
        pDesc->dwValidData |= DMUS_OBJ_CLASS;
		pDesc->guidClass = CLSID_DirectMusicSegment;
    }
#ifdef DBG
    if (hret == E_FAIL)
    {
        Trace(1,"Error: Segment unable to parse file - unknown format.\n");
    }
#endif
	return hret;
}

void CSegmentList::Clear()
{
    CSegment *pSeg;
    while (pSeg = RemoveHead())
    {
        pSeg->SetNext(NULL);
        pSeg->m_pSong = NULL;
        pSeg->Release();
    }
}

inline REFERENCE_TIME ConvertToReference(MUSIC_TIME mtSpan, double dblTempo)
{
    REFERENCE_TIME rtTemp = mtSpan;
    rtTemp *= 600000000;
    rtTemp += (DMUS_PPQ / 2);
    rtTemp /= DMUS_PPQ;
    rtTemp = (REFERENCE_TIME)(rtTemp / dblTempo);
    return rtTemp;
}

inline MUSIC_TIME ConvertToMusic(REFERENCE_TIME rtSpan, double dblTempo)
{
    rtSpan *= DMUS_PPQ;
    rtSpan = (REFERENCE_TIME)(rtSpan * dblTempo);
    rtSpan += 300000000;
    rtSpan /= 600000000;
    if ( rtSpan & 0xFFFFFFFF00000000 )
    {
        Trace(3,"Warning: Reference to Music time conversion with very large ref time resulted in max music time.\n");
        rtSpan = 0x7FFFFFFF;
    }
    return (MUSIC_TIME) (rtSpan & 0xFFFFFFFF);
}

HRESULT CSegment::MusicToReferenceTime(MUSIC_TIME mtTime, REFERENCE_TIME *prtTime)
{
    double dbl = 120;
    MUSIC_TIME mtTempo = 0;
    REFERENCE_TIME rtTempo = 0;
    MUSIC_TIME mtNext = 0;
    PrivateTempo Tempo;
    HRESULT hr;

    do
    {
        hr = GetParam(GUID_PrivateTempoParam, -1, 0, mtTempo, &mtNext,(void *)&Tempo );
        if (hr == S_OK)
        {
            dbl = Tempo.dblTempo;
            if (Tempo.fLast || mtTempo + mtNext >= mtTime) break;
            rtTempo += ConvertToReference(mtNext, dbl);
            mtTempo += mtNext;
        }

    } while (hr == S_OK);

    *prtTime = rtTempo + ConvertToReference(mtTime - mtTempo, dbl);
    return S_OK;
}

HRESULT CSegment::ReferenceToMusicTime(REFERENCE_TIME rtTime, MUSIC_TIME *pmtTime)
{
    double dbl = 120;
    MUSIC_TIME mtTempo = 0;
    REFERENCE_TIME rtTempo = 0;
    MUSIC_TIME mtNext = 0;
    PrivateTempo Tempo;
    HRESULT hr;

    do
    {
        hr = GetParam(GUID_PrivateTempoParam, -1, 0, mtTempo, &mtNext,(void *)&Tempo );
        if (hr == S_OK)
        {
            REFERENCE_TIME rtNext = rtTempo + ConvertToReference(mtNext, dbl);
            dbl = Tempo.dblTempo;
            if (Tempo.fLast || rtNext >= rtTime) break;
            rtTempo = rtNext;
            mtTempo += mtNext;
        }

    } while (hr == S_OK);

    *pmtTime = mtTempo + ConvertToMusic(rtTime - rtTempo, dbl);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\dmperf.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// dmperf.h
// @doc EXTERNAL

#ifndef _DMPERF_H_ 
#define _DMPERF_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "dmusicc.h"
#include "dmusicip.h"
#include "dmusicf.h"
#include "dmime.h"
#include "ntfylist.h"
#include "dmsstobj.h"
#include "audpath.h"
#include "..\shared\dmusicp.h"

#define MIDI_NOTEOFF        0x80
#define MIDI_NOTEON         0x90
#define MIDI_PTOUCH         0xA0
#define MIDI_CCHANGE        0xB0
#define MIDI_PCHANGE        0xC0
#define MIDI_MTOUCH         0xD0
#define MIDI_PBEND          0xE0 
#define MIDI_SYSX           0xF0
#define MIDI_MTC            0xF1
#define MIDI_SONGPP         0xF2
#define MIDI_SONGS          0xF3
#define MIDI_EOX            0xF7
#define MIDI_CLOCK          0xF8
#define MIDI_START          0xFA
#define MIDI_CONTINUE       0xFB
#define MIDI_STOP           0xFC
#define MIDI_SENSE          0xFE
#define MIDI_CC_BS_MSB      0x00
#define MIDI_CC_BS_LSB      0x20
#define MIDI_CC_DATAENTRYMSB 0x06
#define MIDI_CC_DATAENTRYLSB 0x26
#define MIDI_CC_NRPN_LSB    0x62
#define MIDI_CC_NRPN_MSB    0x63
#define MIDI_CC_RPN_LSB     0x64
#define MIDI_CC_RPN_MSB     0x65
#define MIDI_CC_MOD_WHEEL   0x01
#define MIDI_CC_VOLUME      0x07
#define MIDI_CC_PAN         0x0A
#define MIDI_CC_EXPRESSION  0x0B
#define MIDI_CC_FILTER      0x4A
#define MIDI_CC_REVERB      0x5B
#define MIDI_CC_CHORUS      0x5D
#define MIDI_CC_RESETALL    0x79
#define MIDI_CC_ALLSOUNDSOFF 0x78

#define MIDI_RPN_PITCHBEND  0x00

#define CLEARTOOLGRAPH(x)   { \
    if( (x)->pTool ) \
    { \
        (x)->pTool->Release(); \
        (x)->pTool = NULL; \
    } \
    if( (x)->pGraph ) \
    { \
        (x)->pGraph->Release(); \
        (x)->pGraph = NULL; }}

#define DMUS_PCHANNEL_KILL_ME   0xFFFFFFF0

typedef struct _DMUS_SEGSTATEDATA
{
    _DMUS_SEGSTATEDATA *    pNext;        // Linked list of these.
    DWORD                   dwQueue;      // Which queue it is in.
    WCHAR                   wszName[DMUS_MAX_NAME]; // Name of object. 
    MUSIC_TIME              mtLoopStart;  // Loop start point.
    MUSIC_TIME              mtLoopEnd;    // Loop end point.
    DWORD                   dwRepeats;    // The original repeat setting (before countdown)
    MUSIC_TIME              mtLength;     // Length of segment.
    REFERENCE_TIME          rtGivenStart; // Start time given in PlaySegment, unquantized
    MUSIC_TIME              mtResolvedStart;// Start time resolved to desired resolution
    MUSIC_TIME              mtOffset;     // Start time of the segment in absolute time, as if it were started from the beginning. 
    MUSIC_TIME              mtLastPlayed; // The last played absolute time
    MUSIC_TIME              mtPlayTo;     // Used to stop play at a specific time. Ignored when 0.
    MUSIC_TIME              mtSeek;       // How far into the segment we are.
    MUSIC_TIME              mtStartPoint; // Point in the segment where playback started
    DWORD                   dwRepeatsLeft;// Current repeats left.
    DWORD                   dwPlayFlags;// Segment playback control flags
    BOOL                    fStartedPlay; // Indicates if the segstate has started to play yet
    IDirectMusicSegmentState *pSegState;  // Pointer to segstate.
} DMUS_SEGSTATEDATA;

/*////////////////////////////////////////////////////////////////////
// IDirectMusicParamHook */
#undef  INTERFACE
#define INTERFACE  IDirectMusicParamHook
DECLARE_INTERFACE_(IDirectMusicParamHook, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicParamHook */
    STDMETHOD(GetParam)             (THIS_ REFGUID rguidType, 
                                           DWORD dwGroupBits, 
                                           DWORD dwIndex, 
                                           MUSIC_TIME mtTime, 
                                           MUSIC_TIME* pmtNext, 
                                           void* pData,
                                           IDirectMusicSegmentState *pSegState,
                                           DWORD dwTrackFlags,
                                           HRESULT hr) PURE;
};

#undef  INTERFACE
#define INTERFACE  IDirectMusicSetParamHook
DECLARE_INTERFACE_(IDirectMusicSetParamHook, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicSetParamHook */
    STDMETHOD(SetParamHook)         (THIS_ IDirectMusicParamHook *pIHook) PURE; 
};


#undef  INTERFACE
#define INTERFACE  IDirectMusicPerformanceStats
DECLARE_INTERFACE_(IDirectMusicPerformanceStats, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicPerformanceStats */
    STDMETHOD(TraceAllSegments)     (THIS) PURE;
    STDMETHOD(CreateSegstateList)   (THIS_ DMUS_SEGSTATEDATA ** ppList) PURE;     
    STDMETHOD(FreeSegstateList)     (THIS_ DMUS_SEGSTATEDATA * pList) PURE; 
};



#define DEFAULT_BUFFER_SIZE 1024
// the following constants represent time in milliseconds
#define TRANSPORT_RES 100
#define REALTIME_RES 10

// the following constants represent time in 100 nanosecond increments

#define REF_PER_MIL     10000       // For converting from reference time to mils 
#define MARGIN_MIN      (100 * REF_PER_MIL) // 
#define MARGIN_MAX      (400 * REF_PER_MIL) // 
#define PREPARE_TIME    (m_dwPrepareTime * REF_PER_MIL) // Time
#define NEARTIME        (100 * REF_PER_MIL)
#define NEARMARGIN      (REALTIME_RES * REF_PER_MIL)
/*
// here's a convenience inline function that helps using resolution bits
inline DWORD SIMPLIFY_RESOLUTION(DWORD x)
{   
    if( x & DMUS_SEGF_DEFAULT )     
    {                               
        return DMUS_SEGF_DEFAULT;
    }                               
    else if( x & DMUS_SEGF_SEGMENTEND )
    {
        return DMUS_SEGF_SEGMENTEND;
    }
    else if( x & DMUS_SEGF_MARKER )
    {
        return DMUS_SEGF_MARKER;
    }
    else if( x & DMUS_SEGF_MEASURE )        
    {                               
        return DMUS_SEGF_MEASURE;       
    }                               
    else if( x & DMUS_SEGF_BEAT )   
    {                               
        return DMUS_SEGF_BEAT;          
    }                               
    else if( x & DMUS_SEGF_GRID )   
    {                               
        return DMUS_SEGF_GRID;          
    }   
    else return 0;                      
}
*/

struct PRIV_PMSG;

// pNext contains the next pointer for the next PMsg
// dwPrivFlags contains private flags used by the performance
// rtLast contains the previous time when an event is requeued,
//      which is used by the flush routine
#define PRIV_PART                       \
    struct PRIV_PMSG*   pNext;          \
    DWORD               dwPrivFlags;    \
    DWORD               dwPrivPubSize;  \
    REFERENCE_TIME      rtLast; 

typedef struct PRIV_PART_STRUCT
{
    /* begin PRIV_PART */
    PRIV_PART
    /* end PRIV_PART */
} PRIV_PART_STRUCT;

#define PRIV_PART_SIZE  sizeof(PRIV_PART_STRUCT)
#define PRIV_TO_DMUS(x) ((DMUS_PMSG*)(LPBYTE(x) + PRIV_PART_SIZE))
#define DMUS_TO_PRIV(x) ((PRIV_PMSG*)(LPBYTE(x) - PRIV_PART_SIZE))

typedef struct PRIV_PMSG
{
    /* begin PRIV_PART */
    PRIV_PART
    /* end PRIV_PART */
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */
} PRIV_PMSG;

typedef struct PRIV_TEMPO_PMSG
{
    /* begin PRIV_PART */
    PRIV_PART
    /* end PRIV_PART */
    DMUS_TEMPO_PMSG tempoPMsg;
} PRIV_TEMPO_PMSG;

#define PRIV_FLAG_ALLOC_MASK    0x0000FFFF0 // using 4 bits for this for now
#define PRIV_FLAG_ALLOC         0x0000CAFE0 // arbitrary pattern for allocated
#define PRIV_FLAG_FREE			0x0000DEAD0 // pattern for in free list
#define PRIV_FLAG_QUEUED        0x000000001 // set if in a queue
#define PRIV_FLAG_REMOVE        0x000000002 // set if this needs to be removed from a queue
#define PRIV_FLAG_TRACK 		0x000000004 // indicates this message was generated by a track 
#define PRIV_FLAG_FLUSH 		0x000000008 // this is a curve that needs to be flushed after
                                            // its end value has played 
#define PRIV_FLAG_REQUEUE       0x000100000 // set if this needs to be requeued to a queue


class CPMsgQueue
{
public:
    CPMsgQueue();
    ~CPMsgQueue();
    void            Enqueue(PRIV_PMSG *pItem);
    PRIV_PMSG *     Dequeue();
    PRIV_PMSG *     Dequeue(PRIV_PMSG *pItem);
    PRIV_PMSG *     GetHead() { return (m_pTop);}
    PRIV_PMSG *     FlushOldest(REFERENCE_TIME rtTime);
    long            GetCount();
    void            Sort();
private:
    PRIV_PMSG *     m_pTop;             // Top of list.
    PRIV_PMSG *     m_pLastAccessed;    // Last item access in list.
#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
public:
    LONG            m_lCount;
#endif
};

// structure used to hold Ports and Buffers
typedef struct PortTable
{
    REFERENCE_TIME      rtLast; // last message time packed
    IDirectMusicPort*  pPort;
    IDirectMusicBuffer* pBuffer;
    IReferenceClock*    pLatencyClock;
    BOOL                fBufferFilled;   // TRUE if there are messages in the buffer that should be sent to the port
    CLSID               guidPortID;      // The class id of the port, for matching with audio path requests.
    DMUS_PORTPARAMS8    PortParams;      // PortParams returned when this port was created.  
    DWORD               dwGMFlags;       // DM_PORTFLAGS_XG, DM_PORTFLAGS_GM, and DM_PORTFLAGS_GS.
    DWORD               dwChannelGroups; // Number of channel groups active on the port.
} PortTable;

// structure to hold a channel of an accumulated parameter.
// The CChannelMap keeps a linked list of these, one list each
// for each parameter type.

class CMergeParam : public AListItem
{
public:
    CMergeParam* GetNext() { return (CMergeParam*)AListItem::GetNext();}
    long                m_lData;    // Current parameter data.
    DWORD               m_dwIndex;  // Which layer.
};

class CParamMerger : public AList
{
public:
    CParamMerger();
    void Clear(long lInitValue);
    BYTE MergeMidiVolume(DWORD dwIndex, BYTE bMIDIVolume);
    BYTE GetVolumeStart(DWORD dwIndex);
    short MergeTranspose(DWORD dwIndex, short nTranspose);
    long MergeValue(DWORD dwIndex, long lData, long lCenter, long lRange);
    long GetIndexedValue(DWORD dwIndex);
    static BYTE VolumeToMidi(long lVolume);
private:
    long MergeData(DWORD dwIndex, long lData);
    void AddHead(CMergeParam* pMergeParam) { AList::AddHead((AListItem*)pMergeParam);}
    CMergeParam* GetHead(){return (CMergeParam*)AList::GetHead();}
    CMergeParam* RemoveHead() {return (CMergeParam *) AList::RemoveHead();}
    void Remove(CMergeParam* pMergeParam){AList::Remove((AListItem*)pMergeParam);}
    void AddTail(CMergeParam* pMergeParam){AList::AddTail((AListItem*)pMergeParam);}
    static short m_lMIDIToDB[128];   // Array for converting MIDI to centibel volume.
    static BYTE m_lDBToMIDI[97];    // For converting volume to MIDI.
    long                m_lMergeTotal;   // Total for all parameters in the list, but not including m_lData.
    long                m_lZeroIndexData;    // Default (no index) data.
};

class CPitchMerger : public CParamMerger
{
public:
    CPitchMerger();
    long                m_lBendRange;
};

// structure to hold a single ChannelMap
class CChannelMap
{
public:
    void                Clear();            // Completely clears and resets structure. 
    void                Reset(BOOL fVolumeAndPanToo); // Clears just the midi controllers.
    CParamMerger        m_VolumeMerger;     // Set of volumes to merge.
    CParamMerger        m_ExpressionMerger; // Set of expression controllers to merge.
    CParamMerger        m_TransposeMerger;  // Set of transpositions to merge.
    CPitchMerger        m_PitchbendMerger;  // Set of pitchbends to merge.
    CParamMerger        m_PanMerger;        // Set of pans to merge.
    CParamMerger        m_FilterMerger;     // Set of filters to merge.
    CParamMerger        m_ModWheelMerger;   // Set of mod wheel controls to merge.
    CParamMerger        m_ReverbMerger;     // Set of reverb levels to merge.
    CParamMerger        m_ChorusMerger;     // Set of chorus levels to merge.
    DWORD               dwPortIndex;        // index into the PortTable
    DWORD               dwGroup;            // group number of the port
    DWORD               dwMChannel;         // channel number in the group
    short               nTranspose;         // amount to transpose
    WORD                wFlags;             // CMAP_X flags
} ;

#define CMAP_FREE       (WORD) 1        // This channel is currently not in use.
#define CMAP_STATIC     (WORD) 2        // This channel is in use as a regular, static pchannel.
#define CMAP_VIRTUAL    (WORD) 4        // This channel is in use for a dynamic, virtual pchannel.

// structure used to hold a PChannelMap block of 16.
#define PCHANNEL_BLOCKSIZE  16

class CChannelBlock : public AListItem
{
public:
    CChannelBlock* GetNext() { return (CChannelBlock*)AListItem::GetNext();}
    void Init(DWORD dwPChannelStart, DWORD dwPortIndex, DWORD dwGroup, WORD wFlags);
    DWORD               m_dwPChannelStart;  // first PChannel index
    CChannelMap         m_aChannelMap[PCHANNEL_BLOCKSIZE];
    DWORD               m_dwFreeChannels;   // Number of channels currently free.
    DWORD               m_dwPortIndex;      // Port id, if this is completely assigned to one port.
};

class CChannelBlockList : public AList
{
public:
    void Clear();
    void AddHead(CChannelBlock* pChannelBlock) { AList::AddHead((AListItem*)pChannelBlock);}
    CChannelBlock* GetHead(){return (CChannelBlock*)AList::GetHead();}
    CChannelBlock* RemoveHead() {return (CChannelBlock *) AList::RemoveHead();}
    void Remove(CChannelBlock* pChannelBlock){AList::Remove((AListItem*)pChannelBlock);}
    void AddTail(CChannelBlock* pChannelBlock){AList::AddTail((AListItem*)pChannelBlock);}
};

// structure to hold a global GUID and its data
typedef struct GlobalData
{
    ~GlobalData()
    {
        if( pData )
        {
            delete [] pData;
        }
    }
    struct GlobalData*  pNext;
    GUID    guidType;
    void*   pData;
    DWORD   dwSize;
} GlobalData;

// structure to hold internal tempo message with relative tempo
typedef struct DMInternalTempo
{
    /* begin PRIV_PART */
    PRIV_PART
    /* end PRIV_PART */
    DMUS_TEMPO_PMSG tempoPMsg;
    float   fltRelTempo; // the current relative tempo, from .5 to 2
} DMInternalTempo;

/*  Integer constants for defining each segstate queue */

#define SQ_PRI_WAIT     0   
#define SQ_CON_WAIT     1
#define SQ_SEC_WAIT     2
#define SQ_PRI_PLAY     3   
#define SQ_CON_PLAY     4
#define SQ_SEC_PLAY     5
#define SQ_PRI_DONE     6
#define SQ_CON_DONE     7
#define SQ_SEC_DONE     8
#define SQ_COUNT        9

#define IsPriQueue( dwCount ) ((dwCount % 3) == 0)
#define IsConQueue( dwCount ) ((dwCount % 3) == 1)
#define IsSecQueue( dwCount ) ((dwCount % 3) == 2)
#define IsWaitQueue( dwCount ) (dwCount <= SQ_SEC_WAIT)
#define IsPlayQueue( dwCount ) ((dwCount >= SQ_PRI_PLAY) && (dwCount <= SQ_SEC_PLAY))
#define IsDoneQueue( dwCount ) (dwCount >= SQ_PRI_DONE)
 


DEFINE_GUID(IID_CPerformance, 0xade66ea2, 0xe1c5, 0x4552, 0x85, 0x27, 0x1e, 0xef, 0xa5, 0xa, 0xfd, 0x7b);

class CSong;

#ifdef XBOX
#define USE_PMSG_ZONE
#endif

#ifdef USE_PMSG_ZONE
class CPMsgZone;
#endif

#define FLUSH_LEAVE_ON      1   
#define FLUSH_ON_REPEAT     2   // Indicates this invalidation occured because of segment loop.


// class CPerformance
class CPerformance : public CMemTrack,
    public IDirectMusicPerformance8,
    public IDirectMusicTool,
    public IDirectMusicGraph,
#ifndef XBOX
    public IDirectMusicPerformanceStats,
    public IDirectMusicSetParamHook,
#endif
    public IDirectMusicPerformanceP
{
    friend class CAudioPath;
    friend class CSegState;
    friend class CBufferManager;

public:
    CPerformance();
    ~CPerformance();

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDirectMusicPerformance
    STDMETHODIMP Init(IDirectMusic** ppDirectMusic,LPDIRECTSOUND pDSound,HWND hWnd );
    STDMETHODIMP PlaySegment(IDirectMusicSegment *pSegment,DWORD dwFlags,
        __int64 i64StartTime,IDirectMusicSegmentState **ppSegmentState);
    STDMETHODIMP Stop(IDirectMusicSegment *pSegment,
        IDirectMusicSegmentState *pSegmentState,MUSIC_TIME mtTime,DWORD dwFlags);
    STDMETHODIMP GetSegmentState(IDirectMusicSegmentState **ppSegmentState,MUSIC_TIME mtTime);
    STDMETHODIMP SetPrepareTime(DWORD dwMilliSeconds);
    STDMETHODIMP GetPrepareTime(DWORD* pdwMilliSeconds);
    STDMETHODIMP SetBumperLength(DWORD dwMilliSeconds);
    STDMETHODIMP GetBumperLength(DWORD* pdwMilliSeconds);
    STDMETHODIMP SendPMsg(DMUS_PMSG *pPMsg);
    STDMETHODIMP MusicToReferenceTime(MUSIC_TIME mtTime,REFERENCE_TIME *prtTime);
    STDMETHODIMP ReferenceToMusicTime(REFERENCE_TIME rtTime,MUSIC_TIME *pmtTime);
    STDMETHODIMP IsPlaying(IDirectMusicSegment *pSegment,IDirectMusicSegmentState *pSegState);
    STDMETHODIMP GetTime(REFERENCE_TIME *prtNow,MUSIC_TIME  *pmtNow);
    STDMETHODIMP AllocPMsg(ULONG cb,DMUS_PMSG** ppPMsg);
    STDMETHODIMP FreePMsg(DMUS_PMSG* pPMsg);
    STDMETHODIMP SetNotificationHandle(HANDLE hNotificationEvent,REFERENCE_TIME rtMinimum);
    STDMETHODIMP GetNotificationPMsg(DMUS_NOTIFICATION_PMSG** ppNotificationPMsg);
    STDMETHODIMP AddNotificationType(REFGUID rguidNotification);
    STDMETHODIMP RemoveNotificationType(REFGUID rguidNotification);
    STDMETHODIMP GetGraph(IDirectMusicGraph** ppGraph);
    STDMETHODIMP SetGraph(IDirectMusicGraph* pGraph);
    STDMETHODIMP AddPort(IDirectMusicPort* pPort);
    STDMETHODIMP RemovePort(IDirectMusicPort* pPort);
    STDMETHODIMP AssignPChannelBlock(DWORD dwBlockNum,IDirectMusicPort* pPort,DWORD dwGroup);
    STDMETHODIMP AssignPChannel(DWORD dwPChannel,IDirectMusicPort* pPort,DWORD dwGroup,DWORD dwMChannel);
    STDMETHODIMP PChannelInfo(DWORD dwPChannel,IDirectMusicPort** ppPort,DWORD* pdwGroup,DWORD* pdwMChannel);
    STDMETHODIMP DownloadInstrument(IDirectMusicInstrument* pInst,DWORD dwPChannel, 
                IDirectMusicDownloadedInstrument**,DMUS_NOTERANGE* pNoteRanges,
                DWORD dwNumNoteRanges,IDirectMusicPort**,DWORD*,DWORD*);
    STDMETHODIMP Invalidate(MUSIC_TIME mtTime,DWORD dwFlags);
    STDMETHODIMP GetParam(REFGUID rguidDataType,DWORD dwGroupBits,DWORD dwIndex, 
                MUSIC_TIME mtTime,MUSIC_TIME* pmtNext,void* pData); 
    STDMETHODIMP SetParam(REFGUID rguidDataType,DWORD dwGroupBits,DWORD dwIndex, 
                MUSIC_TIME mtTime,void* pData);
    STDMETHODIMP GetGlobalParam(REFGUID rguidType,void* pData,DWORD dwSize);
    STDMETHODIMP SetGlobalParam(REFGUID rguidType,void* pData,DWORD dwSize);
    STDMETHODIMP GetLatencyTime(REFERENCE_TIME* prtTime);
    STDMETHODIMP GetQueueTime(REFERENCE_TIME* prtTime);
    STDMETHODIMP AdjustTime(REFERENCE_TIME rtAmount);
    STDMETHODIMP CloseDown(void);
    STDMETHODIMP GetResolvedTime(REFERENCE_TIME rtTime,REFERENCE_TIME* prtResolved,DWORD dwFlags);
    STDMETHODIMP MIDIToMusic(BYTE bMIDIValue,DMUS_CHORD_KEY* pChord,
                BYTE bPlayMode,BYTE bChordLevel,WORD *pwMusicValue);
    STDMETHODIMP MusicToMIDI(WORD wMusicValue,DMUS_CHORD_KEY* pChord,
                BYTE bPlayMode,BYTE bChordLevel,BYTE *pbMIDIValue);
    STDMETHODIMP TimeToRhythm(MUSIC_TIME mtTime,DMUS_TIMESIGNATURE *pTimeSig,
                WORD *pwMeasure,BYTE *pbBeat,BYTE *pbGrid,short *pnOffset);
    STDMETHODIMP RhythmToTime(WORD wMeasure,BYTE bBeat,BYTE bGrid,
                short nOffset,DMUS_TIMESIGNATURE *pTimeSig,MUSIC_TIME *pmtTime);   
    //  IDirectMusicPerformance8 
    STDMETHODIMP InitAudio(IDirectMusic** ppDirectMusic,
                           IDirectSound** ppDirectSound,
                           HWND hWnd,
                           DWORD dwDefaultPathType,
                           DWORD dwPChannelCount,
                           DWORD dwFlags,                          
                           DMUS_AUDIOPARAMS *pParams);
    STDMETHODIMP PlaySegmentEx(IUnknown* pSource, 
#ifdef XBOX
                    const char *pszSegmentName,
#else
                    WCHAR *pwzSegmentName,
#endif
                    IUnknown* pTransition,
                    DWORD dwFlags, 
                    __int64 i64StartTime, 
                    IDirectMusicSegmentState** ppSegmentState,
                    IUnknown *pFrom,
                    IUnknown *pAudioPath); 
    STDMETHODIMP StopEx(IUnknown *pObjectToStop,__int64 i64StopTime,DWORD dwFlags) ;
    STDMETHODIMP ClonePMsg(DMUS_PMSG* pSourcePMSG,DMUS_PMSG** ppCopyPMSG) ;
    STDMETHODIMP CreateAudioPath( IUnknown *pSourceConfig, BOOL fActivate, 
                                           IDirectMusicAudioPath **ppNewPath);
    STDMETHODIMP CreateStandardAudioPath(DWORD dwType, DWORD dwPChannelCount, BOOL fActivate, 
                                           IDirectMusicAudioPath **ppNewPath);    
    STDMETHODIMP SetDefaultAudioPath(IDirectMusicAudioPath *pAudioPath) ;
    STDMETHODIMP GetDefaultAudioPath(IDirectMusicAudioPath **pAudioPath) ;
    STDMETHODIMP GetParamEx(REFGUID rguidType,
                    DWORD dwTrackID,
                    DWORD dwGroupBits,
                    DWORD dwIndex,
                    MUSIC_TIME mtTime,
                    MUSIC_TIME* pmtNext,
                    void* pParam); 
    STDMETHODIMP InitAudioX(DWORD dwDefaultPathType,
                           DWORD dwPChannelCount,
                           DWORD dwVoiceCount,
                           DWORD dwFlags);


// IDirectMusicTool
    STDMETHODIMP Init(IDirectMusicGraph* pGraph);
    STDMETHODIMP ProcessPMsg(IDirectMusicPerformance* pPerf,DMUS_PMSG* pPMsg);
    STDMETHODIMP Flush(IDirectMusicPerformance* pPerf,DMUS_PMSG* pPMsg,REFERENCE_TIME mtTime);
    STDMETHODIMP GetMsgDeliveryType(DWORD*);
    STDMETHODIMP GetMediaTypeArraySize(DWORD*);
    STDMETHODIMP GetMediaTypes(DWORD**,DWORD);

// IDirectMusicGraph
    STDMETHODIMP Shutdown();
    STDMETHODIMP InsertTool(IDirectMusicTool *pTool,DWORD *pdwPChannels,DWORD cPChannels,LONG lIndex);
    STDMETHODIMP GetTool(DWORD,IDirectMusicTool**);
    STDMETHODIMP RemoveTool(IDirectMusicTool*);
    STDMETHODIMP StampPMsg( DMUS_PMSG* pPMsg );
#ifndef XBOX
// IDirectMusicPerformanceStats 
    STDMETHODIMP TraceAllSegments() ;
    STDMETHODIMP CreateSegstateList(DMUS_SEGSTATEDATA ** ppList) ;     
    STDMETHODIMP FreeSegstateList(DMUS_SEGSTATEDATA * pList) ;  
#endif
// IDirectMusicPerformanceP
    STDMETHODIMP GetPortAndFlags(DWORD dwPChannel,IDirectMusicPort **ppPort,DWORD * pdwFlags);
// IDirectMusicSetParamHook 
    STDMETHODIMP SetParamHook(IDirectMusicParamHook *pIHook); 

// Access from segstate, audiopath and segment...
    HRESULT GetGraphInternal(IDirectMusicGraph** ppGraph);
    HRESULT FlushVirtualTrack(DWORD dwId,MUSIC_TIME mtTime, DWORD dwFlushFlags);
    HRESULT GetControlSegTime(MUSIC_TIME mtTime,MUSIC_TIME* pmtNextSeg);
    HRESULT GetPriSegTime(MUSIC_TIME mtTime,MUSIC_TIME* pmtNextSeg);
    void RemoveUnusedPorts();
    DWORD GetPortID(IDirectMusicPort * pPort);
    HRESULT AddPort(IDirectMusicPort* pPort,GUID *pguidPortID,
        DMUS_PORTPARAMS8 *pParams,DWORD *pdwPortID);
private:
    // private member functions
    void Init();
    friend void WINAPI _Transport(LPVOID,REFERENCE_TIME *);
    friend void WINAPI _Realtime(LPVOID,REFERENCE_TIME *);   
    HRESULT CreateThreads();
    HRESULT AllocPMsg(ULONG cb,PRIV_PMSG** ppPMsg);
    HRESULT FreePMsg(PRIV_PMSG* pPMsg);
#ifdef DXAPI
    bool SendShortMsg(IDirectMusicBuffer* pBuffer,
                               IDirectMusicPort* pPort,DWORD dwMsg,
                               REFERENCE_TIME rt, DWORD dwGroup);
#else
    bool SendShortMsg(IDirectMusicBuffer* pBuffer,
                               IDirectMusicPort* pPort, DWORD dwMsg,
                               REFERENCE_TIME rt, DWORD dwGroup)
    {
        if (m_pSynth)
        {
            m_pSynth->SendShortMsg(rt,dwGroup,dwMsg);
        }
        return true;
    }
    void SendLongMsg(BYTE *pbMsg, DWORD dwLength, REFERENCE_TIME rt, DWORD dwGroup);
#endif
    HRESULT PackNote(DMUS_PMSG* pPMsg,REFERENCE_TIME rt );
    HRESULT PackCurve(DMUS_PMSG* pPMsg,REFERENCE_TIME rt );
    HRESULT PackMidi(DMUS_PMSG* pPMsg,REFERENCE_TIME rt );
    HRESULT PackSysEx(DMUS_PMSG* pPMsg,REFERENCE_TIME rt );
    HRESULT PackPatch(DMUS_PMSG* pPMsg,REFERENCE_TIME rt );
    HRESULT PackWave(DMUS_PMSG* pPMsg,REFERENCE_TIME rt );
    void Realtime(REFERENCE_TIME *prtWakeUp);
    void Transport(REFERENCE_TIME *prtWakeUp);
#ifdef DXAPI
    void SendBuffers();
    void RealtimeThread();
    void TransportThread();
    HRESULT GetPathPort(CPortConfig *pConfig);
#endif
    void ProcessEarlyPMsgs();
    PRIV_PMSG *GetNextPMsg();
    REFERENCE_TIME GetTime();
    REFERENCE_TIME GetLatency();
    REFERENCE_TIME GetBestSegLatency( CSegState* pSeg );
    void PrepSegToPlay(CSegState *pSegState, bool fQueue = false);
    void ManageControllingTracks();
    void PerformSegStNode(DWORD dwList,CSegState* pSegStNode);
    void AddEventToTempoMap( PRIV_PMSG* pPMsg );
    void FlushMainEventQueues( DWORD, MUSIC_TIME mtFlush,  MUSIC_TIME mtFlushUnresolved, DWORD dwFlushFlags); // flush all events in all queues.
    void FlushEventQueue( DWORD dwId,CPMsgQueue *pQueue, REFERENCE_TIME rtFlush, REFERENCE_TIME rtFlushUnresolved, DWORD dwFlushFlags );
    void ClearMusicStoppedNotification();
    HRESULT PlayOneSegment(
        CSegment* pSegment, 
        DWORD dwFlags, 
        __int64 i64StartTime, 
        CSegState **ppSegState,
        CAudioPath *pAudioPath);
    HRESULT PlaySegmentInternal( CSegment* pSegment, 
        CSong * pSong,
        WCHAR *pwzSegmentName,
        CSegment* pTransition,
        DWORD dwFlags, 
        __int64 i64StartTime, 
        IDirectMusicSegmentState** ppSegmentState,
        IUnknown *pFrom,
        CAudioPath *pAudioPath);
    CSegState *GetSegmentForTransition(DWORD dwFlags,MUSIC_TIME mtTime, IUnknown *pFrom);
    void QueuePrimarySegment( CSegState* pSeg );
    void QueueSecondarySegment( CSegState* pSeg );
    void CalculateSegmentStartTime( CSegState* pSeg );
    MUSIC_TIME ResolveTime( MUSIC_TIME mtTime, DWORD dwResolution, MUSIC_TIME *pmtIntervalSize );
    void GetTimeSig( MUSIC_TIME mtTime, DMUS_TIMESIG_PMSG* pTimeSig );
    void SyncTimeSig( CSegState *pSegState );
    void DequeueAllSegments();
    void AddToTempoMap( double dblTempo, MUSIC_TIME mtTime, REFERENCE_TIME rtTime );
    void UpdateTempoMap(MUSIC_TIME mtStart, bool fFirst, CSegState *pSegState, bool fAllDeltas = true);
    void IncrementTempoMap();
    void RecalcTempoMap(CSegState *pSegState, MUSIC_TIME mtOffset, bool fAllDeltas = true);
    void RevalidateRefTimes( CPMsgQueue * pList, MUSIC_TIME mtTime );
    void AddNotificationTypeToAllSegments( REFGUID rguidNotification );
    void RemoveNotificationTypeFromAllSegments( REFGUID rguidNotification );
    CNotificationItem* FindNotification( REFGUID rguidNotification );
    HRESULT GetPort(DWORD dwPortID, IDirectMusicPort **ppPort);
    HRESULT AllocVChannelBlock(DWORD dwPortID,DWORD dwGroup);
    HRESULT AllocVChannel(DWORD dwPortID, DWORD dwDrumFlags, DWORD *pdwPChannel, DWORD *pdwGroup,DWORD *pdwMChannel);
    HRESULT ReleasePChannel(DWORD dwPChannel);
    CChannelMap * GetPChannelMap( DWORD dwPChannel );
    HRESULT AssignPChannelBlock(DWORD dwBlockNum,DWORD dwPortIndex,DWORD dwGroup,WORD wFlags);
    HRESULT AssignPChannel(DWORD dwPChannel,DWORD dwPortIndex,DWORD dwGroup,DWORD dwMChannel,WORD wFlags);
    HRESULT PChannelIndex( DWORD dwPChannel, DWORD* pdwIndex,
                DWORD* pdwGroup, DWORD* pdwMChannel, short* pnTranspose = NULL );
    void GenerateNotification( DWORD dwNotification, MUSIC_TIME mtTime, IDirectMusicSegmentState* pSegSt );
    CSegState* GetPrimarySegmentAtTime( MUSIC_TIME mtTime );
    void ResetAllControllers( REFERENCE_TIME rtTime);
    void ResetAllControllers(CChannelMap* pChannelMap, REFERENCE_TIME rtTime, bool fGMReset);
    void DoStop( CSegState* pSegState, MUSIC_TIME mtTime, BOOL fInvalidate );
    void DoStop( CSegment* pSeg, MUSIC_TIME mtTime, BOOL fInvalidate );
    HRESULT GetChordNotificationStatus(
		DMUS_NOTE_PMSG* pNote, 
		DWORD dwTrackGroup, 
		REFERENCE_TIME rtTime, 
		DMUS_PMSG** ppNew);
	void OnChordUpdateEventQueues( DMUS_NOTIFICATION_PMSG* pNotify);
	void OnChordUpdateEventQueue( DMUS_NOTIFICATION_PMSG* pNotify, CPMsgQueue *pQueue, REFERENCE_TIME rtFlush );
#ifdef DBG
    void TraceAllChannelMaps();
#endif

    // private member variables
#ifdef XBOX
    IDirectMusicSynthX *m_pSynth;
    IDirectSound*       m_pDirectSound;
    DWORD               m_dwNumChannelGroups; // Number of channel groups active on the port.
    REFERENCE_TIME      m_rtLastSendTime; // Last time something was sent to synth.
#else
    IDirectSound8*      m_pDirectSound;
    IDirectMusic8*      m_pDirectMusic;
    DWORD               m_dwNumPorts; // the number of ports
    PortTable*          m_pPortTable; // array of ports, number equals m_dwNumPorts
#endif
    IReferenceClock*    m_pClock;
    IDirectMusicGraph*  m_pGraph;
    CAudioPath *        m_pDefaultAudioPath; // Default audio path.
    CChannelBlockList   m_ChannelBlockList; // List of pchannel maps, in blocks of 16
    CChannelBlockList   m_FreeChannelBlockList; // List of pchannel maps that are no longer in use
    CSegStateList       m_SegStateQueues[SQ_COUNT]; // Lists of all active segment states.
    CSegStateList       m_ShutDownQueue;    // List of segments that are pending shutdown.

    CAudioPathList      m_AudioPathList; // List of all active audio paths in this performance.
    CBufferManager      m_BufferManager; // List of all buffers currently in use.
    DMUS_AUDIOPARAMS    m_AudioParams;  // Initial requirements, as set in InitAudio, by app. 

    HANDLE      m_hNotification; // notification handle set in SetNotificationHandle
    REFERENCE_TIME  m_rtNotificationDiscard; // minimum time to hold onto a notification message
    CNotificationList   m_NotificationList;
    GlobalData* m_pGlobalData; // list of global data structs

    DWORD       m_dwAudioPathMode;  // 0 for not yet set, 1 for old methods, 2 for using AudioPaths.
    BOOL        m_fInTransportThread; // This is used to signal that the transport thread
                                     // is active and the realtime thread should hold
                                     // off on processing the early queue.
	BOOL		m_fInTrackPlay;		// This is used to signal that a track is in the process of
									// generating events. These will have the PRIV_FLAG_TRACK flag set.
    CPMsgQueue m_EarlyQueue;        // List of PMsgs that play immediately.
    CPMsgQueue m_NearTimeQueue;     // List of PMsgs that play a little early.
    CPMsgQueue m_OnTimeQueue;       // List of PMsgs that play exactly when due.
    CPMsgQueue m_TempoMap;          // List of tempo changes.
    CPMsgQueue m_OldTempoMap;       // List of old tempo changes.
    CPMsgQueue m_NotificationQueue; // List of notification messages.
    CPMsgQueue m_TimeSigQueue;      // List of time signature changes.

    double      m_dblLastTempo;     // Last tempo added. We look for duplicates and ignore copies at the same time.
    MUSIC_TIME  m_mtLastTempoTime;  // Time that last tempo was added.

    // cache of allocated pmsg's
#define PERF_PMSG_CB_MIN 48
#define PERF_PMSG_CB_MAX 120
    PRIV_PMSG* m_apPMsgCache[ PERF_PMSG_CB_MAX - PERF_PMSG_CB_MIN ];

    REFERENCE_TIME  m_rtStart;          // time when this performance started
    REFERENCE_TIME  m_rtAdjust;         // adjustment time to compensate for e.g. smpte drift
    REFERENCE_TIME  m_rtHighestPackedNoteOn; // highest time of packed note on
    REFERENCE_TIME  m_rtEarliestStartTime; // Time of last Stop(0,0,0). New segment can not start before this.
    REFERENCE_TIME  m_rtQueuePosition;  // the highest time a message has been packed, or the latency + m_rtBumperLength, whichever is greater
    REFERENCE_TIME  m_rtNextWakeUp;     // Next time the pipeline thread needs to wake up to deliver a message.
    REFERENCE_TIME  m_rtBumperLength;   // Distance ahead of latency clock to send events down to synth.
    MUSIC_TIME      m_mtTransported;    // the highest time transported
    MUSIC_TIME      m_mtPlayTo;         // the time to play to on the next transport cycle
    MUSIC_TIME      m_mtTempoCursor;    // Tempo map has been generated up to this point.
    DWORD           m_dwPrepareTime;    // time ahead, in milliseconds, to transport
    DWORD           m_dwBumperLength;   // Millisecond version of m_rtBumperLength. 
    long            m_lMasterVolume;    // master volume.
    float           m_fltRelTempo;      // relative tempo, can be from 0 to 200
    long            m_cRef;
    WORD            m_wRollOverCount;   // tracks when timeGetTime rolls over
    DWORD            m_dwInitCS;
    CRITICAL_SECTION m_PMsgCacheCrSec;
    CRITICAL_SECTION m_SegmentCrSec;
    CRITICAL_SECTION m_PipelineCrSec;   // For all the CPMsgQueues
    CRITICAL_SECTION m_PChannelInfoCrSec;
    CRITICAL_SECTION m_GlobalDataCrSec;
    CRITICAL_SECTION m_RealtimeCrSec;
    CRITICAL_SECTION m_MainCrSec;
#ifdef DXAPI
    HANDLE          m_hTransport;       // to wake up the Transport thread when needed
    HANDLE          m_hRealtime;
    HANDLE          m_hTransportThread; // to kill the Transport thread if needed
    HANDLE          m_hRealtimeThread;
    DWORD           m_dwTransportThreadID;  // transport thread id
    DWORD           m_dwRealtimeThreadID;
    BOOL            m_fKillThread;      // signal to transport thread to die
    BOOL            m_fKillRealtimeThread;
    bool            m_fReleasedInTransport; // The performance had its final release in the transport thread
    bool            m_fReleasedInRealtime; // The performance had its final release in the realtime thread
#else
    CWorker *       m_pTransportWorker; // Pointer to transport handler. 
    CWorker *       m_pRealtimeWorker;  // Pointer to realtime handler. 
#endif
    BOOL            m_fPlaying;
    BOOL            m_fMusicStopped;
    BOOL            m_fTempoChanged;    // When a tempo change occurs, refresh transport so clock time tracks don't get clobbered.

    IUnknown *      m_pUnkDispatch;     // holds the controlling unknown of the scripting object that implements IDispatch

    IDirectMusicSegmentState * m_pGetParamSegmentState; // Set prior to playing a segment, so GetParam() can know which segment called it.
    DWORD           m_dwGetParamFlags;  // Set prior to playing a segment track, so GetParam() can know how to search for the parameter.
#ifdef DXAPI
    DWORD           m_dwVersion;        // Version number, indicating DX6, DX7, or DX8. Determined by which interface requested.
    IDirectMusicParamHook * m_pParamHook;
#endif  
#ifdef USE_PMSG_ZONE
    CPMsgZone*      m_pPMsgZone;
#endif
#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
    DWORD           m_dwNotesPerSecond;
    DWORD           m_dwWavesPerSecond;
    DWORD           m_dwCurvesPerSecond;
    DWORD           m_dwSysExPerSecond;
    DWORD           m_dwMIDIPerSecond;
    DWORD           m_dwPatchesPerSecond;
    DWORD           m_dwTempNotesPerSecond;
    DWORD           m_dwTempWavesPerSecond;
    DWORD           m_dwTempCurvesPerSecond;
    DWORD           m_dwTempSysExPerSecond;
    DWORD           m_dwTempMIDIPerSecond;
    DWORD           m_dwTempPatchesPerSecond;
    REFERENCE_TIME  m_rtLastWrite;
    void            UpdateDebugParams();
#endif
};

#endif // _DMPERF_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\dmgraph.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// DMGraph.cpp : Implementation of CGraph

#include "pchime.h"

CGraph::CGraph() : m_MemTrack(DMTRACK_GRAPH)
{
	m_cRef = 1;
	INITIALIZE_CRITICAL_SECTION(&m_CrSec);
    IncrementDLLCount();
}

CGraph::~CGraph()
{
	Shutdown();  // shouldn't be needed, but doesn't hurt
	DELETE_CRITICAL_SECTION(&m_CrSec);
	DecrementDLLCount();
}

STDMETHODIMP CGraph::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
	V_INAME(CGraph::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IDirectMusicGraph || iid == IID_IDirectMusicGraph8)
    {
        *ppv = static_cast<IDirectMusicGraph8*>(this);
	} 
    else if (iid == IID_CGraph)
	{
        *ppv = static_cast<CGraph*>(this);
	}  
    else if (iid == IID_IDirectMusicObject)
    {
        *ppv = static_cast<IDirectMusicObject*>(this);
    }
	else if (iid == IID_IPersistStream)
	{
        *ppv = static_cast<IPersistStream*>(this);
	}
    else if (iid == IID_IGraphClone)
	{
        *ppv = static_cast<IGraphClone*>(this);
	}
    else
    {
        *ppv = NULL;
        Trace(4,"Warning: Request to query unknown interface on ToolGraph object\n");
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


// @method:(INTERNAL) HRESULT | IDirectMusicGraph | AddRef | Standard AddRef implementation for <i IDirectMusicGraph>
//
// @rdesc Returns the new reference count for this object.
//
STDMETHODIMP_(ULONG) CGraph::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


// @method:(INTERNAL) HRESULT | IDirectMusicGraph | Release | Standard Release implementation for <i IDirectMusicGraph>
//
// @rdesc Returns the new reference count for this object.
//
STDMETHODIMP_(ULONG) CGraph::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

/*
Made internal 9/25/98
  method HRESULT | IDirectMusicGraph | Shutdown |
  Shuts down the graph. This must be called when the graph is no longer needed,
  in order to release the tools and other memory. A call to Release is not
  sufficient, because there is circular referencing between the graph and the tools.
  However, only the segment, performance, or whatever owns the graph
  should call this function.
  rvalue S_OK | Success.
  rvalue S_FALSE | Success, but didn't need to do anything.
*/
HRESULT STDMETHODCALLTYPE CGraph::Shutdown()
{
	// release all Tools
	CToolRef*	pObj;
	HRESULT hr = S_OK;
	ENTER_CRITICAL_SECTION(&m_CrSec);
	if( IsEmpty() )
	{
		hr = S_FALSE;
	}
    else
    {
	    while( pObj = RemoveHead() )
	    {
            delete pObj;
	    }
    }
	LEAVE_CRITICAL_SECTION(&m_CrSec);
	return hr;
}

HRESULT CGraph::InsertTool( 
    IDirectMusicTool *pTool,
    DWORD *pdwPChannels,
    DWORD cPChannels,
    LONG lIndex,
    GUID *pguidClassID)
{
	HRESULT hr = S_OK;
	ENTER_CRITICAL_SECTION(&m_CrSec);

	CToolRef*	pToolRef;
	// make sure that this Tool instance isn't already in the Graph
	for( pToolRef = GetHead(); pToolRef; pToolRef = pToolRef->GetNext() )
	{
		if( pTool == pToolRef->m_pTool )
		{
			LEAVE_CRITICAL_SECTION(&m_CrSec);
            Trace(1,"Error: Multiple install of the same tool in a graph\n");
	        return DMUS_E_ALREADY_EXISTS;
		}
	}
	// insert this Tool instance into the Graph
	pToolRef = new CToolRef;
	if( pToolRef )
	{
		DWORD		dwTemp;
		DWORD*		pdwArray = NULL;

		pToolRef->m_pTool = pTool;
		pTool->AddRef();
		pTool->Init(this);
		dwTemp = 0;
        IDirectMusicTool8 *pTool8;
        if (SUCCEEDED(pTool->QueryInterface(IID_IDirectMusicTool8,(void **) &pTool8)))
        {
            pToolRef->m_fSupportsClone = TRUE;
            pTool8->Release();
        }
        if (pguidClassID)
        {
            pToolRef->m_guidClassID = *pguidClassID;
        }
        else
        {
            IPersistStream *pPersist;
            if (SUCCEEDED(pTool->QueryInterface(IID_IPersistStream,(void **) &pPersist)))
            {
                pPersist->GetClassID(&pToolRef->m_guidClassID);
                pPersist->Release();
            }
        }
		pTool->GetMsgDeliveryType(&dwTemp);
		if( (dwTemp != DMUS_PMSGF_TOOL_IMMEDIATE) && (dwTemp != DMUS_PMSGF_TOOL_QUEUE) && (dwTemp != DMUS_PMSGF_TOOL_ATTIME) )
		{
			dwTemp = DMUS_PMSGF_TOOL_IMMEDIATE;
		}
		pToolRef->m_dwQueue = dwTemp;
		if( FAILED( pTool->GetMediaTypeArraySize(&dwTemp)))
		{
			dwTemp = 0;
		}
		pToolRef->m_dwMTArraySize = dwTemp;
		if( dwTemp )
		{
			pdwArray = new DWORD[dwTemp];
			if( pdwArray )
			{
				HRESULT hr = pTool->GetMediaTypes( &pdwArray, dwTemp );
				if( hr == E_NOTIMPL )
				{
					delete [] pdwArray;
					pToolRef->m_dwMTArraySize = 0;
				}
				else
				{
					pToolRef->m_pdwMediaTypes = pdwArray;
				}
			}
			else
			{
				delete pToolRef;
				LEAVE_CRITICAL_SECTION(&m_CrSec);
                return E_OUTOFMEMORY;
			}
		}
		if( pdwPChannels )
		{
			pToolRef->m_pdwPChannels = new DWORD[cPChannels];
			if( pToolRef->m_pdwPChannels )
			{
				memcpy( pToolRef->m_pdwPChannels, pdwPChannels, sizeof(DWORD) * cPChannels );
                pToolRef->m_dwPCArraySize = cPChannels;
			}
			else
			{
				delete pToolRef;
				LEAVE_CRITICAL_SECTION(&m_CrSec);
                return E_OUTOFMEMORY;
			}
		}

        if (lIndex < 0)
        {
            lIndex += AList::GetCount();       // Make index be offset from end.
        }
        CToolRef *pNext = GetItem(lIndex);
        if (pNext)
        {
            InsertBefore(pNext,pToolRef);
        }
        else
        {
            AList::AddTail(pToolRef);
        }
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}
	LEAVE_CRITICAL_SECTION(&m_CrSec);
	return hr;
}
HRESULT STDMETHODCALLTYPE CGraph::InsertTool( 
    IDirectMusicTool *pTool,	// @parm The Tool to insert.
    DWORD *pdwPChannels,	// @parm An array of which PChannels to place the tool in. These are 
							// id's which are converted to MIDI Channel + Port on output. If the 
							// tool accepts messages on all PChannels, this is NULL. <p cPChannels>
							// is the count of how many this array points to.
    DWORD cPChannels,		// @parm Count of how many PChannels are pointed to by <p pdwPChannels>.
    LONG lIndex)			// @parm At what position to place the tool. This is an index from either the start 
							// of the current tool list or, working backwards from the end (in which case, it is 
							// a negative number.) If <p lIndex> is out of range, the Tool will be placed at
							// the very beginning or end of the Tool list. 0 is the beginning. To place a Tool
							// at the end of the list, use a number for <p lIndex> that is larger than the number
							// of tools in the current tool list.
{
	V_INAME(IDirectMusicGraph::InsertTool);
	V_INTERFACE(pTool);
	V_BUFPTR_READ_OPT(pdwPChannels, sizeof(DWORD) * cPChannels);
	ENTER_API_CRITICAL_SECTION;
	HRESULT hr = InsertTool(pTool,pdwPChannels,cPChannels,lIndex,NULL);
	LEAVE_API_CRITICAL_SECTION;
	return hr;
}

HRESULT CGraph::GetObjectInPath( DWORD dwPChannel,REFGUID guidObject,
                    DWORD dwIndex,REFGUID iidInterface, void ** ppObject)

{
	V_INAME(IDirectMusicGraph::GetObjectInPath);
	V_PTRPTR_WRITE(ppObject);
    HRESULT hr = DMUS_E_NOT_FOUND;
	CToolRef*	pPlace;
	if( !IsEmpty() )
	{
	    pPlace = NULL;
	    // search for the tool
	    ENTER_CRITICAL_SECTION(&m_CrSec);
	    for( pPlace = GetHead(); pPlace; 
		    pPlace = pPlace->GetNext() )
	    {
            if ((guidObject == pPlace->m_guidClassID) || (guidObject == GUID_All_Objects))
            {
                BOOL fFound = (!pPlace->m_pdwPChannels || (dwPChannel >= DMUS_PCHANNEL_ALL));
                if( !fFound )
			    {
				    DWORD cCount;
			        // scan through the array of PChannels to see if this one
			        // supports dwPChannel
			        for( cCount = 0; cCount < pPlace->m_dwPCArraySize; cCount++)
			        {
				        if( dwPChannel == pPlace->m_pdwPChannels[cCount] )
				        {
                            fFound = TRUE;
					        // yep, it supports it
                            break;
				        }
			        }
                }
                if (fFound)
                {
                    if (!dwIndex)
                    {
                        break;
                    }
                    else
                    {
                        dwIndex--;
                    }
                }
            }
	    }
	    if( pPlace )
	    {
            hr = pPlace->m_pTool->QueryInterface(iidInterface,ppObject);
        }
	    LEAVE_CRITICAL_SECTION(&m_CrSec);
    }
#ifdef DBG
    if (hr == DMUS_E_NOT_FOUND)
    {
        Trace(1,"Error: Requested Tool not found in Graph\n");
    }
#endif
    return hr;

}

/*
  @method HRESULT | IDirectMusicGraph | GetTool |
  Returns the Tool at the specified index.

  @rvalue DMUS_E_NOT_FOUND | Unable to find a Tool at the position described.
  @rvalue E_POINTER | ppTool is NULL or invalid.
  @rvalue S_OK | Success.

  @comm The retrieved tool is AddRef'd by this call, so be sure to Release it.
*/
HRESULT STDMETHODCALLTYPE CGraph::GetTool( 
    DWORD dwIndex,				// @parm The index, from the beginning and starting at 0, 
								// at which to retrieve the Tool from the Graph.
    IDirectMusicTool **ppTool)	// @parm The <i IDirectMusicTool> pointer to use 
								// for returning the requested tool. 
{
	V_INAME(IDirectMusicGraph::GetTool);
	V_PTRPTR_WRITE(ppTool);
	CToolRef*	pPlace;
	HRESULT hr = S_OK;

	if( IsEmpty() )
	{
        Trace(2,"Warning: GetTool failed because the Tool Graph is empty\n");
		return DMUS_E_NOT_FOUND;
	}
	pPlace = NULL;
	// search for the indexed tool
	ENTER_CRITICAL_SECTION(&m_CrSec);
	ENTER_API_CRITICAL_SECTION;
	for( pPlace = GetHead(); ( dwIndex > 0 ) && pPlace; 
		pPlace = pPlace->GetNext() )
	{
		dwIndex--;
	}
	if( NULL == pPlace )
	{
		hr = DMUS_E_NOT_FOUND;
	}
    else
    {
	    *ppTool = pPlace->m_pTool;
	    (*ppTool)->AddRef();
    }
	LEAVE_CRITICAL_SECTION(&m_CrSec);
	LEAVE_API_CRITICAL_SECTION;
	return hr;
}

/*
  @method HRESULT | IDirectMusicGraph | RemoveTool |
  Removes the Tool from the Graph.

  @rvalue DMUS_E_NOT_FOUND | The specified Tool is not in the Graph.
  @rvalue E_POINTER | pTool is NULL or invalid.
  @rvalue S_OK | Success.

  @comm The Tool is removed from the Graph, and the Graph's reference on the Tool
  object is released.
*/
HRESULT STDMETHODCALLTYPE CGraph::RemoveTool( 
    IDirectMusicTool *pTool)	// @parm The <i IDirectMusicTool> pointer of the Tool to remove.
{
	V_INAME(IDirectMusicGraph::RemoveTool);
	V_INTERFACE(pTool);
	CToolRef*	pPlace;
	HRESULT hr = S_OK;
	ENTER_CRITICAL_SECTION(&m_CrSec);
	ENTER_API_CRITICAL_SECTION;
	// search for the tool
	for( pPlace = GetHead(); pPlace; pPlace = pPlace->GetNext() )
	{
		if( pPlace->m_pTool == pTool )
			break;
	}
	if( NULL == pPlace )
	{
        Trace(1,"Error: RemoveTool - Tool not in Graph.\n");
		hr = DMUS_E_NOT_FOUND;
	}
    else
    {
        AList::Remove(pPlace);
	    delete pPlace;
    }
	LEAVE_CRITICAL_SECTION(&m_CrSec);
	LEAVE_API_CRITICAL_SECTION;
	return hr;
}


STDMETHODIMP CGraph::Clone(IDirectMusicGraph **ppGraph)

{
    V_INAME(IDirectMusicGraph::Clone);
	V_PTRPTR_WRITE(ppGraph);

    HRESULT hr = E_OUTOFMEMORY;
   	ENTER_CRITICAL_SECTION(&m_CrSec);
    CGraph *pNew = new CGraph;
    if (pNew)
    {
        pNew->m_Info = m_Info;
        CToolRef *pSource = GetHead();
        CToolRef *pDest;
        for (;pSource;pSource = pSource->GetNext())
        {
            pDest = new CToolRef;
            if (pDest)
            {
                pNew->AList::AddTail(pDest);
                pDest->m_dwMTArraySize = pSource->m_dwMTArraySize;
                pDest->m_dwPCArraySize = pSource->m_dwPCArraySize;
                pDest->m_dwQueue = pSource->m_dwQueue;
                pDest->m_fSupportsClone = pSource->m_fSupportsClone;
                pDest->m_guidClassID = pSource->m_guidClassID;
                if (pSource->m_dwMTArraySize)
                {
                    pDest->m_pdwMediaTypes = new DWORD[pSource->m_dwMTArraySize];
                    if (pDest->m_pdwMediaTypes)
                    {
                        memcpy(pDest->m_pdwMediaTypes,pSource->m_pdwMediaTypes,
                            sizeof(DWORD)*pDest->m_dwMTArraySize);
                    }
                    else
                    {
                        pDest->m_dwMTArraySize = 0;
                    }
                }
                else
                {
                    pDest->m_pdwMediaTypes = NULL;
                }
                if (pSource->m_dwPCArraySize)
                {
                    pDest->m_pdwPChannels = new DWORD[pSource->m_dwPCArraySize];
                    if (pDest->m_pdwPChannels)
                    {
                        memcpy(pDest->m_pdwPChannels,pSource->m_pdwPChannels,
                            sizeof(DWORD)*pDest->m_dwPCArraySize);
                    }
                    else
                    {
                        pDest->m_dwPCArraySize = 0;
                    }
                }
                else
                {
                    pDest->m_pdwPChannels = NULL;
                }
                if (pSource->m_pTool)
                {
                    if (pDest->m_fSupportsClone)
                    {
                        IDirectMusicTool8 *pTool8 = (IDirectMusicTool8 *) pSource->m_pTool;
                        pTool8->Clone(&pDest->m_pTool);
                    }
                    else
                    {
                        pDest->m_pTool = pSource->m_pTool;
                        pDest->m_pTool->AddRef();
                    }
                }
            }
            else
            {
                delete pNew;
                pNew = NULL;
                break;
            }
        }
    }
    *ppGraph = (IDirectMusicGraph *) pNew;
	if (pNew) hr = S_OK;
	LEAVE_CRITICAL_SECTION(&m_CrSec);
    return hr;
}

// returns TRUE if dwType is supported by pToolRef
inline BOOL CGraph::CheckType( DWORD dwType, CToolRef* pToolRef )
{
	BOOL fReturn = FALSE;
	if( pToolRef->m_dwMTArraySize == 0 )
	{
		fReturn = TRUE; // supports all types
	}
	else
	{
		DWORD dw;
		ASSERT( pToolRef->m_pdwMediaTypes );
		for( dw = 0; dw < pToolRef->m_dwMTArraySize; dw++ )
		{
			if( dwType == pToolRef->m_pdwMediaTypes[dw] )
			{
				fReturn = TRUE;
				break;
			}
		}
	}
	return fReturn;
}

HRESULT STDMETHODCALLTYPE CGraph::StampPMsg( 
	DMUS_PMSG* pPMsg)	// @parm The message to stamp. 
{
	V_INAME(IDirectMusicGraph::StampPMsg);
	V_BUFPTR_WRITE(pPMsg, sizeof(DMUS_PMSG));

	HRESULT hr = S_OK;
    if( NULL == pPMsg )
	{
		return E_INVALIDARG;
	}
	ENTER_CRITICAL_SECTION(&m_CrSec);
	ENTER_API_CRITICAL_SECTION;

	CToolRef*	pPlace = GetHead();
	IDirectMusicTool*	pPriorTool;
	DWORD		dwType;
	DWORD		dwPChannel;
	

	pPriorTool = pPMsg->pTool;
	dwType = pPMsg->dwType;
	dwPChannel = pPMsg->dwPChannel;
	if( pPriorTool )
	{
		for( ; pPlace; pPlace = pPlace->GetNext() )
		{
			if( pPriorTool == pPlace->m_pTool )
			{
				pPlace = pPlace->GetNext();
				break;
			}
		}
	}
    BOOL fFound = FALSE;
	for( ; pPlace ; pPlace = pPlace->GetNext() )
	{
		if( CheckType(dwType, pPlace) )
		{
			if( !pPlace->m_pdwPChannels || (dwPChannel >= DMUS_PCHANNEL_BROADCAST_GROUPS))
			{
				// supports all tracks, or requested channel is broadcast.
				break;
			}
			DWORD cCount;
			// scan through the array of PChannels to see if this one
			// supports dwPChannel
			for( cCount = 0; cCount < pPlace->m_dwPCArraySize; cCount++)
			{
				if( dwPChannel == pPlace->m_pdwPChannels[cCount] )
				{
                    fFound = TRUE;
					// yep, it supports it
                    break;
				}
			}
		}
        if (fFound) break;
	}
	// release the current tool
	if( pPMsg->pTool )
	{
		pPMsg->pTool->Release();
		pPMsg->pTool = NULL;
	}
	if( NULL == pPlace )
	{
		hr = DMUS_S_LAST_TOOL;
	}
	else
    {
        // if there is no graph pointer, set it to this
	    if( NULL == pPMsg->pGraph )
	    {
		    pPMsg->pGraph = this;
		    AddRef();
	    }
	    // set to the new tool and addref
        if (pPlace->m_pTool) // Just in case, the ptool sometimes goes away in debugging situations after a long break.
        {
	        pPMsg->pTool = pPlace->m_pTool;
	        pPMsg->pTool->AddRef();
        }
	    // set the event's queue type
	    pPMsg->dwFlags &= ~(DMUS_PMSGF_TOOL_IMMEDIATE | DMUS_PMSGF_TOOL_QUEUE | DMUS_PMSGF_TOOL_ATTIME);
	    pPMsg->dwFlags |= pPlace->m_dwQueue;
    }
	LEAVE_CRITICAL_SECTION(&m_CrSec);
	LEAVE_API_CRITICAL_SECTION;
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CGraph::GetClassID( CLSID* pClassID )
{
	V_INAME(CGraph::GetClassID);
	V_PTR_WRITE(pClassID, CLSID); 
	*pClassID = CLSID_DirectMusicGraph;
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPersistStream functions

HRESULT CGraph::IsDirty()
{
	return S_FALSE;
}

HRESULT CGraph::Load( IStream* pIStream )
{
	V_INAME(IPersistStream::Load);
	V_INTERFACE(pIStream);

    CRiffParser Parser(pIStream);
    RIFFIO ckMain;
    HRESULT hr = S_OK;

    Parser.EnterList(&ckMain);  
    if (Parser.NextChunk(&hr) && (ckMain.fccType == DMUS_FOURCC_TOOLGRAPH_FORM))
    {
        Shutdown(); // Clear out the tools that are currently in the graph.
        hr = Load(&Parser);
    }
    else
    {
        Trace(1,"Error: Unknown file format when parsing Tool Graph\n");
        hr = DMUS_E_DESCEND_CHUNK_FAIL;
    }
    return hr;
}

HRESULT CGraph::Load(CRiffParser *pParser)

{
	RIFFIO ckNext;
    RIFFIO ckChild;
    HRESULT hr = S_OK;
    pParser->EnterList(&ckNext);
	while(pParser->NextChunk(&hr))
	{
		switch(ckNext.ckid)
		{
        case DMUS_FOURCC_GUID_CHUNK:
        case DMUS_FOURCC_VERSION_CHUNK:
        case DMUS_FOURCC_CATEGORY_CHUNK:
        case DMUS_FOURCC_DATE_CHUNK:
            hr = m_Info.ReadChunk(pParser,ckNext.ckid);
			break;
		case FOURCC_LIST:
			switch(ckNext.fccType)
			{
                case DMUS_FOURCC_UNFO_LIST:
                    hr = m_Info.ReadChunk(pParser,ckNext.fccType);
					break;
				case DMUS_FOURCC_TOOL_LIST:
                    pParser->EnterList(&ckChild);
	                while(pParser->NextChunk(&hr))
	                {
		                if ((ckChild.ckid == FOURCC_RIFF) && 
                            (ckChild.fccType == DMUS_FOURCC_TOOL_FORM))
                        {
			                hr = LoadTool(pParser);
		                } 
	                }
                    pParser->LeaveList();
					break;
			}
			break;
		}
	}
    pParser->LeaveList();

	return hr;
}

HRESULT CGraph::LoadTool(CRiffParser *pParser)
{
	RIFFIO ckNext;
	DWORD cbSize;
	
	DMUS_IO_TOOL_HEADER ioDMToolHdr;
	DWORD *pdwPChannels = NULL;

	HRESULT hr = S_OK; 

    pParser->EnterList(&ckNext);

    if (pParser->NextChunk(&hr))
    {
		if(ckNext.ckid != DMUS_FOURCC_TOOL_CHUNK)
		{
            pParser->LeaveList();
            Trace(1,"Error: Tool header chunk not first in tool list.\n");
			return DMUS_E_TOOL_HDR_NOT_FIRST_CK;
		}	
		
		hr = pParser->Read(&ioDMToolHdr, sizeof(DMUS_IO_TOOL_HEADER));
		
		if(ioDMToolHdr.ckid == 0 && ioDMToolHdr.fccType == NULL)
		{
			pParser->LeaveList();
            Trace(1,"Error: Invalid Tool header.\n");
			return DMUS_E_INVALID_TOOL_HDR;
		}
		
		if(ioDMToolHdr.cPChannels)
		{
			pdwPChannels = new DWORD[ioDMToolHdr.cPChannels];
			// subtract 1 from cPChannels, because 1 element is actually stored
			// in the ioDMToolHdr array.
			cbSize = (ioDMToolHdr.cPChannels - 1) * sizeof(DWORD);
			if(pdwPChannels)
			{
				pdwPChannels[0] = ioDMToolHdr.dwPChannels[0];
				if( cbSize )
				{
					hr = pParser->Read(&pdwPChannels[1], cbSize);
					if(FAILED(hr))
					{
						delete [] pdwPChannels;
						pdwPChannels = NULL;
                        pParser->LeaveList();
                        Trace(1,"Error: File read error loading Tool.\n");
						return DMUS_E_CANNOTREAD;
					}
				}
			}
			else
			{
				hr = E_OUTOFMEMORY;
			}
		}
	}
	else
	{
        pParser->LeaveList();
        Trace(1,"Error reading Tool chunk - not RIFF format.\n");
		hr = DMUS_E_DESCEND_CHUNK_FAIL;
	}
    while (pParser->NextChunk(&hr))
    {
        if((((ckNext.ckid == FOURCC_LIST) || (ckNext.ckid == FOURCC_RIFF))
		    && ckNext.fccType == ioDMToolHdr.fccType) ||
            (ckNext.ckid == ioDMToolHdr.ckid))
		{
            pParser->SeekBack();
			hr = CreateTool(ioDMToolHdr, pParser->GetStream(), pdwPChannels);
            pParser->SeekForward();
		} 
	}

    pParser->LeaveList();

    if( pdwPChannels )
    {
        delete [] pdwPChannels;
        pdwPChannels = NULL;
    }

	return hr;
}

HRESULT CGraph::CreateTool(DMUS_IO_TOOL_HEADER ioDMToolHdr, IStream *pStream, DWORD *pdwPChannels)
{
	assert(pStream);

	IDirectMusicTool* pDMTool = NULL;
	HRESULT hr = DirectMusicCreateInstance(ioDMToolHdr.guidClassID,
								  NULL,
								  IID_IDirectMusicTool,
								  (void**)&pDMTool);
	IPersistStream *pIPersistStream = NULL;
	
	if(SUCCEEDED(hr))
	{
		hr = pDMTool->QueryInterface(IID_IPersistStream, (void **)&pIPersistStream);
	}
    else
    {
        Trace(1,"Error creating tool for loading\n");
    }

	if(SUCCEEDED(hr))
	{
		hr = pIPersistStream->Load(pStream);
#ifdef DBG
        if (FAILED(hr))
        {
            Trace(1,"Error loading data into tool\n");
        }
#endif
	}

	if(SUCCEEDED(hr))
	{
		hr = InsertTool(pDMTool, pdwPChannels, ioDMToolHdr.cPChannels, ioDMToolHdr.lIndex, &ioDMToolHdr.guidClassID);  
	}

	if(pIPersistStream)
	{
		pIPersistStream->Release();
	}
	
	if(pDMTool)
	{
		pDMTool->Release();
	}

	return hr;
}

HRESULT CGraph::Save( IStream* pIStream, BOOL fClearDirty )
{
	return E_NOTIMPL;
}

HRESULT CGraph::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// IDirectMusicObject

STDMETHODIMP CGraph::GetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
	// Argument validation
	V_INAME(CGraph::GetDescriptor);
	V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);
    return m_Info.GetDescriptor(pDesc,CLSID_DirectMusicGraph);
}

STDMETHODIMP CGraph::SetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
	// Argument validation
	V_INAME(CGraph::SetDescriptor);
	V_STRUCTPTR_READ(pDesc, DMUS_OBJECTDESC);
	return m_Info.SetDescriptor(pDesc);
}

STDMETHODIMP CGraph::ParseDescriptor(LPSTREAM pIStream, LPDMUS_OBJECTDESC pDesc) 
{
    V_INAME(CGraph::ParseDescriptor);
    V_INTERFACE(pIStream);
    V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);
    return m_Info.ParseDescriptor(pIStream,pDesc,DMUS_FOURCC_TOOLGRAPH_FORM,CLSID_DirectMusicGraph);
}

void CGraphList::Clear()
{
    CGraph *pGraph;
    while (pGraph = RemoveHead())
    {
        pGraph->Release();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\dmsegobj.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// DMSegObj.h : Declaration of the CSegment

#ifndef __DIRECTMUSICSEGMENTOBJECT_H_
#define __DIRECTMUSICSEGMENTOBJECT_H_

#include "dmusicip.h"
#include "dmusicf.h"
#include "dmime.h"

#include "TrkList.h"
#include "ntfylist.h"
#include "dmsstobj.h"
#include "..\shared\dmusicp.h"

#define COMPOSE_TRANSITION1 (DMUS_TRACKCONFIG_TRANS1_FROMSEGSTART | DMUS_TRACKCONFIG_TRANS1_FROMSEGCURRENT | DMUS_TRACKCONFIG_TRANS1_TOSEGSTART)

class CSegment;

DEFINE_GUID(IID_CSegment,0xb06c0c21, 0xd3c7, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);

/////////////////////////////////////////////////////////////////////////////
// CSegment
class CSegment :
	public IDirectMusicSegment8,
#ifndef XBOX
	public IDirectMusicSegment8P,
#endif
	public IPersistStream,
	public IDirectMusicObject,
    public AListItem,
    public IDirectMusicObjectP
{
friend class CPerformance;
friend class CSegState;
friend class CSong;
public:
	CSegment();
    CSegment(DMUS_IO_SEGMENT_HEADER *pHeader, CSegment *pSource);
	~CSegment();
    CSegment* GetNext() { return (CSegment*)AListItem::GetNext();}

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
// IDirectMusicSegment
    STDMETHODIMP GetLength(MUSIC_TIME *pmtLength);
    STDMETHODIMP SetLength(MUSIC_TIME pmtLength);
    STDMETHODIMP GetRepeats(DWORD *pdwRepeats);
    STDMETHODIMP SetRepeats(DWORD dwRepeats);
    STDMETHODIMP GetDefaultResolution(DWORD *pdwResolution);
    STDMETHODIMP SetDefaultResolution(DWORD dwResolution);
    STDMETHODIMP GetTrack(REFCLSID rType,DWORD dwGroupBits,DWORD dwIndex,IDirectMusicTrack **ppTrack);
    STDMETHODIMP GetTrackGroup(IDirectMusicTrack* pTrack,DWORD* pdwGroupBits);
    STDMETHODIMP InsertTrack(IDirectMusicTrack *pTrack,DWORD dwGroupBits);
    STDMETHODIMP RemoveTrack(IDirectMusicTrack *pTrack);
    STDMETHODIMP InitPlay(IDirectMusicSegmentState **ppSegState,IDirectMusicPerformance *pPerformance,DWORD dwFlags);
    STDMETHODIMP GetGraph(IDirectMusicGraph** ppGraph);
    STDMETHODIMP SetGraph(IDirectMusicGraph* pGraph);
    STDMETHODIMP AddNotificationType(REFGUID rguidNotification);
    STDMETHODIMP RemoveNotificationType(REFGUID rguidNotification);
	STDMETHODIMP GetParam(REFGUID rguidDataType,DWORD dwGroupBits,
                    DWORD dwIndex,MUSIC_TIME mtTime, 
				    MUSIC_TIME* pmtNext,void* pData); 
    STDMETHODIMP SetParam(REFGUID rguidDataType,DWORD dwGroupBits, 
				    DWORD dwIndex,MUSIC_TIME mtTime,void* pData);
    STDMETHODIMP Clone(MUSIC_TIME mtStart,MUSIC_TIME mtEnd,IDirectMusicSegment** ppSegment);
	STDMETHODIMP GetStartPoint(MUSIC_TIME* pmtStart);
    STDMETHODIMP SetStartPoint(MUSIC_TIME mtStart);
    STDMETHODIMP GetLoopPoints(MUSIC_TIME* pmtStart,MUSIC_TIME* pmtEnd);
    STDMETHODIMP SetLoopPoints(MUSIC_TIME mtStart,MUSIC_TIME mtEnd);
    STDMETHODIMP SetPChannelsUsed(DWORD dwNumPChannels,DWORD* paPChannels);
// The following 4 are XBox only
    STDMETHODIMP GetClockTimeLength(REFERENCE_TIME *prtLength, BOOL *pfClockTime);
    STDMETHODIMP SetClockTimeLength(REFERENCE_TIME rtLength, BOOL fClockTime);
    STDMETHODIMP SetClockTimeLoopPoints(REFERENCE_TIME rtStart, REFERENCE_TIME rtEnd) ;
    STDMETHODIMP GetClockTimeLoopPoints(REFERENCE_TIME* prtStart, REFERENCE_TIME* prtEnd) ;
    STDMETHODIMP SetWavePlaybackParams(DWORD dwFlags, DWORD dwReadAhead) ;
//  IDirectMusicSegment8 
    STDMETHODIMP SetTrackConfig(REFGUID rguidTrackClassID,DWORD dwGroup, DWORD dwIndex, DWORD dwFlagsOn, DWORD dwFlagsOff) ;
    STDMETHODIMP GetAudioPathConfig(IUnknown ** ppIAudioPathConfig);
    STDMETHODIMP Compose(MUSIC_TIME mtTime,
		IDirectMusicSegment* pFromSegment,
		IDirectMusicSegment* pToSegment,
		IDirectMusicSegment** ppComposedSegment);
    STDMETHODIMP Download(IUnknown *pAudioPath);
    STDMETHODIMP Unload(IUnknown *pAudioPath);
// IDirectMusicSegment8P
    STDMETHODIMP GetObjectInPath(DWORD dwPChannel,    /* PChannel to search. */
                                    DWORD dwStage,       /* Which stage in the path. */
                                    DWORD dwBuffer,
                                    REFGUID guidObject,  /* ClassID of object. */
                                    DWORD dwIndex,       /* Which object of that class. */
                                    REFGUID iidInterface,/* Requested COM interface. */
                                    void ** ppObject) ; /* Pointer to interface. */
    STDMETHODIMP GetHeaderChunk(
        DWORD *pdwSize,      /* Size of passed header chunk. Also, returns size written. */
        DMUS_IO_SEGMENT_HEADER *pHeader); /* Header chunk to fill. */
    STDMETHODIMP SetHeaderChunk(
        DWORD dwSize,        /* Size of passed header chunk. */
        DMUS_IO_SEGMENT_HEADER *pHeader); /* Header chunk to fill. */
    STDMETHODIMP SetTrackPriority(
        REFGUID rguidTrackClassID,  /* ClassID of Track. */
        DWORD dwGroupBits,          /* Group bits. */
        DWORD dwIndex,              /* Nth track. */
        DWORD dwPriority);       /* Priority to set. */
    STDMETHODIMP SetAudioPathConfig(
        IUnknown *pAudioPathConfig);

// IPersist 
    STDMETHODIMP GetClassID( CLSID* pClsId );

// IPersistStream 
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load( IStream* pIStream );
    STDMETHODIMP Save( IStream* pIStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER FAR* pcbSize );

// IDirectMusicObject 
	STDMETHODIMP GetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP SetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc);

	HRESULT GetPChannels( DWORD* pdwNumPChannels, DWORD** ppaPChannels );
	HRESULT CheckNotification( REFGUID );

// IDirectMusicObjectP
	STDMETHOD_(void, Zombie)();

private:
    CMemTrack m_MemTrack;
public:
    HRESULT GetTrackConfig(REFGUID rguidTrackClassID,DWORD dwGroup, DWORD dwIndex, DWORD *pdwFlags) ;
    HRESULT AddNotificationType(REFGUID rguidNotification, BOOL fFromPerformance);
    HRESULT RemoveNotificationType(REFGUID rguidNotification, BOOL fFromPerformance);
    BOOL IsTempoSource();	
    HRESULT CreateSegmentState(CSegState **ppSegState,CPerformance *pPerformance, 
        IDirectMusicAudioPath *pAudioPath, DWORD dwFlags); 
    CTrack *GetTrack(REFCLSID rType,DWORD dwGroupBits,DWORD dwIndex);
    CTrack * GetTrackByParam(CTrack * pCTrack,REFGUID rguidType,DWORD dwGroupBits,DWORD dwIndex, BOOL fDontCheck);
    HRESULT GetTrackByParam(REFGUID rgCommandGuid,DWORD dwGroupBits,
        DWORD dwIndex,IDirectMusicTrack **ppTrack);
	HRESULT LoadDirectMusicSegment(IStream* pIStream);	
	void AddNotificationTypeToAllTracks( REFGUID rguidNotification );
	void RemoveNotificationTypeFromAllTracks( REFGUID rguidNotification );
	CNotificationItem* FindNotification( REFGUID rguidNotification );
	HRESULT LoadTrack(CRiffParser *pParser);
	HRESULT CreateTrack(DMUS_IO_TRACK_HEADER& ioDMHdr, DWORD dwFlags, DWORD dwPriority, IStream *pStream);
    HRESULT InsertTrack(IDirectMusicTrack *pTrack,DWORD dwGroupBits, DWORD dwFlags, DWORD dwPriority, DWORD dwPosition);
	HRESULT LoadGraph(CRiffParser *pParser,CGraph **ppGraph);
    HRESULT LoadAudioPath(IStream *pStream);
	HRESULT ParseSegment(IStream* pIStream, LPDMUS_OBJECTDESC pDesc);
    void Init();
    HRESULT ComposeTransition(MUSIC_TIME mtTime,
		IDirectMusicSegment* pFromSegment,
		IDirectMusicSegment* pToSegment);
    HRESULT ComposeInternal();
	HRESULT SetClockTimeDuration(REFERENCE_TIME rtDuration);
	HRESULT SetFlags(DWORD dwFlags);
    void Clear(bool fZombie);
    HRESULT MusicToReferenceTime(MUSIC_TIME mtTime, REFERENCE_TIME *prtTime);
    HRESULT ReferenceToMusicTime(REFERENCE_TIME rtTime, MUSIC_TIME *pmtTime);

// Attributes
protected:
    CRITICAL_SECTION    m_CriticalSection;
	DWORD	            m_dwRepeats;	// # of times to repeat the segment. 0xffffffff is infinite
	DWORD	            m_dwResolution; // the default resolution to start motifs and such.
    DWORD               m_dwSegFlags;   // Flags loaded in with segment. 
	CTrackList	        m_TrackList;	// list of Tracks held in this Segment
    CAudioPathConfig*   m_pAudioPathConfig; // Optional audio path loaded from file. 
    CGraph*	            m_pGraph;       // Optional tool graph for segment.
	CNotificationList	m_NotificationList;
    REFERENCE_TIME      m_rtLength;     // Optional length in reference time units. 
    REFERENCE_TIME      m_rtLoopStart;
    REFERENCE_TIME      m_rtLoopEnd;
	MUSIC_TIME	        m_mtLength;
	MUSIC_TIME	        m_mtStart;
	MUSIC_TIME	        m_mtLoopStart;
	MUSIC_TIME	        m_mtLoopEnd;
	DWORD	            m_dwNumPChannels;
	DWORD*	            m_paPChannels;
	long                m_cRef;
    IUnknown *          m_pUnkDispatch; // holds the controlling unknown of the scripting object that implements IDispatch
// IDirectMusicObject variables
    CInfo               m_Info;
    DWORD               m_dwVersion;        // Which version of the interfaces is the app requesting?

    bool                m_fZombie;

public:
    DWORD               m_dwLoadID;     // Identifier, used when loaded as part of a song.
    CSong*              m_pSong;        // Optional parent song that segment belongs to. This is not AddRef'd.
    DWORD               m_dwPlayID;     // ID of segment, if within a song.
    DWORD               m_dwNextPlayID; // ID of next segment, if within a song.
    DWORD               m_dwNextPlayFlags; // DMUS_SEGF flags for playing next segment, if within a song.
    BOOL                m_fPlayNext;    // Whether the next segment should be played.
};

class CSegmentList : public AList
{
public:
    void Clear();
    void AddHead(CSegment* pSegment) { AList::AddHead((AListItem*)pSegment);}
    void Insert(CSegment* pSegment);
    BOOL IsMember(CSegment *pSegment) { return AList::IsMember((AListItem*)pSegment);}
    CSegment* GetHead(){return (CSegment*)AList::GetHead();}
    CSegment* GetItem(LONG lIndex){return (CSegment*)AList::GetItem(lIndex);}
    CSegment* RemoveHead() {return (CSegment *) AList::RemoveHead();}
    void Remove(CSegment* pSegment){AList::Remove((AListItem*)pSegment);}
    void AddTail(CSegment* pSegment){AList::AddTail((AListItem*)pSegment);}
    CSegment* GetTail(){ return (CSegment*)AList::GetTail();}
};


#endif //__DIRECTMUSICSEGMENTOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\lyrictrk.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CLyricsTrack.
//
#include "pchime.h"
/*#include "dmime.h"
#include "lyrictrk.h"
#include "..\shared\Validate.h"
#include "dmperf.h"
#include "miscutil.h"*/

//////////////////////////////////////////////////////////////////////
// Load

HRESULT
CLyricsTrack::LoadRiff(SmartRef::RiffIter &ri, IDirectMusicLoader *pIDMLoader)
{
	struct LocalFunction
	{
		// Helper used by the LoadRiff function when we expected to find something
		// but a RiffIter becomes false.  In this case, if it has a success HR
		// indicating there were no more items then we return DMUS_E_INVALID_LYRICSTRACK
		// because the stream didn't contain the data we expected.  If it has a
		// failure hr, it was unable to read from the stream and we return its HR.
		static HRESULT HrFailOK(const SmartRef::RiffIter &ri)
		{
			HRESULT hr = ri.hr();
			return SUCCEEDED(hr) ? DMUS_E_INVALID_LYRICSTRACK : hr;
		}
	};

	HRESULT hr = S_OK;

	// find <lyrt>
	if (!ri.Find(SmartRef::RiffIter::List, DMUS_FOURCC_LYRICSTRACK_LIST))
	{
#ifdef DBG
		if (SUCCEEDED(ri.hr()))
		{
			Trace(1, "Error: Unable to load lyric track: List 'lyrt' not found.\n");
		}
#endif
		return LocalFunction::HrFailOK(ri);
	}

	// find <lyrl>
	SmartRef::RiffIter riTrackForm = ri.Descend();
	if (!riTrackForm)
		return riTrackForm.hr();
	if (!riTrackForm.Find(SmartRef::RiffIter::List, DMUS_FOURCC_LYRICSTRACKEVENTS_LIST))
	{
#ifdef DBG
		if (SUCCEEDED(riTrackForm.hr()))
		{
			Trace(1, "Error: Unable to load lyric track: List 'lyrl' not found.\n");
		}
#endif
		return LocalFunction::HrFailOK(riTrackForm);
	}

	// process each event <lyre>
	SmartRef::RiffIter riEvent = riTrackForm.Descend();
	if (!riEvent)
		return riEvent.hr();

	for ( ; riEvent; ++riEvent)
	{
		if (riEvent.type() == SmartRef::RiffIter::List && riEvent.id() == DMUS_FOURCC_LYRICSTRACKEVENT_LIST)
		{
			HRESULT hr = this->LoadLyric(riEvent.Descend());
			if (FAILED(hr))
				return hr;
		}
	}
	return riEvent.hr();
}

//////////////////////////////////////////////////////////////////////
// other methods

HRESULT
CLyricsTrack::PlayItem(
		const LyricInfo &item,
		statedata &state,
		IDirectMusicPerformance *pPerf,
		IDirectMusicSegmentState* pSegSt,
		DWORD dwVirtualID,
		MUSIC_TIME mtOffset,
		REFERENCE_TIME rtOffset,
		bool fClockTime)
{
	// get the graph from the segment state
	IDirectMusicGraph *pGraph = NULL;
	HRESULT hrG = pSegSt->QueryInterface(IID_IDirectMusicGraph, reinterpret_cast<void**>(&pGraph));
	if (FAILED(hrG))
		return hrG;

	SmartRef::PMsg<DMUS_LYRIC_PMSG> pmsg(pPerf, 2 * wcslen(item.wstrText));
	if (FAILED(pmsg.hr())) {
		pGraph->Release();
		return pmsg.hr();
	}

	assert(((char*)&pmsg.p->wszString[wcslen(item.wstrText)]) + 1 < (((char*)(pmsg.p)) + pmsg.p->dwSize)); // just to make sure we haven't miscalculated.  the last byte of the null of the string should fall before the byte just beyond the extent of the struct (and it could be several bytes before if the DMUS_LYRIC_PMSG struct ended up being padded to come out to an even multiple of bytes.
	wcscpy(pmsg.p->wszString, item.wstrText);
	if (fClockTime)
	{
		pmsg.p->rtTime = item.lTimePhysical * gc_RefPerMil + rtOffset;
		pmsg.p->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME | item.dwTimingFlags;
	}
	else
	{
		pmsg.p->mtTime = item.lTimePhysical + mtOffset;
		pmsg.p->dwFlags = DMUS_PMSGF_MUSICTIME | item.dwTimingFlags;
	}
	pmsg.p->dwVirtualTrackID = dwVirtualID;
	pmsg.p->dwType = DMUS_PMSGT_LYRIC;
	pmsg.p->dwGroupID = 0xffffffff;

	pmsg.StampAndSend(pGraph);
	pGraph->Release();
    return pmsg.hr();
}

HRESULT
CLyricsTrack::LoadLyric(SmartRef::RiffIter ri)
{
	HRESULT hr = S_OK;

	if (!ri)
		return ri.hr();

	// Create an event
	TListItem<LyricInfo> *pItem = new TListItem<LyricInfo>;
	if (!pItem)
		return E_OUTOFMEMORY;
	LyricInfo &rinfo = pItem->GetItemValue();

	bool fFoundEventHeader = false;

	for ( ; ri; ++ri)
	{
		if (ri.type() != SmartRef::RiffIter::Chunk)
			continue;

		switch(ri.id())
		{
			case DMUS_FOURCC_LYRICSTRACKEVENTHEADER_CHUNK:
				// Read an event chunk
				DMUS_IO_LYRICSTRACK_EVENTHEADER ioItem;
				hr = SmartRef::RiffIterReadChunk(ri, &ioItem);
				if (FAILED(hr))
                {
                    delete pItem;
					return hr;
                }

				// Don't allow ref/music timing flags because these are controlled by whether
				// the overall track is playing music or clock time and can't be set in individual
				// events.  Similarly, the tool flush flag isn't appropriate for an event to be played.
				if (ioItem.dwTimingFlags & (DMUS_PMSGF_REFTIME | DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_TOOL_FLUSH | DMUS_PMSGF_LOCKTOREFTIME))
                {
					Trace(1, "Error: Unable to load lyric track: DMUS_PMSGF_REFTIME, DMUS_PMSGF_MUSICTIME, DMUS_PMSGF_TOOL_FLUSH, and DMUS_PMSGF_LOCKTOREFTIME are not allowed as dwTimingFlags in chunk 'lyrh'.\n");
                    delete pItem;
                    return DMUS_E_INVALID_LYRICSTRACK;
                }

				fFoundEventHeader = true;
				rinfo.dwFlags = ioItem.dwFlags;
				rinfo.dwTimingFlags = ioItem.dwTimingFlags;
				rinfo.lTriggerTime = ioItem.lTimeLogical;
				rinfo.lTimePhysical = ioItem.lTimePhysical;
				break;

			case DMUS_FOURCC_LYRICSTRACKEVENTTEXT_CHUNK:
				{
					hr = ri.ReadText(&rinfo.wstrText);
					if (FAILED(hr))
                    {
#ifdef DBG
						if (hr == E_FAIL)
						{
							Trace(1, "Error: Unable to load lyric track: Problem reading 'lyrn' chunk.\n");
						}
#endif
                        delete pItem;
						return hr == E_FAIL ? DMUS_E_INVALID_LYRICSTRACK : hr;
                    }
				}
				break;

			default:
				break;
		}
	}
	hr = ri.hr();

	if (SUCCEEDED(hr) && (!fFoundEventHeader || !rinfo.wstrText))
    {
#ifdef DBG
		if (!fFoundEventHeader)
		{
			Trace(1, "Error: Unable to load lyric track: Chunk 'lyrh' not found.\n");
		}
		else
		{
			Trace(1, "Error: Unable to load lyric track: Chunk 'lyrn' not found.\n");
		}
#endif
		hr = DMUS_E_INVALID_LYRICSTRACK;
    }

	if (SUCCEEDED(hr))
    {
		m_EventList.AddHead(pItem);
    }
    else
    {
        delete pItem;
    }

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\lyrictrk.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CLyricTrack.
//

// This track type holds events that send DMUS_LYRIC_PMSG notifications at
// specific points during playback of a segment.

#pragma once

#include "trackhelp.h"
#include "tlist.h"
#include "smartref.h"
#include "dmusicf.h"

//////////////////////////////////////////////////////////////////////
// Types

// Items in list of events
struct LyricInfo
{
	LyricInfo() : dwFlags(0), dwTimingFlags(0), lTriggerTime(0), lTimePhysical(0) {}

	HRESULT Clone(const LyricInfo &o, MUSIC_TIME mtStart)
	{
		*this = o;
		lTriggerTime -= mtStart;
		lTimePhysical -= mtStart;
		return S_OK;
	}

	DWORD dwFlags;
	DWORD dwTimingFlags;
	MUSIC_TIME lTriggerTime; // Logical time
	MUSIC_TIME lTimePhysical;
	SmartRef::WString wstrText;
};

//////////////////////////////////////////////////////////////////////
// CLyricsTrack

class CLyricsTrack;
typedef CPlayingTrack<CLyricsTrack, LyricInfo> CLyricsTrackBase;

class CLyricsTrack
  : public CLyricsTrackBase
{
public:
	// When the lyric track plays one of its items, it sends a Lyric PMsg through its segment state.  If an invalidation occurs,
	// the PMsg is retracted by the performance.  Then the track is played again (with the FLUSH bit set).  The last pameter to
	// the CSegTriggerTrackBase is true, which instructs it to play the item a second time--to replace the retracted lyric.
	CLyricsTrack(HRESULT *pHr) : m_MemTrack(DMTRACK_LYRICS_TRACK), CLyricsTrackBase(&g_cComponent, CLSID_DirectMusicLyricsTrack, false, true) {}

protected:
	HRESULT PlayItem(
		const LyricInfo &item,
		statedata &state,
		IDirectMusicPerformance *pPerf,
		IDirectMusicSegmentState* pSegSt,
		DWORD dwVirtualID,
		MUSIC_TIME mtOffset,
		REFERENCE_TIME rtOffset,
		bool fClockTime);
	HRESULT LoadRiff(SmartRef::RiffIter &ri, IDirectMusicLoader *pIDMLoader);

private:
    CMemTrack       m_MemTrack;             // For debug memory tracking.
	HRESULT LoadLyric(SmartRef::RiffIter ri);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\marktrk.h ===
//MarkTrk.h : Declaration of the marker track

#ifndef __MARKTRK_H_
#define __MARKTRK_H_

#include "dmusicip.h"
#include "dmusicf.h"
#include "alist.h"

class CValidStartItem : public AListItem
{
public:
    CValidStartItem* GetNext(){ return (CValidStartItem*)AListItem::GetNext(); };
    DMUS_IO_VALID_START  m_ValidStart;
};
   
class CValidStartList : public AList
{
public:
    CValidStartItem* GetHead() {return (CValidStartItem*)AList::GetHead();};
    CValidStartItem* RemoveHead() {return (CValidStartItem*)AList::RemoveHead();};
    CValidStartItem* GetItem(LONG lIndex) { return (CValidStartItem*) AList::GetItem(lIndex);};
};

class CPlayMarkerItem : public AListItem
{
public:
    CPlayMarkerItem* GetNext(){ return (CPlayMarkerItem*)AListItem::GetNext(); };
    DMUS_IO_PLAY_MARKER  m_PlayMarker;
};
   
class CPlayMarkerList : public AList
{
public:
    CPlayMarkerItem* GetHead() {return (CPlayMarkerItem*)AList::GetHead();};
    CPlayMarkerItem* RemoveHead() {return (CPlayMarkerItem*)AList::RemoveHead();};
    CPlayMarkerItem* GetItem(LONG lIndex) { return (CPlayMarkerItem*) AList::GetItem(lIndex);};
};

/////////////////////////////////////////////////////////////////////////////
// CMarkerTrack
class CMarkerTrack : 
	public IPersistStream,
	public IDirectMusicTrack
{
public:
	CMarkerTrack();
	CMarkerTrack(CMarkerTrack *pTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd);
	~CMarkerTrack();

// member variables
protected:
    CValidStartList     m_ValidStartList;
    CPlayMarkerList     m_PlayMarkerList;
	long		        m_cRef;
	DWORD		        m_dwValidate; // used to validate state data.
	CRITICAL_SECTION	m_CrSec;
    BOOL                m_fCSInitialized;

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

// IDirectMusicTrack methods
    STDMETHODIMP IsParamSupported(REFGUID rguid);
    STDMETHODIMP Init(IDirectMusicSegment *pSegment);
    STDMETHODIMP InitPlay(IDirectMusicSegmentState *pSegmentState,
                IDirectMusicPerformance *pPerformance,
                void **ppStateData,
                DWORD dwTrackID,
                DWORD dwFlags);
    STDMETHODIMP EndPlay(void *pStateData);
    STDMETHODIMP Play(void *pStateData,MUSIC_TIME mtStart,
                MUSIC_TIME mtEnd,MUSIC_TIME mtOffset,
		        DWORD dwFlags,IDirectMusicPerformance* pPerf,
		        IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID);
    STDMETHODIMP GetParam(REFGUID rguid,MUSIC_TIME mtTime,MUSIC_TIME* pmtNext,void *pData);
    STDMETHODIMP SetParam(REFGUID rguid,MUSIC_TIME mtTime,void *pData);
    STDMETHODIMP AddNotificationType(REFGUID rguidNotification);
    STDMETHODIMP RemoveNotificationType(REFGUID rguidNotification);
    STDMETHODIMP Clone(MUSIC_TIME mtStart,MUSIC_TIME mtEnd,IDirectMusicTrack** ppTrack);

// IPersist functions
    STDMETHODIMP GetClassID( CLSID* pClsId );
// IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load( IStream* pIStream );
    STDMETHODIMP Save( IStream* pIStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER FAR* pcbSize );
protected:
	void Construct(void);
    void Clear();
    HRESULT LoadValidStartList( CRiffParser *pParser, long lChunkSize );
    HRESULT LoadPlayMarkerList( CRiffParser *pParser, long lChunkSize );
    CMemTrack       m_MemTrack;             // For debug memory tracking.
};

#endif //__MARKTRK_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\dowork.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// DoWork.cpp 

#include "pchime.h"

CBossMan g_BossMan;
static BOOL g_fUseThreads = TRUE;
static DWORD dwWorkerCount = 0;
static DWORD DoWorkThreadProc(void* pvhWndMain);
static void WaitForThreadEnd(HANDLE *phThread);
static HANDLE g_hDoWorkThread= NULL;
static HANDLE g_hDoWorkQuitEvent = NULL;
static HANDLE g_hDoWorkWakeupEvent = NULL;

void SetDoWorkThreadMode(DWORD dwOff)
{
    if(g_hDoWorkThread && dwOff) 
    {
        Trace(1,"Error: InitAudio() called with different thread flags from previous call. \n");
        dwOff = false;
    }
    g_fUseThreads = !dwOff;
}

/********************************************************************************
********************************************************************************/
static HRESULT StartDoWorkThreadProc(void)
{
    DWORD dwTemp = 0;
    g_hDoWorkQuitEvent = CreateEvent(NULL, TRUE, 0, 0);
    if (!g_hDoWorkQuitEvent)
    {
        return E_FAIL;        
    }
    g_hDoWorkWakeupEvent = CreateEvent(NULL, FALSE, 0, 0); // FALSE for second arg means automatically reset event after worker thread wakes up
    if (!g_hDoWorkWakeupEvent)
    {
        CloseHandle(g_hDoWorkQuitEvent);
        g_hDoWorkQuitEvent = NULL;
        return E_FAIL;        
    }
    g_hDoWorkThread =    CreateThread(NULL,20000,(LPTHREAD_START_ROUTINE)DoWorkThreadProc,(void*)dwTemp,0,NULL);
    if (!g_hDoWorkThread)
    {
        CloseHandle(g_hDoWorkQuitEvent);
        CloseHandle(g_hDoWorkWakeupEvent);
        g_hDoWorkQuitEvent = NULL;
        g_hDoWorkWakeupEvent = NULL;
        return E_FAIL;        
    }
    SetThreadPriority( g_hDoWorkThread, THREAD_PRIORITY_TIME_CRITICAL); 
    return S_OK;
};


/********************************************************************************
********************************************************************************/
static DWORD DoWorkThreadProc(void* pvhWndMain)
{
    DWORD dwQuantum = 30;
    HANDLE handles[2];
    handles[0] = g_hDoWorkQuitEvent;
    handles[1] = g_hDoWorkWakeupEvent;

    while (true){
        DWORD result = WaitForMultipleObjects(2, handles, FALSE, dwQuantum);
        if ( result == WAIT_OBJECT_0 ) {
            break; // asked to quit
        }
        else if ( result == WAIT_OBJECT_0 + 1 ) {
            // Asked to run quickly
            g_BossMan.DoWork(0);
        }
        else {
            // Normal quantum timeout
            g_BossMan.DoWork(dwQuantum);
        }
    }

	CloseHandle(g_hDoWorkQuitEvent);
	CloseHandle(g_hDoWorkWakeupEvent);

    g_hDoWorkThread= NULL;
    g_hDoWorkQuitEvent = NULL;
    g_hDoWorkWakeupEvent = NULL;

    return 0;
} 



/********************************************************************************
********************************************************************************/
static void WaitForThreadEnd(HANDLE *phThread)
{
    DWORD dwWaitResult = WAIT_TIMEOUT;

    if(*phThread)
    {
        dwWaitResult = WAIT_TIMEOUT;
        while(dwWaitResult != WAIT_OBJECT_0)
        {
            dwWaitResult = WaitForSingleObject(*phThread, 0);
            Sleep(100);
        }

        CloseHandle(*phThread);
        *phThread = NULL;
    }
}

CRITICAL_SECTION gDirectMusicDoWorkCriticalSection;
CRITICAL_SECTION gDirectMusicPinkSlipCriticalSection;

void InitializeDirectMusicDoWorkCriticalSection(){
    InitializeCriticalSection(&gDirectMusicDoWorkCriticalSection);
    InitializeCriticalSection(&gDirectMusicPinkSlipCriticalSection);
}

#ifdef DBG
void DirectMusicInitializedCheck();
#endif

void WINAPI DirectMusicDoWork(DWORD dwQuantum)

{
#ifdef DBG
    DirectMusicInitializedCheck();
#endif
    if (!g_fUseThreads)
    {
        g_BossMan.DoWork(dwQuantum);
    }
}

void CWorker::PinkSlip()
{
    ENTER_CRITICAL_SECTION(&gDirectMusicPinkSlipCriticalSection);
    m_bToldToDie = true;
    LEAVE_CRITICAL_SECTION(&gDirectMusicPinkSlipCriticalSection);
}

bool CWorker::HasBeenToldToDie()
{
    bool result;
    ENTER_CRITICAL_SECTION(&gDirectMusicPinkSlipCriticalSection);
    result = m_bToldToDie;
    LEAVE_CRITICAL_SECTION(&gDirectMusicPinkSlipCriticalSection);
    return result;
}

void CWorker::DoPinkSlip()
{
#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
    DMusicUnregisterPerformanceCounter(m_szName);
#endif
}

CBossMan::~CBossMan()
{
    if (m_pMasterClock)
    {
        m_pMasterClock->Release();
    }
}

void CBossMan::SetMasterClock(IReferenceClock *pClock)
{
    ENTER_CRITICAL_SECTION(&gDirectMusicDoWorkCriticalSection);
    if (m_pMasterClock)
    {
        m_pMasterClock->Release();
    }
    m_pMasterClock = pClock;
    if (m_pMasterClock)
    {
        m_pMasterClock->AddRef();
    }
    LEAVE_CRITICAL_SECTION(&gDirectMusicDoWorkCriticalSection);
}

CWorker * CBossMan::InstallWorker(PWORKER_ROUTINE pRoutine,void * pContext,DWORD dwOrder,char *pszName)
{
    ENTER_CRITICAL_SECTION(&gDirectMusicDoWorkCriticalSection);
    CWorker *pWorker = new CWorker;
    if (pWorker)
    {
        pWorker->m_bToldToDie = false;
        pWorker->m_pWorkRoutine = pRoutine;
        pWorker->m_pContext = pContext;
        pWorker->m_rtWakeUpTime = 0;
        pWorker->m_pBossMan = this;
        pWorker->m_dwOrder = dwOrder;
        CWorker *pScan = GetHead();
        for (;pScan;pScan = pScan->GetNext())
        {
            if (pScan->m_dwOrder > dwOrder)
            {
                break;
            }
        }
#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
        strcpy (pWorker->m_szName,pszName);
        DMusicRegisterPerformanceCounter(pWorker->m_szName,
                                      DMCOUNT_VALUE  | DMCOUNT_ASYNC32,
                                      &pWorker->m_dwElapsedTime );

#endif
        if (IsEmpty() && g_fUseThreads)
        {
            StartDoWorkThreadProc();
        }
        InsertBefore(pScan,pWorker);
    }
    LEAVE_CRITICAL_SECTION(&gDirectMusicDoWorkCriticalSection);
    return pWorker;
}

static void GetPentiumTime(REFERENCE_TIME *prtTime)

{
    _int64 cycNow;

    _asm
    {
        RDTSC                       // Get the time in EDX:EAX
        mov     dword ptr [cycNow], eax
        mov     dword ptr [cycNow+4], edx
    }

    cycNow *= 10;          // Gives greater clock granularity.
    cycNow /= 733; // m_dwDivisor;
    *prtTime = cycNow;
}

static REFERENCE_TIME rtWakeUp = 0;
static REFERENCE_TIME rtGoToSleep = 0;

void CBossMan::DoWork(DWORD dwQuantum)
{
//    GetPentiumTime(&rtWakeUp);
    ENTER_CRITICAL_SECTION(&gDirectMusicDoWorkCriticalSection);
    dwQuantum *= 10000;     // Convert from milliseconds to REFERENCE_TIME units.
    if (m_pMasterClock)
    {
        REFERENCE_TIME rtTime;
        m_pMasterClock->GetTime(&rtTime);   // Get current time.
        rtTime += (dwQuantum * 2);                // Find out when everything needs to be done by.
//        DWORD fAgain = TRUE;                 // This is used to track whether we need another pass through. 
//DbgPrint("%ld: ",(long) (rtTime / 10000));
        for (DWORD dwTries = 0; dwTries < 2; dwTries++)
        {
//            fAgain = FALSE;
            // Get rid of any workers who have been told to die
            {
                CWorker *pWorker = GetHead();
                while(pWorker)
                {
                    CWorker* pNext = pWorker->GetNext();
                    if(pWorker->HasBeenToldToDie())
                    {
                        pWorker->DoPinkSlip();
                        Remove(pWorker);

                        // If we're out of workers, we can shut down.
                        bool fStopThread = false;
                        if (IsEmpty() && g_fUseThreads)
                        {
                            fStopThread = true;
                        }
                        if (fStopThread)
                        {
                            SetEvent(g_hDoWorkQuitEvent);
                        }

                        delete pWorker;
                    }
                    pWorker = pNext;
                }
            }

            CWorker *pWorker = GetHead();
            for (;pWorker;pWorker = pWorker->GetNext())
            {
//                DbgPrint("%lx, %ld: \t",pWorker,(long)(pWorker->m_rtWakeUpTime / 10000));
//                if (pWorker->m_rtWakeUpTime <= rtTime)
                {
#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
                    REFERENCE_TIME rtStart;
                    GetPentiumTime(&rtStart);
                    pWorker->m_pWorkRoutine(pWorker->m_pContext,&pWorker->m_rtWakeUpTime);
                    REFERENCE_TIME rtEnd;
                    GetPentiumTime(&rtEnd);
                    pWorker->m_rtElapsedTime += (rtEnd - rtStart);
#else
                    pWorker->m_pWorkRoutine(pWorker->m_pContext,&pWorker->m_rtWakeUpTime);
#endif
//                    fAgain = TRUE;
                }
            }
        }
    }
//    REFERENCE_TIME rtLastSleep = rtGoToSleep;
#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
    GetPentiumTime(&rtWakeUp);
    if ((rtWakeUp - rtGoToSleep) > 10000 * 1000)
    {
//        DbgPrint("Interval: %ld: ",(long) ((rtWakeUp - rtGoToSleep) / 10000));
        CWorker *pWorker = GetHead();
        for (;pWorker;pWorker = pWorker->GetNext())
        {
            pWorker->m_dwElapsedTime = (DWORD) (pWorker->m_rtElapsedTime / 10000);
//            DbgPrint("%ld: %ld \t",pWorker->m_dwOrder,(long)(pWorker->m_rtElapsedTime / 100));
            pWorker->m_rtElapsedTime = 0;
        }
//        DbgPrint("\n");
        rtGoToSleep = rtWakeUp;
    }
#endif
    LEAVE_CRITICAL_SECTION(&gDirectMusicDoWorkCriticalSection);
//    DbgPrint("Slept: %ld, Worked: %ld, Percent: %ld\n",
//        (long) (rtWakeUp - rtLastSleep), (long) (rtGoToSleep - rtWakeUp),
//        (long) (100 * (rtGoToSleep - rtWakeUp) / (rtGoToSleep - rtLastSleep)));

}



void CBossMan::WakeUp(CWorker* pWorker){
    if(g_fUseThreads){
        // We could deadlock if we actually tried to run worker
        pWorker->WakeUp(); // Run me right away
        SetEvent(g_hDoWorkWakeupEvent);
    }
    else
    {
        // No worker thread, just call worker now.
        REFERENCE_TIME rt;
        pWorker->m_pWorkRoutine(pWorker->m_pContext,&rt);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\mutx.h ===
// Copyright (c) 1998 Microsoft Corporation
/* No longer used */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\midifile.h ===
//
// midifile.h
// 
// Copyright (c) 1997-1998 Microsoft Corporation
//
// Note: 
//

#ifndef MIDIFILE_H
#define MIDIFILE_H

HRESULT CreateSegmentFromMIDIStream(LPSTREAM pStream, 
									IDirectMusicSegment* pSegment);
#endif // #ifndef MIDIFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\marktrk.cpp ===
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// INITIALIZE_CRITICAL_SECTION. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)
// MarkTrk.cpp : Implementation of CMarkerTrack
#include "pchime.h"
/*
#include "dmime.h"
#include "..\shared\dmstrm.h"
#include "MarkTrk.h"
#include "dmusici.h"
#include "dmusicf.h"
#include "debug.h"
#include "..\shared\Validate.h"
#include "debug.h"
#define ASSERT	assert*/

/////////////////////////////////////////////////////////////////////////////
// CMarkerTrack

void CMarkerTrack::Construct()
{
    IncrementDLLCount();

	m_cRef = 0;
    m_fCSInitialized = FALSE;
	INITIALIZE_CRITICAL_SECTION(&m_CrSec);
    m_fCSInitialized = TRUE;
	m_dwValidate = 0;
}

CMarkerTrack::CMarkerTrack() : m_MemTrack(DMTRACK_MARKER_TRACK)
{
	Construct();
}

CMarkerTrack::CMarkerTrack(
		CMarkerTrack *pSourceTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd) 
        : m_MemTrack(DMTRACK_MARKER_TRACK)
{
	Construct();
    // Clone the valid start point list.
	CValidStartItem* pVScan = pSourceTrack->m_ValidStartList.GetHead();
	CValidStartItem* pVPrevious = NULL;
	for(; pVScan; pVScan = pVScan->GetNext())
	{
		if (pVScan->m_ValidStart.mtTime < mtStart)
		{
			pVPrevious = pVScan;
		}
		else if (pVScan->m_ValidStart.mtTime < mtEnd)
		{
			if (pVScan->m_ValidStart.mtTime == mtStart)
			{
				pVPrevious = NULL;
			}
			CValidStartItem* pNew = new CValidStartItem;
			if (pNew)
			{
				pNew->m_ValidStart.mtTime = pVScan->m_ValidStart.mtTime - mtStart;
				m_ValidStartList.AddHead(pNew); // instead of AddTail, which is n^2. We reverse below.
			}
		}
		else break;
	}
	m_ValidStartList.Reverse(); // Now, put list in order.
    // Then, install the time signature that precedes the clone.
	if (pVPrevious)
	{
		CValidStartItem* pNew = new CValidStartItem;
		if (pNew)
		{
			pNew->m_ValidStart.mtTime = 0;
			m_ValidStartList.AddHead(pNew);
		}
	}
    // Clone the play marker list. Gee, this is identical code...
	CPlayMarkerItem* pPScan = pSourceTrack->m_PlayMarkerList.GetHead();
	CPlayMarkerItem* pPPrevious = NULL;
	for(; pPScan; pPScan = pPScan->GetNext())
	{
		if (pPScan->m_PlayMarker.mtTime < mtStart)
		{
			pPPrevious = pPScan;
		}
		else if (pPScan->m_PlayMarker.mtTime < mtEnd)
		{
			if (pPScan->m_PlayMarker.mtTime == mtStart)
			{
				pPPrevious = NULL;
			}
			CPlayMarkerItem* pNew = new CPlayMarkerItem;
			if (pNew)
			{
				pNew->m_PlayMarker.mtTime = pPScan->m_PlayMarker.mtTime - mtStart;
				m_PlayMarkerList.AddHead(pNew); // instead of AddTail, which is n^2. We reverse below.
			}
		}
		else break;
	}
	m_PlayMarkerList.Reverse(); // Now, put list in order.
    // Then, install the time signature that precedes the clone.
	if (pPPrevious)
	{
		CPlayMarkerItem* pNew = new CPlayMarkerItem;
		if (pNew)
		{
			pNew->m_PlayMarker.mtTime = 0;
			m_PlayMarkerList.AddHead(pNew);
		}
	}
}

void CMarkerTrack::Clear()

{
	CValidStartItem* pStart;
	while( pStart = m_ValidStartList.RemoveHead() )
	{
		delete pStart;
	}
	CPlayMarkerItem* pPlay;
	while( pPlay = m_PlayMarkerList.RemoveHead() )
	{
		delete pPlay;
	}
}

CMarkerTrack::~CMarkerTrack()
{
    Clear();
    if (m_fCSInitialized)
    {
	    DELETE_CRITICAL_SECTION(&m_CrSec);
    }
    DecrementDLLCount();
}

STDMETHODIMP CMarkerTrack::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
	V_INAME(CMarkerTrack::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

   if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack)
    {
        *ppv = static_cast<IDirectMusicTrack*>(this);
    } else
	if (iid == IID_IPersistStream)
	{
        *ppv = static_cast<IPersistStream*>(this);
	} else
    {
        *ppv = NULL;
        Trace(4,"Warning: Request to query unknown interface on Marker Track\n");
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CMarkerTrack::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CMarkerTrack::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CMarkerTrack::GetClassID( CLSID* pClassID )
{
	V_INAME(CMarkerTrack::GetClassID);
	V_PTR_WRITE(pClassID, CLSID); 
	*pClassID = CLSID_DirectMusicMarkerTrack;
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPersistStream functions

HRESULT CMarkerTrack::IsDirty()
{
	return S_FALSE;
}

HRESULT CMarkerTrack::Load( IStream* pIStream )
{
	V_INAME(CMarkerTrack::Load);
	V_INTERFACE(pIStream);

    CRiffParser Parser(pIStream);
	ENTER_CRITICAL_SECTION(&m_CrSec);
	m_dwValidate++; // used to validate state data that's out there
    RIFFIO ckMain;

    HRESULT hr = S_OK;

    Parser.EnterList(&ckMain);  
    if (Parser.NextChunk(&hr) && (ckMain.fccType == DMUS_FOURCC_MARKERTRACK_LIST))
    {
        Clear();
	    RIFFIO ckNext;    // Descends into the children chunks.
        Parser.EnterList(&ckNext);
        while (Parser.NextChunk(&hr))
        {
		    switch(ckNext.ckid)
		    {
            case DMUS_FOURCC_VALIDSTART_CHUNK :
                hr = LoadValidStartList(&Parser,ckNext.cksize);
                break;
            case DMUS_FOURCC_PLAYMARKER_CHUNK :
                hr = LoadPlayMarkerList(&Parser,ckNext.cksize);
                break;
            }    
        }
        Parser.LeaveList();
    }
    else
    {
        Trace(1,"Error: Invalid Marker Track.\n");
        hr = DMUS_E_CHUNKNOTFOUND;
    }
    Parser.LeaveList();
	LEAVE_CRITICAL_SECTION(&m_CrSec);
	return hr;
}

HRESULT CMarkerTrack::LoadPlayMarkerList( CRiffParser *pParser, long lChunkSize )
{
	HRESULT hr;
	// copy contents of the stream into the list.
	DWORD dwSubSize;
	// read in the size of the data structures
	hr = pParser->Read( &dwSubSize, sizeof(DWORD));
    if (SUCCEEDED(hr))
    {
	    lChunkSize -= sizeof(DWORD);

	    DWORD dwRead, dwSeek;
	    if( dwSubSize > sizeof(DMUS_IO_PLAY_MARKER) )
	    {
		    dwRead = sizeof(DMUS_IO_PLAY_MARKER);
		    dwSeek = dwSubSize - dwRead;
	    }
	    else
	    {
		    dwRead = dwSubSize;
		    dwSeek = 0;
	    }
	    if( 0 == dwRead )
	    {
            Trace(1,"Error: Invalid Marker Track.\n");
		    hr = DMUS_E_CANNOTREAD;
	    }
        else
        {
	        while( lChunkSize > 0 )
	        {
                CPlayMarkerItem *pNew = new CPlayMarkerItem;
                if (pNew)
                {
		            if( FAILED( pParser->Read( &pNew->m_PlayMarker, dwRead)))
		            {
                        delete pNew;
			            hr = DMUS_E_CANNOTREAD;
			            break;
		            }
                    m_PlayMarkerList.AddHead(pNew); // Insert in reverse order for speed.
		            lChunkSize -= dwRead;
		            if( dwSeek )
		            {
			            if( FAILED( pParser->Skip(dwSeek)))
			            {
				            hr = DMUS_E_CANNOTSEEK;
				            break;
			            }
			            lChunkSize -= dwSeek;
		            }
		        }
	        }
            m_PlayMarkerList.Reverse(); // Reverse to put in time order.
        }
    }
	return hr;
}

HRESULT CMarkerTrack::LoadValidStartList( CRiffParser *pParser, long lChunkSize )
{
    HRESULT hr;
	// copy contents of the stream into the list.
	DWORD dwSubSize;
	// read in the size of the data structures
	hr = pParser->Read( &dwSubSize, sizeof(DWORD));
    if (SUCCEEDED(hr))
    {	
	    lChunkSize -= sizeof(DWORD);

	    DWORD dwRead, dwSeek;
	    if( dwSubSize > sizeof(DMUS_IO_VALID_START) )
	    {
		    dwRead = sizeof(DMUS_IO_VALID_START);
		    dwSeek = dwSubSize - dwRead;
	    }
	    else
	    {
		    dwRead = dwSubSize;
		    dwSeek = 0;
	    }
	    if( 0 == dwRead )
	    {
		    hr = DMUS_E_CANNOTREAD;
	    }
        else
        {
	        while( lChunkSize > 0 )
	        {
                CValidStartItem *pNew = new CValidStartItem;
                if (pNew)
                {
		            if( FAILED( pParser->Read( &pNew->m_ValidStart, dwRead)))
		            {
                        delete pNew;
			            hr = DMUS_E_CANNOTREAD;
			            break;
		            }
                    m_ValidStartList.AddHead(pNew); // Insert in reverse order for speed.
		            lChunkSize -= dwRead;
		            if( dwSeek )
		            {
			            if( FAILED( pParser->Skip(dwSeek)))
			            {
				            hr = DMUS_E_CANNOTSEEK;
				            break;
			            }
			            lChunkSize -= dwSeek;
		            }
		        }
	        }
            m_ValidStartList.Reverse(); // Reverse to put in time order.
        }
    }
	return hr;
}

HRESULT CMarkerTrack::Save( IStream* pIStream, BOOL fClearDirty )
{
	return E_NOTIMPL;
}

HRESULT CMarkerTrack::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
	return E_NOTIMPL;
}

// IDirectMusicTrack

HRESULT STDMETHODCALLTYPE CMarkerTrack::IsParamSupported( 
    /* [in] */ REFGUID rguid)
{
	V_INAME(CMarkerTrack::IsParamSupported);
	V_REFGUID(rguid);

    if ((rguid == GUID_Valid_Start_Time) || 
        (rguid == GUID_Play_Marker))
        return S_OK;
	return DMUS_E_TYPE_UNSUPPORTED;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack::Init
HRESULT CMarkerTrack::Init( 
    /* [in] */ IDirectMusicSegment *pSegment)
{
	return S_OK;
}

HRESULT CMarkerTrack::InitPlay( 
    /* [in] */ IDirectMusicSegmentState *pSegmentState,
    /* [in] */ IDirectMusicPerformance *pPerformance,
    /* [out] */ void **ppStateData,
    /* [in] */ DWORD dwTrackID,
    /* [in] */ DWORD dwFlags)
{
	return S_OK;
}

HRESULT CMarkerTrack::EndPlay( 
    /* [in] */ void *pStateData)
{
	return S_OK;
}

HRESULT CMarkerTrack::Play( 
    /* [in] */ void *pStateData,
    /* [in] */ MUSIC_TIME mtStart,
    /* [in] */ MUSIC_TIME mtEnd,
    /* [in] */ MUSIC_TIME mtOffset,
	DWORD dwFlags,
	IDirectMusicPerformance* pPerf,
	IDirectMusicSegmentState* pSegSt,
	DWORD dwVirtualID
	)
{
	return S_OK;
}

HRESULT CMarkerTrack::GetParam( 
	REFGUID rguid,
    MUSIC_TIME mtTime,
	MUSIC_TIME* pmtNext,
    void *pData)
{
	V_INAME(CMarkerTrack::GetParam);
	V_PTR_WRITE_OPT(pmtNext,MUSIC_TIME);
	V_REFGUID(rguid);

	HRESULT hr = DMUS_E_GET_UNSUPPORTED;
    ENTER_CRITICAL_SECTION(&m_CrSec);
	if( NULL == pData )
	{
		hr = E_POINTER;
	}
	else if( GUID_Valid_Start_Time == rguid )
	{
        DMUS_VALID_START_PARAM* pValidStartData = (DMUS_VALID_START_PARAM*)pData;
		CValidStartItem* pScan = m_ValidStartList.GetHead();
		for (; pScan; pScan = pScan->GetNext())
		{
			if (pScan->m_ValidStart.mtTime >= mtTime)
			{
        		pValidStartData->mtTime = pScan->m_ValidStart.mtTime - mtTime;
				break;
			}
		}
        if (pScan)
        {
 		    if (pmtNext)
		    {
		        if (pScan && (pScan = pScan->GetNext()))
		        {
                    *pmtNext = pScan->m_ValidStart.mtTime - mtTime;
			    }
                else
                {
        		    *pmtNext = 0;
                }
            }
		    hr = S_OK;
        }
        else
        {
            hr = DMUS_E_NOT_FOUND;
        }
    }
	else if( GUID_Play_Marker == rguid )
	{
        // This is a little different. The marker should be the one in existence
        // BEFORE, not after the requested time. 
        DMUS_PLAY_MARKER_PARAM* pPlayMarkerData = (DMUS_PLAY_MARKER_PARAM*)pData;
		CPlayMarkerItem* pScan = m_PlayMarkerList.GetHead();
        CPlayMarkerItem* pNext;
        // For fallback, treat it as if there were a marker at the start of the segment, but return S_FALSE.
        hr = S_FALSE;
        pPlayMarkerData->mtTime = -mtTime;
		for (; pScan; pScan = pNext)
		{
            pNext = pScan->GetNext();
            if (pScan->m_PlayMarker.mtTime <= mtTime) 
            {
                if (!pNext || (pNext->m_PlayMarker.mtTime > mtTime))
                {
        		    pPlayMarkerData->mtTime = pScan->m_PlayMarker.mtTime - mtTime;
                    if (pmtNext && pNext)
                    {
                        *pmtNext = pNext->m_PlayMarker.mtTime - mtTime;
                    }
                    hr = S_OK;
				    break;
                }
			}
            else
            {
                // Didn't find a marker before the requested time.
                if (pmtNext)
                {
                    *pmtNext = pScan->m_PlayMarker.mtTime - mtTime;
                }
                break;
            }
		}
    }
#ifdef DBG
    if (hr == DMUS_E_GET_UNSUPPORTED)
    {
        Trace(1,"Error: MarkerTrack does not support requested GetParam call.\n");
    }
#endif
    LEAVE_CRITICAL_SECTION(&m_CrSec);
	return hr;
}

HRESULT CMarkerTrack::SetParam( 
	REFGUID rguid,
    MUSIC_TIME mtTime,
    void *pData)
{
	return DMUS_E_SET_UNSUPPORTED;
}

HRESULT STDMETHODCALLTYPE CMarkerTrack::AddNotificationType(
	/* [in] */  REFGUID rguidNotification)
{
	return S_FALSE;
}

HRESULT STDMETHODCALLTYPE CMarkerTrack::RemoveNotificationType(
	/* [in] */  REFGUID rguidNotification)
{
	return S_FALSE;
}

HRESULT STDMETHODCALLTYPE CMarkerTrack::Clone(
	MUSIC_TIME mtStart,
	MUSIC_TIME mtEnd,
	IDirectMusicTrack** ppTrack)
{
	V_INAME(IDirectMusicTrack::Clone);
	V_PTRPTR_WRITE(ppTrack);

	if(mtStart < 0 )
	{
        Trace(1,"Error: Unable to clone marker track because the start point is less than 0.\n");
		return E_INVALIDARG;
	}
	if(mtStart > mtEnd)
	{
        Trace(1,"Error: Unable to clone marker track because the start point is greater than the length.\n");
		return E_INVALIDARG;
	}

	ENTER_CRITICAL_SECTION(&m_CrSec);
    CMarkerTrack *pDM;
    NEWCATCH(pDM,CMarkerTrack(this, mtStart, mtEnd))

	LEAVE_CRITICAL_SECTION(&m_CrSec);
    if (pDM == NULL) 
    {
        return E_OUTOFMEMORY;
    }

    return pDM->QueryInterface(IID_IDirectMusicTrack, (void**)ppTrack);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\dmsstobj.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// dmsstobj.cpp : Implementation of CSegState

#include "pchime.h"
/*
#include "dmime.h"
#include "urlmonhelper.h"
#include "DMSStObj.h"
#include "dmsegobj.h"
#include "song.h"
#include "dmgraph.h"
#include "dmperf.h"
#include "dmusici.h"
#include "..\shared\Validate.h"
#include "debug.h"
#include "dmscriptautguids.h"
#include "paramtrk.h"
#ifdef XBOX
#include "..\shared\xcreate.h"
#endif
#define ASSERT	assert*/

CSegState::CSegState() : m_MemTrack(DMTRACK_SEGMENT_STATE)
{
    INITIALIZE_CRITICAL_SECTION(&m_CriticalSection);
    IncrementDLLCount();
    m_fDelayShutDown = false;
    m_fInPlay = false;
	m_cRef = 1;
	m_dwPlayTrackFlags = DMUS_TRACKF_START | DMUS_TRACKF_SEEK;
    m_dwFirstTrackID = 0;
    m_dwLastTrackID = 0;
    m_mtEndTime = 0;
    m_mtAbortTime = 0;
	m_mtOffset = 0;
    m_rtOffset = 0;
    m_rtEndTime = 0;
	m_mtStartPoint = 0;
    m_rtStartPoint = 0;
	m_mtSeek = 0;
    m_rtSeek = 0;
    m_rtFirstLoopStart = 0;
    m_rtCurLoopStart = 0;
    m_rtCurLoopEnd = 0;
    m_mtFirstLoopStart = 0;
	m_mtLength = 0;
    m_rtLength = 0;
	m_mtLoopStart = 0;
	m_mtLoopEnd = 0;
    m_mtCurLoopStart = 0;
    m_mtCurLoopEnd = 0;
    m_rtLoopStart = 0;
    m_rtLoopEnd = 0;
    m_dwRepeatsLeft = 0;
	m_dwRepeats = 0;
    m_dwVersion = 0; // Init to 6.1 behavior.
    m_fPrepped = FALSE;
	m_fCanStop = TRUE;
	m_rtGivenStart = -1;
	m_mtResolvedStart = -1;
	m_mtLastPlayed = 0;
    m_rtLastPlayed = 0;
    m_rtLastVolChange = 0;
    m_rtLastPitchChange = 0;
	m_mtStopTime = 0;
	m_dwPlaySegFlags = 0;
    m_dwSegFlags = 0;
	m_fStartedPlay = FALSE;
	m_pUnkDispatch = NULL;
	m_pSegment = NULL;
	m_pPerformance = NULL;
    m_pAudioPath = NULL;
    m_pGraph = NULL;
    m_fSongMode = FALSE;
    m_pSongSegState = NULL;
	TraceI(2, "SegmentState %lx created\n", this );
}

CSegState::~CSegState()
{
	if (m_pUnkDispatch)
		m_pUnkDispatch->Release(); // free IDispatch implementation we may have borrowed
    if (m_pAudioPath) m_pAudioPath->Release();
    if (m_pGraph) m_pGraph->Release();
    if (m_pSongSegState) m_pSongSegState->Release();
    DecrementDLLCount();
    DELETE_CRITICAL_SECTION(&m_CriticalSection);
	TraceI(2, "SegmentState %lx destroyed with %ld releases outstanding\n", this, m_cRef );
}


STDMETHODIMP CSegState::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
	V_INAME(CSegState::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

    *ppv = NULL;

	if (iid == IID_IUnknown || iid == IID_IDirectMusicSegmentState || 
        iid == IID_IDirectMusicSegmentState8)
	{
		*ppv = static_cast<IDirectMusicSegmentState*>(this);
	} else
    if (iid == IID_CSegState)
	{
        *ppv = static_cast<CSegState*>(this);
	} else 
	if (iid == IID_IDirectMusicGraph)
	{
		*ppv = static_cast<IDirectMusicGraph*>(this);
	} else
	if (iid == IID_IDispatch)
	{
		// A helper scripting object implements IDispatch, which we expose from the
		// Performance object via COM aggregation.
		if (!m_pUnkDispatch)
		{
			// Create the helper object
			DirectMusicCreateInstance(
				CLSID_AutDirectMusicSegmentState,
				static_cast<IDirectMusicSegmentState*>(this),
				IID_IUnknown,
				reinterpret_cast<void**>(&m_pUnkDispatch));
		}
		if (m_pUnkDispatch)
		{
			return m_pUnkDispatch->QueryInterface(IID_IDispatch, ppv);
		}
	}

	if (*ppv == NULL)
    {
        Trace(4,"Warning: Request to query unknown interface on SegmentState object\n");
		return E_NOINTERFACE;
    }
	reinterpret_cast<IUnknown*>(this)->AddRef();
	return S_OK;
}

STDMETHODIMP_(ULONG) CSegState::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CSegState::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
		m_cRef = 100; // artificial reference count to prevent reentrency due to COM aggregation
        delete this;
        return 0;
    }

    return m_cRef;
}

extern long g_lNewTrackID; // Global track id source.

/*
  Private initialization function called by IDirectMusicSegment to set this
  state object's parent segment and performance. Addref's the parent segment
  but only retains a weak reference to the performance.
*/
HRESULT CSegState::PrivateInit(
	CSegment *pParentSegment,
	CPerformance *pPerformance)
{
	HRESULT hr = S_OK;
	ASSERT(pParentSegment);
	ASSERT(pPerformance);

   	InterlockedIncrement(&g_lNewTrackID);   // Every segstate gets a unique "track ID."
	m_dwTrackID = g_lNewTrackID;
    m_pSegment = pParentSegment;
    pParentSegment->AddRef();
    m_pPerformance = pPerformance; // retain only a weak reference
    m_rtLength = pParentSegment->m_rtLength;
    m_mtStartPoint = pParentSegment->m_mtStart;
    pParentSegment->MusicToReferenceTime(m_mtStartPoint, &m_rtStartPoint);
    m_mtLoopStart = pParentSegment->m_mtLoopStart;
    m_mtLoopEnd = pParentSegment->m_mtLoopEnd;
    m_dwSegFlags = pParentSegment->m_dwSegFlags;
    m_dwRepeats = pParentSegment->m_dwRepeats;
    m_rtLoopStart = pParentSegment->m_rtLoopStart;
    m_rtLoopEnd = pParentSegment->m_rtLoopEnd;
    if (m_rtLoopEnd)
    {
        // Don't allow a music time start point on a clock time looping segment.
        m_mtStartPoint = 0;
        // Don't allow the clock time loop length to be shorter than the length of the segment.
        if (m_rtLoopEnd > m_rtLength)
        {
            m_rtLength = m_rtLoopEnd;
        }
    }
    if (m_rtLength) // It's a ref time segment, so convert the length to music time
    {
        pParentSegment->ReferenceToMusicTime(m_rtLength, &m_mtLength);
    }
    else
    {
        m_mtLength = pParentSegment->m_mtLength;
    }
    // Don't allow repeat count to overflow and cause mathematical errors. 
    // Make it so it can't create a segment length larger than 0x3FFFFFFF, 
    // which would last for 8 days at 120 bpm!
    if (m_dwRepeats)
    {
        if ((m_mtLoopEnd == 0) && (m_mtLoopStart == 0))
        {
            // This happens when loading waves and MIDI files. 
            m_mtLoopEnd = m_mtLength;

            // zero rtLoopEnd so we dont try to do clock time looping on a wave
            m_rtLoopEnd = 0;
        }
        // Make sure the loop is real.
        if (m_rtLoopEnd > m_rtLoopStart)
        {
            // probably need some test code for now, but at least this enables clock time looping...
        }
        else if (m_mtLoopEnd > m_mtLoopStart)
        {
            // Take the maximum length, subtract out the full length, then divide by the loop size.
            DWORD dwMax = (0x3FFFFFFF - m_mtLength) / (m_mtLoopEnd - m_mtLoopStart);
            // dwMax is the maximum number of loops that can be done without overflowing the time.
            if (m_dwRepeats > dwMax)
            {
                m_dwRepeats = dwMax;
            }
        }
        else
        {
            m_dwRepeats = 0;
        }
    }
	m_dwRepeatsLeft = m_dwRepeats;
	if( m_mtLoopEnd == 0 )
	{
		m_mtLoopEnd = m_mtLength;
	}
	if( m_mtStartPoint >= m_mtLoopEnd )
	{
		// in this case, we're not doing any looping.
		m_mtLoopEnd = m_mtLoopStart = 0;
		m_dwRepeats = m_dwRepeatsLeft = 0;
	}
	return hr;
}

HRESULT CSegState::InitRoute(IDirectMusicAudioPath *pAudioPath)

{
    HRESULT hr = E_INVALIDARG;
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    if (pAudioPath)
    {
        if (m_dwVersion < 8) m_dwVersion = 8;
        m_pAudioPath = (CAudioPath *) pAudioPath;
        pAudioPath->AddRef();
        hr = S_OK;
    }
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    return hr;
}

/*
  This is called from the performance when it wants to release a
  segmentstate. This ensures that the segstate is
  no longer valid once outside the Performance.
*/
HRESULT CSegState::ShutDown(void)
{
    if (this)
    {
        if (m_fInPlay)
        {
            m_fDelayShutDown = true;
            return S_OK;
        }
        ENTER_CRITICAL_SECTION(&m_CriticalSection);
        m_TrackList.Clear();
        if( m_pSegment )
        {
            m_pSegment->Release();
            m_pSegment = NULL;
        }
        if( m_pAudioPath)
        {
            m_pAudioPath->Release();
            m_pAudioPath = NULL;
        }
        if (m_pSongSegState)
        {
            m_pSongSegState->Release();
            m_pSongSegState = NULL;
        }
        m_pPerformance = NULL;
        LEAVE_CRITICAL_SECTION(&m_CriticalSection);
        if( int nCount = Release() )
	    {
		    TraceI( 2, "Warning! SegmentState %lx still referenced %d times after Performance has released it.\n", this, nCount );
	    }

        return S_OK;
    }
    TraceI(0,"Attempting to delete a NULL SegmentState!\n");
    return E_FAIL;
}

/*
  Computes the length of the segmentstate using the internal length, loop points,
  and repeat count. This is the length of the segstate that will actually play,
  not necessarily the length if it played from the beginning.
*/
MUSIC_TIME CSegState::GetEndTime(MUSIC_TIME mtStartTime)
{
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    if (m_rtLength && m_pPerformance)
    {
        // If there is a reference time length, convert it into Music Time.
        // ALSO: convert m_mtLength and re-adjust loop points.
        MUSIC_TIME mtOffset = m_mtResolvedStart;
        REFERENCE_TIME rtOffset = 0;
        m_pPerformance->MusicToReferenceTime(mtOffset, &rtOffset);
        REFERENCE_TIME rtEndTime = (m_rtLength - m_rtStartPoint) + rtOffset; // Convert from length to actual end time.
        m_pPerformance->ReferenceToMusicTime(rtEndTime, &m_mtEndTime);
        MUSIC_TIME mtOldLength = m_mtLength;
        m_mtLength = m_mtEndTime - mtOffset + m_mtStartPoint;
        if (m_mtLoopEnd >= mtOldLength) // keep loop end equal to length
        {
            m_mtLoopEnd = m_mtLength;
        }
        if( m_mtLoopEnd > m_mtLength ) // shrink loop end to equal length
        {
            m_mtLoopEnd = m_mtLength;
            if( m_mtStartPoint >= m_mtLoopEnd )
            {
                // in this case, we're not doing any looping.
                m_mtLoopEnd = m_mtLoopStart = 0;
                m_dwRepeats = m_dwRepeatsLeft = 0;
            }
        }
    }
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
	LONGLONG length;
	length = m_mtLength + ((m_mtLoopEnd - m_mtLoopStart) * m_dwRepeats);
	length -= m_mtStartPoint;
    length += mtStartTime;
	if(length > 0x7fffffff) length = 0x7fffffff;
	return (MUSIC_TIME)length;
}

/*
  Converts an absolute Performance time to the index into the SegmentState, using
  the SegmentState's offset, internal length, loop points, and repeat count.
  Also returns the offset and repeat count for that time.
*/
HRESULT CSegState::ConvertToSegTime(
	MUSIC_TIME* pmtTime, MUSIC_TIME* pmtOffset, DWORD* pdwRepeat )
{
	ASSERT( pmtTime );
	ASSERT( pmtOffset );
	ASSERT( pdwRepeat );

	MUSIC_TIME mtPos = *pmtTime - m_mtResolvedStart + m_mtStartPoint;
	MUSIC_TIME mtLoopLength = m_mtLoopEnd - m_mtLoopStart;
	DWORD dwRepeat = 0;
	DWORD mtOffset = m_mtResolvedStart - m_mtStartPoint;

	while( mtPos >= m_mtLoopEnd )
	{
		if( dwRepeat >= m_dwRepeats ) break;
		mtPos -= mtLoopLength;
		mtOffset += mtLoopLength;
		dwRepeat++;
	}
	*pmtTime = mtPos;
	*pmtOffset = mtOffset;
	*pdwRepeat = dwRepeat;
	if( (mtPos >= 0) && (mtPos < m_mtLength) )
	{
		return S_OK;	// time is in range of the Segment
	}
	else
	{
		return S_FALSE; // time is out of range of the Segment
	}
}

void CSegState::GenerateNotification( DWORD dwNotification, MUSIC_TIME mtTime )
{
	GUID guid;
	HRESULT hr;
	guid = GUID_NOTIFICATION_SEGMENT;

	hr = m_pSegment->CheckNotification( guid );

	if( S_FALSE != hr )
    {
	    DMUS_NOTIFICATION_PMSG* pEvent = NULL;
	    if( SUCCEEDED( m_pPerformance->AllocPMsg( sizeof(DMUS_NOTIFICATION_PMSG), 
		    (DMUS_PMSG**)&pEvent )))
	    {
		    pEvent->dwField1 = 0;
		    pEvent->dwField2 = 0;
		    pEvent->guidNotificationType = GUID_NOTIFICATION_SEGMENT;
		    pEvent->dwType = DMUS_PMSGT_NOTIFICATION;
		    pEvent->mtTime = mtTime;
		    pEvent->dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_TOOL_ATTIME;
            pEvent->dwPChannel = 0;
		    pEvent->dwNotificationOption = dwNotification;
		    pEvent->dwGroupID = 0xffffffff;
		    pEvent->punkUser = (IUnknown*)(IDirectMusicSegmentState*)this;
		    AddRef();
		    StampPMsg((DMUS_PMSG*)pEvent);
			if(FAILED(m_pPerformance->SendPMsg( (DMUS_PMSG*)pEvent )))
			{
				m_pPerformance->FreePMsg((DMUS_PMSG*) pEvent );
			}
		}
	}
}

/* 
  Called to send the tools in the tool graph a dirty pmsg so they update any
  cached GetParam() info.
*/
void CSegState::SendDirtyPMsg( MUSIC_TIME mtTime )
{
	DMUS_PMSG* pEvent = NULL;
    if (m_pPerformance)
    {
	    if( SUCCEEDED( m_pPerformance->AllocPMsg( sizeof(DMUS_PMSG), 
		    (DMUS_PMSG**)&pEvent )))
	    {
		    pEvent->mtTime = mtTime;
		    pEvent->dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_TOOL_IMMEDIATE;
		    pEvent->dwGroupID = 0xffffffff;
		    pEvent->dwType = DMUS_PMSGT_DIRTY;
		    StampPMsg((DMUS_PMSG*)pEvent);
		    if( FAILED( m_pPerformance->SendPMsg( pEvent )))
		    {
			    m_pPerformance->FreePMsg( pEvent );
		    }
	    }
    }
}

/*
  Called when the SegState is stopped prematurely, so we can send a SEGABORT
  Notification.
  Also, flushes all events that were sent after the stop time. 
*/
HRESULT CSegState::AbortPlay( MUSIC_TIME mtTime, BOOL fLeaveNotesOn )
{
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    if (m_pPerformance)
    {
        if( m_mtLastPlayed > mtTime )
        {
            // If we've played past the abort time, we need to flush messages. 
            // Note that if we were aborted by playing another segment that had
            // the DMUS_SEGF_NOINVALIDATE flag set, don't truncate notes
            // that are currently on.
            CTrack*	pTrack;
	        pTrack = m_TrackList.GetHead();
	        while( pTrack )
	        {
		        m_pPerformance->FlushVirtualTrack( pTrack->m_dwVirtualID, mtTime, FLUSH_LEAVE_ON );
		        pTrack = pTrack->GetNext();
	        }
            m_mtLastPlayed = mtTime;
        }
        // Always fill in the updated value for lastplayed so the ShutDown or Done queue will flush this
        // at the right time.
        m_pPerformance->MusicToReferenceTime(mtTime,&m_rtLastPlayed);
    }
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    // Always generate an abort for a segment that has not started playing yet. 
    if (m_fStartedPlay && (m_mtEndTime <= mtTime))
    {
        return S_FALSE; // Abort was too late to matter.
    }
    if (m_mtAbortTime)  // Previous abort.
    {
        if (m_mtAbortTime <= mtTime) // Is this earlier?
        {
            return S_FALSE;     // No, don't send abort message.
        }
    }
    m_mtAbortTime = mtTime;
    // Find all the parameter control tracks and invalidate any parameter envelopes
    // that need invalidation.
	CTrack* pTrack = m_TrackList.GetHead();
	while( pTrack )
	{
        if (pTrack->m_guidClassID == CLSID_DirectMusicParamControlTrack)
        {
            CParamControlTrack* pParamTrack = NULL;
            if (pTrack->m_pTrack &&
                SUCCEEDED(pTrack->m_pTrack->QueryInterface(IID_CParamControlTrack, (void**)&pParamTrack)))
            {
                pParamTrack->OnSegmentEnd(m_rtLastPlayed, pTrack->m_pTrackState);
                pParamTrack->Release();
            }
        }
		pTrack = pTrack->GetNext();
	}
    GenerateNotification( DMUS_NOTIFICATION_SEGABORT, mtTime );
    // if this is a primary or controlling segment, send a DMUS_PMSGT_DIRTY message
    if( !(m_dwPlaySegFlags & DMUS_SEGF_SECONDARY) || (m_dwPlaySegFlags & DMUS_SEGF_CONTROL) )
    {
        TraceI(4, "Send Dirty PMsg [4] %d (%d)\n", m_mtSeek, m_mtOffset + m_mtSeek);
        SendDirtyPMsg( m_mtOffset + m_mtSeek );
    }
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IDirectMusicSegmentState

//////////////////////////////////////////////////////////////////////
// IDirectMusicSegmentState::GetRepeats
/*
@method HRESULT | IDirectMusicSegmentState | GetRepeats |
Returns the number of times the SegmentState is set to repeat. A value of zero indicates
to play through only once (no repeats.) This value remains constant throughout the life
of the SegmentState.

@rvalue E_POINTER | if <p pdwRepeats> is NULL or invalid.
@rvalue S_OK | Success.
*/
HRESULT STDMETHODCALLTYPE CSegState::GetRepeats( 
    DWORD *pdwRepeats)	// @parm Returns the repeat count.
{
	V_INAME(IDirectMusicSegmentState::GetRepeats);
	V_PTR_WRITE(pdwRepeats,DWORD);

	*pdwRepeats = m_dwRepeats;
	return S_OK;
}

///////////////////////////////////////////////////////////////////////
// IDirectMusicSegmentState::GetSegment
/*
@method HRESULT | IDirectMusicSegmentState | GetSegment |
Returns a pointer to the Segment that owns this SegmentState.

@rvalue E_POINTER | if ppSegment is NULL or invalid.
@rvalue S_OK | Success.
*/
HRESULT STDMETHODCALLTYPE CSegState::GetSegment( 
    IDirectMusicSegment **ppSegment)	// @parm The Segment interface pointer to this
										// SegmentState. Call Release() on this pointer when
										// through.
{
	V_INAME(IDirectMusicSegmentState::GetSegment);
	V_PTRPTR_WRITE(ppSegment);

	*ppSegment = (IDirectMusicSegment *) m_pSegment;
	if( m_pSegment )
	{
		m_pSegment->AddRef();
	}
	else
	{
        Trace(1,"Error: Segmentstate doesn't have an associated segment.\n");
		return DMUS_E_NOT_FOUND;
	}
	return S_OK;
}

///////////////////////////////////////////////////////////////////////
// IDirectMusicSegmentState::Play
/*
method (INTERNAL) HRESULT | IDirectMusicSegmentState | Play |
<om IDirectMusicSegmentState.Play> is called regularly by the Performance object, 
usually every 200 ms or so, at a time ahead of playback that is set by 
<om IDirectMusicPerformance.SetPerformTime>
.
parm MUSIC_TIME | mtAmount |
	[in] The length of time to play, starting at the current Seek time.
	The SegmentState updates its Seek time to be the current Seek time
	plus mtAmount. Therefore, the SegmentState should play from the current
	Seek time to Seek time plus mtAmount, not including the last clock.

comm 
Play calls each Track's Play method in priority order, instructing the Track to 
create events from the current Seek time up to, but not including the current Seek
time plus <p mtAmount.>
Since the Segment started at the point designated by m_mtOffset (set by
<im IDirectMusicSegmentState.SetOffset>
m_mtOffset sets the starting offset to add to the times of all events.

rvalue E_INVALIDARG | mtAmount <= 0
rvalue S_OK | Success.
*/

HRESULT STDMETHODCALLTYPE CSegState::Play( 
    /* [in] */ MUSIC_TIME mtAmount, MUSIC_TIME* pmtPlayed )
{
    return E_FAIL;      // We don't want to support this publicly!
}

HRESULT CSegState::Play( MUSIC_TIME mtAmount )
{
    CTrack* pCTrack;
    MUSIC_TIME mtMyAmount = mtAmount;
    REFERENCE_TIME rtMyAmount;
    HRESULT hr = DMUS_S_END;
    BOOL fUseClockTime = FALSE;

    if( mtAmount <= 0 )
        return E_INVALIDARG;

    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    if (m_fInPlay)
    {
        LEAVE_CRITICAL_SECTION(&m_CriticalSection);
        return S_OK;
    }
    m_fInPlay = true;
    m_pPerformance->m_pGetParamSegmentState = (IDirectMusicSegmentState *) this;
    // if this is the first call to play, we need to send a SegStart notification.
    // We also need to check to see if we are supposed to start at the beginning,
    // or at an offset.
    if( m_dwPlayTrackFlags & DMUS_TRACKF_START )
    {
        // send a segment start notification
        GenerateNotification( DMUS_NOTIFICATION_SEGSTART, m_mtOffset );
        // if this is a primary or controlling segment, send a DMUS_PMSGT_DIRTY message
        if( !(m_dwPlaySegFlags & DMUS_SEGF_SECONDARY) || (m_dwPlaySegFlags & DMUS_SEGF_CONTROL) )
        {
            TraceI(4, "Send Dirty PMsg [1] %d (%d)\n", m_mtSeek, m_mtOffset + m_mtSeek);
            SendDirtyPMsg( m_mtOffset + m_mtSeek );
        }
        // set the current seek to the start point
        m_mtSeek = m_mtStartPoint;
        // convert current offset to ref time
        m_pPerformance->MusicToReferenceTime(m_mtOffset,&m_rtOffset);
        m_rtEndTime = m_rtOffset + m_rtLength;
        // subtract the start points from the offsets
        m_mtOffset -= m_mtStartPoint;
        m_rtOffset -= m_rtStartPoint;
        m_rtEndTime -= m_rtStartPoint;
        m_rtSeek = m_rtLastPlayed - m_rtOffset;

        m_rtFirstLoopStart = 0;
    }
    if (m_rtLength)
    {
        // If there is a reference time length, convert it into mtTime.
        // Because there's always the danger of a tempo change, we do this every
        // time. It doesn't require the tight precision that song time
        // requires, so that's okay.
        // ALSO: convert m_mtLength and re-adjust loop points. (RSW)
        m_pPerformance->ReferenceToMusicTime(m_rtEndTime, &m_mtEndTime);
        MUSIC_TIME mtOldLength = m_mtLength;
        m_mtLength = m_mtEndTime - m_mtOffset; 

        if (m_mtLoopEnd >= mtOldLength) // keep loop end equal to length
        {
            m_mtLoopEnd = m_mtLength;
        }
        if( m_mtLoopEnd > m_mtLength )
        {
            m_mtLoopEnd = m_mtLength;
            if( m_mtStartPoint >= m_mtLoopEnd )
            {
                // in this case, we're not doing any looping.
                m_mtLoopEnd = m_mtLoopStart = 0;
                m_dwRepeats = m_dwRepeatsLeft = 0;
            }
        }
        
        //m_mtEndTime += (m_mtLoopEnd - m_mtLoopStart) * m_dwRepeats;

        fUseClockTime = TRUE;
    }
    // if we need to do a loop or the end is near, restrict mtMyAmount
//  ASSERT( m_mtLength ); // length is 0, this segment won't do anything
    if( m_dwRepeatsLeft )
    {
        if (m_rtLoopEnd)    // Is this a clock time looped segment?
        {
            REFERENCE_TIME rtCalcAmount;
            m_pPerformance->MusicToReferenceTime(m_mtLastPlayed + mtMyAmount,&rtCalcAmount);
            rtCalcAmount -= m_rtLastPlayed;
            if (rtCalcAmount > m_rtLoopEnd - m_rtSeek)
            {
                rtCalcAmount = m_rtLoopEnd - m_rtSeek;
                m_pPerformance->ReferenceToMusicTime(m_rtLastPlayed + rtCalcAmount,&mtMyAmount);
                mtMyAmount -= m_mtLastPlayed;
                if (!mtMyAmount && (m_rtLoopEnd > m_rtSeek))
                {
                    mtMyAmount = 1;
                }
            }
        }
        else if( mtMyAmount > m_mtLoopEnd - m_mtSeek )
        {
            mtMyAmount = m_mtLoopEnd - m_mtSeek;
        }
    }
    else 
    {
        if (fUseClockTime)
        {
            if (mtMyAmount > (m_mtEndTime - (m_mtOffset + m_mtSeek)))
            {
                mtMyAmount = m_mtEndTime - (m_mtOffset + m_mtSeek);
            }
        }
        else if( mtMyAmount > m_mtLength - m_mtSeek )
        {
            mtMyAmount = m_mtLength - m_mtSeek;
        }
    }
    if (mtMyAmount <= 0)
    {
        hr = DMUS_S_END;
    }
    else
    {
        // check the primary segment queue for a segment that might begin 
        // before mtMyAmount is up
        MUSIC_TIME mtNextPri;
        if (S_OK == m_pPerformance->GetPriSegTime( m_mtOffset + m_mtSeek, &mtNextPri ))
        {
            if( m_mtOffset + m_mtSeek + mtMyAmount > mtNextPri )
            {
                mtMyAmount = mtNextPri - m_mtOffset - m_mtSeek;
            }
        }
        TraceI(3, "SegState %ld Play from %ld to %ld at %ld = %ld - %ld\n", this, m_mtSeek, m_mtSeek + mtMyAmount, m_mtOffset, m_mtSeek + m_mtOffset, m_mtSeek + mtMyAmount + m_mtOffset );
        
        // find out if there's a control segment interrupting this period of time.
        MUSIC_TIME mtControlSeg;
        if( S_OK == m_pPerformance->GetControlSegTime( m_mtOffset + m_mtSeek, &mtControlSeg ))
        {
            if( m_mtOffset + m_mtSeek == mtControlSeg )
            {
                // we're at the beginning of a new control seg, so tell the tracks
                m_dwPlayTrackFlags |= DMUS_TRACKF_DIRTY;
            }
            else if( m_mtOffset + m_mtSeek + mtMyAmount > mtControlSeg )
            {
                mtMyAmount = mtControlSeg - m_mtOffset - m_mtSeek;
            }
        }
        // Now that mtMyAmount is calculated for how far to play in music time,
        // create the equivalent value in reference time.
        m_pPerformance->MusicToReferenceTime(m_mtLastPlayed + mtMyAmount,&rtMyAmount);
        rtMyAmount -= m_rtLastPlayed;
        pCTrack = m_TrackList.GetHead();
        while( pCTrack )
        {
            if( mtMyAmount )
            {
                m_pPerformance->m_fInTrackPlay = TRUE; // This causes the Pmsgs to be stamped with PRIV_FLAG_TRACK.
                ASSERT( pCTrack->m_pTrack );
                // If either notification or play are enabled, we need to call the play method and set the behavior
                // with the DMUS_TRACKF_NOTIFY_OFF and DMUS_TRACKF_PLAY_OFF flags. 
                if (pCTrack->m_dwFlags & (DMUS_TRACKCONFIG_PLAY_ENABLED | DMUS_TRACKCONFIG_NOTIFICATION_ENABLED))
                {
                    DWORD dwAdditionalFlags = 0;
                    if (!(pCTrack->m_dwFlags & DMUS_TRACKCONFIG_NOTIFICATION_ENABLED))
                    {
                        dwAdditionalFlags = DMUS_TRACKF_NOTIFY_OFF;
                    }
                    if (!(pCTrack->m_dwFlags & DMUS_TRACKCONFIG_PLAY_ENABLED))
                    {
                        dwAdditionalFlags |= DMUS_TRACKF_PLAY_OFF;
                    }
                    // If the track was authored to generate new data on start or loop, let it know.
                    if ( ((m_dwPlayTrackFlags & DMUS_TRACKF_START) && (pCTrack->m_dwFlags & DMUS_TRACKCONFIG_PLAY_COMPOSE)) ||
                        ((m_dwPlayTrackFlags & DMUS_TRACKF_LOOP) && (pCTrack->m_dwFlags & DMUS_TRACKCONFIG_LOOP_COMPOSE)) )
                    {
                        dwAdditionalFlags |= DMUS_TRACKF_RECOMPOSE;
                    }
                    if (pCTrack->m_dwInternalFlags & CONTROL_PLAY_REFRESH)
                    {
                        dwAdditionalFlags |= DMUS_TRACKF_START;
                        pCTrack->m_dwInternalFlags &= ~CONTROL_PLAY_REFRESH;
                    }
                    // Let performance know what the priority should be in ensuing GetParam() calls from the track.
                    m_pPerformance->m_dwGetParamFlags = pCTrack->m_dwFlags;
                    // If track has DX8 interface, use it.
                    if (pCTrack->m_pTrack8)
                    {
                        //  The track can call GetParam on the segment which locks the segment so
                        //  we have to lock the segment before calling PlayEx or we'll deadlock
                        //  with a thread that's calling PlayOneSegment which locks the segment
                        //  before playing the tracks.
                        if (m_pSegment) 
                        {
                            ENTER_CRITICAL_SECTION(&m_pSegment->m_CriticalSection);
                        }
                        // If track plays in clock time, set time variables appropriately.
                        if (pCTrack->m_dwFlags & DMUS_TRACKCONFIG_PLAY_CLOCKTIME)
                        {
                            if( ( S_OK == (pCTrack->m_pTrack8->PlayEx(pCTrack->m_pTrackState,
                                m_rtSeek,m_rtSeek + rtMyAmount, m_rtOffset, m_dwPlayTrackFlags | dwAdditionalFlags | DMUS_TRACKF_CLOCK,
                                m_pPerformance, this, pCTrack->m_dwVirtualID ))))
                            {
                                hr = S_OK; // if even one track isn't done playing,
                                // keep going
                            }
                            else 
                            {
                                pCTrack->m_bDone = TRUE;
                            }
                        }
                        else
                        {
                            if( ( S_OK == (pCTrack->m_pTrack8->PlayEx(pCTrack->m_pTrackState,
                                m_mtSeek,m_mtSeek + mtMyAmount, m_mtOffset, m_dwPlayTrackFlags | dwAdditionalFlags,
                                m_pPerformance, this, pCTrack->m_dwVirtualID ))))
                            {
                                hr = S_OK; // if even one track isn't done playing,
                                // keep going
                            }
                            else 
                            {
                                pCTrack->m_bDone = TRUE;
                            }
                        }

                        if (m_pSegment) 
                        {
                            LEAVE_CRITICAL_SECTION(&m_pSegment->m_CriticalSection);
                        }
                    }
                    else
                    {
                        if( ( S_OK == ( pCTrack->m_pTrack->Play( pCTrack->m_pTrackState, 
                            m_mtSeek, m_mtSeek + mtMyAmount, m_mtOffset, m_dwPlayTrackFlags | dwAdditionalFlags,
                            m_pPerformance, this, pCTrack->m_dwVirtualID ))))
                        {
                            hr = S_OK; // if even one track isn't done playing,
                            // keep going
                        }
                        else
                        {
                            pCTrack->m_bDone = TRUE;
                        }
                    }
                }
                m_pPerformance->m_fInTrackPlay = FALSE;
            }
            pCTrack = pCTrack->GetNext();
            if( pCTrack == NULL )
            {
                // none of the play flags are persistent
                m_dwPlayTrackFlags = 0;
                m_mtLastPlayed += mtMyAmount;   // increment play pointer
                m_rtLastPlayed += rtMyAmount;   // same in ref time
                m_mtSeek += mtMyAmount;         // increment seek pointer
                m_rtSeek += rtMyAmount;
                hr = S_OK;

                // If we're looping....
                // And if this is the first repeat
                if(m_dwRepeats > 0 && m_dwRepeats == m_dwRepeatsLeft)
                {
                    if (m_rtLoopEnd)
                    {
                        // If we're playing the loop start, remember it's musictime value
                        if(m_rtSeek >= m_rtLoopStart && m_rtFirstLoopStart == 0)
                        {
                            m_rtFirstLoopStart = m_rtLoopStart + m_rtOffset;
                            m_pPerformance->ReferenceToMusicTime(m_rtFirstLoopStart,&m_mtFirstLoopStart);
                            m_mtCurLoopStart = m_mtFirstLoopStart;
                        }
                    }
                    else
                    {
                        // If we're playing the loop start, remember it's reftime value
                        if(m_mtSeek >= m_mtLoopStart && m_rtFirstLoopStart == 0)
                        {
                            m_mtFirstLoopStart = m_mtLoopStart + m_mtOffset;
                            // Huh? Why are we including the startpoint in this calculation? I talked with Bob and it's
                            // to work around a problem with a tempo map in a clock time segment. 
                            // But, even this solution can cause flawed results. 
                            // Truth is, you should never have a tempo map in a clock time segment, but we'll need to 
                            // keep this for regression reasons. 
                            m_pPerformance->MusicToReferenceTime(m_mtLoopStart + m_mtOffset + m_mtStartPoint, &m_rtFirstLoopStart);
                            m_rtFirstLoopStart -= m_rtStartPoint;
                            m_rtCurLoopStart = m_rtFirstLoopStart;
                        }
                    }
                }

                // take into account repeats if necessary
                if(( m_mtSeek >= m_mtLoopEnd ) || (m_rtLoopEnd && (m_rtSeek >= m_rtLoopEnd)))
                {
                    // Remember the current loop end
                    if (m_rtLoopEnd)
                    {
                        m_pPerformance->ReferenceToMusicTime(m_rtLoopEnd + m_rtOffset,&m_mtCurLoopEnd);
                    }
                    else
                    {
                        // Again, we have this weirdness with startpoint that should not be...
                        m_pPerformance->MusicToReferenceTime(m_mtLoopEnd + m_mtOffset + m_mtStartPoint, &m_rtCurLoopEnd);
                        m_rtCurLoopEnd -= m_rtStartPoint;
                    }

                    if(m_dwRepeatsLeft)
                    {
                        m_dwPlayTrackFlags |= DMUS_TRACKF_LOOP | DMUS_TRACKF_SEEK;
                        m_dwRepeatsLeft--;
                        pCTrack = m_TrackList.GetHead();
                        while( pCTrack )
                        {
                            pCTrack->m_bDone = FALSE;
                            pCTrack = pCTrack->GetNext();
                        }
                        
                        if (m_rtLoopEnd)
                        {
                            m_rtSeek = m_rtLoopStart;
                            m_rtOffset += ( m_rtLoopEnd - m_rtLoopStart);
                        
                            m_mtOffset += (m_mtCurLoopEnd - m_mtCurLoopStart);
                            m_mtFirstLoopStart += (m_mtCurLoopEnd - m_mtCurLoopStart);
                            m_mtSeek = m_mtFirstLoopStart - m_mtOffset;

                            m_mtEndTime += (m_mtCurLoopEnd - m_mtCurLoopStart);
                   
                            m_mtCurLoopStart = m_mtCurLoopEnd;
                        }
                        else
                        {    
                            m_mtSeek = m_mtLoopStart;
                            m_mtOffset += ( m_mtLoopEnd - m_mtLoopStart);
                        
                        
                            m_rtOffset += (m_rtCurLoopEnd - m_rtCurLoopStart);
                            m_rtFirstLoopStart += (m_rtCurLoopEnd - m_rtCurLoopStart);
                            m_rtSeek = m_rtFirstLoopStart - m_rtOffset;

                            m_rtEndTime += (m_rtCurLoopEnd - m_rtCurLoopStart);
                   
                            m_rtCurLoopStart = m_rtCurLoopEnd;
                        }


                        if( mtMyAmount < mtAmount )
                        {
                            pCTrack = m_TrackList.GetHead(); // cause outer while loop to start over
                            mtMyAmount = mtAmount - mtMyAmount;
                            mtAmount = mtMyAmount;
                            // if we need to do a loop or the end is near, restrict mtMyAmount
                            if( m_dwRepeatsLeft )
                            {
                                if (m_rtLoopEnd)    // Is this a clock time looped segment?
                                {
                                    // If so, convert from clock time to music time.
                                    REFERENCE_TIME rtCalcAmount;
                                    m_pPerformance->MusicToReferenceTime(m_mtLastPlayed + mtMyAmount,&rtCalcAmount);
                                    rtCalcAmount -= m_rtLastPlayed;
                                    if (rtCalcAmount > m_rtLoopEnd - m_rtSeek)
                                    {
                                        rtCalcAmount = m_rtLoopEnd - m_rtSeek;
                                        m_pPerformance->ReferenceToMusicTime(m_rtLastPlayed + rtCalcAmount,&mtMyAmount);
                                        mtMyAmount -= m_mtLastPlayed;
                                        // It's possible to have a rounding error because reference time is so mcuh
                                        // higher than music time. If so, a value of 0 is not appropriate if loopend
                                        // is greater than seek, so fudge by providing one clock to get us there.
                                        if (!mtMyAmount && (m_rtLoopEnd > m_rtSeek))
                                        {
                                            mtMyAmount = 1;
                                        }
                                    }
                                }
                                else if( mtMyAmount > m_mtLoopEnd - m_mtSeek )
                                {
                                    mtMyAmount = m_mtLoopEnd - m_mtSeek;
                                }
                            }
                            else 
                            {
                                if (fUseClockTime)
                                {
                                    if (mtMyAmount > (m_mtEndTime - (m_mtOffset + m_mtSeek)))
                                    {
                                        mtMyAmount = m_mtEndTime - (m_mtOffset + m_mtSeek);
                                    }
                                }
                                else if( mtMyAmount > m_mtLength - m_mtSeek )
                                {
                                    mtMyAmount = m_mtLength - m_mtSeek;
                                }
                            }
                        }
                        // send a segment looped notification
                        GenerateNotification( DMUS_NOTIFICATION_SEGLOOP, m_mtOffset + m_mtSeek );
                        // find out if there's a control segment interrupting this period of time
                        if( S_OK == m_pPerformance->GetControlSegTime( m_mtOffset + m_mtSeek, &mtControlSeg ))
                        {
                            if( m_mtOffset + m_mtSeek == mtControlSeg ) 
                            {
                                // we're at the beginning of a new control seg, so tell the tracks
                                m_dwPlayTrackFlags |= DMUS_TRACKF_DIRTY; 
                            }
                            else if( m_mtOffset + m_mtSeek + mtMyAmount < mtControlSeg )
                            {
                                mtMyAmount = mtControlSeg - m_mtOffset - m_mtSeek;
                            }
                        }
                        m_pPerformance->MusicToReferenceTime(m_mtLastPlayed + mtMyAmount,&rtMyAmount);
                        rtMyAmount -= m_rtLastPlayed;
                    }
                    else if( m_mtSeek == m_mtLength )
                    {
                        // no more repeats.
                        hr = DMUS_S_END;
                    }
                }
            }
        }
    }
    if (hr == DMUS_S_END)
    {
        // send a segment end notification
        GenerateNotification( DMUS_NOTIFICATION_SEGEND, m_mtOffset + m_mtSeek );
        // also queue the almost ended for now
        MUSIC_TIME mtNow;
        m_pPerformance->GetTime( NULL, &mtNow );
        GenerateNotification( DMUS_NOTIFICATION_SEGALMOSTEND, mtNow );
        // if this is a primary or controlling segment, send a DMUS_PMSGT_DIRTY message
        if( !(m_dwPlaySegFlags & DMUS_SEGF_SECONDARY) || (m_dwPlaySegFlags & DMUS_SEGF_CONTROL) )
        {
            TraceI(4, "Send Dirty PMsg [2] %d (%d)\n", m_mtSeek, m_mtOffset + m_mtSeek);
            SendDirtyPMsg( m_mtOffset + m_mtSeek );
        }
        // If this is part of a song, we need to queue the next segment.
        if (m_fSongMode)
        {
            if (m_pSegment)
            {
                CSong *pSong = m_pSegment->m_pSong;
                if (pSong)
                {
                    // Get the next segment from the song.
                    CSegment *pSegment;
                    if (S_OK == pSong->GetPlaySegment(m_pSegment->m_dwNextPlayID,&pSegment))
                    {
                        // Now, play it.
                        // Unless DMUS_SEGF_USE_AUDIOPATH is set, play it on the same audiopath. 
                        // And, make sure that it plays at the same level (control, secondary, or primary.)
                        CSegState *pCSegState = NULL;
                        CAudioPath *pPath = m_pAudioPath;
                        CAudioPath *pInternalPath = NULL;
                        DWORD dwFlags = m_dwPlaySegFlags & (DMUS_SEGF_CONTROL | DMUS_SEGF_SECONDARY);
                        dwFlags &= ~DMUS_SEGF_REFTIME;
                        if (dwFlags & DMUS_SEGF_USE_AUDIOPATH)
                        {
                            IUnknown *pConfig;
                            if (SUCCEEDED(pSegment->GetAudioPathConfig(&pConfig)))
                            {
                                IDirectMusicAudioPath *pNewPath;
                                if (SUCCEEDED(m_pPerformance->CreateAudioPath(pConfig,TRUE,&pNewPath)))
                                {
                                    // Now, get the CAudioPath structure.
                                    pConfig->QueryInterface(IID_CAudioPath,(void **) &pInternalPath);
                                    pPath = pInternalPath;
                                }
                                pConfig->Release();
                            }
                        }
                        if (SUCCEEDED(m_pPerformance->PlayOneSegment((CSegment *)pSegment,dwFlags,m_mtEndTime,&pCSegState,pPath)))
                        {
                            if (m_pSongSegState)
                            {
                                // This is not the first, so transfer the segstate pointer.
                                pCSegState->m_pSongSegState = m_pSongSegState;
                                m_pSongSegState = NULL;
                            }
                            else
                            {
                                // This is the first, so have the next segstate point to this.
                                pCSegState->m_pSongSegState = this;
                                AddRef();
                            }
                            pCSegState->m_fSongMode = TRUE;
                            pCSegState->Release();
                        }
                        if (pInternalPath)
                        {
                            pInternalPath->Release();
                        }
                        pSegment->Release();
                    }
                }
            }
        }
    }
    m_dwPlayTrackFlags &= ~DMUS_TRACKF_DIRTY;
    m_pPerformance->m_dwGetParamFlags = 0;
    m_pPerformance->m_pGetParamSegmentState = NULL;
    m_fInPlay = false;
    if (m_fDelayShutDown)
    {
        Shutdown();
        m_fDelayShutDown = false;
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

CTrack * CSegState::GetTrackByParam( CTrack * pCTrack,
    REFGUID rguidType,DWORD dwGroupBits,DWORD dwIndex)
{
    // If the caller was already part way through the list, it passes the current
    // track. Otherwise, NULL to indicate start at the top.
    if (pCTrack)
    {
        pCTrack = pCTrack->GetNext();
    }
    else
    {
	    pCTrack = m_TrackList.GetHead();
    }
	while( pCTrack )
	{
		ASSERT(pCTrack->m_pTrack);
		if( (pCTrack->m_dwGroupBits & dwGroupBits ) && 
            (pCTrack->m_dwFlags & DMUS_TRACKCONFIG_CONTROL_ENABLED))
		{
			if( (GUID_NULL == rguidType) || (pCTrack->m_pTrack->IsParamSupported( rguidType ) == S_OK ))
			{
				if( 0 == dwIndex )
				{
                    return pCTrack;
				}
				dwIndex--;
			}
		}
		pCTrack = pCTrack->GetNext();
	}
    return NULL;
}

/* GetParam() is called by the performance in response to a GetParam() call
   on the performance. This needs the performance pointer so it can handle
   clock time to music time conversion and back, in case the source track is a
   clock time track.
*/

HRESULT CSegState::GetParam(
    CPerformance *pPerf,
    REFGUID rguidType,
    DWORD dwGroupBits,      
    DWORD dwIndex,          
    MUSIC_TIME mtTime,      
    MUSIC_TIME* pmtNext,    
    void* pParam)           
{
    HRESULT hr = DMUS_E_TRACK_NOT_FOUND;
    BOOL fMultipleTry = FALSE;
    if (dwIndex == DMUS_SEG_ANYTRACK)
    {
        dwIndex = 0;
        // Even though DX7 didn't support this, this is always safe because an index this high could never happen.
        fMultipleTry = TRUE; 
    }
    CTrack * pTrack = GetTrackByParam( NULL, rguidType, dwGroupBits, dwIndex);
    while (pTrack)
    {
        if (pTrack->m_pTrack8)
        {
            if (pTrack->m_dwFlags & DMUS_TRACKCONFIG_PLAY_CLOCKTIME)
            {
                REFERENCE_TIME rtTime, rtNext;
                // Convert mtTime into reference time units:
                pPerf->MusicToReferenceTime(m_mtOffset + mtTime,&rtTime);
                rtTime -= m_rtOffset;
                hr = pTrack->m_pTrack8->GetParamEx( rguidType, rtTime, &rtNext, 
                    pParam, pTrack->m_pTrackState, DMUS_TRACK_PARAMF_CLOCK );
                if (pmtNext)
                {
                    if (rtNext == 0) *pmtNext = 0;
                    else
                    {
                        rtNext += m_rtOffset;
                        pPerf->ReferenceToMusicTime(rtNext,pmtNext);
                        *pmtNext -= m_mtOffset;
                    }
                }
            }
            else
            {
                REFERENCE_TIME rtNext, *prtNext;
                // We need to store the next time in a 64 bit pointer. But, don't
                // make 'em fill it in unless the caller requested it. 
                if (pmtNext)
                {
                    prtNext = &rtNext;
                }
                else
                {
                    prtNext = NULL;
                }
                hr = pTrack->m_pTrack8->GetParamEx( rguidType, mtTime, prtNext, pParam,
                    pTrack->m_pTrackState, 0 );
                if (pmtNext)
                {
                    *pmtNext = (MUSIC_TIME) rtNext;
                }
            }
        }
        else
        {
            // This is a pre DX8 track...
            hr = pTrack->m_pTrack->GetParam( rguidType, mtTime, pmtNext, pParam );
        }
        if (SUCCEEDED(hr))
        {
            if( pmtNext )
            { 
                if(( *pmtNext == 0 ) || (*pmtNext > (m_mtLength - mtTime)))
                {
                    // If no next was found OR it's greater than the end of the segment, set 
                    // it to the end of the segment. 
                    *pmtNext = m_mtLength - mtTime;
                }
            }
            pTrack = NULL;
        }
        // If nothing was found and dwIndex was DMUS_SEG_ANYTRACK, try again...
        else if (fMultipleTry && (hr == DMUS_E_NOT_FOUND))
        {
            pTrack = GetTrackByParam( pTrack, rguidType, dwGroupBits, 0);
        }
        else
        {
            pTrack = NULL;
        }
    }
#ifdef DBG
    if (hr == DMUS_E_TRACK_NOT_FOUND)
    {
        Trace(4,"Warning: Segmentstate::GetParam failed, unable to find a track that supports the requested param.\n");
    }
#endif
    return hr;
}


CTrack *CSegState::GetTrack( 
    REFCLSID rType,		
	DWORD dwGroupBits,	
    DWORD dwIndex)
{
	CTrack* pCTrack;
	pCTrack = m_TrackList.GetHead();
	while( pCTrack )
	{
		ASSERT(pCTrack->m_pTrack);
		if( pCTrack->m_dwGroupBits & dwGroupBits )
		{
			if( (GUID_All_Objects == rType) || (pCTrack->m_guidClassID == rType))
			{
				if( 0 == dwIndex )
				{
                    break;
				}
				dwIndex--;
			}
		}
		pCTrack = pCTrack->GetNext();
	}
	return pCTrack;
}

STDMETHODIMP CSegState::SetVolume(long lVolume,DWORD dwDuration) 

{
    V_INAME(SegState::SetVolume);
#if defined(DBG) || defined(DXAPI)
    if (lVolume < DSBVOLUME_MIN || lVolume > DSBVOLUME_MAX)
    {
        RIP_E_INVALIDARG(lVolume)
    }
#endif
    HRESULT hr = E_FAIL; // This should never happen, since the audiopath is created by the performance. 
    BYTE bMIDIVol = CParamMerger::VolumeToMidi(lVolume);

    DMUS_CURVE_PMSG *pCurve;
    // Clamp to an hour!
    if (dwDuration > (60 * 60 * 1000)) dwDuration = (60 * 60 * 1000);
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    ENTER_API_CRITICAL_SECTION;
    if (m_pPerformance)
    {
        hr = m_pPerformance->AllocPMsg(sizeof(DMUS_CURVE_PMSG),(DMUS_PMSG **)&pCurve);
        if (SUCCEEDED(hr))
        {
            REFERENCE_TIME rtTimeNow = 0;
            m_pPerformance->GetQueueTime(&rtTimeNow);
            // If this starts before a previous fade ended, invalidate it.
            if (m_rtLastVolChange > rtTimeNow)
            {
                MUSIC_TIME mtNow;
                m_pPerformance->ReferenceToMusicTime(rtTimeNow,&mtNow);
                m_pPerformance->FlushVirtualTrack(m_dwTrackID,mtNow,0);
            }
            if (m_rtLastVolChange < (rtTimeNow + (dwDuration * 10000)))
            {
                m_rtLastVolChange = rtTimeNow + (dwDuration * 10000);
            }
                pCurve->dwVirtualTrackID = m_dwTrackID;
            pCurve->rtTime = rtTimeNow;
            pCurve->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME | DMUS_PMSGF_DX8;
            pCurve->dwPChannel = DMUS_PCHANNEL_BROADCAST_SEGMENT;
            // dwVirtualTrackID: this isn't a track so leave as 0
            pCurve->dwType = DMUS_PMSGT_CURVE;
            pCurve->dwGroupID = -1; // this isn't a track so just say all groups

            // curve PMsg fields
            pCurve->mtDuration = dwDuration; // setting the DMUS_PMSGF_LOCKTOREFTIME is interpreted by the performance that mtDuration is milliseconds
            // mtResetDuration: no reset so leave as 0
            pCurve->nStartValue = 127; //m_bLastVol;
            // nStartValue: will be ignored
            pCurve->nEndValue = bMIDIVol;
            // nResetValue: no reset so leave as 0
            pCurve->bType = DMUS_CURVET_CCCURVE;
            pCurve->bCurveShape = dwDuration ? DMUS_CURVES_LINEAR : DMUS_CURVES_INSTANT;
            pCurve->bCCData = 7; // MIDI volume controller number
            pCurve->bFlags = DMUS_CURVE_START_FROM_CURRENT;
            // wParamType: leave as zero since this isn't a NRPN/RPN curve
            pCurve->wMergeIndex = 0xFFFF; //  special merge index so this won't get stepped on. is a big number OK? define a constant for this value?

            // send it

            StampPMsg((DMUS_PMSG *)pCurve);
            hr = m_pPerformance->SendPMsg((DMUS_PMSG*)pCurve);
        }
    }
    else
    {
        hr = DMUS_E_NOT_INIT;
    }
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    LEAVE_API_CRITICAL_SECTION;
    return hr;
}

STDMETHODIMP CSegState::SetPitch(long lPitch,DWORD dwDuration) 

{
    V_INAME(AudioPath::SetPitch);
    HRESULT hr = E_FAIL; // This should never happen, since the audiopath is created by the performance. 
    lPitch += 0x2000; // Bump up to center around 0x2000.
#if defined(DBG) || defined(DXAPI)
    if (lPitch < 0 || lPitch > 0x3FFF)
    {
        RIP_E_INVALIDARG(lPitch)
    }
#endif
    DMUS_CURVE_PMSG *pCurve;
    // Clamp to an hour!
    if (dwDuration > (60 * 60 * 1000)) dwDuration = (60 * 60 * 1000);
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    ENTER_API_CRITICAL_SECTION;
    if (m_pPerformance)
    {
        hr = m_pPerformance->AllocPMsg(sizeof(DMUS_CURVE_PMSG),(DMUS_PMSG **)&pCurve);
        if (SUCCEEDED(hr))
        {
            REFERENCE_TIME rtTimeNow = 0;
            m_pPerformance->GetQueueTime(&rtTimeNow);
            // If this starts before a previous fade ended, invalidate it.
            if (m_rtLastPitchChange > rtTimeNow)
            {
                MUSIC_TIME mtNow;
                m_pPerformance->ReferenceToMusicTime(rtTimeNow,&mtNow);
                m_pPerformance->FlushVirtualTrack(m_dwTrackID,mtNow,0);
            }
            if (m_rtLastPitchChange < (rtTimeNow + (dwDuration * 10000)))
            {
                m_rtLastPitchChange = rtTimeNow + (dwDuration * 10000);
            }
            pCurve->dwVirtualTrackID = m_dwTrackID;
            pCurve->rtTime = rtTimeNow;
            pCurve->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME | DMUS_PMSGF_DX8;
            pCurve->dwPChannel = DMUS_PCHANNEL_BROADCAST_SEGMENT;
            // dwVirtualTrackID: this isn't a track so leave as 0
            pCurve->dwType = DMUS_PMSGT_CURVE;
            pCurve->dwGroupID = -1; // this isn't a track so just say all groups

            // curve PMsg fields
            pCurve->mtDuration = dwDuration; // setting the DMUS_PMSGF_LOCKTOREFTIME is interpreted by the performance that mtDuration is milliseconds
            // mtResetDuration: no reset so leave as 0
            pCurve->nStartValue = 0;
            // nStartValue: will be ignored
            pCurve->nEndValue = (short) lPitch;
            // nResetValue: no reset so leave as 0
            pCurve->bType = DMUS_CURVET_PBCURVE;
            pCurve->bCurveShape = dwDuration ? DMUS_CURVES_LINEAR : DMUS_CURVES_INSTANT;
            // bCCData: Ignore, since this is pitch bend
            pCurve->bFlags = DMUS_CURVE_START_FROM_CURRENT;
            pCurve->wParamType = 0x2000;  // PB Range equivalent to pitch cents units.
            pCurve->wMergeIndex = 0xFFFF; //  special merge index so this won't get stepped on. is a big number OK? define a constant for this value?

            // send it

            StampPMsg((DMUS_PMSG *)pCurve);
            hr = m_pPerformance->SendPMsg((DMUS_PMSG*)pCurve);
        }
    }
    else
    {
        hr = DMUS_E_NOT_INIT;
    }
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    LEAVE_API_CRITICAL_SECTION;
    return hr;
}

STDMETHODIMP CSegState::SetTrackConfig(REFGUID rguidTrackClassID,
                                      DWORD dwGroup, DWORD dwIndex, 
                                      DWORD dwFlagsOn, DWORD dwFlagsOff) 
{
	V_INAME(IDirectMusicSegment::SetTrackConfig);
	V_REFGUID(rguidTrackClassID);
#ifndef XBOX
    if (rguidTrackClassID == GUID_NULL)
    {
        return E_INVALIDARG;
    }
#endif
	HRESULT hr = DMUS_E_TRACK_NOT_FOUND;
    CTrack* pCTrack;
    DWORD dwCounter = dwIndex;
    DWORD dwMax = dwIndex;
    if (dwIndex == DMUS_SEG_ALLTRACKS)
    {
        dwCounter = 0;
        dwMax = DMUS_SEG_ALLTRACKS;
    }
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    while (pCTrack = GetTrack(rguidTrackClassID,dwGroup,dwIndex))
    {
        pCTrack->m_dwFlags &= ~dwFlagsOff;
        pCTrack->m_dwFlags |= dwFlagsOn;
        hr = S_OK;
        dwCounter++;
        if (dwCounter > dwMax) break;
    }
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
#ifdef DBG
    if (hr == DMUS_E_TRACK_NOT_FOUND)
    {
        Trace(1,"Error: Segmentstate::SetTrackConfig failed, unable to find the requested track.\n");
    }
#endif
	return hr;
}

HRESULT CSegState::CheckPlay( 
	MUSIC_TIME mtAmount, MUSIC_TIME* pmtResult )
{
	MUSIC_TIME mtMyAmount = mtAmount;
	MUSIC_TIME mtSeek = m_mtSeek;
	MUSIC_TIME mtOffset = m_mtOffset;

	ASSERT(pmtResult);
	// if this is the first call to play,
	// We also need to check to see if we are supposed to start at the beginning,
	// or at an offset.
	if( m_dwPlayTrackFlags & DMUS_TRACKF_START )
	{
		// set the current seek to the start point
		mtSeek = m_mtStartPoint;
	}
	// if we need to do a loop or the end is near, restrict mtMyAmount
	ASSERT( m_mtLength ); // length is 0, this segment won't do anything
	if( m_dwRepeatsLeft )
	{
		if( mtMyAmount > m_mtLoopEnd - mtSeek )
		{
			mtMyAmount = m_mtLoopEnd - mtSeek;
		}
	}
	else if( mtMyAmount > m_mtLength - mtSeek )
	{
		mtMyAmount = m_mtLength - mtSeek;
	}
	
	// take into account repeats if necessary
	*pmtResult = mtMyAmount;
	return S_OK;
}

///////////////////////////////////////////////////////////////////////
// IDirectMusicSegmentState::GetStartTime
/*
@method HRESULT | IDirectMusicSegmentState | GetStartTime |
Gets the music time this SegmentState started playing.

@rvalue E_POINTER | <p pmtStart> is NULL or invalid.
@rvalue S_OK | Success.

@xref <om IDirectMusicPerformance.PlaySegment>
*/
HRESULT STDMETHODCALLTYPE CSegState::GetStartTime( 
    MUSIC_TIME *pmtStart)	// @parm Returns the music time of the start of this SegmentState.
							// This is the music time, in Performance time, that the SegmentState
							// started or will start playing.
{
	V_INAME(IDirectMusicSegmentState::GetStartTime);
	V_PTR_WRITE(pmtStart,MUSIC_TIME);

	*pmtStart = m_mtResolvedStart;
	return S_OK;
}

///////////////////////////////////////////////////////////////////////
// IDirectMusicSegmentState::GetStartPoint
/*
@method HRESULT | IDirectMusicSegmentState | GetStartPoint |
Calling <om IDirectMusicSegment.SetStartPoint> causes the SegmentState to begin
playing from the middle instead of from the beginning. <om .GetStartPoint>
returns the amount of time from the beginning of the SegmentState that it
plays.

@rvalue E_POINTER | <p pmtStart> is NULL or invalid.
@rvalue S_OK | Success.

@xref <om IDirectMusicSegment.SetStartPoint>,
<om IDirectMusicPerformance.PlaySegment>
*/
HRESULT STDMETHODCALLTYPE CSegState::GetStartPoint( 
    MUSIC_TIME *pmtStart)	// @parm Returns the music time offset from the start of the
							// SegmentState at which the SegmentState initially plays.
{
	V_INAME(IDirectMusicSegmentState::GetStartPoint);
	V_PTR_WRITE(pmtStart,MUSIC_TIME);

	*pmtStart = m_mtStartPoint;
	return S_OK;
}

///////////////////////////////////////////////////////////////////////
// IDirectMusicSegmentState::SetSeek
/*
method (INTERNAL) HRESULT | IDirectMusicSegmentState | SetSeek |
Sets the music time Seek maintained by this SegmentState.

parm MUSIC_TIME | mtSeek |
	[in] The music time Seek to store in this SegmentState.

comm The SegmentState passes this Seek value to <im IDirectMusicTrack.Play>
Note that newly created SegmentState's start with a Seek time of 0.
rvalue S_OK | Success.
*/
HRESULT CSegState::SetSeek( 
    MUSIC_TIME mtSeek, DWORD dwPlayFlags)
{
	m_mtSeek = mtSeek;
	m_dwPlayTrackFlags |= dwPlayFlags | DMUS_TRACKF_SEEK;
	return S_OK;
}

/*
Called from IDirectMusicPerformance::Invalidate, this routine helps set
the current seek pointer. Done here instead of directly inside Performance
because it's easier to compute the repeats, etc. here.
*/
HRESULT CSegState::SetInvalidate(
	MUSIC_TIME mtTime) // mtTime is in Performance time
{
	MUSIC_TIME mtOffset;
	DWORD dwRepeat;
	DWORD dwFlags = DMUS_TRACKF_FLUSH | DMUS_TRACKF_SEEK;

	HRESULT hr = ConvertToSegTime( &mtTime, &mtOffset, &dwRepeat );
	if( hr != S_OK )
	{
		mtTime = 0;
		m_dwRepeatsLeft = m_dwRepeats;
		m_mtOffset = m_mtResolvedStart;
		dwFlags |= DMUS_TRACKF_START;
	}
	else
	{
		m_dwRepeatsLeft = m_dwRepeats - dwRepeat;
		m_mtOffset = mtOffset;
	}
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
	CTrack* pCTrack = m_TrackList.GetHead();
	while( pCTrack )
	{
		pCTrack->m_bDone = FALSE;
		pCTrack = pCTrack->GetNext();
	}
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
	return SetSeek( mtTime, dwFlags );
}

///////////////////////////////////////////////////////////////////////
// IDirectMusicSegmentState::GetSeek

HRESULT STDMETHODCALLTYPE CSegState::GetSeek( 
    MUSIC_TIME *pmtSeek) // @parm Returns the current seek pointer, which indicates
						// the next time that will be called inside <om IDirectMusicTrack.Play>.
{
	V_INAME(IDirectMusicSegmentState::GetSeek);
	V_PTR_WRITE(pmtSeek, MUSIC_TIME);

	*pmtSeek = m_mtSeek;
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CSegState::Flush(MUSIC_TIME mtTime) // The time on and after which to flush.
{
	CTrack*	pTrack;
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
	pTrack = m_TrackList.GetHead();
	while( pTrack )
	{
		m_pPerformance->FlushVirtualTrack( pTrack->m_dwVirtualID, mtTime, 0 );
		pTrack = pTrack->GetNext();
	}
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CSegState::Shutdown()
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CSegState::InsertTool( 
    IDirectMusicTool *pTool,
    DWORD *pdwPChannels,
    DWORD cPChannels,
    LONG lIndex)
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CSegState::GetTool(
	DWORD dwIndex,
	IDirectMusicTool** ppTool)
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CSegState::RemoveTool(
	IDirectMusicTool* pTool)
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CSegState::StampPMsg( 
	/* [in */ DMUS_PMSG* pPMsg)
{
	V_INAME(IDirectMusicSegmentState::StampPMsg);
    if( m_dwVersion < 8)
    {
    	V_BUFPTR_WRITE(pPMsg,sizeof(DMUS_PMSG));
    }
    else
    {
#ifdef DBG
		V_BUFPTR_WRITE(pPMsg,sizeof(DMUS_PMSG));
#else
        if (!pPMsg)
        {
            return E_POINTER;
        }
#endif
    }
	HRESULT hr = E_FAIL;
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
	ENTER_API_CRITICAL_SECTION;

    if (m_pPerformance) 

    {
        // First, check if the segmentstate has its own graph.
        if (m_pGraph)
	    {
            // Could return DMUS_S_LAST_TOOL, indicating end of graph. 
            // If so, we'll treat that as a failure and drop on through to the next graph...
		    if( S_OK == ( hr = m_pGraph->StampPMsg( pPMsg )))
		    {
			    if( pPMsg->pGraph != this ) // Make sure this is set to point to the segstate embedded graph so it will come here again.
			    {
				    if( pPMsg->pGraph )
				    {
					    pPMsg->pGraph->Release();
					    pPMsg->pGraph = NULL;
				    }
				    pPMsg->pGraph = this;
				    AddRef();
			    }
		    }
        }
        // If done with the graph, send to the audio path, if it exists,
        // else the performance. Also, check for the special case of 
        // DMUS_PCHANNEL_BROADCAST_SEGMENT. If so, duplicate the pMsg
        // and send all the copies with the appropriate pchannel values.
	    if( FAILED(hr) || (m_dwVersion && (hr == DMUS_S_LAST_TOOL)))
        {
            if (pPMsg->dwPChannel == DMUS_PCHANNEL_BROADCAST_SEGMENT)
            {
                CSegment *pSegment = m_pSegment;
                ENTER_CRITICAL_SECTION(&pSegment->m_CriticalSection);
                DWORD dwIndex;
                // Create new messages with new pchannels for all but one, which will
                // be assigned to this message.
                for (dwIndex = 1;dwIndex < pSegment->m_dwNumPChannels;dwIndex++)
                {
                    DWORD dwNewChannel = pSegment->m_paPChannels[dwIndex];
                    // Don't broadcast any broadcast messages!
                    // And, if this is a transpose on the drum channel, don't send it.
                    if ((dwNewChannel < DMUS_PCHANNEL_BROADCAST_GROUPS) &&
                        ((pPMsg->dwType != DMUS_PMSGT_TRANSPOSE) || ((dwNewChannel & 0xF) != 9)))
                    {
                        DMUS_PMSG *pNewMsg;
                        if (SUCCEEDED(m_pPerformance->ClonePMsg(pPMsg,&pNewMsg)))
                        {
                            HRESULT hrTemp;
                            pNewMsg->dwPChannel = dwNewChannel;
                            if (m_pAudioPath)
                            {
                                hrTemp = m_pAudioPath->StampPMsg(pNewMsg);
                            }
                            else
                            {
                                hrTemp = m_pPerformance->StampPMsg(pNewMsg);
                            }
                            if (SUCCEEDED(hrTemp))
                            {
                                m_pPerformance->SendPMsg(pNewMsg);
                            }
                            else
                            {
                                m_pPerformance->FreePMsg(pNewMsg);
                            }
                        }
                    }
                }
                // Now, set the pchannel for this one. First check that there are any
                // pchannels. If none, mark the PMsg to be deleted by the SendPMsg routine.
                // Also, mark it this way if the PMsg is a broadcast PMsg.
                pPMsg->dwPChannel = DMUS_PCHANNEL_KILL_ME;
                if (pSegment->m_dwNumPChannels)
                {
                    if (pSegment->m_paPChannels[0] < DMUS_PCHANNEL_BROADCAST_GROUPS)
                    {
                        pPMsg->dwPChannel = pSegment->m_paPChannels[0];
                    }
                }
                LEAVE_CRITICAL_SECTION(&pSegment->m_CriticalSection);
            }
            if (m_pAudioPath)
            {
                hr = m_pAudioPath->StampPMsg(pPMsg);
            }
            else
            {
                hr = m_pPerformance->StampPMsg(pPMsg);
            }
        }

    }
    else
    {
        hr = DMUS_E_NOT_INIT;
        Trace(1,"Error: Segmentstate::StampPMsg failed because the segmentstate is not properly initialized.\n");
    }
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
	LEAVE_API_CRITICAL_SECTION;
	return hr;
}


STDMETHODIMP CSegState::GetObjectInPath( DWORD dwPChannel,DWORD dwStage,DWORD dwBuffer, REFGUID guidObject,
                    DWORD dwIndex,REFGUID iidInterface, void ** ppObject)
{
	V_INAME(IDirectMusicSegmentState::GetObjectInPath);
	V_PTRPTR_WRITE(ppObject);
    *ppObject = NULL;
    if (dwBuffer && ((dwStage < DMUS_PATH_BUFFER) || (dwStage >= DMUS_PATH_PRIMARY_BUFFER)))
    {
        return DMUS_E_NOT_FOUND;
    }
    HRESULT hr = DMUS_E_NOT_FOUND;
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    ENTER_API_CRITICAL_SECTION;
    switch (dwStage)
    {
    case DMUS_PATH_SEGMENT:
        if (m_pSegment && (dwIndex == 0) && (dwPChannel == 0))
        {
            hr = m_pSegment->QueryInterface(iidInterface,ppObject);
        }
        break;
    case DMUS_PATH_SEGMENT_TRACK:
        if (dwPChannel == 0)
        {
            CTrack * pCTrack = GetTrack(guidObject,-1,dwIndex);
	        if (pCTrack)
            {
                if (pCTrack->m_pTrack)
                {
                    hr = pCTrack->m_pTrack->QueryInterface(iidInterface,ppObject);
                }
            }
        }
        break;
    case DMUS_PATH_SEGMENT_GRAPH:
        if ((dwIndex == 0) && (dwPChannel == 0))
        {
            if (!m_pGraph)
            {
                m_pGraph = new CGraph;
            }
            if (m_pGraph)
            {
                hr = m_pGraph->QueryInterface(iidInterface,ppObject);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        break;
    case DMUS_PATH_SEGMENT_TOOL:
        if (!m_pGraph)
        {
            m_pGraph = new CGraph;
        }
        if (m_pGraph)
        {
            hr = m_pGraph->GetObjectInPath(dwPChannel,guidObject,dwIndex,iidInterface,ppObject);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
        break;
    case DMUS_PATH_PERFORMANCE:
        if (m_pPerformance && (dwIndex == 0) && (dwPChannel == 0))
        {
            hr = m_pPerformance->QueryInterface(iidInterface,ppObject);
        }
        break;
    case DMUS_PATH_PERFORMANCE_GRAPH:
        if (m_pPerformance && (dwIndex == 0) && (dwPChannel == 0))
        {
            IDirectMusicGraph *pGraph;
            if (SUCCEEDED(hr = m_pPerformance->GetGraphInternal(&pGraph)))
            {
                hr = pGraph->QueryInterface(iidInterface,ppObject);
                pGraph->Release();
            }
        }
        break;
    case DMUS_PATH_PERFORMANCE_TOOL:
        if (m_pPerformance)
        {
            IDirectMusicGraph *pGraph;
            if (SUCCEEDED(hr = m_pPerformance->GetGraphInternal(&pGraph)))
            {
                CGraph *pCGraph = (CGraph *) pGraph;
                hr = pCGraph->GetObjectInPath(dwPChannel,guidObject,dwIndex,iidInterface,ppObject);
                pGraph->Release();
            }
        }
        break;
    default:
        if (m_pAudioPath)
        {
            hr = m_pAudioPath->GetObjectInPath(dwPChannel,dwStage,dwBuffer,guidObject,dwIndex,iidInterface,ppObject);
        }
        else
        {
            Trace(1,"Error: Unable to access audiopath components of segmentstate.\n");
        }
    }
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    LEAVE_API_CRITICAL_SECTION;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\ntfylist.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
//////////////////////////////////////////////////////////////////////
// NtfyList.h

#include "alist.h"
#include "dmusicip.h"
#include "debug.h"

#ifndef __NTFYLIST_H_
#define __NTFYLIST_H_

class CNotificationItem : public AListItem
{
public:
	CNotificationItem* GetNext()
	{
		return (CNotificationItem*)AListItem::GetNext();
	};
public:
	GUID	guidNotificationType;
    BOOL    fFromPerformance;
};

class CNotificationList : public AList
{
public:
    CNotificationItem* GetHead() 
	{
		return (CNotificationItem*)AList::GetHead();
	};
    CNotificationItem* RemoveHead() 
	{
		return (CNotificationItem*)AList::RemoveHead();
	};
    CNotificationItem* GetItem(LONG lIndex) 
	{
		return (CNotificationItem*) AList::GetItem(lIndex);
	};
	void Clear(void)
	{
		CNotificationItem* pTrack;
		while( pTrack = RemoveHead() )
		{
			delete pTrack;
		}
	}
};

#endif // __NTFYLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\oledll.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
//
//
#ifndef _OLEDLL_
#define _OLEDLL_

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID);

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID);

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue);
				 
HRESULT CLSIDToStr(const CLSID &clsid,
				   TCHAR *szStr,
				   int cbStr);

HRESULT StrToCLSID(TCHAR *szStr,
				   CLSID &clsid,
				   int cbStr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\dmstrm.cpp ===
//
// dmstrm.cpp
// 
// Copyright (c) 1995-2000 Microsoft Corporation
//
#include "pchime.h"
/*
#include "debug.h"
#include "dmusicc.h"
#include "..\shared\dmstrm.h"
#include "..\shared\validate.h"*/

/////////////////////////////////////////////////////////////////////////////
// AllocDIrectMusicStream

STDAPI AllocDirectMusicStream(IStream* pIStream, IDMStream** ppIDMStream)
{
	if(pIStream == NULL || ppIDMStream == NULL)
	{
		return E_INVALIDARG;            
	}

	if((*ppIDMStream = (IDMStream*) new CDirectMusicStream()) == NULL)
    {
		return E_OUTOFMEMORY;
    }
	
	((CDirectMusicStream*)*ppIDMStream)->Init(pIStream);
    
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::CDirectMusicStream

CDirectMusicStream::CDirectMusicStream() :
m_cRef(1),
m_pStream(NULL)
{
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::~CDirectMusicStream
   
CDirectMusicStream::~CDirectMusicStream()
{
	if(m_pStream != NULL)
    {
		m_pStream->Release();
    }
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::Init
   
STDMETHODIMP CDirectMusicStream::Init(IStream* pStream)
{
    SetStream(pStream);
	
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// IUnknown

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::QueryInterface

STDMETHODIMP CDirectMusicStream::QueryInterface(const IID &iid, void **ppv)
{
	V_INAME(CDirectMusicStream::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

	if(iid == IID_IUnknown || iid == IID_IDMStream)
	{
		*ppv = static_cast<IDMStream*>(this);
    } 
	else 
	{
		*ppv = NULL;
		return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::AddRef

STDMETHODIMP_(ULONG) CDirectMusicStream::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::Release

STDMETHODIMP_(ULONG) CDirectMusicStream::Release()
{
    if(!InterlockedDecrement(&m_cRef)) 
	{
		delete this;
		return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::SetStream

STDMETHODIMP CDirectMusicStream::SetStream(IStream* pStream)
{
    if(m_pStream != NULL)
    {
		m_pStream->Release();
    }

	m_pStream = pStream;
    
	if(m_pStream != NULL)
    {
		m_pStream->AddRef();
    }
    
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::GetStream

STDMETHODIMP_(IStream*) CDirectMusicStream::GetStream()
{
	if(m_pStream != NULL)
    {
		m_pStream->AddRef();
    }
    
	return m_pStream;
}

//////////////////////////////////////////////////////////////////////
// IDMStream

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::Descend

STDMETHODIMP CDirectMusicStream::Descend(LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags)
{
    assert(lpck);

	FOURCC ckidFind;           // Chunk ID to find (or NULL)
    FOURCC fccTypeFind;    // Form/list type to find (or NULL)

    // Figure out what chunk id and form/list type for which to search
    if(wFlags & MMIO_FINDCHUNK)
	{
		ckidFind = lpck->ckid;
		fccTypeFind = NULL;
	}
    else if(wFlags & MMIO_FINDRIFF)
    {
		ckidFind = FOURCC_RIFF;
		fccTypeFind = lpck->fccType;
    }
	else if(wFlags & MMIO_FINDLIST)
	{
		ckidFind = FOURCC_LIST;
		fccTypeFind = lpck->fccType;
	}
    else
    {
		ckidFind = fccTypeFind = NULL;
	}

    lpck->dwFlags = 0L;

    for(;;)
    {
		HRESULT hr;
		LARGE_INTEGER li;
		ULARGE_INTEGER uli;
		ULONG cbRead;

		// Read the chunk header
		hr = m_pStream->Read(lpck, 2 * sizeof(DWORD), &cbRead);

        if (FAILED(hr) || (cbRead != 2 * sizeof(DWORD)))
		{
            Trace(3,"Warning: Reached end of file.\n");
			return DMUS_E_DESCEND_CHUNK_FAIL;
		}

		// Store the offset of the data part of the chunk
		li.QuadPart = 0;
		hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &uli);

		if(FAILED(hr))
		{
            Trace(1,"Error: Unable to read file.\n");
			return DMUS_E_CANNOTSEEK;
		}
		else
		{
			lpck->dwDataOffset = uli.LowPart;
		}

		// See if the chunk is within the parent chunk (if given)
		if((lpckParent != NULL) &&
		   (lpck->dwDataOffset - 8L >=
		   lpckParent->dwDataOffset + lpckParent->cksize))
		{
            // This is not really a failure, just indicating we've reached the end of the list.
			return DMUS_E_DESCEND_CHUNK_FAIL;
		}

		// If the chunk is a 'RIFF' or 'LIST' chunk, read the
		// form type or list type
		if((lpck->ckid == FOURCC_RIFF) || (lpck->ckid == FOURCC_LIST))
		{

			hr = m_pStream->Read(&lpck->fccType, sizeof(DWORD), &cbRead);

			if(FAILED(hr) || (cbRead != sizeof(DWORD)))
			{
                Trace(1,"Error: Unable to read file.\n");
				return DMUS_E_DESCEND_CHUNK_FAIL;
			}
		}
		else
		{
			lpck->fccType = NULL;
		}

		// If this is the chunk we're looking for, stop looking
		if(((ckidFind == NULL) || (ckidFind == lpck->ckid)) &&
		   ((fccTypeFind == NULL) || (fccTypeFind == lpck->fccType)))
		{
			break;
		}

		// Ascend out of the chunk and try again
		HRESULT w = Ascend(lpck, 0);
		if(FAILED(w))
		{
			return w;
		}
	}

    return S_OK;
}


//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::Ascend

STDMETHODIMP CDirectMusicStream::Ascend(LPMMCKINFO lpck, UINT /*wFlags*/)
{
	assert(lpck);

    HRESULT hr;
	LARGE_INTEGER li;
	ULARGE_INTEGER uli;
	
	if (lpck->dwFlags & MMIO_DIRTY)
    {
		// <lpck> refers to a chunk created by CreateChunk();
		// check that the chunk size that was written when
		// CreateChunk() was called is the real chunk size;
		// if not, fix it
		LONG lOffset;           // current offset in file
		LONG lActualSize;   // actual size of chunk data

		li.QuadPart = 0;
		hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &uli);

		if(FAILED(hr))
		{
            Trace(1,"Error: Unable to write file.\n");
			return DMUS_E_CANNOTSEEK;
		}
		else
		{
			lOffset = uli.LowPart;
		}
		
		if((lActualSize = lOffset - lpck->dwDataOffset) < 0)
		{
            Trace(1,"Error: Unable to write file.\n");
			return DMUS_E_CANNOTWRITE;
		}

		if(LOWORD(lActualSize) & 1)
		{
			ULONG cbWritten;

			// Chunk size is odd -- write a null pad byte
			hr = m_pStream->Write("\0", 1, &cbWritten); 
			
			if(FAILED(hr) || cbWritten != 1)
			{
                Trace(1,"Error: Unable to write file.\n");
				return DMUS_E_CANNOTWRITE;
			}
		
		}
	
		if(lpck->cksize == (DWORD)lActualSize)
		{
			return S_OK;
		}

		// Fix the chunk header
		lpck->cksize = lActualSize;

		li.QuadPart = lpck->dwDataOffset - sizeof(DWORD);
		hr = m_pStream->Seek(li, STREAM_SEEK_SET, &uli);

		if(FAILED(hr))
		{
            Trace(1,"Error: Unable to write file.\n");
			return DMUS_E_CANNOTSEEK;
		}

		ULONG cbWritten;

		hr = m_pStream->Write(&lpck->cksize, sizeof(DWORD), &cbWritten); 
		
		if(FAILED(hr) || cbWritten != sizeof(DWORD))
		{
            Trace(1,"Error: Unable to write file.\n");
			return DMUS_E_CANNOTWRITE;
		}
    }

	// Seek to the end of the chunk, past the null pad byte
	// (which is only there if chunk size is odd)
	li.QuadPart = lpck->dwDataOffset + lpck->cksize + (lpck->cksize & 1L);
	hr = m_pStream->Seek(li, STREAM_SEEK_SET, &uli);

	if(FAILED(hr))
	{
        Trace(1,"Error: Unable to write file.\n");
		return DMUS_E_CANNOTSEEK;
	}

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::CreateChunk

STDMETHODIMP CDirectMusicStream::CreateChunk(LPMMCKINFO lpck, UINT wFlags)
{
	assert(lpck);

    UINT iBytes;    // Bytes to write
    LONG lOffset;   // Current offset in file

	// Store the offset of the data part of the chunk
	LARGE_INTEGER li;
	ULARGE_INTEGER uli;

	li.QuadPart = 0;
	HRESULT hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &uli);

	if(FAILED(hr))
	{
        Trace(1,"Error: Unable to write file.\n");
		return DMUS_E_CANNOTSEEK;
	}
    else
	{
		lOffset = uli.LowPart;
	}
    
    lpck->dwDataOffset = lOffset + 2 * sizeof(DWORD);

    // figure out if a form/list type needs to be written
    if(wFlags & MMIO_CREATERIFF)
	{
		lpck->ckid = FOURCC_RIFF, iBytes = 3 * sizeof(DWORD);
    }
	else if(wFlags & MMIO_CREATELIST)
	{
		lpck->ckid = FOURCC_LIST, iBytes = 3 * sizeof(DWORD);
	}
    else
    {
		iBytes = 2 * sizeof(DWORD);
	}

    // Write the chunk header
	ULONG cbWritten;

	hr = m_pStream->Write(lpck, iBytes, &cbWritten); 
		
	if(FAILED(hr) || cbWritten != iBytes)
	{
        Trace(1,"Error: Unable to write file.\n");
		return DMUS_E_CANNOTWRITE;
	}

	lpck->dwFlags = MMIO_DIRTY;

    return S_OK;
}

CRiffParser::CRiffParser(IStream *pStream)

{
    assert(pStream);
    m_fDebugOn = FALSE;
    m_pStream = pStream; 
    m_pParent = NULL;
    m_pChunk = NULL;
    m_lRead = 0;
    m_fFirstPass = TRUE;
    m_fComponentFailed = FALSE;
    m_fInComponent = FALSE;
}

void CRiffParser::EnterList(RIFFIO *pChunk)

{
    assert (pChunk);
    pChunk->lRead = 0;
    pChunk->pParent = m_pChunk; // Previous chunk (could be NULL.)
    m_pParent = m_pChunk;
    m_pChunk = pChunk;
    m_fFirstPass = TRUE;
}

void CRiffParser::LeaveList()

{
    assert (m_pChunk);
    if (m_pChunk)
    {
        m_pChunk = m_pChunk->pParent;
        if (m_pChunk)
        {
            m_pParent = m_pChunk->pParent;
        }
    }
}

BOOL CRiffParser::NextChunk(HRESULT * pHr)

{
    BOOL fMore = FALSE;
    if (SUCCEEDED(*pHr))
    {
        // If this is the first time we've entered this list, there is no previous chunk.
        if (m_fFirstPass)
        {
            // Clear the flag.
            m_fFirstPass = FALSE;
        }
        else
        {
            // Clean up the previous pass.
            *pHr = LeaveChunk();
        }
        // Find out if there are more chunks to read.
        fMore = MoreChunks();
        // If so, and we don't have any failure, go ahead and read the next chunk header.
        if (fMore && SUCCEEDED(*pHr))
        {
            *pHr = EnterChunk();
        }
    }
    else
    {
#ifdef DBG
        char szName[5];
        if (m_fDebugOn)
        {
            szName[4] = 0;
            strncpy(szName,(char *)&m_pChunk->ckid,4);
            Trace(-1,"Error parsing %s, Read %ld of %ld\n",szName,m_pChunk->lRead,RIFF_ALIGN(m_pChunk->cksize));
        }
#endif
        // If we were in a component, it's okay to fail. Mark that fact by setting
        // m_fComponentFailed then properly pull out of the chunk so we can
        // continue reading.
        if (m_fInComponent) 
        {
            m_fComponentFailed = TRUE;
            // We don't need to check for first pass, because we must have gotten
            // that far. Instead, we just clean up from the failed chunk.
            // Note that this sets the hresult to S_OK, which is what we want.
            // Later, the caller needs to call ComponentFailed() to find out if
            // this error occured.
            *pHr = LeaveChunk();
        }
        else
        {
            // Clean up but leave the error code.
            LeaveChunk();
        }
    }
    return fMore && SUCCEEDED(*pHr);
}

BOOL CRiffParser::MoreChunks()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        if (m_pParent)
        {
            // Return TRUE if there's enough room for another chunk.
            return (m_pParent->lRead < (m_pParent->cksize - 8));
        }
        else
        {
            // This must be a top level chunk, in which case there would only be one to read.
            return (m_pChunk->lRead == 0);
        }
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return false;
}

HRESULT CRiffParser::EnterChunk()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Read the chunk header
	    HRESULT hr = m_pStream->Read(m_pChunk, 2 * sizeof(DWORD), NULL);
        if (SUCCEEDED(hr))
        {
#ifdef DBG
            char szName[5];
            if (m_fDebugOn)
            {
                szName[4] = 0;
                strncpy(szName,(char *)&m_pChunk->ckid,4);
                ULARGE_INTEGER ul;
                LARGE_INTEGER li;
                li.QuadPart = 0;
                HRESULT hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);

                Trace(-1,"Entering %s, Length %ld, File position is %ld",szName,m_pChunk->cksize,(long)ul.QuadPart);
            }
#endif
            // Clear bytes read field.
            m_pChunk->lRead = 0;
            // Check to see if this is a container (LIST or RIFF.)
            if((m_pChunk->ckid == FOURCC_RIFF) || (m_pChunk->ckid == FOURCC_LIST))
		    {
			    hr = m_pStream->Read(&m_pChunk->fccType, sizeof(DWORD), NULL);
                if (SUCCEEDED(hr))
                {
                    m_pChunk->lRead += sizeof(DWORD);
#ifdef DBG
                    if (m_fDebugOn)
                    {
                        strncpy(szName,(char *)&m_pChunk->fccType,4);
                        Trace(-1," Type %s",szName);
                    }
#endif
                }
		    }
#ifdef DBG
            if (m_fDebugOn) Trace(-1,"\n");
#endif
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::LeaveChunk()

{
    HRESULT hr = S_OK;
    assert(m_pChunk);
    if (m_pChunk)
    {
        m_fInComponent = false;
        // Get the rounded up size of the chunk.
        long lSize = RIFF_ALIGN(m_pChunk->cksize);
        // Increment the parent's count of bytes read so far.
        if (m_pParent)
        {
            m_pParent->lRead += lSize + (2 * sizeof(DWORD));
            if (m_pParent->lRead > RIFF_ALIGN(m_pParent->cksize))
            {
                hr = DMUS_E_DESCEND_CHUNK_FAIL; // Goofy error name, but need to be consistent with previous versions.
            }
        }
#ifdef DBG
        char szName[5];
        if (m_fDebugOn)
        {
            szName[4] = 0;
            strncpy(szName,(char *)&m_pChunk->ckid,4);
            ULARGE_INTEGER ul;
            LARGE_INTEGER li;
            li.QuadPart = 0;
            HRESULT hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);

            Trace(-1,"Leaving %s, Read %ld of %ld, File Position is %ld\n",szName,m_pChunk->lRead,lSize,(long)ul.QuadPart);
        }
#endif
        // If we haven't actually read this entire chunk, seek to the end of it.
        if (m_pChunk->lRead < lSize)
        {
            LARGE_INTEGER li;
            li.QuadPart = lSize - m_pChunk->lRead;
            hr = m_pStream->Seek(li,STREAM_SEEK_CUR,NULL);
            // There's a chance it could fail because we are at the end of file with an odd length chunk.
            if (FAILED(hr))
            {
                // If there's a parent, see if this is the last chunk.
                if (m_pParent)
                {
                    if (m_pParent->cksize >= (m_pParent->lRead - 1))
                    {
                        hr = S_OK;
                    }
                }
                // Else, see if we are an odd length.
                else if (m_pChunk->cksize & 1)
                {
                    hr = S_OK;
                }
            }
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::Read(void *pv,ULONG cb)

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Make sure we don't read beyond the end of the chunk.
        if (((long)cb + m_pChunk->lRead) > m_pChunk->cksize)
        {
            cb -= (cb - (m_pChunk->cksize - m_pChunk->lRead));
        }
        HRESULT hr = m_pStream->Read(pv,cb,NULL);
        if (SUCCEEDED(hr))
        {
            m_pChunk->lRead += cb;
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::Skip(ULONG ulBytes)

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Make sure we don't scan beyond the end of the chunk.
        if (((long)ulBytes + m_pChunk->lRead) > m_pChunk->cksize)
        {
            ulBytes -= (ulBytes - (m_pChunk->cksize - m_pChunk->lRead));
        }
        LARGE_INTEGER li;
        li.HighPart = 0;
		li.LowPart = ulBytes;
        HRESULT hr = m_pStream->Seek( li, STREAM_SEEK_CUR, NULL );
        if (SUCCEEDED(hr))
        {
            m_pChunk->lRead += ulBytes;
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}


void CRiffParser::MarkPosition()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        LARGE_INTEGER li;
        ULARGE_INTEGER ul;
        li.HighPart = 0;
        li.LowPart = 0;
        m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);
        m_pChunk->liPosition.QuadPart = (LONGLONG) ul.QuadPart;
    }
}

HRESULT CRiffParser::SeekBack()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Move back to the start of the current chunk. Also, store the
        // absolute position because that will be useful later when we need to seek to the
        // end of this chunk.
        ULARGE_INTEGER ul;
        LARGE_INTEGER li;
        li.QuadPart = 0;
        li.QuadPart -= (m_pChunk->lRead + (2 * sizeof(DWORD))); 
        HRESULT hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);
        // Now, save the absolute position for the end of this chunk.
        m_pChunk->liPosition.QuadPart = ul.QuadPart + 
            RIFF_ALIGN(m_pChunk->cksize) + (2 * sizeof(DWORD));
        m_pChunk->lRead = 0;
        return hr;
    }
    return E_FAIL;
}

HRESULT CRiffParser::SeekForward()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        m_pChunk->lRead = RIFF_ALIGN(m_pChunk->cksize);
        return m_pStream->Seek(m_pChunk->liPosition, STREAM_SEEK_SET, NULL);
    }
    return E_FAIL;
}


HRESULT CInfo::GetDescriptor(LPDMUS_OBJECTDESC pDesc,REFGUID rguidClassID)
{
    memset( pDesc, 0, sizeof(DMUS_OBJECTDESC));
    pDesc->dwSize = sizeof(DMUS_OBJECTDESC);
    pDesc->guidClass = rguidClassID;
    pDesc->guidObject = m_guidObject;
    pDesc->ftDate = m_ftDate;
    pDesc->vVersion = m_vVersion;
    memcpy( pDesc->wszName, m_wszName, sizeof(m_wszName) );
    memcpy( pDesc->wszCategory, m_wszCategory, sizeof(m_wszCategory) );
    memcpy( pDesc->wszFileName, m_wszFileName, sizeof(m_wszFileName) );
    pDesc->dwValidData = ( m_dwValidData | DMUS_OBJ_CLASS );
    return S_OK;
}

HRESULT CInfo::SetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    HRESULT hr = E_INVALIDARG;
    DWORD dw = 0;
    if( pDesc->dwSize >= sizeof(DMUS_OBJECTDESC) )
    {
        if(pDesc->dwValidData & DMUS_OBJ_CLASS)
        {
            dw |= DMUS_OBJ_CLASS;
        }
        if(pDesc->dwValidData & DMUS_OBJ_LOADED)
        {
            dw |= DMUS_OBJ_LOADED;
        }
        if( pDesc->dwValidData & DMUS_OBJ_OBJECT )
        {
            m_guidObject = pDesc->guidObject;
            dw |= DMUS_OBJ_OBJECT;
        }
        if( pDesc->dwValidData & DMUS_OBJ_NAME )
        {
            memcpy( m_wszName, pDesc->wszName, sizeof(WCHAR)*DMUS_MAX_NAME );
            dw |= DMUS_OBJ_NAME;
        }
        if( pDesc->dwValidData & DMUS_OBJ_CATEGORY )
        {
            memcpy( m_wszCategory, pDesc->wszCategory, sizeof(WCHAR)*DMUS_MAX_CATEGORY );
            dw |= DMUS_OBJ_CATEGORY;
        }
        if( ( pDesc->dwValidData & DMUS_OBJ_FILENAME ) ||
            ( pDesc->dwValidData & DMUS_OBJ_FULLPATH ) )
        {
            memcpy( m_wszFileName, pDesc->wszFileName, sizeof(WCHAR)*DMUS_MAX_FILENAME );
            dw |= (pDesc->dwValidData & (DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH));
        }
        if( pDesc->dwValidData & DMUS_OBJ_VERSION )
        {
            m_vVersion = pDesc->vVersion;
            dw |= DMUS_OBJ_VERSION;
        }
        if( pDesc->dwValidData & DMUS_OBJ_DATE )
        {
            m_ftDate = pDesc->ftDate;
            dw |= DMUS_OBJ_DATE;
        }
        m_dwValidData |= dw;
        if( pDesc->dwValidData & (~dw) )
        {
            Trace(2,"Warning: SetDescriptor was not able to handle all passed fields, dwValidData bits %lx.\n",pDesc->dwValidData & (~dw));
            hr = S_FALSE; // there were extra fields we didn't parse;
            pDesc->dwValidData = dw;
        }
        else
        {
            hr = S_OK;
        }
    }
    else
    {
        Trace(1,"Error: Size of descriptor too large to parse.\n");
    }
    return hr;
}


HRESULT CInfo::ParseDescriptor(LPSTREAM pIStream, LPDMUS_OBJECTDESC pDesc, 
                                     DWORD dwRIFFID, REFGUID guidClassID) 
{
    CRiffParser Parser(pIStream);
    RIFFIO ckMain;
    RIFFIO ckNext;
    RIFFIO ckUNFO;
    HRESULT hr = S_OK;
    DWORD dwValidData;

    Parser.EnterList(&ckMain);  
    if (Parser.NextChunk(&hr) && (ckMain.fccType == dwRIFFID))
    {
        dwValidData = DMUS_OBJ_CLASS;
        pDesc->guidClass = guidClassID;
        Parser.EnterList(&ckNext);
        while(Parser.NextChunk(&hr))
        {
            switch(ckNext.ckid)
            {
            case FOURCC_DLID:
            case DMUS_FOURCC_GUID_CHUNK:
                hr = Parser.Read( &pDesc->guidObject, sizeof(GUID) );
                dwValidData |= DMUS_OBJ_OBJECT;
                break;
            case FOURCC_VERS:
                hr = Parser.Read( &pDesc->vVersion, sizeof(DMUS_VERSION) );
                dwValidData |= DMUS_OBJ_VERSION;
                break;
            case DMUS_FOURCC_CATEGORY_CHUNK:
                hr = Parser.Read( &pDesc->wszCategory, sizeof(pDesc->wszCategory) );
                dwValidData |= DMUS_OBJ_CATEGORY;
                break;
            case DMUS_FOURCC_DATE_CHUNK:
                hr = Parser.Read( &pDesc->ftDate, sizeof(FILETIME) );
                dwValidData |= DMUS_OBJ_DATE;
                break;
            case FOURCC_LIST:
                switch(ckNext.fccType)
                {
                case DMUS_FOURCC_UNFO_LIST:
                    Parser.EnterList(&ckUNFO);
                    while (Parser.NextChunk(&hr))
                    {
                        if (ckUNFO.ckid == DMUS_FOURCC_UNAM_CHUNK)
                        {
                            hr = Parser.Read(&pDesc->wszName, sizeof(pDesc->wszName));
                            dwValidData |= DMUS_OBJ_NAME;
                        }
                    }
                    Parser.LeaveList();
                    break;            
                    // Waves and DLS files have ascii info chunks...
                case DMUS_FOURCC_INFO_LIST:
                    Parser.EnterList(&ckUNFO);
                    while (Parser.NextChunk(&hr))
                    {
                        if ( ckUNFO.ckid == mmioFOURCC('I','N','A','M'))
                        {
			                char szName[DMUS_MAX_NAME];
			                hr = Parser.Read(szName, DMUS_MAX_NAME);
			                if(SUCCEEDED(hr))
			                {
				                MultiByteToWideChar(CP_ACP, 0, szName, -1, pDesc->wszName, sizeof(pDesc->wszName));
				                dwValidData |= DMUS_OBJ_NAME;
			                }
                            break;
                        }
                    }
                    Parser.LeaveList();
                    break;
                }
                break;
            }
        }
        Parser.LeaveList();
    }
    else
    {
        Trace(1,"Error: Parsing file - invalid file format\n");
        hr = DMUS_E_CHUNKNOTFOUND;
    }

    if (SUCCEEDED(hr))
    {
        pDesc->dwValidData = dwValidData;
    }
    return hr;
}

HRESULT CInfo::ReadChunk(CRiffParser *pParser,DWORD dwID)

{
    HRESULT hr = S_OK;
    RIFFIO ckChild;
    switch (dwID)
    {
    case FOURCC_DLID:
    case DMUS_FOURCC_GUID_CHUNK:
        hr = pParser->Read( &m_guidObject, sizeof(GUID) );
        m_dwValidData |= DMUS_OBJ_OBJECT;
        break;
    case DMUS_FOURCC_VERSION_CHUNK:
        hr = pParser->Read( &m_vVersion, sizeof(DMUS_VERSION) );
        m_dwValidData |= DMUS_OBJ_VERSION;
        break;
    case DMUS_FOURCC_CATEGORY_CHUNK:
        hr = pParser->Read( &m_wszCategory, sizeof(WCHAR)*DMUS_MAX_CATEGORY );
        m_dwValidData |= DMUS_OBJ_CATEGORY;
        break;
    case DMUS_FOURCC_DATE_CHUNK:
        hr = pParser->Read( &m_ftDate, sizeof(FILETIME) );
        m_dwValidData |= DMUS_OBJ_DATE;
        break;
    case DMUS_FOURCC_UNFO_LIST:
        pParser->EnterList(&ckChild);
        while (pParser->NextChunk(&hr))
        {
            if ( ckChild.ckid == DMUS_FOURCC_UNAM_CHUNK)
            {
                hr = pParser->Read(&m_wszName, sizeof(m_wszName));
                m_dwValidData |= DMUS_OBJ_NAME;
            }
        }
        pParser->LeaveList();
        break;
        // Waves and DLS files have ascii info chunks...
    case DMUS_FOURCC_INFO_LIST:
        pParser->EnterList(&ckChild);
        while (pParser->NextChunk(&hr))
        {
            if ( ckChild.ckid == mmioFOURCC('I','N','A','M'))
            {
			    char szName[DMUS_MAX_NAME];
			    hr = pParser->Read(szName, DMUS_MAX_NAME);
			    if(SUCCEEDED(hr))
			    {
				    MultiByteToWideChar(CP_ACP, 0, szName, -1, m_wszName, DMUS_MAX_NAME);
				    m_dwValidData |= DMUS_OBJ_NAME;
			    }
                break;
            }
        }
        pParser->LeaveList();
        break;
    }
    return hr;
}


void CInfo::Init()

{
    memset(this,0,sizeof(CInfo));
    m_dwValidData = DMUS_OBJ_CLASS; // upon creation, only this data is valid
}


HRESULT CLinkParser::ReadReference(CRiffParser *pParser, LPDMUS_OBJECTDESC pDesc)

{
    HRESULT hr = S_OK;
    pDesc->dwValidData = 0;
    RIFFIO ckNext;
    pParser->EnterList(&ckNext);
    while(pParser->NextChunk(&hr))
    {
        switch(ckNext.ckid)
        {
        case  DMUS_FOURCC_REF_CHUNK:
            DMUS_IO_REFERENCE ioDMRef;
            hr = pParser->Read(&ioDMRef, sizeof(DMUS_IO_REFERENCE));
            pDesc->guidClass = ioDMRef.guidClassID;
            pDesc->dwValidData |= ioDMRef.dwValidData;
            pDesc->dwValidData |= DMUS_OBJ_CLASS;
            break;
        case FOURCC_DLID:
        case DMUS_FOURCC_GUID_CHUNK:
            hr = pParser->Read(&(pDesc->guidObject), sizeof(GUID));
            pDesc->dwValidData |=  DMUS_OBJ_OBJECT;
            break;
        case DMUS_FOURCC_NAME_CHUNK:
            hr = pParser->Read(pDesc->wszName, sizeof(pDesc->wszName));
            pDesc->dwValidData |=  DMUS_OBJ_NAME;
            break;
        case DMUS_FOURCC_FILE_CHUNK:
            hr = pParser->Read(pDesc->wszFileName, sizeof(pDesc->wszFileName));
            pDesc->dwValidData |=  DMUS_OBJ_FILENAME;
            break;
        case DMUS_FOURCC_DATE_CHUNK:
            hr = pParser->Read(&(pDesc->ftDate), sizeof(FILETIME));
            pDesc->dwValidData |=  DMUS_OBJ_DATE;
            break;
        case DMUS_FOURCC_CATEGORY_CHUNK:
            hr = pParser->Read(pDesc->wszCategory, sizeof(pDesc->wszCategory));
            pDesc->dwValidData |=  DMUS_OBJ_CATEGORY;
            break;
        case DMUS_FOURCC_VERSION_CHUNK:
            DMUS_IO_VERSION ioDMObjVer;
            hr = pParser->Read(&ioDMObjVer, sizeof(DMUS_IO_VERSION));
            pDesc->vVersion.dwVersionMS = ioDMObjVer.dwVersionMS;
            pDesc->vVersion.dwVersionLS = ioDMObjVer.dwVersionLS;
            pDesc->dwValidData |= DMUS_OBJ_VERSION;
            break;
        }
    }
    pParser->LeaveList();
    return hr;
}

HRESULT CLinkParser::LoadReferencedObject(CRiffParser *pParser,void **ppObject,REFGUID rguidIID,BOOL fDontCache)

{
    IDirectMusicGetLoader *pIGetLoader;
    HRESULT hr = pParser->GetStream()->QueryInterface( IID_IDirectMusicGetLoader,(void **) &pIGetLoader );
    if (SUCCEEDED(hr))
    {
        IDirectMusicLoader* pLoader = NULL;
        hr = pIGetLoader->GetLoader(&pLoader);
        pIGetLoader->Release();
        if (SUCCEEDED(hr))
        {
            DMUS_OBJECTDESC Desc;
            hr = ReadReference(pParser,&Desc);
            if(SUCCEEDED(hr))
            {
                Desc.dwSize = sizeof(DMUS_OBJECTDESC);
                hr = pLoader->GetObject(&Desc, rguidIID, ppObject);
                // Once we get the object, we need to ensure that the same object is never
                // connected up to any other songs (or this one, too.)
                // So, we ensure that the loader doesn't keep it around.
                if (SUCCEEDED(hr) && fDontCache)
                {
#ifdef DXAPI
                    IDirectMusicObject *pObject;
                    if (SUCCEEDED(((IUnknown *) (*ppObject))->QueryInterface(IID_IDirectMusicObject,(void **)&pObject)))
                    {
                        pLoader->ReleaseObject(pObject);
                        pObject->Release();
                    }
#else
                    pLoader->ReleaseObjectByUnknown((IUnknown *) (*ppObject));
#endif
                }
            }
            pLoader->Release();
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\imediaobjectparams.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Mon Nov 29 16:13:05 1999
 */
/* Compiler settings for C:\dx8\dmusic\dmime\imediaobjectparams.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H

#ifdef XBOX
#include <xtl.h>
#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define _WINGDI_
#else // XBOX
#include <windows.h>
#endif // XBOX

#ifndef _DUMMY_LPMSG
#define _DUMMY_LPMSG
typedef void* LPMSG;
#endif
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __imediaobjectparams_h__
#define __imediaobjectparams_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IMediaParamInfo_FWD_DEFINED__
#define __IMediaParamInfo_FWD_DEFINED__
typedef interface IMediaParamInfo IMediaParamInfo;
#endif 	/* __IMediaParamInfo_FWD_DEFINED__ */


#ifndef __IMediaParams_FWD_DEFINED__
#define __IMediaParams_FWD_DEFINED__
typedef interface IMediaParams IMediaParams;
#endif 	/* __IMediaParams_FWD_DEFINED__ */


#ifndef __IMediaParamsRecordNotify_FWD_DEFINED__
#define __IMediaParamsRecordNotify_FWD_DEFINED__
typedef interface IMediaParamsRecordNotify IMediaParamsRecordNotify;
#endif 	/* __IMediaParamsRecordNotify_FWD_DEFINED__ */


#ifndef __IMediaParamsRecord_FWD_DEFINED__
#define __IMediaParamsRecord_FWD_DEFINED__
typedef interface IMediaParamsRecord IMediaParamsRecord;
#endif 	/* __IMediaParamsRecord_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "strmif.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_imediaobjectparams_0000 */
/* [local] */ 

typedef float MP_DATA;

typedef 
enum _MP_Type
    {	MPT_INT	= 0,
	MPT_FLOAT	= MPT_INT + 1,
	MPT_BOOL	= MPT_FLOAT + 1,
	MPT_ENUM	= MPT_BOOL + 1,
	MPT_MAX	= MPT_ENUM + 1
    }	MP_TYPE;

#define	MPBOOL_TRUE	( 1 )

#define	MPBOOL_FALSE	( 0 )

typedef 
enum _MP_CURVE_TYPE
    {	MP_CURVE_JUMP	= 0x1,
	MP_CURVE_LINEAR	= 0x2,
	MP_CURVE_SQUARE	= 0x4,
	MP_CURVE_INVSQUARE	= 0x8,
	MP_CURVE_SINE	= 0x10,
	MP_CURVE_CURRENTVAL	= 0x8000
    }	MP_CURVE_TYPE;

typedef DWORD MP_CAPS;

#define	MP_CAPS_CURVE_JUMP	( MP_CURVE_JUMP )

#define	MP_CAPS_CURVE_LINEAR	( MP_CURVE_LINEAR )

#define	MP_CAPS_CURVE_SQUARE	( MP_CURVE_SQUARE )

#define	MP_CAPS_CURVE_INVSQUARE	( MP_CURVE_INVSQUARE )

#define	MP_CAPS_CURVE_SINE	( MP_CURVE_SINE )

typedef struct  _MP_PARAMINFO
    {
    MP_TYPE mpType;
    MP_CAPS mopCaps;
    MP_DATA mpdMinValue;
    MP_DATA mpdMaxValue;
    MP_DATA mpdNeutralValue;
    WCHAR szUnitText[ 32 ];
    WCHAR szLabel[ 32 ];
    }	MP_PARAMINFO;

typedef DWORD DWORD;

#define	DWORD_ALLPARAMS	( -1 )

typedef DWORD MP_TIMEDATA;

DEFINE_GUID(GUID_TIME_REFERNCE,
0x93ad712b, 0xdaa0, 0x4ffe, 0xbc, 0x81, 0xb0, 0xce, 0x50, 0xf, 0xcd, 0xd9);
DEFINE_GUID(GUID_TIME_MUSIC,
0x574c49d, 0x5b04, 0x4b15, 0xa5, 0x42, 0xae, 0x28, 0x20, 0x30, 0x11, 0x7b);
DEFINE_GUID(GUID_TIME_SAMPLES,
0xa8593d05, 0xc43, 0x4984, 0x9a, 0x63, 0x97, 0xaf, 0x9e, 0x2, 0xc4, 0xc0);
typedef DWORD MP_FLAGS;

#define	MPF_ENVLP_STANDARD	( 0 )

#define	MPF_ENVLP_BEGIN_CURRENTVAL	( 0x1 )

typedef struct  _MP_ENVELOPE
    {
    REFERENCE_TIME rtStart;
    REFERENCE_TIME rtEnd;
    MP_DATA valStart;
    MP_DATA valEnd;
    MP_CURVE_TYPE iCurve;
    MP_FLAGS flags;
    }	MP_ENVELOPE;

#define	MPF_PUNCHIN_REFTIME	( 0 )

#define	MPF_PUNCHIN_NOW	( 0x1 )



extern RPC_IF_HANDLE __MIDL_itf_imediaobjectparams_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_imediaobjectparams_0000_v0_0_s_ifspec;

#ifndef __IMediaParamInfo_INTERFACE_DEFINED__
#define __IMediaParamInfo_INTERFACE_DEFINED__

/* interface IMediaParamInfo */
/* [version][uuid][object] */ 


EXTERN_C const IID IID_IMediaParamInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6d6cbb60-a223-44aa-842f-a2f06750be6d")
    IMediaParamInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetParamCount( 
            /* [out] */ DWORD __RPC_FAR *pdwParams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParamInfo( 
            /* [in] */ DWORD dwParamIndex,
            /* [out] */ MP_PARAMINFO __RPC_FAR *pInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParamText( 
            /* [in] */ DWORD dwParamIndex,
            /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *ppwchText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNumTimeFormats( 
            /* [out] */ DWORD __RPC_FAR *pdwNumTimeFormats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSupportedTimeFormat( 
            /* [in] */ DWORD dwFormatIndex,
            /* [out] */ GUID __RPC_FAR *pguidTimeFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentTimeFormat( 
            /* [out] */ GUID __RPC_FAR *pguidTimeFormat,
            /* [out] */ MP_TIMEDATA __RPC_FAR *pTimeData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaParamInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMediaParamInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMediaParamInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMediaParamInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetParamCount )( 
            IMediaParamInfo __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwParams);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetParamInfo )( 
            IMediaParamInfo __RPC_FAR * This,
            /* [in] */ DWORD dwParamIndex,
            /* [out] */ MP_PARAMINFO __RPC_FAR *pInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetParamText )( 
            IMediaParamInfo __RPC_FAR * This,
            /* [in] */ DWORD dwParamIndex,
            /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *ppwchText);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNumTimeFormats )( 
            IMediaParamInfo __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwNumTimeFormats);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSupportedTimeFormat )( 
            IMediaParamInfo __RPC_FAR * This,
            /* [in] */ DWORD dwFormatIndex,
            /* [out] */ GUID __RPC_FAR *pguidTimeFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCurrentTimeFormat )( 
            IMediaParamInfo __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *pguidTimeFormat,
            /* [out] */ MP_TIMEDATA __RPC_FAR *pTimeData);
        
        END_INTERFACE
    } IMediaParamInfoVtbl;

    interface IMediaParamInfo
    {
        CONST_VTBL struct IMediaParamInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaParamInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMediaParamInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMediaParamInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMediaParamInfo_GetParamCount(This,pdwParams)	\
    (This)->lpVtbl -> GetParamCount(This,pdwParams)

#define IMediaParamInfo_GetParamInfo(This,dwParamIndex,pInfo)	\
    (This)->lpVtbl -> GetParamInfo(This,dwParamIndex,pInfo)

#define IMediaParamInfo_GetParamText(This,dwParamIndex,ppwchText)	\
    (This)->lpVtbl -> GetParamText(This,dwParamIndex,ppwchText)

#define IMediaParamInfo_GetNumTimeFormats(This,pdwNumTimeFormats)	\
    (This)->lpVtbl -> GetNumTimeFormats(This,pdwNumTimeFormats)

#define IMediaParamInfo_GetSupportedTimeFormat(This,dwFormatIndex,pguidTimeFormat)	\
    (This)->lpVtbl -> GetSupportedTimeFormat(This,dwFormatIndex,pguidTimeFormat)

#define IMediaParamInfo_GetCurrentTimeFormat(This,pguidTimeFormat,pTimeData)	\
    (This)->lpVtbl -> GetCurrentTimeFormat(This,pguidTimeFormat,pTimeData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMediaParamInfo_GetParamCount_Proxy( 
    IMediaParamInfo __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwParams);


void __RPC_STUB IMediaParamInfo_GetParamCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaParamInfo_GetParamsInfo_Proxy( 
    IMediaParamInfo __RPC_FAR * This,
    /* [in] */ DWORD dwParamIndex,
    /* [out] */ MP_PARAMINFO __RPC_FAR *pInfo);


void __RPC_STUB IMediaParamInfo_GetParamsInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaParamInfo_GetParamText_Proxy( 
    IMediaParamInfo __RPC_FAR * This,
    /* [in] */ DWORD dwParamIndex,
    /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *ppwchText);


void __RPC_STUB IMediaParamInfo_GetParamText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaParamInfo_GetNumTimeFormats_Proxy( 
    IMediaParamInfo __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwNumTimeFormats);


void __RPC_STUB IMediaParamInfo_GetNumTimeFormats_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaParamInfo_GetSupportedTimeFormat_Proxy( 
    IMediaParamInfo __RPC_FAR * This,
    /* [in] */ DWORD dwFormatIndex,
    /* [out] */ GUID __RPC_FAR *pguidTimeFormat);


void __RPC_STUB IMediaParamInfo_GetSupportedTimeFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaParamInfo_GetCurrentTimeFormat_Proxy( 
    IMediaParamInfo __RPC_FAR * This,
    /* [out] */ GUID __RPC_FAR *pguidTimeFormat,
    /* [out] */ MP_TIMEDATA __RPC_FAR *pTimeData);


void __RPC_STUB IMediaParamInfo_GetCurrentTimeFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMediaParamInfo_INTERFACE_DEFINED__ */


#ifndef __IMediaParams_INTERFACE_DEFINED__
#define __IMediaParams_INTERFACE_DEFINED__

/* interface IMediaParams */
/* [version][uuid][object] */ 


EXTERN_C const IID IID_IMediaParams;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6d6cbb61-a223-44aa-842f-a2f06750be6e")
    IMediaParams : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetParam( 
            /* [in] */ DWORD dwParamIndex,
            /* [out] */ MP_DATA __RPC_FAR *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetParam( 
            /* [in] */ DWORD dwParamIndex,
            /* [in] */ MP_DATA value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddEnvelope( 
            /* [in] */ DWORD dwParamIndex,
            /* [in] */ DWORD cPoints,
            /* [in] */ MP_ENVELOPE __RPC_FAR *pEnvelope,
            /* [out] */ DWORD __RPC_FAR *pdwIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FlushEnvelope( 
            /* [in] */ DWORD dwParamIndex,
            /* [in] */ REFERENCE_TIME refTimeStart,
            /* [in] */ REFERENCE_TIME refTimeEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTimeFormat( 
            /* [in] */ GUID guidTimeFormat,
            /* [in] */ MP_TIMEDATA mpTimeData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaParamsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMediaParams __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMediaParams __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMediaParams __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetParam )( 
            IMediaParams __RPC_FAR * This,
            /* [in] */ DWORD dwParamIndex,
            /* [out] */ MP_DATA __RPC_FAR *pValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetParam )( 
            IMediaParams __RPC_FAR * This,
            /* [in] */ DWORD dwParamIndex,
            /* [in] */ MP_DATA value);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddEnvelope )( 
            IMediaParams __RPC_FAR * This,
            /* [in] */ DWORD dwParamIndex,
            /* [in] */ DWORD cPoints,
            /* [in] */ MP_ENVELOPE __RPC_FAR *pEnvelope,
            /* [out] */ DWORD __RPC_FAR *pdwIndex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FlushEnvelope )( 
            IMediaParams __RPC_FAR * This,
            /* [in] */ DWORD dwParamIndex,
            /* [in] */ REFERENCE_TIME refTimeStart,
            /* [in] */ REFERENCE_TIME refTimeEnd);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTimeFormat )( 
            IMediaParams __RPC_FAR * This,
            /* [in] */ GUID guidTimeFormat,
            /* [in] */ MP_TIMEDATA mpTimeData);
        
        END_INTERFACE
    } IMediaParamsVtbl;

    interface IMediaParams
    {
        CONST_VTBL struct IMediaParamsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaParams_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMediaParams_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMediaParams_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMediaParams_GetParam(This,dwParamIndex,pValue)	\
    (This)->lpVtbl -> GetParam(This,dwParamIndex,pValue)

#define IMediaParams_SetParam(This,dwParamIndex,value)	\
    (This)->lpVtbl -> SetParam(This,dwParamIndex,value)

#define IMediaParams_AddEnvelope(This,dwParamIndex,cPoints,pEnvelope,pdwIndex)	\
    (This)->lpVtbl -> AddEnvelope(This,dwParamIndex,cPoints,pEnvelope,pdwIndex)

#define IMediaParams_FlushEnvelope(This,dwParamIndex,refTimeStart,refTimeEnd)	\
    (This)->lpVtbl -> FlushEnvelope(This,dwParamIndex,refTimeStart,refTimeEnd)

#define IMediaParams_SetTimeFormat(This,guidTimeFormat,mpTimeData)	\
    (This)->lpVtbl -> SetTimeFormat(This,guidTimeFormat,mpTimeData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMediaParams_GetParam_Proxy( 
    IMediaParams __RPC_FAR * This,
    /* [in] */ DWORD dwParamIndex,
    /* [out] */ MP_DATA __RPC_FAR *pValue);


void __RPC_STUB IMediaParams_GetParam_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaParams_SetParam_Proxy( 
    IMediaParams __RPC_FAR * This,
    /* [in] */ DWORD dwParamIndex,
    /* [in] */ MP_DATA value);


void __RPC_STUB IMediaParams_SetParam_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaParams_AddEnvelope_Proxy( 
    IMediaParams __RPC_FAR * This,
    /* [in] */ DWORD dwParamIndex,
    /* [in] */ DWORD cPoints,
    /* [in] */ MP_ENVELOPE __RPC_FAR *pEnvelope,
    /* [out] */ DWORD __RPC_FAR *pdwIndex);


void __RPC_STUB IMediaParams_AddEnvelope_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaParams_FlushEnvelope_Proxy( 
    IMediaParams __RPC_FAR * This,
    /* [in] */ DWORD dwParamIndex,
    /* [in] */ REFERENCE_TIME refTimeStart,
    /* [in] */ REFERENCE_TIME refTimeEnd);


void __RPC_STUB IMediaParams_FlushEnvelope_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaParams_SetTimeFormat_Proxy( 
    IMediaParams __RPC_FAR * This,
    /* [in] */ GUID guidTimeFormat,
    /* [in] */ MP_TIMEDATA mpTimeData);


void __RPC_STUB IMediaParams_SetTimeFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMediaParams_INTERFACE_DEFINED__ */


#ifndef __IMediaParamsRecordNotify_INTERFACE_DEFINED__
#define __IMediaParamsRecordNotify_INTERFACE_DEFINED__

/* interface IMediaParamsRecordNotify */
/* [version][uuid][object] */ 


EXTERN_C const IID IID_IMediaParamsRecordNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fea74878-4e39-4267-8a17-6aaf0536ff7c")
    IMediaParamsRecordNotify : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitRecording( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PunchedIn( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PunchedOut( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndRecording( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ParamChanged( 
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD cNumPoints,
            /* [in] */ MP_ENVELOPE __RPC_FAR *pEnvelope) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaParamsRecordNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMediaParamsRecordNotify __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMediaParamsRecordNotify __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMediaParamsRecordNotify __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitRecording )( 
            IMediaParamsRecordNotify __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PunchedIn )( 
            IMediaParamsRecordNotify __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PunchedOut )( 
            IMediaParamsRecordNotify __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndRecording )( 
            IMediaParamsRecordNotify __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ParamChanged )( 
            IMediaParamsRecordNotify __RPC_FAR * This,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD cNumPoints,
            /* [in] */ MP_ENVELOPE __RPC_FAR *pEnvelope);
        
        END_INTERFACE
    } IMediaParamsRecordNotifyVtbl;

    interface IMediaParamsRecordNotify
    {
        CONST_VTBL struct IMediaParamsRecordNotifyVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaParamsRecordNotify_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMediaParamsRecordNotify_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMediaParamsRecordNotify_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMediaParamsRecordNotify_InitRecording(This)	\
    (This)->lpVtbl -> InitRecording(This)

#define IMediaParamsRecordNotify_PunchedIn(This)	\
    (This)->lpVtbl -> PunchedIn(This)

#define IMediaParamsRecordNotify_PunchedOut(This)	\
    (This)->lpVtbl -> PunchedOut(This)

#define IMediaParamsRecordNotify_EndRecording(This)	\
    (This)->lpVtbl -> EndRecording(This)

#define IMediaParamsRecordNotify_ParamChanged(This,dwIndex,cNumPoints,pEnvelope)	\
    (This)->lpVtbl -> ParamChanged(This,dwIndex,cNumPoints,pEnvelope)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMediaParamsRecordNotify_InitRecording_Proxy( 
    IMediaParamsRecordNotify __RPC_FAR * This);


void __RPC_STUB IMediaParamsRecordNotify_InitRecording_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaParamsRecordNotify_PunchedIn_Proxy( 
    IMediaParamsRecordNotify __RPC_FAR * This);


void __RPC_STUB IMediaParamsRecordNotify_PunchedIn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaParamsRecordNotify_PunchedOut_Proxy( 
    IMediaParamsRecordNotify __RPC_FAR * This);


void __RPC_STUB IMediaParamsRecordNotify_PunchedOut_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaParamsRecordNotify_EndRecording_Proxy( 
    IMediaParamsRecordNotify __RPC_FAR * This);


void __RPC_STUB IMediaParamsRecordNotify_EndRecording_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaParamsRecordNotify_ParamChanged_Proxy( 
    IMediaParamsRecordNotify __RPC_FAR * This,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD cNumPoints,
    /* [in] */ MP_ENVELOPE __RPC_FAR *pEnvelope);


void __RPC_STUB IMediaParamsRecordNotify_ParamChanged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMediaParamsRecordNotify_INTERFACE_DEFINED__ */


#ifndef __IMediaParamsRecord_INTERFACE_DEFINED__
#define __IMediaParamsRecord_INTERFACE_DEFINED__

/* interface IMediaParamsRecord */
/* [version][uuid][object] */ 


EXTERN_C const IID IID_IMediaParamsRecord;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("21b64d1a-8e24-40f6-8797-44cc021b2a0a")
    IMediaParamsRecord : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitRecording( 
            /* [in] */ IMediaParamsRecordNotify __RPC_FAR *pINotify) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PunchIn( 
            /* [in] */ REFERENCE_TIME refTimeStart,
            /* [in] */ MP_FLAGS flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PunchOut( 
            /* [in] */ REFERENCE_TIME refTimeStopped) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndRecording( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaParamsRecordVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMediaParamsRecord __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMediaParamsRecord __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMediaParamsRecord __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitRecording )( 
            IMediaParamsRecord __RPC_FAR * This,
            /* [in] */ IMediaParamsRecordNotify __RPC_FAR *pINotify);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PunchIn )( 
            IMediaParamsRecord __RPC_FAR * This,
            /* [in] */ REFERENCE_TIME refTimeStart,
            /* [in] */ MP_FLAGS flags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PunchOut )( 
            IMediaParamsRecord __RPC_FAR * This,
            /* [in] */ REFERENCE_TIME refTimeStopped);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndRecording )( 
            IMediaParamsRecord __RPC_FAR * This);
        
        END_INTERFACE
    } IMediaParamsRecordVtbl;

    interface IMediaParamsRecord
    {
        CONST_VTBL struct IMediaParamsRecordVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaParamsRecord_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMediaParamsRecord_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMediaParamsRecord_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMediaParamsRecord_InitRecording(This,pINotify)	\
    (This)->lpVtbl -> InitRecording(This,pINotify)

#define IMediaParamsRecord_PunchIn(This,refTimeStart,flags)	\
    (This)->lpVtbl -> PunchIn(This,refTimeStart,flags)

#define IMediaParamsRecord_PunchOut(This,refTimeStopped)	\
    (This)->lpVtbl -> PunchOut(This,refTimeStopped)

#define IMediaParamsRecord_EndRecording(This)	\
    (This)->lpVtbl -> EndRecording(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMediaParamsRecord_InitRecording_Proxy( 
    IMediaParamsRecord __RPC_FAR * This,
    /* [in] */ IMediaParamsRecordNotify __RPC_FAR *pINotify);


void __RPC_STUB IMediaParamsRecord_InitRecording_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaParamsRecord_PunchIn_Proxy( 
    IMediaParamsRecord __RPC_FAR * This,
    /* [in] */ REFERENCE_TIME refTimeStart,
    /* [in] */ MP_FLAGS flags);


void __RPC_STUB IMediaParamsRecord_PunchIn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaParamsRecord_PunchOut_Proxy( 
    IMediaParamsRecord __RPC_FAR * This,
    /* [in] */ REFERENCE_TIME refTimeStopped);


void __RPC_STUB IMediaParamsRecord_PunchOut_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMediaParamsRecord_EndRecording_Proxy( 
    IMediaParamsRecord __RPC_FAR * This);


void __RPC_STUB IMediaParamsRecord_EndRecording_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMediaParamsRecord_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\paramtrk.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CParamControlTrack.
//

// This track holds curve information for automation (like automating sliders on a mixing board -- not OLE automation)
// of effects and tools in the audio path.

#pragma once

#ifdef XBOX
#include <xbox.h>
#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define _WINGDI_
#endif // XBOX

#include "trackhelp.h"
//#include "imediaobjectparams.h"
//#include "mediaobj.h" //  need to get this from public\sdk\inc
#include "medparam.h"
#include "dmusicf.h"

// {827F0437-9ED6-4107-8494-49976FF5B642}
DEFINE_GUID(IID_CParamControlTrack, 0x827f0437, 0x9ed6, 0x4107, 0x84, 0x94, 0x49, 0x97, 0x6f, 0xf5, 0xb6, 0x42);

class CParamControlTrack
  : public CBasicTrack
{
    // types for track data...

    struct ParamInfo
    {
        ParamInfo() : curves(NULL), curvesEnd(NULL), fAlreadyTracedPlaybackError(false) { Zero(&header); }
        ~ParamInfo() { delete[] curves; }

        DMUS_IO_PARAMCONTROLTRACK_PARAMHEADER header;
        DMUS_IO_PARAMCONTROLTRACK_CURVEINFO *curves; // pointer to first curve
        DMUS_IO_PARAMCONTROLTRACK_CURVEINFO *curvesEnd; // pointer one past last curve
        bool fAlreadyTracedPlaybackError;
    };

    struct ObjectInfo
    {
        ObjectInfo() : fAlreadyTracedPlaybackError(false) { Zero(&header); }

        DMUS_IO_PARAMCONTROLTRACK_OBJECTHEADER header;
        TList<ParamInfo> listParams;
        bool fAlreadyTracedPlaybackError;
    };

    struct ParamState // the state data we need to keep track of for each parameter we're controlling
    {
        ParamState() : pCurrentCurve(NULL), fLast(false), rtStartPointOfLastCurve(0) {}

        DMUS_IO_PARAMCONTROLTRACK_CURVEINFO *pCurrentCurve; // current seek pointer in the array of control points
        bool fLast; // true if the last envelope was sent successfully
        REFERENCE_TIME rtStartPointOfLastCurve; // time (in the object's time) of the start point of the last envelope we sent
        TList<REFERENCE_TIME> listStartTimes; // start times of all envelopes that have been sent 
    };

    struct StateData
    {
        StateData() : prgpIMediaParams(NULL), prgParam(NULL), fFlushInAbort(false) {}

        IMediaParams **prgpIMediaParams; // Array of size m_cObjects.
        ParamState *prgParam; // Array of size m_cParams.
        DWORD dwValidate;
        bool fFlushInAbort;
    };

public:
    CParamControlTrack(HRESULT *pHr) : m_MemTrack(DMTRACK_PARAM_TRACK), m_dwValidate(0), m_cObjects(0), m_cParams(0), CBasicTrack(&g_cComponent, CLSID_DirectMusicParamControlTrack) {}

    STDMETHOD(QueryInterface)(const IID &iid, void **ppv);

    STDMETHOD(Init)(IDirectMusicSegment *pSegment);
    STDMETHOD(Load)(IStream* pIStream);
    STDMETHOD(InitPlay)(
        IDirectMusicSegmentState *pSegmentState,
        IDirectMusicPerformance *pPerformance,
        void **ppStateData,
        DWORD dwTrackID,
        DWORD dwFlags);
    STDMETHOD(EndPlay)(void *pStateData);
    STDMETHOD(Clone)(MUSIC_TIME mtStart,MUSIC_TIME mtEnd,IDirectMusicTrack** ppTrack);
    virtual HRESULT PlayMusicOrClock(
        void *pStateData,
        MUSIC_TIME mtStart,
        MUSIC_TIME mtEnd,
        MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
        DWORD dwFlags,
        IDirectMusicPerformance* pPerf,
        IDirectMusicSegmentState* pSegSt,
        DWORD dwVirtualID,
        bool fClockTime);

    virtual HRESULT OnSegmentEnd(REFERENCE_TIME rtEnd, void *pStateData);

private:
    HRESULT LoadObject(SmartRef::RiffIter ri);
    HRESULT LoadParam(SmartRef::RiffIter ri, TList<ParamInfo> &listParams);
    HRESULT TrackToObjectTime(
        MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
        IDirectMusicPerformance* pPerf,
        bool fTrkClockTime,
        bool fObjClockTime,
        MUSIC_TIME mt,
        REFERENCE_TIME *rt);
    HRESULT PlayEnvelope(
        IMediaParams *pIMediaParams,
        MP_ENVELOPE_SEGMENT *pEnv,
        DMUS_IO_PARAMCONTROLTRACK_CURVEINFO *pPt,
        const ObjectInfo &obj,
        const ParamInfo &param,
        ParamState &paramstate,
        MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
        IDirectMusicPerformance* pPerf,
        bool fTrkClockTime,
        bool fObjClockTime);
    HRESULT PlayTruncatedEnvelope(
        MUSIC_TIME mtTruncStart,
        IMediaParams *pIMediaParams,
        MP_ENVELOPE_SEGMENT *pEnv,
        DMUS_IO_PARAMCONTROLTRACK_CURVEINFO *pPt,
        const ObjectInfo &obj,
        const ParamInfo &param,
        ParamState &paramstate,
        MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
        IDirectMusicPerformance* pPerf,
        bool fTrkClockTime,
        bool fObjClockTime,
        DWORD dwFlags);
        HRESULT InitStateData(
            StateData *pStateData,
            IDirectMusicSegmentState *pSegmentState);

    DWORD m_dwValidate; // Increment this counter in Load, causing the state data to synchonize with the new events
    TList<ObjectInfo> m_listObjects;
    int m_cObjects;
    int m_cParams;
    CMemTrack       m_MemTrack;             // For debug memory tracking.
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\pchime.h ===
#ifdef XBOX
//#include "dsoundb.h"
#include <xtl.h>
#include <xdbg.h>
#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define _WINGDI_
DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
#include <objbase.h> // Need IClassFactory
//#include <initguid.h>
#include <mmsystem.h>
#undef timeGetTime 
#define timeGetTime GetTickCount
#include "..\shared\dmusiccp.h"
#include "..\shared\xsoundp.h" // For GUID_All_Objects
extern "C" ULONG _cdecl DbgPrint(PCH Format, ...);
#include "..\shared\DoWork.h" 
extern CBossMan g_BossMan;
#else // XBOX
#include <windows.h>
#include <objbase.h> // Need IClassFactory
#include <mmsystem.h>
#endif // XBOX
#include "..\shared\xalloc.h"
#include <mmsystem.h>
#include <time.h>	// to seed random number generator
#include "cmixbins.h"
#include "urlmonhelper.h"
#include "..\shared\critsec.h"
#include "dmsegobj.h"
#include "dmime.h"
#include "song.h"
#include "dmgraph.h"
#include "dmprfdll.h"
#include "dmperf.h"
#include "dmusicip.h"
#include "dmusicf.h"
#include "..\shared\dmstrm.h"
#include "..\shared\validp.h"
#include "dls1.h"
#include "trackhelp.h"
#include "..\shared\Validate.h"
#include "audpath.h"
#include "debug.h"
#include "..\shared\dmusiccp.h"
#include "..\shared\xcreate.h"
#include "..\dmstyle\dmstylep.h"
#include "..\dswave\dswave.h"
#include <ks.h>
#include "dmksctrl.h"
#include "math.h"
#include "plclock.h"
#include "phoneyds.h"
#include "dmscriptautguids.h"
#include "..\shared\dmusiccp.h"
#ifdef XBOX
#include "..\shared\xcreate.h"
#endif
#include "wavtrack.h"
#include "dmperf.h"
#include "smartref.h"
using namespace SmartRef;
#include <xutility>
#include "miscutil.h"
#include "song.h"
#include "seqtrack.h"
#include "sysextrk.h"
#include "tempotrk.h"
#include "tsigtrk.h"
#include "marktrk.h"
#include "wavtrack.h"
#include "segtrtrk.h"
#include "lyrictrk.h"
#include "ParamTrk.h"
#include "dmgraph.h"
#include "..\shared\oledll.h"
#include "..\dmband\dmbndtrk.h"
#include "dmksctrl.h"
#include "dmscriptautguids.h"
#include "audpath.h"
#ifdef XBOX
#include "..\shared\xcreate.h"
#endif

#ifdef XBOX
#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
extern "C" void DMRegisterPMsgPerformanceCounters();
extern "C" void DMUnregisterPMsgPerformanceCounters();
extern "C" void DMRPC_DownloadBuffer();
extern "C" void DMURPC_DownloadBuffer();
#endif
#define NEWCATCH(obj,type) \
    obj = new type;
#else
#define NEWCATCH(obj,type)  \
	try \
    { \
        obj = new type; \
    } \
    catch( ... ) \
    { \
        hr = E_OUTOFMEMORY; \
        break; \
    }
#endif

#define SAMPLERATE  48000   // sample rate
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\phoneyds.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// phoneds.cpp : Implementation of CPhoneyDSound

#include "pchime.h"
/*#ifdef XBOX
#include <xtl.h>
#else // XBOX
#include <windows.h>
#endif // XBOX

#include <mmsystem.h>
#include <dsoundp.h>
#include "dmsegobj.h"
#include "dmgraph.h"
#include "dmperf.h"
#include "dmusici.h"
#include "..\shared\Validate.h"
#include "audpath.h"
#include "debug.h"
#include "..\shared\dmusiccp.h"
#include "..\shared\xcreate.h"
//#include "dslink.h"
#include "audiosink.h"
#include "phoneyds.h"*/


CPhoneyDSound::CPhoneyDSound()
{
    m_cRef = 0;
}

CPhoneyDSound::~CPhoneyDSound()
{
}

/*STDMETHODIMP CPhoneyDSound::QueryInterface(const IID &iid, void **ppv)
{
    if(iid == IID_IUnknown || iid == IID_IDirectSound || iid == IID_IDirectSound8)
    {
        *ppv = static_cast<IDirectSound8*>(this);
    } 
    else if(iid == IID_IDirectSoundPrivate) 
    {
        *ppv = static_cast<IDirectSoundPrivate*>(this);
    } 
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    
    return S_OK;
}*/

STDMETHODIMP_(ULONG) CPhoneyDSound::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CPhoneyDSound::Release()
{
    if(!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CPhoneyDSound::CreateSoundBuffer(LPCDSBUFFERDESC pcDSBufferDesc, LPDIRECTSOUNDBUFFER *ppDSBuffer, LPUNKNOWN pUnkOuter) 
{ 
    CBuffer *pBuffer = new CBuffer(NULL,NULL,NULL,0,GUID_NULL);
    if (pBuffer)
    {
        pBuffer->AddRef();
        (*ppDSBuffer) = (LPDIRECTSOUNDBUFFER) pBuffer;
        return S_OK;
    }
    return E_OUTOFMEMORY; 
}

STDMETHODIMP CPhoneyDSound::GetCaps(LPDSCAPS pDSCaps) 
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CPhoneyDSound::DuplicateSoundBuffer(LPDIRECTSOUNDBUFFER pDSBufferOriginal, LPDIRECTSOUNDBUFFER *ppDSBufferDuplicate) 
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CPhoneyDSound::SetCooperativeLevel(HWND hwnd, DWORD dwLevel) 
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CPhoneyDSound::Compact() 
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CPhoneyDSound::GetSpeakerConfig(LPDWORD pdwSpeakerConfig) 
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CPhoneyDSound::SetSpeakerConfig(DWORD dwSpeakerConfig) 
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CPhoneyDSound::Initialize(LPCGUID pcGuidDevice) 
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CPhoneyDSound::VerifyCertification(LPDWORD pdwCertified) 
{ 
    return E_NOTIMPL; 
}

// IDirectSoundPrivate methods
STDMETHODIMP CPhoneyDSound::AllocSink(LPWAVEFORMATEX pwfxFormat, LPDIRECTSOUNDCONNECT *ppSinkConnect) 
{ 
    CAudioSink *pSink = new CAudioSink(pwfxFormat);
    if (pSink)
    {
        return pSink->QueryInterface(IID_IDirectSoundConnect,(void **)ppSinkConnect);
    }
    return E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\phoneyds.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation
//	    PhoneyDS.h

#ifndef __PHONEY_DS__
#define __PHONEY_DS__

#include <math.h>
#include <mmsystem.h>
#include <dsoundp.h>
#include "dmusicc.h"
#include "dmusics.h"
#include "cclock.h"
#include "PLClock.h"
#include "audiosink.h"


class CPhoneyDSound : public IDirectSound8, public IDirectSoundPrivate 
{
public:
    // IUnknown methods
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDirectSound methods
    STDMETHODIMP CreateSoundBuffer(LPCDSBUFFERDESC pcDSBufferDesc, LPDIRECTSOUNDBUFFER *ppDSBuffer, LPUNKNOWN pUnkOuter) ;
    STDMETHODIMP GetCaps(LPDSCAPS pDSCaps) ;
    STDMETHODIMP DuplicateSoundBuffer(LPDIRECTSOUNDBUFFER pDSBufferOriginal, LPDIRECTSOUNDBUFFER *ppDSBufferDuplicate) ;
    STDMETHODIMP SetCooperativeLevel(HWND hwnd, DWORD dwLevel) ;
    STDMETHODIMP Compact() ;
    STDMETHODIMP GetSpeakerConfig(LPDWORD pdwSpeakerConfig) ;
    STDMETHODIMP SetSpeakerConfig(DWORD dwSpeakerConfig) ;
    STDMETHODIMP Initialize(LPCGUID pcGuidDevice) ;
    STDMETHODIMP VerifyCertification(LPDWORD pdwCertified) ;

    // IDirectSoundPrivate methods
    STDMETHODIMP AllocSink(LPWAVEFORMATEX pwfxFormat, LPDIRECTSOUNDCONNECT *ppSinkConnect) ;

    CPhoneyDSound();
    ~CPhoneyDSound();
private:
    long        m_cRef;
};
#endif // __PHONEY_DS__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\plclock.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// phoneds.cpp : Implementation of CPhoneyDSound

#include "pchime.h"
/*
#ifdef XBOX
#include <xtl.h>
#else // XBOX
#include <windows.h>
#endif // XBOX

#include "dmusici.h"
#include "..\shared\Validate.h"
#include "audpath.h"
#include "debug.h"
#include "..\shared\dmusiccp.h"
#include "..\shared\xcreate.h"
#include "plclock.h"*/

#define MILS_TO_REF	10000

CPhaseLockClock::CPhaseLockClock()
{
	m_rfOffset = 0;
    m_rfBaseOffset = 0;
}

// When the clock starts, it needs to mark down the 
// difference between the time it is given and its concept of time. 

void CPhaseLockClock::Start(REFERENCE_TIME rfMasterTime, REFERENCE_TIME rfSlaveTime)
{
	m_rfOffset = 0;
    m_rfBaseOffset = rfMasterTime - rfSlaveTime;
}	


// Convert the passed time to use the same base as the master clock.

void CPhaseLockClock::GetSlaveTime(REFERENCE_TIME rfSlaveTime, REFERENCE_TIME *prfTime)
{
	rfSlaveTime += (m_rfBaseOffset + m_rfOffset);
	*prfTime = rfSlaveTime;
}

void CPhaseLockClock::SetSlaveTime(REFERENCE_TIME rfSlaveTime, REFERENCE_TIME *prfTime)

{
	rfSlaveTime -= (m_rfBaseOffset + m_rfOffset);
	*prfTime = rfSlaveTime;
}

/*	SyncToMaster provides the needed magic to keep the clock
	in sync. Since the clock uses its own clock (rfSlaveTime)
	to increment, it can drift. This call provides a reference
	time which the clock compares with its internal 
	concept of time. The difference between the two is
	considered the drift. Since the sync time may increment in
	a lurching way, the correction has to be subtle. 
	So, the difference between the two is divided by
	100 and added to the offset.
*/
void CPhaseLockClock::SyncToMaster(REFERENCE_TIME rfSlaveTime, REFERENCE_TIME rfMasterTime, BOOL fLockToMaster)
{
	rfSlaveTime += (m_rfOffset + m_rfBaseOffset);
	rfSlaveTime -= rfMasterTime;	// Find difference between calculated and expected time.
	rfSlaveTime /= 100;				// Reduce in magnitude.
    // If fLockToMaster is true, we want to adjust our offset that we use for conversions, 
    // so our clock will slave to the master clock.
    if (fLockToMaster)
    {
        m_rfBaseOffset -= rfSlaveTime;
    }
    // Otherwise, we want to put a value into m_rfOffset that will be used to 
    // tweak the master clock so it will slave to our time.
    else
    {
	    m_rfOffset -= rfSlaveTime;		// Subtract that from the original offset.
    }
}

CSampleClock::CSampleClock()
{
	m_dwStart = 0;
	m_dwSampleRate = SAMPLERATE;
}

void CSampleClock::Start(IReferenceClock *pIClock, DWORD dwSampleRate, DWORD dwSamples)
{
	REFERENCE_TIME rfStart;
	m_dwStart = dwSamples;
	m_dwSampleRate = dwSampleRate;
	if (pIClock)
	{
		pIClock->GetTime(&rfStart);
		m_PLClock.Start(rfStart,0);
	}
}

CSampleClock::~CSampleClock()
{
}

void CSampleClock::SampleToRefTime(LONGLONG llSampleTime, REFERENCE_TIME *prfTime)
{
	llSampleTime -= m_dwStart;
	llSampleTime *= MILS_TO_REF;
	llSampleTime /= m_dwSampleRate;
	llSampleTime *= 1000;
	m_PLClock.GetSlaveTime(llSampleTime, prfTime);
}

LONGLONG CSampleClock::RefToSampleTime(REFERENCE_TIME rfTime)
{
	m_PLClock.SetSlaveTime(rfTime, &rfTime);
	rfTime /= 1000;
	rfTime *= m_dwSampleRate;
	rfTime /= MILS_TO_REF;
	rfTime += m_dwStart;
	return rfTime;
}

void CSampleClock::SyncToMaster(LONGLONG llSampleTime, IReferenceClock *pIClock, BOOL fLockToMaster)
{
	llSampleTime -= m_dwStart;
	llSampleTime *= MILS_TO_REF;
	llSampleTime /= m_dwSampleRate;
	llSampleTime *= 1000;
	if (pIClock)
	{
		REFERENCE_TIME rfMasterTime;
		pIClock->GetTime(&rfMasterTime);
		m_PLClock.SyncToMaster(llSampleTime, rfMasterTime,fLockToMaster);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\midifile.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
// midifile.cpp
//
// original author: Dave Miller
// orignal project: AudioActive
// modified by: Mark Burton
// project: DirectMusic
//


#ifdef XBOX
#include <xtl.h>
#else // XBOX
#include <windows.h>
#endif // XBOX

#include <mmsystem.h>
#include <dsoundp.h>
#include "debug.h"
#define ASSERT	assert
#include "Template.h"
#include "dmusici.h"
#include "dmperf.h"
#include "dmusicf.h"
#include "..\dmusic\dmcollec.h"
#include "alist.h"
#include "tlist.h"
#include "dmime.h"
#include "..\dmband\dmbndtrk.h"
#include "..\dmband\bandinst.h"
#include "..\shared\xcreate.h"
#include "seqtrack.h"
#include "tsigtrk.h"
#include "sysextrk.h"

#ifdef XBOX
#define CreateStreamOnHGlobal DMusic_CreateStreamOnHGlobal
STDAPI DMusic_CreateStreamOnHGlobal(HANDLE hGlobal, BOOL fDeleteOnRelease,
        LPSTREAM FAR* ppstm);
#endif

typedef struct _DMUS_IO_BANKSELECT_ITEM
{
    BYTE    byLSB;
    BYTE    byMSB;
    BYTE    byPad[2];
} DMUS_IO_BANKSELECT_ITEM;

#define EVENT_VOICE     1       // Performance event
#define EVENT_REALTIME  2       // qevent() must invoke interrupt
#define EVENT_ONTIME    3       // event should be handled on time

/*  MIDI status bytes ==================================================*/

#define MIDI_NOTEOFF    0x80
#define MIDI_NOTEON     0x90
#define MIDI_PTOUCH     0xA0
#define MIDI_CCHANGE    0xB0
#define MIDI_PCHANGE    0xC0
#define MIDI_MTOUCH     0xD0
#define MIDI_PBEND      0xE0
#define MIDI_SYSX       0xF0
#define MIDI_MTC        0xF1
#define MIDI_SONGPP     0xF2
#define MIDI_SONGS      0xF3
#define MIDI_EOX        0xF7
#define MIDI_CLOCK      0xF8
#define MIDI_START      0xFA
#define MIDI_CONTINUE   0xFB
#define MIDI_STOP       0xFC
#define MIDI_SENSE      0xFE
#define ET_NOTEOFF  ( MIDI_NOTEOFF >> 4 )  // 0x08
#define ET_NOTEON       ( MIDI_NOTEON >> 4 )   // 0x09
#define ET_PTOUCH       ( MIDI_PTOUCH >> 4 )   // 0x0A
#define ET_CCHANGE      ( MIDI_CCHANGE >> 4 )  // 0x0B
#define ET_PCHANGE      ( MIDI_PCHANGE >> 4 )  // 0x0C
#define ET_MTOUCH       ( MIDI_MTOUCH >> 4 )   // 0x0D
#define ET_PBEND        ( MIDI_PBEND >> 4 )    // 0x0E
#define ET_SYSX         ( MIDI_SYSX >> 4 )     // 0x0F
#define ET_PBCURVE          0x03
#define ET_CCCURVE      0x04
#define ET_MATCURVE     0x05
#define ET_PATCURVE     0x06
#define ET_TEMPOEVENT   0x01
#define ET_NOTDEFINED   0

#define NUM_MIDI_CHANNELS	16

struct FSEBlock;

/* FullSeqEvent is SeqEvent plus next pointers*/
typedef struct FullSeqEvent : DMUS_IO_SEQ_ITEM
{
	struct FullSeqEvent* pNext;
	struct FullSeqEvent* pTempNext; /* used in the compresseventlist routine */
	long pos;	/* used to keep track of the order of events in the file */

private:
    DWORD dwPosInBlock;
    static FSEBlock* sm_pBlockList;
public:
    static void CleanUp();
    void* operator new(size_t n);
    void operator delete(void* p);
} FullSeqEvent;

#define BITMAPSPERBLOCK 8
struct FSEBlock
{
    FSEBlock()
    {
        for(int i = 0 ; i < BITMAPSPERBLOCK ; ++i)
        {
            m_dwBitMap[i] = 0;
        }
    };
    FSEBlock* m_pNext;
    DWORD m_dwBitMap[BITMAPSPERBLOCK];
    FullSeqEvent m_Event[BITMAPSPERBLOCK][32];
};

FSEBlock* FullSeqEvent::sm_pBlockList;

void FullSeqEvent::CleanUp()
{
    FSEBlock* pBlock;
    FSEBlock* pNext;

    for(pBlock = sm_pBlockList ; pBlock != NULL ; pBlock = pNext)
    {
#ifdef DEBUG
        for(int i = 0 ; i < BITMAPSPERBLOCK ; ++i)
        {
            if(pBlock->m_dwBitMap[i] != 0)
            {
                DebugBreak();
            }
        }
#endif
        pNext = pBlock->m_pNext;
        delete pBlock;
    }
    sm_pBlockList = NULL;
}

void* FullSeqEvent::operator new(size_t n)
{
    if(sm_pBlockList == NULL)
    {
        sm_pBlockList = new FSEBlock;
        if(sm_pBlockList == NULL)
        {
            return NULL;
        }
        sm_pBlockList->m_pNext = NULL;
        sm_pBlockList->m_dwBitMap[0] = 1;
        sm_pBlockList->m_Event[0][0].dwPosInBlock = 0;
        return &sm_pBlockList->m_Event[0][0];
    }

    FSEBlock* pBlock;
    int i;
    DWORD dw;

    for(pBlock = sm_pBlockList ; pBlock != NULL ; pBlock = pBlock->m_pNext)
    {
        for(i = 0 ; i < BITMAPSPERBLOCK ; ++i)
        {
            if(pBlock->m_dwBitMap[i] != 0xffff)
            {
                break;
            }
        }
        if(i < BITMAPSPERBLOCK)
        {
            break;
        }
    }
    if(pBlock == NULL)
    {
        pBlock = new FSEBlock;
        if(pBlock == NULL)
        {
            return NULL;
        }
        pBlock->m_pNext = sm_pBlockList;
        sm_pBlockList = pBlock;
        pBlock->m_dwBitMap[0] = 1;
        pBlock->m_Event[0][0].dwPosInBlock = 0;
        return &pBlock->m_Event[0][0];
    }

    for(dw = 0 ; (pBlock->m_dwBitMap[i] & (1 << dw)) != 0 ; ++dw);
    pBlock->m_dwBitMap[i] |= (1 << dw);
    pBlock->m_Event[i][dw].dwPosInBlock = (i << 6) | dw;
    return &pBlock->m_Event[i][dw];
}

void FullSeqEvent::operator delete(void* p)
{
    FSEBlock* pBlock;
    int i;
    DWORD dw;
    FullSeqEvent* pEvent = (FullSeqEvent*)p;

    dw = pEvent->dwPosInBlock & 0x1f;
    i = pEvent->dwPosInBlock >> 6;
    for(pBlock = sm_pBlockList ; pBlock != NULL ; pBlock = pBlock->m_pNext)
    {
        if(p == &pBlock->m_Event[i][dw])
        {
            pBlock->m_dwBitMap[i] &= ~(1 << dw);
            return;
        }
    }
}

TList<StampedGMGSXG> gMidiModeList;

// One for each MIDI channel 0-15	
DMUS_IO_BANKSELECT_ITEM gBankSelect[NUM_MIDI_CHANNELS];
DWORD gPatchTable[NUM_MIDI_CHANNELS];
long gPos; // keeps track of order of events in the file
DWORD gdwLastControllerTime[NUM_MIDI_CHANNELS];	// Holds the time of the last CC event.
DWORD gdwControlCollisionOffset[NUM_MIDI_CHANNELS]; // Holds the index of the last CC.
DWORD gdwLastPitchBendValue[NUM_MIDI_CHANNELS]; // Holds the value of the last pbend event.
long glLastSysexTime;

void CreateChordFromKey(char cSharpsFlats, BYTE bMode, DWORD dwTime, DMUS_CHORD_PARAM& rChord);


void InsertMidiMode( TListItem<StampedGMGSXG>* pPair )
{
	TListItem<StampedGMGSXG>* pScan = gMidiModeList.GetHead();
	if( NULL == pScan )
	{
		gMidiModeList.AddHead(pPair);
	}
	else
	{
		if( pPair->GetItemValue().mtTime < pScan->GetItemValue().mtTime )
		{
			gMidiModeList.AddHead(pPair);
		}
		else
		{
			pScan = pScan->GetNext();
			while( pScan )
			{
				if( pPair->GetItemValue().mtTime < pScan->GetItemValue().mtTime )
				{
					gMidiModeList.InsertBefore( pScan, pPair );
					break;
				}
				pScan = pScan->GetNext();
			}
			if( NULL == pScan )
			{
				gMidiModeList.AddTail(pPair);
			}
		}
	}
}

HRESULT LoadCollection(IDirectMusicCollection** ppIDMCollection,
					   IDirectMusicLoader* pIDMLoader)
{
	// Any changes made to this function should also be made to CDirectMusicBand::LoadCollection
	// in dmband.dll

	assert(ppIDMCollection);
	assert(pIDMLoader);

	DMUS_OBJECTDESC desc;
	memset(&desc, 0, sizeof(desc));
	desc.dwSize = sizeof(desc);

	desc.guidClass = CLSID_DirectMusicCollection;
	desc.guidObject = GUID_DefaultGMCollection;
	desc.dwValidData |= (DMUS_OBJ_CLASS | DMUS_OBJ_OBJECT);
	
	HRESULT hr = pIDMLoader->GetObject(&desc,IID_IDirectMusicCollection, (void**)ppIDMCollection);

	return hr;
}

// seeks to a 32-bit position in a stream.
HRESULT __inline StreamSeek( LPSTREAM pStream, long lSeekTo, DWORD dwOrigin )
{
	LARGE_INTEGER li;

	if( lSeekTo < 0 )
	{
		li.HighPart = -1;
	}
	else
	{
	li.HighPart = 0;
	}
	li.LowPart = lSeekTo;
	return pStream->Seek( li, dwOrigin, NULL );
}

// this function gets a long that is formatted the correct way
// i.e. the motorola way as opposed to the intel way
BOOL __inline GetMLong( LPSTREAM pStream, DWORD& dw )
{
    union uLong
	{
		unsigned char buf[4];
	DWORD dw;
	} u;
    unsigned char ch;

    if( S_OK != pStream->Read( u.buf, 4, NULL ) )
    {
	return FALSE;
    }

#ifndef _MAC
    // swap bytes
    ch = u.buf[0];
    u.buf[0] = u.buf[3];
    u.buf[3] = ch;

    ch = u.buf[1];
    u.buf[1] = u.buf[2];
    u.buf[2] = ch;
#endif

    dw = u.dw;
    return TRUE;
}

// this function gets a short that is formatted the correct way
// i.e. the motorola way as opposed to the intel way
BOOL __inline GetMShort( LPSTREAM pStream, short& n )
{
    union uShort
	{
	unsigned char buf[2];
	short n;
	} u;
    unsigned char ch;

    if( S_OK != pStream->Read( u.buf, 2, NULL ) )
    {
	return FALSE;
    }

#ifndef _MAC
    // swap bytes
    ch = u.buf[0];
    u.buf[0] = u.buf[1];
    u.buf[1] = ch;
#endif

    n = u.n;
    return TRUE;
}

static short snPPQN;
static IStream* gpTempoStream = NULL;
static IStream* gpSysExStream = NULL;
static IStream* gpTimeSigStream = NULL;
static DWORD gdwSizeTimeSigStream = 0;
static DWORD gdwSizeSysExStream = 0;
static DWORD gdwSizeTempoStream = 0;
static DMUS_IO_TIMESIGNATURE_ITEM gTimeSig; // holds the latest time sig
long	glTimeSig = 1; // flag to see if we should be paying attention to time sigs.
	// this is needed because we only care about the time sigs on the first track to
	// contain them that we read
static IDirectMusicTrack* g_pChordTrack = NULL;
static DMUS_CHORD_PARAM g_Chord; // Holds the latest chord
static DMUS_CHORD_PARAM g_DefaultChord; // in case no chords are extracted from the track

static WORD GetVarLength( LPSTREAM pStream, DWORD& rfdwValue )
{
    BYTE b;
    WORD wBytes;

    if( S_OK != pStream->Read( &b, 1, NULL ) )
    {
		rfdwValue = 0;
		return 0;
    }
    wBytes = 1;
    rfdwValue = b & 0x7f;
    while( ( b & 0x80 ) != 0 )
    {
		if( S_OK != pStream->Read( &b, 1, NULL ) )
		{
			break;
		}
		++wBytes;
		rfdwValue = ( rfdwValue << 7 ) + ( b & 0x7f );
    }
    return wBytes;
}

#ifdef _MAC
static DWORD ConvertTime( DWORD dwTime )
{
	wide d;
	long l;  // storage for the remainder

	if( snPPQN == DMUS_PPQ )  {
		return dwTime;
	}
	WideMultiply( dwTime, DMUS_PPQ, &d );
	return WideDivide( &d, snPPQN, &l );
}
#else
static DWORD ConvertTime( DWORD dwTime )
{
    __int64 d;

    if( snPPQN == DMUS_PPQ )
    {
		return dwTime;
    }
    d = dwTime;
    d *= DMUS_PPQ;
    d /= snPPQN;
    return (DWORD)d;
}
#endif

static FullSeqEvent* ScanForDuplicatePBends( FullSeqEvent* lstEvent )
{
    FullSeqEvent* pEvent;
    FullSeqEvent* pNextEvent;
    MUSIC_TIME mtCurrentTime = 0x7FFFFFFF;  // We are scanning backwards in time, so start way in the future.
    WORD wDupeBits = 0;     // Keep a bit array of all channels that have active PBends at mtCurrentTime. 

	if( NULL == lstEvent ) return NULL;

	// Scan through the list of events. This list is in backwards order, with the first item read at the end
    // of the list. This makes it very easy to scan through and remove pitch bends that occur at the same time, since
    // we can remove the latter events (which occured earlier in the midi file.)
    for( pEvent = lstEvent ; pEvent ; pEvent = pNextEvent )
    {
		pNextEvent = pEvent->pNext;
		if( pNextEvent )
        {
            // If the time is not the same as the last, reset. 
            if (pNextEvent->mtTime != mtCurrentTime)
            {
                // Reset the time.
                mtCurrentTime = pNextEvent->mtTime;
                // No duplicate pbends at this time.
                wDupeBits = 0;
            }
            if ((pNextEvent->bStatus & 0xf0) == MIDI_PBEND)
            {
                DWORD dwChannel = pNextEvent->dwPChannel;
                if (wDupeBits & (1 << dwChannel))
                {
                    // There was a previous (therefore later in the file) pbend at this time. Delete this one.
                    pEvent->pNext = pNextEvent->pNext;
                    delete pNextEvent;
                    pNextEvent = pEvent;
                }
                else
                {
                    // This is the last instance of a pbend on this channel at this time, so hang on to it.
                    wDupeBits |= (1 << dwChannel);
                }
            }
        }
    }
    return lstEvent;
}


static FullSeqEvent* CompressEventList( FullSeqEvent* lstEvent )
{
    static FullSeqEvent* paNoteOnEvent[16][128];
    FullSeqEvent* pEvent;
    FullSeqEvent* pPrevEvent;
    FullSeqEvent* pNextEvent;
	FullSeqEvent* pHoldEvent;
	FullSeqEvent tempEvent;
    int nChannel;

	if( NULL == lstEvent ) return NULL;

	memset( paNoteOnEvent, 0, sizeof( paNoteOnEvent ) );
    pPrevEvent = NULL;

	// add an event to the beginning of the list as a place holder
	memset( &tempEvent, 0, sizeof(FullSeqEvent) );
	tempEvent.mtTime = -1;
	tempEvent.pNext = lstEvent;
	lstEvent = &tempEvent;
	// make sure that any events with the same time are sorted in order
	// they were read
    for( pEvent = lstEvent ; pEvent != NULL ; pEvent = pNextEvent )
    {
		pNextEvent = pEvent->pNext;
		if( pNextEvent )
		{
			BOOL fSwap = TRUE;
			// bubble sort
			while( fSwap )
			{
				fSwap = FALSE;
				pPrevEvent = pEvent;
				pNextEvent = pEvent->pNext;
				while( pNextEvent->pNext && ( pNextEvent->mtTime == pNextEvent->pNext->mtTime ))
				{
					if( pNextEvent->pNext->pos < pNextEvent->pos )
					{
						fSwap = TRUE;
						pHoldEvent = pNextEvent->pNext;
						pPrevEvent->pNext = pHoldEvent;
						pNextEvent->pNext = pHoldEvent->pNext;
						pHoldEvent->pNext = pNextEvent;
						pPrevEvent = pHoldEvent;
						continue;
					}
					pPrevEvent = pNextEvent;
					pNextEvent = pNextEvent->pNext;
				}
			}
		}
	}
	// remove the first, temporary event, added above
	lstEvent = lstEvent->pNext;

	pPrevEvent = NULL;
	// combine note on and note offs
    for( pEvent = lstEvent ; pEvent != NULL ; pEvent = pNextEvent )
    {
		pEvent->pTempNext = NULL;
		pNextEvent = pEvent->pNext;
		//nChannel = pEvent->bStatus & 0xf;
		nChannel = pEvent->dwPChannel;
		if( ( pEvent->bStatus & 0xf0 ) == MIDI_NOTEON )
		{
			// add this event to the end of the list of events based
			// on the event's pitch. Keeping track of multiple events
			// of the same pitch allows us to have overlapping notes
			// of the same pitch, choosing that note on's and note off's
			// follow in the same order.
			if( NULL == paNoteOnEvent[nChannel][pEvent->bByte1] )
			{
				paNoteOnEvent[nChannel][pEvent->bByte1] = pEvent;
			}
			else
			{
				FullSeqEvent* pScan;
				for( pScan = paNoteOnEvent[nChannel][pEvent->bByte1];
					 pScan->pTempNext != NULL; pScan = pScan->pTempNext );
				pScan->pTempNext = pEvent;
			}
		}
		else if( ( pEvent->bStatus & 0xf0 ) == MIDI_NOTEOFF )
		{
			if( paNoteOnEvent[nChannel][pEvent->bByte1] != NULL )
			{
				paNoteOnEvent[nChannel][pEvent->bByte1]->mtDuration =
					pEvent->mtTime - paNoteOnEvent[nChannel][pEvent->bByte1]->mtTime;
				paNoteOnEvent[nChannel][pEvent->bByte1] =
					paNoteOnEvent[nChannel][pEvent->bByte1]->pTempNext;
			}
			if( pPrevEvent == NULL )
			{
				lstEvent = pNextEvent;
			}
			else
			{
				pPrevEvent->pNext = pNextEvent;
			}
			delete pEvent;
			continue;
		}
		pPrevEvent = pEvent;
    }

    for( pEvent = lstEvent ; pEvent != NULL ; pEvent = pEvent->pNext )
    {
		pEvent->mtTime = pEvent->mtTime;
		if( ( pEvent->bStatus & 0xf0 ) == MIDI_NOTEON )
		{
			pEvent->mtDuration = pEvent->mtDuration;
			if( pEvent->mtDuration == 0 ) pEvent->mtDuration = 1;
		}
    }

    return lstEvent;
}

static int CompareEvents( FullSeqEvent* pEvent1, FullSeqEvent* pEvent2 )
{
	BYTE bEventType1 = static_cast<BYTE>( pEvent1->bStatus >> 4 );
	BYTE bEventType2 = static_cast<BYTE>( pEvent2->bStatus >> 4 );

    if( pEvent1->mtTime < pEvent2->mtTime )
    {
		return -1;
    }
    else if( pEvent1->mtTime > pEvent2->mtTime )
    {
		return 1;
    }
    else if( bEventType1 != ET_SYSX && bEventType2 != ET_SYSX )
    {
		BYTE bStatus1;
		BYTE bStatus2;

		bStatus1 = (BYTE)( pEvent1->bStatus & 0xf0 );
		bStatus2 = (BYTE)( pEvent2->bStatus & 0xf0 );
		if( bStatus1 == bStatus2 )
		{
			return 0;
		}
		else if( bStatus1 == MIDI_NOTEON )
		{
			return -1;
		}
		else if( bStatus2 == MIDI_NOTEON )
		{
			return 1;
		}
		else if( bStatus1 > bStatus2 )
		{
			return 1;
		}
		else if( bStatus1 < bStatus2 )
		{
			return -1;
		}
    }
    return 0;
}

static FullSeqEvent* MergeEvents( FullSeqEvent* lstLeftEvent, FullSeqEvent* lstRightEvent )
{
    FullSeqEvent  anchorEvent;
    FullSeqEvent* pEvent;

    anchorEvent.pNext = NULL;
    pEvent = &anchorEvent;

    do
    {
	if( CompareEvents( lstLeftEvent, lstRightEvent ) < 0 )
	{
	    pEvent->pNext = lstLeftEvent;
	    pEvent = lstLeftEvent;
	    lstLeftEvent = lstLeftEvent->pNext;
	    if( lstLeftEvent == NULL )
	    {
		pEvent->pNext = lstRightEvent;
	    }
	}
	else
	{
	    pEvent->pNext = lstRightEvent;
	    pEvent = lstRightEvent;
	    lstRightEvent = lstRightEvent->pNext;
	    if( lstRightEvent == NULL )
	    {
		pEvent->pNext = lstLeftEvent;
		lstLeftEvent = NULL;
	    }
	}
    } while( lstLeftEvent != NULL );

    return anchorEvent.pNext;
}

static FullSeqEvent* SortEventList( FullSeqEvent* lstEvent )
{
    FullSeqEvent* pMidEvent;
    FullSeqEvent* pRightEvent;

    if( lstEvent != NULL && lstEvent->pNext != NULL )
    {
	pMidEvent = lstEvent;
	pRightEvent = pMidEvent->pNext->pNext;
	if( pRightEvent != NULL )
	{
	    pRightEvent = pRightEvent->pNext;
	}
	while( pRightEvent != NULL )
	{
	    pMidEvent = pMidEvent->pNext;
	    pRightEvent = pRightEvent->pNext;
	    if( pRightEvent != NULL )
	    {
		pRightEvent = pRightEvent->pNext;
	    }
	}
	pRightEvent = pMidEvent->pNext;
	pMidEvent->pNext = NULL;
	return MergeEvents( SortEventList( lstEvent ),
			    SortEventList( pRightEvent ) );
    }
    return lstEvent;
}

static DWORD ReadEvent( LPSTREAM pStream, DWORD dwTime, FullSeqEvent** plstEvent, DMUS_IO_PATCH_ITEM** pplstPatchEvent )
{
    static BYTE bRunningStatus;

	gPos++;
	dwTime = ConvertTime(dwTime);

    DWORD dwBytes;
    DWORD dwLen;
    FullSeqEvent* pEvent;
	DMUS_IO_PATCH_ITEM* pPatchEvent;
    DMUS_IO_SYSEX_ITEM* pSysEx;
    BYTE b;

	BYTE* pbSysExData = NULL;

    if( FAILED( pStream->Read( &b, 1, NULL ) ) )
    {
		return 0;
    }

    if( b < 0x80 )
    {
		StreamSeek( pStream, -1, STREAM_SEEK_CUR );
		b = bRunningStatus;
		dwBytes = 0;
    }
    else
    {
		dwBytes = 1;
    }

    if( b < 0xf0 )
    {
		bRunningStatus = (BYTE)b;

		switch( b & 0xf0 )
		{
		case MIDI_CCHANGE:
		case MIDI_PTOUCH:
		case MIDI_PBEND:
		case MIDI_NOTEOFF:
		case MIDI_NOTEON:
			if( FAILED( pStream->Read( &b, 1, NULL ) ) )
			{
				return dwBytes;
			}
			++dwBytes;

			pEvent = new FullSeqEvent;
			if( pEvent == NULL )
			{
				return 0;
			}

			pEvent->mtTime = dwTime;
			pEvent->nOffset = 0;
			pEvent->pos = gPos;
			pEvent->mtDuration = 0;
			pEvent->bStatus = bRunningStatus & 0xf0;
			pEvent->dwPChannel = bRunningStatus & 0xf;
			pEvent->bByte1 = b;
			if( FAILED( pStream->Read( &b, 1, NULL ) ) )
			{
				delete pEvent;
				return dwBytes;
			}
			++dwBytes;
			pEvent->bByte2 = b;

			if( ( pEvent->bStatus & 0xf0 ) == MIDI_NOTEON &&
				pEvent->bByte2 == 0 )
			{
				pEvent->bStatus = (BYTE)( MIDI_NOTEOFF );
			}

			/*  If there are multiple controller events at the same time, seperate
				them by clock ticks. 
				gdwLastControllerTime holds the time of the last CC event.
				gdwControlCollisionOffset holds the number of colliding CCs.
			*/

			if ((pEvent->bStatus & 0xf0) == MIDI_CCHANGE)
			{
				DWORD dwChannel = pEvent->dwPChannel;
				if (dwTime == gdwLastControllerTime[dwChannel])
				{
					pEvent->mtTime += ++gdwControlCollisionOffset[dwChannel];
				}
				else
				{
					gdwControlCollisionOffset[dwChannel] = 0;
					gdwLastControllerTime[dwChannel] = dwTime;
				}
			}

			if(((pEvent->bStatus & 0xf0) == MIDI_CCHANGE) && (pEvent->bByte1 == 0 || pEvent->bByte1 == 0x20))
			{
				// We have a bank select or its LSB either of which are not added to event list
				if(pEvent->bByte1 == 0x20)
				{
					gBankSelect[pEvent->dwPChannel].byLSB = pEvent->bByte2;
				}
				else // pEvent->bByte1 == 0
				{
					gBankSelect[pEvent->dwPChannel].byMSB = pEvent->bByte2;
				}
				// We no longer need the event so we can free it
				delete pEvent;
			}
			else // Add to event list
			{
				pEvent->pNext = *plstEvent;
				*plstEvent = pEvent;
			}
			break;

		case MIDI_PCHANGE:
			if(FAILED(pStream->Read(&b, 1, NULL)))
			{
				return dwBytes;
			}
			
			++dwBytes;

			pPatchEvent = new DMUS_IO_PATCH_ITEM;

			if(pPatchEvent == NULL)
			{
				return 0;
			}
			memset(pPatchEvent, 0, sizeof(DMUS_IO_PATCH_ITEM));
			pPatchEvent->lTime = dwTime - 1;
			pPatchEvent->byStatus = bRunningStatus;
			pPatchEvent->byPChange = b;
			pPatchEvent->byMSB = gBankSelect[bRunningStatus & 0xF].byMSB;
			pPatchEvent->byLSB = gBankSelect[bRunningStatus & 0xF].byLSB;
			pPatchEvent->dwFlags |= DMUS_IO_INST_PATCH;

			if((pPatchEvent->byMSB != 0xFF) && (pPatchEvent->byLSB != 0xFF))
			{
				pPatchEvent->dwFlags |= DMUS_IO_INST_BANKSELECT;						
			}

			gPatchTable[bRunningStatus & 0xF] = 1;

			pPatchEvent->pNext = *pplstPatchEvent;
			pPatchEvent->pIDMCollection = NULL;

			*pplstPatchEvent = pPatchEvent;

			break;

		case MIDI_MTOUCH:
			if( FAILED( pStream->Read( &b, 1, NULL ) ) )
			{
				return dwBytes;
			}
			++dwBytes;
			pEvent = new FullSeqEvent;
			if( pEvent == NULL )
			{
				return 0;
			}


			pEvent->mtTime = dwTime;
			pEvent->nOffset = 0;
			pEvent->pos = gPos;
			pEvent->mtDuration = 0;
			pEvent->bStatus = bRunningStatus & 0xf0;
			pEvent->dwPChannel = bRunningStatus & 0xf;
			pEvent->bByte1 = b;
			pEvent->pNext = *plstEvent;
			*plstEvent = pEvent;
			break;
		default:
			// this should NOT be possible - unknown midi note event type
			ASSERT(FALSE);
			break;
		}
    }
    else
    {
		switch( b )
		{
		case 0xf0:
			dwBytes += GetVarLength( pStream, dwLen );
			pSysEx = new DMUS_IO_SYSEX_ITEM;
			if( pSysEx != NULL )
			{
				pbSysExData = new BYTE[dwLen + 1];
				if( pbSysExData != NULL )
				{
					MUSIC_TIME mt = dwTime;
                    if (mt == 0)
                    {
                        mt = glLastSysexTime++;
                        if (mt > 0) mt = 0;
                    }
					pbSysExData[0] = 0xf0;
					if( FAILED( pStream->Read( pbSysExData + 1, dwLen, NULL ) ) )
					{
						delete [] pbSysExData;
						delete pSysEx;
						return dwBytes;
					}

                    if( pbSysExData[1] == 0x43 )
					{
						// check for XG files
						BYTE abXG[] = { 0xF0, 0x43, 0x10, 0x4C, 0x00, 0x00, 0x7E, 0x00, 0xF7 };
						int i;
						for( i = 0; i < 8; i++ )
						{
							if( i == 2 )
							{
								if( ( pbSysExData[i] & 0xF0 ) != abXG[i] )
									break;
							}
							else
							{
								if( pbSysExData[i] != abXG[i] )
									break;
							}
						}
						if( i == 8 ) // we have an XG!
						{
							TListItem<StampedGMGSXG>* pPair = new TListItem<StampedGMGSXG>;
							if (!pPair) return dwBytes;
							pPair->GetItemValue().mtTime = mt;
							pPair->GetItemValue().dwMidiMode = DMUS_MIDIMODEF_XG;
							InsertMidiMode(pPair);
						}
					}
					else if( pbSysExData[1] == 0x41 )
					{
						// check for GS files
						BYTE abGS[] = { 0xF0,0x41,0x00,0x42,0x12,0x40,0x00,0x7F,0x00,0x41,0xF7 };
						int i;
						for( i = 0; i < 10; i++ )
						{
							if( i != 2 )
							{
								if( pbSysExData[i] != abGS[i] )
									break;
							}
						}
						if( i == 10 ) // we have a GS!
						{
							TListItem<StampedGMGSXG>* pPair = new TListItem<StampedGMGSXG>;
							if (!pPair) return dwBytes;
							pPair->GetItemValue().mtTime = mt;
							pPair->GetItemValue().dwMidiMode = DMUS_MIDIMODEF_GS;
							InsertMidiMode(pPair);
						}
					}
					else if (( pbSysExData[1] == 0x7E ) && (pbSysExData[3] == 0x09))
				    {
						TListItem<StampedGMGSXG>* pPair = new TListItem<StampedGMGSXG>;
						if (!pPair) return dwBytes;
						pPair->GetItemValue().mtTime = mt;
						pPair->GetItemValue().dwMidiMode = DMUS_MIDIMODEF_GM;
						InsertMidiMode(pPair);
					}
					pSysEx->mtTime = mt;
					pSysEx->dwPChannel = 0;
					DWORD dwTempLen = dwLen + 1;
					pSysEx->dwSysExLength = dwTempLen;
					if( NULL == gpSysExStream )
					{
						// create a stream to hold sysex events
						CreateStreamOnHGlobal( NULL, TRUE, &gpSysExStream );
						if( gpSysExStream )
						{
							DWORD dwTemp;
							// write the chunk header
							dwTemp = DMUS_FOURCC_SYSEX_TRACK;
							gpSysExStream->Write( &dwTemp, sizeof(DWORD), NULL );
							// write the overall size. (Replace this later with the
							// true overall size.)
							dwTemp = sizeof(DMUS_IO_TIMESIGNATURE_ITEM);
							// overall size (to be replaced later)
							gpSysExStream->Write( &dwTemp, sizeof(DWORD), NULL );
						}
					}
					if( gpSysExStream )
					{
						gpSysExStream->Write( &pSysEx->mtTime, sizeof(MUSIC_TIME), NULL );
						gpSysExStream->Write( &pSysEx->dwPChannel, sizeof(DWORD), NULL );
						gpSysExStream->Write( &pSysEx->dwSysExLength, sizeof(DWORD), NULL );
						gpSysExStream->Write( pbSysExData, dwTempLen, NULL );
						gdwSizeSysExStream += (sizeof(long) + sizeof(DWORD) + dwTempLen);
					}
					delete [] pbSysExData;
					delete pSysEx;
				}
				else
				{
					StreamSeek( pStream, dwLen, STREAM_SEEK_CUR );
				}
			}
			else
			{
				StreamSeek( pStream, dwLen, STREAM_SEEK_CUR );
			}
			dwBytes += dwLen;
			break;
		case 0xf7:
			// ignore sysex f7 chunks
			dwBytes += GetVarLength( pStream, dwLen );
			StreamSeek( pStream, dwLen, STREAM_SEEK_CUR );
			dwBytes += dwLen;
			break;
		case 0xff:
			if( FAILED( pStream->Read( &b, 1, NULL ) ) )
			{
				return dwBytes;
			}
			++dwBytes;
			dwBytes += GetVarLength( pStream, dwLen );
			if( b == 0x51 ) // tempo change
			{
				DWORD dw = 0;
				DMUS_IO_TEMPO_ITEM tempo;

				while( dwLen > 0 )
				{
					if( FAILED( pStream->Read( &b, 1, NULL ) ) )
					{
						return dwBytes;
					}
					++dwBytes;
					--dwLen;
					dw <<= 8;
					dw += b;
				}
                if (dw < 1) dw = 1;
				tempo.dblTempo = 60000000.0 / ((double)dw);
				tempo.lTime = dwTime;
				if( NULL == gpTempoStream )
				{
					// create a stream to hold tempo events
					CreateStreamOnHGlobal( NULL, TRUE, &gpTempoStream );
					if( gpTempoStream )
					{
						DWORD dwTemp;
						// write the chunk header
						dwTemp = DMUS_FOURCC_TEMPO_TRACK;
						gpTempoStream->Write( &dwTemp, sizeof(DWORD), NULL );
						// write the overall size. (Replace this later with the
						// true overall size.) Also write the size of the individual
						// structure.
						dwTemp = sizeof(DMUS_IO_TEMPO_ITEM);
						// overall size (to be replaced later)
						gpTempoStream->Write( &dwTemp, sizeof(DWORD), NULL );
						// individual structure.
						gpTempoStream->Write( &dwTemp, sizeof(DWORD), NULL );
					}
				}
				if( gpTempoStream )
				{
					gpTempoStream->Write( &tempo, sizeof(DMUS_IO_TEMPO_ITEM), NULL );
					gdwSizeTempoStream += sizeof(DMUS_IO_TEMPO_ITEM);
				}
			}
			else if( b == 0x58 && glTimeSig )
			{
				// glTimeSig will be set to 0 inside the main calling function
				// once we no longer care about time sigs.
				DMUS_IO_TIMESIGNATURE_ITEM timesig;
				if( FAILED( pStream->Read( &b, 1, NULL ) ) )
				{
					return dwBytes;
				}
				// set glTimeSig to 2 to signal to the main function that we've
				// read a time sig on this track
				glTimeSig = 2;
				gTimeSig.lTime = timesig.lTime = dwTime;
				gTimeSig.bBeatsPerMeasure = timesig.bBeatsPerMeasure = b;
				++dwBytes;
				if( FAILED( pStream->Read( &b, 1, NULL ) ) )
				{
					return dwBytes;
				}
				gTimeSig.bBeat = timesig.bBeat = (BYTE)( 1 << b ); // 0 means 256th note
				gTimeSig.wGridsPerBeat = timesig.wGridsPerBeat = 4; // this is irrelavent for MIDI files
				
				if( NULL == gpTimeSigStream )
				{
					CreateStreamOnHGlobal( NULL, TRUE, &gpTimeSigStream );
					if( gpTimeSigStream )
					{
						DWORD dwTemp;
						// write the chunk header
						dwTemp = DMUS_FOURCC_TIMESIGNATURE_TRACK;
						gpTimeSigStream->Write( &dwTemp, sizeof(DWORD), NULL );
						// write the overall size. (Replace this later with the
						// true overall size.) Also write the size of the individual
						// structure.
						dwTemp = sizeof(DMUS_IO_TIMESIGNATURE_ITEM);
						// overall size (to be replaced later)
						gpTimeSigStream->Write( &dwTemp, sizeof(DWORD), NULL );
						// individual structure.
						gpTimeSigStream->Write( &dwTemp, sizeof(DWORD), NULL );
                        gdwSizeTimeSigStream += sizeof(DWORD);
					}
				}
				if( gpTimeSigStream )
				{
					gpTimeSigStream->Write( &timesig, sizeof(DMUS_IO_TIMESIGNATURE_ITEM), NULL );
					gdwSizeTimeSigStream += sizeof(DMUS_IO_TIMESIGNATURE_ITEM);
				}
				++dwBytes;
				StreamSeek( pStream, dwLen - 2, STREAM_SEEK_CUR );
				dwBytes += ( dwLen - 2 );
			}
			else if( b == 0x59 )
			{
				// Read sharps/flats and major/minor bytes
				if( FAILED( pStream->Read( &b, 1, NULL ) ) )
				{
					return dwBytes;
				}
				char cSharpsFlats = b;
				++dwBytes;
				if( FAILED( pStream->Read( &b, 1, NULL ) ) )
				{
					return dwBytes;
				}
				BYTE bMode = b;
				++dwBytes;

				// Create a chord (with one subchord) from the key info
				CreateChordFromKey(cSharpsFlats, bMode, dwTime, g_Chord);

				// If the chord track is empty, create it.
				if (!g_pChordTrack)
				{
					HRESULT hr = DirectMusicCreateInstance( 
							CLSID_DirectMusicChordTrack, NULL,
							IID_IDirectMusicTrack,
							(void**)&g_pChordTrack );
					if (!SUCCEEDED(hr)) return dwBytes;

					// If dwTime > 0, use SetParam to insert the default chord at time 0
					if (dwTime > 0)
					{
						g_pChordTrack->SetParam(GUID_ChordParam, 0, &g_DefaultChord);
					}
				}

				// Use SetParam to insert the new chord into the chord track
				g_pChordTrack->SetParam(GUID_ChordParam, dwTime, &g_Chord);

			}
			else
			{
				StreamSeek( pStream, dwLen, STREAM_SEEK_CUR );
				dwBytes += dwLen;
			}
			break;
		default:
			break;
		}
    }
    return dwBytes;
}

static void AddOffsets(FullSeqEvent* lstEvent, IDirectMusicTrack* pTimeSigTrack)
{
	HRESULT hr;
	MUSIC_TIME mtNext = 0;
	DMUS_IO_TIMESIGNATURE_ITEM timesig;
	timesig.bBeat = gTimeSig.bBeat ? gTimeSig.bBeat : 4;
	timesig.bBeatsPerMeasure = gTimeSig.bBeatsPerMeasure ? gTimeSig.bBeatsPerMeasure : 4;
	timesig.wGridsPerBeat = gTimeSig.wGridsPerBeat ? gTimeSig.wGridsPerBeat : 4;
    timesig.lTime = 0;
	short nClocksPerGrid = ((DMUS_PPQ * 4) / timesig.bBeat) / timesig.wGridsPerBeat;

	if (pTimeSigTrack)
	{
		hr = pTimeSigTrack->GetParam(GUID_TimeSignature, 0, &mtNext, (void*)&timesig);
		if (FAILED(hr))
		{
			mtNext = 0;
		}
		else
		{
			nClocksPerGrid = ((DMUS_PPQ * 4) / timesig.bBeat) / timesig.wGridsPerBeat;
		}
	}

	for( FullSeqEvent* pEvent = lstEvent; pEvent; pEvent = pEvent->pNext )
	{
		if ( ( pEvent->bStatus & 0xf0 ) == MIDI_NOTEON )
		{
			if (mtNext && pTimeSigTrack && mtNext < pEvent->mtTime)
			{
				hr = pTimeSigTrack->GetParam(GUID_TimeSignature, mtNext, &mtNext, (void*)&timesig);
				if (FAILED(hr))
				{
					mtNext = 0;
				}
				else
				{
					nClocksPerGrid = ((DMUS_PPQ * 4) / timesig.bBeat) / timesig.wGridsPerBeat;
				}
			}
			ASSERT(nClocksPerGrid);
			if( 0 == nClocksPerGrid ) nClocksPerGrid = 1; // this should never happen, but just in case.
			pEvent->nOffset = (short) ((pEvent->mtTime - timesig.lTime) % nClocksPerGrid);
			pEvent->mtTime -= pEvent->nOffset;
			if (pEvent->nOffset > (nClocksPerGrid / 2))
			{
				// make it a negative offset and bump the time a corresponding amount
				pEvent->nOffset -= nClocksPerGrid;
				pEvent->mtTime += nClocksPerGrid;
			}
		}
	}

}

/*

  @method HRESULT | IDirectMusicPerformance | CreateSegmentFromMIDIStream |
  Given a MIDI stream, creates a Segment that can be played via
  <im IDirectMusicPerformance.PlaySegment>.

  @parm LPSTREAM | pStream |
  [in] The MIDI stream. It should be set to the correct seek to begin reading.
  @parm IDirectMusicSegment* | pSegment |
  [out] A pointer to contain the created Segment.

  @rvalue DMUS_E_CANNOTREAD | There was an error attempting to read the MIDI file.
  @rvalue S_OK

*/
HRESULT CreateSegmentFromMIDIStream(LPSTREAM pStream,
									IDirectMusicSegment* pSegment)
{
	if(pSegment == NULL || pStream == NULL)
	{
		return E_POINTER;
	}

	HRESULT hr = DMUS_E_CANNOTREAD;
    DWORD dwID;
    DWORD dwCurTime;
    DWORD dwLength;
	DWORD dwSize;
    short nFormat;
    short nNumTracks;
    short nTracksRead;
     FullSeqEvent* lstEvent;
	DMUS_IO_PATCH_ITEM* lstPatchEvent;
	FullSeqEvent* lstTrackEvent;
	HRESULT hrGM = S_OK;


	EnterCriticalSection(&g_CritSec);
	gpTempoStream = NULL;
	gpSysExStream = NULL;
	gpTimeSigStream = NULL;
	gdwSizeTimeSigStream = 0;
	gdwSizeSysExStream = 0;
	gdwSizeTempoStream = 0;
	glTimeSig = 1; // flag to see if we should be paying attention to time sigs.
	// this is needed because we only care about the time sigs on the first track to
	// contain them that we read
	g_pChordTrack = NULL;

    lstEvent = NULL;
    lstPatchEvent = NULL;
    nNumTracks = nTracksRead = 0;
    dwLength = 0;
	gPos = 0;
	gMidiModeList.CleanUp();
	if (g_pChordTrack)
	{
		g_pChordTrack->Release();
		g_pChordTrack = NULL;
	}
	CreateChordFromKey(0, 0, 0, g_Chord);
	CreateChordFromKey(0, 0, 0, g_DefaultChord);

	memset(&gBankSelect, 0xFF, (sizeof(DMUS_IO_BANKSELECT_ITEM) * NUM_MIDI_CHANNELS));
	memset(&gPatchTable, 0, (sizeof(DWORD) * NUM_MIDI_CHANNELS));
	memset(&gTimeSig, 0, sizeof(DMUS_IO_TIMESIGNATURE_ITEM));
	memset(&gdwLastControllerTime, 0xFF, (sizeof(DWORD) * NUM_MIDI_CHANNELS)); 
	memset(&gdwControlCollisionOffset, 0, (sizeof(DWORD) * NUM_MIDI_CHANNELS)); 
    glLastSysexTime = -5;

    if( ( S_OK != pStream->Read( &dwID, sizeof( FOURCC ), NULL ) ) ||
		!GetMLong( pStream, dwSize ) )
    {
        Trace(1,"Error: Failure parsing MIDI file.\n");
		LeaveCriticalSection(&g_CritSec);
		return DMUS_E_CANNOTREAD;
    }
// check for RIFF MIDI files
    if( dwID == mmioFOURCC( 'R', 'I', 'F', 'F' ) )
    {
		StreamSeek( pStream, 12, STREAM_SEEK_CUR );
		if( ( S_OK != pStream->Read( &dwID, sizeof( FOURCC ), NULL ) ) ||
			!GetMLong( pStream, dwSize ) )
		{
            Trace(1,"Error: Failure parsing MIDI file.\n");
			LeaveCriticalSection(&g_CritSec);
			return DMUS_E_CANNOTREAD;
		}
    }
// check for normal MIDI files
	if( dwID != mmioFOURCC( 'M', 'T', 'h', 'd' ) )
	{
		LeaveCriticalSection(&g_CritSec);
        Trace(1,"Error: Failure parsing MIDI file - can't find a valid header.\n");
		return DMUS_E_CANNOTREAD;
	}

    GetMShort( pStream, nFormat );
    GetMShort( pStream, nNumTracks );
    GetMShort( pStream, snPPQN );
    if( dwSize > 6 )
    {
		StreamSeek( pStream, dwSize - 6, STREAM_SEEK_CUR );
    }
    pStream->Read( &dwID, sizeof( FOURCC ), NULL );
    while( dwID == mmioFOURCC( 'M', 'T', 'r', 'k' ) )
    {
		GetMLong( pStream, dwSize );
		dwCurTime = 0;
		lstTrackEvent = NULL;

		long lSize = (long)dwSize;
		while( lSize > 0 )
		{
			long lReturn;
			lSize -= GetVarLength( pStream, dwID );
			dwCurTime += dwID;
            if (lSize > 0)
            {
			    lReturn = ReadEvent( pStream, dwCurTime, &lstTrackEvent, &lstPatchEvent );
			    if( lReturn )
			    {
				    lSize -= lReturn;
			    }
			    else
			    {
                    Trace(1,"Error: Failure parsing MIDI file.\n");
				    hr = DMUS_E_CANNOTREAD;
				    goto END;
			    }
            }
		}
		dwSize = lSize;
		if( glTimeSig > 1 )
		{
			// if glTimeSig is greater than 1, it means we've read some time sigs
			// from this track (it was set to 2 inside ReadEvent.) This means that
			// we no longer want ReadEvent to pay any attention to time sigs, so
			// we set this to 0.
			glTimeSig = 0;
		}
		if( dwCurTime > dwLength )
		{
			dwLength = dwCurTime;
		}
        lstTrackEvent = ScanForDuplicatePBends( lstTrackEvent );
		lstTrackEvent = SortEventList( lstTrackEvent );
		lstTrackEvent = CompressEventList( lstTrackEvent );
		lstEvent = List_Cat( lstEvent, lstTrackEvent );
		if( FAILED( pStream->Read( &dwID, sizeof( FOURCC ), NULL ) ) )
		{
			break;
		}
    }
	dwLength = ConvertTime(dwLength);

    lstEvent = SortEventList( lstEvent );

//	if( lstEvent ) Removed: this might be just a band, or sysex data, or whatever.
	{
		if(pSegment)
		{
			IPersistStream* pIPSTrack;
			IDirectMusicTrack*	pDMTrack;

			hr = S_OK;

			if (!g_pChordTrack)
			{
				hr = DirectMusicCreateInstance( 
						CLSID_DirectMusicChordTrack, NULL,
						IID_IDirectMusicTrack,
						(void**)&g_pChordTrack );
				if (SUCCEEDED(hr))
				{
					g_pChordTrack->SetParam(GUID_ChordParam, 0, &g_DefaultChord);
				}
			}
			if (SUCCEEDED(hr))
			{
				pSegment->InsertTrack( g_pChordTrack, 1 );
				g_pChordTrack->Release();
				g_pChordTrack = NULL;
			}

			// Note: We could be checking to see if there are actually tempo events,
			// sysex events, etc. to see if it's really necessary to create these
			// tracks...
			// Create a Tempo Track in which to store the tempo events
			if( gpTempoStream )
			{
				if( SUCCEEDED( DirectMusicCreateInstance( CLSID_DirectMusicTempoTrack,
					NULL, IID_IPersistStream,
					(void**)&pIPSTrack )))
				{
					StreamSeek( gpTempoStream, sizeof(DWORD), STREAM_SEEK_SET );
					gpTempoStream->Write( &gdwSizeTempoStream, sizeof(DWORD), NULL );
					StreamSeek( gpTempoStream, 0, STREAM_SEEK_SET );
					pIPSTrack->Load( gpTempoStream );

					if( SUCCEEDED( pIPSTrack->QueryInterface( IID_IDirectMusicTrack, 
						(void**)&pDMTrack ) ) )
					{
						pSegment->InsertTrack( pDMTrack, 1 );
						pDMTrack->Release();
					}
					pIPSTrack->Release();
				}
			}

			// Add a patch event for each MIDI channel that does not have one
			DMUS_IO_PATCH_ITEM* pPatchEvent = NULL;
			for(DWORD i = 0; i < 16; i++)
			{
				if(gPatchTable[i] == 0)
				{
					pPatchEvent = new DMUS_IO_PATCH_ITEM;

					if(pPatchEvent == NULL)
					{
						continue;
					}
					
					memset(pPatchEvent, 0, sizeof(DMUS_IO_PATCH_ITEM));
					pPatchEvent->lTime = ConvertTime(0);
					pPatchEvent->byStatus = 0xC0 + (BYTE)(i & 0xf);
					pPatchEvent->dwFlags |= (DMUS_IO_INST_PATCH);
					pPatchEvent->pIDMCollection = NULL;
					pPatchEvent->fNotInFile = TRUE;

					pPatchEvent->pNext = lstPatchEvent;
					lstPatchEvent = pPatchEvent;
				}
			}

			if(lstPatchEvent)
			{
				// Create Band Track in which to store patch change events
				IDirectMusicBandTrk* pBandTrack;

				if(SUCCEEDED(DirectMusicCreateInstance(CLSID_DirectMusicBandTrack,
											  NULL, 
											  IID_IDirectMusicBandTrk,
											  (void**)&pBandTrack)))
				{
					// Get the loader from stream so we can open a required collections
					IDirectMusicGetLoader* pIDMGetLoader = NULL;
					IDirectMusicLoader* pIDMLoader = NULL;
	
					HRESULT hr = pStream->QueryInterface(IID_IDirectMusicGetLoader, 
					 									 (void**)&pIDMGetLoader);
					if( SUCCEEDED(hr) )
					{
						hr = pIDMGetLoader->GetLoader(&pIDMLoader);
						pIDMGetLoader->Release();
					}
					// IStream needs a loader attached
					assert(SUCCEEDED(hr));

					// Populate the the Band Track with patch change events
					for(DMUS_IO_PATCH_ITEM* pEvent = lstPatchEvent; pEvent; pEvent = lstPatchEvent)
					{
						// Remove instrument from head of list and give to band
						DMUS_IO_PATCH_ITEM* temp = pEvent->pNext;
						pEvent->pNext = NULL;
						lstPatchEvent = temp;

						// We will try to load the collection but if we can not we will continure
						// and use the default GM on the card
						if(pIDMLoader)
						{
							HRESULT hrTemp = LoadCollection(&pEvent->pIDMCollection, pIDMLoader);
							if (FAILED(hrTemp))
							{
								hrGM = hrTemp;
							}
						}

						hr = pBandTrack->AddBand(pEvent);

						// Release reference to collection
						if(pEvent->pIDMCollection)
						{
							(pEvent->pIDMCollection)->Release();
							pEvent->pIDMCollection = NULL;
						}
						delete pEvent;

						if(FAILED(hr))
						{
							break;						
						}
					}

					if(SUCCEEDED(hr))
					{
		
						TListItem<StampedGMGSXG>* pPair = gMidiModeList.GetHead();
						if( NULL == pPair )
						{
							// if we had nothing, generate a GM one so the band knows
							// it was loaded from a midi file
							// since the first band is set to play at -1,
							// this is when the default midi mode must occur.
							pBandTrack->SetGMGSXGMode(-1, DMUS_MIDIMODEF_GM);
						}
						for ( ; pPair; pPair = pPair->GetNext() )
						{
							StampedGMGSXG& rPair = pPair->GetItemValue();
							pBandTrack->SetGMGSXGMode(rPair.mtTime, rPair.dwMidiMode);
						}
						gMidiModeList.CleanUp();

						if(SUCCEEDED(pBandTrack->QueryInterface(IID_IDirectMusicTrack, 
																(void**)&pDMTrack)))
						{
							pSegment->InsertTrack(pDMTrack, 1);
							pDMTrack->Release();
						}
					}
					
					if(pBandTrack)
					{
						pBandTrack->Release();
					}

					if(pIDMLoader)
					{
						pIDMLoader->Release();
					}
				}

			}

			if( gpTimeSigStream )
			{
				// Create a TimeSig Track to store the TimeSig events
				if( SUCCEEDED( DirectMusicCreateInstance( CLSID_DirectMusicTimeSigTrack,
					NULL, IID_IPersistStream,
					(void**)&pIPSTrack )))
				{
					// set the overall size to the correct size
					StreamSeek( gpTimeSigStream, sizeof(DWORD), STREAM_SEEK_SET );
					gpTimeSigStream->Write( &gdwSizeTimeSigStream, sizeof(DWORD), NULL );
					// reset to beginning and persist to track.
					StreamSeek( gpTimeSigStream, 0, STREAM_SEEK_SET );
					pIPSTrack->Load( gpTimeSigStream );

					if( SUCCEEDED( pIPSTrack->QueryInterface( IID_IDirectMusicTrack, 
						(void**)&pDMTrack ) ) )
					{
						pSegment->InsertTrack( pDMTrack, 1 );
						AddOffsets(lstEvent, pDMTrack);
						pDMTrack->Release();
					}
					pIPSTrack->Release();
				}
			}
			else
			{
				AddOffsets(lstEvent, NULL);
			}

		    lstEvent = SortEventList( lstEvent );

			// Create a Sequence Track in which to store the notes, curves,
			// and SysEx events.
			//
			if( SUCCEEDED( DirectMusicCreateInstance( CLSID_DirectMusicSeqTrack,
				NULL, IID_IPersistStream,
				(void**)&pIPSTrack )))
			{
				// Create a stream in which to place the events so we can
				// give it to the SeqTrack.Load.
				IStream* pEventStream;

				if( S_OK == CreateStreamOnHGlobal( NULL, TRUE, &pEventStream ) )
				{
                    // angusg: The implementation of memory IStream interface on
                    // CE can be inefficient if the stream memory isn't allocated
                    // before. It will call LocalRealloc on every IStream->Write
                    // for the amount that is written (in this case a small amount)
                    // this is incredible inefficient here as Realloc can be called
                    // thousands of times....
                    // The solution is to pre calculate the size of the stream and
                    // call ISteam->SetSize(), which calls LocalAlloc, to alloc the
                    // memory in one call.

                    // calculate the size of the stream storage
                    DWORD   dwStreamStorageSize;
					FullSeqEvent* pEvent;

                    // add the size of the chunk id's written below
                    dwStreamStorageSize = 5 * sizeof(DWORD);
                    // now count how many events need to be stored in the stream
					for( pEvent = lstEvent; pEvent; pEvent = pEvent->pNext )
					{
                        dwStreamStorageSize += sizeof(DMUS_IO_SEQ_ITEM);
					}

                    ULARGE_INTEGER liSize;

                    liSize.QuadPart = dwStreamStorageSize;
                    // make the stream allocate the complete amount of memory
                    pEventStream->SetSize(liSize);

					// Save the events into the stream
					ULONG	cb, cbWritten;

					// Save the chunk id
					DWORD dwTemp = DMUS_FOURCC_SEQ_TRACK;
					pEventStream->Write( &dwTemp, sizeof(DWORD), NULL );
					// Save the overall size. Count the number of events to determine.
					DWORD dwSize = 0;
					for( pEvent = lstEvent; pEvent; pEvent = pEvent->pNext )
					{
						dwSize++;
					}
					dwSize *= sizeof(DMUS_IO_SEQ_ITEM);
					// add 8 for the subchunk
					dwSize += 8;
					pEventStream->Write( &dwSize, sizeof(DWORD), NULL );
					// Save the subchunk id
					dwTemp = DMUS_FOURCC_SEQ_LIST;
					pEventStream->Write( &dwTemp, sizeof(DWORD), NULL );
					// Subtract the previously added 8
					dwSize -= 8;
					// Save the size of the subchunk
					pEventStream->Write( &dwSize, sizeof(DWORD), NULL );
					// Save the structure size.
					dwTemp = sizeof(DMUS_IO_SEQ_ITEM);
					pEventStream->Write( &dwTemp, sizeof(DWORD), NULL );
					// Save the events.
					cb = sizeof(DMUS_IO_SEQ_ITEM); // doesn't have the next pointers
					for( pEvent = lstEvent; pEvent; pEvent = pEvent->pNext )
					{
						if( dwLength < (DWORD)(pEvent->mtTime + pEvent->mtDuration) )
						{
							dwLength = pEvent->mtTime + pEvent->mtDuration;
						}
						pEventStream->Write( pEvent, cb, &cbWritten );
						if( cb != cbWritten ) // error!
						{
							pEventStream->Release();
							pEventStream = NULL;
							hr = DMUS_E_CANNOTREAD;
							break;
						}
					}

					if( pEventStream ) // may be NULL
					{
						StreamSeek( pEventStream, 0, STREAM_SEEK_SET );
						pIPSTrack->Load( pEventStream );
						pEventStream->Release();
					}
				}

				if( SUCCEEDED( pIPSTrack->QueryInterface( IID_IDirectMusicTrack, 
					(void**)&pDMTrack ) ) )
				{
					pSegment->InsertTrack( pDMTrack, 1 );
					pDMTrack->Release();
				}
				pIPSTrack->Release();
			}
			// set the length of the segment. Set it to the measure boundary
			// past the last note.
			DWORD dwResolvedLength = gTimeSig.lTime;
			if( 0 == gTimeSig.bBeat ) gTimeSig.bBeat = 4;
			if( 0 == gTimeSig.bBeatsPerMeasure ) gTimeSig.bBeatsPerMeasure = 4;
			if( 0 == gTimeSig.wGridsPerBeat ) gTimeSig.wGridsPerBeat = 4;
			while( dwResolvedLength < dwLength )
			{
				dwResolvedLength += (((DMUS_PPQ * 4) / gTimeSig.bBeat) * gTimeSig.bBeatsPerMeasure);
			}
			pSegment->SetLength( dwResolvedLength );

			if( gpSysExStream )
			{
				// Create a SysEx Track in which to store the SysEx events
				if( SUCCEEDED( DirectMusicCreateInstance( CLSID_DirectMusicSysExTrack,
					NULL, IID_IPersistStream,
					(void**)&pIPSTrack )))
				{
					// write overall length
					StreamSeek( gpSysExStream, sizeof(DWORD), STREAM_SEEK_SET );
					gpSysExStream->Write( &gdwSizeSysExStream, sizeof(DWORD), NULL );
					// seek to beginning and persist to track
					StreamSeek( gpSysExStream, 0, STREAM_SEEK_SET );
					pIPSTrack->Load( gpSysExStream );

					if( SUCCEEDED( pIPSTrack->QueryInterface( IID_IDirectMusicTrack, 
						(void**)&pDMTrack ) ) )
					{
						pSegment->InsertTrack( pDMTrack, 1 );
						pDMTrack->Release();
					}
					pIPSTrack->Release();
				}
			}

		}
		else
		{
			hr = E_POINTER;
		}
	}
END:
	List_Free( lstEvent );
	List_Free( lstPatchEvent );

    FullSeqEvent::CleanUp();

	// release our hold on the streams
	RELEASE( gpTempoStream );
	RELEASE( gpSysExStream );
	RELEASE( gpTimeSigStream );
	gpTempoStream = NULL;
	gpSysExStream = NULL;
	gpTimeSigStream = NULL;
	gdwSizeTimeSigStream = 0;
	gdwSizeSysExStream = 0;
	gdwSizeTempoStream = 0;
	LeaveCriticalSection(&g_CritSec);

	if (SUCCEEDED(hrGM) || hr != S_OK )
	{
		return hr;
	}
	else
	{
		return DMUS_S_PARTIALLOAD;
	}
}

// Creates and returns (in rChord) a DMUS_CHORD_PARAM given the three input params.
// the new chord will have one subchord containing the root, third, fifth, and seventh
// of the key (as indicated by the sharps/flats and mode).  Scale will be either
// major or minor, depending on the mode (mode is 0 if major, 1 if minor).
void CreateChordFromKey(char cSharpsFlats, BYTE bMode, DWORD dwTime, DMUS_CHORD_PARAM& rChord)
{
	static DWORD dwMajorScale = 0xab5ab5;	// 1010 1011 0101 1010 1011 0101
	static DWORD dwMinorScale = 0x5ad5ad;	// 0101 1010 1101 0101 1010 1101
	static DWORD dwMajor7Chord = 0x891;		// 1000 1001 0001
	static DWORD dwMinor7Chord = 0x489;		// 0100 1000 1001
	BYTE bScaleRoot = 0;
	switch (cSharpsFlats)
	{
	case  0: bScaleRoot = bMode ?  9 :  0; break;
	case  1: bScaleRoot = bMode ?  4 :  7; break;
	case  2: bScaleRoot = bMode ? 11 :  2; break;
	case  3: bScaleRoot = bMode ?  6 :  9; break;
	case  4: bScaleRoot = bMode ?  1 :  4; break;
	case  5: bScaleRoot = bMode ?  8 : 11; break;
	case  6: bScaleRoot = bMode ?  3 :  6; break;
	case  7: bScaleRoot = bMode ? 10 :  1; break;
	case -1: bScaleRoot = bMode ?  2 :  5; break;
	case -2: bScaleRoot = bMode ?  7 : 10; break;
	case -3: bScaleRoot = bMode ?  0 :  3; break;
	case -4: bScaleRoot = bMode ?  5 :  8; break;
	case -5: bScaleRoot = bMode ? 10 :  1; break;
	case -6: bScaleRoot = bMode ?  3 :  6; break;
	case -7: bScaleRoot = bMode ?  8 : 11; break;
	}
	if (bMode)
	{
		wcscpy(rChord.wszName, L"m7");
	}
	else
	{
		wcscpy(rChord.wszName, L"M7");
	}
	DMUS_IO_TIMESIGNATURE_ITEM timesig;
	timesig.bBeat = gTimeSig.bBeat ? gTimeSig.bBeat : 4;
	timesig.bBeatsPerMeasure = gTimeSig.bBeatsPerMeasure ? gTimeSig.bBeatsPerMeasure : 4;
	timesig.wGridsPerBeat = gTimeSig.wGridsPerBeat ? gTimeSig.wGridsPerBeat : 4;
	DWORD dwAbsBeat = dwTime / ((DMUS_PPQ * 4) / timesig.bBeat);
	rChord.wMeasure = (WORD)(dwAbsBeat / timesig.bBeatsPerMeasure);
	rChord.bBeat = (BYTE)(dwAbsBeat % timesig.bBeatsPerMeasure);
	rChord.bSubChordCount = 1;
	rChord.SubChordList[0].dwChordPattern = bMode ? dwMinor7Chord : dwMajor7Chord;
	rChord.SubChordList[0].dwScalePattern = bMode ? dwMinorScale : dwMajorScale;
	rChord.SubChordList[0].dwInversionPoints = 0xffffff;	// inversions allowed everywhere
	rChord.SubChordList[0].dwLevels = 0xffffffff;			// supports all levels
	rChord.SubChordList[0].bChordRoot = bScaleRoot;
	rChord.SubChordList[0].bScaleRoot = bScaleRoot;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\plclock.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation
/*	PLClock.h

  */

#ifndef __PLCLOCK_H__
#define __PLCLOCK_H__

class CPhaseLockClock
{
public:
						CPhaseLockClock();
	void				Start(REFERENCE_TIME rfMasterTime, REFERENCE_TIME rfSlaveTime);
	void				GetSlaveTime(REFERENCE_TIME rfSlaveTime,REFERENCE_TIME *prfTime);
	void				SetSlaveTime(REFERENCE_TIME rfSlaveTime,REFERENCE_TIME *prfTime);
	void				SyncToMaster(REFERENCE_TIME rfSlaveTime, REFERENCE_TIME rfMasterTime,BOOL fLockToMaster);
	void				GetClockOffset(REFERENCE_TIME *prfTime) { *prfTime = m_rfOffset; };
private:
	REFERENCE_TIME		m_rfOffset;
    REFERENCE_TIME      m_rfBaseOffset;
};

class CSampleClock
{
public:
						CSampleClock();
						~CSampleClock();
	void				Start(IReferenceClock *pIClock, DWORD dwSampleRate, DWORD dwSamples);
	void				SampleToRefTime(LONGLONG llSampleTime,REFERENCE_TIME *prfTime);
	void				SyncToMaster(LONGLONG llSampleTime, IReferenceClock *pIClock,BOOL fLockToMaster);
	LONGLONG			RefToSampleTime(REFERENCE_TIME rfTime);
	void				GetClockOffset(REFERENCE_TIME *prfTime) { m_PLClock.GetClockOffset(prfTime); };

private:
	CPhaseLockClock		m_PLClock;
	DWORD				m_dwStart;			// Initial sample offset.
	DWORD				m_dwSampleRate;
};
#endif	// __PLCLOCK_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\dmsstobj.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// DMSStObj.h : Declaration of the CSegState

#ifndef __DIRECTMUSICSEGMENTSTATEOBJECT_H_
#define __DIRECTMUSICSEGMENTSTATEOBJECT_H_

#include "dmusicip.h"
#include "TrkList.h"
#include "alist.h"
#include "audpath.h"

class CPerformance;
class CSegState;
class CGraph;

// Control flags, placed in track->m_dwInternalFlags by ManageControllingTracks().

#define CONTROL_PLAY_IS_DISABLED       0x1   // Indicates the track is already disabled.
#define CONTROL_PLAY_WAS_DISABLED      0x2   // Indicates the track was previously disabled.
#define CONTROL_PLAY_REFRESH           0x4   // Indicates it has been reenabled and needs to be refreshed.
#define CONTROL_PLAY_DEFAULT_DISABLED  0x8   // Indicates it was disabled for playback anyway.
#define CONTROL_PLAY_DEFAULT_ENABLED   0x10  // Indicates it was enabled for playback.

#define CONTROL_NTFY_IS_DISABLED       0x20  // Indicates the track is already disabled for notifications.
#define CONTROL_NTFY_DEFAULT_DISABLED  0x40  // Indicates it was disabled for notifications anyway.
#define CONTROL_NTFY_DEFAULT_ENABLED   0x80  // Indicates it was enabled for notifications.

DEFINE_GUID(IID_CSegState,0xb06c0c26, 0xd3c7, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);

/////////////////////////////////////////////////////////////////////////////
// CSegState
class CSegState : 
	public IDirectMusicSegmentState8,
	public IDirectMusicGraph,
    public AListItem
{
friend class CSegment;
friend class CAudioPath;
friend class CPerformance;
public:
	CSegState();
	~CSegState();

// IUnknown
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // IDirectMusicSegmentState
    STDMETHODIMP GetRepeats(DWORD *pdwRepeats);
	STDMETHODIMP GetSegment(IDirectMusicSegment **ppSegment);
    STDMETHODIMP GetStartTime(MUSIC_TIME __RPC_FAR *);
	STDMETHODIMP Play(MUSIC_TIME mtAmount,MUSIC_TIME *pmtPlayed); // No longer supported.
    STDMETHODIMP GetSeek(MUSIC_TIME *pmtSeek);
	STDMETHODIMP GetStartPoint(MUSIC_TIME *pmtStart);
	STDMETHODIMP Flush(MUSIC_TIME mtTime);
    // IDirectMusicSegmentState8 
    STDMETHODIMP SetTrackConfig( REFGUID rguidTrackClassID,DWORD dwGroup, DWORD dwIndex, DWORD dwFlagsOn, DWORD dwFlagsOff) ;
    STDMETHODIMP GetObjectInPath( DWORD dwPChannel,DWORD dwStage,DWORD dwBuffer, REFGUID guidObject,
                    DWORD dwIndex,REFGUID iidInterface, void ** ppObject);
#ifdef XBOX
    STDMETHODIMP SetVolume(long lVolume,DWORD dwDuration) ;
    STDMETHODIMP SetPitch(long lPitch,DWORD dwDuration) ;
#endif
    // IDirectMusicGraph
	STDMETHODIMP Shutdown();
    STDMETHODIMP InsertTool(IDirectMusicTool *pTool,DWORD *pdwPChannels,DWORD cPChannels,LONG lIndex);
    STDMETHODIMP GetTool(DWORD,IDirectMusicTool**);
    STDMETHODIMP RemoveTool(IDirectMusicTool*);
    STDMETHODIMP StampPMsg(DMUS_PMSG* pEvent);

    // Methods used by performance to access SegmentState.
	HRESULT PrivateInit(CSegment *pParentSegment,CPerformance *pPerformance);
    HRESULT InitRoute(IDirectMusicAudioPath *pAudioPath);
    HRESULT ShutDown(void); // called from ~SEGSTNODE in dmperf.h
	HRESULT GetTrackList(void** ppTrackList);
    HRESULT SetSeek(MUSIC_TIME mtSeek,DWORD dwPlayFlags);
    HRESULT SetInvalidate(MUSIC_TIME mtTime);
	MUSIC_TIME GetEndTime(MUSIC_TIME mtStartTime);
	HRESULT ConvertToSegTime(MUSIC_TIME* pmtTime, MUSIC_TIME* pmtOffset, DWORD* pdwRepeat);
	HRESULT AbortPlay( MUSIC_TIME mtTime, BOOL fLeaveNotesOn ); // called when the segstate is stopped prematurely
	HRESULT CheckPlay( MUSIC_TIME mtAmount, MUSIC_TIME* pmtResult );
    HRESULT Play(MUSIC_TIME mtAmount);  
    HRESULT GetParam( CPerformance *pPerf,REFGUID rguidType,DWORD dwGroupBits,
        DWORD dwIndex,MUSIC_TIME mtTime,MUSIC_TIME* pmtNext,void* pParam);	

    CSegState* GetNext() { return (CSegState*)AListItem::GetNext();}
private:
    CMemTrack                   m_MemTrack;
    CTrack *GetTrackByParam(CTrack * pCTrack,REFGUID rguidType,DWORD dwGroupBits,DWORD dwIndex);
    CTrack *GetTrack(REFCLSID rType,DWORD dwGroupBits,DWORD dwIndex);
	void GenerateNotification( DWORD dwNotification, MUSIC_TIME mtTime );
	void SendDirtyPMsg( MUSIC_TIME mtTime );
public:
// Attributes
    CRITICAL_SECTION            m_CriticalSection;
	IUnknown*					m_pUnkDispatch; // holds the controlling unknown of the scripting object that implements IDispatch
	CPerformance*	            m_pPerformance;
	CSegment*		            m_pSegment;     // Holds the parent segment pointer, weak reference, for convenience
    CAudioPath*                 m_pAudioPath;   // Maps vchannels to pchannels, if requested.
    CGraph*                     m_pGraph;       // Temp graph is a copy of the segment's graph.
    CTrackList	                m_TrackList;	// list of Tracks held in this SegmentState
    MUSIC_TIME					m_mtLoopStart;  // Loop start point.
	MUSIC_TIME					m_mtLoopEnd;    // Loop end point.
	DWORD						m_dwRepeats;    // The original repeat setting (before countdown)
	MUSIC_TIME					m_mtLength;     // Length of segment.
	DWORD						m_dwPlayTrackFlags;// Track playback controlflags.
    DWORD						m_dwPlaySegFlags;// Segment playback control flags.
    DWORD                       m_dwSegFlags;   // New Segment Flags from file.
    MUSIC_TIME					m_mtResolvedStart;// Start time resolved to desired resolution
	MUSIC_TIME					m_mtEndTime;    // End time that the segment should play to if not stopped. 
	MUSIC_TIME					m_mtOffset;     // Start time of the segment in absolute time, as if it were started from the beginning. 
    MUSIC_TIME					m_mtLastPlayed; // the last played absolute time
	MUSIC_TIME					m_mtStopTime;     // Used to stop play at a specific time. Ignored when 0.
	MUSIC_TIME					m_mtSeek;       // How far into the segment we are.
	MUSIC_TIME					m_mtStartPoint; // Point in the segment where playback started
    MUSIC_TIME                  m_mtAbortTime;  // Time a sudden stop occured.
    MUSIC_TIME                  m_mtFirstLoopStart; // The music time for the loop start when it starts looping the VERY FIRST time 
    MUSIC_TIME                  m_mtCurLoopStart; // The music time for the loop start when clock time looping is enforced.
    MUSIC_TIME                  m_mtCurLoopEnd; // The music time for the loop end when clock time looping is enforced.
    REFERENCE_TIME              m_rtLoopStart;  // Clock time loop start.
    REFERENCE_TIME              m_rtLoopEnd;    // Clock time loop end. 
	REFERENCE_TIME				m_rtGivenStart; // Start time given in PlaySegment, unquantized
    REFERENCE_TIME              m_rtLastPlayed; // Clock time version of the last played absolute time
	REFERENCE_TIME				m_rtStartPoint; // Clock time version of point in the segment where playback started
	REFERENCE_TIME				m_rtOffset;     // Clock time version of start time of the segment in absolute time, as if it were started from the beginning. 
    REFERENCE_TIME              m_rtEndTime;    // Clock time version of full length.
    REFERENCE_TIME				m_rtSeek;       // Clock time version of how far into the segment we are.
    REFERENCE_TIME              m_rtLength;     // Clock time length, read from file. If 0, ignore.
    REFERENCE_TIME              m_rtFirstLoopStart; // The clock time for the loop start when it starts looping the VERY FIRST time 
    REFERENCE_TIME              m_rtCurLoopStart;// The clock time for the loop start for the current loop repetition
    REFERENCE_TIME              m_rtCurLoopEnd; // The clock time for the loop end in the current loop repetition
    REFERENCE_TIME              m_rtLastVolChange; // Track the last volume change. */
    REFERENCE_TIME              m_rtLastPitchChange; // Track the last pitch change. */
    DWORD						m_dwRepeatsLeft;// Current repeats left.
	BOOL						m_fStartedPlay; // indicates if the segstate has started to play yet
    DWORD                       m_dwVersion;    // Which release does the app think it is using - 6, 7, or 8..
    DWORD                       m_dwFirstTrackID;// Virtual ID of first track in segstate.
    DWORD                       m_dwLastTrackID;// Last track's virtual id.
    BOOL                        m_fPrepped;     // Used to track whether PrepSegToPlay has been called.
    BOOL                        m_fSongMode;    // True if part of a playing song. If so, this should queue the next segment when done.
	BOOL						m_fCanStop;		// If false, Stop() should ignore this segment (it was just queued to play by PlaySegmentEx().)
    BOOL                        m_fInPlay;      // Segmentstate is currently playing.   
    BOOL                        m_fDelayShutDown;
    CSegState *                 m_pSongSegState;// Used to track the starting segstate in a song.
    long						m_cRef;         // COM reference counter.
	DWORD						m_dwTrackID;	// Audiopath gets a track id for all broadcast PMsgs sent via it.
};

class CSegStateList : public AList
{
public:
    void AddHead(CSegState* pSegState) { AList::AddHead((AListItem*)pSegState);}
    void Insert(CSegState* pSegState);
    CSegState* GetHead(){return (CSegState*)AList::GetHead();}
    CSegState* GetItem(LONG lIndex){return (CSegState*)AList::GetItem(lIndex);}
    CSegState* RemoveHead() {return (CSegState *) AList::RemoveHead();}
    void Remove(CSegState* pSegState){AList::Remove((AListItem*)pSegState);}
    void AddTail(CSegState* pSegState){AList::AddTail((AListItem*)pSegState);}
    CSegState* GetTail(){ return (CSegState*)AList::GetTail();}
    void SetID(DWORD dwID) { m_dwID = dwID; }
    DWORD GetID() { return m_dwID; }
private:
    DWORD       m_dwID;         // Identifies which segstate list this is.
};

#endif //__DIRECTMUSICSEGMENTSTATEOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\seqtrack.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// SeqTrack.h : Declaration of the CSeqTrack

#ifndef __SEQTRACK_H_
#define __SEQTRACK_H_

#include "dmusicip.h"
#include "dmusicf.h"
#include "..\dmstyle\tlist.h"
#include "PChMap.h"

struct SeqStateData
{
	DWORD						dwPChannelsUsed; // number of PChannels
	// the following two arrays are allocated to the size of dwNumPChannels, which
	// must match the SeqTrack's m_dwPChannelsUsed. The arrays match one-for-one with
	// the parts inside the SeqTrack.
	TListItem<DMUS_IO_SEQ_ITEM>**	apCurrentSeq; // array of size dwNumPChannels
	TListItem<DMUS_IO_CURVE_ITEM>**	apCurrentCurve; // array of size dwNumPChannels
	DWORD						dwValidate;
	MUSIC_TIME					mtCurTimeSig; // time the current timesig started
	MUSIC_TIME					mtNextTimeSig; // time for the next timesig
	DWORD						dwMeasure; // starting measure # of the timesig
	DWORD						dwlnBeat; // length of a beat
	DWORD						dwlnMeasure; // length of a measure
	DWORD						dwlnGrid; // length of a grid
	DWORD						dwGroupBits; // the group bits of this track

	SeqStateData()
	{
		mtCurTimeSig = 0;
		mtNextTimeSig = 0;
		dwMeasure = 0;
		dwlnBeat = DMUS_PPQ;
		dwlnMeasure = DMUS_PPQ * 4;
		dwlnGrid = DMUS_PPQ / 4;
		apCurrentSeq = NULL;
		apCurrentCurve = NULL;
	}
	~SeqStateData()
	{
		if( apCurrentSeq )
		{
			delete [] apCurrentSeq;
		}
		if( apCurrentCurve )
		{
			delete [] apCurrentCurve;
		}
	}
};

// SEQ_PART represents all of the DMUS_PMSG's inside the SeqTrack for one PChannel
struct SEQ_PART
{
	SEQ_PART*			pNext;
	DWORD				dwPChannel;
	TList<DMUS_IO_SEQ_ITEM>	seqList;
	TList<DMUS_IO_CURVE_ITEM>	curveList;

	SEQ_PART() : pNext(NULL) {}; // always initialize pNext to NULL
};

/////////////////////////////////////////////////////////////////////////////
// CSeqTrack
class CSeqTrack : 
	public IPersistStream,
	public IDirectMusicTrack8
{
public:
	CSeqTrack();
	CSeqTrack(
		const CSeqTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd);
	~CSeqTrack();

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

// IDirectMusicTrack methods
    STDMETHODIMP IsParamSupported(REFGUID rguid);
    STDMETHODIMP Init(IDirectMusicSegment *pSegment);
    STDMETHODIMP InitPlay(IDirectMusicSegmentState *pSegmentState,
                IDirectMusicPerformance *pPerformance,
                void **ppStateData,
                DWORD dwTrackID,
                DWORD dwFlags);
    STDMETHODIMP EndPlay(void *pStateData);
    STDMETHODIMP Play(void *pStateData,MUSIC_TIME mtStart,
                MUSIC_TIME mtEnd,MUSIC_TIME mtOffset,
		        DWORD dwFlags,IDirectMusicPerformance* pPerf,
		        IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID);
    STDMETHODIMP GetParam(REFGUID rguid,MUSIC_TIME mtTime,MUSIC_TIME* pmtNext,void *pData);
    STDMETHODIMP SetParam(REFGUID rguid,MUSIC_TIME mtTime,void *pData);
    STDMETHODIMP AddNotificationType(REFGUID rguidNotification);
    STDMETHODIMP RemoveNotificationType(REFGUID rguidNotification);
    STDMETHODIMP Clone(MUSIC_TIME mtStart,MUSIC_TIME mtEnd,IDirectMusicTrack** ppTrack);
// IDirectMusicTrack8 
    STDMETHODIMP PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf, 
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) ; 
    STDMETHODIMP GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) ; 
    STDMETHODIMP SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,void* pParam, void * pStateData, DWORD dwFlags) ;
    STDMETHODIMP Compose(IUnknown* pContext, 
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;
    STDMETHODIMP Join(IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;
// IPersist functions
    STDMETHODIMP GetClassID( CLSID* pClsId );
// IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load( IStream* pIStream );
    STDMETHODIMP Save( IStream* pIStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER FAR* pcbSize );

protected:
	HRESULT STDMETHODCALLTYPE Seek( 
		IDirectMusicSegmentState*,
		IDirectMusicPerformance*,
		DWORD dwVirtualID,
		SeqStateData*,
		MUSIC_TIME mtTime,
		BOOL fGetPrevious,
		MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
        BOOL fClockTime);
	void SendSeekItem( 
		IDirectMusicPerformance*,
		IDirectMusicGraph*,
		IDirectMusicSegmentState*,
		SeqStateData* pSD,
		DWORD dwVirtualID,
		MUSIC_TIME mtTime,
		MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
		TListItem<DMUS_IO_SEQ_ITEM>*,
		TListItem<DMUS_IO_CURVE_ITEM>*,
        BOOL fClockTime);
    HRESULT Play(
        void *pStateData,	
        MUSIC_TIME mtStart,	
        MUSIC_TIME mtEnd,
        MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
	    DWORD dwFlags,		
	    IDirectMusicPerformance* pPerf,	
	    IDirectMusicSegmentState* pSegSt,
	    DWORD dwVirtualID,
        BOOL fClockTime);
	void Construct(void);
	HRESULT LoadCurve( IStream* pIStream, long lSize );
	HRESULT LoadSeq( IStream* pIStream, long lSize );
	void UpdateTimeSig(IDirectMusicSegmentState*, SeqStateData* pSD, MUSIC_TIME mt);
	TListItem<SEQ_PART>* FindPart( DWORD dwPChannel );
	void DeleteSeqPartList(void);
	void SetUpStateCurrentPointers(SeqStateData* pStateData);

// member variables
private:
	TList<SEQ_PART>			m_SeqPartList;
	TListItem<SEQ_PART>*	m_pSeqPartCache;	// used to time-optimize FindPart()
	DWORD					m_dwPChannelsUsed;
	DWORD*					m_aPChannels;
	long					m_cRef;
	DWORD					m_dwValidate; // used to validate state data
	CRITICAL_SECTION		m_CrSec;
    BOOL                    m_fCSInitialized;
	CPChMap					m_PChMap;
    CMemTrack               m_MemTrack;             // For debug memory tracking.
};

#endif //__SEQTRACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\segtrtrk.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CSegTriggerTrack.
//

// This track type holds events that cause other segments to be cued at
// specific points during playback of a segment.

#pragma once

#include "trackhelp.h"
#include "tlist.h"
#include "smartref.h"

//////////////////////////////////////////////////////////////////////
// Types

// Items in list of events
struct TriggerInfo
{
	TriggerInfo() : lTriggerTime(0), lTimePhysical(0), dwPlayFlags(0), dwFlags(0), pIDMSegment(NULL) {}
	~TriggerInfo() {
		RELEASE(pIDMSegment);
	}

	HRESULT Clone(const TriggerInfo &o, MUSIC_TIME mtStart)
	{
		lTriggerTime = o.lTriggerTime - mtStart;
		lTimePhysical = o.lTimePhysical - mtStart;
		dwPlayFlags = o.dwPlayFlags;
		dwFlags = o.dwFlags;
		pIDMSegment = o.pIDMSegment;
		pIDMSegment->AddRef();
		return S_OK;
	}

	// from event header chunk <scrh>
	MUSIC_TIME lTriggerTime; // Logical time
	MUSIC_TIME lTimePhysical;
	DWORD dwPlayFlags;
	DWORD dwFlags;
	// from reference <DMRF>
	IDirectMusicSegment *pIDMSegment;
};

// State data.  This track needs to get the audio path that's currently playing so that it
// can use it when playing triggered segments.
struct CSegTriggerTrackState : public CStandardStateData<TriggerInfo>
{
	CSegTriggerTrackState() : pAudioPath(NULL) {};
	~CSegTriggerTrackState() { if (pAudioPath) pAudioPath->Release(); }
	IDirectMusicAudioPath *pAudioPath;
};

//////////////////////////////////////////////////////////////////////
// CSegTriggerTrack

class CSegTriggerTrack;
typedef CPlayingTrack<CSegTriggerTrack, TriggerInfo, CSegTriggerTrackState> CSegTriggerTrackBase;

class CSegTriggerTrack
  : public CSegTriggerTrackBase
{
public:
	// When the segment trigger track plays one of its items, it plays a segment.  If an invalidation occurs, that Play operation
	// can't be retracted.  Then the track is played again (with the FLUSH bit set).  This was causing it to trigger the segment
	// a second time.  To fix this, the last parameter to the CSegTriggerTrackBase is false, which instructs it not to call play
	// a second time when the FLUSH bit is set.
	CSegTriggerTrack(HRESULT *pHr) : CSegTriggerTrackBase(&g_cComponent, CLSID_DirectMusicSegmentTriggerTrack, true, false), m_dwFlags(NULL), m_dwRecursionCount(0) {}

	// Implement SetParam by calling SetParam in turn on all the child segments.  This is needed, for example so that downloading a segment with a segment trigger track will download all the triggered segments as well.
	STDMETHOD(IsParamSupported)(REFGUID rguid) { return S_OK; } // Once or more of our child segments could potentially support any type of parameter.
	STDMETHOD(SetParam)(REFGUID rguid, MUSIC_TIME mtTime, void *pData);

	STDMETHOD(InitPlay)(
		IDirectMusicSegmentState *pSegmentState,
		IDirectMusicPerformance *pPerformance,
		void **ppStateData,
		DWORD dwTrackID,
		DWORD dwFlags);

protected:
	HRESULT PlayItem(
		const TriggerInfo &item,
		statedata &state,
		IDirectMusicPerformance *pPerf,
		IDirectMusicSegmentState* pSegSt,
		DWORD dwVirtualID,
		MUSIC_TIME mtOffset,
		REFERENCE_TIME rtOffset,
		bool fClockTime);
	HRESULT LoadRiff(SmartRef::RiffIter &ri, IDirectMusicLoader *pIDMLoader);

private:
	HRESULT LoadTrigger(SmartRef::RiffIter ri, IDirectMusicLoader *pIDMLoader);

	// Data
	DWORD m_dwFlags; // from track header (sgth chunk)
    BOOL  m_dwRecursionCount; // Used to keep track of recursive calls to self.
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\seqtrack.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// INITIALIZE_CRITICAL_SECTION. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)
#include "pchime.h"
/*
// SeqTrack.cpp : Implementation of CSeqTrack
#include "dmime.h"
#include "dmperf.h"
#include "SeqTrack.h"
#include "dmusici.h"
#include "dmusicf.h"
#include "debug.h"
#include "..\shared\Validate.h"
#include "debug.h"
#define ASSERT	assert*/

// @doc EXTERNAL
#define MIDI_NOTEOFF    0x80
#define MIDI_NOTEON     0x90
#define MIDI_PTOUCH     0xA0
#define MIDI_CCHANGE    0xB0
#define MIDI_PCHANGE    0xC0
#define MIDI_MTOUCH     0xD0
#define MIDI_PBEND      0xE0
#define MIDI_SYSX       0xF0
#define MIDI_MTC        0xF1
#define MIDI_SONGPP     0xF2
#define MIDI_SONGS      0xF3
#define MIDI_EOX        0xF7
#define MIDI_CLOCK      0xF8
#define MIDI_START      0xFA
#define MIDI_CONTINUE   0xFB
#define MIDI_STOP       0xFC
#define MIDI_SENSE      0xFE
#define MIDI_CC_BS_MSB		0x00
#define MIDI_CC_BS_LSB		0x20

/////////////////////////////////////////////////////////////////////////////
// CSeqTrack
void CSeqTrack::Construct()
{
    IncrementDLLCount();

	m_pSeqPartCache = NULL;
	m_dwPChannelsUsed = 0;
	m_aPChannels = NULL;
	m_dwValidate = 0;
    m_fCSInitialized = FALSE;
	INITIALIZE_CRITICAL_SECTION(&m_CrSec);
    m_fCSInitialized = TRUE;
	m_cRef = 1;
}

CSeqTrack::CSeqTrack() : m_MemTrack(DMTRACK_SEQUENCE_TRACK)
{
	Construct();
}

CSeqTrack::CSeqTrack(
		const CSeqTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd) : m_MemTrack(DMTRACK_SEQUENCE_TRACK)
{
	Construct();
	m_dwPChannelsUsed = rTrack.m_dwPChannelsUsed;
	if( m_dwPChannelsUsed )
	{
		m_aPChannels = new DWORD[m_dwPChannelsUsed];
        if (m_aPChannels)
        {
		    memcpy( m_aPChannels, rTrack.m_aPChannels, sizeof(DWORD) * m_dwPChannelsUsed );
        }
	}

	TListItem<SEQ_PART>* pPart = rTrack.m_SeqPartList.GetHead();
	for( ; pPart; pPart = pPart->GetNext() )
	{
		TListItem<SEQ_PART>* pNewPart = new TListItem<SEQ_PART>;
		if( pNewPart )
		{
			pNewPart->GetItemValue().dwPChannel = pPart->GetItemValue().dwPChannel;
			TListItem<DMUS_IO_SEQ_ITEM>* pScan = pPart->GetItemValue().seqList.GetHead();

			for(; pScan; pScan = pScan->GetNext())
			{
				DMUS_IO_SEQ_ITEM& rScan = pScan->GetItemValue();
				if( rScan.mtTime < mtStart )
				{
					continue;
				}
				if (rScan.mtTime < mtEnd)
				{
					TListItem<DMUS_IO_SEQ_ITEM>* pNew = new TListItem<DMUS_IO_SEQ_ITEM>;
					if (pNew)
					{
						DMUS_IO_SEQ_ITEM& rNew = pNew->GetItemValue();
						memcpy( &rNew, &rScan, sizeof(DMUS_IO_SEQ_ITEM) );
						rNew.mtTime = rScan.mtTime - mtStart;
						pNewPart->GetItemValue().seqList.AddHead(pNew); // AddTail can get expensive (n^2), so
													// AddHead instead and Reverse later.
					}
				}
				else break;
			}
			pNewPart->GetItemValue().seqList.Reverse(); // since we AddHead'd earlier.

			TListItem<DMUS_IO_CURVE_ITEM>* pScanCurve = pPart->GetItemValue().curveList.GetHead();

			for(; pScanCurve; pScanCurve = pScanCurve->GetNext())
			{
				DMUS_IO_CURVE_ITEM& rScan = pScanCurve->GetItemValue();
				if( rScan.mtStart < mtStart )
				{
					continue;
				}
				if (rScan.mtStart < mtEnd)
				{
					TListItem<DMUS_IO_CURVE_ITEM>* pNew = new TListItem<DMUS_IO_CURVE_ITEM>;
					if (pNew)
					{
						DMUS_IO_CURVE_ITEM& rNew = pNew->GetItemValue();
						memcpy( &rNew, &rScan, sizeof(DMUS_IO_CURVE_ITEM) );
						rNew.mtStart = rScan.mtStart - mtStart;
						pNewPart->GetItemValue().curveList.AddHead(pNew); // AddTail can get expensive (n^2), so
													// AddHead instead and Reverse later.
					}
				}
				else break;
			}
			pNewPart->GetItemValue().curveList.Reverse(); // since we AddHead'd earlier.
			m_SeqPartList.AddHead(pNewPart);
		}
		m_SeqPartList.Reverse();
	}
}

CSeqTrack::~CSeqTrack()
{
    if (m_fCSInitialized)
    {
        DeleteSeqPartList();                // This will be empty if critical section
                                            // never got initialized.
	    DELETE_CRITICAL_SECTION(&m_CrSec);
    }

    DecrementDLLCount();
}

// @method:(INTERNAL) HRESULT | IDirectMusicTrack | QueryInterface | Standard QueryInterface implementation for <i IDirectMusicSeqTrack>
//
// @rdesc Returns one of the following:
//
// @flag S_OK | If the interface is supported and was returned
// @flag E_NOINTERFACE | If the object does not support the given interface.
// @flag E_POINTER | <p ppv> is NULL or invalid.
//
STDMETHODIMP CSeqTrack::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
	V_INAME(CSeqTrack::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

   if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack || iid == IID_IDirectMusicTrack8)
    {
        *ppv = static_cast<IDirectMusicTrack*>(this);
    } else
	if (iid == IID_IPersistStream)
	{
        *ppv = static_cast<IPersistStream*>(this);
	} else
    {
        *ppv = NULL;
        Trace(4,"Warning: Request to query unknown interface on Sequence Track\n");
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


// @method:(INTERNAL) HRESULT | IDirectMusicTrack | AddRef | Standard AddRef implementation for <i IDirectMusicSeqTrack>
//
// @rdesc Returns the new reference count for this object.
//
STDMETHODIMP_(ULONG) CSeqTrack::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


// @method:(INTERNAL) HRESULT | IDirectMusicTrack | Release | Standard Release implementation for <i IDirectMusicSeqTrack>
//
// @rdesc Returns the new reference count for this object.
//
STDMETHODIMP_(ULONG) CSeqTrack::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CSeqTrack::GetClassID( CLSID* pClassID )
{
	V_INAME(CSeqTrack::GetClassID);
	V_PTR_WRITE(pClassID, CLSID); 
	*pClassID = CLSID_DirectMusicSeqTrack;
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPersistStream functions

HRESULT CSeqTrack::IsDirty()
{
	return S_FALSE;
}

/*

  method HRESULT | ISeqTrack | LoadSeq |
  Call this with an IStream filled with SeqEvents, sorted in time order.
  parm IStream* | pIStream |
  A stream of SeqEvents, sorted in time order. The seek pointer should point
  to the first event. The stream should contain only SeqEvents and nothing more.
  rvalue E_POINTER | If pIStream == NULL or invalid.
  rvalue S_OK | Success.
  comm The <p pIStream> will be AddRef'd inside this function and held
  until the SeqTrack is released.
*/
HRESULT CSeqTrack::LoadSeq( IStream* pIStream, long lSize )
{
	HRESULT hr = S_OK;
	TListItem<SEQ_PART>* pPart;

	ENTER_CRITICAL_SECTION(&m_CrSec);

	// copy contents of the stream into the list.
	LARGE_INTEGER li;
	DMUS_IO_SEQ_ITEM seqEvent;
	DWORD dwSubSize;
	// read in the size of the data structures
	if( FAILED( pIStream->Read( &dwSubSize, sizeof(DWORD), NULL )))
	{
        Trace(1,"Error: Failure reading sequence track.\n");
		hr = DMUS_E_CANNOTREAD;
		goto END;
	}
	lSize -= sizeof(DWORD);

	DWORD dwRead, dwSeek;
	if( dwSubSize > sizeof(DMUS_IO_SEQ_ITEM) )
	{
		dwRead = sizeof(DMUS_IO_SEQ_ITEM);
		dwSeek = dwSubSize - dwRead;
		li.HighPart = 0;
		li.LowPart = dwSeek;
	}
	else
	{
		if( dwSubSize == 0 )
		{
            Trace(1,"Error: Failure reading sequence track.\n");
			hr = DMUS_E_CHUNKNOTFOUND;
			goto END;
		}
		dwRead = dwSubSize;
		dwSeek = 0;
	}
	if( 0 == dwRead )
	{
		hr = DMUS_E_CANNOTREAD;
		goto END;
	}
	while( lSize > 0 )
	{
		if( FAILED( pIStream->Read( &seqEvent, dwRead, NULL )))
		{
            Trace(1,"Error: Failure reading sequence track.\n");
			hr = DMUS_E_CANNOTREAD;
			goto END;
		}
		lSize -= dwRead;
		if( dwSeek )
		{
			if( FAILED( pIStream->Seek( li, STREAM_SEEK_CUR, NULL )))
			{
				hr = DMUS_E_CANNOTSEEK;
				goto END;
			}
			lSize -= dwSeek;
		}
		pPart = FindPart(seqEvent.dwPChannel);
		if( pPart )
		{
			TListItem<DMUS_IO_SEQ_ITEM>* pEvent = new TListItem<DMUS_IO_SEQ_ITEM>(seqEvent);
			if( pEvent )
			{
				pPart->GetItemValue().seqList.AddHead(pEvent); // AddTail can get
															// expensive (n pow 2) so
															// AddHead instead and reverse later.
			}
		}
	}
END:
	for( pPart = m_SeqPartList.GetHead(); pPart; pPart = pPart->GetNext() )
	{
		pPart->GetItemValue().seqList.Reverse(); // since we AddHead'd earlier
	}
	m_dwValidate++; // used to validate state data that's out there
	LEAVE_CRITICAL_SECTION(&m_CrSec);
	return hr;
}

/*
  method HRESULT | LoadCurve
  Call this with an IStream filled with CurveEvents, sorted in time order.
  parm IStream* | pIStream |
  A stream of CurveEvents, sorted in time order. The seek pointer should point
  to the first event. The stream should contain only CurveEvents and nothing more.
  rvalue E_POINTER | If pIStream == NULL or invalid.
  rvalue S_OK | Success.
There are also other error codes.
  comm The <p pIStream> will be AddRef'd inside this function and held
  until the CurveTrack is released.
*/
HRESULT CSeqTrack::LoadCurve( IStream* pIStream, long lSize )
{
	HRESULT hr = S_OK;
	TListItem<SEQ_PART>* pPart;

	ENTER_CRITICAL_SECTION(&m_CrSec);

	DWORD dwSubSize;
	// copy contents of the stream into the list.
	LARGE_INTEGER li;
	DMUS_IO_CURVE_ITEM curveEvent;
	// read in the size of the data structures
	if( FAILED( pIStream->Read( &dwSubSize, sizeof(DWORD), NULL )))
	{
        Trace(1,"Error: Failure reading sequence track.\n");
		hr = DMUS_E_CANNOTREAD;
		goto END;
	}
	lSize -= sizeof(DWORD);

	DWORD dwRead, dwSeek;
	if( dwSubSize > sizeof(DMUS_IO_CURVE_ITEM) )
	{
		dwRead = sizeof(DMUS_IO_CURVE_ITEM);
		dwSeek = dwSubSize - dwRead;
		li.HighPart = 0;
		li.LowPart = dwSeek;
	}
	else
	{
		if( dwSubSize == 0 )
		{
            Trace(1,"Error: Failure reading sequence track - bad data.\n");
			hr = DMUS_E_CHUNKNOTFOUND;
			goto END;
		}
		dwRead = dwSubSize;
		dwSeek = 0;
	}
	if( 0 == dwRead )
	{
        Trace(1,"Error: Failure reading sequence track - bad data.\n");
		hr = DMUS_E_CANNOTREAD;
		goto END;
	}
	while( lSize > 0 )
	{
        curveEvent.wMergeIndex = 0; // Older format doesn't support this.
		if( FAILED( pIStream->Read( &curveEvent, dwRead, NULL )))
		{
			hr = DMUS_E_CANNOTREAD;
			break;
		}
        // Sometimes, we get a pitch bend in a file that has bogus data in wParamType, which will
        // cause pitch bend range to be set incorrectly.
        if (curveEvent.bType == DMUS_CURVET_PBCURVE)
        {
            curveEvent.wParamType = 0;
        }
		lSize -= dwRead;
		if( dwSeek )
		{
			pIStream->Seek( li, STREAM_SEEK_CUR, NULL );
			lSize -= dwSeek;
		}
		pPart = FindPart(curveEvent.dwPChannel);
		if( pPart )
		{
			TListItem<DMUS_IO_CURVE_ITEM>* pEvent = new TListItem<DMUS_IO_CURVE_ITEM>(curveEvent);
			if( pEvent )
			{
				pPart->GetItemValue().curveList.AddHead(pEvent); // AddTail can get
															// expensive (n pow 2) so
															// AddHead instead and reverse later.
			}
		}
	}
END:
	for( pPart = m_SeqPartList.GetHead(); pPart; pPart = pPart->GetNext() )
	{
		pPart->GetItemValue().curveList.Reverse(); // since we AddHead'd earlier
	}
	m_dwValidate++; // used to validate state data that's out there
	LEAVE_CRITICAL_SECTION(&m_CrSec);
	return hr;
}

HRESULT CSeqTrack::Load( IStream* pIStream )
{
	V_INAME(CSeqTrack::Load);
	V_INTERFACE(pIStream);
	HRESULT hr = S_OK;

	ENTER_CRITICAL_SECTION(&m_CrSec);
	m_dwValidate++; // used to validate state data that's out there
	DeleteSeqPartList();
	LEAVE_CRITICAL_SECTION(&m_CrSec);

	// read in the chunk id
	long lSize;
	DWORD dwChunk;
	if( FAILED( pIStream->Read( &dwChunk, sizeof(DWORD), NULL )))
	{
        Trace(1,"Error: Failure reading sequence track.\n");
		hr = DMUS_E_CANNOTREAD;
		goto END;
	}
	if( dwChunk != DMUS_FOURCC_SEQ_TRACK )
	{
        Trace(1,"Error: Failure reading sequence track - bad data.\n");
		hr = DMUS_E_CHUNKNOTFOUND;
		goto END;
	}
	// read in the overall size
	if( FAILED( pIStream->Read( &lSize, sizeof(long), NULL )))
	{
		hr = DMUS_E_CANNOTREAD;
		goto END;
	}
	while( lSize )
	{
		DWORD dwSubChunk, dwSubSize;
		if( FAILED( pIStream->Read( &dwSubChunk, sizeof(DWORD), NULL )))
		{
            Trace(1,"Error: Failure reading sequence track.\n");
			hr = DMUS_E_CANNOTREAD;
			goto END;
		}
		lSize -= sizeof(DWORD);
		// read in the overall size
		if( FAILED( pIStream->Read( &dwSubSize, sizeof(DWORD), NULL )))
		{
            Trace(1,"Error: Failure reading sequence track.\n");
			hr = DMUS_E_CANNOTREAD;
			goto END;
		}
		if( (dwSubSize == 0) || (dwSubSize > (DWORD)lSize) )
		{
            Trace(1,"Error: Failure reading sequence track - bad data.\n");
			hr = DMUS_E_CHUNKNOTFOUND;
			goto END;
		}
		lSize -= sizeof(DWORD);
		switch( dwSubChunk )
		{
		case DMUS_FOURCC_SEQ_LIST:
			if( FAILED( hr = LoadSeq( pIStream, dwSubSize )))
			{
				goto END;
			}
			break;
		case DMUS_FOURCC_CURVE_LIST:
			if( FAILED( hr = LoadCurve( pIStream, dwSubSize )))
			{
				goto END;
			}
			break;
		default:
			LARGE_INTEGER li;
			li.HighPart = 0;
			li.LowPart = dwSubSize;
			if( FAILED( pIStream->Seek( li, STREAM_SEEK_CUR, NULL )))
			{
				hr = DMUS_E_CANNOTREAD;
				goto END;
			}
			break;
		}
		lSize -= dwSubSize;
	}
END:
	return hr;
}
	
HRESULT CSeqTrack::Save( IStream* pIStream, BOOL fClearDirty )
{
	return E_NOTIMPL;
}

HRESULT CSeqTrack::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
	return E_NOTIMPL;
}

// IDirectMusicTrack
/*
@method HRESULT | IDirectMusicTrack | IsParamSupported |
Check to see if the Track supports data types in <om .GetParam> and <om .SetParam>.

@rvalue S_OK | It does support the type of data.
@rvalue S_FALSE | It does not support the type of data.
@rvalue E_NOTIMPL | (Or any other failure code) It does not support the type of data.

@comm Note that it is valid for a Track to return different results for the same
guid depending on its current state.
*/
HRESULT STDMETHODCALLTYPE CSeqTrack::IsParamSupported( 
    REFGUID rguidType)	// @parm The guid identifying the type of data to check.
{
	return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack::Init
/*
@method HRESULT | IDirectMusicTrack | Init |
When a track is first added to a <i IDirectMusicSegment>, this method is called
by that Segment.

@rvalue S_OK | Success.
@rvalue E_POINTER | <p pSegment> is NULL or invalid.

@comm If the Track plays messages, it should call <om IDirectMusicSegment.SetPChannelsUsed>.
*/
HRESULT CSeqTrack::Init( 
    IDirectMusicSegment *pSegment)	// @parm Pointer to the Segment to which this Track belongs.
{
	if( m_dwPChannelsUsed && m_aPChannels )
	{
		pSegment->SetPChannelsUsed( m_dwPChannelsUsed, m_aPChannels );
	}
	return S_OK;
}

/*
@method HRESULT | IDirectMusicTrack | InitPlay |
This method is called when a Segment is ready to start playing. The <p ppStateData> field
may return a pointer to a structure of state data, which is sent into <om .Play> and
<om .EndPlay>, and allows the Track to keep track of variables on a <i SegmentState> by
<i SegmentState> basis.

@rvalue S_OK | Success. This is the only valid return value from this method.
@rvalue E_POINTER | <p pSegmentState>, <p pPerf>, or <p ppStateData> is NULL or
invalid.

@comm Note that it is unneccessary for the Track to store the <p pSegmentState>, <p pPerf>,
or <p dwTrackID> parameters, since they are also sent into <om .Play>.
*/
HRESULT CSeqTrack::InitPlay( 
    IDirectMusicSegmentState *pSegmentState,	// @parm The calling <i IDirectMusicSegmentState> pointer.
    IDirectMusicPerformance *pPerf,	// @parm The calling <i IDirectMusicPerformance> pointer.
    void **ppStateData,		// @parm This method can return state data information here.
    DWORD dwTrackID,		// @parm The virtual track ID assigned to this Track instance.
    DWORD dwFlags)          // @parm Same flags that were set with the call
            // to PlaySegment. These are passed all the way down to the tracks, who may want to know
            // if the track was played as a primary, controlling, or secondary segment.
{
	V_INAME(IDirectMusicTrack::InitPlay);
	V_PTRPTR_WRITE(ppStateData);
	V_INTERFACE(pSegmentState);
	V_INTERFACE(pPerf);

	SeqStateData* pStateData;
	pStateData = new SeqStateData;
	if( NULL == pStateData )
		return E_OUTOFMEMORY;
	*ppStateData = pStateData;
	SetUpStateCurrentPointers(pStateData);
	// need to know the group this track is in, for the mute track GetParam
	IDirectMusicSegment* pSegment;
	if( SUCCEEDED( pSegmentState->GetSegment(&pSegment)))
	{
		pSegment->GetTrackGroup( this, &pStateData->dwGroupBits );
		pSegment->Release();
	}
	return S_OK;
}

/*
@method HRESULT | IDirectMusicTrack | EndPlay |
This method is called when the <i IDirectMusicSegmentState> object that originally called
<om .InitPlay> is destroyed.

@rvalue S_OK | Success. 
@rvalue E_POINTER | <p pStateData> is invalid.
@comm The return code isn't used, but S_OK is preferred.
*/
HRESULT CSeqTrack::EndPlay( 
    void *pStateData)	// @parm The state data returned from <om .InitPlay>.
{
	ASSERT( pStateData );
	if( pStateData )
	{
		V_INAME(IDirectMusicTrack::EndPlay);
		V_BUFPTR_WRITE(pStateData, sizeof(SeqStateData));
		SeqStateData* pSD = (SeqStateData*)pStateData;
		delete pSD;
	}
	return S_OK;
}

void CSeqTrack::SetUpStateCurrentPointers(SeqStateData* pStateData)
{
	ASSERT(pStateData);
	pStateData->dwPChannelsUsed = m_dwPChannelsUsed;
	if( m_dwPChannelsUsed )
	{
		if( pStateData->apCurrentSeq )
		{
			delete [] pStateData->apCurrentSeq;
			pStateData->apCurrentSeq = NULL;
		}
		if( pStateData->apCurrentCurve )
		{
			delete [] pStateData->apCurrentCurve;
			pStateData->apCurrentCurve = NULL;
		}
		pStateData->apCurrentSeq = new TListItem<DMUS_IO_SEQ_ITEM>* [m_dwPChannelsUsed];
		pStateData->apCurrentCurve = new TListItem<DMUS_IO_CURVE_ITEM>* [m_dwPChannelsUsed];
		if( pStateData->apCurrentSeq )
		{
			memset( pStateData->apCurrentSeq, 0, sizeof(TListItem<DMUS_IO_SEQ_ITEM>*) * m_dwPChannelsUsed );
		}
		if( pStateData->apCurrentCurve )
		{
			memset( pStateData->apCurrentCurve, 0, sizeof(TListItem<DMUS_IO_CURVE_ITEM>*) * m_dwPChannelsUsed );
		}
	}
	pStateData->dwValidate = m_dwValidate;
}

// DeleteSeqPartList() - delete all parts in m_SeqPartList, and associated events.
void CSeqTrack::DeleteSeqPartList(void)
{
    ENTER_CRITICAL_SECTION(&m_CrSec);
	m_dwPChannelsUsed = 0;
	if (m_aPChannels) delete [] m_aPChannels;
	m_aPChannels = NULL;
	m_pSeqPartCache = NULL;
	if( m_SeqPartList.GetHead() )
	{
		TListItem<SEQ_PART>* pItem;
		while( pItem = m_SeqPartList.RemoveHead() )
		{
			TListItem<DMUS_IO_SEQ_ITEM>* pEvent;
			while( pEvent = pItem->GetItemValue().seqList.RemoveHead() )
			{
				delete pEvent;
			}
			TListItem<DMUS_IO_CURVE_ITEM>* pCurve;
			while( pCurve = pItem->GetItemValue().curveList.RemoveHead() )
			{
				delete pCurve;
			}
			delete pItem;
		}
	}
    LEAVE_CRITICAL_SECTION(&m_CrSec);
}

// FindPart() - return the SEQ_PART corresponding to dwPChannel, or create one.
TListItem<SEQ_PART>* CSeqTrack::FindPart( DWORD dwPChannel )
{
	TListItem<SEQ_PART>* pPart;
	
	if( m_pSeqPartCache && (m_pSeqPartCache->GetItemValue().dwPChannel == dwPChannel) )
	{
		return m_pSeqPartCache;
	}
	for( pPart = m_SeqPartList.GetHead(); pPart; pPart = pPart->GetNext() )
	{
		if( pPart->GetItemValue().dwPChannel == dwPChannel )
		{
			break;
		}
	}
	if( NULL == pPart )
	{
		pPart = new TListItem<SEQ_PART>;
		if( pPart )
		{
			pPart->GetItemValue().dwPChannel = dwPChannel;
			m_SeqPartList.AddHead( pPart );
		}
		m_dwPChannelsUsed++;
		
		DWORD* aPChannels = new DWORD[m_dwPChannelsUsed];
		if( aPChannels )
		{
			if( m_aPChannels )
			{
				memcpy( aPChannels, m_aPChannels, sizeof(DWORD) * (m_dwPChannelsUsed - 1) );
			}
			aPChannels[m_dwPChannelsUsed - 1] = dwPChannel;
		}
		if( m_aPChannels )
		{
			delete [] m_aPChannels;
		}
		m_aPChannels = aPChannels;
	}
	m_pSeqPartCache = pPart;
	return pPart;
}

void CSeqTrack::UpdateTimeSig(IDirectMusicSegmentState* pSegSt, 
										 SeqStateData* pSD, 
										 MUSIC_TIME mt)
{
	// get a new time sig if needed
	if( (mt >= pSD->mtNextTimeSig) || (mt < pSD->mtCurTimeSig) )
	{
		IDirectMusicSegment* pSeg;
		DMUS_TIMESIGNATURE timesig;
		MUSIC_TIME mtNext;
		HRESULT hr;
		if(SUCCEEDED(hr = pSegSt->GetSegment(&pSeg)))
		{
			DWORD dwGroup;
			if( SUCCEEDED(hr = pSeg->GetTrackGroup( this, &dwGroup )))
			{
				if(SUCCEEDED(hr = pSeg->GetParam( GUID_TimeSignature, dwGroup, 
					0, mt, &mtNext, (void*)&timesig )))
				{
					timesig.mtTime += mt; 
					if( pSD->dwlnMeasure )
					{
						pSD->dwMeasure = (timesig.mtTime - pSD->mtCurTimeSig) / pSD->dwlnMeasure;
					}
					else
					{
						pSD->dwMeasure = 0;
					}
					pSD->mtCurTimeSig = timesig.mtTime;
					if( mtNext == 0 ) mtNext = 0x7fffffff;
					pSD->mtNextTimeSig = mtNext;
					if( timesig.bBeat )
					{
						pSD->dwlnBeat = DMUS_PPQ * 4 / timesig.bBeat;
					}
					pSD->dwlnMeasure = pSD->dwlnBeat * timesig.bBeatsPerMeasure;
					if( timesig.wGridsPerBeat )
					{
						pSD->dwlnGrid = pSD->dwlnBeat / timesig.wGridsPerBeat;
					}
				}
			}
			pSeg->Release();
		}
		if( FAILED(hr) )
		{
			// couldn't get time sig, default to 4/4
			pSD->mtNextTimeSig = 0x7fffffff;
			pSD->dwlnBeat = DMUS_PPQ;
			pSD->dwlnMeasure = DMUS_PPQ * 4;
			pSD->dwlnGrid = DMUS_PPQ / 4;
			pSD->dwMeasure = 0;
			pSD->mtCurTimeSig = 0;
		}
	}
	// make absolutely sure there is no way these can be 0, since we divide
	// by them.
	if( 0 == pSD->dwlnGrid ) pSD->dwlnGrid = DMUS_PPQ / 4;
	if( 0 == pSD->dwlnBeat ) pSD->dwlnBeat = DMUS_PPQ;
	if( 0 == pSD->dwlnMeasure ) pSD->dwlnMeasure = DMUS_PPQ * 4;
}

STDMETHODIMP CSeqTrack::PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf,
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) 
{
	V_INAME(IDirectMusicTrack::PlayEx);
	V_BUFPTR_WRITE( pStateData, sizeof(SeqStateData));
	V_INTERFACE(pPerf);
	V_INTERFACE(pSegSt);

    HRESULT hr;
    ENTER_CRITICAL_SECTION(&m_CrSec);
    if (dwFlags & DMUS_TRACKF_CLOCK)
    {
        // Convert all reference times to millisecond times. Then, just use same MUSIC_TIME
        // variables.
	    hr = Play(pStateData,(MUSIC_TIME)(rtStart / REF_PER_MIL),(MUSIC_TIME)(rtEnd / REF_PER_MIL),
            (MUSIC_TIME)(rtOffset / REF_PER_MIL),rtOffset,dwFlags,pPerf,pSegSt,dwVirtualID,TRUE);
    }
    else
    {
	    hr = Play(pStateData,(MUSIC_TIME)rtStart,(MUSIC_TIME)rtEnd,
            (MUSIC_TIME)rtOffset,0,dwFlags,pPerf,pSegSt,dwVirtualID,FALSE);
    }
    LEAVE_CRITICAL_SECTION(&m_CrSec);
	return hr;
}
/*
@enum DMUS_TRACKF_FLAGS | Sent in <om IDirectMusicTrack.Play>'s dwFlags parameter.
@emem DMUS_TRACKF_SEEK | Play was called on account of seeking, meaning that mtStart is
not necessarily the same as the previous Play call's mtEnd.
@emem DMUS_TRACKF_LOOP | Play was called on account of a loop, e.g. repeat.
@emem DMUS_TRACKF_START | This is the first call to Play. DMUS_TRACKF_SEEK may also be set if the
Track is not playing from the beginning.
@emem DMUS_TRACKF_FLUSH | The call to Play is on account of a flush or invalidate, that
requires the Track to replay something it played previously. In this case, DMUS_TRACKF_SEEK
will be set as well.

  @method HRESULT | IDirectMusicTrack | Play |
  Play method.
  @rvalue DMUS_DMUS_S_END | The Track is done playing.
  @rvalue S_OK | Success.
  @rvalue E_POINTER | <p pStateData>, <p pPerf>, or <p pSegSt> is NULL or invalid.
*/
STDMETHODIMP CSeqTrack::Play( 
    void *pStateData,	// @parm State data pointer, from <om .InitPlay>.
    MUSIC_TIME mtStart,	// @parm The start time to play.
    MUSIC_TIME mtEnd,	// @parm The end time to play.
    MUSIC_TIME mtOffset,// @parm The offset to add to all messages sent to
						// <om IDirectMusicPerformance.SendPMsg>.
	DWORD dwFlags,		// @parm Flags that indicate the state of this call.
						// See <t DMUS_TRACKF_FLAGS>. If dwFlags == 0, this is a
						// normal Play call continuing playback from the previous
						// Play call.
	IDirectMusicPerformance* pPerf,	// @parm The <i IDirectMusicPerformance>, used to
						// call <om IDirectMusicPerformance.AllocPMsg>,
						// <om IDirectMusicPerformance.SendPMsg>, etc.
	IDirectMusicSegmentState* pSegSt,	// @parm The <i IDirectMusicSegmentState> this
						// track belongs to. QueryInterface() can be called on this to
						// obtain the SegmentState's <i IDirectMusicGraph> in order to
						// call <om IDirectMusicGraph.StampPMsg>, for instance.
	DWORD dwVirtualID	// @parm This track's virtual track id, which must be set
						// on any <t DMUS_PMSG>'s m_dwVirtualTrackID member that
						// will be queued to <om IDirectMusicPerformance.SendPMsg>.
	)
{
	V_INAME(IDirectMusicTrack::Play);
	V_BUFPTR_WRITE( pStateData, sizeof(SeqStateData));
	V_INTERFACE(pPerf);
	V_INTERFACE(pSegSt);

	ENTER_CRITICAL_SECTION(&m_CrSec);
	HRESULT	hr = Play(pStateData,mtStart,mtEnd,mtOffset,0,dwFlags,pPerf,pSegSt,dwVirtualID,FALSE);
    LEAVE_CRITICAL_SECTION(&m_CrSec);
	return hr;
}

/*  The Play method handles both music time and clock time versions, as determined by
    fClockTime. If running in clock time, rtOffset is used to identify the start time
    of the segment. Otherwise, mtOffset. The mtStart and mtEnd parameters are in MUSIC_TIME units
    or milliseconds, depending on which mode. 
*/

HRESULT CSeqTrack::Play( 
    void *pStateData,	
    MUSIC_TIME mtStart,	
    MUSIC_TIME mtEnd,
    MUSIC_TIME mtOffset,
    REFERENCE_TIME rtOffset,
	DWORD dwFlags,		
	IDirectMusicPerformance* pPerf,	
	IDirectMusicSegmentState* pSegSt,
	DWORD dwVirtualID,
    BOOL fClockTime)
{
    if (dwFlags & DMUS_TRACKF_PLAY_OFF)
    {
	    return S_OK;
    }
	HRESULT	hr = S_OK;
	IDirectMusicGraph* pGraph = NULL;
	DMUS_PMSG* pEvent = NULL;
	SeqStateData* pSD = (SeqStateData*)pStateData;
	BOOL fSeek = (dwFlags & DMUS_TRACKF_SEEK) ? TRUE : FALSE;

	if( dwFlags & (DMUS_TRACKF_SEEK | DMUS_TRACKF_FLUSH | DMUS_TRACKF_DIRTY |
		DMUS_TRACKF_LOOP) )
	{
		// need to reset the PChannel Map in case of any of these flags.
		m_PChMap.Reset();
	}

	if( pSD->dwValidate != m_dwValidate )
	{
		SetUpStateCurrentPointers(pSD);
		fSeek = TRUE;
	}

	if( fSeek )
	{
		if( dwFlags & DMUS_TRACKF_START )
		{
			Seek( pSegSt, pPerf, dwVirtualID, pSD, mtStart, TRUE, mtOffset, rtOffset, fClockTime );
		}
		else
		{
			Seek( pSegSt, pPerf, dwVirtualID, pSD, mtStart, FALSE, mtOffset, rtOffset, fClockTime );
		}
	}

	if( FAILED( pSegSt->QueryInterface( IID_IDirectMusicGraph,
		(void**)&pGraph )))
	{
		pGraph = NULL;
	}

	DWORD dwIndex;
	DWORD dwPChannel;
	DWORD dwMutePChannel;
	BOOL fMute;
	TListItem<SEQ_PART>* pPart = m_SeqPartList.GetHead();
	for( dwIndex = 0; pPart && (dwIndex < m_dwPChannelsUsed); dwIndex++,pPart = pPart->GetNext() )
	{
		dwPChannel = pPart->GetItemValue().dwPChannel;
		if( pSD->apCurrentCurve )
		{
			for( ; pSD->apCurrentCurve[dwIndex]; 
				pSD->apCurrentCurve[dwIndex] = pSD->apCurrentCurve[dwIndex]->GetNext() )
			{
				DMUS_IO_CURVE_ITEM& rItem = pSD->apCurrentCurve[dwIndex]->GetItemValue();
				if( rItem.mtStart >= mtEnd )
				{
					break;
				}
				m_PChMap.GetInfo( dwPChannel, rItem.mtStart, mtOffset, pSD->dwGroupBits,
					pPerf, &fMute, &dwMutePChannel, fClockTime );
				if( !fMute )
				{
					DMUS_CURVE_PMSG* pCurve;
					if( SUCCEEDED( pPerf->AllocPMsg( sizeof(DMUS_CURVE_PMSG),
						(DMUS_PMSG**)&pCurve )))
					{
						pEvent = (DMUS_PMSG*)pCurve;
                        if (fClockTime)
                        {
						    pCurve->wMeasure = 0;
						    pCurve->bBeat = 0;
						    pCurve->bGrid = 0;
						    pCurve->nOffset = rItem.nOffset;
						    pCurve->rtTime = ((rItem.mtStart + rItem.nOffset) * REF_PER_MIL) + rtOffset;
                            // Set the DX8 flag to indicate the wMergeIndex and wParamType fields are valid.
						    pCurve->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME | DMUS_PMSGF_DX8;
                        }
                        else
                        {
						    UpdateTimeSig( pSegSt, pSD, rItem.mtStart);
						    long lTemp = (rItem.mtStart - pSD->mtCurTimeSig);
						    pCurve->wMeasure = (WORD)((lTemp / pSD->dwlnMeasure) + pSD->dwMeasure);
						    lTemp = lTemp % pSD->dwlnMeasure;
						    pCurve->bBeat = (BYTE)(lTemp / pSD->dwlnBeat);
						    lTemp = lTemp % pSD->dwlnBeat;
						    pCurve->bGrid = (BYTE)(lTemp / pSD->dwlnGrid);
						    //pCurve->nOffset = (short)(lTemp % pSD->dwlnGrid);
						    pCurve->nOffset = (short)(lTemp % pSD->dwlnGrid) + rItem.nOffset;
						    pCurve->mtTime = rItem.mtStart + mtOffset + rItem.nOffset;
                            // Set the DX8 flag to indicate the wMergeIndex and wParamType fields are valid.
						    pCurve->dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_DX8;
                        }
						pCurve->dwPChannel = dwMutePChannel;
						pCurve->dwVirtualTrackID = dwVirtualID;
						pCurve->dwType = DMUS_PMSGT_CURVE;
						pCurve->mtDuration = rItem.mtDuration;
						pCurve->mtResetDuration = rItem.mtResetDuration;
						pCurve->nStartValue = rItem.nStartValue;
						pCurve->nEndValue = rItem.nEndValue;
						pCurve->nResetValue = rItem.nResetValue;
						pCurve->bType = rItem.bType;
						pCurve->bCurveShape = rItem.bCurveShape;
						pCurve->bCCData = rItem.bCCData;
						pCurve->bFlags = rItem.bFlags;
                        pCurve->wParamType = rItem.wParamType;
                        pCurve->wMergeIndex = rItem.wMergeIndex;
						pCurve->dwGroupID = pSD->dwGroupBits;

						if( pGraph )
						{
							pGraph->StampPMsg( pEvent );
						}
						if(FAILED(pPerf->SendPMsg( pEvent )))
						{
							pPerf->FreePMsg(pEvent);
						}
					}
				}
			}
		}
		if( pSD->apCurrentSeq )
		{
			for( ; pSD->apCurrentSeq[dwIndex]; 
				pSD->apCurrentSeq[dwIndex] = pSD->apCurrentSeq[dwIndex]->GetNext() )
			{
				DMUS_IO_SEQ_ITEM& rItem = pSD->apCurrentSeq[dwIndex]->GetItemValue();
				BOOL fMute;
				if( rItem.mtTime >= mtEnd )
				{
					break;
				}
				m_PChMap.GetInfo( dwPChannel, rItem.mtTime, mtOffset, pSD->dwGroupBits,
					pPerf, &fMute, &dwMutePChannel, fClockTime );
				if( !fMute )
				{
					if( (rItem.bStatus & 0xf0) == 0x90 )
					{
						// this is a note event
						DMUS_NOTE_PMSG* pNote;
						if( SUCCEEDED( pPerf->AllocPMsg( sizeof(DMUS_NOTE_PMSG),
							(DMUS_PMSG**)&pNote )))
						{
							pNote->bFlags = DMUS_NOTEF_NOTEON;
							pNote->mtDuration = rItem.mtDuration;
							pNote->bMidiValue = rItem.bByte1;
							pNote->bVelocity = rItem.bByte2;
							pNote->dwType = DMUS_PMSGT_NOTE;
							pNote->bPlayModeFlags = DMUS_PLAYMODE_FIXED;
							pNote->wMusicValue = pNote->bMidiValue;
							pNote->bSubChordLevel = 0;  // SUBCHORD_BASS 
                            if (fClockTime)
                            {
                                pNote->rtTime = ((rItem.mtTime + rItem.nOffset) * REF_PER_MIL) + rtOffset;
                                pNote->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME;
                                pNote->wMeasure = 0;
                                pNote->bBeat = 0;
                                pNote->bGrid = 0;
                                pNote->nOffset = rItem.nOffset;
                            }
                            else
                            {
                                pNote->mtTime = rItem.mtTime + mtOffset + rItem.nOffset;
							    UpdateTimeSig( pSegSt, pSD, rItem.mtTime );
                                pNote->dwFlags = DMUS_PMSGF_MUSICTIME;
							    long lTemp = (rItem.mtTime - pSD->mtCurTimeSig);
							    pNote->wMeasure = (WORD)((lTemp / pSD->dwlnMeasure) + pSD->dwMeasure);
							    lTemp = lTemp % pSD->dwlnMeasure;
							    pNote->bBeat = (BYTE)(lTemp / pSD->dwlnBeat);
							    lTemp = lTemp % pSD->dwlnBeat;
							    pNote->bGrid = (BYTE)(lTemp / pSD->dwlnGrid);
							    //pNote->nOffset = (short)(lTemp % pSD->dwlnGrid);
							    pNote->nOffset = (short)(lTemp % pSD->dwlnGrid) + rItem.nOffset;
                            }
							pNote->bTimeRange = 0;
							pNote->bDurRange = 0;
							pNote->bVelRange = 0;
							pNote->cTranspose = 0;
							pEvent = (DMUS_PMSG*)pNote;
						}
					}
					else
					{
						// it's a MIDI short that's not a note
						DMUS_MIDI_PMSG* pMidi;
						if( SUCCEEDED( pPerf->AllocPMsg( sizeof(DMUS_MIDI_PMSG),
							(DMUS_PMSG**)&pMidi )))
						{
							pMidi->bStatus = rItem.bStatus & 0xf0;
							pMidi->bByte1 = rItem.bByte1;
							pMidi->bByte2 = rItem.bByte2;
							pMidi->dwType = DMUS_PMSGT_MIDI;
                            if (fClockTime)
                            {
                                pMidi->rtTime = (rItem.mtTime * REF_PER_MIL) + rtOffset;
                                pMidi->dwFlags |= DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME;
                            }
                            else
                            {
							    pMidi->mtTime = rItem.mtTime + mtOffset;
                                pMidi->dwFlags |= DMUS_PMSGF_MUSICTIME;
                            }
							pEvent = (DMUS_PMSG*)pMidi;
						}
					}
					if( pEvent )
					{
						pEvent->dwPChannel = dwMutePChannel;
						pEvent->dwVirtualTrackID = dwVirtualID;
						pEvent->dwGroupID = pSD->dwGroupBits;
						if( pGraph )
						{
							pGraph->StampPMsg( pEvent );
						}
						if(FAILED(pPerf->SendPMsg( pEvent )))
						{
							pPerf->FreePMsg(pEvent);
						}
					}
				}
			}
		}
	}

	if( pGraph )
	{
		pGraph->Release();
	}
	return hr;
}

// SendSeekItem() - sends either the pSeq or pCurve, depending on which occurs
// latest. Sends the item at mtTime + mtOffset.
void CSeqTrack::SendSeekItem( IDirectMusicPerformance* pPerf,
										IDirectMusicGraph* pGraph,
										IDirectMusicSegmentState* pSegSt,
										SeqStateData* pSD,
										DWORD dwVirtualID,
										MUSIC_TIME mtTime,
										MUSIC_TIME mtOffset,
                                        REFERENCE_TIME rtOffset,
										TListItem<DMUS_IO_SEQ_ITEM>* pSeq,
										TListItem<DMUS_IO_CURVE_ITEM>* pCurve,
                                        BOOL fClockTime)
{
	DWORD dwMutePChannel;
	BOOL fMute;

	if( pSeq )
	{
		DMUS_IO_SEQ_ITEM& rSeq = pSeq->GetItemValue();
		if( pCurve )
		{
			DMUS_IO_CURVE_ITEM& rCurve = pCurve->GetItemValue();
			if( rSeq.mtTime >= rCurve.mtStart + rCurve.mtDuration )
			{
				// the seq item happens after the curve item. Send the
				// seq item and clear the curve item so it doesn't go out.
				pCurve = NULL;
			}
		}
		// if pCurve is NULL or was set to NULL, send out the seq item
		if( NULL == pCurve )
		{
			m_PChMap.GetInfo( rSeq.dwPChannel, rSeq.mtTime, mtOffset, pSD->dwGroupBits,
				pPerf, &fMute, &dwMutePChannel, fClockTime );
			if( !fMute )
			{
				DMUS_MIDI_PMSG* pMidi;
				if( SUCCEEDED( pPerf->AllocPMsg( sizeof(DMUS_MIDI_PMSG),
					(DMUS_PMSG**)&pMidi )))
				{
					pMidi->bStatus = rSeq.bStatus & 0xf0;
					pMidi->bByte1 = rSeq.bByte1;
					pMidi->bByte2 = rSeq.bByte2;
					pMidi->dwType = DMUS_PMSGT_MIDI;

					ASSERT( mtTime > rSeq.mtTime ); // this is true for back-seeking
                    if (fClockTime)
                    {
                        pMidi->rtTime = (mtTime * REF_PER_MIL) + rtOffset;
                        pMidi->dwFlags |= DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME;
                    }
                    else
                    {
					    pMidi->mtTime = mtTime + mtOffset;
                        pMidi->dwFlags |= DMUS_PMSGF_MUSICTIME;
                    }
					pMidi->dwPChannel = dwMutePChannel;
					pMidi->dwVirtualTrackID = dwVirtualID;
					pMidi->dwGroupID = pSD->dwGroupBits;
					if( pGraph )
					{
						pGraph->StampPMsg( (DMUS_PMSG*)pMidi );
					}
					if(FAILED(pPerf->SendPMsg( (DMUS_PMSG*)pMidi )))
					{
						pPerf->FreePMsg((DMUS_PMSG*)pMidi);
					}
				}
			}
		}
	}
	if( pCurve )
	{
		DMUS_IO_CURVE_ITEM& rCurve = pCurve->GetItemValue();
		m_PChMap.GetInfo( rCurve.dwPChannel, rCurve.mtStart, mtOffset, pSD->dwGroupBits,
			pPerf, &fMute, &dwMutePChannel, fClockTime );
		if( !fMute )
		{
			DMUS_CURVE_PMSG* pCurve;
			if( SUCCEEDED( pPerf->AllocPMsg( sizeof(DMUS_CURVE_PMSG),
				(DMUS_PMSG**)&pCurve )))
			{
                if (fClockTime) // If clock time, don't fill in time signature info, it's useless.
                {
                    pCurve->wMeasure = 0;
				    pCurve->bBeat = 0;
				    pCurve->bGrid = 0;
				    pCurve->nOffset = 0;
                    pCurve->rtTime = ((mtTime + rCurve.nOffset) * REF_PER_MIL) + rtOffset;
                    pCurve->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME;
                }
                else
                {
                    UpdateTimeSig( pSegSt, pSD, rCurve.mtStart);
				    long lTemp = (rCurve.mtStart - pSD->mtCurTimeSig);
				    pCurve->wMeasure = (WORD)((lTemp / pSD->dwlnMeasure) + pSD->dwMeasure);
				    lTemp = lTemp % pSD->dwlnMeasure;
				    pCurve->bBeat = (BYTE)(lTemp / pSD->dwlnBeat);
				    lTemp = lTemp % pSD->dwlnBeat;
				    pCurve->bGrid = (BYTE)(lTemp / pSD->dwlnGrid);
				    pCurve->nOffset = (short)(lTemp % pSD->dwlnGrid) + rCurve.nOffset;
				    pCurve->dwFlags = DMUS_PMSGF_MUSICTIME;
                    ASSERT( mtTime > rCurve.mtStart );// this is true for back-seeking
				    // in any case, play curve at mtTime + mtOffset + pCurve->nOffset
				    pCurve->mtTime = mtTime + mtOffset + rCurve.nOffset;
                    pCurve->dwFlags = DMUS_PMSGF_MUSICTIME;
                }

				pCurve->dwPChannel = dwMutePChannel;
				pCurve->dwVirtualTrackID = dwVirtualID;
				pCurve->dwType = DMUS_PMSGT_CURVE;
				pCurve->bType = rCurve.bType;
				pCurve->bCCData = rCurve.bCCData;
				pCurve->bFlags = rCurve.bFlags;
				pCurve->dwGroupID = pSD->dwGroupBits;
				pCurve->nStartValue = rCurve.nStartValue;
				pCurve->nEndValue = rCurve.nEndValue;
				pCurve->nResetValue = rCurve.nResetValue;
				
				if( mtTime >= rCurve.mtStart + rCurve.mtDuration )
				{
					// playing at a time past the curve's duration. Just play
					// an instant curve at that time instead. Instant curves
					// play at their endvalue. Duration is irrelavant.
					pCurve->bCurveShape = DMUS_CURVES_INSTANT;
					if( pCurve->bFlags & DMUS_CURVE_RESET )
					{
						if( mtTime >= rCurve.mtStart + rCurve.mtDuration + 
							rCurve.mtResetDuration + rCurve.nOffset )
						{
							// don't need the curve reset any more
							pCurve->bFlags &= ~DMUS_CURVE_RESET;
						}
						else
						{
							// otherwise make sure the reset event happens at the same time
							// it would have if we weren't seeking back.
							pCurve->mtResetDuration = rCurve.mtStart + rCurve.mtDuration +
								rCurve.mtResetDuration + rCurve.nOffset - mtTime;
						}
					}
				}
				else
				{
					// playing at a time in the middle of a curve.
					pCurve->bCurveShape = rCurve.bCurveShape;
                    if (fClockTime)
                    {
                        pCurve->mtOriginalStart = mtTime - (rCurve.mtStart + mtOffset + rCurve.nOffset);
                    }
                    else
                    {
				    	pCurve->mtOriginalStart = rCurve.mtStart + mtOffset + rCurve.nOffset;
                    }
					if( pCurve->bCurveShape != DMUS_CURVES_INSTANT )
					{
						pCurve->mtDuration = rCurve.mtStart + rCurve.mtDuration - mtTime;
					}
					pCurve->mtResetDuration = rCurve.mtResetDuration;
				}

				if( pGraph )
				{
					pGraph->StampPMsg( (DMUS_PMSG*)pCurve );
				}
				if(FAILED(pPerf->SendPMsg( (DMUS_PMSG*)pCurve )))
				{
					pPerf->FreePMsg((DMUS_PMSG*)pCurve);
				}
			}
		}
	}
}

// Seek() - set all pSD's pointers to the correct location. If fGetPrevious is set,
// also send control change, pitch bend, curves, etc. that are in the past so the
// state at mtTime is as if we played from the beginning of the track.
HRESULT CSeqTrack::Seek( IDirectMusicSegmentState* pSegSt,
	IDirectMusicPerformance* pPerf, DWORD dwVirtualID,
    SeqStateData* pSD, MUSIC_TIME mtTime, BOOL fGetPrevious, 
    MUSIC_TIME mtOffset, REFERENCE_TIME rtOffset, BOOL fClockTime)
{
	DWORD dwIndex;
	TListItem<SEQ_PART>* pPart;
	TListItem<DMUS_IO_SEQ_ITEM>* pSeqItem;
	TListItem<DMUS_IO_CURVE_ITEM>* pCurveItem;

	// in the case of mtTime == 0 and fGetPrevious (which means DMUS_SEGF_START was
	// set in Play() ) we want to reset all lists to the beginning regardless of time.
	if( fGetPrevious && ( mtTime == 0 ) )
	{
		pPart = m_SeqPartList.GetHead();
		for( dwIndex = 0; dwIndex < m_dwPChannelsUsed; dwIndex++ )
		{
			if( pPart )
			{
				pSeqItem = pPart->GetItemValue().seqList.GetHead();
				if( pSeqItem && pSD->apCurrentSeq )
				{
					pSD->apCurrentSeq[dwIndex] = pSeqItem;
				}
				pCurveItem = pPart->GetItemValue().curveList.GetHead();
				if( pCurveItem && pSD->apCurrentCurve )
				{
					pSD->apCurrentCurve[dwIndex] = pCurveItem;
				}
				pPart = pPart->GetNext();
			}
			else
			{
				break;
			}
		}
		return S_OK;
	}

#define CC_1	96
	// CC_1 is the limit of the CC#'s we pay attention to. CC#96 through #101
	// are registered and non-registered parameter #'s, and data increment and
	// decrement, which we are choosing to ignore.

	TListItem<DMUS_IO_SEQ_ITEM>*	apSeqItemCC[ CC_1 ];
	TListItem<DMUS_IO_CURVE_ITEM>*	apCurveItemCC[ CC_1 ];
	TListItem<DMUS_IO_SEQ_ITEM>*	pSeqItemMonoAT;
	TListItem<DMUS_IO_CURVE_ITEM>*	pCurveItemMonoAT;
	TListItem<DMUS_IO_SEQ_ITEM>*	pSeqItemPBend;
	TListItem<DMUS_IO_CURVE_ITEM>*	pCurveItemPBend;
	IDirectMusicGraph* pGraph;
	if( FAILED( pSegSt->QueryInterface( IID_IDirectMusicGraph,
		(void**)&pGraph )))
	{
		pGraph = NULL;
	}

	pPart = m_SeqPartList.GetHead();
	for( dwIndex = 0; dwIndex < m_dwPChannelsUsed; dwIndex++ )
	{
		if( pPart )
		{
			memset(apSeqItemCC, 0, sizeof(TListItem<DMUS_IO_SEQ_ITEM>*) * CC_1);
			memset(apCurveItemCC, 0, sizeof(TListItem<DMUS_IO_CURVE_ITEM>*) * CC_1);
			pSeqItemMonoAT = NULL;
			pCurveItemMonoAT = NULL;
			pSeqItemPBend = NULL;
			pCurveItemPBend = NULL;

			// scan the seq event list in this part, storing any CC, MonoAT, and PBend
			// events we come across.
			for( pSeqItem = pPart->GetItemValue().seqList.GetHead(); pSeqItem; pSeqItem = pSeqItem->GetNext() )
			{
				DMUS_IO_SEQ_ITEM& rSeqItem = pSeqItem->GetItemValue();
				if( rSeqItem.mtTime >= mtTime )
				{
					break;
				}
				if( !fGetPrevious )
				{
					// if we don't care about previous events, just continue
					continue;
				}
				switch( rSeqItem.bStatus & 0xf0 )
				{
				case MIDI_CCHANGE:
					// ignore Registered and Non-registered Parameters,
					// Data increment, Data decrement, and Data entry MSB and LSB.
					if( ( rSeqItem.bByte1 < CC_1 ) && ( rSeqItem.bByte1 != 6 ) &&
						( rSeqItem.bByte1 != 38 ) )
					{
						apSeqItemCC[ rSeqItem.bByte1 ] = pSeqItem;
					}
					break;
				case MIDI_MTOUCH:
					pSeqItemMonoAT = pSeqItem;
					break;
				case MIDI_PBEND:
					pSeqItemPBend = pSeqItem;
					break;
				default:
					break;
				}
			}
			if( pSD->apCurrentSeq )
			{
				pSD->apCurrentSeq[dwIndex] = pSeqItem;
			}
			// scan the curve event list in this part, storing any CC, MonoAT, and PBend
			// events we come across
			for( pCurveItem = pPart->GetItemValue().curveList.GetHead(); pCurveItem; pCurveItem = pCurveItem->GetNext() )
			{
				DMUS_IO_CURVE_ITEM& rCurveItem = pCurveItem->GetItemValue();
				if( rCurveItem.mtStart >= mtTime )
				{
					break;
				}
				if( !fGetPrevious )
				{
					// if we don't care about previous events, just continue
					continue;
				}
				switch( rCurveItem.bType )
				{
				case DMUS_CURVET_CCCURVE:
					if( ( rCurveItem.bCCData < CC_1 ) && ( rCurveItem.bCCData != 6 ) &&
						( rCurveItem.bCCData != 38 ) )
					{
						if( apCurveItemCC[ rCurveItem.bCCData ] )
						{
							DMUS_IO_CURVE_ITEM& rTemp = apCurveItemCC[ rCurveItem.bCCData ]->GetItemValue();
							if( rCurveItem.mtStart + rCurveItem.mtDuration + rCurveItem.nOffset >
								rTemp.mtStart + rTemp.mtDuration + rTemp.nOffset )
							{
								apCurveItemCC[ rCurveItem.bCCData ] = pCurveItem;
							}
						}
						else
						{
							apCurveItemCC[ rCurveItem.bCCData ] = pCurveItem;
						}
					}
					break;
				case DMUS_CURVET_MATCURVE:
					if( pCurveItemMonoAT )
					{
						DMUS_IO_CURVE_ITEM& rTemp = pCurveItemMonoAT->GetItemValue();
						if( rCurveItem.mtStart + rCurveItem.mtDuration + rCurveItem.nOffset >
							rTemp.mtStart + rTemp.mtDuration + rTemp.nOffset )
						{
							pCurveItemMonoAT = pCurveItem;
						}
					}
					else
					{
						pCurveItemMonoAT = pCurveItem;
					}
					break;
				case DMUS_CURVET_PBCURVE:
					if( pCurveItemPBend )
					{
						DMUS_IO_CURVE_ITEM& rTemp = pCurveItemPBend->GetItemValue();
						if( rCurveItem.mtStart + rCurveItem.mtDuration + rCurveItem.nOffset >
							rTemp.mtStart + rTemp.mtDuration + rTemp.nOffset )
						{
							pCurveItemPBend = pCurveItem;
						}
					}
					else
					{
						pCurveItemPBend = pCurveItem;
					}
					break;
				default:
					break;
				}
			}
			if( pSD->apCurrentCurve )
			{
				pSD->apCurrentCurve[dwIndex] = pCurveItem;
			}
			if( fGetPrevious )
			{
				DWORD dwCC;
				// create and send past events appropriately
				SendSeekItem( pPerf, pGraph, pSegSt, pSD, dwVirtualID, mtTime, mtOffset, rtOffset, pSeqItemPBend, pCurveItemPBend, fClockTime );
				SendSeekItem( pPerf, pGraph, pSegSt, pSD, dwVirtualID, mtTime, mtOffset, rtOffset, pSeqItemMonoAT, pCurveItemMonoAT, fClockTime );
				for( dwCC = 0; dwCC < CC_1; dwCC++ )
				{
					SendSeekItem( pPerf, pGraph, pSegSt, pSD, dwVirtualID, mtTime, mtOffset, rtOffset, apSeqItemCC[dwCC], apCurveItemCC[dwCC], fClockTime );
				}
			}
			pPart = pPart->GetNext();
		}
	}

	if( pGraph )
	{
		pGraph->Release();
	}
	return S_OK;
}

/*
  @method HRESULT | IDirectMusicTrack | GetParam |
  Retrieves data from a Track.

  @rvalue S_OK | Got the data ok.
  @rvalue E_NOTIMPL | Not implemented.
*/
STDMETHODIMP CSeqTrack::GetParam( 
	REFGUID rguidType,	// @parm The type of data to obtain.
    MUSIC_TIME mtTime,	// @parm The time, in Track time, to obtain the data.
	MUSIC_TIME* pmtNext,// @parm Returns the Track time until which the data is valid. <p pmtNext>
						// may be NULL. If this returns a value of 0, it means that this
						// data will either be always valid, or it is unknown when it will
						// become invalid.
    void *pData)		// @parm The struture in which to return the data. Each
						// <p pGuidType> identifies a particular structure of a
						// particular size. It is important that this field contain
						// the correct structure of the correct size. Otherwise,
						// fatal results can occur.
{
	return E_NOTIMPL;
}

/*
  @method HRESULT | IDirectMusicTrack | SetParam |
  Sets data on a Track.

  @rvalue S_OK | Set the data ok.
  @rvalue E_NOTIMPL | Not implemented.
*/
STDMETHODIMP CSeqTrack::SetParam( 
	REFGUID rguidType,	// @parm The type of data to set.
    MUSIC_TIME mtTime,	// @parm The time, in Track time, to set the data.
    void *pData)		// @parm The struture containing the data to set. Each
						// <p pGuidType> identifies a particular structure of a
						// particular size. It is important that this field contain
						// the correct structure of the correct size. Otherwise,
						// fatal results can occur.
{
	return E_NOTIMPL;
}

STDMETHODIMP CSeqTrack::GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) 
{
	return E_NOTIMPL;
}

STDMETHODIMP CSeqTrack::SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,
                                      void* pParam, void * pStateData, DWORD dwFlags) 
{
	return E_NOTIMPL;
}

/*
  @method HRESULT | IDirectMusicTrack | AddNotificationType |
  Similar to and called from <om IDirectMusicSegment.AddNotificationType>. This
  gives the track a chance to respond to notifications.

  @rvalue E_NOTIMPL | The track doesn't support notifications.
  @rvalue S_OK | Success.
  @rvalue S_FALSE | The track doesn't support the requested notification type.
*/
HRESULT STDMETHODCALLTYPE CSeqTrack::AddNotificationType(
	 REFGUID rguidNotification) // @parm The notification guid to add.
{
	return E_NOTIMPL;
}

/*
  @method HRESULT | IDirectMusicTrack | RemoveNotificationType |
  Similar to and called from <om IDirectMusicSegment.RemoveNotificationType>. This
  gives the track a chance to remove notifications.

  @rvalue E_NOTIMPL | The track doesn't support notifications.
  @rvalue S_OK | Success.
  @rvalue S_FALSE | The track doesn't support the requested notification type.
*/
HRESULT STDMETHODCALLTYPE CSeqTrack::RemoveNotificationType(
	 REFGUID rguidNotification) // @parm The notification guid to remove.
{
	return E_NOTIMPL;
}

/*
  @method HRESULT | IDirectMusicTrack | Clone |
  Creates a copy of the Track.

  @rvalue S_OK | Success.
  @rvalue E_OUTOFMEMORY | Out of memory.
  @rvalue E_POINTER | <p ppTrack> is NULL or invalid.

  @xref <om IDirectMusicSegment.Clone>
*/
HRESULT STDMETHODCALLTYPE CSeqTrack::Clone(
	MUSIC_TIME mtStart,	// @parm The start of the part to clone. It should be 0 or greater,
						// and less than the length of the Track.
	MUSIC_TIME mtEnd,	// @parm The end of the part to clone. It should be greater than
						// <p mtStart> and less than the length of the Track.
	IDirectMusicTrack** ppTrack)	// @parm Returns the cloned Track.
{
	V_INAME(IDirectMusicTrack::Clone);
	V_PTRPTR_WRITE(ppTrack);

	HRESULT hr = S_OK;

	if(mtStart < 0 )
	{
        Trace(1,"Error: Invalid clone parameters to Sequence Track, start time is %ld.\n",mtStart);
		return E_INVALIDARG;
	}
	if(mtStart > mtEnd)
	{
        Trace(1,"Error: Invalid clone parameters to Sequence Track, start time %ld is greater than end %ld.\n",mtStart,mtEnd);
		return E_INVALIDARG;
	}

	ENTER_CRITICAL_SECTION(&m_CrSec);
    CSeqTrack *pDM;
    NEWCATCH(pDM,CSeqTrack(*this, mtStart, mtEnd))
/*    try
    {
        pDM = new CSeqTrack(*this, mtStart, mtEnd);
    }
    catch( ... )
    {
        pDM = NULL;
    }*/

	LEAVE_CRITICAL_SECTION(&m_CrSec);
    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(IID_IDirectMusicTrack, (void**)ppTrack);
    pDM->Release();

	return hr;
}


STDMETHODIMP CSeqTrack::Compose(
		IUnknown* pContext, 
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) 
{
	return E_NOTIMPL;
}

STDMETHODIMP CSeqTrack::Join(
		IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) 
{
	return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\segtrtrk.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CSegTriggerTrack.
//

#include "pchime.h"
/*
#include "dmime.h"
#include "segtrtrk.h"
#include "..\shared\Validate.h"
#include "dmperf.h"
#include "miscutil.h"*/

//////////////////////////////////////////////////////////////////////
// SetParam

STDMETHODIMP
CSegTriggerTrack::SetParam(REFGUID rguid, MUSIC_TIME mtTime, void *pData)
{
	HRESULT hr = S_OK;
    // Allow a certain amount of recursion. If it gets to 10, something is obviously broken.
    if (m_dwRecursionCount < 10)
    {
        m_dwRecursionCount++;
	    TListItem<TriggerInfo> *li = m_EventList.GetHead();
	    for (; li; li = li->GetNext())
	    {
		    TriggerInfo &rinfo = li->GetItemValue();
		    rinfo.pIDMSegment->SetParam(rguid, 0xFFFFFFFF, DMUS_SEG_ALLTRACKS, mtTime - rinfo.lTimePhysical, pData);
	    }
        m_dwRecursionCount--;
    }

	return hr;
}

STDMETHODIMP
CSegTriggerTrack::InitPlay(
		IDirectMusicSegmentState *pSegmentState,
		IDirectMusicPerformance *pPerformance,
		void **ppStateData,
		DWORD dwTrackID,
		DWORD dwFlags)
{
	// Call PlayingTrack base class, which sets up our state data.
	HRESULT hr = CSegTriggerTrackBase::InitPlay(pSegmentState, pPerformance, ppStateData, dwTrackID, dwFlags);
	if (SUCCEEDED(hr))
	{
		// Get the audiopath being used by our segment state and save it in our state data.
		assert(*ppStateData); // base class should have created state data
		assert(pSegmentState); // base class should have returned E_POINTER if it wasn't given a segment state

		CSegTriggerTrackState *pState = static_cast<CSegTriggerTrackState *>(*ppStateData);

		IDirectMusicSegmentState8 *pSegSt8 = NULL;
		hr = pSegmentState->QueryInterface(IID_IDirectMusicSegmentState8, reinterpret_cast<void**>(&pSegSt8));
		if (SUCCEEDED(hr))
		{
			hr = pSegSt8->GetObjectInPath(
							0,							// pchannel doesn't apply
							DMUS_PATH_AUDIOPATH,		// get the audiopath
							0,							// buffer index doesn't apply
							CLSID_NULL,					// clsid doesn't apply
							0,							// there should be only one audiopath
							IID_IDirectMusicAudioPath,
							reinterpret_cast<void**>(&pState->pAudioPath));

			// If this doesn't find an audiopath that's OK.  If we're not playing on an audiopath then
			// pAudioPath stays NULL and we'll play our triggered segments on the general performance.
			if (hr == DMUS_E_NOT_FOUND)
				hr = S_OK;
    		pSegSt8->Release();
		}
	}
	return hr;
}

//////////////////////////////////////////////////////////////////////
// Load

// Helper used by the Load functions when we expected to find something
// but a RiffIter becomes false.  In this case, if it has a success HR
// indicating there were no more items then we return DMUS_E_INVALID_SEGMENTTRIGGERTRACK
// because the stream didn't contain the data we expected.  If it has a
// failure hr, it was unable to read from the stream and we return its HR.
HRESULT LoadHrFailOK(const SmartRef::RiffIter &ri)
{
	HRESULT hr = ri.hr();
	return SUCCEEDED(hr) ? DMUS_E_INVALID_SEGMENTTRIGGERTRACK : hr;
};

HRESULT
CSegTriggerTrack::LoadRiff(SmartRef::RiffIter &ri, IDirectMusicLoader *pIDMLoader)
{
	HRESULT hr = S_OK;

	if (!ri.Find(SmartRef::RiffIter::List, DMUS_FOURCC_SEGTRACK_LIST))
	{
#ifdef DBG
		if (SUCCEEDED(ri.hr()))
		{
			Trace(1, "Error: Unable to load segment trigger track: List 'segt' not found.\n");
		}
#endif
		return LoadHrFailOK(ri);
	}

	SmartRef::RiffIter riTrackForm = ri.Descend();
	if (!riTrackForm)
		return riTrackForm.hr();

	for ( ; riTrackForm; ++riTrackForm)
	{
		if (riTrackForm.type() == SmartRef::RiffIter::Chunk)
		{
			if (riTrackForm.id() == DMUS_FOURCC_SEGTRACK_CHUNK)
			{
				DMUS_IO_SEGMENT_TRACK_HEADER ioItem;
				hr = SmartRef::RiffIterReadChunk(riTrackForm, &ioItem);
				if (FAILED(hr))
					return hr;

				m_dwFlags = ioItem.dwFlags;
			}
		}
		else if (riTrackForm.type() == SmartRef::RiffIter::List)
		{
			if (riTrackForm.id() == DMUS_FOURCC_SEGMENTS_LIST)
			{
				SmartRef::RiffIter riSegList = riTrackForm.Descend();
				while (riSegList && riSegList.Find(SmartRef::RiffIter::List, DMUS_FOURCC_SEGMENT_LIST))
				{
					hr = LoadTrigger(riSegList.Descend(), pIDMLoader);
					if (FAILED(hr))
						return hr;
					++riSegList;
				}
				hr = riSegList.hr();
				if (FAILED(hr))
					return hr;
			}
		}
	}
	return riTrackForm.hr();
}

//////////////////////////////////////////////////////////////////////
// other methods

HRESULT
CSegTriggerTrack::PlayItem(
		const TriggerInfo &item,
		statedata &state,
		IDirectMusicPerformance *pPerf,
		IDirectMusicSegmentState* pSegSt,
		DWORD dwVirtualID,
		MUSIC_TIME mtOffset,
		REFERENCE_TIME rtOffset,
		bool fClockTime)
{
	IDirectMusicPerformance8 *pPerf8 = NULL;
	HRESULT hr = pPerf->QueryInterface(IID_IDirectMusicPerformance8, reinterpret_cast<void**>(&pPerf8));
	if (FAILED(hr))
		return hr;

	hr = pPerf8->PlaySegmentEx(
					item.pIDMSegment,
					NULL,														// not a song
					NULL,														// no transition
					item.dwPlayFlags | (fClockTime ? DMUS_SEGF_REFTIME : 0),	// flags
					fClockTime
						? item.lTimePhysical * REF_PER_MIL + rtOffset
						: item.lTimePhysical + mtOffset,						// time
					NULL,														// ignore returned segment state
					NULL,														// no replacement
					state.pAudioPath											// audio path to use (may be NULL indicating defualt)
					);
	pPerf8->Release();
    if (FAILED(hr))
    {
        Trace(1,"Segment Trigger Track failed segment playback\n");
        hr = S_OK; // Avoid an assert.
    }
	return hr;
}

HRESULT
CSegTriggerTrack::LoadTrigger(
		SmartRef::RiffIter ri,
		IDirectMusicLoader *pIDMLoader)
{
	HRESULT hr = S_OK;

	if (!ri)
		return ri.hr();

	// Create an event
	TListItem<TriggerInfo> *pItem = new TListItem<TriggerInfo>;
	if (!pItem)
		return E_OUTOFMEMORY;
	TriggerInfo &rinfo = pItem->GetItemValue();

	// find the item header (we can't interpret the other chunks until we've found it)
	if (!ri.Find(SmartRef::RiffIter::Chunk, DMUS_FOURCC_SEGMENTITEM_CHUNK))
    {
        delete pItem;
#ifdef DBG
		if (SUCCEEDED(ri.hr()))
		{
			Trace(1, "Error: Unable to load segment trigger track: Chunk 'sgih' not found.\n");
		}
#endif
		return LoadHrFailOK(ri);
    }

	// read the header
	DMUS_IO_SEGMENT_ITEM_HEADER ioItem;
	hr = SmartRef::RiffIterReadChunk(ri, &ioItem);
	if (FAILED(hr))
    {
        delete pItem;
		return hr;
    }
	rinfo.lTriggerTime = ioItem.lTimeLogical;
	rinfo.lTimePhysical = ioItem.lTimePhysical;
	rinfo.dwPlayFlags = ioItem.dwPlayFlags;
	rinfo.dwFlags = ioItem.dwFlags;
	++ri;
	if (!ri)
	{
		// If there's nothing more then this is an empty trigger we should ignore because the user hasn't specified
		// the style or segment to play from.
		delete pItem;
		return ri.hr();
	}

	if (!(rinfo.dwFlags & DMUS_SEGMENTTRACKF_MOTIF))
	{
		// find the referenced segment
		if (!ri.Find(SmartRef::RiffIter::List, DMUS_FOURCC_REF_LIST))
		{
			// If there's no DMRF then we should ignore this trigger because the user hasn't specified a segment.
			delete pItem;
			return ri.hr();
        }

		hr = ri.LoadReference(pIDMLoader, IID_IDirectMusicSegment, reinterpret_cast<void**>(&rinfo.pIDMSegment));
		if (FAILED(hr))
        {
            Trace(1,"Error: Segment trigger track failed, unable to load referenced segment.\n");
            delete pItem;
			return hr;
        }
	}
	else
	{
		// find the segment from the referenced style and motif name
		SmartRef::ComPtr<IDirectMusicStyle> scomStyle;
		SmartRef::Buffer<WCHAR> wbufMotifName;
		for ( ; ri; ++ri)
		{
			if (ri.type() == SmartRef::RiffIter::List)
			{
				if (ri.id() == DMUS_FOURCC_REF_LIST)
				{
					hr = ri.LoadReference(pIDMLoader, IID_IDirectMusicStyle, reinterpret_cast<void**>(&scomStyle));
					if (FAILED(hr))
                    {
                        delete pItem;
						return hr;
                    }
				}
			}
			else if (ri.type() == SmartRef::RiffIter::Chunk)
			{
				if (ri.id() == DMUS_FOURCC_SEGMENTITEMNAME_CHUNK)
				{
					hr = ri.ReadText(&wbufMotifName);
					if (FAILED(hr))
                    {
                        delete pItem;
#ifdef DBG
						if (hr == E_FAIL)
						{
							Trace(1, "Error: Unable to load segment trigger track: Problem reading 'snam' chunk.\n");
						}
#endif
						return hr == E_FAIL ? DMUS_E_INVALID_SEGMENTTRIGGERTRACK : hr;
                    }
				}
			}
		}
		hr = ri.hr();
		if (FAILED(hr))
        {
            delete pItem;
			return hr;
        }

		if (!(scomStyle && wbufMotifName))
		{
			// This happens if the track didn't contain a DMRF list or snam chunk.	We allow
			// this as a means of representing an empty trigger track item or where the
			// motif to play hasn't been specified.  When loading we'll simply ignore
			// this item and continue reading the track.
			delete pItem;
			return S_OK;
		}

		hr = scomStyle->GetMotif(wbufMotifName, &rinfo.pIDMSegment);
		if (hr == S_FALSE)
		{
			Trace(1, "Error: The segment trigger track couldn't load because the motif %S was not found in the style.\n", wbufMotifName);
			hr = DMUS_E_NOT_FOUND;
		}
		if (FAILED(hr))
        {
            delete pItem;
			return hr;
        }
	}

	m_EventList.AddHead(pItem);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\song.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// DMSegObj.h : Declaration of the CSegment

#ifndef __DIRECTMUSICSONGOBJECT_H_
#define __DIRECTMUSICSONGOBJECT_H_

#include "dmusicip.h"
#include "dmusicf.h"
#include "dmime.h"
#include "TrkList.h"
#include "dmgraph.h"
#include "dmsegobj.h"
#include "tlist.h"
#include "..\shared\dmusicp.h"

class CVirtualSegment : public AListItem
{
friend class CSong;
friend class ComposingTrack;
public:
    CVirtualSegment();
    ~CVirtualSegment();
    CVirtualSegment* GetNext() { return (CVirtualSegment*)AListItem::GetNext();}
    CTrack * GetTrackByParam( CTrack * pCTrack,
        REFGUID rguidType,DWORD dwGroupBits,DWORD dwIndex);
private:
    CTrackList              m_TrackList;        // List of tracks that this segment uses.
    CSegment *              m_pSourceSegment;   // Segment that is used as basis for this segment.
    CSegment *              m_pPlaySegment;     // Resulting segment that will be played.
    CGraph *                m_pGraph;           // Optional tool graph.
    DWORD                   m_dwFlags;          // Various control flags.
    DWORD                   m_dwID;             // Unique ID.
    DWORD                   m_dwNextPlayID;     // ID of next segment, to chain segments into a song.
    DWORD                   m_dwNextPlayFlags;  // DMUS_SEGF flags for playing next segment, when chaining a song.
    DMUS_IO_SEGMENT_HEADER  m_SegHeader;        // Segment header, used to define the segment that it creates, or change the one it references.
    MUSIC_TIME              m_mtTime;           // Start time of this segment.
    DWORD                   m_dwTransitionCount;// How many transitions are defined. 
    DMUS_IO_TRANSITION_DEF *m_pTransitions;     // Array of transitions from other segments.
	WCHAR	                m_wszName[DMUS_MAX_NAME];// Name of generated segment.
};

class CVirtualSegmentList : public AList
{
public:
    void Clear();
    void AddHead(CVirtualSegment* pVirtualSegment) { AList::AddHead((AListItem*)pVirtualSegment);}
    void Insert(CVirtualSegment* pVirtualSegment);
    CVirtualSegment* GetHead(){return (CVirtualSegment*)AList::GetHead();}
    CVirtualSegment* GetItem(LONG lIndex){return (CVirtualSegment*)AList::GetItem(lIndex);}
    CVirtualSegment* RemoveHead()  { return (CVirtualSegment *)AList::RemoveHead();};
    void Remove(CVirtualSegment* pVirtualSegment){AList::Remove((AListItem*)pVirtualSegment);}
    void AddTail(CVirtualSegment* pVirtualSegment){AList::AddTail((AListItem*)pVirtualSegment);}
    CVirtualSegment* GetTail(){ return (CVirtualSegment*)AList::GetTail();}
};

class CSongSegment : public AListItem
{
public:
    CSongSegment();
    ~CSongSegment();
    CSongSegment* GetNext() { return (CSongSegment*)AListItem::GetNext();}
    CSegment *              m_pSegment;   
    DWORD                   m_dwLoadID;
};

class CSongSegmentList : public AList
{
public:
    HRESULT AddSegment(CSegment *pSegment, DWORD dwLoadID);
    void Clear();
    void AddHead(CSongSegment* pSongSegment) { AList::AddHead((AListItem*)pSongSegment);}
    void Insert(CSongSegment* pSongSegment);
    CSongSegment* GetHead(){return (CSongSegment*)AList::GetHead();}
    CSongSegment* GetItem(LONG lIndex){return (CSongSegment*)AList::GetItem(lIndex);}
    CSongSegment* RemoveHead()  { return (CSongSegment *)AList::RemoveHead();};
    void Remove(CSongSegment* pSongSegment){AList::Remove((AListItem*)pSongSegment);}
    void AddTail(CSongSegment* pSongSegment){AList::AddTail((AListItem*)pSongSegment);}
    CSongSegment* GetTail(){ return (CSongSegment*)AList::GetTail();}
};


class CSong;

DEFINE_GUID(IID_CSong,0xb06c0c22, 0xd3c7, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);


/////////////////////////////////////////////////////////////////////////////
// CSong
class CSong : 
	public IDirectMusicSong,
	public IPersistStream,
	public IDirectMusicObject,
    public IDirectMusicObjectP
{
public:
	CSong();
	~CSong();

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
// IDirectMusicSong
    STDMETHODIMP Compose( );
    STDMETHODIMP GetParam( REFGUID rguidType, 
                            DWORD dwGroupBits, 
                            DWORD dwIndex, 
                            MUSIC_TIME mtTime, 
                            MUSIC_TIME* pmtNext, 
                            void* pParam) ;
    STDMETHODIMP GetSegment( const WCHAR *wszName,IDirectMusicSegment **ppSegment) ;
    STDMETHODIMP EnumSegment( DWORD dwIndex,IDirectMusicSegment **ppSegment) ;
    STDMETHODIMP GetAudioPathConfig(IUnknown ** ppAudioPathConfig);
    STDMETHODIMP Download(IUnknown *pAudioPath);
    STDMETHODIMP Unload(IUnknown *pAudioPath);

// IPersist 
    STDMETHODIMP GetClassID( CLSID* pClsId );

// IPersistStream 
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load( IStream* pIStream );
    STDMETHODIMP Save( IStream* pIStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER FAR* pcbSize );

// IDirectMusicObject 
	STDMETHODIMP GetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP SetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc);

// IDirectMusicObjectP
	STDMETHOD_(void, Zombie)();

public:
    HRESULT GetTransitionSegment(CSegment *pSource, CSegment *pDestination,
        DMUS_IO_TRANSITION_DEF *pTransDef);
    HRESULT GetPlaySegment( DWORD dwIndex,CSegment **ppSegment) ;
private:
    void                Clear();
    HRESULT				Instantiate() ;
//    HRESULT             LoadReferencedSegment(CSegment **ppSegment, CRiffParser *pParser);
    HRESULT             LoadSegmentList(CRiffParser *pParser);
    HRESULT             LoadGraphList(CRiffParser *pParser);
    HRESULT             LoadVirtualSegmentList(CRiffParser *pParser);
    HRESULT             LoadTrackRefList(CRiffParser *pParser, CVirtualSegment *pVirtualSegment);
    HRESULT             LoadAudioPath(IStream *pStream);

    void GetGraph(CGraph **ppGraph,DWORD dwGraphID);
    void GetSourceSegment(CSegment **ppSegment,DWORD dwSegmentID);
    BOOL GetSegmentTrack(IDirectMusicTrack **ppTrack,DWORD dwSegmentID,DWORD dwGroupBits,DWORD dwIndex,REFGUID guidClassID);
    CAudioPathConfig*   m_pAudioPathConfig;     // Optional audio path loaded from file. 
    CGraphList          m_GraphList;            // List of graphs for use by segments in the song.
    CSongSegmentList    m_SegmentList;          // List of source segments.
    CSegmentList        m_PlayList;             // List of composed segments.
    CVirtualSegmentList m_VirtualSegmentList;   // List of segment references. This is what is used to compose the finished song.         
    CRITICAL_SECTION    m_CriticalSection;      
    DWORD               m_dwFlags;
    DWORD               m_dwStartSegID;         // ID of first segment, in play list, that should play.
	long                m_cRef;
// IDirectMusicObject variables
    CInfo               m_Info;
    IUnknown *          m_pUnkDispatch;     // holds the controlling unknown of the scripting object that implements IDispatch
    bool                m_fZombie;
    CMemTrack           m_MemTrack;             // For debug memory tracking.
};


struct CompositionComponent
{
	CVirtualSegment*	pVirtualSegment;			// composing track came from here
	CTrack*		pComposingTrack;	// used for composition
	MUSIC_TIME	mtTime;
};

class ComposingTrack
{
public:
	ComposingTrack();
	~ComposingTrack();
	DWORD GetTrackGroup() { return m_dwTrackGroup; }
	GUID GetTrackID() { return m_guidClassID; }
	DWORD GetPriority() { return m_dwPriority; }
	void SetPriority(DWORD dwPriority) { m_dwPriority = dwPriority; }
	void SetTrackGroup(DWORD dwTrackGroup) { m_dwTrackGroup = dwTrackGroup; }
	void SetTrackID(GUID& rguidClassID) { m_guidClassID = rguidClassID; }
	HRESULT AddTrack(CVirtualSegment* pVirtualSegment, CTrack* pTrack);
	HRESULT Compose(IDirectMusicSong* pSong);
private:
	GUID						m_guidClassID;		// composing track's class id
	DWORD						m_dwTrackGroup;		// track will be composed from these groups
    DWORD						m_dwPriority;		// Track priority, to order the composition process.
	TList<CompositionComponent>	m_Components;		// list of components making up the master
};

#endif //__DIRECTMUSICSONGOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\sysextrk.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// SysExTrk.h : Declaration of the CSysExTrk

#ifndef __SYSEXTRK_H_
#define __SYSEXTRK_H_

#include "dmusicip.h"
#include "dmusicf.h"
#include "alist.h"

// FullSysexEvent is DMUS_IO_SYSEX_ITEM plus data pointer
struct FullSysexEvent : DMUS_IO_SYSEX_ITEM
{
	BYTE* pbSysExData;
};

class SysExListItem : public AListItem
{
public:
	SysExListItem()
	{
		m_pItem = NULL;
	};

	HRESULT SetItem( FullSysexEvent item )
	{
		if( m_pItem )
		{
			delete [] m_pItem->pbSysExData;
		}
		else
		{
			m_pItem = new FullSysexEvent;
		}
		if( m_pItem )
		{
			m_pItem->mtTime = item.mtTime;
			m_pItem->dwSysExLength = item.dwSysExLength;
			m_pItem->pbSysExData = item.pbSysExData;
			return S_OK;
		}
		else
		{
			return E_OUTOFMEMORY;
		}
	};

	~SysExListItem()
	{
		if( m_pItem )
		{
			if( m_pItem->pbSysExData )
			{
				delete [] m_pItem->pbSysExData;
			}
			delete m_pItem;
		}
	};

	SysExListItem* GetNext()
	{
		return (SysExListItem*)AListItem::GetNext();
	};
public:
	FullSysexEvent* m_pItem;
};

class SysExList : public AList
{
public:
	~SysExList()
	{
		SysExListItem* pItem;
		while( pItem = (SysExListItem*)AList::RemoveHead() )
		{
			delete pItem;
		}
	};

	void DeleteAll()
	{
		SysExListItem* pItem;
		while( pItem = (SysExListItem*)AList::RemoveHead() )
		{
			delete pItem;
		}
	};

    SysExListItem* GetHead() 
	{
		return (SysExListItem*)AList::GetHead();
	};
};

struct SysExStateData
{
	SysExListItem*				pCurrentSysEx;
	IDirectMusicPerformance*	pPerformance;
	IDirectMusicSegmentState*	pSegState;
	DWORD						dwVirtualTrackID;
	DWORD						dwValidate;
	MUSIC_TIME					mtPrevEnd;

	SysExStateData()
	{
		mtPrevEnd = 0;
	}
};

/////////////////////////////////////////////////////////////////////////////
// CSysExTrk
class CSysExTrack : 
	public IPersistStream,
	public IDirectMusicTrack8
{
public:
	CSysExTrack();
	CSysExTrack::CSysExTrack(
		CSysExTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd);
	~CSysExTrack();

// ISysExTrk
public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

// IDirectMusicTrack methods
    STDMETHODIMP IsParamSupported(REFGUID rguid);
    STDMETHODIMP Init(IDirectMusicSegment *pSegment);
    STDMETHODIMP InitPlay(IDirectMusicSegmentState *pSegmentState,
                IDirectMusicPerformance *pPerformance,
                void **ppStateData,
                DWORD dwTrackID,
                DWORD dwFlags);
    STDMETHODIMP EndPlay(void *pStateData);
    STDMETHODIMP Play(void *pStateData,MUSIC_TIME mtStart,
                MUSIC_TIME mtEnd,MUSIC_TIME mtOffset,
		        DWORD dwFlags,IDirectMusicPerformance* pPerf,
		        IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID);
    STDMETHODIMP GetParam(REFGUID rguid,MUSIC_TIME mtTime,MUSIC_TIME* pmtNext,void *pData);
    STDMETHODIMP SetParam(REFGUID rguid,MUSIC_TIME mtTime,void *pData);
    STDMETHODIMP AddNotificationType(REFGUID rguidNotification);
    STDMETHODIMP RemoveNotificationType(REFGUID rguidNotification);
    STDMETHODIMP Clone(MUSIC_TIME mtStart,MUSIC_TIME mtEnd,IDirectMusicTrack** ppTrack);
// IDirectMusicTrack8 
    STDMETHODIMP PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf, 
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) ; 
    STDMETHODIMP GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) ; 
    STDMETHODIMP SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,void* pParam, void * pStateData, DWORD dwFlags) ;
    STDMETHODIMP Compose(IUnknown* pContext, 
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;
    STDMETHODIMP Join(IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;

// IPersist functions
    STDMETHODIMP GetClassID( CLSID* pClsId );
// IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load( IStream* pIStream );
    STDMETHODIMP Save( IStream* pIStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER FAR* pcbSize );

protected:
	HRESULT Seek(void *pStateData,MUSIC_TIME mtTime);
    HRESULT Play(void *pStateData,MUSIC_TIME mtStart,MUSIC_TIME mtEnd,
        MUSIC_TIME mtOffset,REFERENCE_TIME rtOffset,DWORD dwFlags,		
	    IDirectMusicPerformance* pPerf,IDirectMusicSegmentState* pSegSt,
	    DWORD dwVirtualID,BOOL fClockTime);
	void Construct(void);

// private member variables
protected:
	SysExList	m_SysExEventList;
	long	m_cRef;
	DWORD	m_dwValidate;
	CRITICAL_SECTION m_CrSec;
    BOOL    m_fCSInitialized;
    CMemTrack           m_MemTrack;             // For debug memory tracking.
};

#endif //__SYSEXTRK_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\paramtrk.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CParamControlTrack.
//

#include "pchime.h"
/*#include "dmime.h"
#include "urlmonhelper.h"
#include "ParamTrk.h"
#include "..\shared\Validate.h"
#include "miscutil.h"
#include "limits.h"
#include "math.h"*/


STDMETHODIMP 
CParamControlTrack::QueryInterface(const IID &iid, void **ppv)
{
	V_INAME(CParamControlTrack::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

	if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack || iid == IID_IDirectMusicTrack8)
		*ppv = static_cast<IDirectMusicTrack8*>(this);
	else if (iid == IID_IPersistStream)
		*ppv = static_cast<IPersistStream*>(this);
	else if (iid == IID_IPersist)
		*ppv = static_cast<IPersist*>(this);
    else if (iid == IID_CParamControlTrack)
    {
        *ppv = static_cast<CParamControlTrack*>(this);
    }
	else
	{
		*ppv = NULL;
        Trace(4,"Warning: Request to query unknown interface on Track\n");
		return E_NOINTERFACE;
	}
	
	reinterpret_cast<IUnknown*>(this)->AddRef();
	return S_OK;
}

STDMETHODIMP
CParamControlTrack::Init(IDirectMusicSegment *pSegment)
{
    V_INAME(CBasicTrack::Init);
    V_INTERFACE(pSegment);

    return S_OK;
}

STDMETHODIMP
CParamControlTrack::Load(IStream* pIStream)
{
    V_INAME(CPlayingTrack::Load);
    V_INTERFACE(pIStream);
    HRESULT hr = S_OK;

    SmartRef::CritSec CS(&m_CriticalSection);

    // Increment counter so the next play will update state data with the new list.
    ++m_dwValidate;
    // Clear the objects/params/curves in case we're being reloaded.
    m_listObjects.CleanUp();
    m_cObjects = 0;
    m_cParams = 0;

    SmartRef::RiffIter ri(pIStream);
    if (!ri)
        return ri.hr();

    // find <prmt>
    hr = ri.FindRequired(SmartRef::RiffIter::List, DMUS_FOURCC_PARAMCONTROLTRACK_TRACK_LIST, DMUS_E_INVALID_PARAMCONTROLTRACK);
    if (FAILED(hr))
    {
#ifdef DBG
        if (hr == DMUS_E_INVALID_PARAMCONTROLTRACK)
        {
            Trace(1, "Error: Unable to load parameter control track: List 'prmt' not found.\n");
        }
#endif
        return hr;
    }
    SmartRef::RiffIter riTrack = ri.Descend();

    // for each <prol>
    while (riTrack && riTrack.Find(SmartRef::RiffIter::List, DMUS_FOURCC_PARAMCONTROLTRACK_OBJECT_LIST))
    {
        hr = this->LoadObject(riTrack.Descend());
        if (FAILED(hr))
            return hr;
        ++riTrack;
    }
    hr = riTrack.hr();

    return hr;
}

STDMETHODIMP
CParamControlTrack::InitPlay(
    IDirectMusicSegmentState *pSegmentState,
    IDirectMusicPerformance *pPerformance,
    void **ppStateData,
    DWORD dwTrackID,
    DWORD dwFlags)
{
    V_INAME(CParamControlTrack::InitPlay);
    V_PTRPTR_WRITE(ppStateData);
    V_INTERFACE(pSegmentState);
    V_INTERFACE(pPerformance);

    SmartRef::CritSec CS(&m_CriticalSection);

    // Set up state data
    StateData *pStateData = new StateData;
    if (!pStateData)
        return E_OUTOFMEMORY;

    HRESULT hr = InitStateData(pStateData, pSegmentState);
    if (FAILED(hr))
    {
        delete pStateData;
    }
    else
    {
        pStateData->dwValidate = m_dwValidate;
        *ppStateData = pStateData;
    }

    return hr;
}

STDMETHODIMP
CParamControlTrack::EndPlay(void *pStateData)
{
    V_INAME(CParamControlTrack::EndPlay);
    V_BUFPTR_WRITE(pStateData, sizeof(StateData));

    SmartRef::CritSec CS(&m_CriticalSection);

    StateData *pSD = static_cast<StateData *>(pStateData);

    if (!pSD->fFlushInAbort)
    {
        // For each object, flush all curves on each parameter up to the start time of the last one we sent.
        //    (This allows the DMO being controlled to free up memory associated with any previous curves
        //     while still keeping the last one around so that the next thing played picks up that parameter
        //     value how it was left.)
        // Then release the object's params interface.
        int iObj = 0;
        for (TListItem<ObjectInfo> *pObject = m_listObjects.GetHead();
                pObject && iObj < m_cObjects;
                pObject = pObject->GetNext(), ++iObj)
        {
            IMediaParams *pIMediaParams = pSD->prgpIMediaParams[iObj];
            if (pIMediaParams)
            {
                ObjectInfo &obj = pObject->GetItemValue();
                int iParam = 0;
                for (TListItem<ParamInfo> *pParam = obj.listParams.GetHead();
                        pParam && iParam < m_cParams;
                        pParam = pParam->GetNext(), ++iParam)
                {
                    ParamInfo &param = pParam->GetItemValue();
                    ParamState &paramstate = pSD->prgParam[iParam];
                    if (paramstate.fLast)
                    {
                        HRESULT hrFlush = pIMediaParams->FlushEnvelope(param.header.dwIndex, _I64_MIN, paramstate.rtStartPointOfLastCurve);
                        if (FAILED(hrFlush))
                        {
                            assert(false);
                            TraceI(1, "Unable to flush envelope information from an audio path object in parameter control track, HRESULT 0x%08x.\n", hrFlush);
                        }
                    }
                }
            }
            SafeRelease(pIMediaParams);
        }
    }
    delete[] pSD->prgpIMediaParams;
    delete[] pSD->prgParam;
    delete pSD;

    return S_OK;
}

HRESULT CParamControlTrack::OnSegmentEnd(REFERENCE_TIME rtEnd, void *pStateData)
{
    SmartRef::CritSec CS(&m_CriticalSection);

    StateData *pSD = static_cast<StateData *>(pStateData);

    // For each object, flush all curves on each parameter up to the start time of the last one we sent
    // (if that started before segment end) or flush everything up to the last one to start before
    // segment end, and flush everything after segment end (if the start time was after segment end).
    //    (This allows the DMO being controlled to free up memory associated with any previous curves
    //     while still keeping the last one around so that the next thing played picks up that parameter
    //     value how it was left.)
    // Then release the object's params interface.
    int iObj = 0;
    for (TListItem<ObjectInfo> *pObject = m_listObjects.GetHead();
            pObject && iObj < m_cObjects;
            pObject = pObject->GetNext(), ++iObj)
    {
        IMediaParams *pIMediaParams = pSD->prgpIMediaParams[iObj];
        if (pIMediaParams)
        {
            ObjectInfo &obj = pObject->GetItemValue();
            int iParam = 0;
            for (TListItem<ParamInfo> *pParam = obj.listParams.GetHead();
                    pParam && iParam < m_cParams;
                    pParam = pParam->GetNext(), ++iParam)
            {
                ParamInfo &param = pParam->GetItemValue();
                ParamState &paramstate = pSD->prgParam[iParam];
                if (paramstate.fLast)
                {
                    HRESULT hrFlush = S_OK;
                    if (paramstate.rtStartPointOfLastCurve < rtEnd)
                    {
                        hrFlush = pIMediaParams->FlushEnvelope(param.header.dwIndex, _I64_MIN, paramstate.rtStartPointOfLastCurve);
                    }
                    else
                    {
                        // first, look for the largest start time less than rtEnd and
                        // flush up to there.  The loop assumes the list is ordered largest to smallest.
                        TListItem<REFERENCE_TIME>* pStartTime = paramstate.listStartTimes.GetHead();
                        for (; pStartTime; pStartTime = pStartTime->GetNext())
                        {
                            if (pStartTime->GetItemValue() < rtEnd)
                            {
                                hrFlush = pIMediaParams->FlushEnvelope(param.header.dwIndex, _I64_MIN, pStartTime->GetItemValue());
                                break;
                            }
                        }
                        // Then, flush from rtEnd on.
                        if (SUCCEEDED(hrFlush))
                        {
                            hrFlush = pIMediaParams->FlushEnvelope(param.header.dwIndex, rtEnd, _I64_MAX);
                        }
                    }
                    if (FAILED(hrFlush))
                    {
                        assert(false);
                        TraceI(1, "Unable to flush envelope information from an audio path object in parameter control track, HRESULT 0x%08x.\n", hrFlush);
                    }
                }
            }
        }
        SafeRelease(pIMediaParams);
        pSD->prgpIMediaParams[iObj] = NULL;
    }

    pSD->fFlushInAbort = true;

    return S_OK;
}

STDMETHODIMP
CParamControlTrack::Clone(MUSIC_TIME mtStart, MUSIC_TIME mtEnd, IDirectMusicTrack** ppTrack)
{
    //  Test more thoroughly when we have multiple working params/objects.

    V_INAME(CParamControlTrack::Clone);
    V_PTRPTR_WRITE(ppTrack);

    SmartRef::CritSec CS(&m_CriticalSection);

    HRESULT hr = S_OK;

    SmartRef::ComPtr<CParamControlTrack> scomTrack = new CParamControlTrack(&hr);
    if (FAILED(hr))
        return hr;
    if (!scomTrack)
        return E_OUTOFMEMORY;
    scomTrack->AddRef();

    // Copy each object
    for (TListItem<ObjectInfo> *pObject = m_listObjects.GetHead();
            pObject;
            pObject = pObject->GetNext())
    {
        ObjectInfo &obj = pObject->GetItemValue();
        TListItem<ObjectInfo> *pNewObject = new TListItem<ObjectInfo>;
        if (!pNewObject)
            return E_OUTOFMEMORY;
        ObjectInfo &newobj = pNewObject->GetItemValue();
        newobj.header = obj.header;

        // Copy each parameter
        for (TListItem<ParamInfo> *pParam = obj.listParams.GetHead();
                pParam;
                pParam = pParam->GetNext())
        {
            ParamInfo &param = pParam->GetItemValue();
            TListItem<ParamInfo> *pNewParam = new TListItem<ParamInfo>;
            if (!pNewParam)
                return E_OUTOFMEMORY;
            ParamInfo &newparam = pNewParam->GetItemValue();
            newparam.header = param.header;

            // Copy the curves from mtStart to mtEnd
            // These should include curves that overlap the start and end, though this
            // leave some issues we still need to work out (what happens with overlapping curves?)
            // So, first find the first curve whose end time is at or after mtStart...
            for (DMUS_IO_PARAMCONTROLTRACK_CURVEINFO *pCurveStart = param.curves;
                    (pCurveStart < param.curvesEnd) && (pCurveStart->mtEndTime < mtStart);
                    ++pCurveStart)
            {}
            // Then, find the curve whose start time is after mtEnd.
            for (DMUS_IO_PARAMCONTROLTRACK_CURVEINFO *pCurveEnd = pCurveStart;
                    (pCurveEnd < param.curvesEnd) && (pCurveEnd->mtStartTime < mtEnd);
                    ++pCurveEnd)
            {}
            int cCurves = (int)(pCurveEnd - pCurveStart);
            newparam.curves = new DMUS_IO_PARAMCONTROLTRACK_CURVEINFO[cCurves];
            if (!newparam.curves)
                return E_OUTOFMEMORY;
            memcpy(newparam.curves, pCurveStart, cCurves * sizeof(DMUS_IO_PARAMCONTROLTRACK_CURVEINFO));
            newparam.curvesEnd = newparam.curves + cCurves;
            // Now, scan through the new curve array and adjust the times by subtracting mtStart from everything.
            for (pCurveStart = newparam.curves; pCurveStart < newparam.curvesEnd; pCurveStart++)
            {
                pCurveStart->mtStartTime -= mtStart;
                pCurveStart->mtEndTime -= mtStart;
            }

            newobj.listParams.AddHead(pNewParam);
        }

        newobj.listParams.Reverse(); // Technically, the order shouldn't matter.  But this ensures that the cloned track will send curves to different parameters in the exact same order just in case.
        scomTrack->m_listObjects.AddHead(pNewObject);
    }
    scomTrack->m_listObjects.Reverse(); // Technically, the order shouldn't matter.  But this ensures that the cloned track will send curves to different objects in the exact same order just in case.
    ++scomTrack->m_dwValidate;

    scomTrack->m_cObjects = m_cObjects;
    scomTrack->m_cParams = m_cParams;

    *ppTrack = scomTrack.disown();
    return hr;
}

HRESULT
CParamControlTrack::PlayMusicOrClock(
    void *pStateData,
    MUSIC_TIME mtStart,
    MUSIC_TIME mtEnd,
    MUSIC_TIME mtOffset,
    REFERENCE_TIME rtOffset,
    DWORD dwFlags,
    IDirectMusicPerformance* pPerf,
    IDirectMusicSegmentState* pSegSt,
    DWORD dwVirtualID,
    bool fClockTime)
{
    V_INAME(CParamControlTrack::Play);
    V_BUFPTR_WRITE( pStateData, sizeof(StateData));
    V_INTERFACE(pPerf);
    V_INTERFACE(pSegSt);

    if (dwFlags & DMUS_TRACKF_PLAY_OFF)
        return S_OK;

    SmartRef::CritSec CS(&m_CriticalSection);

    StateData *pSD = static_cast<StateData *>(pStateData);

    if (m_dwValidate != pSD->dwValidate)
    {
        HRESULT hr = InitStateData(pSD, pSegSt);
        if (FAILED(hr))
        {
            return hr;
        }
    }

    // envelope structure we'll fill for sending each envelope segment.
    MP_ENVELOPE_SEGMENT envCurve;
    Zero(&envCurve);
    MP_ENVELOPE_SEGMENT *const penvCurve = &envCurve;

    bool fMoreCurves = false; // set to true by any parameter that has more curves to play

    // for each parameter...
    int iParam = 0;
    int iObject = 0;
    for (TListItem<ObjectInfo> *pObject = m_listObjects.GetHead();
            pObject && iObject < m_cObjects;
            pObject = pObject->GetNext(), ++iObject)
    {
        ObjectInfo &obj = pObject->GetItemValue();
        IMediaParams *pIMediaParams = pSD->prgpIMediaParams[iObject];

        bool fObjClockTime = !!(obj.header.guidTimeFormat == GUID_TIME_REFERENCE);
        if (!fObjClockTime && obj.header.guidTimeFormat != GUID_TIME_MUSIC)
        {
            // track can only handle music and clock time
            assert(false);
            // Only log this once at warning level one.  Rest go to warning level three to avoid tons of identical trace messages during playback).
            TraceI(
                obj.fAlreadyTracedPlaybackError ? 3 : 1,
                "Parameter control track unable to control object -- unknown time format (must be GUID_TIME_MUSIC or GUID_TIME_REFERENCE).\n");
            obj.fAlreadyTracedPlaybackError = true;
            continue;
        }

        for (TListItem<ParamInfo> *pParam = obj.listParams.GetHead();
                pParam && iParam < m_cParams;
                pParam = pParam->GetNext(), ++iParam)
        {
            ParamInfo &param = pParam->GetItemValue();
            ParamState &paramstate = pSD->prgParam[iParam];

            DMUS_IO_PARAMCONTROLTRACK_CURVEINFO *&pCurrentCurve = paramstate.pCurrentCurve;

            // We're going to seek through the event list to find the proper next control curve for each parameter if
            // the track's data has been reloaded or if playback has made a jump to a different position in the track.
            if (m_dwValidate != pSD->dwValidate || dwFlags & (DMUS_TRACKF_SEEK | DMUS_TRACKF_LOOP | DMUS_TRACKF_FLUSH | DMUS_TRACKF_START))
            {
                assert(m_dwValidate != pSD->dwValidate || dwFlags & DMUS_TRACKF_SEEK); // by contract SEEK should be set whenever the other dwFlags are

                // find first curve that begins at or after the start time we're currently playing
                for (pCurrentCurve = param.curves; pCurrentCurve < param.curvesEnd && pCurrentCurve->mtStartTime < mtStart; ++pCurrentCurve)
                {}

                if (pIMediaParams && pCurrentCurve > param.curves)
                {
                    // check the previous curve to see if we ended up in the middle of it
                    DMUS_IO_PARAMCONTROLTRACK_CURVEINFO *pPrevCurve = pCurrentCurve - 1;
                    // Send a curve chopped off at the start time we're currently playing.
                    // We can't send the whole curve because it would take effect too early.
                    HRESULT hrEnv = this->PlayTruncatedEnvelope(mtStart, pIMediaParams, penvCurve, pPrevCurve, obj, param, paramstate, mtOffset, rtOffset, pPerf, fClockTime, fObjClockTime, dwFlags);
                    if (FAILED(hrEnv))
                    {
                        // Can't fail from Play.  Just assert and print trace information.
                        assert(false);
                        // Only log this once at warning level one.  Rest go to warning level three to avoid tons of identical trace messages during playback).
                        TraceI(
                            param.fAlreadyTracedPlaybackError ? 3 : 1,
                            "Unable to send envelope information to an audio path object in parameter control track, HRESULT 0x%08x.\n", hrEnv);
                        param.fAlreadyTracedPlaybackError = true;
                    }
                }
            }

            // Send curves until the next curve is after mtEnd
            for ( ; pCurrentCurve < param.curvesEnd; ++pCurrentCurve )
            {
                if (pCurrentCurve->mtStartTime < mtStart) // this can happen if DMUS_TRACKF_PLAY_OFF was set and the seek pointer remains at events from the past
                    continue;
                if (pCurrentCurve->mtStartTime >= mtEnd)
                    break;

                // send this curve
                if (pIMediaParams)
                {
                    HRESULT hrEnv = this->PlayEnvelope(pIMediaParams, penvCurve, pCurrentCurve, obj, param, paramstate, mtOffset, rtOffset, pPerf, fClockTime, fObjClockTime);
                    if (FAILED(hrEnv))
                    {
                        // Can't fail from Play.  Just assert and print trace information.
                        assert(false);
                        // Only log this once at warning level one.  Rest go to warning level three to avoid tons of identical trace messages during playback).
                        TraceI(
                            param.fAlreadyTracedPlaybackError ? 3 : 1,
                            "Unable to send envelope information to an audio path object in parameter control track, HRESULT 0x%08x.\n", hrEnv);
                        param.fAlreadyTracedPlaybackError = true;
                    }
                }
            }

            if (pCurrentCurve < param.curvesEnd)
                fMoreCurves = true;
        }
        assert(!pParam); // we should have gotten all the way through this param list
    }
    assert(!pObject && iParam == m_cParams && iObject == m_cObjects); // we should have gotten all the way through the object list and done the expected number of objects and parameters

    pSD->dwValidate = m_dwValidate; // if we weren't in sync with new track data before, we are now
    return fMoreCurves ? S_OK : DMUS_S_END;
}

HRESULT CParamControlTrack::LoadObject(SmartRef::RiffIter ri)
{
    if (!ri)
        return ri.hr();

    HRESULT hr = S_OK;

    SmartRef::Ptr<TListItem<ObjectInfo> > spItem = new TListItem<ObjectInfo>;
    if (!spItem)
        return E_OUTOFMEMORY;
    ObjectInfo &ritem = spItem->GetItemValue();

    // find <proh>
    hr = ri.FindRequired(SmartRef::RiffIter::Chunk, DMUS_FOURCC_PARAMCONTROLTRACK_OBJECT_CHUNK, DMUS_E_INVALID_PARAMCONTROLTRACK);
    if (FAILED(hr))
    {
#ifdef DBG
        if (hr == DMUS_E_INVALID_PARAMCONTROLTRACK)
        {
            Trace(1, "Error: Unable to load parameter control track: Chunk 'proh' not found.\n");
        }
#endif
        return hr;
    }

    hr = SmartRef::RiffIterReadChunk(ri, &ritem.header);
    if (FAILED(hr))
        return hr;
    if (!(ritem.header.guidTimeFormat == GUID_TIME_MUSIC || ritem.header.guidTimeFormat == GUID_TIME_REFERENCE))
    {
        Trace(1, "Error: Unable to load parameter control track: guidTimeFormat in chunk 'proh' must be either GUID_TIME_MUSIC or GUID_TIME_REFERENCE.\n");
        return DMUS_E_INVALID_PARAMCONTROLTRACK;
    }

    // for each <prpl>
    while (ri && ri.Find(SmartRef::RiffIter::List, DMUS_FOURCC_PARAMCONTROLTRACK_PARAM_LIST))
    {
        hr = this->LoadParam(ri.Descend(), ritem.listParams);
        if (FAILED(hr))
            return hr;
        ++ri;
    }
    hr = ri.hr();

    if (SUCCEEDED(hr))
    {
        m_listObjects.AddHead(spItem.disown());
        ++m_cObjects;
    }
    return hr;
}

HRESULT CParamControlTrack::LoadParam(SmartRef::RiffIter ri, TList<ParamInfo> &listParams)
{
    if (!ri)
        return ri.hr();

    HRESULT hr = S_OK;

    SmartRef::Ptr<TListItem<ParamInfo> > spItem = new TListItem<ParamInfo>;
    if (!spItem)
        return E_OUTOFMEMORY;
    ParamInfo &ritem = spItem->GetItemValue();

    // find <prph>
    hr = ri.FindRequired(SmartRef::RiffIter::Chunk, DMUS_FOURCC_PARAMCONTROLTRACK_PARAM_CHUNK, DMUS_E_INVALID_PARAMCONTROLTRACK);
    if (FAILED(hr))
    {
#ifdef DBG
        if (hr == DMUS_E_INVALID_PARAMCONTROLTRACK)
        {
            Trace(1, "Error: Unable to load parameter control track: Chunk 'prph' not found.\n");
        }
#endif
        return hr;
    }

    hr = SmartRef::RiffIterReadChunk(ri, &ritem.header);
    if (FAILED(hr))
        return hr;

    // find <prcc>
    if (!ri.Find(SmartRef::RiffIter::Chunk, DMUS_FOURCC_PARAMCONTROLTRACK_CURVES_CHUNK))
    {
        // It is OK if we read to the end without finding the chunk--we succeed without finding any curves.
        // Or it could be a failure because there was a problem reading from the stream.
        // The RiffIter's hr method reflects this.
        return ri.hr();
    }

    // read the array of control curves
    int cRecords;
    hr = SmartRef::RiffIterReadArrayChunk(ri, &ritem.curves, &cRecords);
    if (FAILED(hr))
        return hr;
    ritem.curvesEnd = ritem.curves + cRecords;

    listParams.AddHead(spItem.disown());
    ++m_cParams;
    return hr;
}

HRESULT CParamControlTrack::TrackToObjectTime(
        MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
        IDirectMusicPerformance* pPerf,
        bool fTrkClockTime,
        bool fObjClockTime,
        MUSIC_TIME mt,
        REFERENCE_TIME *rt)
{
    HRESULT hr = S_OK;

    // set the time (reference time variable is used to hold either music or reference time in different contexts)
    REFERENCE_TIME rtEnv = mt;

    // add the correct offset and if necessary convert from millisecond time 
    rtEnv = fTrkClockTime
                ? rtEnv * gc_RefPerMil + rtOffset
                : rtEnv = rtEnv + mtOffset;

    if (fTrkClockTime != fObjClockTime)
    {
        // need to convert between out track's time format and the audio object's time format
        if (fObjClockTime)
        {
            MUSIC_TIME mtEnv = static_cast<MUSIC_TIME>(rtEnv);
            hr = pPerf->MusicToReferenceTime(mtEnv, &rtEnv);
            if (FAILED(hr))
                return hr;
        }
        else
        {
            MUSIC_TIME mtEnv = 0;
            hr = pPerf->ReferenceToMusicTime(rtEnv, &mtEnv);
            rtEnv = mtEnv;
            if (FAILED(hr))
                return hr;
        }
    }

    *rt = rtEnv;
    return hr;
}

HRESULT
CParamControlTrack::PlayEnvelope(
    IMediaParams *pIMediaParams,
    MP_ENVELOPE_SEGMENT *pEnv,
    DMUS_IO_PARAMCONTROLTRACK_CURVEINFO *pPt,
    const ObjectInfo &obj,
    const ParamInfo &param,
    ParamState &paramstate,
    MUSIC_TIME mtOffset,
    REFERENCE_TIME rtOffset,
    IDirectMusicPerformance* pPerf,
    bool fTrkClockTime,
    bool fObjClockTime)
{
    HRESULT hr = S_OK;

    // set the curve type and flags
    pEnv->iCurve = static_cast<MP_CURVE_TYPE>(pPt->dwCurveType);
    pEnv->flags = pPt->dwFlags;

    pEnv->valEnd = pPt->fltEndValue;
    pEnv->valStart = pPt->fltStartValue;

    // set the time (used to hold either music or reference time in different contexts)

    REFERENCE_TIME &rtEnvStart = pEnv->rtStart;
    hr = this->TrackToObjectTime(mtOffset, rtOffset, pPerf, fTrkClockTime, fObjClockTime, pPt->mtStartTime, &rtEnvStart);
    if (FAILED(hr))
        return hr;

    REFERENCE_TIME &rtEnvEnd = pEnv->rtEnd;
    hr = this->TrackToObjectTime(mtOffset, rtOffset, pPerf, fTrkClockTime, fObjClockTime, pPt->mtEndTime, &rtEnvEnd);
    if (FAILED(hr))
        return hr;

    hr = pIMediaParams->AddEnvelope(param.header.dwIndex, 1, pEnv);
    if (SUCCEEDED(hr))
    {
        paramstate.rtStartPointOfLastCurve = rtEnvStart;
        TListItem<REFERENCE_TIME>* pStartTime = new TListItem<REFERENCE_TIME>;
        if (pStartTime)
        {
            pStartTime->GetItemValue() = rtEnvStart;
            // Adding to the head maintains a largest-to-smallest ordering.
            paramstate.listStartTimes.AddHead(pStartTime);
        }
        paramstate.fLast = true;
    }

    return hr;
}

HRESULT
CParamControlTrack::PlayTruncatedEnvelope(
    MUSIC_TIME mtTruncStart,
    IMediaParams *pIMediaParams,
    MP_ENVELOPE_SEGMENT *pEnv,
    DMUS_IO_PARAMCONTROLTRACK_CURVEINFO *pPt,
    const ObjectInfo &obj,
    const ParamInfo &param,
    ParamState &paramstate,
    MUSIC_TIME mtOffset,
    REFERENCE_TIME rtOffset,
    IDirectMusicPerformance* pPerf,
    bool fTrkClockTime,
    bool fObjClockTime,
    DWORD dwFlags)
{
    // Copy info from the curve
    DMUS_IO_PARAMCONTROLTRACK_CURVEINFO curveinfo = *pPt;
    // Cut the start to the designated time
    curveinfo.mtStartTime = mtTruncStart;
    bool fSkip = false;

    if (mtTruncStart >= curveinfo.mtEndTime)
    {
        // Curve happened in the past.  Send a jump curve right at the current (truncate) time picking up with
        // that value.
        // if we're looping and we passed the end of this curve, just skip it.
        if ( (dwFlags & DMUS_TRACKF_LOOP) )
        {
            fSkip = true;
        }
        else
        {
            curveinfo.mtEndTime = mtTruncStart;
            curveinfo.dwCurveType = MP_CURVE_JUMP;
        }
    }
    else if (pPt->dwCurveType != MP_CURVE_JUMP)
    {
        // Find the point at that time and pick up with a linear curve from there.
        // (For the nonlinear curves, there's no way to pick them up part-way along.)
        curveinfo.dwCurveType = MP_CURVE_LINEAR;

        MUSIC_TIME mtTimeChange = pPt->mtEndTime - pPt->mtStartTime;
        MUSIC_TIME mtTimeIntermediate = mtTruncStart - pPt->mtStartTime;

        float fltScalingX = static_cast<float>(mtTimeIntermediate) / mtTimeChange; // horizontal distance along curve between 0 and 1
        float fltScalingY; // height of curve at that point between 0 and 1 based on curve function
        switch (pPt->dwCurveType)
        {
        case MP_CURVE_SQUARE:
            fltScalingY = fltScalingX * fltScalingX;
            break;
        case MP_CURVE_INVSQUARE:
            fltScalingY = (float) sqrt(fltScalingX);
            break;
        case MP_CURVE_SINE:
            //  Maybe we should have a lookup table here?
            fltScalingY = (float) (sin(fltScalingX * 3.1415926535 - (3.1415926535/2)) + 1) / 2;
            break;
        case MP_CURVE_LINEAR:
        default:
            fltScalingY = fltScalingX;
        }

        // Apply that scaling to the range of the actual points
        curveinfo.fltStartValue = (pPt->fltEndValue - pPt->fltStartValue) * fltScalingY + pPt->fltStartValue;
    }

    if (fSkip) return S_OK;

    return this->PlayEnvelope(pIMediaParams, pEnv, &curveinfo, obj, param, paramstate, mtOffset, rtOffset, pPerf, fTrkClockTime, fObjClockTime);
}

HRESULT CParamControlTrack::InitStateData(StateData *pStateData,
                                          IDirectMusicSegmentState *pSegmentState)
{
    if (pStateData->prgpIMediaParams)
    {
        delete [] pStateData->prgpIMediaParams;
        pStateData->prgpIMediaParams = NULL;
    }
    if (pStateData->prgParam)
    {
        delete [] pStateData->prgParam;
        pStateData->prgParam = NULL;
    }

    pStateData->prgpIMediaParams = new IMediaParams *[m_cObjects];
    if (!pStateData->prgpIMediaParams)
    {
        return E_OUTOFMEMORY;
    }
    pStateData->prgParam = new ParamState[m_cParams];
    if (!pStateData->prgParam)
    {
        delete [] pStateData->prgpIMediaParams;
        return E_OUTOFMEMORY;
    }

    // Get the IMediaParams interface for each object
    SmartRef::ComPtr<IDirectMusicSegmentState8> scomSegSt8;
    HRESULT hr = pSegmentState->QueryInterface(IID_IDirectMusicSegmentState8, reinterpret_cast<void**>(&scomSegSt8));
    if (FAILED(hr))
    {      
        delete [] pStateData->prgParam;
        delete [] pStateData->prgpIMediaParams;
        return hr;
    }

    int iObject = 0;
    for (TListItem<ObjectInfo> *pObject = m_listObjects.GetHead();
            pObject;
            pObject = pObject->GetNext(), ++iObject)
    {
        IMediaParams *pIMediaParams = NULL;
        ObjectInfo &rinfo = pObject->GetItemValue();
        HRESULT hrObject = scomSegSt8->GetObjectInPath(
                                rinfo.header.dwPChannel,
                                rinfo.header.dwStage,
                                rinfo.header.dwBuffer,
                                rinfo.header.guidObject,
                                rinfo.header.dwIndex,
                                IID_IMediaParams,
                                reinterpret_cast<void**>(&pIMediaParams));
        if (FAILED(hrObject))
        {
            // Can't fail from InitPlay (and this is called from there).
            // Just print trace information.
            TraceI(1, "Parameter control track was unable to find audio path object, HRESULT 0x%08x.\n", hrObject);
        }
        else
        {
            hrObject = pIMediaParams->SetTimeFormat(rinfo.header.guidTimeFormat, rinfo.header.guidTimeFormat == GUID_TIME_MUSIC ? 768 : 0);
        }
        if (FAILED(hrObject))
        {
            // Can't fail from InitPlay (and this is called from there).
            // Just print trace information.
            Trace(1, "Unable to set time format of object in parameter control track, HRESULT 0x%08x.\n", hrObject);
        }
        if (FAILED(hrObject))
        {
            SafeRelease(pIMediaParams);
        }
        pStateData->prgpIMediaParams[iObject] = pIMediaParams;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\queue.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// queue.cpp

#include "pchime.h"
/*
#include "debug.h"
#define ASSERT	assert
#include "dmime.h"
#include "dmperf.h"*/

CPMsgQueue::CPMsgQueue()

{
    m_pTop = NULL;
    m_pLastAccessed = NULL;
#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
    m_lCount = 0;
#endif
}

CPMsgQueue::~CPMsgQueue()

{
#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
    assert(m_lCount == 0);
#endif
}

static PRIV_PMSG * sortevents( PRIV_PMSG * pEvents, long lLen )

{
    PRIV_PMSG * pLeft;
    PRIV_PMSG * pRight ;
    long        lLeft;
    long        lRight ;
    PRIV_PMSG * pTop ;

    if( lLen < 3 )
    {
        if( !pEvents )
            return( 0 ) ;
        if( lLen == 1 )
            return( pEvents ) ;
        pLeft  = pEvents ;
        pRight = pEvents->pNext ;
        if( !pRight )
            return( pLeft ) ;
        if( pLeft->rtTime > pRight->rtTime )
        {
            pLeft->pNext = NULL ;
            pRight->pNext = pLeft ;
            return( pRight ) ;
        }
        return( pLeft ) ;
    }

    lLeft = lLen >> 1 ;
    lRight = lLen - lLeft;
    pLeft = pEvents ;
    for (;lLeft > 1;pEvents = pEvents->pNext) lLeft--;
    pRight = sortevents( pEvents->pNext, lRight ) ;
    pEvents->pNext = NULL ;
    pLeft = sortevents( pLeft, lLen - lRight ) ;
    pTop = NULL ;

    for( ;  pLeft && pRight ;  )
    {
        if( pLeft->rtTime < pRight->rtTime )
        {
            if( !pTop )
                pTop = pLeft ;
            else
                pEvents->pNext = pLeft ;
            pEvents = pLeft ;
            pLeft   = pEvents->pNext ;
        }
        else
        {
            if( !pTop )
                pTop = pRight ;
            else
                pEvents->pNext = pRight ;
            pEvents = pRight ;
            pRight  = pEvents->pNext ;
        }
    }

    if( pLeft )
        pEvents->pNext = pLeft ;
    else
        pEvents->pNext = pRight ;

    return( pTop ) ;

}   

void CPMsgQueue::Sort() 

{
    m_pTop = sortevents(m_pTop, GetCount()) ;
    m_pLastAccessed = NULL;
}  

long CPMsgQueue::GetCount()

{
    long lCount = 0;
    PRIV_PMSG *pScan = GetHead();
    for (;pScan;pScan = pScan->pNext)
    {
        lCount++;
    }
#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
    assert(m_lCount == lCount);
#endif
    return lCount;
}

void CPMsgQueue::Enqueue(PRIV_PMSG *pItem)

{
    if (!pItem)
    {
        TraceI(0, "ENQUEUE: Attempt to enqueue a NULL pItem!\n");
        return;
    }
    // Ensure not already queued...
    if (pItem->dwPrivFlags & PRIV_FLAG_QUEUED)
    {
        TraceI(0,"ENQUEUE: Item thinks it is still in a queue!\n");
        return;
    }
	pItem->dwPrivFlags |= PRIV_FLAG_QUEUED;
    PRIV_PMSG *pScan; 
#ifdef DBG
    // Verify robustness of list. Check that the event is not already in the list
    // and that the time stamps are all in order.
    REFERENCE_TIME rtTime = 0;
    for (pScan = m_pTop;pScan;pScan = pScan->pNext)
    {
        if (pScan == pItem)
        {
            TraceI(0,"ENQUEUE: Item is already in the queue!\n"); 
            return;
        }
    	// this must queue events in time sorted order
        if (pScan->rtTime < rtTime)
        {
            TraceI(0,"ENQUEUE: Queue is not in time order!\n");
            pScan->rtTime = rtTime;
        }
        else if (pScan->rtTime > rtTime)
        {
            rtTime = pScan->rtTime;
        }
    }
#endif
    if ( !(pItem->dwFlags & DMUS_PMSGF_REFTIME) ) // sorting on reftime, so this must be valid 
    {
        TraceI(0, "ENQUEUE: Attempt to enqueue a pItem with a bogus RefTime!\n");
        return;
    }
    if (m_pLastAccessed && (m_pLastAccessed->rtTime <= pItem->rtTime))
    {
        pScan = m_pLastAccessed;
    }
    else
    {
        pScan = m_pTop;
    }
    if ( pScan && ( pScan->rtTime <= pItem->rtTime ) )
	{
		for (; pScan->pNext; pScan = pScan->pNext )
		{
			if( pScan->pNext->rtTime > pItem->rtTime )
			{
				break;
			}
		}
		pItem->pNext = pScan->pNext;
		pScan->pNext = pItem;
    }
	else 
	{
		pItem->pNext = m_pTop;
		m_pTop = pItem;
	}
    m_pLastAccessed = pItem;
#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
    m_lCount++;
#endif
}

/*  Remove the oldest event before time rtTime, making sure that there is still
    at minimum one event prior to that time stamp. 
    This ensures that there is a sufficiently old event, but gets rid of old
    stale events. This is used by the timesig and tempomap lists.
*/

PRIV_PMSG *CPMsgQueue::FlushOldest(REFERENCE_TIME rtTime)

{
    PRIV_PMSG *pNext;
    if (m_pTop && (pNext = m_pTop->pNext))
    {
        if (pNext->rtTime < rtTime)
        {
            PRIV_PMSG *pDelete = m_pTop;
            if (m_pLastAccessed == m_pTop)
            {
                m_pLastAccessed = pNext;
            }
            m_pTop = pNext;
			pDelete->dwPrivFlags &= ~PRIV_FLAG_QUEUED;
			pDelete->pNext = NULL;
#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
            m_lCount--;
#endif
            return pDelete;
        }
    }
    return NULL;
}

PRIV_PMSG *CPMsgQueue::Dequeue()

{
    PRIV_PMSG *pItem = m_pTop;

    if (pItem != NULL)
	{
        m_pTop = pItem->pNext;
		pItem->dwPrivFlags &= ~PRIV_FLAG_QUEUED;
        pItem->pNext = NULL;
        if (m_pLastAccessed == pItem)
        {
            m_pLastAccessed = m_pTop;
        }
#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
        m_lCount--;
#endif
    }

    return pItem;
}

PRIV_PMSG *CPMsgQueue::Dequeue(PRIV_PMSG *pItem)

{
    ASSERT(pItem);

    if (pItem == m_pTop)
    {
        return Dequeue();
    }
    PRIV_PMSG *pScan;
    PRIV_PMSG *pNext;
    if (m_pLastAccessed && 
        (m_pLastAccessed->rtTime < pItem->rtTime))
    {
        pScan = m_pLastAccessed;
    }
    else
    {
        pScan = m_pTop;
    }
    for (;pScan;pScan = pNext)
    {
        pNext = pScan->pNext;
        if (pNext == pItem)
        {
            pScan->pNext = pItem->pNext;
            pItem->pNext = NULL;
            pItem->dwPrivFlags &= ~PRIV_FLAG_QUEUED;
            if (m_pLastAccessed == pItem)
            {
                m_pLastAccessed = pScan;
            }
#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
            m_lCount--;
#endif
            return pItem;
        }
    }
    if (m_pLastAccessed)
    {
        // This happens every now and then as a result of a curve setting rtTime to 0
        // in the middle of FlushEventQueue. 
        // This should be fixed, but this patch will work for now.
        m_pLastAccessed = NULL;
        return Dequeue(pItem);
    }
    return NULL;
}

// queue Segment nodes in time order. pItem must be in the same
// time base as all items in ppList (RefTime or Music Time.)

void CSegStateList::Insert(CSegState* pItem)

{
    CSegState *pScan = GetHead();
    CSegState *pNext;
    pItem->SetNext(NULL);
    if (pScan)
	{
		if( pItem->m_dwPlaySegFlags & DMUS_SEGF_REFTIME )
		{
			ASSERT( pScan->m_dwPlaySegFlags & DMUS_SEGF_REFTIME );
			// Avoid putting circularities in the list
			if (pItem == pScan)
			{
				TraceI(0, "ENQUEUE (SEGMENT RT): NODE IS ALREADY IN AT THE HEAD OF LIST\n");
			}
			else if( pItem->m_rtGivenStart < pScan->m_rtGivenStart )
			{
                AddHead(pItem);
			}
			else
			{
				while( pNext = pScan->GetNext() )
				{
					ASSERT( pScan->m_dwPlaySegFlags & DMUS_SEGF_REFTIME );
					// Am I trying to insert something that's already in the list?
					if (pItem == pScan)
					{
						break;
					}
					// Check for the queue getting corrupted (happens on multiproc machines at 400mhz)
					if ( ( pNext->m_dwPlaySegFlags & DMUS_SEGF_REFTIME ) && 
						 pScan->m_rtGivenStart > pNext->m_rtGivenStart )
					{
						TraceI(0, "ENQUEUE (SEGMENT RT): LOOP CONDITION VIOLATED\n");
						// get rid of the potential circularity in the list.  Note that this
						// (or actually the creation of the circularity) could cause memory leaks.
						pScan->SetNext(NULL);
						break;
					}
					if( pItem->m_rtGivenStart < pNext->m_rtGivenStart )
					{
						break;
					}
					pScan = pNext;
				}
				if (pItem != pScan)
				{
					pItem->SetNext(pScan->GetNext());
					pScan->SetNext(pItem);
				}
				else
				{
					TraceI(0, "ENQUEUE (SEGMENT RT): NODE IS ALREADY IN LIST\n");
				}
			}
		}
		else
		{
			ASSERT( !( pScan->m_dwPlaySegFlags & DMUS_SEGF_REFTIME ) );
			// Avoid putting circularities in the list
			if (pItem == pScan)
			{
				TraceI(0, "ENQUEUE (SEGMENT MT): NODE IS ALREADY IN AT THE HEAD OF LIST\n");
			}
			else if( pItem->m_mtResolvedStart < pScan->m_mtResolvedStart )
			{
				AddHead(pItem);
			}
			else
			{
				while( pNext = pScan->GetNext() )
				{
					ASSERT( !( pScan->m_dwPlaySegFlags & DMUS_SEGF_REFTIME ) );
					// Am I trying to insert something that's already in the list?
					if (pItem == pScan)
					{
						break;
					}
					// Check for the queue getting corrupted (happens on multiproc machines at 400mhz)
					if ( !( pNext->m_dwPlaySegFlags & DMUS_SEGF_REFTIME ) && 
						 pScan->m_mtResolvedStart > pNext->m_mtResolvedStart )
					{
						TraceI(0, "ENQUEUE (SEGMENT MT): LOOP CONDITION VIOLATED\n");
						// get rid of the potential circularity in the list.  Note that this
						// (or actually the creation of the circularity) could cause memory leaks.
						pScan->SetNext(NULL);
						break;
					}
					if( pItem->m_mtResolvedStart < pNext->m_mtResolvedStart )
					{
						break;
					}
					pScan = pNext;
				}
                if (pItem != pScan)
				{
					pItem->SetNext(pScan->GetNext());
					pScan->SetNext(pItem);
				}
				else
				{
					TraceI(0, "ENQUEUE (SEGMENT MT): NODE IS ALREADY IN LIST\n");
				}
			}
		}
    }
	else
	{
		m_pHead = pItem;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\template.h ===
// Copyright (c) 1998 Microsoft Corporation
// templates.h

#ifndef __TEMPLATES_H__
#define __TEMPLATES_H__


#ifdef XBOX
#include <xtl.h>
#else // XBOX
#include <windows.h>
#endif // XBOX


template< class T > T* List_Cat( T* p1, T* p2 )
{
    T* pScan;

    if( p1 == NULL )
    {
        return p2;
    }
    for( pScan = p1 ; pScan->pNext != NULL ; pScan = (T*)pScan->pNext );
    pScan->pNext = p2;
    return p1;
}

template< class T > DWORD List_Len( T* p )
{
    DWORD dw;

    for( dw = 0 ; p != NULL ; p = (T*)p->pNext )
    {
         ++dw;
    }

    return dw;
}

template< class T > BOOL inlist( T* lst, T* p )
{
    if( p == NULL )
    {
        return TRUE;
    }

    for( ; lst != NULL ; lst = (T*)lst->pNext )
    {
        if( p == lst )
        {
            return TRUE;
        }
    }

    return FALSE;
}

template< class T > T* List_Index( T* lst, DWORD dwIndex )
{
    T* pScan;

    for( pScan = lst ; dwIndex > 0 && pScan != NULL && pScan->pNext != NULL ; --dwIndex, pScan = (T*)pScan->pNext );

    return pScan;
}

template< class T > T* List_Insert( T* lst, T* p, DWORD dwIndex )
{
    T* pPrev;

    if( lst == NULL || dwIndex == 0 )
    {
        p->pNext = lst;
        lst = p;
    }
    else
    {
        pPrev = List_Index( lst, dwIndex - 1 );
        p->pNext = pPrev->pNext;
        pPrev->pNext = p;
    }

    return lst;
}

template< class T > T* List_Remove( T* lst, T* p )
{
    if( lst != NULL )
    {
        if( lst == p )
        {
            lst = (T*)lst->pNext;
            p->pNext = NULL;
        }
        else
        {
            T* pScan;

            for( pScan = lst ; pScan->pNext != p && pScan->pNext != NULL ; pScan = (T*)pScan->pNext );
            if( pScan->pNext != NULL )
            {
                pScan->pNext = pScan->pNext->pNext;
                p->pNext = NULL;
            }
        }
    }

    return lst;
}

template< class T > long List_Position( T* lst, T* p )
{
    long lPos;

    lPos = 0;
    while( lst != NULL && lst != p )
    {
        lst = lst->pNext;
        ++lPos;
    }
    if( lst == NULL )
    {
        return -1;
    }

    return lPos;
}

template< class T > T* List_Clone( T* lst )
{
    T* pPrev;
    T* lstClone;
    T* pCopy;

    lstClone = NULL;
    pPrev = NULL;

    for( ; lst ; lst = (T*)lst->pNext )
    {
        pCopy = new T;
        if( pCopy != NULL )
        {
            memcpy( pCopy, lst, sizeof( T ) );
            pCopy->pNext = NULL;
            if( pPrev != NULL )
            {
                pPrev->pNext = pCopy;
            }
            else
            {
                lstClone = pCopy;
            }
            pPrev = pCopy;
        }
    }

    return lstClone;
}

template< class T > void List_Free( T* lst )
{
    T* pNext;

    for( ; lst != NULL ; lst = pNext )
    {
        pNext = (T*)lst->pNext;
        delete lst;
    }
}

template< class T > T* Clone( T* p )
{
    T* pCopy;

    pCopy = new T;
    if( pCopy != NULL )
    {
        memcpy( pCopy, p, sizeof( T ) );
        pCopy->pNext = NULL;
    }

    return pCopy;
}

#endif // __TEMPLATES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\song.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// song.cpp : Implementation of CSong
#include "pchime.h"
/*
#include "dmime.h"
#include "song.h"
#include "..\shared\validp.h"
#include "..\shared\dmstrm.h"
#include "..\shared\Validate.h"
#include "debug.h"
#ifdef XBOX
#include "..\shared\xcreate.h"
#endif
*/
CTrack::CTrack() // : m_MemTrack(DMTRACK_TRACK) (removing for now...)
{
	m_pTrack = NULL;
    m_pTrack8 = NULL;
	m_pTrackState = NULL;
	m_bDone = FALSE;
    m_dwPriority = 0;
    m_dwPosition = 0;
    m_dwFlags = DMUS_TRACKCONFIG_DEFAULT;
    m_dwInternalFlags = 0;
    m_dwGroupBits = 0xFFFFFFFF;
    m_dwVirtualID = 0;
    m_guidClassID = GUID_NULL;
}

CTrack::~CTrack()
{
	assert( !( m_pTrackState && !m_pTrack ) ); // if we have state but no track, something's wrong
	if( m_pTrack )
	{
		if( m_pTrackState )
		{
			m_pTrack->EndPlay( m_pTrackState ); // allow the track to delete its state data
		}
		m_pTrack->Release();
	}
    if ( m_pTrack8 )
    {
        m_pTrack8->Release();
    }
}

HRESULT CTrackList::CreateCopyWithBlankState(CTrackList* pTrackList)
{
	if( pTrackList )
	{
		CTrack* pTrack;
		CTrack* pCopy;
		pTrackList->Clear();
		pTrack = (CTrack*)m_pHead;
		while( pTrack )
		{
			pCopy = new CTrack;
			if( pCopy )
			{
				// copy the IDirectMusicTrack pointer, but leave
				// the track state blank.
                *pCopy = *pTrack;
                pCopy->SetNext(NULL);
                pCopy->m_pTrackState = NULL;
				assert( pCopy->m_pTrack );
				pCopy->m_pTrack->AddRef();
                if (pCopy->m_pTrack8)
                {
                    pCopy->m_pTrack8->AddRef();
                }
				pTrackList->Cat( pCopy );
			}
			else
			{
				assert(FALSE); // out of memory
				return E_OUTOFMEMORY;
			}
			pTrack = pTrack->GetNext();
		}
	}
	else
	{
		assert(FALSE); // out of memory
		return E_OUTOFMEMORY;
	}
	return S_OK;
}

CVirtualSegment::CVirtualSegment()

{
    m_wszName[0] = 0;
    m_pSourceSegment = NULL;
    m_pPlaySegment = NULL;
    m_pGraph = NULL;
    m_dwFlags = 0;
    m_dwID = 0;
    m_dwNextPlayID = DMUS_SONG_NOSEG;
    m_dwNextPlayFlags = 0;
    m_mtTime = 0;
    m_dwTransitionCount = 0;
    m_pTransitions = NULL;
    m_SegHeader.rtLength = 0;
    m_SegHeader.dwFlags = 0;
    m_SegHeader.dwRepeats = 0;      /* Number of repeats. By default, 0. */
    m_SegHeader.mtLength = 0xC00;   /* Length, in music time. */
    m_SegHeader.mtPlayStart = 0;    /* Start of playback. By default, 0. */
    m_SegHeader.mtLoopStart = 0;    /* Start of looping portion. By default, 0. */
    m_SegHeader.mtLoopEnd = 0;      /* End of loop. Must be greater than dwPlayStart. By default equal to length. */
    m_SegHeader.dwResolution = 0;   /* Default resolution. */
}

CVirtualSegment::~CVirtualSegment()

{
    if (m_pSourceSegment)
    {
        m_pSourceSegment->Release();
    }
    if (m_pPlaySegment)
    {
        m_pPlaySegment->Release();
    }
    if (m_pGraph)
    {
        m_pGraph->Release();
    }
    if (m_pTransitions)
    {
        delete [] m_pTransitions;
    }
    m_TrackList.Clear();
}

CTrack * CVirtualSegment::GetTrackByParam( CTrack * pCTrack,
    REFGUID rguidType,DWORD dwGroupBits,DWORD dwIndex)
{
	// If the caller was already part way through the list, it passes the current
    // track. Otherwise, NULL to indicate start at the top.
    if (pCTrack)
    {
        pCTrack = pCTrack->GetNext();
    }
    else
    {
	    pCTrack = m_TrackList.GetHead();
    }
	while( pCTrack )
	{
		ASSERT(pCTrack->m_pTrack);
		if( (pCTrack->m_dwGroupBits & dwGroupBits ) && 
            (pCTrack->m_dwFlags & DMUS_TRACKCONFIG_CONTROL_ENABLED))
		{
			if( (GUID_NULL == rguidType) || (pCTrack->m_pTrack->IsParamSupported( rguidType ) == S_OK ))
			{
				if( 0 == dwIndex )
				{
                    return pCTrack;
				}
				dwIndex--;
			}
		}
		pCTrack = pCTrack->GetNext();
	}
    return NULL;
}

void CVirtualSegmentList::Clear()
{
    CVirtualSegment *pVirtualSegment;
    while (pVirtualSegment = RemoveHead())
    {
        delete pVirtualSegment;
    }
}

CSongSegment::CSongSegment()

{
    m_pSegment = NULL;
    m_dwLoadID = 0;
}

CSongSegment::~CSongSegment()

{
    if (m_pSegment)
    {
        m_pSegment->Release();
    }
}

HRESULT CSongSegmentList::AddSegment(CSegment *pSegment, DWORD dwLoadID)

{
    CSongSegment *pSeg = new CSongSegment;
    if (pSeg)
    {
        pSeg->m_dwLoadID = dwLoadID;
        pSeg->m_pSegment = pSegment;
        pSegment->AddRef();
        AddTail(pSeg);
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

void CSongSegmentList::Clear()
{
    CSongSegment *pSongSegment;
    while (pSongSegment = RemoveHead())
    {
        delete pSongSegment;
    }
}


CSong::CSong() : m_MemTrack(DMTRACK_SONG)
{
    INITIALIZE_CRITICAL_SECTION(&m_CriticalSection);
    m_dwStartSegID = DMUS_SONG_NOSEG;
    m_pAudioPathConfig = NULL;
    m_Info.Init();
    m_cRef = 1;
    m_dwFlags = 0;
    m_pUnkDispatch = NULL;
    IncrementDLLCount();
    m_fZombie = false;
    TraceI(2, "Song %lx created\n", this );
}

CSong::~CSong()
{
    Clear();

    if (m_pUnkDispatch)
    {
        m_pUnkDispatch->Release(); // free IDispatch implementation we may have borrowed
    }
    DELETE_CRITICAL_SECTION(&m_CriticalSection);
    DecrementDLLCount();
    TraceI(2, "Song %lx destroyed\n", this );
}


void CSong::Clear()
{
    if (m_pAudioPathConfig) 
    {
        m_pAudioPathConfig->Release();
        m_pAudioPathConfig = NULL;
    }
    m_GraphList.Clear();
    m_PlayList.Clear();
    m_SegmentList.Clear();
    m_VirtualSegmentList.Clear();
    m_dwStartSegID = DMUS_SONG_NOSEG;
    m_dwFlags = 0;
    m_Info.Init();
}

STDMETHODIMP_(void) CSong::Zombie()
{
	Clear();
	m_fZombie = true;
}

STDMETHODIMP CSong::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
    V_INAME(CSong::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    *ppv = NULL;
    if (iid == IID_IUnknown || iid == IID_IDirectMusicSong)
    {
        *ppv = static_cast<IDirectMusicSong*>(this);
    }
    else if (iid == IID_CSong)
    {
        *ppv = static_cast<CSong*>(this);
    }
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else if(iid == IID_IDirectMusicObject)
    {
        *ppv = static_cast<IDirectMusicObject*>(this);
    }
	else if (iid == IID_IDirectMusicObjectP)
	{
		*ppv = static_cast<IDirectMusicObjectP*>(this);
	}
	else if(iid == IID_IDispatch)
	{
		// A helper scripting object implements IDispatch, which we expose via COM aggregation.
		if (!m_pUnkDispatch)
		{
			// Create the helper object
			DirectMusicCreateInstance(
				CLSID_AutDirectMusicSong,
				static_cast<IDirectMusicSong*>(this),
				IID_IUnknown,
				reinterpret_cast<void**>(&m_pUnkDispatch));
		}
		if (m_pUnkDispatch)
		{
			return m_pUnkDispatch->QueryInterface(IID_IDispatch, ppv);
		}
	}

	if (*ppv == NULL)
    {
        Trace(4,"Warning: Request to query unknown interface on Song object\n");
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CSong::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CSong::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
		m_cRef = 100; // artificial reference count to prevent reentrency due to COM aggregation
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CSong::Compose( )
{
	CHECK_ZOMBIE(m_fZombie);

    HRESULT hr = S_OK;
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    // Go through the seg ref list and create master composition tracks for each composing track.
    TList<ComposingTrack> MasterTrackList;
    CVirtualSegment* pVirtualSegment = m_VirtualSegmentList.GetHead();
    for (; pVirtualSegment; pVirtualSegment = pVirtualSegment->GetNext())
    {
        if (!pVirtualSegment->m_pPlaySegment)
        {
            Trace(1,"Error: Corrupt song, one or more virtual segments do not resolve to real segments. Unable to compose.\n");
            hr = E_POINTER;
            break;
        }
        CSegment *pSegment = pVirtualSegment->m_pPlaySegment;
        CTrack* pTrack = pSegment->m_TrackList.GetHead();
        for (; pTrack; pTrack = pTrack->GetNext())
        {
            if (pTrack->m_dwFlags & DMUS_TRACKCONFIG_COMPOSING)
            {
                DWORD dwTrackGroup = pTrack->m_dwGroupBits;
                // filter out any group bits already covered by other master tracks of same type
                TListItem<ComposingTrack>* pMaster = MasterTrackList.GetHead();
                for (; pMaster; pMaster = pMaster->GetNext())
                {
                    ComposingTrack& rMaster = pMaster->GetItemValue();
                    if (rMaster.GetTrackID() == pTrack->m_guidClassID)
                    {
                        DWORD dwMaster = rMaster.GetTrackGroup();
                        if (dwMaster == dwTrackGroup)
                        {
                            // Exact match: put the track here.
                            hr = rMaster.AddTrack(pVirtualSegment, pTrack);
                            dwTrackGroup = 0;
                            break;
                        }
                        DWORD dwIntersection = dwMaster & dwTrackGroup;
                        if (dwIntersection)
                        {
                            dwTrackGroup |= ~dwIntersection;
                        }
                    }
                }
                // If we've still got any group bits left, add a new composing track
                if (dwTrackGroup)
                {
                    TListItem<ComposingTrack>* pTrackItem = new TListItem<ComposingTrack>;
                    if (!pTrackItem)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    else
                    {
                        ComposingTrack& rTrack = pTrackItem->GetItemValue();
                        rTrack.SetTrackGroup(dwTrackGroup);
                        rTrack.SetTrackID(pTrack->m_guidClassID);
                        rTrack.SetPriority(pTrack->m_dwPriority);
                        // add tracks in priority order (higher priority first)
                        TListItem<ComposingTrack>* pMaster = MasterTrackList.GetHead();
                        TListItem<ComposingTrack>* pPrevious = NULL;
                        for (; pMaster; pMaster = pMaster->GetNext())
                        {
                            ComposingTrack& rMaster = pMaster->GetItemValue();
                            if (pTrack->m_dwPriority > rMaster.GetPriority()) break;
                            pPrevious = pMaster;
                        }
                        if (!pPrevious) // this has higher priority than anything in the list
                        {
                            MasterTrackList.AddHead(pTrackItem);
                        }
                        else // lower priority than pPrevious, higher than pMaster
                        {
                            pTrackItem->SetNext(pMaster);
                            pPrevious->SetNext(pTrackItem);
                        }
                        hr = pTrackItem->GetItemValue().AddTrack(pVirtualSegment, pTrack);
                    }
                }
            }
            if (FAILED(hr)) break;
        }
        if (FAILED(hr)) break;
    }
    // Call compose on each master composition track
    if (SUCCEEDED(hr))
    {
        TListItem<ComposingTrack>* pMaster = MasterTrackList.GetHead();
        if (pMaster)
        {
            for (; pMaster; pMaster = pMaster->GetNext())
            {
                hr = pMaster->GetItemValue().Compose(this);
            }
        }
        else hr = S_FALSE;
    }
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CSong::Download(IUnknown *pAudioPath)

{
    V_INAME(IDirectMusicSong::Download);
    V_INTERFACE(pAudioPath);

	CHECK_ZOMBIE(m_fZombie);

    DWORD dwSuccess = 0;
    HRESULT hr = S_OK;
    HRESULT hrFail = S_OK;
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    CSegment *pSegment = m_PlayList.GetHead();
    for (;pSegment;pSegment = pSegment->GetNext())
    {
        if (SUCCEEDED(hr = pSegment->Download(pAudioPath)))
        {
            // count partial successes, so that S_FALSE will be returned if we have, e.g.,
            // one partial success followed by one failure
            dwSuccess++;
        }
        if (hr != S_OK) 
        {
            // keep track of partial successes so that they always percolate up
            hrFail = hr;
        }
    }
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    if (hrFail != S_OK && dwSuccess)
    {
        Trace(1,"Warning: Only %ld of the total %ld segments successfully downloaded.\n",
            dwSuccess,m_PlayList.GetCount());
        hr = S_FALSE;
    }
    return hr;
}

STDMETHODIMP CSong::Unload(IUnknown *pAudioPath)

{
    V_INAME(IDirectMusicSong::Unload);
    V_INTERFACE(pAudioPath);

	CHECK_ZOMBIE(m_fZombie);

    DWORD dwSuccess = 0;
    HRESULT hr = S_OK;
    HRESULT hrFail = S_OK;
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    CSegment *pSegment = m_PlayList.GetHead();
    for (;pSegment;pSegment = pSegment->GetNext())
    {
        if (SUCCEEDED(hr = pSegment->Unload(pAudioPath)))
        {
            dwSuccess++;
        }
        else
        {
            hrFail = hr;
        }
    }
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    if (FAILED(hrFail) && dwSuccess)
    {
        Trace(1,"Warning: Only %ld of the total %ld segments successfully unloaded.\n",
            dwSuccess,m_PlayList.GetCount());
        hr = S_FALSE;
    }
    return hr;
}

STDMETHODIMP CSong::GetParam( REFGUID rguidType, 
                        DWORD dwGroupBits, 
                        DWORD dwIndex, 
                        MUSIC_TIME mtTime, 
                        MUSIC_TIME* pmtNext, 
                        void* pParam) 
{
    V_INAME(IDirectMusiCSong::GetParam);
    V_REFGUID(rguidType);
    V_PTR_WRITE_OPT(pmtNext,MUSIC_TIME);

	CHECK_ZOMBIE(m_fZombie);

    HRESULT hr = DMUS_E_TRACK_NOT_FOUND;
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    /*CSegment *pSegment = m_PlayList.GetHead();
    for (;pSegment;pSegment = pSegment->GetNext())
    {
        if (pSegment->m_mtStart <= mtTime && 
            mtTime < pSegment->m_mtStart + pSegment->m_mtLength)
        {
            hr = pSegment->GetParam(rguidType, dwGroupBits, dwIndex, mtTime - pSegment->m_mtStart, pmtNext, pParam);
            if (SUCCEEDED(hr)) break;
        }
    }*/
    CVirtualSegment *pVirtualSegment = m_VirtualSegmentList.GetHead();
    for (;pVirtualSegment;pVirtualSegment = pVirtualSegment->GetNext())
    {
        if (pVirtualSegment->m_mtTime <= mtTime &&
            pVirtualSegment->m_pPlaySegment &&
            mtTime < pVirtualSegment->m_mtTime + pVirtualSegment->m_pPlaySegment->m_mtLength)
        {
            hr = pVirtualSegment->m_pPlaySegment->GetParam(rguidType, dwGroupBits, dwIndex, mtTime - pVirtualSegment->m_mtTime, pmtNext, pParam);
            if (SUCCEEDED(hr)) break;
        }
    }
/*    for (;pVirtualSegment;pVirtualSegment = pVirtualSegment->GetNext())
    {
        if (pVirtualSegment->m_mtTime <= mtTime)
        {
            CTrack* pCTrack;
            pCTrack = pVirtualSegment->GetTrackByParam(NULL, rguidType,dwGroupBits, dwIndex);
            while (pCTrack)
            {
                if (pCTrack->m_pTrack8)
                {
                    REFERENCE_TIME rtNext, *prtNext;
                    // We need to store the next time in a 64 bit pointer. But, don't
                    // make 'em fill it in unless the caller requested it. 
                    if (pmtNext)
                    {
                        prtNext = &rtNext;
                    }
                    else
                    {
                        prtNext = NULL;
                    }
                    hr = pCTrack->m_pTrack8->GetParamEx( rguidType, mtTime - pVirtualSegment->m_mtTime, prtNext, pParam,
                        NULL, 0 );
                    if (pmtNext)
                    {
                        *pmtNext = (MUSIC_TIME) rtNext;
                    }
                }
                else
                {
                    hr = pCTrack->m_pTrack->GetParam( rguidType, mtTime - pVirtualSegment->m_mtTime, pmtNext, pParam );
/ *                 if( pmtNext && (( *pmtNext == 0 ) || (*pmtNext > (m_mtLength - mtTime))))
                    {
                        *pmtNext = m_mtLength - mtTime;
                    }* /
                }
                // If nothing was found and dwIndex was DMUS_SEG_ANYTRACK, try again...
                if (fMultipleTry && (hr == DMUS_E_NOT_FOUND))
                {
                    pCTrack = pVirtualSegment->GetTrackByParam(pCTrack, rguidType,dwGroupBits, dwIndex);
                }
                else
                {
                    pCTrack = NULL;
                }
            }
        }
    }*/
    if (FAILED(hr) && pmtNext)
    {
        // return the time of the first segment after mtTime (or 0 if there is no such segment)
        pVirtualSegment = m_VirtualSegmentList.GetHead();
        for (;pVirtualSegment;pVirtualSegment = pVirtualSegment->GetNext())
        {
            if (pVirtualSegment->m_mtTime > mtTime)
            {
                *pmtNext = pVirtualSegment->m_mtTime;
                break;
            }
        }
    }
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    return hr;
}

HRESULT CSong::Instantiate() 
{
    V_INAME(IDirectMusicSong::Instantiate);
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    CVirtualSegment *pRef = m_VirtualSegmentList.GetHead();
    m_PlayList.Clear();
    for (;pRef;pRef = pRef->GetNext())
    {
        // the constructor below does an AddRef.
        CSegment *pSegment = new CSegment(&pRef->m_SegHeader,pRef->m_pSourceSegment);
        if (pSegment)
        {
            if (pRef->m_wszName[0])
            {
                wcscpy(pSegment->m_Info.m_wszName,pRef->m_wszName);
                pSegment->m_Info.m_dwValidData |= DMUS_OBJ_NAME;
            }
            CTrack *pTrack;
            for (pTrack = pRef->m_TrackList.GetHead();pTrack;pTrack = pTrack->GetNext())
            {
                CTrack *pCopy = new CTrack;
                if( pCopy )
                {
                    *pCopy = *pTrack;
                    pCopy->SetNext(NULL);
                    pCopy->m_pTrackState = NULL;
                    pCopy->m_pTrack->AddRef();
                    if (pCopy->m_pTrack8)
                    {
                        pCopy->m_pTrack8->AddRef();
                    }
                    // The tracks were in backwards order. This puts them back in order, and ahead of the segment tracks.
                    pSegment->m_TrackList.AddHead( pCopy );
                }
            }
            pSegment->m_pSong = this;
            pSegment->m_dwPlayID = pRef->m_dwID;
//Trace(0,"Intantiating PlaySegment %ls with ID %ld.\n",pRef->m_wszName,pRef->m_dwID);
            pSegment->m_dwNextPlayFlags = pRef->m_dwNextPlayFlags;
            pSegment->m_dwNextPlayID = pRef->m_dwNextPlayID;
            m_PlayList.AddTail(pSegment);
            if (pRef->m_pPlaySegment) pRef->m_pPlaySegment->Release();
            pRef->m_pPlaySegment = pSegment;
            pRef->m_pPlaySegment->AddRef();
        }
    }
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    return S_OK;
}

HRESULT CSong::EnumSegment( DWORD dwIndex,IDirectMusicSegment **ppSegment) 
{
    V_INAME(IDirectMusicSong::EnumSegment);
    V_PTRPTR_WRITE (ppSegment);

	CHECK_ZOMBIE(m_fZombie);

    HRESULT hr = S_FALSE;
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    CSegment *pSegment = m_PlayList.GetHead();
    for (;pSegment && dwIndex;pSegment = pSegment->GetNext()) dwIndex--;
    if (pSegment)
    {
        *ppSegment = static_cast<IDirectMusicSegment*>(pSegment);
        pSegment->AddRef();
        hr = S_OK;
    }    
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    return hr;
}

HRESULT CSong::GetPlaySegment( DWORD dwIndex,CSegment **ppSegment) 
{
    HRESULT hr = S_FALSE;
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    CSegment *pSegment = m_PlayList.GetHead();
    for (;pSegment;pSegment = pSegment->GetNext())
    {
        if (pSegment->m_dwPlayID == dwIndex)
        {
            *ppSegment = pSegment;
            pSegment->AddRef();
            hr = S_OK;
            break;
        }
    }
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CSong::GetSegment(const WCHAR *wszName, IDirectMusicSegment **ppSegment)

{
    V_INAME(IDirectMusicSong::GetSegment);
    V_PTRPTR_WRITE(ppSegment);

	CHECK_ZOMBIE(m_fZombie);

    HRESULT hr = S_FALSE;
    CSegment *pSegment;
    if (wszName)
    {
        V_BUFPTR_READ(wszName,2);
        ENTER_CRITICAL_SECTION(&m_CriticalSection);
        pSegment = m_PlayList.GetHead();
        for (;pSegment;pSegment = pSegment->GetNext())
        {
            if (_wcsicmp(pSegment->m_Info.m_wszName, wszName) == 0)
            {
                pSegment->AddRef();
                hr = S_OK;
                break;
            }
        }
        LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    }
    else
    {
        hr = GetPlaySegment( m_dwStartSegID,&pSegment);
    }
    if (hr == S_OK)
    {
        *ppSegment = static_cast<IDirectMusicSegment*>(pSegment);
    }
    else
    {
#ifdef DBG
        if (wszName)
        {
            Trace(1,"Error: Unable to find segment %ls in song.\n",wszName);
        }
        else
        {
            Trace(1,"Error: Unable to find starting segment in the song.\n");
        }
#endif
    }
    return hr;
}

STDMETHODIMP CSong::GetAudioPathConfig(IUnknown ** ppAudioPathConfig)

{
    V_INAME(IDirectMusicSegment::GetAudioPathConfig);
    V_PTRPTR_WRITE(ppAudioPathConfig);
#ifdef DXAPI
	CHECK_ZOMBIE(m_fZombie);
#endif

    HRESULT hr;
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    if (m_pAudioPathConfig)
    {
        hr = m_pAudioPathConfig->QueryInterface(IID_IUnknown,(void **)ppAudioPathConfig);
    }
    else
    {
        Trace(2,"Warning: No embedded audiopath configuration in the song.\n");         
        hr = DMUS_E_NO_AUDIOPATH_CONFIG;
    }
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CSong::GetClassID( CLSID* pClassID )
{
    V_INAME(CSong::GetClassID);
    V_PTR_WRITE(pClassID, CLSID); 
#ifdef DXAPI
	CHECK_ZOMBIE(m_fZombie);
#endif

    *pClassID = CLSID_DirectMusicSong;
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPersistStream functions

HRESULT CSong::IsDirty()
{
    return E_NOTIMPL;
}

HRESULT CSong::Load( IStream* pIStream )
{
    V_INAME(CSong::Load);
    V_INTERFACE(pIStream);

    // Song format temporarily turned off for DX8 release.
#ifdef DXAPI
    return E_NOTIMPL;
#else
	CHECK_ZOMBIE(m_fZombie);

    // Create RIFF parser. 
    CRiffParser Parser(pIStream);

    RIFFIO ckMain;
    HRESULT hr = S_OK;
    // First, clear the song in case it is being read into a second time.
    Clear();

    Parser.EnterList(&ckMain);  
    if (Parser.NextChunk(&hr))
    {
        if (ckMain.fccType == DMUS_FOURCC_SONG_FORM)
        {
            ENTER_CRITICAL_SECTION(&m_CriticalSection);
            RIFFIO ckNext;
            IDirectMusicContainer *pContainer = NULL; // For handling embedded container with linked objects.
            Parser.EnterList(&ckNext);
            while(Parser.NextChunk(&hr))
            {
                switch(ckNext.ckid)
                {
                    case DMUS_FOURCC_SONG_CHUNK:
                        DMUS_IO_SONG_HEADER ioSongHdr;
                        ioSongHdr.dwFlags = 0;
                        hr = Parser.Read(&ioSongHdr, sizeof(DMUS_IO_SONG_HEADER));
                        if(SUCCEEDED(hr))
                        {
                            m_dwFlags = ioSongHdr.dwFlags;
                            m_dwStartSegID = ioSongHdr.dwStartSegID;
                        }
                        break;
			        case DMUS_FOURCC_GUID_CHUNK:
			        case DMUS_FOURCC_VERSION_CHUNK:
			        case DMUS_FOURCC_CATEGORY_CHUNK:
			        case DMUS_FOURCC_DATE_CHUNK:
                        hr = m_Info.ReadChunk(&Parser,ckNext.ckid);
                        break;
                    case FOURCC_LIST:
                    case FOURCC_RIFF:
                        switch(ckNext.fccType)
                        {
                        case DMUS_FOURCC_UNFO_LIST:
                                hr = m_Info.ReadChunk(&Parser,ckNext.fccType);
                                break;
                        case DMUS_FOURCC_CONTAINER_FORM:
                            // An embedded container RIFF chunk which includes a bunch
                            // of objects referenced by the song. This should precede the
                            // segments and gets loaded prior to them. Loading this
                            // causes all of its objects to get SetObject'd in the loader,
                            // so they later get pulled in as requested by the tracks in the segments.
                            // After the tracks are loaded, the loader references are
                            // released by a call to release the IDirectMusicContainer.
                            {
                                DMUS_OBJECTDESC Desc;
                                IDirectMusicLoader *pLoader;
                                IDirectMusicGetLoader *pGetLoader;
                                HRESULT hr = pIStream->QueryInterface(IID_IDirectMusicGetLoader,(void **) &pGetLoader);
                                if (SUCCEEDED(hr))
                                {
                                    if (SUCCEEDED(pGetLoader->GetLoader(&pLoader)))
                                    {
                                        // Move back stream's current position
                                        Parser.SeekBack();
                                        Desc.dwSize = sizeof(Desc);
                                        Desc.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_STREAM;
                                        Desc.guidClass = CLSID_DirectMusicContainer;
                                        Desc.pStream = pIStream;
                                        pLoader->GetObject(&Desc,IID_IDirectMusicContainer,(void **) &pContainer);
                                        if (pContainer)
                                        {
                                            // Don't cache the container object! We want it and the
                                            // objects it references to go away when the segment is done loading.
                                            IDirectMusicObject *pObject = NULL;
                                            pContainer->QueryInterface(IID_IDirectMusicObject,(void **)&pObject);
                                            if (pObject)
                                            {
                                                pLoader->ReleaseObject(pObject);
                                                pObject->Release();
                                            }
                                        }
                                        // Now, seek to the end of this chunk.
                                        Parser.SeekForward();
                                        pLoader->Release();
                                    }
                                    pGetLoader->Release();
                                }
                            }
                            break;
                        case DMUS_FOURCC_SONGSEGMENTS_LIST:
                            hr = LoadSegmentList(&Parser); //pIStream, pIDirectMusicStream, ckNext);
                            break;
                        case DMUS_FOURCC_SEGREFS_LIST:
                            hr = LoadVirtualSegmentList(&Parser);
                            break;
                        case DMUS_FOURCC_AUDIOPATH_FORM:
                            // Move back to start of this chunk.
                            Parser.SeekBack();
                            hr = LoadAudioPath(pIStream);
                            // Now, seek to the end of this chunk.
                            Parser.SeekForward();
                            break;
                        default:
                            break;
                        }
                        break;

                    default:
                        break;

                }
            }
            Parser.LeaveList();
            LEAVE_CRITICAL_SECTION(&m_CriticalSection);

            if (pContainer)
            {
                pContainer->Release();
            }
        }
        else
        {
            // Couldn't find the chunk header for a song. 
            // But, maybe this is actually a segment, in which case see if
            // the segment object will load it.
            CSegment *pSegment = new CSegment;
            if (pSegment)
            {
                pSegment->AddRef(); // Segment::Load (and possibly others) may need the refcount
                // Force the version so audiopath functionality will be supported.
                pSegment->m_dwVersion = 8;
                Parser.SeekBack();
                hr = pSegment->Load(pIStream);
                if (SUCCEEDED(hr))
                {
                    DMUS_OBJECTDESC Desc;
                    Desc.dwSize = sizeof (Desc);
                    pSegment->GetDescriptor(&Desc);
                    Desc.guidClass = CLSID_DirectMusicSong;
                    SetDescriptor(&Desc);
                    // AddSegment addref's by one.
                    m_SegmentList.AddSegment(pSegment,0);
                    pSegment->GetAudioPathConfig((IUnknown **) &m_pAudioPathConfig);
                    m_dwStartSegID = 0; // Points to this segment.
                    CVirtualSegment *pVirtual = new CVirtualSegment;
                    if (pVirtual)
                    {
                        pVirtual->m_pSourceSegment = pSegment;
                        pSegment->AddRef();
                        pVirtual->m_SegHeader.dwRepeats = pSegment->m_dwRepeats;
                        pVirtual->m_SegHeader.dwResolution = pSegment->m_dwResolution;
                        pVirtual->m_SegHeader.mtLength = pSegment->m_mtLength;
                        pVirtual->m_SegHeader.mtLoopEnd = pSegment->m_mtLoopEnd;
                        pVirtual->m_SegHeader.mtLoopStart = pSegment->m_mtLoopStart;
                        pVirtual->m_SegHeader.mtPlayStart = pSegment->m_mtStart;
                        pVirtual->m_SegHeader.rtLength = pSegment->m_rtLength;
                        pVirtual->m_SegHeader.dwFlags = pSegment->m_dwSegFlags;
                        if (pSegment->m_Info.m_dwValidData & DMUS_OBJ_NAME)
                        {
                            wcscpy(pVirtual->m_wszName,pSegment->m_Info.m_wszName);
                        }
                        m_VirtualSegmentList.AddHead(pVirtual);
                    }                
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    pSegment->Release(); // release the initial AddRef
                }
                if (FAILED(hr))
                {
                    delete pSegment;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    // If there are no virtual segments, clear the song and fail the load
    if ( !m_VirtualSegmentList.GetHead() )
    {
        Clear();
        hr = DMUS_E_NOT_INIT;
    }
    if (SUCCEEDED(hr)) Instantiate();
    return hr;
#endif
}

HRESULT CSong::LoadAudioPath(IStream *pStream)
{
    assert(pStream);

    CAudioPathConfig *pPath = new CAudioPathConfig;
    if (pPath == NULL) {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pPath->Load(pStream);

    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    if(m_pAudioPathConfig)
    {
        m_pAudioPathConfig->Release();
    }
    m_pAudioPathConfig = pPath;
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
    
    return hr;
}

/*HRESULT CSong::LoadReferencedSegment(CSegment **ppSegment, CRiffParser *pParser)
{

    IDirectMusicLoader* pLoader = NULL;
    IDirectMusicGetLoader *pIGetLoader;
    HRESULT hr = pParser->GetStream()->QueryInterface( IID_IDirectMusicGetLoader,(void **) &pIGetLoader );
    if (FAILED(hr)) return hr;
    hr = pIGetLoader->GetLoader(&pLoader);
    pIGetLoader->Release();
    if (FAILED(hr)) return hr;

    DMUS_OBJECTDESC desc;
    ZeroMemory(&desc, sizeof(desc));

    RIFFIO ckNext;
        
    pParser->EnterList(&ckNext);
    while(pParser->NextChunk(&hr))
    {
        switch(ckNext.ckid)
        {
            case  DMUS_FOURCC_REF_CHUNK:
                DMUS_IO_REFERENCE ioDMRef;
                hr = pParser->Read(&ioDMRef, sizeof(DMUS_IO_REFERENCE));
                if(SUCCEEDED(hr))
                {
                    if (ioDMRef.guidClassID != CLSID_DirectMusicSegment)
                    {
                        Trace(1,"Error: Invalid segment reference in song.\n");
                        hr = DMUS_E_CANNOTREAD;
                    }
                    else
                    {
                        desc.guidClass = ioDMRef.guidClassID;
                        desc.dwValidData |= ioDMRef.dwValidData;
                        desc.dwValidData |= DMUS_OBJ_CLASS;
                    }
                }
                break;

            case DMUS_FOURCC_GUID_CHUNK:
                hr = pParser->Read(&(desc.guidObject), sizeof(GUID));
                if(SUCCEEDED(hr))
                {
                    desc.dwValidData |=  DMUS_OBJ_OBJECT;
                }
                break;

            case DMUS_FOURCC_NAME_CHUNK:
                hr = pParser->Read(desc.wszName, sizeof(desc.wszName));
                if(SUCCEEDED(hr))
                {
                    desc.dwValidData |=  DMUS_OBJ_NAME;
                }
                break;
            
            case DMUS_FOURCC_FILE_CHUNK:
                hr = pParser->Read(desc.wszFileName, sizeof(desc.wszFileName));
                if(SUCCEEDED(hr))
                {
                    desc.dwValidData |=  DMUS_OBJ_FILENAME;
                }
                break;

            case DMUS_FOURCC_CATEGORY_CHUNK:
                hr = pParser->Read(desc.wszCategory, sizeof(desc.wszCategory));
                if(SUCCEEDED(hr))
                {
                    desc.dwValidData |=  DMUS_OBJ_CATEGORY;
                }
                break;

            default:
                break;
        }
    }
    pParser->LeaveList();

    if(SUCCEEDED(hr))
    {
        desc.dwSize = sizeof(DMUS_OBJECTDESC);
        hr = pLoader->GetObject(&desc, IID_CSegment, (void**)ppSegment);
        // Once we get the object, we need to ensure that the same object is never
        // connected up to any other songs (or this one, too.)
        // So, we ensure that the loader doesn't keep it around.
        if (SUCCEEDED(hr))
        {
            IDirectMusicObject *pObject;
            if (SUCCEEDED((*ppSegment)->QueryInterface(IID_IDirectMusicObject,(void **)&pObject)))
            {
#ifdef DXAPI
                pLoader->ReleaseObject(pObject);
#else
                pLoader->ReleaseObjectByUnknown(pObject);
#endif
                pObject->Release();
            }
            // If the segment has a next pointer, it still must be in another song. This
            // should never happen, but being paranoid...
            if ((*ppSegment)->GetNext())
            {
                *ppSegment = NULL;
                hr = E_FAIL;
                TraceI(0,"Error: Attempt to load song segment that is already referenced by another song. \n");
            }
        }
    }

    if (pLoader)
    {
        pLoader->Release();
    }
    return hr;
}*/

HRESULT CSong::LoadSegmentList(CRiffParser *pParser)

{
    assert(pParser);

    RIFFIO ckNext, ckChild;
    DWORD dwSegmentCount = 0;

    HRESULT hr = S_OK;
    pParser->EnterList(&ckNext);
    while(pParser->NextChunk(&hr))
    {   
        switch(ckNext.ckid)
        {
        case FOURCC_LIST:
            if (ckNext.fccType == DMUS_FOURCC_SONGSEGMENT_LIST)
            {
                pParser->EnterList(&ckChild);
                while (pParser->NextChunk(&hr))
                {
                    switch(ckChild.ckid)
                    {
                    case FOURCC_RIFF:
                    case FOURCC_LIST:
                        if ((ckChild.fccType == DMUS_FOURCC_SEGMENT_FORM) || 
                            (ckChild.fccType == DMUS_FOURCC_REF_LIST))
                        {
                            CSegment *pSegment = NULL;
                            if (ckChild.fccType == DMUS_FOURCC_SEGMENT_FORM)
                            {
                                pSegment = new CSegment;
                                if (pSegment)
                                {
                                    pSegment->AddRef(); // Segment::Load may need a refcount
                                    // Force the version so audiopath functionality will be supported.
                                    pSegment->m_dwVersion = 8;
                                    // Move back to start of this chunk.
                                    pParser->SeekBack();
                                    hr = pSegment->Load(pParser->GetStream());
                                    pParser->SeekForward();
                                }
                                else
                                {
                                    return E_OUTOFMEMORY;
                                }
                            }
                            else
                            {
                                // This will increment the refcount for the segment
                                CLinkParser LinkParser;
                                hr = LinkParser.LoadReferencedObject(pParser,(void **)&pSegment,IID_CSegment,TRUE);
//                                hr = LoadReferencedSegment( &pSegment, pParser );
                            }
                            if (SUCCEEDED(hr))
                            {
                                // This increments the refcount.
                                m_SegmentList.AddSegment(pSegment,dwSegmentCount);
                            }
                            pSegment->Release(); // Release the extra AddRef
                            dwSegmentCount++;
                        }
                        break;
                    }
                }
                pParser->LeaveList();
            }

        default:
            break;

        }
    }
    pParser->LeaveList();

    return hr;
}

HRESULT CSong::LoadGraphList(CRiffParser *pParser)

{

    RIFFIO ckNext;
    DWORD dwGraphCount = 0;

    HRESULT hr = S_OK;
    pParser->EnterList(&ckNext);
    while(pParser->NextChunk(&hr))
    {   
        switch(ckNext.ckid)
        {
            case FOURCC_RIFF:
                switch(ckNext.fccType)
                {
                    CGraph *pGraph;
                    case DMUS_FOURCC_TOOLGRAPH_FORM :
                        // Move back to start of this chunk.
                        pParser->SeekBack();
                        pGraph = new CGraph;
                        if (pGraph)
                        {
                            hr = pGraph->Load(pParser->GetStream());
                            dwGraphCount++;
                            if (SUCCEEDED(hr))
                            {
                                m_GraphList.AddTail(pGraph);
                                pGraph->m_dwLoadID = dwGraphCount;
                            }
                        }
                        else
                        {
                            return E_OUTOFMEMORY;
                        }
                        pParser->SeekForward();
                        break;          
                    default:
                        break;
                }
                break;

            default:
                break;

        }
    }
    pParser->LeaveList();
    return hr;
}

HRESULT CSong::GetTransitionSegment(CSegment *pSource, CSegment *pDestination,
                                  DMUS_IO_TRANSITION_DEF *pTransDef)

{
    HRESULT hr = DMUS_E_NOT_FOUND;
//    if (pSource) Trace(0,"Transitioning from %ls ",pSource->m_wszName);
//    if (pDestination) Trace(0,"to %ls",pDestination->m_wszName);
//    Trace(0,"\n");
    ENTER_CRITICAL_SECTION(&m_CriticalSection);
    // Default values for other fields, in case we don't find a match.
    pTransDef->dwPlayFlags = 0;
    pTransDef->dwTransitionID = DMUS_SONG_NOSEG;
    pTransDef->dwSegmentID = DMUS_SONG_NOSEG;
    CVirtualSegment *pVSource = NULL;
    // If there is a source segment, look to see if it's in this song
    // and pull the matchin virtual segment.
    if (pSource)
    {
        pVSource = m_VirtualSegmentList.GetHead();
        for (;pVSource;pVSource = pVSource->GetNext())
        {
            if (pVSource->m_pPlaySegment == pSource) 
            {
//                Trace(0,"Found match for source segment %ls in song\n",pSource->m_wszName);
                break;
            }
        }
    }
    CVirtualSegment *pVDestination = NULL;
    // If there is a destination segment, look to see if it's in this song
    // and pull the matching virtual segment.
    if (pDestination)
    {
        pVDestination = m_VirtualSegmentList.GetHead();
        for (;pVDestination;pVDestination = pVDestination->GetNext())
        {
            if (pVDestination->m_pPlaySegment == pDestination) 
            {
//                Trace(0,"Found match for destination segment %ls in song\n",pDestination->m_wszName);
                break;
            }
        }
    }

    if (pVSource)
    {
        if (pVDestination)
        {
            pTransDef->dwSegmentID = pVDestination->m_dwID;
        }
        else
        {
            // If there is no destination, mark this to transition to nothing.
            pTransDef->dwSegmentID = DMUS_SONG_NOSEG;
        }
        if (pVSource->m_dwTransitionCount)
        {
            ASSERT(pVSource->m_pTransitions);
            DWORD dwIndex;
            DWORD dwMatchCount = 0;
            // First, find out how many transitions match the requirement. 
            // We'll randomly select from the matching ones.
            for (dwIndex = 0; dwIndex < pVSource->m_dwTransitionCount; dwIndex++)
            {
                if (pVSource->m_pTransitions[dwIndex].dwSegmentID == pTransDef->dwSegmentID)
                {
                    dwMatchCount++;
                }
            }
            DWORD dwChoice;
            if (dwMatchCount)
            {
                dwChoice = dm_rand() % dwMatchCount;
            }
            for (dwIndex = 0; dwIndex < pVSource->m_dwTransitionCount; dwIndex++)
            {
                if (pVSource->m_pTransitions[dwIndex].dwSegmentID == pTransDef->dwSegmentID)
                {
                    if (!dwChoice)
                    {
//Trace(0,"Chose transition from %lx with Transition %lx, flags %lx\n",pVSource->m_pTransitions[dwIndex].dwSegmentID,
//    pVSource->m_pTransitions[dwIndex].dwTransitionID,pVSource->m_pTransitions[dwIndex].dwPlayFlags);
                        pTransDef->dwPlayFlags = pVSource->m_pTransitions[dwIndex].dwPlayFlags;
                        pTransDef->dwTransitionID = pVSource->m_pTransitions[dwIndex].dwTransitionID;
                        hr = S_OK;
                        break;
                    }
                    dwChoice--;
                }
                else if ((pVSource->m_pTransitions[dwIndex].dwSegmentID == DMUS_SONG_ANYSEG) && !dwMatchCount)
                {
                    // Mark the segment and flags, but don't break because we might still have the matched segment in the list.
                    pTransDef->dwPlayFlags = pVSource->m_pTransitions[dwIndex].dwPlayFlags;
                    pTransDef->dwTransitionID = pVSource->m_pTransitions[dwIndex].dwTransitionID;
//Trace(0,"Found default transition from %lx with Transition %lx, flags %lx\n",pVSource->m_pTransitions[dwIndex].dwSegmentID,
//    pVSource->m_pTransitions[dwIndex].dwTransitionID,pVSource->m_pTransitions[dwIndex].dwPlayFlags);
                    hr = S_OK;
                    break;
                }
            }
        }
    }
    else if (pVDestination)
    {
        // This is the special case where there is no source segment, perhaps because we are starting
        // playback or we are starting from a different song. In this case, look for a transition in the destination
        // segment for the special case of DMUS_SONG_NOFROMSEG. Typically, this represents a transition
        // segment that is an intro.
        if (pVDestination->m_dwTransitionCount)
        {
            ASSERT(pVDestination->m_pTransitions);
            DWORD dwIndex;
            DWORD dwMatchCount = 0;
            // First, find out how many transitions match the requirement. 
            // We'll randomly select from the matching ones.
            for (dwIndex = 0; dwIndex < pVDestination->m_dwTransitionCount; dwIndex++)
            {
                if (pVDestination->m_pTransitions[dwIndex].dwSegmentID == DMUS_SONG_NOFROMSEG)
                {
                    dwMatchCount++;
                }
            }
            DWORD dwChoice;
            if (dwMatchCount)
            {
                dwChoice = dm_rand() % dwMatchCount;
            }
            for (dwIndex = 0; dwIndex < pVDestination->m_dwTransitionCount; dwIndex++)
            {
                if (pVDestination->m_pTransitions[dwIndex].dwSegmentID == DMUS_SONG_NOFROMSEG)
                {
                    if (!dwChoice)
                    {
//Trace(0,"Chose transition from NONE with Transition %lx, flags %lx\n",
//    pVDestination->m_pTransitions[dwIndex].dwTransitionID,pVDestination->m_pTransitions[dwIndex].dwPlayFlags);
                        pTransDef->dwPlayFlags = pVDestination->m_pTransitions[dwIndex].dwPlayFlags;
                        pTransDef->dwTransitionID = pVDestination->m_pTransitions[dwIndex].dwTransitionID;
                        hr = S_OK;
                        break;
                    }
                    dwChoice--;
                }
            }
        }
    }
    LEAVE_CRITICAL_SECTION(&m_CriticalSection);
#ifdef DBG
    if (hr == DMUS_E_NOT_FOUND)
    {
        Trace(2,"Warning: No transition segment was found in song.\n");
    }
#endif
    return hr;
}


void CSong::GetSourceSegment(CSegment **ppSegment,DWORD dwSegmentID)

{
    CSongSegment *pSongSegment = m_SegmentList.GetHead();
    while (pSongSegment)
    {
        if (pSongSegment->m_dwLoadID == dwSegmentID)
        {
            if (pSongSegment->m_pSegment)
            {
                pSongSegment->m_pSegment->AddRef();
                *ppSegment = pSongSegment->m_pSegment;
                return;
            }
        }
        pSongSegment = pSongSegment->GetNext();
    }
}

void CSong::GetGraph(CGraph **ppGraph,DWORD dwGraphID)

{
    CGraph *pGraph = m_GraphList.GetHead();
    while (pGraph)
    {
        if (pGraph->m_dwLoadID == dwGraphID)
        {
            pGraph->AddRef();
            *ppGraph = pGraph;
            return;
        }
        pGraph = pGraph->GetNext();
    }
}

BOOL CSong::GetSegmentTrack(IDirectMusicTrack **ppTrack,DWORD dwSegmentID,DWORD dwGroupBits,DWORD dwIndex,REFGUID guidClassID)

{
    CSongSegment *pSongSegment = m_SegmentList.GetHead();
    while (pSongSegment)
    {
        if (pSongSegment->m_dwLoadID == dwSegmentID)
        {
            if (pSongSegment->m_pSegment)
            {
                return (pSongSegment->m_pSegment->GetTrack(guidClassID,dwGroupBits,dwIndex,ppTrack) == S_OK);
            }
        }
        pSongSegment = pSongSegment->GetNext();
    }
    return FALSE;
}


HRESULT CSong::LoadVirtualSegmentList(CRiffParser *pParser)

{
    RIFFIO ckNext;
    RIFFIO ckChild;
    RIFFIO ckUNFO;
    DWORD dwSegmentCount = 0;
    CVirtualSegment *pVirtualSegment;
    MUSIC_TIME mtTime = 0;

    HRESULT hr = S_OK;
    pParser->EnterList(&ckNext);
    while(pParser->NextChunk(&hr))
    {   
        switch(ckNext.ckid)
        {
            case FOURCC_RIFF:
            case FOURCC_LIST:
                switch(ckNext.fccType)
                {
                    case DMUS_FOURCC_SEGREF_LIST:
                        pVirtualSegment = new CVirtualSegment;
                        if (pVirtualSegment)
                        {
                            BOOL fGotHeader = FALSE;
                            BOOL fGotSegmentHeader = FALSE;
                            pVirtualSegment->m_mtTime = mtTime; // Give the start time, an accumulation of all preceding segments. 
                            pParser->EnterList(&ckChild);
                            while(pParser->NextChunk(&hr))
                            {
                                switch( ckChild.ckid )
                                {
                                    case FOURCC_RIFF:
                                    case FOURCC_LIST:
                                        switch(ckChild.fccType)
                                        {
                                        case DMUS_FOURCC_TRACKREFS_LIST:
                                            hr = LoadTrackRefList(pParser, pVirtualSegment);
                                            break;
                                        case DMUS_FOURCC_UNFO_LIST:
                                            pParser->EnterList(&ckUNFO);
                                            while(pParser->NextChunk(&hr))
                                            {
                                                switch( ckUNFO.ckid )
                                                {
                                                    case DMUS_FOURCC_UNAM_CHUNK:
                                                    {
                                                        hr = pParser->Read(pVirtualSegment->m_wszName, sizeof(pVirtualSegment->m_wszName));
                                                        break;
                                                    }
                                                    default:
                                                        break;
                                                }
                                            }
                                            pParser->LeaveList();
                                        }
                                        break;
                                    case DMUS_FOURCC_SEGREF_CHUNK:
                                    {
                                        DMUS_IO_SEGREF_HEADER ioVirtualSegment;
                                        hr = pParser->Read(&ioVirtualSegment,sizeof(ioVirtualSegment));
                                        if(SUCCEEDED(hr) )
                                        {
                                            pVirtualSegment->m_dwFlags = ioVirtualSegment.dwFlags;
                                            pVirtualSegment->m_dwID = ioVirtualSegment.dwID;
                                            pVirtualSegment->m_dwNextPlayID = ioVirtualSegment.dwNextPlayID;
                                            if (ioVirtualSegment.dwSegmentID != DMUS_SONG_NOSEG)
                                            {
                                                GetSourceSegment(&pVirtualSegment->m_pSourceSegment,ioVirtualSegment.dwSegmentID);
                                            }
                                            if (ioVirtualSegment.dwToolGraphID != DMUS_SONG_NOSEG)
                                            {
                                                GetGraph(&pVirtualSegment->m_pGraph,ioVirtualSegment.dwToolGraphID);
                                            }
                                            fGotHeader = TRUE;
                                        }
                                        break;
                                    }
                                    case DMUS_FOURCC_SEGTRANS_CHUNK:
                                        {
                                            DWORD dwTransCount;
                                            dwTransCount = ckChild.cksize / sizeof(DMUS_IO_TRANSITION_DEF);
                                            if (dwTransCount > 0)
                                            {
                                                pVirtualSegment->m_pTransitions = new DMUS_IO_TRANSITION_DEF[dwTransCount];
                                                if (pVirtualSegment->m_pTransitions)
                                                {
                                                    pVirtualSegment->m_dwTransitionCount = dwTransCount;
                                                    hr = pParser->Read(pVirtualSegment->m_pTransitions,sizeof(DMUS_IO_TRANSITION_DEF)*dwTransCount);
                                                }
                                                else
                                                {
                                                    return E_OUTOFMEMORY;
                                                }                                                        
                                            }
                                        }
                                        break;
                                    case DMUS_FOURCC_SEGMENT_CHUNK:
                                        fGotSegmentHeader = TRUE;
                                        hr = pParser->Read(&pVirtualSegment->m_SegHeader, sizeof(DMUS_IO_SEGMENT_HEADER));
                                        mtTime += (pVirtualSegment->m_SegHeader.dwRepeats * (pVirtualSegment->m_SegHeader.mtLoopEnd - pVirtualSegment->m_SegHeader.mtLoopStart)) + 
                                            pVirtualSegment->m_SegHeader.mtLength - pVirtualSegment->m_SegHeader.mtPlayStart;
                                    default:
                                        break;
                                }
                            }
                            pParser->LeaveList();
                            if (fGotHeader && fGotSegmentHeader)
                            {
//Trace(0,"Adding VSegment %ls with ID %ld to song.\n",pVirtualSegment->m_wszName,pVirtualSegment->m_dwID);
                                m_VirtualSegmentList.AddTail(pVirtualSegment);
                            }
                            else
                            {
                                delete pVirtualSegment;
                            }
                            break;
                        }
                        else
                        {
                            return E_OUTOFMEMORY;
                        }
                        break;
                    default:
                        break;
                }
                break;

            default:
                break;

        }
    }
    pParser->LeaveList();
    return hr;
}

struct ClassGuidCounts
{
    GUID guidClass;
    DWORD dwCount;
};

HRESULT CSong::LoadTrackRefList(CRiffParser *pParser,CVirtualSegment *pVirtualSegment)
{
    RIFFIO ckNext;
    RIFFIO ckChild;

    HRESULT hr = S_OK;
    TList<ClassGuidCounts> GuidCountList;
    pParser->EnterList(&ckNext);
    while(pParser->NextChunk(&hr))
    {
        switch(ckNext.ckid)
        {
            case FOURCC_LIST:
                switch(ckNext.fccType)
                {
                    CTrack *pTrack;
                    case DMUS_FOURCC_TRACKREF_LIST :
                        pTrack = new CTrack;
                        if (pTrack)
                        {
                            TListItem<ClassGuidCounts>* pCountItem = NULL;
                            DMUS_IO_TRACKREF_HEADER ioTrackRef;
                            DMUS_IO_TRACK_HEADER ioTrackHdr;
                            DMUS_IO_TRACK_EXTRAS_HEADER ioTrackExtrasHdr;
                            ioTrackExtrasHdr.dwPriority = 0;
                            ioTrackExtrasHdr.dwFlags = DMUS_TRACKCONFIG_DEFAULT;
                            ioTrackHdr.dwPosition = 0;
                            BOOL fGotHeader = FALSE;
                            BOOL fGotRef = FALSE;
                            pParser->EnterList(&ckChild);
                            while(pParser->NextChunk(&hr))
                            {
                                switch( ckChild.ckid )
                                {
                                    case DMUS_FOURCC_TRACKREF_CHUNK:
                                    {
                                        hr = pParser->Read(&ioTrackRef, sizeof(ioTrackRef));
                                        fGotRef = SUCCEEDED(hr);
                                        break;
                                    }
                                    case DMUS_FOURCC_TRACK_CHUNK:
                                    {
                                        hr = pParser->Read(&ioTrackHdr, sizeof(ioTrackHdr));
                                        fGotHeader = SUCCEEDED(hr);
                                        pTrack->m_guidClassID = ioTrackHdr.guidClassID;
                                        pTrack->m_dwGroupBits = ioTrackHdr.dwGroup;
                                        pTrack->m_dwPosition = ioTrackHdr.dwPosition;
                                        break;
                                    }
                                    case DMUS_FOURCC_TRACK_EXTRAS_CHUNK:
                                    {
                                        hr = pParser->Read(&ioTrackExtrasHdr, sizeof(ioTrackExtrasHdr));
                                        pTrack->m_dwPriority = ioTrackExtrasHdr.dwPriority;
                                        pTrack->m_dwFlags = ioTrackExtrasHdr.dwFlags;
                                        break;

                                    }
                                    default:
                                        break;
                                }
                            }
                            pParser->LeaveList();
                            if (fGotHeader && fGotRef)
                            {
                                if (ioTrackRef.dwSegmentID != DMUS_SONG_NOSEG)
                                {
                                    DWORD dwID = 0;
                                    for (pCountItem = GuidCountList.GetHead(); pCountItem; pCountItem = pCountItem->GetNext())
                                    {
                                        if (pCountItem->GetItemValue().guidClass == pTrack->m_guidClassID)
                                        {
                                            break;
                                        }
                                    }
                                    if (pCountItem)
                                    {
                                        dwID = pCountItem->GetItemValue().dwCount;
                                    }
                                    fGotHeader = GetSegmentTrack(&pTrack->m_pTrack,ioTrackRef.dwSegmentID,pTrack->m_dwGroupBits,dwID,pTrack->m_guidClassID);
                                }
                            }
                            if (fGotHeader && pTrack->m_pTrack)
                            {
                                pTrack->m_pTrack->QueryInterface(IID_IDirectMusicTrack8,(void **) &pTrack->m_pTrack8);
                                // Add the track based on position.
                                CTrack* pScan = pVirtualSegment->m_TrackList.GetHead();
                                CTrack* pPrevTrack = NULL;
                                for (; pScan; pScan = pScan->GetNext())
                                {
                                    if (pTrack->Less(pScan))
                                    {
                                        break;
                                    }
                                    pPrevTrack = pScan;
                                }
                                if (pPrevTrack)
                                {
                                    pPrevTrack->SetNext(pTrack);
                                    pTrack->SetNext(pScan);
                                }
                                else
                                {
                                    pVirtualSegment->m_TrackList.AddHead( pTrack );
                                }
                                if (pCountItem)
                                {
                                    pCountItem->GetItemValue().dwCount++;
                                }
                                else
                                {
                                    TListItem<ClassGuidCounts>* pNew = new TListItem<ClassGuidCounts>;
                                    if (pNew)
                                    {
                                        pNew->GetItemValue().dwCount = 1;
                                        pNew->GetItemValue().guidClass = pTrack->m_guidClassID;
                                        GuidCountList.AddHead(pNew);
                                    }
                                    else return E_OUTOFMEMORY;
                                }
                            }
                            else
                            {
                                delete pTrack;
                            }
                            break;
                        }
                        else
                        {
                            return E_OUTOFMEMORY;
                        }
                        break;
                    
                    default:
                        break;
                }
                break;

            default:
                break;

        }
    }
    pParser->LeaveList();
    return hr;
}

HRESULT CSong::Save( IStream* pIStream, BOOL fClearDirty )
{
    return E_NOTIMPL;
}

HRESULT CSong::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// IDirectMusicObject

STDMETHODIMP CSong::GetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CSong::GetDescriptor);
    V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);
#ifdef DXAPI
	CHECK_ZOMBIE(m_fZombie);
#endif
    return m_Info.GetDescriptor(pDesc,CLSID_DirectMusicSong);
}

STDMETHODIMP CSong::SetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CSong::SetDescriptor);
    V_STRUCTPTR_READ(pDesc, DMUS_OBJECTDESC);
#ifdef DXAPI
	CHECK_ZOMBIE(m_fZombie);
#endif
    return m_Info.SetDescriptor(pDesc);
}

STDMETHODIMP CSong::ParseDescriptor(LPSTREAM pIStream, LPDMUS_OBJECTDESC pDesc) 
{
    V_INAME(CSong::ParseDescriptor);
    V_INTERFACE(pIStream);
    V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);
#ifdef DXAPI
	CHECK_ZOMBIE(m_fZombie);
#endif
	// Save stream's current position. If this can't parse a song, we'll try a segment.
	LARGE_INTEGER li;
    ULARGE_INTEGER ul;
    li.HighPart = 0;
    li.LowPart = 0;
    pIStream->Seek(li, STREAM_SEEK_CUR, &ul);
	pDesc->dwValidData = 0;
    HRESULT hr = m_Info.ParseDescriptor(pIStream,pDesc,DMUS_FOURCC_SONG_FORM,CLSID_DirectMusicSong);
    if (FAILED(hr))
    {
        li.HighPart = 0;
		li.LowPart = ul.LowPart;
		pIStream->Seek(li, STREAM_SEEK_SET, NULL);
        hr = m_Info.ParseDescriptor(pIStream,pDesc,DMUS_FOURCC_SEGMENT_FORM,CLSID_DirectMusicSegment);
    }
    return hr;
}

ComposingTrack::ComposingTrack() : m_dwTrackGroup(0), m_dwPriority(0)
{
    memset((void*) &m_guidClassID, 0, sizeof(m_guidClassID));
}

ComposingTrack::~ComposingTrack()
{
    TListItem<CompositionComponent>* pComponent = m_Components.GetHead();
    for (; pComponent; pComponent = pComponent->GetNext())
    {
        CompositionComponent& rComponent = pComponent->GetItemValue();
        if (rComponent.pVirtualSegment && rComponent.pVirtualSegment->m_pPlaySegment)
        {
            rComponent.pVirtualSegment->m_pPlaySegment->Release();
        }
        if (rComponent.pComposingTrack && rComponent.pComposingTrack->m_pTrack8)
        {
            rComponent.pComposingTrack->m_pTrack8->Release();
        }
    }
}

HRESULT ComposingTrack::AddTrack(CVirtualSegment* pVirtualSegment, CTrack* pTrack)
{
    HRESULT hr = S_OK;
    if (!pVirtualSegment || !pVirtualSegment->m_pPlaySegment || !pTrack || !pTrack->m_pTrack8)
    {
        Trace(1,"Error: Unable to compose song because of a required segment or track is missing.\n");
        return E_INVALIDARG;
    }
    TListItem<CompositionComponent>* pComponent = new TListItem<CompositionComponent>;
    if (!pComponent)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        pVirtualSegment->m_pPlaySegment->AddRef();
        pTrack->m_pTrack8->AddRef();
        CompositionComponent& rComponent = pComponent->GetItemValue();
        rComponent.pVirtualSegment = pVirtualSegment;
        rComponent.pComposingTrack = pTrack;
        rComponent.mtTime = pVirtualSegment->m_mtTime;
        m_Components.AddHead(pComponent);
    }
    return hr;
}

BOOL Less(CompositionComponent& Comp1, CompositionComponent& Comp2)
{ 
    return Comp1.mtTime < Comp2.mtTime; 
}

// compose does the joining, composing, successive splitting, and adding to segments
HRESULT ComposingTrack::Compose(IDirectMusicSong* pSong)
{
    HRESULT hr = S_OK;
    IDirectMusicTrack8* pMasterTrack = NULL;
    IDirectMusicTrack8* pComposedTrack = NULL;
    m_Components.MergeSort(Less);
    // Join the tracks together according to the ordering of their associated segments.
    TListItem<CompositionComponent>* pComponent = m_Components.GetHead();
    for (; pComponent; pComponent = pComponent->GetNext())
    {
        CompositionComponent& rComponent = pComponent->GetItemValue();
        if (!pMasterTrack)
        {
            //MUSIC_TIME mtEnd = 0;
            //if (pComponent->GetNext())
            //{
            //  mtEnd = pComponent->GetNext()->GetItemValue().mtTime;
            //}
            //else
            //{
            //  rComponent.pVirtualSegment->m_pPlaySegment->GetLength(&mtEnd);
            //}
            //hr = rComponent.pComposingTrack->m_pTrack8->Clone(0, mtEnd, (IDirectMusicTrack**)&pMasterTrack);
            hr = rComponent.pComposingTrack->m_pTrack8->Clone(0, 0, (IDirectMusicTrack**)&pMasterTrack);
        }
        //else
        if (SUCCEEDED(hr))
        {
            hr = pMasterTrack->Join(rComponent.pComposingTrack->m_pTrack8, rComponent.mtTime, pSong, m_dwTrackGroup, NULL);
        }
        if (FAILED(hr)) break;
    }

    // Call Compose on the joined track.
    if (SUCCEEDED(hr))
    {
        hr = pMasterTrack->Compose(pSong, m_dwTrackGroup, (IDirectMusicTrack**)&pComposedTrack);
    }

    // Split the composed result according to the original segments.
    if (SUCCEEDED(hr))
    {
        MUSIC_TIME mtStart = 0;
        MUSIC_TIME mtEnd = 0;
        pComponent = m_Components.GetHead();
        for (; pComponent; pComponent = pComponent->GetNext())
        {
            CompositionComponent& rComponent = pComponent->GetItemValue();
            mtStart = rComponent.mtTime;
            // only split off a composed track if the original segment contained a composing track
            IDirectMusicTrack* pOldTrack = NULL;
            IPersistStream* pPersist = NULL;
            GUID guidClassId;
            memset(&guidClassId, 0, sizeof(guidClassId));
            if (SUCCEEDED(pMasterTrack->QueryInterface(IID_IPersistStream, (void**)&pPersist)) &&
                SUCCEEDED(pPersist->GetClassID(&guidClassId)) &&
                SUCCEEDED( rComponent.pVirtualSegment->m_pPlaySegment->GetTrack( guidClassId, m_dwTrackGroup, 0, &pOldTrack ) )  )
            {
                pPersist->Release();
                pOldTrack->Release();
                if (pComponent->GetNext())
                {
                    mtEnd = pComponent->GetNext()->GetItemValue().mtTime;
                }
                else
                {
                    MUSIC_TIME mtLength = 0;
                    rComponent.pVirtualSegment->m_pPlaySegment->GetLength(&mtLength);
                    mtEnd = mtStart + mtLength;
                }
                IDirectMusicTrack8* pComposedFragment = NULL;
                hr = pComposedTrack->Clone(mtStart, mtEnd, (IDirectMusicTrack**)&pComposedFragment);
                if (SUCCEEDED(hr))
                {
                    // Remove any tracks of this type (in the same group) from the segment.
                    pOldTrack = NULL;
                    pPersist = NULL;
                    memset(&guidClassId, 0, sizeof(guidClassId));
                    if (SUCCEEDED(pComposedFragment->QueryInterface(IID_IPersistStream, (void**)&pPersist)) )
                    {
                        if (SUCCEEDED(pPersist->GetClassID(&guidClassId)) &&
                            SUCCEEDED( rComponent.pVirtualSegment->m_pPlaySegment->GetTrack( guidClassId, m_dwTrackGroup, 0, &pOldTrack ) ) )
                        {
                            rComponent.pVirtualSegment->m_pPlaySegment->RemoveTrack( pOldTrack );
                            pOldTrack->Release();
                        }
                        pPersist->Release();
                    }
                    hr = rComponent.pVirtualSegment->m_pPlaySegment->InsertTrack(pComposedFragment, m_dwTrackGroup);
                    pComposedFragment->Release(); // release from the Clone
                }

                if (FAILED(hr)) break;
            }
            else // the QI to pPersist might have succeeded, so clean it up
            {
                if (pPersist) pPersist->Release();
            }
        }
        if (pComposedTrack) pComposedTrack->Release();
    }

    if (pMasterTrack) pMasterTrack->Release();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\tempotrk.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// TempoTrk.h : Declaration of the CTempoTrack

#ifndef __TEMPOTRK_H_
#define __TEMPOTRK_H_

#include "dmusicip.h"
#include "dmusicf.h"
#include "..\dmstyle\tlist.h"

struct PrivateTempo
{
    double      dblTempo;
    MUSIC_TIME  mtTime;
    MUSIC_TIME  mtDelta;
    bool        fLast;

    PrivateTempo() : dblTempo(120.), mtTime(0), mtDelta(0), fLast(false) {}
};

DEFINE_GUID(GUID_PrivateTempoParam, 0xe8dbd832, 0xbcf0, 0x4c8c, 0xa0, 0x75, 0xa3, 0xf1, 0x5e, 0x67, 0xfd, 0x63);

struct TempoStateData
{
	IDirectMusicPerformance*	pPerformance;
	IDirectMusicSegmentState*	pSegState;
	DWORD						dwVirtualTrackID;
	MUSIC_TIME					mtPrevEnd;
	TListItem<DMUS_IO_TEMPO_ITEM>*		pCurrentTempo;
	DWORD						dwValidate;
    BOOL                        fActive;

	TempoStateData()
	{
		mtPrevEnd = 0;
	}
};

/////////////////////////////////////////////////////////////////////////////
// CTempoTrack
class CTempoTrack : 
	public IPersistStream,
	public IDirectMusicTrack8
{
public:
	CTempoTrack();
	CTempoTrack(
		const CTempoTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd);
	~CTempoTrack();

// member variables
protected:
	TList<DMUS_IO_TEMPO_ITEM>	m_TempoEventList;
	long				m_cRef;
	DWORD				m_dwValidate; // used to validate state data
	CRITICAL_SECTION	m_CrSec;
    BOOL                m_fCSInitialized;
	BOOL				m_fActive; // if FALSE, disable output and param support
    BOOL                m_fStateSetBySetParam;  // If TRUE, active flag was set by GUID. Don't override. 
    CMemTrack           m_MemTrack;             // For debug memory tracking.

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

// IDirectMusicTrack methods
    STDMETHODIMP IsParamSupported(REFGUID rguid);
    STDMETHODIMP Init(IDirectMusicSegment *pSegment);
    STDMETHODIMP InitPlay(IDirectMusicSegmentState *pSegmentState,
                IDirectMusicPerformance *pPerformance,
                void **ppStateData,
                DWORD dwTrackID,
                DWORD dwFlags);
    STDMETHODIMP EndPlay(void *pStateData);
    STDMETHODIMP Play(void *pStateData,MUSIC_TIME mtStart,
                MUSIC_TIME mtEnd,MUSIC_TIME mtOffset,
		        DWORD dwFlags,IDirectMusicPerformance* pPerf,
		        IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID);
    STDMETHODIMP GetParam(REFGUID rguid,MUSIC_TIME mtTime,MUSIC_TIME* pmtNext,void *pData);
    STDMETHODIMP SetParam(REFGUID rguid,MUSIC_TIME mtTime,void *pData);
    STDMETHODIMP AddNotificationType(REFGUID rguidNotification);
    STDMETHODIMP RemoveNotificationType(REFGUID rguidNotification);
    STDMETHODIMP Clone(MUSIC_TIME mtStart,MUSIC_TIME mtEnd,IDirectMusicTrack** ppTrack);
// IDirectMusicTrack8 
    STDMETHODIMP PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf, 
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) ; 
    STDMETHODIMP GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) ; 
    STDMETHODIMP SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,void* pParam, void * pStateData, DWORD dwFlags) ;
    STDMETHODIMP Compose(IUnknown* pContext, 
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;
    STDMETHODIMP Join(IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;
// IPersist functions
    STDMETHODIMP GetClassID( CLSID* pClsId );
// IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load( IStream* pIStream );
    STDMETHODIMP Save( IStream* pIStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER FAR* pcbSize );
protected:
    HRESULT Play(
        void *pStateData,	
        MUSIC_TIME mtStart,	
        MUSIC_TIME mtEnd,
        MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
	    DWORD dwFlags,		
	    IDirectMusicPerformance* pPerf,	
	    IDirectMusicSegmentState* pSegSt,
	    DWORD dwVirtualID,
        BOOL fClockTime);
	HRESULT Seek(TempoStateData *pSD,MUSIC_TIME mtTime,BOOL fGetPrevious );
	void Construct(void);
	HRESULT JoinInternal(IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		DWORD dwTrackGroup);
};

#endif //__TEMPOTRK_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\trackhelp.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Base classes that implement aspects of a standard DirectMusic track.
// Implementations for CBasicTrack.
//

#include "pchime.h"
/*
#include "trackhelp.h"
#include "validate.h"
*/
//////////////////////////////////////////////////////////////////////
// Creation

CBasicTrack::CBasicTrack(long *plModuleLockCounter, const CLSID &rclsid)
  : m_cRef(0),
	m_plModuleLockCounter(plModuleLockCounter),
	m_rclsid(rclsid)
{
	INITIALIZE_CRITICAL_SECTION(&m_CriticalSection);
	InterlockedIncrement(plModuleLockCounter);
}

//////////////////////////////////////////////////////////////////////
// IUnknown

STDMETHODIMP 
CBasicTrack::QueryInterface(const IID &iid, void **ppv)
{
	V_INAME(CBasicTrack::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

	if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack || iid == IID_IDirectMusicTrack8)
		*ppv = static_cast<IDirectMusicTrack8*>(this);
	else if (iid == IID_IPersistStream)
		*ppv = static_cast<IPersistStream*>(this);
	else if (iid == IID_IPersist)
		*ppv = static_cast<IPersist*>(this);
	else
	{
		*ppv = NULL;
        Trace(4,"Warning: Request to query unknown interface on Track\n");
		return E_NOINTERFACE;
	}
	
	reinterpret_cast<IUnknown*>(this)->AddRef();
	return S_OK;
}

STDMETHODIMP_(ULONG)
CBasicTrack::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
CBasicTrack::Release()
{
	if (!InterlockedDecrement(&m_cRef))
	{
		DELETE_CRITICAL_SECTION(&m_CriticalSection);
		delete this;
		return 0;
	}

	return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// IUnknown

STDMETHODIMP
CBasicTrack::GetClassID(CLSID* pClassID)
{
	V_INAME(CBasicTrack::GetClassID);
	V_PTR_WRITE(pClassID, sizeof(pClassID));
	*pClassID = m_rclsid;
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack

STDMETHODIMP
CBasicTrack::Init(IDirectMusicSegment *pSegment)
{
	V_INAME(CBasicTrack::Init);
	V_INTERFACE(pSegment);
	return S_OK;
}

STDMETHODIMP
CBasicTrack::Play(
		void *pStateData,
		MUSIC_TIME mtStart,
		MUSIC_TIME mtEnd,
		MUSIC_TIME mtOffset,
		DWORD dwFlags,
		IDirectMusicPerformance* pPerf,
		IDirectMusicSegmentState* pSegSt,
		DWORD dwVirtualID)
{
	return this->PlayMusicOrClock(
					pStateData,
					mtStart,
					mtEnd,
					mtOffset,
					0,
					dwFlags,
					pPerf,
					pSegSt,
					dwVirtualID,
					false);
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack8

STDMETHODIMP CBasicTrack::PlayEx(
		void* pStateData,
		REFERENCE_TIME rtStart,
		REFERENCE_TIME rtEnd,
		REFERENCE_TIME rtOffset,
		DWORD dwFlags,
		IDirectMusicPerformance* pPerf,
		IDirectMusicSegmentState* pSegSt,
		DWORD dwVirtualID)
{
    if (dwFlags & DMUS_TRACKF_CLOCK)
    {
	    // Convert all reference times to millisecond times and then just use them as if this were MUSIC_TIME.
	    return this->PlayMusicOrClock(
					pStateData,
					static_cast<MUSIC_TIME>(rtStart / gc_RefPerMil),
					static_cast<MUSIC_TIME>(rtEnd / gc_RefPerMil),
					static_cast<MUSIC_TIME>(rtOffset / gc_RefPerMil),
					rtOffset,
					dwFlags,
					pPerf,
					pSegSt,
					dwVirtualID,
					true);
    }
    else
    {
        return this->PlayMusicOrClock(
					pStateData,
					static_cast<MUSIC_TIME>(rtStart),
					static_cast<MUSIC_TIME>(rtEnd),
					static_cast<MUSIC_TIME>(rtOffset),
					0,
					dwFlags,
					pPerf,
					pSegSt,
					dwVirtualID,
					false);
    }
}

STDMETHODIMP CBasicTrack::GetParamEx(
		REFGUID rguidType,
		REFERENCE_TIME rtTime,
		REFERENCE_TIME* prtNext,
		void* pParam,
        void * pStateData,
        DWORD dwFlags)
{
    HRESULT hr;
    MUSIC_TIME mtNext;
    if (dwFlags & DMUS_TRACK_PARAMF_CLOCK)
    {
	    hr = GetParam(rguidType, static_cast<MUSIC_TIME>(rtTime / gc_RefPerMil), &mtNext, pParam);
	    if (prtNext)
	    {
		    *prtNext = mtNext * gc_RefPerMil;
	    }
    }
    else
    {
	    hr = GetParam(rguidType, static_cast<MUSIC_TIME>(rtTime), &mtNext, pParam);
        if (prtNext)
        {
            *prtNext = mtNext;
        }
    }
    return hr;
}

STDMETHODIMP CBasicTrack::SetParamEx(
		REFGUID rguidType,
		REFERENCE_TIME rtTime,
		void* pParam, void * pStateData, DWORD dwFlags) 
{
    if (dwFlags & DMUS_TRACK_PARAMF_CLOCK)
    {
        rtTime /= gc_RefPerMil;
    }
	return SetParam(rguidType, static_cast<MUSIC_TIME>(rtTime ), pParam);
}

STDMETHODIMP CBasicTrack::Compose(
		IUnknown* pContext, 
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) 
{
	return E_NOTIMPL;
}

STDMETHODIMP CBasicTrack::Join(
		IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) 
{
	return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\trklist.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
//////////////////////////////////////////////////////////////////////
// TrkList.h

#include "alist.h"
#include "dmusicip.h"
#include "debug.h"

#ifndef __TRACKLIST_H_
#define __TRACKLIST_H_

#define TRACKINTERNAL_START_PADDED 0x1
#define TRACKINTERNAL_END_PADDED 0x2

class CSegment;

class CTrack : public AListItem
{
public:
	CTrack();
	~CTrack();
	CTrack* GetNext()
	{
		return (CTrack*)AListItem::GetNext();
	};
    bool Less(CTrack* pCTrack)
    {
        // Give the sysex track priority over any other track at the same position,
        // and the band track priority over any track but the sysex track. 
        return
            ( m_dwPosition < pCTrack->m_dwPosition ||
              (m_dwPosition == pCTrack->m_dwPosition && 
               m_guidClassID == CLSID_DirectMusicSysExTrack) ||
              (m_dwPosition == pCTrack->m_dwPosition && 
               m_guidClassID == CLSID_DirectMusicBandTrack &&
               pCTrack->m_guidClassID != CLSID_DirectMusicSysExTrack) );
    }
public:
    CLSID               m_guidClassID;  // Class ID of track.
	IDirectMusicTrack*	m_pTrack;       // Standard track interface.
    IDirectMusicTrack8* m_pTrack8;      // Extra DX8 functions.
    void*				m_pTrackState; // state pointer returned by IDirectMusicTrack::InitPerformance
	BOOL				m_bDone;
	DWORD				m_dwVirtualID; // only valid inside segment states
	DWORD				m_dwGroupBits;
    DWORD               m_dwPriority;  // Track priority, to order the composition process.
    DWORD               m_dwPosition;  // Track position, to determine the Play order.
    DWORD               m_dwFlags;     // DMUS_TRACKCONFIG_ flags. 
    DWORD               m_dwInternalFlags;     // TRACKINTERNAL_ flags. 
private:
//    CMemTrack           m_MemTrack;   // For some reason, this causes a crash, so removing for now.
};

class CTrackList : public AList
{
public:
    CTrack* GetHead() 
	{
		return (CTrack*)AList::GetHead();
	};
    CTrack* RemoveHead() 
	{
		return (CTrack*)AList::RemoveHead();
	};
    CTrack* GetItem(LONG lIndex) 
	{
		return (CTrack*) AList::GetItem(lIndex);
	};
	void Clear(void)
	{
		CTrack* pTrack;
		while( pTrack = RemoveHead() )
		{
			delete pTrack;
		}
	}
	HRESULT CreateCopyWithBlankState(CTrackList* pTrackList);
};

#endif // __TRACKLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\tsigtrk.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// TSigTrk.h : Declaration of the CTimeSigTrack

#ifndef __TSIGTRK_H_
#define __TSIGTRK_H_

#include "dmusicip.h"
#include "dmusicf.h"
#include "alist.h"

class CRiffParser;

class CTimeSigItem : public AListItem
{
public:
    CTimeSigItem();
    CTimeSigItem* GetNext(){ return (CTimeSigItem*)AListItem::GetNext(); };
    DMUS_IO_TIMESIGNATURE_ITEM  m_TimeSig;
};

   
class CTimeSigList : public AList
{
public:
    CTimeSigItem* GetHead() {return (CTimeSigItem*)AList::GetHead();};
    CTimeSigItem* RemoveHead() {return (CTimeSigItem*)AList::RemoveHead();};
    CTimeSigItem* GetItem(LONG lIndex) { return (CTimeSigItem*) AList::GetItem(lIndex);};
};

class CTimeSigStateData
{
public:
    CTimeSigStateData()
	{
		m_mtPrevEnd = 0;
		m_bBeat = 4;
		m_bBeatsPerMeasure = 4;
		m_mtTimeSig = 0;
        m_fActive = TRUE;
		/* don't need these since they are always initialized
		m_pPerformance = NULL;
		m_pSegState = NULL;
		m_dwVirtualTrackID = 0;
		*/
	}
    CTimeSigItem *	            m_pCurrentTSig;
	IDirectMusicPerformance*	m_pPerformance;
	IDirectMusicSegmentState*	m_pSegState;
	DWORD						m_dwVirtualTrackID;
	DWORD						m_dwValidate; // used to validate state data
	MUSIC_TIME					m_mtPrevEnd;
	MUSIC_TIME					m_mtTimeSig; // previous time sig time
    BOOL                        m_fActive;
    BYTE						m_bBeat; // previous beat
	BYTE						m_bBeatsPerMeasure; // previous beats per measure
};

/////////////////////////////////////////////////////////////////////////////
// CTimeSigTrack
class CTimeSigTrack : 
	public IPersistStream,
	public IDirectMusicTrack
{
public:
	CTimeSigTrack();
	CTimeSigTrack(CTimeSigTrack *pTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd);
	~CTimeSigTrack();

// member variables
protected:
	CTimeSigList	    m_TSigEventList;
	long		        m_cRef;
	DWORD		        m_dwValidate; // used to validate state data.
	CRITICAL_SECTION	m_CrSec;
    BOOL                m_fCSInitialized;
	BOOL		        m_fNotificationMeasureBeat;
	BOOL		        m_fActive;              // Track is active for generating time signatures
    BOOL                m_fStateSetBySetParam;  // If TRUE, active flag was set by GUID. Don't override. 
    CMemTrack           m_MemTrack;             // For debug memory tracking.

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

// IDirectMusicTrack methods
    STDMETHODIMP IsParamSupported(REFGUID rguid);
    STDMETHODIMP Init(IDirectMusicSegment *pSegment);
    STDMETHODIMP InitPlay(IDirectMusicSegmentState *pSegmentState,
                IDirectMusicPerformance *pPerformance,
                void **ppStateData,
                DWORD dwTrackID,
                DWORD dwFlags);
    STDMETHODIMP EndPlay(void *pStateData);
    STDMETHODIMP Play(void *pStateData,MUSIC_TIME mtStart,
                MUSIC_TIME mtEnd,MUSIC_TIME mtOffset,
		        DWORD dwFlags,IDirectMusicPerformance* pPerf,
		        IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID);
    STDMETHODIMP GetParam(REFGUID rguid,MUSIC_TIME mtTime,MUSIC_TIME* pmtNext,void *pData);
    STDMETHODIMP SetParam(REFGUID rguid,MUSIC_TIME mtTime,void *pData);
    STDMETHODIMP AddNotificationType(REFGUID rguidNotification);
    STDMETHODIMP RemoveNotificationType(REFGUID rguidNotification);
    STDMETHODIMP Clone(MUSIC_TIME mtStart,MUSIC_TIME mtEnd,IDirectMusicTrack** ppTrack);

// IPersist functions
    STDMETHODIMP GetClassID( CLSID* pClsId );
// IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load( IStream* pIStream );
    STDMETHODIMP Save( IStream* pIStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER FAR* pcbSize );
protected:
	HRESULT STDMETHODCALLTYPE Seek( void *pStateData,MUSIC_TIME mtTime,BOOL fGetPrevious);
	void Construct(void);
    void Clear();
    HRESULT LoadTimeSigList( CRiffParser *pParser, long lChunkSize );
protected:
	MUSIC_TIME NotificationMeasureBeat( MUSIC_TIME mtStart, MUSIC_TIME mtEnd,
			CTimeSigStateData* pSD, MUSIC_TIME mtOffset );
};

#endif //__TSIGTRK_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmime\smartref.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Simple helper classes that use the "resource acquisition is initialization" technique.
// In English, this means they acquire a reference to a resource and the resource is automatically
//    released in the destructor.
//

#include "pchime.h"
/*
#include "smartref.h"
using namespace SmartRef;
#include <xutility>
#include "miscutil.h"
#include "dmusicf.h"
*/
//////////////////////////////////////////////////////////////////////
// AString

AString::AString(const char *psz, UINT cch)
{
	assert(psz);
	m_psz = new char[cch + 1];
	if (m_psz)
	{
		strncpy(m_psz, psz, cch);
		m_psz[cch] = L'\0';
	}
}

AString &
AString::operator =(const char *psz)
{
	if (m_psz)
	{
		delete[] m_psz;
		m_psz = NULL;
	}

	if (psz)
	{
		m_psz = new char[strlen(psz) + 1];
		if (m_psz)
			strcpy(m_psz, psz);
	}

	return *this;
}

AString &AString::Assign(const char *psz, UINT cch)
{
	assert(psz);
	if (m_psz)
	{
		delete[] m_psz;
		m_psz = NULL;
	}

	m_psz = new char[cch + 1];
	if (m_psz)
	{
		strncpy(m_psz, psz, cch);
		m_psz[cch] = L'\0';
	}

	return *this;
}

AString &
AString::AssignFromW(const WCHAR *psz)
{
	if (m_psz)
	{
		delete[] m_psz;
		m_psz = NULL;
	}

	if (psz)
	{
		int cch = WideCharToMultiByte(CP_ACP, 0, psz, -1, NULL, 0, NULL, NULL);
		if (cch)
		{
			m_psz = new char[cch];
			if (m_psz)
			{
				cch = WideCharToMultiByte(CP_ACP, 0, psz, -1, m_psz, cch, NULL, NULL);
				if (!cch)
				{
					assert(false);
					delete[] m_psz;
					m_psz = NULL;
				}
			}
		}
	}

	return *this;
}

//////////////////////////////////////////////////////////////////////
// WString

WString &
WString::operator =(const WCHAR *psz)
{
	if (m_psz)
	{
		delete[] m_psz;
		m_psz = NULL;
	}

	if (psz)
	{
		m_psz = new WCHAR[wcslen(psz) + 1];
		if (m_psz)
			wcscpy(m_psz, psz);
	}

	return *this;
}

WString &WString::Assign(const WCHAR *psz, UINT cch)
{
	assert(psz);
	if (m_psz)
	{
		delete[] m_psz;
		m_psz = NULL;
	}

	m_psz = new WCHAR[cch + 1];
	if (m_psz)
	{
		wcsncpy(m_psz, psz, cch);
		m_psz[cch] = L'\0';
	}

	return *this;
}

WString &
WString::AssignFromA(const char *psz)
{
	if (m_psz)
	{
		delete[] m_psz;
		m_psz = NULL;
	}

	if (psz)
	{
		int cch = MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
		if (cch)
		{
			m_psz = new WCHAR[cch];
			if (m_psz)
			{
				cch = MultiByteToWideChar(CP_ACP, 0, psz, -1, m_psz, cch);
				if (!cch)
				{
					assert(false);
					delete[] m_psz;
					m_psz = NULL;
				}
			}
		}
	}

	return *this;
}

//////////////////////////////////////////////////////////////////////
// RiffIter

RiffIter::RiffIter(IStream *pStream)
  : m_hr(S_OK),
	m_pIStream(pStream),
	m_pIDMStream(NULL),
	m_fParent(false)
{
	m_pIStream->AddRef();

	ZeroMemory(&m_ckParent, sizeof(m_ckParent));
	ZeroMemory(&m_ckChild, sizeof(m_ckChild));

	m_hr = ::AllocDirectMusicStream(m_pIStream, &m_pIDMStream);
	if (FAILED(m_hr))
		return;

	m_hr = m_pIDMStream->Descend(&m_ckChild, NULL, 0);
}

RiffIter::~RiffIter()
{
	if (!m_fParent)
	{
		SafeRelease(m_pIStream);
		SafeRelease(m_pIDMStream);
	}
}

RiffIter
&RiffIter::operator ++()
{
	if (validate())
		return *this;

	m_hr = m_pIDMStream->Ascend(&m_ckChild, 0);
	if (FAILED(m_hr))
		return *this;

	m_ckChild.ckid = 0;
	m_ckChild.fccType = 0;
	m_hr = m_pIDMStream->Descend(&m_ckChild, m_fParent ? &m_ckParent : NULL, 0);
	return *this;
}

RiffIter
&RiffIter::Find(RiffType t, FOURCC idFind)
{
	if (validate())
		return *this;

	while (*this && (type() != t || id() != idFind))
		++*this;

	return *this;
}

HRESULT
RiffIter::ReadChunk(
		void *pv,
		UINT cb)
{
	if (type() != Chunk)
	{
		assert(false);
		return DMUS_E_CANNOTREAD;
	}

	ZeroMemory(pv, cb);
	DWORD cbRead = 0;
	DWORD cbSize = std::_cpp_min<DWORD>(cb, m_ckChild.cksize);
	HRESULT hr = m_pIStream->Read(pv, cbSize, &cbRead);
	if (FAILED(hr) || cbRead != cbSize)
	{
		Trace(1, "Error: Unable to read file.\n");
		hr = DMUS_E_CANNOTREAD;
	}
	return hr;
}

HRESULT
RiffIter::ReadArrayChunk(
	DWORD cbSize,
	void **ppv,
	int *pcRecords)
{
	// zero the out params
	*ppv = NULL;
	*pcRecords = 0;

	// get the size of the chunk and its records

	UINT cbChunk = size();
	if (cbChunk < sizeof(DWORD))
	{
		assert(false);
		return E_FAIL;
	}

	DWORD cbChunkRecord = 0;
	HRESULT hr = RiffIterReadChunk(*this, &cbChunkRecord);
	if (FAILED(hr))
		return hr;
	cbChunk -= sizeof(DWORD);

	if (cbChunk % cbChunkRecord != 0)
	{
		// array is not divisible by size of records!
		assert(false);
		return E_FAIL;
	}

	UINT cRecords = cbChunk / cbChunkRecord;

	// Get the whole rest of the chunk
	PtrArray<char> sprgChunk = new char[cbChunk];
	if (!sprgChunk)
		return E_OUTOFMEMORY;
	hr = ReadChunk(sprgChunk, cbChunk);
	if (FAILED(hr))
		return hr;

	// Return the chunk and its info.

	if (cbChunkRecord == cbSize)
	{
		// Great!  Return the chunk as is.
		*ppv = sprgChunk.disown();
	}
	else
	{
		// make an array of the requested size
		char *pArray = new char[cbSize * cRecords];
		if (!pArray)
			return E_OUTOFMEMORY;
		ZeroMemory(pArray, cbSize * cRecords);

		// copy each record
		char *pRec = sprgChunk; // iterate reading each record of the chunk
		char *pEnd = pRec + cbChunkRecord * cRecords; // stop before this (nonexistant) record
		char *pOut = pArray; // iterate writing into the array
		while (pRec < pEnd)
		{
			memcpy(pOut, pRec, std::_cpp_min<DWORD>(cbChunkRecord, cbSize));
			pRec += cbChunkRecord;
			pOut += cbSize;
		}
		*ppv = pArray;
	}

	*pcRecords = cRecords;
	return hr;
}

HRESULT RiffIter::FindAndGetEmbeddedObject(
		RiffType t,
		FOURCC idFind,
		HRESULT hrOnNotFound,
		IDirectMusicLoader *pLoader,
		REFCLSID rclsid,
		REFIID riid,
		LPVOID *ppv)
{
	if (validate() || !pLoader || !ppv)
	{
		assert(false);
		return E_FAIL;
	}

	*ppv = NULL;
	MMCKINFO ckLast;
	ZeroMemory(&ckLast, sizeof(ckLast));

	while (*this && (type() != t || id() != idFind))
	{
		ckLast = m_ckChild;
		++*this;
	}

	if (!*this)
		return hrOnNotFound;

	// Ascend in such a way that the stream can be used to find this chunk.
	m_hr = m_pIDMStream->Ascend(&ckLast, 0);
	if (FAILED(m_hr))
		return m_hr;

	// Call GetObject using the stream
	DMUS_OBJECTDESC desc;
	ZeroAndSize(&desc);
	desc.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_STREAM;
	desc.guidClass = rclsid;
	desc.pStream = m_pIStream;
	HRESULT hrLoad = pLoader->GetObject(&desc, riid, ppv);

	// Descend again to leave the stream at the next chunk
	m_ckChild.ckid = 0;
	m_ckChild.fccType = 0;
	m_hr = m_pIDMStream->Descend(&m_ckChild, m_fParent ? &m_ckParent : NULL, 0);

	HRESULT hrDescend = this->hr();
	if (FAILED(hrDescend))
	{
		// Give precedence to reporting failure in the stream even though getting the
		// object succeeded before the failure.
		if (*ppv)
		{
			IUnknown *punk = static_cast<IUnknown *>(*ppv);
			if (punk)
				punk->Release();
			*ppv = NULL;
		}
		return hrDescend;
	}
	else
	{
		return hrLoad;
	}
}

HRESULT
RiffIter::ReadReference(DMUS_OBJECTDESC *pDESC)
{
	HRESULT hr = S_OK;

	assert(this->type() == List && this->id() == DMUS_FOURCC_REF_LIST);

	ZeroAndSize(pDESC);

	for (RiffIter ri = this->Descend(); ri; ++ri)
	{
		switch (ri.id())
		{
			case  DMUS_FOURCC_REF_CHUNK:
				DMUS_IO_REFERENCE ioDMRef;
				hr = SmartRef::RiffIterReadChunk(ri, &ioDMRef);
				if (SUCCEEDED(hr))
				{
					pDESC->guidClass = ioDMRef.guidClassID;
					pDESC->dwValidData |= ioDMRef.dwValidData;
					pDESC->dwValidData |= DMUS_OBJ_CLASS;
				}
				break;

			case DMUS_FOURCC_GUID_CHUNK:
				hr = SmartRef::RiffIterReadChunk(ri, &pDESC->guidObject);
				if (SUCCEEDED(hr))
					pDESC->dwValidData |=  DMUS_OBJ_OBJECT;
				break;

			case DMUS_FOURCC_DATE_CHUNK:
				hr = SmartRef::RiffIterReadChunk(ri, &pDESC->ftDate);
				if (SUCCEEDED(hr))
					pDESC->dwValidData |=  DMUS_OBJ_DATE;
				break;

			case DMUS_FOURCC_NAME_CHUNK:
				hr = SmartRef::RiffIterReadChunk(ri, &pDESC->wszName);
				if (SUCCEEDED(hr))
					pDESC->dwValidData |=  DMUS_OBJ_NAME;
				break;
			
			case DMUS_FOURCC_FILE_CHUNK:
				hr = SmartRef::RiffIterReadChunk(ri, &pDESC->wszFileName);
				if (SUCCEEDED(hr))
					pDESC->dwValidData |=  DMUS_OBJ_FILENAME;
				break;

			case DMUS_FOURCC_CATEGORY_CHUNK:
				hr = SmartRef::RiffIterReadChunk(ri, &pDESC->wszCategory);
				if (SUCCEEDED(hr))
					pDESC->dwValidData |=  DMUS_OBJ_CATEGORY;
				break;

			case DMUS_FOURCC_VERSION_CHUNK:
				DMUS_IO_VERSION ioDMObjVer;
				hr = SmartRef::RiffIterReadChunk(ri, &ioDMObjVer);
				if (SUCCEEDED(hr))
				{
					pDESC->vVersion.dwVersionMS = ioDMObjVer.dwVersionMS;
					pDESC->vVersion.dwVersionLS = ioDMObjVer.dwVersionLS;
					pDESC->dwValidData |= DMUS_OBJ_VERSION;
				}
				else
				{
					hr = E_FAIL;
				}
				break;

			default:
				break;
		}
	}
	return ri.hr();
}

HRESULT RiffIter::LoadObjectInfo(ObjectInfo *pObjInfo, RiffType rtypeStop, FOURCC ridStop)
{
	assert(pObjInfo);
	pObjInfo->Clear();

	HRESULT hr = S_OK;

	if (!(*this))
		return this->hr();

	for ( ; *this; ++(*this))
	{
		RiffType rtype = type();
		FOURCC fcc = id();
		if (rtype == rtypeStop && fcc == ridStop)
			return S_OK;

		if (rtype == SmartRef::RiffIter::Chunk)
		{
			if (fcc == DMUS_FOURCC_GUID_CHUNK)
				hr = SmartRef::RiffIterReadChunk(*this, &pObjInfo->guid);
			else if (fcc == DMUS_FOURCC_VERSION_CHUNK)
				hr = SmartRef::RiffIterReadChunk(*this, &pObjInfo->vVersion);
		}
		else if (rtype == SmartRef::RiffIter::List)
		{
			if (fcc == DMUS_FOURCC_UNFO_LIST)
			{
				RiffIter riUnfo = this->Descend();
				if (!riUnfo)
					return riUnfo.hr();
				if (riUnfo.Find(SmartRef::RiffIter::Chunk, DMUS_FOURCC_UNAM_CHUNK))
				{
					hr = riUnfo.ReadTextTrunc(pObjInfo->wszName, DMUS_MAX_NAME);
					if (FAILED(hr))
						return hr;
				}
			}
		}

		if (FAILED(hr))
			return hr;
	}
	
	Trace(1, "Error: Unable to read file.\n");
	return E_FAIL;
}

HRESULT RiffIter::ReadText(WCHAR **ppwsz)
{
	DWORD dwSize = this->size();
	if (dwSize % 2 != 0)
	{
		assert(false);
		return E_FAIL;
	}
	*ppwsz = new WCHAR[dwSize / 2];
	if (!*ppwsz)
		return E_OUTOFMEMORY;
	HRESULT hr = this->ReadChunk(*ppwsz, dwSize);
	return hr;
}

HRESULT RiffIter::ReadTextTrunc(WCHAR *pwsz, UINT cbBufSize)
{
	DWORD dwSize = this->size();
	if (dwSize % 2 != 0)
	{
		assert(false);
		return E_FAIL;
	}
	HRESULT hr = this->ReadChunk(pwsz, std::min<DWORD>(dwSize, (cbBufSize - 1) * 2));
	pwsz[cbBufSize - 1] = L'\0';
	return hr;
}

RiffIter::RiffIter(const RiffIter &other, MMCKINFO ckParent)
  : m_hr(S_OK),
	m_pIStream(other.m_pIStream),
	m_pIDMStream(other.m_pIDMStream),
	m_fParent(true),
	m_ckParent(ckParent)
{
	other.validate();
	ZeroMemory(&m_ckChild, sizeof(m_ckChild));

	m_hr = m_pIDMStream->Descend(&m_ckChild, &m_ckParent, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmloader\container.h ===
// Copyright (c) 1999 Microsoft Corporation
// container.h : Declaration of the CContainer

#ifndef __CONTAINER_H_
#define __CONTAINER_H_
#include "alist.h"
#include "..\shared\dmstrm.h"
#include "..\shared\dmusicp.h"

class CContainer;
class CContainerItem : public AListItem
{
public:
                        CContainerItem(bool fEmbedded);
                        ~CContainerItem();
    CContainerItem *    GetNext() {return(CContainerItem *)AListItem::GetNext();};
    IDirectMusicObject *m_pObject;
    DWORD               m_dwFlags;
    DMUS_OBJECTDESC     m_Desc;     // Stored description of object.
    bool                m_fEmbedded; // This is an embedded (as opposed to referenced) object.
    WCHAR *             m_pwszAlias;
};

class CContainerItemList : public AList
{
public:
    CContai